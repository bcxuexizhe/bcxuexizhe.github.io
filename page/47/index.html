<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.126.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程学习者的博客">
		<meta property="og:url" content="https://bcxuexizhe.github.io/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="编程学习者">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6c6701fd8ffe53c366da0ba4dddb42d/" rel="bookmark">
			【04】C语言括号匹配问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到土土的博客~🥳🥳🌹🌹🌹
💥个人主页：大耳朵土土垚的博客
💥 所属专栏：C语言系列函数实现
题目描述： 给定一个只包括 ‘(’，’)’，’{’，’}’，’[’，’]’ 的字符串 s ，判断字符串是否有效。 有效字符串需满足：
1.左括号必须用相同类型的右括号闭合。
2.左括号必须以正确的顺序闭合。
3.每个右括号都有一个对应的相同类型的左括号。
也就是说第一个必须为左括号才可以匹配的上，一左一右，相邻的同类型的左右括号可以消掉，最后能消完就行。跟消消乐一样。
示例 1：
输入：s = “()”
输出：true
示例 2：
输入：s = “()[]{}”
输出：true
示例 3：
输入：s = “{()}”
输出：true
输入：s = “{(})”
输出：tfalse
解题思路：上篇博客我们学习了数据结构的栈和队列——大耳朵土土的博客，这道题我们就可以根据栈的特点——后进先出来匹配括号，完成题解。 #define _CRT_SECURE_NO_WARNINGS 1 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;stdbool.h&gt; #include&lt;assert.h&gt; // 支持动态增长的栈 typedef char STDataType; typedef struct Stack { STDataType* a; int top; // 栈顶 int capacity; // 容量 }Stack; // 初始化栈 void StackInit(Stack* ps) { assert(ps); ps-&gt;a = NULL; ps-&gt;capacity = 0; ps-&gt;top = 0;//指向栈顶的下一个数据 //ps-&gt;top = -1; //则指向栈顶数据 } // 检测栈是否为空，如果为空返回true，如果不为空返回false bool StackEmpty(Stack* ps) { assert(ps); /*if (ps-&gt;top == 0) return true; else return false;*/ return ps-&gt;top == 0; } // 入栈 void StackPush(Stack* ps, STDataType data) { assert(ps); //STDataType tmp = ps-&gt;top == ps-&gt;capacity ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6c6701fd8ffe53c366da0ba4dddb42d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4984a711922c9cc64589ad1c3c57b65d/" rel="bookmark">
			使用openai-whisper实现语音转文字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用openai-whisper实现语音转文字 1 安装依赖 1.1 Windows下安装ffmpeg FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。
# ffmpeg官网 https://ffmpeg.org/ # ffmpeg下载地址 https://ffmpeg.org/download.html # 点击下载后会进入github，地址如下 https://github.com/BtbN/FFmpeg-Builds/releases 在官网上选择windows版本
推荐使用ffmpeg-n5.1.4-win64-gpl-5.1.zip 和 ffmpeg-n6.0.1-win64-gpl-6.0.zip这两个版本，因为ffmpeg 5.1.4 和 ffmpeg 6.0.1版本是最新稳定版。
# Auto-Build 2023-11-30的地址 https://github.com/BtbN/FFmpeg-Builds/releases/tag/autobuild-2023-11-30-12-55 # ffmpeg-n5.1.4-win64-gpl-5.1.zip的地址 https://github.com/BtbN/FFmpeg-Builds/releases/download/autobuild-2023-11-30-12-55/ffmpeg-n5.1.4-win64-gpl-5.1.zip # ffmpeg-n6.0.1-win64-gpl-6.0.zip的地址 https://github.com/BtbN/FFmpeg-Builds/releases/download/autobuild-2023-11-30-12-55/ffmpeg-n6.0.1-win64-gpl-6.0.zip 在GitHub上可以选择最新版本，选择ffmpeg-master-latest-win64-gpl.zip；
⚠️​ 如果python程序出现“FileNotFoundError: [WinError 2] 系统找不到指定的文件。”错误时，可能是ffmpeg版本的问题。
将ffmpeg-master-latest-win64-gpl.zip 解压到D盘，名字修改为ffmpeg， 将目录 D:\ffmpeg\bin 添加到环境变量中。
在dos页面查看版本号中输入：ffmpeg.exe -version，出现下面的信息表示安装成功。
1.2 安装openai-whispe # whispe地址 https://github.com/openai/whisper # 安装openai-whisper pip install openai-whisper -i https://pypi.tuna.tsinghua.edu.cn/simple # 安装pydub切割音频，防止音频太长 pip install pydub -i https://pypi.tuna.tsinghua.edu.cn/simple 下载语音，可以直接在浏览器中打开，再下载
wget -c https://paddlespeech.bj.bcebos.com/PaddleAudio/zh.wav wget -c https://paddlespeech.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4984a711922c9cc64589ad1c3c57b65d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/241ad2972a64ea37d3104cff7797ceeb/" rel="bookmark">
			RabbitMQ 部署方式选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		部署模式 RabbitMQ支持多种部署模式，可以根据应用的需求和规模选择适合的模式。以下是一些常见的RabbitMQ部署模式：
单节点模式： 最简单的部署方式，所有的RabbitMQ组件（消息存储、交换机、队列等）都运行在单个节点上。适用于小型应用或者开发和测试环境，但不具备高可用性和容错能力。
集群模式： RabbitMQ集群由多个节点组成，分布在不同的物理服务器上。集群提供高可用性和容错性，其中一个节点出现故障时，其他节点可以继续提供服务。集群模式需要仔细的配置和管理，以确保数据同步和故障转移的正确性。
镜像队列模式： 镜像队列模式是集群模式的一种变体，用于提供队列级别的高可用性。队列的内容被复制到集群中的多个节点上，确保在节点故障时仍然可以访问数据。
仲裁队列模式：仲裁队列模式是镜像队列的替代方案，用于提供队列级别的高可用性。队列内容被复制集群中的多个节点上，通过raft算法保证数据的一致性。使用仲裁队列时，需要保证集群至少有一半以上节点可用。
双机房模式：用于保证在其中一个机房MQ服务不可用时，可以将服务切换到另一个机房，避免单机房故障。该方案对机房间、机房内部网络都有很高要求，否则会有很多可靠性问题。
单机部署模式 单机部署模式是最简单的部署模式，该模式下RabbitMQ不具备高可用性: MQ节点下线后，所有依赖RabbitMQ的服务将无法提供服务。
优点 简单易部署：单节点部署非常简单，不需要复杂的配置或管理。
适用于小型应用：对于小型应用或开发/测试环境，单节点部署足够满足需求。
成本低廉：由于只需部署单个节点，因此硬件和资源需求较低，成本相对较低。
缺点 容错性差：单节点部署的容错性较差，如果节点出现故障，整个系统可能会中断。没有故障转移或冗余机制来保证可用性。
扩展性有限：无法满足大规模应用的需求，无法水平扩展来提高性能和处理能力。
单点故障：由于只有一个节点，所以存在单点故障的风险，一旦节点出现问题，整个消息传递系统将不可用。
无法实现高可用性：缺乏故障转移和冗余机制，因此无法实现高可用性和持久性，消息可能会丢失或不可达。
使用场景 开发环境。
集群模式 普通集群模式下，队列数据节点分布在各节点中，具备较好的负载均衡能力，需要注意：该模式下如果有节点下线则该节点上的队列状态会变成down状态，正在消费队列消息的消费者也将会被下线。
优点 具备负载均衡能力：相比于单点部署模式，普通集群模式下，不同队列的消息生产者和消费者可以连接到不通过节点，节点之间通过内部代理的方式将消息发送请求和消费请求转发到内部数据节点。
可用性相比于单点模式有增强：单个节点进程不可用后，只要队列数据不可用的节点不是队列数据所在节点，则队列可用性不受影响。
缺点 队列数据缺少副本，队列数据所在节点不可用后， 和队列相关的消息将不会进入队列，队列中的消息将无法消费。
使用场景 对性能要求较高，但是对队列可用性较低的场景。
镜像队列模式 镜像集群模式下，非临时队列会有多个副本（分master副本和slave副本）分散在各节点下，单个节点下线不影响整体可用性。镜像队列内部采用可靠组播方式来保证集群内各副本数据的一致，对网络稳定性有很高要求。需要注意的是：启用了镜像模式后，消息需要在多个节点之间同步，性能相对单节点或者普通节点而言会有降低，且镜像队列副本数越多性能损失越大。
优点 相比于普通集群，镜像队列支持队列级别的高可用，部分节点出现不可用故障不会影响队列整体的可用性。
可通过任意一个节点将数据复制到镜像队列副本，客户端无序关心队列master节点位置。
缺点 数据通过可靠性组播方式来完成镜像队列副本数据同步，效率低下，对性能影响较大。
镜像队列副本不支持增量数据同步， 同步时会删除本地数据全量从master副本所在节点拉取数据，拉取数据过程中，集群不可用。
受网络稳定性影响较大，分区恢复过程中不稳定的网络环境容易导致队列crash并进一步引发消费者掉线、消息发送阻塞等现象。
RabbitMQ官方已不在维护，计划在4.0版本中删除镜像队列。
使用场景 在MQ 版本低于3.8的版本中推荐使用， 镜像队列是3.8版本之前版本中唯一支持高可用的方案， 为了减少网络分区导致的各种问题，建议使用3节点 + pause_minority模式。
仲裁队列模式 仲裁队列是RabbitMQ官方支持的新一代高可用队列，内部采用Raft算法实现，队列副本也会分leader角色和follow角色，只要一半以上节点可用集群即可用，其在高可用和性能之间做了很好的平衡。
优点 相比于镜像队列，仲裁队列在一致性算法上做了升级，换成了raft算法，节点同步的容错能力明显增强：只需要一半以上的节点完成同步确认即可认为成功。
相比于镜像队列需要全量同步情况，仲裁也做了优化：支持增量同步，并且同步过程中并不会导致整个集群不可用。
相比于镜像队里，不存在队列副本之间的分区问题。
缺点 低于3.8的版本中不支持仲裁队列
要求集群节点为奇数，部分特性，如优先级不支持，部分特性如ttl，长度限制需要3.10版本支持。
使用场景 新环境对接使用3.10以上版本RabbitMQ 包含3个节点的仲裁队列集群。
双机房模式 多机房部署RabbitMq集群，防止因单机房出问题到时服务不可用。
优点 相比于普通的单机房镜像队列集群，双机房模式下， 可以避免集群出现单机房故障引发的整个集群不可用问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/241ad2972a64ea37d3104cff7797ceeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5a3e20021aca9d2677b38028db06196/" rel="bookmark">
			【Vue3】解锁Vue3黑科技：探索接口、泛型和自定义类型的前端奇迹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💗💗💗欢迎来到我的博客，你将找到有关如何使用技术解决问题的文章，也会找到某个技术的学习路线。无论你是何种职业，我都希望我的博客对你有所帮助。最后不要忘记订阅我的博客以获取最新文章，也欢迎在文章下方留下你的评论和反馈。我期待着与你分享知识、互相学习和建立一个积极的社区。谢谢你的光临，让我们一起踏上这个知识之旅！
文章目录 🍋介绍🍋接口🍋泛型🍋自定义类型🍋接口、泛型、自定义相对比🍋结论 🍋介绍 在Vue3中，我们不仅可以利用其强大的响应式系统和组件化开发来构建灵活的前端应用程序，还可以利用TypeScript(简称TS)的特性来增强代码的可读性、可维护性和类型安全性。在本文中，我们将深入探讨Vue3中接口、泛型和自定义类型的使用，以便更好地利用这些功能来构建优秀的Vue应用
🍋接口 首先我们介绍一下接口
接口在Vue3中是一种定义对象结构的方式，它可以用来描述对象的形状，包括属性和方法。通过接口，我们可以明确指定组件的props、data等属性的类型，从而在编译时捕获潜在的错误
老样子，我们准备初始代码
&lt;template&gt; &lt;div class="person"&gt; Python &lt;/div&gt; &lt;/template&gt; &lt;script lang="ts" setup name="Person11"&gt; let person = {id:'1515',name:'馒头',age:22} &lt;/script&gt; &lt;style scoped&gt; .person { background-color: skyblue; box-shadow: 0 0 10px; border-radius: 10px; padding: 20px; } button { margin: 0 5px; } &lt;/style&gt; 上面的代码在页面中仅仅显示了Python
如果我们写代码的时候，对于有些数据写错了但是又仅仅是失误造成的，这样是不会给我们进行错误提示的，这样就需要我们使用接口了
首先我们需要创建一个文件夹并创建index.ts文件，这样创建的好处是引入路径更方便
接下来我们定义一个接口，目的是为了限制Person对象的具体属性
export interface PersonInter { id:string, name:string, age:number` let personList = [ {id:'a',name:'大馒头',age:18}, {id:'b',name:'中馒头',age:19}, {id:'c',name:'小馒头',age:20} ]` } 接下来我们进行导入
import {type PersonInter} from '@/types' 同时我们进行定义，目的是让Person符合这个PersonInter接口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5a3e20021aca9d2677b38028db06196/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c90ee46f638d9c125cea29577ff08e53/" rel="bookmark">
			python中的鸡兔同笼问题,鸡兔同笼python多种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要介绍了python中的鸡兔同笼问题，具有一定借鉴价值，需要的朋友可以参考下。希望大家阅读完这篇文章后大有收获，下面让小编带着大家一起了解一下。
a 为头的个数, b 为脚的个数, x 为鸡的个数， y 为兔的个数
方法一
已知头和腿的个数
a = 120 b = 350 for x in range(1, a): y = a - x if 2 * x + 4 * y == b: print("鸡有" + str(x) + "只，兔有" + str(y) + "只。") 运行结果
鸡有65只，兔有55只怎么样用python绘制满天星。 方法二
输入头和脚的个数
函数调用
def app(a, b): x = (4 * a - b) / 2 if a != 0 and (4 * a - b) % (x * 2) == 0: y = a - x if x &lt; 0 or y &lt; 0: print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c90ee46f638d9c125cea29577ff08e53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc915094c4624c30e01314fd8f453dac/" rel="bookmark">
			Spring Boot如何彻底解决跨域问题，五种方案来看看吧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是跨域
二、为什么会跨域
三、如何解决跨域问题
四、如何在Spring Boot项目中防止跨域问题
一、什么是跨域 跨域是指在浏览器中，当一个网页的脚本试图去访问另一个网页的资源时，如果这两个网页的域名、协议或端口不一致，就会发生跨域问题。
浏览器出于安全考虑，实施了同源策略，即限制不同源之间的交互。同源是指两个页面具有相同的协议、主机和端口号，跨域问题通常发生在以下情况。
不同子域之间的跨域访问，例如a.example.com和b.example.com之间的通信。不同域名之间的跨域访问，例如example.com和example.net之间的通信。使用不同协议进行通信，例如http和https之间的通信。不同端口之间的跨域访问，例如example.com:8080和example.com:8888之间的通信。 为了解决跨域问题，可以通过以下方法进行处理。
JSONP：利用script标签的src属性不受同源策略限制的特点，通过动态创建script标签来加载远程脚本，并在返回的脚本中调用回调函数来获取数据。
CORS（跨域资源共享）：在服务端设置响应头，允许指定的域名进行跨域访问。
代理服务器：在同一个域名下设置一个代理服务器，将跨域请求转发到目标服务器，再将结果返回给浏览器。
WebSocket：使用WebSocket协议进行通信，WebSocket不受同源策略的限制。
虽然有这些方法可以解决跨域问题，但在使用时要注意安全性和合规性，并避免滥用跨域权限。
二、为什么会跨域 跨域问题是出于浏览器的安全策略考虑而存在的。跨域问题是由同源策略（Same-Origin Policy）引起的。
同源策略是浏览器的一种安全机制，它限制了一个网页中的脚本只能与同源网址下的资源进行交互。同源指的是两个页面具有相同的协议、主机和端口号。
同源策略的存在是为了防止恶意网站通过脚本访问用户的敏感数据，保护用户的隐私安全。如果同源策略不存在，那么恶意网站就可以通过脚本获取其他网站的数据，进行恶意操作。
所以，当一个网页的脚本试图去访问另一个网页的资源时，如果这两个网页的域名、协议或端口不一致，就会发生跨域问题，浏览器会拦截这次跨域请求，阻止脚本获取跨域资源。
需要注意的是，跨域是发生在浏览器端的限制，对于服务器端并没有限制。服务器端可以正常响应跨域请求，但浏览器拦截了响应，不允许脚本获取跨域的响应数据。所以，要解决跨域问题，需要在客户端采取一些特殊的处理方式，比如使用JSONP、CORS等技术手段。
三、如何解决跨域问题 JSONP（JSON with Padding）：JSONP是一种利用script标签的src属性不受同源策略限制的特点来进行跨域数据传输的方法。通过动态创建script标签，并指定src属性为跨域请求的URL，服务器返回的数据会被包裹在回调函数中，通过执行回调函数来获取数据。
CORS（跨域资源共享）：CORS是一种标准的跨域解决方案，它通过在服务器端设置响应头来允许指定的域名进行跨域访问。在服务器端设置Access-Control-Allow-Origin字段，指定允许的域名或通配符（*）来解决跨域问题。
代理服务器：可以在同源的情况下，设置一个代理服务器，将跨域请求转发到目标服务器，再将结果返回给浏览器。客户端通过访问同源的代理服务器来避免跨域问题。
WebSocket：WebSocket是一种全双工通信协议，不受同源策略的限制，可以在不同域名间进行跨域通信。
postMessage：使用HTML5中的postMessage方法，可以实现不同窗口（甚至不同域名）之间的跨域通信。
四、如何在Spring Boot项目中防止跨域问题 在Spring Boot项目中可以通过配置来解决跨域问题，在Spring Boot的配置类中添加一个跨域配置的Bean。
@Configuration public class CorsConfiguration { @Bean public WebMvcConfigurer corsConfigurer() { return new WebMvcConfigurer() { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping("/**") .allowedOrigins("*") // 允许所有源访问，可以指定具体的源 .allowedMethods("GET", "POST", "PUT", "DELETE") // 允许的请求方法 .allowedHeaders("*") // 允许所有请求头 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc915094c4624c30e01314fd8f453dac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e594d6ae99d5e84d607bd80842014b6/" rel="bookmark">
			大数据毕业设计Python&#43;Spark高速公路车流量预测可视化分析 智慧城市交通大数据 交通流量预测 交通爬虫 地铁客流量分析 深度学习 计算机毕业设计 知识图谱 深度学习 人工智能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是一个简单的示例代码，演示如何使用 Python 中的机器学习模型（使用 Scikit-learn）来预测高速公路的车流量。在这个示例中，我们将使用线性回归模型进行预测。
import numpy as np from sklearn.linear_model import LinearRegression from sklearn.model_selection import train_test_split from sklearn.metrics import mean_squared_error # 模拟一些车流量数据（特征：时间、天气；标签：车流量） X = np.array([[6, 1], [7, 0], [8, 1], [9, 0], [10, 1]]) y = np.array([100, 120, 110, 130, 105]) # 划分训练集和测试集 X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # 构建线性回归模型 model = LinearRegression() # 训练模型 model.fit(X_train, y_train) # 在测试集上进行预测 predictions = model.predict(X_test) mse = mean_squared_error(y_test, predictions) print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e594d6ae99d5e84d607bd80842014b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8da72350e9182829af210831fa07e9f/" rel="bookmark">
			VSCode上搭建C/C&#43;&#43;开发环境（vscode配置c/c&#43;&#43;环境）Windows系统---保姆级教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言+劝退 VSCode，全称为Visual Studio Code，是由微软开发的一款轻量级，跨平台的代码编辑器。大家能来搜用VSCode配置c/c++，想必也知道VSCode的强大，可以手握一个VSCode同时编写如C，C++，C#，Java，python等等语言的代码。得益于在VSCode上可以下载很多不同种类的插件，可以给vscode添加很多扩展功能，如代码高亮美化，代码补全和代码检查等。
在今天的内容开始之前，我想先劝退一波。
如果你是刚刚接触编程或是使用计算机并不熟练，我强烈建议：
不要碰VSCode！！！
不要碰VSCode！！！
不要碰VSCode！！！
VSCode的环境配置和文件操作相比于直接下载集成开发环境，对于初学者实在是一种灾难。
要学习C/C++，可以去下一个Visual Studio，如果嫌占内存太大，不写什么大工程，可以去下一个Dev-C++
要写Java，去找IntelliJ IDEA
要写python，去找pycharm
总之，初学者建议先熟悉下计算机和编程再来搞VSCode，当初还是小白的我弄了个VSCode的就开始配环境，后期一大堆非程序问题搞得不得不下个集成的环境再学。
能看到这里，说明你已经下定了学习如何在VSCode上写C/C++代码的决心，那么现在就开始我们的内容吧！
VSCode的下载和安装 下载vscode直接去搜就可以，这里我附上一个下载链接吧
Visual Studio Code - Code Editing. Redefined
这里根据自己的电脑系统选择，我的电脑是windows系统，选择stable版
应用商城里面自带的vscode其实也是可下的
下好之后，我们打开安装包，开始安装
这里下一步其实没什么可说的，路径那里放到哪都无所谓
下面这个界面注意一下，都选上
最后就是安装完成了
在打开VSCode之后，你会发现，里面都是英文，那是因为你还没安装中文插件
在组件里，搜索Chinese，下载最上面那个
右下角会弹出这样一个框
当你点Restart重启后就已经是熟悉的中文啦！
VSCode配置C/C++开发环境 安装MinGW VSCode安装好之后，我们还是要了解到，VSCode毕竟是一个高级的编辑器，只能用来写C/C++代码，不能直接编译代码。所以，如果我们要能使用VSCode搭建C/C++的编译和调试环境，还必须要有编译器。为了方便，我们使用MinGW-w64，MinGW-w64是移植到windows平台的一个gcc编译器，用起来很方便。
下载MinGW-w64的话，下面是下载地址
MinGW下载地址
在这个界面，不要直接点下载，先往下拖动，建议下载这个
点击之后，正常情况下，就应该开始正常下载了。
MinGW-w64下载好之后，需要先解压缩
最后会解压出一个文件夹，建议将文件夹放到一个容易管理的地方，这里我放到C盘的根目录下
C:\mingw64
配置MinGw 在windows电脑上，按win+s快捷键，或者直接在搜索框中搜：环境变量，就可以看到：
点击环境变量
找到系统变量中path路径，点击打开
在最后添加上C:\mingw64\bin （放在了不同的路径，只要保证最后是\mingw64\bin就行）这个路径
最后连续点击确定三次层层退出
这样mingw编译器套件基本上就配好了
接下来，我们需要安装一个C/C++插件
我们直接搜索c/c++，选择最上面那个直接安装上就行
安装完之后，重启一下，VSCode配置C/C++环境这一块的工作就算彻底完成。
在VSCode上编写C/C++代码并编译成功 VSCode上写代码首先需要打开文件夹，这样也可以方便管理代码和编译器产生的可执行程序和VSCode生成的配置文件（总之就是很有好处）。在写代码前，先要考虑好把代码放在什么地方管理。
这里我创建一个名字叫test_vscode的文件夹，在我的C根目录当中
我们要保证创建的文件夹中的路径是没有中文名的，不然后续会有一系列问题，就比如调试莫名报错之类
用中文名调试时的报错（其中马赛克位置是中文）：
用VSCode打开此文件夹
然后文件夹就被顺利打开了 编写C/C++代码 编译当前代单个文件代码 在我们编译代码前需要创建下图黄框内的两个文件
第一个文件的创建方式，在中间搜索框打&gt;，然后找C/C++编译配置
这里进到这样一个界面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8da72350e9182829af210831fa07e9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c9f02d1d39fd8290289ae1577e245aa/" rel="bookmark">
			用GGUF和Llama.cpp量化Llama模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用GGUF和Llama .cpp量化Llama模型 什么是GGML如何用GGML量化llm使用GGML进行量化NF4 vs. GGML vs. GPTQ结论 由于大型语言模型（LLMS）的庞大规模，量化已成为有效运行它们的必要技术。通过降低其权重的精度，您可以节省内存并加快推理，同时保留大部分模型性能。最近，8-bit和4-bit量化解锁了在消费者硬件上运行LLM的可能性。加上Llama模型和参数有效技术以微调它们（Lora，Qlora）的释放，这创建了一个丰富的本地LLM生态系统，该生态系统现在正在与OpenAI的GPT-3.5和GPT-4竞争。
目前，主要有三种量化技术：NF4、GPTQ和GGML。NF4是QLoRA使用的静态方法，用于以4位精度加载模型以执行微调。在上一篇文章中，我们探讨了GPTQ方法，并量化了我们自己的模型，以便在消费者GPU上运行它。在本文中，我们将介绍GGML技术，了解如何量化Llama模型，并提供实现最佳结果的提示和技巧。
什么是GGML GGML是一个专注于机器学习的C语言库。它是由Georgi Gerganov创建的，这是GG的首字母缩写。这个库不仅提供了机器学习的基本元素，如张量，而且还提供了一种独特的二进制格式来分发llm。
该格式最近更改为GGUF。这种新格式被设计为可扩展的，因此新特性不会破坏与现有模型的兼容性。它还将所有元数据集中在一个文件中，例如特殊 tokens、RoPE缩放参数等。简而言之，它解决了历史上的一些痛点，而且应该经得起未来的考验。欲了解更多信息，您可以在此地址阅读规范。在本文的其余部分，我们将称使用GGUF或以前格式的所有模型为GGML模型。
GGML设计为与Georgi Gerganov创建的Llama.CPP库一起使用。该库用C/C ++编写，以有效地推理 Llama模型。它可以加载GGML型号并将其运行在CPU上。最初，这是与GPTQ模型的主要区别，该模型已加载并在GPU上运行。但是，您现在可以使用Llama.cpp将LLM的一些LLM层卸载到GPU。为了给您一个例子，有35层用于7B参数模型。这大大加快了推理，并使您可以运行不适合VRAM的LLM。
如果您喜欢命令行工具，那么llama.cpp和GGUF支持已经集成到许多gui中，例如oobabooga的文本生成web-ui、koboldcpp、LM Studio或ctransformers。您可以简单地用这些工具加载您的GGML模型，并以类似chatgpt的方式与它们交互。幸运的是，许多量化模型可以直接在Hugging Face Hub 上使用。您很快就会注意到，它们中的大多数都是由LLM社区的知名人物TheBloke量化的。
在下一节中，我们将看到如何量化我们自己的模型并在消费级GPU上运行它们。
如何用GGML量化llm 让我们看一下 thebloke/Llama-2-13b-chat-ggml repo内部的文件。我们可以看到14种不同的GGML模型，与不同类型的量化相对应。他们遵循特定的命名约定：“ Q” +用于存储权重（精度） +特定变体的位数。这是根据TheBloke制作的型号卡的所有可能定量方法及其相应用例的列表：
根据经验，我建议使用Q5_K_M，因为它保留了该型号的大部分性能。另外，如果想节省一些内存，也可以使用 Q4_K_M。一般来说，K_M版本优于 K_S 版本。我不推荐 Q2_K 或 Q3 *版本，因为它们会大大降低模型的性能。
现在我们了解了更多可用的量化类型，让我们看看如何在实际模型中使用它们。您可以在Google Colab上的免费T4 GPU上执行以下代码。第一步包括编译llama.cpp并在Python环境中安装所需的库。
# Install llama.cpp !git clone https://github.com/ggerganov/llama.cpp !cd llama.cpp &amp;&amp; git pull &amp;&amp; make clean &amp;&amp; LLAMA_CUBLAS=1 make !pip install -r llama.cpp/requirements.txt 现在我们可以下载我们的模型。我们将使用本文中的Mlabonne/Evolcodellama-7B进行微调的模型。
MODEL_ID = "mlabonne/EvolCodeLlama-7b" # Download model !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c9f02d1d39fd8290289ae1577e245aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3bf1df76cd0a5681c804006b544fa7d/" rel="bookmark">
			【Linux C | 网络编程】getaddrinfo 函数详解及C语言例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😁博客主页😁：🚀https://blog.csdn.net/wkd_007🚀
🤑博客内容🤑：🍭嵌入式开发、Linux、C语言、C++、数据结构、音视频🍭
🤣本文内容🤣：🍭介绍 getaddrinfo 函数 🍭
😎金句分享😎：🍭你不能选择最好的，但最好的会来选择你——泰戈尔🍭
⏰发布时间⏰：2024-03-01 14:15:54
本文未经允许，不得转发！！！
目录 🎄一、概述🎄二、getaddrinfo 函数✨2.1 getaddrinfo 函数介绍✨2.2 struct addrinfo 结构体说明 🎄三、gai_strerror、freeaddrinfo 函数✨3.1 gai_strerror 函数介绍✨3.2 freeaddrinfo 函数介绍 🎄四、getaddrinfo 函数使用例子🎄五、总结 🎄一、概述 前面介绍过域名和IP地址之间转换的两个函数：gethostbyname和gethostbyaddr，但是这两个函数仅仅支持IPv4。本文再介绍一个可支持 IPv4 和 IPv6 的函数getaddrinfo，该函数可以处理名字到地址以及服务到端口这两种转换。
🎄二、getaddrinfo 函数 ✨2.1 getaddrinfo 函数介绍 1、函数原型：
#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netdb.h&gt; int getaddrinfo(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res); void freeaddrinfo(struct addrinfo *res); const char *gai_strerror(int errcode); 2、函数描述：
getaddrinfo函数根据给定的主机名和服务名，返回一个struct addrinfo结构链表，每个struct addrinfo结构都包含一个互联网地址。getaddrinfo函数将gethostbyname和getservbyname函数提供的功能组合到一个接口中，但与后一个函数不同，getaddrinfo是可重入的，可支持IPv4、IPv6。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3bf1df76cd0a5681c804006b544fa7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5cbfc5332b869119a4122da77d7b1b7/" rel="bookmark">
			【提效指南】怎样利用AIGC提高自己的工作效率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在的AIGC如火如荼，国内外的应用也如雨后春笋般出现在我们视线里。
曾经有一段时间，很多人都说AIGC会淘汰很多打工人，背后反应出的就是工作提效。只不过这个价值是作用于企业家还是打工人。
下面，我们先谈一下AIGC的基本能力，AIGC的优势，然后从一个岗位的角度，剖析怎样利用AIGC提高工作效率的落地方案及关键点。
AIGC/ChatGPT的基本能力 AIGC/ChatGPT的能力主要表现在跨模态上，目前主要有以下几个类型：
文生文:从文本输入生成新的文本输出,如文本翻译、文本摘要、创作小说等。
文生图:从文本描述生成相应的图像,如“一只小猫咪”可以生成一只可爱猫咪的图像。
文生视频:从文本描述生成视频,如生成做饭过程的教学视频。
文生代码:从功能描述文本生成代码,如生成完成指定功能的Python代码。
图生文:从图像生成对图像内容的文本描述,如为图片加上文字说明。
图生图:输入图像,输出样式不同的图像,如实现图片转素描、线条图等效果。
图生视频:从静态图像生成视频,如为人物图像生成说话的视频。
视频生文:为视频生成文本描述,自动添加字幕或生成视频内容总结。
对机器人的控制。
AIGC/ChatGPT的优势 网上总结的优势有很多，技术流的比较多，我用能听懂的话提炼总结一下：
用平时和别人说话的方式和它交流，它大多数都能听得懂，如果觉得听不懂，可以让它总结一下或多点耐心教教它；
它在文字的扩写、改写、总结方面表现尤其出色；
它有很好的文字逻辑能力（不是数学推理能力哈），所以很适合做大纲；
它有很好的扩散思维，我们总是需要头脑风暴，把一件事的方方面面都考虑到，但是总有遗漏，如果让AIGC/GPT来协助我们，常常会给我们意外的惊喜；
它可以忽视语言的障碍，你只要使用熟练的语言，就可以获取其他语言的信息，并且直接翻译过来；
它虽然达不到专家的水平，但是做到一个行业的中等水平，没有问题，比如画画；
它可以随时切换成任何行业的角色，如律师、心理咨询师、医生，为你提供较准确的信息；
它还有更加广阔的想象空间。
提效落地的思路 明确行业、岗位、能力级别
把相应的工作细化到最为细致不可拆分
从耗费的时长和难度，挑选性价比最高的AIGC替代方案
整合
熟悉操作
案例：软件产品经理 1.明确行业、岗位、能力级别 软件行业，中级产品经理岗
2.把相应的工作细化到最为细致不可拆分 基于FJA职能工作分析法，中级产品经理的工作内容为：
一、计划性工作
1.确定产品定位与规划产品路线图
分析市场及用户需求,明确产品定位制定产品愿景,规划产品功能路线图 2.制定具体的产品规划及实现计划
根据路线图,拟定详细的版本计划明确每个版本的具体功能及实现计划 二、组织性工作
1.组织跨部门团队进行需求评审和产品设计
召集相关部门成员进行需求评审领导产品设计团队的具体设计工作 2.明确各部门的责任,组织产品开发
指导研发团队的具体开发任务配合设计团队进行视觉设计工作 三、指挥性工作
1.跟踪产品计划进度,解决实施中问题
定期检查产品开发进度协调各方资源,解决实施过程中的问题 2.督促各部门工作,确保产品质量
检查各部门工作产出的质量推进产品质量的改进与优化 四、控制性工作
1.监控核心业务指标,评估产品运营效果
设立数据追踪,监控产品运营指标根据数据评估产品效果,找出需优化方面 2.收集用户反馈,提出产品迭代建议
组织开展用户调查,收集用户反馈将反馈转化为产品优化建议 3.总结产品发布后的改进经验教训
对每次发布进行总结,找出改进方向形成问题库,避免重复犯错 五、创新性工作
1.寻找产品创新方向,实现产品差异化
研究行业前沿,寻求产品创新点设计独特功能,实现产品差异化 2.构建良好的用户体验,提升产品核心竞争力
设计人性化、流畅的用户体验不断迭代与优化,提升产品核心竞争力 3.从耗费的时长和难度，挑选性价比最高的AIGC替代方案 4.整合 需要有能力把本行业和本企业专用的知识库内化为AIGC的内容；
满足企业数据安全的需求；
紧跟最新应用，准备替代方案；
设计灵活的架构，并有迅速替代的能力。
5.熟悉操作 有完整的培训，帮助相应岗位的人员，熟练掌握使用技能；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5cbfc5332b869119a4122da77d7b1b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a10c578d9a09cf53bf6116ca5f98d41/" rel="bookmark">
			怎么调用文心一言的api接口生成一个简单的聊天机器人（python代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		寒假在学习大模型，但也没弄出多少眉目，电脑性能还有点小问题，大模型总跑不起来，只会简单调用一下现有的大模型的接口，例如：文心一言，下面展示一下代码：
import tkinter as tk import requests import json #此处需填入自己的API_KEY以及SECRET_KEY API_KEY = "*****" SECRET_KEY = "*******" class ChatBot: def __init__(self, master): self.master = master master.title("Chat Bot") # 创建控件 self.message_input = tk.Entry(master, width=50) self.send_button = tk.Button(master, text="Send", command=self.send_message) self.chat_box = tk.Text(master, width=60, height=20) # 布局控件 self.message_input.pack(side=tk.LEFT, padx=10) self.send_button.pack(side=tk.LEFT) self.chat_box.pack(side=tk.BOTTOM, pady=20) def send_message(self): message = self.message_input.get() self.message_input.delete(0, tk.END) self.chat_box.insert(tk.END, "You: " + message + "\n") response = self.get_response(message) self.chat_box.insert(tk.END, "Bot: " + response + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a10c578d9a09cf53bf6116ca5f98d41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b59157f99cd69ca2c0cd474a04a7d6c7/" rel="bookmark">
			图数据库Neo4j——Neo4j简介、数据结构 &amp; Docker版本的部署安装 &amp; Cypher语句的入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 MySQL是一种开源的关系型数据库管理系统，使用SQL作为其查询语言，常见的关系型数据库有MySQL、Oracle、SQL Server、PostgreSQL等。相关博客文章如下：
【合集】MySQL的入门进阶强化——从 普通人 到 超级赛亚人 的 华丽转身PostgreSQL数据库——Docker版本的postgres安装 &amp; Navicat连接方式+导入向导使用 &amp; SpringBoot结合Jpa使用PostgreSQL初步 还有就是非关系型数据库，也称为NoSQL数据库，它不使用表格来存储数据，而是使用键值对、文档、图形等方式来存储数据。常见的非关系型数据库有MongoDB、Redis、Cassandra等。相关博客文章如下：
【合集】Redis——Redis的入门到进阶 &amp; 结合实际场景的Redis的应用
此外，还有一种图数据库，图形数据库是专门用于存储图形数据的数据库，它使用图形模型来存储数据，并且支持复杂的图形查询。常见的图形数据库有Neo4j、OrientDB等。
本篇博客介绍Neo4j图数据库，Neo4j是用Java实现的开源NoSQL图数据库，本篇博客介绍docker版本的安装，Neo4j的数据结构，基本的创建、查询的Cypher语句。
目录 前言引出Neo4j什么是Neo4j？部署安装数据结构 Cypher入门创建数据删除数据查询语句按照转运次数最少按照费用最少 附录：构造数据 总结 引出 1.Neo4j是用Java实现的开源NoSQL图数据库;
2.dokcer版本的Neo4j部署安装，数据结构介绍；
3.Cypher是Neo4j的查询语言，创建和查询入门；
Neo4j 什么是Neo4j？ Neo4j是用Java实现的开源NoSQL图数据库。从2003年开始开发，2007年正式发布第一版，其源码托管于GitHtb。Neo4j作为图数据库中的代表产品，已经在众多的行业项目中进行了应用，如：网络管理、软件分析、组织和项目管理、社交项目等方面。
官网：https://neo4j.com/
Neo4j实现了专业数据库级别的图数据模型的存储，提供了完整的数据库特性，包括ACID事务的支持、集群的支持、备份和故障转移等。
Neo4j提供了申明式的查询语言Cypher，它类似于关系型数据库中的SQL语言，其具有表现力丰富、使用简单、查询效率高、高扩展性等特点。
其中，紫色圆圈是【人】数据，橙色圆圈是【电影】数据，表示人与电影之间参演或导演的数据关系。
部署安装 Neo4j支持众多平台的部署安装，如：Windows、Mac、Linux等系统。Neo4j是基于Java平台的，所以部署安装前先保证已经安装了Java虚拟机。
7474是web管理工具的端口，7687是neo4j协议端口进行数据通信
docker run \ -d \ --restart=always \ --name neo4j \ -p 7474:7474 \ -p 7687:7687 \ -v neo4j:/data \ neo4j:4.4.5 查看运行的容器
查看日志
http://119.3.162.127:7474/browser/
首次登录需要修改密码
修改后进入首页
查询语句入门
MATCH (tom:Person {name: "Tom Hanks"})-[:ACTED_IN]-&gt;(tomHanksMovies) RETURN tom,tomHanksMovies 数据结构 节点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b59157f99cd69ca2c0cd474a04a7d6c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fda1b391fa73d7f345b10009b12b558/" rel="bookmark">
			uniapp 安卓、IOS、H5、微信小程序实现PDF在线预览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用uniapp开发移动端时，微信开发者工具里webview能正常打开后端接口返回的pdf文件流。正式发布后，在配置了业务域名和服务器域名的前提下，预览pdf文件却只能看到白屏，因此我猜测微信小程序不能通过webview读取文件流。这个想法有问题的话请大家给与指正。
后来我通过uniapp api将文件下载在临时目录，再调用api打开，实现了微信小程序的预览。但在安卓端会调用安装的WPS打开，如果用户没有安装pdf阅读器，则无法打开，造成了不好的用户体验。因此，手机端我用pdf.js实现在线预览。
苹果IOS直接使用webview预览pdf。
h5我刚开始的时候使用webview无法预览。报错： no enabled plugin supports this MIME type。所以h5也使用pdf.js实现在线预览，但是我遇到cors跨域问题。后来采用blob实现了在线预览。
后端的api接口如下：
/** * @功能：pdf预览 */ @IgnoreAuth @RequestMapping("/pdf/preview/**") public void pdfPreviewIframe(HttpServletRequest request, HttpServletResponse response) { String imgPath = extractPathFromPattern(request); // 其余处理略 InputStream inputStream = null; OutputStream outputStream = null; try { inputStream = MinioUtil.getMinioFile(imgPath); outputStream = response.getOutputStream(); response.setContentType("application/pdf; charset=UTF-8"); byte[] buf = new byte[1024]; int len; while ((len = inputStream.read(buf)) &gt; 0) { outputStream.write(buf, 0, len); } response.flushBuffer(); } catch (Exception e) { log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fda1b391fa73d7f345b10009b12b558/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ed69b1e2d93b6e2664c9031255873d8/" rel="bookmark">
			Amazon CodeWhisperer——AI助力编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Amazon CodeWhisperer简介二、安装Amazon CodeWhisperer2.1 PyCharm环境（一定要2023版本及以上）2.1.1 下载插件2.1.2 注册Amazon账号2.1.3 CodeWhisperer与Amazon Q 2.2 IDEA环境（一定要2023版本及以上）2.2.1 下载插件2.2.2 注册并登录 2.3 Jupyter Lab环境2.3.1 Jupyter Lab与Jupyter notebook2.3.2 安装Jupyter Lab2.3.3 安装amazon-codewhisperer-jupyterlab-ext插件2.3.4 注册并登录2.3.5 安装问题汇总（非常重要！！！） 三、案例演示3.1 Pycharm环境3.1.1 斐波那契数列（使用中文注解）3.1.2 汉诺塔问题（使用英文注解）3.1.3 三层BP神经网络（需人工调参） 3.2 IDEA环境3.2.1 创建Bean对象3.2.2 创建工具类3.2.3 Amazon Q优化代码 3.3 Jupyter Lab环境3.3.1 更改热键/快捷键（必要操作）3.3.2 读取数据3.3.3 空值处理3.3.4 统计描述/绘图 四、总结4.1 快捷键4.2 使用方法 一、Amazon CodeWhisperer简介 善始者繁多，克终者盖寡。
2022年底以ChatGPT为代表的大语言模型（LLMs）技术在各个领域掀起了人工智能浪潮，此后一年多的时间里众多机构和组织相继推出了应用LLMs的产品。大家听过最多的肯定是OpenAI推出的ChatGPT（官网地址），如今公布的最新版本是ChatGPT4.0，众多营销号鼓吹是可以替代普通程序员的存在，本人体验过后感觉确实不错，但是国家在互联网这方面管理太严了，访问起来相当不方便。
除了ChatGPT外其实还有很多优秀的LLMs产品，例如Cusor、tabnine、Amazon CodeWhisperer（亚马逊）、Copilot（微软）、文心一言、讯飞星火等
Amazon CodeWhisperer（官方网址）是亚马逊公司推出的一款用于 IDE 和命令行的 AI 生产力工具。（相信大公司，国内就可访问还是免费！！！当然微软的也很优秀，但是国内网络不能访问而且收费还不低）可以通过插件的方式安装在IDEA、PyCharm、JupyterLab 中（非常人性化），它能识别中文和英文注解并自动生成代码。（功能十分强大）
二、安装Amazon CodeWhisperer 下面介绍在PyCharm、IDEA、Jupyter三种环境中安装AWS，当然也可以直接访问官方文档
2.1 PyCharm环境（一定要2023版本及以上） 2.1.1 下载插件 依次点击“File | Settings | Plugins”，在商店中搜索“AWS Toolkit”下载安装即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ed69b1e2d93b6e2664c9031255873d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0187bcc0c3da369f762656f0eeceb562/" rel="bookmark">
			使用Java和PostGis的全国A级风景区数据入库实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、数据介绍
1、空间数据 2、属性表说明
3、QGIS数据预览 二、PostGIS空间数据库设计
1、空间表结构
三、Java空间入库
1、实体定义
2、数据操作Mapper
3、业务层实现
4、入库
5、数据入库验证
总结
前言 星垂平野阔，月涌大江流”“晴川历历汉阳树，芳草萋萋鹦鹉洲”……祖国的每一寸土地，都饱含着诗情画意。旅行一定是很多朋友的爱好，有人说：“人生至少要有两次冲动：一场奋不顾身的爱情和一段走就走的旅行。”不知道在看博文的朋友，是否也是一位旅行爱好者呢。
随着后疫情时代的到来，许多人又开始踏上旅行。旅游可以放松自己身心，缓解工作和生活方面的压力.旅行的过程中是不需要有任何的心理负担的，可以使人达到一种完全放松的状况.感受最原始的快乐。旅行的时候不仅可以观赏风景，还可以尝美食，住宾馆，听故事，感受全国各地的饮食文化.增长自己的见识，可以看到更多的人.了解更多的民俗文化，看到更多的景色使自己的内心感到充实。旅游可以开阔眼界，观察到丰富的人文景观，了解各地的文化风俗，饮食习惯和宗教信仰，广交朋友。旅游还可以锤炼人的意志，增加人的智慧，尤其是去一些有挑战性的景区游玩，征服一座山，跨过一条河学会一项新技能，都可以使自己变的更加勇敢。
中华大地，旅游景点众多，那我们国家到底有多少旅游景区呢？在前面的很多博文中，我们讲过如何将空间数据进行入库。那么文本将采用Java语言，重点讲述如何将全国A级风景区数据导入到PostGis数据库中，为后续我们进行旅游资源和旅游路线的推荐和展示打下坚实的基础。如果您也是WebGis的爱好者，可以从本文了解空间数据的入库开发方式，知道空间数据库的设计和操作。
一、数据介绍 数据说明，本文下载的数据是朋友分享的2023年全国A级风景区数据。数据大小为36MB左右，数据格式shapfile，下面是数据展示。
1、空间数据 这里我们采用Qgis对空间数据进行导入前查看。其基础信息如下表所示：
序号参数说明1文件格式 ESRI Shapefile
2文件编码 GBK
3元素类型 Point
4坐标参考系 EPSG:4326 - WGS 84 5数据单位度6数据总数 14,847
2、属性表说明 在shp文件中，除了有空间数据的定义，还有属性数据的定义，A级景区shp数据一共有15个字段，详情请看下面的表定义。
序号字段名数据类型长度1 景区名称
String 2542 等级
String2543 所属省份
String2544 地址
String2545 评定时间
String2546 发布时间
String2547 发布链接
String2548 lng_GCJ02（高德经度）
Double189 lat_GCJ02（高德纬度）
Double1810 lng_BD09（百度经度）
Double1811 lat_BD09（百度纬度）
Double1812 lng_WGS84
Double1813 lat_WGS84
Double1814 所属城市
String25415 所属区县
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0187bcc0c3da369f762656f0eeceb562/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0440ab042533fe2e4561f3c009e8b53/" rel="bookmark">
			vite打包解决前端发版后浏览器缓存问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何避免浏览器缓存问题，保证每次发布新版本时浏览器都能加载最新的代码
Vite 构建工具的配置文件 vite.config.js：
import { defineConfig } from 'vite'; import vue from '@vitejs/plugin-vue'; import { resolve } from 'path'; import pkg from './package.json' assert { type: 'json' }; // 时间戳 const timestamp = new Date().getTime(); export default defineConfig({ plugins: [vue()], resolve: { alias: { '@': resolve(__dirname, 'src') // 将@配置为src目录的绝对路径 } }, server: { host: '0.0.0.0', }, build: { rollupOptions: { output: { manualChunks: { vendor: Object.keys(pkg.dependencies), }, chunkFileNames: ({ name }) =&gt; { if (name === 'vendor') { return `assets/js/[name]-[hash].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0440ab042533fe2e4561f3c009e8b53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c22158fdd31f1bf01df03585b51a444c/" rel="bookmark">
			万字长文！AIGC 时代数字图像水印的进展与实践 | 新程序员
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【导读】数字水印是信息安全领域的新技术，用于保护数据的保密性和完整性。传统方法基于信号处理、信息论和密码学原理，分为空域和变换域方法。本文介绍了数字图像水印的发展与实践，包括定义和追求、传统数字水印方法、深度学习水印方法以及生成图像水印方法。文章还讨论了水印提取方案和未来发展趋势，如将水印信息隐藏在生成图像的风格特征中，利用深度学习模型的优势提高水印的不可感知性等。
本文精选自《新程序员 007：大模型时代的开发者》，《新程序员 007》聚焦开发者成长，其间既有图灵奖得主 Joseph Sifakis、前 OpenAI 科学家 Joel Lehman 等高瞻远瞩，又有对于开发者们至关重要的成长路径、工程实践及趟坑经验等，欢迎大家点击订阅年卡。
作者 | 王丙坤
责编 | 王启隆
出品 | 《新程序员》编辑部
数字图像水印定义和追求
无论是基于传统方法还是基于深度学习的数字水印技术，一个完整的数字水印系统的设计一般包括三部分：水印生成、水印嵌入和水印提取[1]。
水印生成 水印信号可以通过多种方式生成，例如利用伪随机序列发生器或混沌系统，亦或是有意义的二值、灰度或彩色图像。通常为了携带更多的版权信息，人们倾向于使用二值图像或灰度图像来表示水印，例如产品序列号或 logo 等。对于有意义的水印序列，为了增强水印信息的安全性并提高其抵抗恶意攻击的能力，可以使用置乱技术对水印进行预处理，以消除水印信息之间的相关性。
水印嵌入 水印嵌入是将水印信息嵌入到载体图像中的过程，它可以通过不同的技术和算法实现。在嵌入的过程中，水印信息被融合进载体图像的特定区域，使其在视觉上不易察觉。嵌入过程如图 1 所示。
图 1 水印嵌入过程
水印提取 水印提取是从载体图像中提取水印信息的过程，它涉及使用特定的算法来从图像中提取已嵌入的水印，这些算法会根据水印嵌入的方式采取相应的措施。水印提取过程如图 2 所示。
图 2 水印提取过程
追求：不可感知性/鲁棒性/容量 数字水印算法有多种评估标准，主要有以下几方面的追求：不可感知性/鲁棒性/容量。
不可感知性 不可感知性指的是载体嵌入水印前后不会引起感知上的明显变化。当评估数字水印算法的不可感知性时，常用的指标是结构相似性指标（SSIM）和峰值信噪比（PSNR）。
SSIM 衡量两幅图像之间的结构相似性，考虑了亮度、对比度和结构三个方面的相似度。其数学表达式为：
而 PSNR（峰值信噪比）则用于衡量图像的质量损失程度，其数学表达式为：
其中，MAX（极限值）是图像的最大可能像素值，MSE（均方误差）代表图像之间的均方误差。
这两个指标常用来评估数字水印算法对图像质量的影响，一般来说，较高的 SSIM 和较高的 PSNR 值表示水印嵌入对图像质量的影响较小，即水印图像的不可感知性较好。
鲁棒性 鲁棒性是指数字水印算法抵抗各种攻击的能力，例如 JPEG 压缩、旋转、剪切、添加噪声等。使用鲁棒性强的水印算法嵌入水印的图像在经历多种攻击后，在提取水印信息时依然有较高的提取成功率。评估鲁棒性常用的指标包括错误率、提取成功率等。
容量 图像水印容量指的是在载体图像中可以隐藏的最大水印信息量。它的大小受多种因素影响，包括载体图像的统计特性、失真限度，以及水印嵌入和提取算法是否能够充分利用载体图像。不同的应用场景对水印容量有着不同的需求和限制。
性能指标之间的关系 数字水印的鲁棒性、不可见性和容量之间存在一种相互制约的关系，这种关系可以通过图 3 进行展示。当三者中的任何一个参数被固定时，剩下的两个参数之间会存在矛盾。举例来说，若水印容量被设定为一定数值，为了提高水印的鲁棒性，可能需要增加水印的嵌入强度，而这样做必然会导致更大的图像失真。同理，若降低水印的嵌入强度以保证较好的图像质量，那么水印的鲁棒性就可能会降低。因此，在设计水印算法时，常常需要在水印鲁棒性、不可见性和容量之间取得一种平衡，根据实际应用需求进行权衡处理。
图 3 水印性能指标之间的关系
传统数字水印方法
概述
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c22158fdd31f1bf01df03585b51a444c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/156a57621116bdc5e18f6f9cfc414bdd/" rel="bookmark">
			【前端】代码警告处理Parsing error: Unexpected token ＜eslint或Parsing error: Unexpected token =eslint
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、报错情况： 二、原因 是由于开发环境与esLint当前的解析功能不兼容。
三、解决方案 1.下载依赖
npm i babel-eslint -S 2.在.eslintrc.js文件加上parse: 'babel-eslint'
module.exports = { parse: 'babel-eslint', parserOptions: { "ecmaVersion": 7, "sourceType": "module" } } 3.我用的babel-eslint版本
"babel-eslint": "^10.1.0" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ffe3708c9fc32f9e163d76eddce12fa/" rel="bookmark">
			Java中的HTTP POST请求详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP POST请求是HTTP协议中的另一种请求方法，通常用于向指定的资源提交数据，以创建或更新资源。与GET请求不同，POST请求会将请求数据包含在请求体中，而不是通过URL参数传递。这使得POST请求特别适合处理大量数据或敏感信息。
在Java中，我们可以使用多种方式发送HTTP POST请求，其中最常用的方法之一是使用java.net.HttpURLConnection类。此外，还有一些流行的第三方库，如Apache HttpClient和OkHttp，它们提供了更强大、更灵活的功能。
使用java.net.HttpURLConnection发送POST请求 下面是一个使用HttpURLConnection发送POST请求的示例：
java复制代码
import java.io.OutputStream; import java.net.HttpURLConnection; import java.net.URL; public class HttpPostExample { public static void main(String[] args) { try { // 创建URL对象 URL url = new URL("http://example.com/resource"); // 打开到URL的连接 HttpURLConnection connection = (HttpURLConnection) url.openConnection(); // 设置请求方法为POST connection.setRequestMethod("POST"); // 设置请求体内容类型 connection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded"); // 设置是否向服务器发送和接收数据 connection.setDoOutput(true); // 获取输出流，用于写入请求数据 OutputStream os = connection.getOutputStream(); // 写入请求数据 在这个例子中，我们首先创建了一个URL对象，然后使用openConnection()方法获取一个HttpURLConnection对象。接着，我们设置请求方法为"POST"，设置请求体的内容类型为application/x-www-form-urlencoded，这通常用于发送表单数据。我们还设置了setDoOutput(true)，以便我们可以向服务器发送数据。
然后，我们获取一个输出流，将请求数据写入该流，并关闭输出流。最后，我们获取服务器的响应码，并处理响应。
在这个例子中，我们使用Apache HttpClient创建了一个HttpClient对象和一个HttpPost对象。我们设置请求的URL，并创建一个StringEntity来包含请求数据。然后，我们将这个实体设置为POST请求的实体，并执行请求。最后，我们处理响应。
使用第三方库的好处是它们提供了更丰富的功能和更好的性能，而且通常更容易使用。选择哪个库取决于你的具体需求和个人偏好。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/46/">«</a>
	<span class="pagination__item pagination__item--current">47/71</span>
	<a class="pagination__item pagination__item--next btn" href="/page/48/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>