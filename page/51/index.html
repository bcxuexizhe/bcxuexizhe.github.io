<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.126.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程学习者的博客">
		<meta property="og:url" content="https://bcxuexizhe.github.io/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="编程学习者">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ffa48f321b297e1f2e0917a67a21251/" rel="bookmark">
			20240202在WIN10下部署faster-whisper
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		20240202在WIN10下部署faster-whisper
2024/2/2 12:15
前提条件，可以通过技术手段上外网！^_
首先你要有一张NVIDIA的显卡，比如我用的PDD拼多多的二手GTX1080显卡。【并且极其可能是矿卡！】800￥
2、请正确安装好NVIDIA最新的545版本的驱动程序和CUDA、cuDNN。
2、安装Torch
3、配置whisper
https://developer.aliyun.com/article/1366662
2023-11-03持续进化，快速转录，Faster-Whisper对视频进行双语字幕转录实践(Python3.10)
https://zhuanlan.zhihu.com/p/664892334
持续进化，快速转录，Faster-Whisper对视频进行双语字幕转录实践(Python3.10)
构建Faster-Whisper转录环境
首先确保本地已经安装好Python3.10版本以上的开发环境，随后克隆项目：
git clone https://github.com/ycyy/faster-whisper-webui.git
进入项目的目录：
cd faster-whisper-webui
安装项目依赖：
pip3 install -r requirements.txt
这里需要注意的是，除了基础依赖，还得再装一下faster-whisper依赖：
pip3 install -r requirements-fasterWhisper.txt
如此，转录速度会更快。
模型的下载和配置
首先在项目的目录建立模型文件夹：
mkdir Models
faster-whisper项目内部已经整合了VAD算法，VAD是一种音频活动检测的算法，它可以准确的把音频中的每一句话分离开来，并且让whisper更精准的定位语音开始和结束的位置。
所有首先需要配置VAD模型：
git clone https://github.com/snakers4/silero-vad
然后将克隆下来的vad模型放入刚刚建立的Models文件夹中即可。
接着下载faster-whisper模型，下载地址：
https://huggingface.co/guillaumekln/faster-whisper-large-v2
这里建议只下载faster-whisper-large-v2模型，也就是大模型的第二版，因为faster-whisper本来就比whisper快，所以使用large模型优势就会更加的明显。
模型放入models文件夹的faster-whisper目录，最终目录结构如下：
models ├─faster-whisper │ ├─large-v2 └─silero-vad ├─examples │ ├─cpp │ ├─microphone_and_webRTC_integration │ └─pyaudio-streaming ├─files └─__pycache__
至此，模型就配置好了。
本地推理进行转录
现在，我们可以试一试faster-whisper的效果了，以「原神」神里绫华日语视频：《谁能拒绝一只蝴蝶忍呢？》为例子，原视频地址：
https://www.bilibili.com/video/BV1fG4y1b74e/
项目根目录运行命令：
python cli.py --model large-v2 --vad silero-vad --language Japanese --output_dir d:/whisper_model d:/Downloads/test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ffa48f321b297e1f2e0917a67a21251/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19600417dd68ce55d2f698cb3f9477f9/" rel="bookmark">
			Python创建字典的八种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.创建空字典
dic = {} type(dic) # &lt;type 'dict'&gt; 2.直接赋值创建
dic = {'spam':1, 'egg':2, 'bar':3} print(dic) # {'bar': 3, 'egg': 2, 'spam': 1} 3.通过关键字dict和关键字参数创建
dic = dict(spam = 1, egg = 2, bar =3) print(dic) # {'bar': 3, 'egg': 2, 'spam': 1} 4.通过二元组列表创建
lis = [('spam', 1), ('egg', 2), ('bar', 3)] dic = dict(lis) print(dic) # {'bar': 3, 'egg': 2, 'spam': 1} 5.dict和zip结合创建
dic = dict(zip('abc', [1, 2, 3])) print(dic) # {'a': 1, 'c': 3, 'b': 2} 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19600417dd68ce55d2f698cb3f9477f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb09ea6208daf16af5184a8cf4e39429/" rel="bookmark">
			SpringCloud-搭建Eureka服务模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在构建分布式微服务体系中，搭建Eureka服务模块是实现服务注册与发现的关键一步。Spring Cloud作为领先的微服务框架，通过Eureka为我们提供了高效的服务治理能力。本文将深入探讨如何使用Spring Cloud，逐步引导读者完成Eureka服务模块的搭建。从基础的Eureka服务配置到测试启动，我们将详细讲解每个步骤，助力开发者快速而准确地搭建出可靠的服务注册中心，为微服务架构的健康运行奠定坚实基础。
一、创建父工程 新建项目 SpringCloudTest。
勾选 spring web
删除多余内容：
pom.xml 新增 packaging 标签
二、创建eurake注册中心 新建模块
模块命名为 euraka-server
勾选 eureka server
修改 eureka-server 模块的 pom.xml，将其中的 parent 标签内容，指向父工程。
parent 标签内容为父工程的 pom.xml 里的内容：
&lt;parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;SpringCloudTest&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; 在父级 pom 中添加该子模块
&lt;modules&gt; &lt;module&gt;eureka-server&lt;/module&gt; &lt;/modules&gt; 子类会继承父类的依赖，可以利用这个特性，精简依赖项配置。
创建 application.yml 配置文件。
#服务端口 server: port: 8081 #服务名称 spring: application: name: eureka-server #eureka地址 eureka: client: service-url: defaultZone: http://127.0.0.1:8081/eureka/ register-with-eureka: false fetch-registry: false 启动类上添加 @EnableEurekaServer 注解
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb09ea6208daf16af5184a8cf4e39429/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15d5765fe9abc2eb7b4757a007bfff7c/" rel="bookmark">
			C&#43;&#43; 动态规划 01背包问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有 N
件物品和一个容量是 V
的背包。每件物品只能使用一次。
第 i
件物品的体积是 vi
，价值是 wi
。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。
输入格式
第一行两个整数， N，V
，用空格隔开，分别表示物品数量和背包容积。
接下来有 N
行，每行两个整数 vi,wi
，用空格隔开，分别表示第 i
件物品的体积和价值。
输出格式
输出一个整数，表示最大价值。
数据范围
0&lt;N,V≤1000
0&lt;vi,wi≤1000
输入样例
4 5
1 2
2 4
3 4
4 5
输出样例：
8
这是一个经典的动态规划问题，称为"01背包问题"。问题描述如下：
有一个容量为 m 的背包，和 n 个物品，每个物品有两个属性：体积 v[i] 和价值 w[i]。要求选择一些物品放入背包中，使得放入的物品的体积总和不超过背包容量，且价值最大。
这里的 f[i][j] 表示前 i 个物品放入容量为 j 的背包中的最大价值。状态转移方程为：
f[i][j]=max⁡(f[i−1][j],f[i−1][j−v[i]]+w[i])f[i][j]=max(f[i−1][j],f[i−1][j−v[i]]+w[i])
其中，第一项 f[i−1][j]f[i−1][j] 表示不选择第 i 个物品，第二项 f[i−1][j−v[i]]+w[i]f[i−1][j−v[i]]+w[i] 表示选择第 i 个物品。选择的条件是当前背包容量 j 大于等于第 i 个物品的体积 v[i]。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15d5765fe9abc2eb7b4757a007bfff7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51433a7b295da62dc70059cf7f83c500/" rel="bookmark">
			【小白向】MAC端VSCode C&#43;&#43;环境配置（超干货、超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：使用环境为 MAC（M2）
其实 VSCode 很早就下载好了，但是因为在配置过程中总是遇到很多坑，搁置了很久，回头捡起遇到报 Error 还是两眼抓瞎，到处翻 blog。为了减少以后的遇坑可能性，整理了这份笔记（支持编译多cpp文件，支持C++11以上的新特性），希望能够帮助小白同学避坑。
分两个版本，本文是详细版本。
版本区别如下：
对于有时间的朋友：请查看详细版本。本着“授人以鱼不如授人以渔”的想法，和大多数的博客不同，此版本里除了详细记录了配置步骤，也基于官方文档拓展了配置文件所对应的功能和参数简介，能够让大家举一反三，后续碰到问题时快速做定位。对于没耐心希望快速解决当前问题的朋友：跳转 TLDR（too long, dont read）版本。只包含教程步骤。 详细版本 前提 安装 Visual Studio CodeVSCode 中安装 C/C++扩展
确保 Clang 已经安装（在终端中输入命令：clang --version 来确认是否安装） 创建你的第一个 HelloWorld 程序 创建工作区（WorkSpace） 打开 VSCode， 创建一个 project 文件夹。
现在，project 就是我们的工作区（WorkSpace）了。当我们继续做完本教程的配置，这个工作区中将出现一个子文件夹.vscode，包含三个文件。
● tasks.json（编译选项设置）
● launch.json（调试选项设置）
● c_cpp_properties.json（编译器路径以及IntelliSense 设置）
创建 HelloWorld 的源代码文件 在 project 文件夹下创建一个 hello.cpp 文件
在 hello.cpp中粘贴以下内容
#include &lt;iostream&gt; using namespace std; int main(){ cout &lt;&lt; "Hello World" &lt;&lt; endl; } Command+S（⌘S）保存该文件，建议在 File &gt; Auto Save 中打开该选项，自动保存。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51433a7b295da62dc70059cf7f83c500/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff0807f04761786579428e61afb6c042/" rel="bookmark">
			【AIGC扫盲】人工智能大模型快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人工智能大模型的技术框架主要有以下几种：
TensorFlow：这是一个由Google Brain团队开发的开源库，用于进行高性能数值计算，特别是用于训练和运行深度学习模型。TensorFlow提供了一种称为计算图的编程模型，它允许用户定义复杂的计算并自动计算梯度。此外，TensorFlow还提供了一组丰富的工具，用于可视化模型的结构和性能。
PyTorch：这是一个由Facebook的AI研究团队开发的开源库，用于进行深度学习和其他形式的机器学习。与TensorFlow相比，PyTorch的设计更加灵活和直观，它允许用户在运行时更改计算图。此外，PyTorch还提供了一种简洁的编程模型，使得代码更容易理解和调试。
Keras：这是一个用于深度学习的高级API，可以运行在TensorFlow、Theano和CNTK等底层引擎之上。Keras的设计理念是提供一种简单和快速的方式来创建和训练深度学习模型，而不需要了解底层的详细实现。
Theano：这是一个用于深度学习的开源库，由蒙特利尔大学的MILA实验室开发。Theano可以自动计算梯度，并提供了一种优化计算图的方式，以提高运行效率。然而，由于TensorFlow和PyTorch的流行，Theano的开发已经在2017年停止。
MXNet：这是一个用于深度学习的开源库，由亚马逊Web服务（AWS）支持。MXNet提供了一种灵活的编程模型，允许用户在运行时更改计算图。此外，MXNet还提供了一种高效的分布式训练方法，可以在多台机器上并行训练模型。
ONNX (Open Neural Network Exchange)：这是一个开放的模型交换格式，允许用户在不同的深度学习框架之间转换模型。ONNX支持大量的深度学习框架，包括PyTorch、TensorFlow、MXNet等。
OpenAI’s GPT Models：OpenAI GPT模型是一种基于Transformer的大型语言模型，用于生成自然语言文本。目前，我使用的是OpenAI的GPT-4模型。
TensorFlow如何使用？ TensorFlow是一个强大的深度学习框架，可以用来创建各种各样的神经网络模型。以下是一个简单的TensorFlow使用示例，该示例显示了如何创建和训练一个用于识别手写数字的简单神经网络（使用MNIST数据集）：
首先，需要导入TensorFlow和其他必要的库：
import tensorflow as tf from tensorflow.keras.datasets import mnist from tensorflow.keras.models import Sequential from tensorflow.keras.layers import Dense, Dropout, Flatten from tensorflow.keras.layers import Conv2D, MaxPooling2D 然后，我们加载MNIST数据集，并对数据进行预处理：
(x_train, y_train), (x_test, y_test) = mnist.load_data() # 将图像数据从 (28, 28) 的数组转换为 (28, 28, 1) 的三维张量 x_train = x_train.reshape(x_train.shape[0], 28, 28, 1) x_test = x_test.reshape(x_test.shape[0], 28, 28, 1) # 将像素值从整数转换为浮点数，并将其归一化到 0-1 的范围 x_train = x_train.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff0807f04761786579428e61afb6c042/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f29252ac7b4d8237456c110e5a813435/" rel="bookmark">
			基于Java在线考试网站系统的设计与实现(Springboot框架) 参考文献
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：黄菊华老师《Vue.js入门与商城开发实战》《微信小程序商城开发》图书作者，CSDN博客专家，在线教育专家，CSDN钻石讲师；专注大学生毕业设计教育和辅导。
所有项目都配有从入门到精通的基础知识视频课程，免费
项目配有对应开发文档、开题报告、任务书、PPT、论文模版等
项目都录了发布和功能操作演示视频；项目的界面和功能都可以定制，包安装运行！！！
如果需要联系我，可以在CSDN网站查询黄菊华老师
在文章末尾可以获取联系方式
李善平. Spring Boot 实战[M]. 北京：人民邮电出版社，2018.杨晓慧. 基于Java语言的在线考试系统研究与设计［D］. 沈阳：东北大学，2013.钟伟. 基于Spring Boot的在线考试系统设计与实现［D］. 北京：北京交通大学，2019.董中华, 蒋友权. 基于Web的在线考试系统设计与实现［J］. 计算机工程，2008，34(17)：3-5.张震, 张晓萍. 基于Web的在线考试系统的设计与实现［J］. 现代计算机，2012，(11)：37-39.张辉, 何国文. 基于Web的在线考试系统的设计与实现［J］. 软件开发与应用，2018，(3)：76-78.张明亮, 陈芳. 基于Spring Boot的在线考试系统设计与实现［J］. 现代计算机，2020，(5)：98-100.王小军. 基于Java的在线考试系统设计与实现［D］. 天津：天津理工大学，2015.刘威, 邓洁. 基于Java的在线考试系统设计与实现［J］. 江西师范大学学报(自然科学版)，2019，43(6)：677-682.刘红, 李庆生. 基于Web的在线考试系统设计与实现［J］. 河北师范大学学报(自然科学版)，2017，41(1)：67-70.杨文娟. 基于Java语言的在线考试系统设计与实现［D］. 长沙：湖南师范大学，2015.董涛, 李力军. 基于Java的在线考试系统设计与实现［J］. 计算机工程与设计，2014，35(1)：262-263.薛云刚, 张博. 基于Spring Boot的在线考试系统设计与实现［J］. 现代计算机(专业版)，2020，(1)：103-105.李晶晶, 陈涛. 基于Web的在线考试系统的设计与实现［J］. 现代计算机(专业版)，2016，(10)：105-107.李文彬, 王忠辉. 基于Java的在线考试系统设计与实现［J］. 电子设计工程，2013，(1)：98-101.沈方南. 基于Java的在线考试系统设计与实现［D］. 上海：上海大学，2018.刘媛, 李晓燕. 基于Java语言的在线考试系统设计与实现［J］. 计算机与数字工程，2016，(2)：104-107.杨强, 刘峰. 基于Web的在线考试系统设计与实现［J］. 现代计算机(专业版)，2011，(8)：143-145.李剑, 陈洁. 基于Java的在线考试系统设计与实现［J］. 现代计算机(专业版)，2017，(8)：113-115.陈倩倩, 陈磊. 基于Java的在线考试系统设计与实现［J］. 现代计算机(专业版)，2013，(7)：95-98. 张峰. Spring Boot实战核心技术［M］. 北京：清华大学出版社，2022.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f29252ac7b4d8237456c110e5a813435/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36175d3304c3d2201e9875d1800f20b0/" rel="bookmark">
			h5页面跳转小程序-----明文URL Scheme
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步 ：配置 1.1 登录微信公众平台 1.2 设置 -&gt; 基本设置 -&gt; 隐私与安全 -&gt; 明文scheme拉起此小程序 -&gt; 配置 1.3 进入配置后，在里面配置允许通过scheme URL进入的小程序路径 ps：多个路径用分号隔开，且路径必须在小程序正式版存在 否则会报：小程序path格式不对，请填正确path。
第二步 ： 跳转 2.1 拼接参数 weixin://dl/business/？appid=*APPID*&amp;path=*PATH*&amp;query=*QUERY*&amp;env_version=*ENV_VERSION*
示例：weixin://dl/business/?appid=wx30617d589d6ed4ca&amp;path=pages/pay/pay&amp;query=mobile=13888888888&amp;env_version=release
注 ：query传参是用 = 号连接
2.2 跳转小程序 window.location.href = "appid=wx30617d589d6ed4ca&amp;path=pages/pay/pay&amp;query=mobile=13888888888&amp;env_version=release" 这样就实现跳转了
------------- 如果觉得有用，帮到了你，麻烦浪费你一秒钟点个赞，谢谢 -------------
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6217433bb8fe03407d83931f9e03147/" rel="bookmark">
			Python 字符串：Python 中的字符串切片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 Python 引入了多种字符串操作方法，允许获取字符串子字符串。其中一个操作称为 Slice。这个运算符非常通用且语法优雅，只需几个参数，就可以从字符串中获取许多子字符串组合。python 编程中的字符串切片就是通过从“开始”索引到“停止”索引切片来从给定字符串中获取子字符串。
切片（） Python 为我们提供了一个方法 slice（），它创建了一个“slice”对象，其中包含一组“start”和“stop”索引和步长值。具体来说，参数是（开始、停止、步进）。
根据 Python 官方关于 python 字符串切片的文档： Slice 有两种不同的实现方式，即 slice 有两种重载方法，每种方法都采用两组不同的参数：
slice（stop） // 起始为 0 &amp; 步长为 1
切片（开始、停止、步进）
start：是必须对其执行切片操作的字符串的起始索引。它确定字符串的切片将从哪里“开始”。stop：是切片的停止索引，'until'必须执行哪个切片操作，即在生成子字符串时排除停止索引。step：这是一个可选参数，用于定义迭代列表时的步骤，即它允许我们跳过元素。 两个 slice（） 实现都返回一个格式为 slice（start， stop， end） 的对象。（检查示例-1）
此返回的对象现在可用于对字符串、列表、元组、集合、字节或范围对象进行切片。
应用：
示例 1 – 使用 slice 对象获取子字符串
s = "Welcome to scaler docs" s1 = slice(6) # takes start as 0 automatically print("s1-obj:", s1) print("s1-res:", s[s1]) s2 = slice(2,8) # using slice(start, end, step) without step print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6217433bb8fe03407d83931f9e03147/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ad2b61ed51c7b462f431f4344ba94e1/" rel="bookmark">
			Spring Boot集成Redisson详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redisson是一个用于Java的分布式和高可用的Java对象的框架，它基于Redis实现。在Spring Boot应用程序中集成Redisson可以帮助我们更轻松地实现分布式锁、分布式对象、分布式集合等功能。本文将介绍如何在Spring Boot项目中集成Redisson，并展示一些基本用法。
添加依赖 在Spring Boot项目中，打开pom.xml文件并添加以下Redisson的Maven依赖：
&lt;!-- redisson --&gt; &lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;3.25.2&lt;/version&gt; &lt;/dependency&gt; 添加配置文件 在application.yml文件中添加Redisson的配置信息：
spring: redisson: # 单机模式 host: 192.168.10.106 port: 6379 # 哨兵模式 sentinel: master: mymaster nodes: 192.168.10.106:6209,192.168.10.106:6219,192.168.10.106:6229 # 集群模式 cluster: 192.168.10.106:6109,192.168.10.106:6119,192.168.10.106:6129 # 密码 password: xj2022 注意： 我们如果只有一个redis客户端的话我们在此处只需要配置一种模式，别的配置信息留空即可，我们会通过配置类优先找 哨兵配置，没有的话再找cluster集群配置，没有的话再找单机配置。
添加配置类 在代码中添加配置类RedissonConfig：
import lombok.extern.slf4j.Slf4j; import org.apache.commons.lang3.StringUtils; import org.redisson.Redisson; import org.redisson.api.RedissonClient; import org.redisson.client.codec.StringCodec; import org.redisson.config.Config; import org.redisson.config.ReadMode; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration @Slf4j public class RedissonConfig { @Value("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ad2b61ed51c7b462f431f4344ba94e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c030280628ba89882fc076af18112a73/" rel="bookmark">
			Android SystemUI 介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是SystemUI
二、SystemUI应用源码
三、学习 SystemUI 的核心组件
四、修改状态与导航栏测试
本篇文章，主要科普的是Android SystemUI ， 下一篇文章我们将介绍如何把Android SystemUI 应用转成Android Studio 工程项目。
一、什么是SystemUI 什么是SystemUI？Android SystemUi是指Android操作系统中的系统用户界面，它是用户与设备交互的界面。 SystemUi提供了状态栏、导航栏、通知中心等重要的用户界面元素，这些元素可以帮助用户快速地访问设备的各种功能和信息。主要模块如下：
1、NavigationBar（导航栏）：NavigationBar是位于屏幕底部的导航界面，提供了返回、主页和最近任务等导航操作的按钮。它使用户能够浏览应用程序和系统功能，如切换应用、返回主屏幕等。
2、StatusBar（状态栏）：StatusBar是Android SystemUI的核心组件之一，位于屏幕顶部。它显示了通知图标、系统图标（如电池、信号强度、时间等）以及其他与系统状态相关的信息。
3、Notification Shade（通知面板）：Notification Shade是一个可下拉的面板，用户可以从任何屏幕位置向下滑动以展开它。它显示了来自各个应用程序的通知，并提供一些快速设置选项，如Wi-Fi、蓝牙、飞行模式等。
4、LockScreen（锁屏界面）：LockScreen是Android设备的初始界面，显示了时间、日期、通知和快捷操作。用户可以在锁屏界面上查看和管理通知，以及执行一些快速操作，如解锁屏幕、调整音量等。
5、Quick Settings（快速设置）：Quick Settings是通知面板中的一部分，提供了一组常用的系统设置选项，用户可以通过快速切换按钮打开或关闭这些选项，例如调整屏幕亮度、打开/关闭无线网络等。
6、SystemUI Tuner（系统UI调节器）：SystemUI Tuner是一个隐藏的设置菜单，允许用户自定义和调整系统UI的某些功能和外观。用户可以通过SystemUI Tuner修改状态栏图标、导航栏按钮、通知行为等。
7、System Bars（系统栏）：系统栏包括StatusBar和NavigationBar，它们作为Android设备的固定元素，提供了对系统功能和导航的访问。系统栏的样式和行为可以根据不同设备和版本进行自定义
版本变化
时间段 系统版本 发展历程
2008年 Android 1.0 Android初始版本没有状态栏，只有应用程序屏幕
2009年 Android 1.5 引入状态栏，但只有通知和电池指示器
2010年 Android 2.3 状态栏加入了快捷设置面板
2011年 Android 4.0 引入了新的状态栏，支持通知和快捷设置面板
2013年 Android 4.4 状态栏和导航栏支持半透明效果
2014年 Android 5.0 引入Material Design，对状态栏和导航栏进行了全面更新
2016年 Android 7.0 引入了快捷应用程序快捷方式，可从状态栏访问
2019年 Android 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c030280628ba89882fc076af18112a73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/780f5bf15f5789e8aecb3ff59d46adad/" rel="bookmark">
			【Kafka】 分区和副本 Partition 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 概述AR、ISR和OSRLEO和HW分区Leader选举分区重新分配自动再均衡修改分区副本分区分配策略RangeAssignorRoundRobinAssignorStickyAssignor自定义分配策略 概述 Kafka 使用主题来组织数据，每个主题被分为若干个分区，每个分区有多个副本。那些副本被保存在broker 上，每个broker 可以保存成百上千个属于不同主题和分区的副本。同组分区的不同副本分布在不同的 Broker 上，保存相同的消息(可能有滞后)。
副本有两种类型：
leader 副本：负责处理读写请求，每个分区都有一个首领副本。为了保证一致性，所有生产者请求和消费者请求都会经过这个副本。follower 副本：follower副本不处理来自客户端的请求，它们唯一的任务就是从leader那里复制消息，保持与首领一致的状态。如果首领发生崩溃，其中的一个跟随者会被提升为新首领。 当集群中的一个broker宕机后系统可以自动故障转移到其他可用的副本上，不会造成数据丢失。
通常，分区比broker多，并且Leader分区在broker之间平均分配。
AR、ISR和OSR 分区的所有副本统称为 AR（Assigned Replicas），其中所有与 leader 副本保持一定同步的副本（包括 leader 副本在内）组成 ISR（In-Sync Replicas），与 leader 同步滞后过多的副本组成 OSR（Out-of-Sync Replicas），由此可见，AR=ISR+OSR。
follower 副本是否与 leader 同步的判断标准取决于 Broker 端参数 replica.lag.time.max.ms(默认为 10 秒)，follower 默认每隔 500ms 向 leader fetch 一次数据，只要一个 Follower 副本落后 Leader 副本的时间不连续超过 10 秒，那么 Kafka 就认为该 Follower 副本与 leader 是同步的。在正常情况下，所有的 follower 副本都应该与 leader 副本保持一定程度的同步，即 AR=ISR，OSR 集合为空。
当 leader 副本所在 Broker 宕机时，Kafka 会借助 ZK 从 follower 副本中选举新的 leader 继续对外提供服务，实现故障的自动转移，保证服务可用。为了使选举的新 leader 和旧 leader 数据尽可能一致，当 leader 副本发生故障时，默认情况下只有在 ISR 集合中的副本才有资格被选举为新的 leader，而在 OSR 集合中的副本则没有任何机会（可通过设置 unclean.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/780f5bf15f5789e8aecb3ff59d46adad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f61931c0206bd258659efbb832e72830/" rel="bookmark">
			Python的logging模块（日志、DEBUG、INFO、WARNING、ERROR、CRITICAL）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 logging 是 Python 标准库中用于记录日志的模块。它提供了一种灵活且可配置的方式来在应用程序中记录各种信息，包括调试信息、警告和错误消息。无论是写框架代码还是业务代码，都离不开日志的记录，它能给我们定位问题带来极大的帮助。
记录日志最简单的方法就是在我们想要记录的地方加上一句 print。在简单的代码中或者小型项目中这么干一点问题都没有。就比如说我之前经常这样写日志：
outputs = model(inputs) print(f"outputs.shape: {outputs.shape}") 这样记录日志当然是可以的，但当我们正式运行模型的时候，随着 for 循环的进行，一味的 print 会占用我们 console 的界面，所以我们会将这句 print 删除 ——我们好像做了一件事儿，但之后还要删了它，怪可惜的😂。
所以我在训练模型的时候也会使用 .txt 文件，如下所示：
with open(f'{args.save_path}/logging.txt', 'a') as file: file.write(f"Epoch [{epoch}/{args.epochs}]" f"Train Loss: {train_loss:.4f}\t" f"Train Acc: {train_accuracy:.4f}" f"Val Loss: {val_loss:.4f}\t" f"Val Acc: {val_accuracy:.4f}\t\t" f"Best Acc: {best_acc:.4f} ({np.argmax(val_accuracy_lst) + 1 if epoch != 1 else epoch})\n") Epoch [1/50]	Train Loss: 1.2728	Train Acc: 0.7058	Val Loss: 1.1853	Val Acc: 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f61931c0206bd258659efbb832e72830/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/396e843eacb96e6691c20ef7b0313808/" rel="bookmark">
			AI决策的解构与实践：初探可解释性技术（XAI）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 随着人工智能（AI）技术在各个领域的广泛应用，解释性人工智能（XAI）的概念备受瞩目。作为开发者，我们深知AI系统的复杂性，以及对于用户和利益相关者来说理解AI决策过程的重要性。本文将深入探讨可解释性AI的定义、重要性，并通过分析XAI在开发者工作中的关键作用，为我们构建更透明和可理解的AI系统提供新的视角。
目录 AI决策的解构与实践：初探可解释性技术（XAI）什么是可解释人工智能可解释性AI的定义与重要性可解释性AI的评估与度量可解释性AI的应用场景金融领域医疗领域自动驾驶和安全领域 可解释性AI的实践经验与案例分析可解释性AI的挑战与难点可解释性AI的未来发展 最后 AI决策的解构与实践：初探可解释性技术（XAI） 什么是可解释人工智能 可解释人工智能（Explainable Artificial Intelligence, XAI）是指智能体以一种可解释、可理解、人机互动的方式，与人工智能系统的使用者、受影响者、决策者、开发者等，达成清晰有效的沟通，以取得人类信任，同时满足监管要求。
可解释性AI的定义与重要性 可解释性AI旨在提高人工智能系统的透明度和可理解性，使人们更好地理解AI的决策过程和原理。
换言之，它追求AI决策背后的逻辑可被人理解，而非像黑盒子一样难以穿透。我们应当认识到可解释性AI的重要性。用户和利益相关者希望了解AI系统为什么做出某些决策，而不仅仅接受其结果。通过建立可解释性AI，我们不仅提高了用户对AI系统的信任，还有助于解决伦理和偏见等问题，使AI更好地服务于人类社会。XAI的研究和应用涵盖了从算法改进、可视化技术到应用场景等多个方面，为解决复杂问题提供了新的思路和方法。
可解释性AI的评估与度量 了解如何评估和度量AI的可解释性对于开发者至关重要。
我们可以引入一系列解释性的度量标准，例如解释性准确性、一致性等指标，来量化模型的可解释性。同时，借鉴像LIME（局部可解释模型解释器）这样的工具，通过生成局部解释来验证模型的决策过程。不同的评估标准和度量方法各有优劣，开发者需要综合考虑实际情况选择合适的工具，以确保对AI系统的可解释性有全面的了解。
可解释性AI的应用场景 XAI的目标是使人工智能系统的决策过程更加透明和可解释。在许多应用中，尤其是涉及到重要的决策（如医疗诊断、贷款批准等）的情况下，用户和利益相关者通常希望了解为什么某个决策被做出，以及系统是如何得出结论的。
传统的机器学习和深度学习模型有时被认为是“黑盒”模型，因为它们的决策过程通常难以理解。XAI的方法旨在提供关于模型内部操作的解释，以帮助用户理解模型的预测或决策。
XAI的技术包括生成解释性文本、可视化模型的关键特征、提供决策的不确定性度量等。通过增加可解释性，XAI有助于提高人们对人工智能系统的信任，并且在一些对解释性要求高的领域，如医疗和法律，XAI也具有重要的应用前景。
金融领域 在金融领域，可解释性AI对于投资决策至关重要。投资者需要了解AI系统如何分析市场数据、评估风险，以及为何提出某项投资建议。透明的决策过程使投资者更加信任AI系统，提高了投资决策的可信度。
医疗领域 在医疗领域，AI系统被广泛应用于辅助医生进行疾病诊断和制定治疗方案。通过XAI，医生可以更清晰地理解AI系统的诊断依据和建议，增强了医生与AI系统的合作效果，提高了医疗决策的准确性。
自动驾驶和安全领域 在自动驾驶和安全领域，AI决策直接关系到车辆行驶的安全性。通过可解释性AI，我们可以追踪和理解自动驾驶系统如何做出决策，尤其是在紧急情况下。这不仅提高了系统的可靠性，还增加了用户对自动驾驶技术的接受度。
在这些场景中，可解释性AI的需求和作用显而易见。用户和相关利益者对于AI决策的可解释性要求更高，而开发者的任务就是通过XAI技术解决实际问题，确保AI系统在各个领域都能发挥最大的价值。
可解释性AI的实践经验与案例分析 在实际应用中，一些行业已经积极探索可解释性AI的实践。在金融领域，一些公司通过可视化展示模型的决策过程，帮助投资者更好地理解AI系统对市场的分析和投资建议。在医疗领域，一些XAI工具已经成功应用于肿瘤诊断，通过清晰的解释帮助医生更好地理解AI系统的诊断建议。这些实践经验为我们提供了宝贵的启示，同时也提示了在实际应用中需要特别关注的问题，例如如何平衡解释性和性能之间的权衡。
可解释性AI的挑战与难点 面对可解释性AI的追求，我们面临诸多挑战。
首先，随着深度学习等复杂模型的应用，模型的复杂性成为一大挑战。这些模型拥有大量参数，难以直观理解其决策过程。其次，数据不确定性是可解释性AI领域的另一个难点。在实时、动态的数据环境中，模型如何解释决策的合理性是一个需要深思熟虑的问题。此外，因果关系的理解也是一个亟待解决的难题。我们需要思考如何让AI系统更好地理解事件之间的因果关系，而不仅仅是捕捉到它们之间的统计相关性。 解决这些挑战需要我们不断创新，从算法到模型设计，全方位提高AI的可解释性。
可解释性AI的未来发展 展望未来，可解释性AI将在技术和应用方面迎来更大的发展。
技术上，我们可以期待更智能、更灵活的可解释性模型的涌现，以适应不断变化的应用场景。在应用方面，XAI将逐渐成为各个行业的标配，其在推动人工智能技术发展、提高用户体验方面的作用将更加凸显。 最后 好看的灵魂千篇一律，有趣的鲲志一百六七！如果觉得文章还不错的话，可以点赞+收藏+关注 支持一下，鲲志的主页 还有很多有趣的文章，欢迎小伙伴们前去点评如果有什么需要改进的地方还请大佬指出❌欢迎学习交流｜商务合作｜共同进步！❤️ kunzhi96 公众号【鲲志说】 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/371758eeca465eaf7465d0dda81f7946/" rel="bookmark">
			轻量化的yolov8部署到安卓Android手机端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、pytorch环境配置和yolov8源码安装 首先在电脑上需要配置好pytorch环境，和yolov8源码的下载
然后针对yolov8做自己的轻量化改进
二、下载Android Studio和ncnn-android-yolov8 1. Android Studio官网链接： 下载 Android Studio 和应用工具 - Android 开发者 | Android Developers
自行配置AS环境和JDK
我参考了下面这两个：
Android Studio 安装配置教程 - Windows(详细版)-CSDN博客Android Studio 开发环境快速搭建（超详细）_配置android 开发环境-CSDN博客
Android Studio 安装配置教程 - Windows(详细版)-CSDN博客 （1）JDK下载： 官网站：https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html
同意协议后，下载相应版本的JDK
（2）配置JDK及JAVA的环境 打开系统环境
打开计算机的属性/高级设置/环境变量/, 配置JAVA_HOME:
变量名：JAVA_HOME
变量值：JDK安装目录（复制jdk的路径，也就是我们前面安装JDK时设置的路径）
具体见那个链接
（3）安装cmake 注意安装的是cmake3.10版本。
手机安卓版本选择相应的安卓版本，我的是荣耀70，直接下载sdk,对应的是安卓14。
（4）出现的问题： 老项目导入可能遇到的问题 Unsupported Java. Your build is currently configured to use Java 17.0.7 and Gradle 5.4.1.
原本这个项目执行不是Java17，本地使用了更高的Java版本，因此同步需要更新gradle。
当然，可以更新gradle,但，这意味着后面有很多需要跟着改的问题。但是只是想运行下项目看下效果，结果还要改一通内容，最终很可能还不知道能否跑起来。
于是，根据条件，可以进行一下操作。
解决方案
可以设置较低的Java版本，以此来迎合Gradle 5.4.1。
——&gt;File——&gt;Project Structure——&gt;SDK location——&gt;Gradle Setting——&gt;Gradle SDK——&gt;选择个1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/371758eeca465eaf7465d0dda81f7946/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0148bb602229e47f78f92500ad792e84/" rel="bookmark">
			zookeeper未授权访问（CVE-2014-0085）漏洞修复建议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境搭建安装docker sudo systemctl start docker 拉取zookeeper镜像
sudo docker pull wurstmeister/zookeeper 启动zookeeper
sudo docker run \ -d \ --restart=always \ --log-driver json-file \ --log-opt max-size=100m \ --log-opt max-file=2 \ --name zookeeper \ -p 2181:2181 \ -v /etc/localtime:/etc/localtime \ wurstmeister/zookeeper 二、进入容器 1.登录服务器执行docker ps查看是zookeeper是否为容器运行，如果不是容器运行请跳到第三步骤
2.使用命令进入容器docker exec -it 容器ID /bin/bash
三.使用find / -name zoo.cfg命令查找文件，看看文件位置 1.进入zookeeper目录找到zoo.cfg文件，常见路径为/opt/zookeeper-3.4.13/conf/zoo.cfg
具体路径以zookeeper安装路径为准
2.使用vi编辑器打开zoo.cfg文件，在文件中添加四字命令白名单，添加命令如下
4lw.commands.whitelist=xxxx,xxxx,xxxx xxxx为需要设置的四字命令，添加多命令请使用逗号进行隔开，请根据系统所需进行命令设置，请勿添加envi命令，如系统有使用此命令的需求请使用其他修复方法
四.配置服务ACL限制IP访问 1.登录zookeeper
要找到zkCli.sh脚本文件，需要定位到Zookeeper的安装目录。在大多数情况下，如果您是按照标准流程安装的Zookeeper，那么该脚本应该位于$ZK_HOME/bin目录下，其中$ZK_HOME代表Zookeeper的安装路径。例如，如果Zookeeper安装在/opt/zookeeper-3.4.9，则脚本将位于/opt/zookeeper-3.4.9/bin目录下。
2.使用下面命令登录zookeeper命令中ip为容器ip如果直接安装在服务器上请使用服务器ip
./zkCli.sh -server 172.17.0.2:2181 3.使用getAcl /查看当前权限（默认所有人可访问）
4.设置权限记得一定要将本机和需要连接的ip添加进去
setAcl / ip:172.0.0.1:cdrwa,ip:192.168.110.241:cdrwa,ip:192.168.100.241:cdrwa,ip:192.168.110.242:cdrwa cdrwa每个参数代表的意思
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0148bb602229e47f78f92500ad792e84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b424ddeafcfd8796f024a24187df2e1a/" rel="bookmark">
			Qt WebEngine模块使用（开发环境安装和程序开发）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Qt WebEngine Qt WebEngine_hitzsf的博客-CSDN博客
Qt WebEngine模块提供了一个Web浏览器引擎，可以轻松地将万维网上的内容嵌入到没有本机Web引擎的平台上的Qt应用程序中。Qt WebEngine提供了用于渲染HTML，XHTML和SVG文档的C ++类和QML类型，它们使用级联样式表（CSS）进行样式设置并使用JavaScript编写脚本。 用户可以通过使用HTML元素上的contenteditable属性，使HTML文档完全可编辑。
1、Qt WebEngine架构 Qt WebEngine中的功能分为以下模块：
Qt WebEngine Widgets，用于创建基于Widget的Web应用程序Qt WebEngine，用于创建基于Qt Quick的Web应用程序Qt WebEngine Core，用于与Chromium交互Qt WebEngine Process模块，页面渲染和JavaScript执行从GUI流程分离到Qt WebEngine Process中。 如果将Qt库捆绑到应用程序中，则该库必须随应用程序一起提供。 2、瑞芯微带Qt WebEngine的SDK编译 详见如下链接
有道云笔记
3、Qt WebEngine 类介绍 Qt QWebEngine 加载网页及交互，实现C++与JS 相互调用_qt5 加载网页-CSDN博客
Qt WebEngine（04）：QWebEngineView 类【官翻】-CSDN博客
4、官方demo程序 下面这两个是比较好的学习示例，simplebrowser是使用的QT Widget，quicknanobrowser是使用的 QT Quick
D:\QT5.12.10\install\Examples\Qt-5.12.10\webenginewidgets\simplebrowser
D:\QT5.12.10\install\Examples\Qt-5.12.10\webengine\quicknanobrowser
二、开发环境安装 QtWebengine模块作为Qt的子模块同样支持跨平台，可以安装在Windows、Linux、MacOS系统上，我这里安装在了windows和Ubuntu下。为了在RK3568平台上运行QT Web程序，所以还需要安装ARM64的交叉编译环境（只支持在Ubuntu下编译）
1、Windows桌面版本 在Windows上，Qt5.12.10版本中的Qt WebEngine仅在MSVC 2017或MSVC2019下可用，所以在按照QT之前，需要先安装VS2017。
注：我这里想选用的5.12.10版本，可以下载安装其他版本的也可以，比如5.12.2，在ubuntu下就是安装的这个版本
1、VS2017环境安装
Visual Studio 2017下载及安装_vs2017下载_枫蓝驿的博客-CSDN博客
2、QT Creator安装
QT下载链接：Index of /archive/qt/5.12/5.12.10
选择安装组件，需要勾选上MSVC2017 和 Qt WebEngine
2、Ubuntu桌面版本 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b424ddeafcfd8796f024a24187df2e1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0ec816c5bdfefe97e78b7ae01402740/" rel="bookmark">
			解析MySQL生产环境CPU使用率过高的排查与解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在生产环境中，MySQL作为一个关键的数据库组件，其性能对整个系统的稳定性至关重要。然而，有时候我们可能会遇到MySQL CPU使用率过高的问题，这可能导致系统性能下降，应用页面访问减慢，甚至影响到用户体验。本文将详细介绍如何排查和解决MySQL CPU过高的问题，帮助您迅速恢复正常的数据库性能。
首先我们要明白什么是CPU使用率：
CPU使用率是指在单位时间内CPU处于非空闲状态的时间比，反映了CPU的繁忙程度。某个进程的CPU使用率就是这个进程在一段时间内占用的CPU时间占总的时间的百分比。比如在双核CPU某个开启多线程的进程1s内占用了CPU0 0.6s, CPU1 0.9s, 那么它的占用率是150%。这里不深入阐述，网上文章很多。
CPU占用过高原因分析 CPU 占用过高常见原因：
服务器硬件问题内存溢出高并发业务中业务设计不合理导致 数据库对象设计不合理表索引设计不合理数据库锁导致，如行锁冲突、行锁等待、锁超时、死锁等系统架构没有缓存中间件读写分离配置不合理未合理升级改造为集群环境MySQL 系统参数设置不合理问题 SQL 导致 SQL 问题导致 CPU 使用率过高是最常见的现象，比如 group by、order by、join 等，这些很大程度影响 SQL 执行效率，从而占用大量的系统资源。
说了这么多常见原因，其实总结一句话来说就是现有系统的现有配置下的现有环境提供不了所需要的数据查询、分析、执行能力，针对这个问题，首先我们要发现问题的所在，就是说我们要准确的定位问题，然后针对问题进行优化，再考虑其他升级改造的事情。
检查MySQL运行情况
可以看到CPU使用率非常高，内存使用较低，可以排除不是内存影响的。而且内存资源还有很大空间。
因此要解决问题，可以从两方面入手：
优化Mysql参数配置，发挥服务器硬件性能，通过合适的参数配置提升Mysql性能（以空间换时间，见效快，成本高）找到问题原因，优化问题sql、添加合理的索引、引入缓存等 方案一：MySQL配置参数优化 查看服务器资源 查看服务器内存：
[java@localhost ~]$ grep MemTotal /proc/meminfo MemTotal: 266419264 kB // 约256G 查看服务器CPU个数：
[java@localhost ~]$ lscpu 架构： aarch64 CPU 运行模式： 64-bit 字节序： Little Endian CPU: 64 在线 CPU 列表： 0-63 每个核的线程数： 1 每个座的核数： 32 座： 2 NUMA 节点： 2 厂商 ID： HiSilicon 型号： 0 型号名称： Kunpeng-920 步进： 0x1 Frequency boost: disabled CPU 最大 MHz： 2600.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0ec816c5bdfefe97e78b7ae01402740/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9290098c111dd4d8e8383fe87643843/" rel="bookmark">
			android APK安装提示“解析错误，解析软件包时出现问题” 解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android APK安装提示“解析错误，解析软件包时出现问题” 解析及优化 1.问题 项目产品在客户端升级的过程中遇到弹窗提示“解析错误，解析软件包时出现问题”，如下图。
2.分析过程 1.该弹窗内容，搜索项目工程代码，并无相关字眼，排除项目代码中的业务。
2.通过APK安装调用代码，可知安装行为，实为系统应用PackageInstaller中的业务
/** * 安装APK * @param file */ public static void installAPK(Context context,File file) { try { Intent intent = new Intent(); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.setAction("android.intent.action.VIEW"); intent.addCategory("android.intent.category.DEFAULT"); intent.setDataAndType(Uri.fromFile(file), "application/vnd.android.package-archive"); context.startActivity(intent); } catch (Exception e) { e.printStackTrace(); } } Packageinstaller清单文件内容，可知上述调用方式实则调用Packageinstaller的PackageInstallerActivity的第一个红色框的隐式调用方法
4.查询解析错误的相关业务
通过查找res/values-zh-rCN的strings.xml文件中“解析软件包时出现问题”文本，确有该内容
通过Parse_error_dlg_text字符串资源，反查生成对话框代码位置
通过DLG_PACKAGE_ERROR查找调用位置，业务调用
showDialogInner(DLG_PACKAGE_ERROR)
显示解析失败对话框，其中有2处调用该方法。
从上图 onCreat() 方法可看出，调用安装程序的Intent携带的scheme内容为“package”，获取APK包信息=null，则调用第一处的解析错误弹窗；否则执行else代码块，获取apk包信息为null，则调用解析错误弹窗。
从项目代码调用安装程序可知，采用android.intent.action.VIEW隐式调用，从packageinstaller清单文件AndroidManifest.xml可知该方式携带scheme=“file”,所以实际是执行第二处的解析错误弹窗。
else代码块中，通过PackageUtil工具类中的 getPackageInfo(sourceFile) 方法获取apk文件包信息，如返回null，则弹出解析错误对话框。
PackageUtil中的 getPackageInfo(sourceFile) 如下，实际执行是调用 PackageParser类中的parseMonolithicPackage(sourceFile, 0) 方法获取安装包的信息。
/** * Utility method to get package information for a given {@link File} */ public static PackageParser.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9290098c111dd4d8e8383fe87643843/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57c8c93934922c72510258d1a3757970/" rel="bookmark">
			JavaScript------常用的输入(input)聚焦方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.定义： 输入聚焦方法：通过设置焦点使用户能够在一个或多个输入字段上进行操作。
聚焦：通过将用户的光标定位到输入字段上，以便用户可以直接在该字段中输入内容或执行其他操作。
2.三种方法： 1.自动聚焦： &lt;input type="text" autofocus /&gt; 或者使用JavaScript代码来实现自动聚焦:
&lt;script&gt; document.getElementById ("myInput").focus; &lt;/script&gt; 注意:自动聚焦可能会打断用户的浏览体验，因此应仔细选择自动聚焦的位置
2.点击聚焦: ①点击聚焦：当用户点击指定的元素时将光标定位到输入字段上。
②通过JavaScript代码来实现，可以为元素添加一个点击事件，并在触发事件时将输入字段聚焦:
&lt;div onclick="document.getElementById('myInput’).focus"&gt;点击此处聚焦输入字段&lt;/div&gt; ③点击聚焦通常用于需要用户主动点击才能开始输入的情况，例如输入框或登录表单。
3.延迟聚焦: ①延迟聚焦：在页面加载后一段时间再将光标聚焦到指定的输入字段上。
②使用JavaScript的setTimeout函数来实现。
例如，可以在页面加载完成后延迟1秒将输入字段聚焦:
&lt;script&gt; setTimeout(function){ document.getElementById("myInput").focus; }, 1000); &lt;/script&gt; 延迟聚焦：可以用于需要给用户留出一些时间来熟悉页面布局后再进行输入的情况。
3.在网页开发中实现输入聚焦: ①在网页开发中，可以使用HTML和JavaScript来实现输入聚焦。
②三种方法：
1. 使用autofocus属性:
&lt;input type="text" autofocus /&gt; 页面加载完成后自动将光标聚焦到输入字段上
2.使用JavaScript：
&lt;input type="text" id="myInput" /&gt; 然后
&lt;script&gt; document.getElementById( "myInput" ).focus; &lt;/script&gt; 页面加载完成后将光标聚焦到id为“myInput”的输入字段上
3.使用事件:
可以使用各种事件来触发输入聚焦，如点击事件、鼠标悬停事件等。
例如，可以为一个元素添加一个点击事件，在触发事件时将输入字段聚焦：
&lt;div onclick="document.getElementById('myInput').focus"&gt;点击此处聚焦输入字段&lt;/div&gt; 用户点击该元素时将光标聚焦到id为“myInput”的输入字段上
总结：
输入聚焦是一种使用户在输入字段上进行操作的方法。可以使用自动聚焦、点击聚焦、延迟聚焦等方法来实现输入聚焦。在网页开发中，可以使用HTML的autofocus属性或JavaScript的focus方法来实现输入聚焦。另外，还可以使用事件来触发输入聚焦，如点击事件、鼠标悬停事件等。输入聚焦可以提高用户的操作效率和用户体验，但也应当谨慎使用，避免干扰用户的浏览体验。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/50/">«</a>
	<span class="pagination__item pagination__item--current">51/71</span>
	<a class="pagination__item pagination__item--next btn" href="/page/52/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>