<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.126.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程学习者的博客">
		<meta property="og:url" content="https://bcxuexizhe.github.io/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="编程学习者">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/291e6e1ef953b6e31fd4c61f16cdd28a/" rel="bookmark">
			Node.js脚手架安装配置、Vue环境搭建以及创建Vue项目 (包括配置环境变量)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本教程所使用的系统为Windows10 LTSC 64位；Node.js版本为18.17.1。 注：截止到2023年09月15日Node.js-18.17.1为长期维护版的最新版本
目录
1 下载Node.js
2 安装Node.js
3 配置Node.js以及环境变量
4 安装Vue
5 创建Vue项目
1 下载Node.js 在Node.js官网下载最新版本的Node.js长期维护版。(根据系统实际情况选择32位或64位，这里选择的是64位的)
官网下载页链接：Node.js官网下载页
2 安装Node.js 2.1 安装包下载完成后，选中单击鼠标右键点击 “安装” ，进入安装页面。如下图所示：
安装页面：
2.2 点击 “Next” 并 勾选 “I accept the terms in License Agreement”，然后继续点击 “Next” 至 “Tools for Native Modules”页面，如下图所示。
注： 安装路径使用默认路径，不要随意修改。不然后续在配置环境变量时可能会出现问题。
2.3 取消 “Automatically install the necessary tools.” 前面的勾，如下图所示，若没有勾选则直接点击“Next”即可。
2.4 点击 “Install”，并等待其安装完成。
2.5 完成后，点击 “Finish” 退出安装页面即可 。
2.6 检查node.js是否安装成功。分别依次输入如下命令：
node -v npm -v 执行完成后，出现如下图所示，说明安装成功。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/291e6e1ef953b6e31fd4c61f16cdd28a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b383582ca83369ac2b7123070524aa01/" rel="bookmark">
			Android抓包工具—Fiddler详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 平时和其他大佬交流时，总会出现这么些话，“抓个包看看就知道哪出问题了”，“抓流量啊，payload都在里面”，“这数据流怎么这么奇怪”。
👉这里出现的名词，其实都是差不多的意思啊，这都跟抓包这个词有关，说到抓包呢我们今天就先来了解一下抓包的一些基础定义跟抓包工具Fiddler的使用跟安装吧。
本篇文章，博主只想使用通俗易懂的话语，让大家明白以下内容：
什么是抓包哪些场景需要用到抓包Fiddler抓包的原理怎样使用Fiddler进行移动端抓包
同时，在这我也准备了一份软件测试视频教程（含接口、自动化、性能等），需要的可以直接在下方观看，或者直接关注VX公众号：互联网杂货铺，免费领取
软件测试视频教程观看处：（Fiddler抓包视频教程从P104开始）
2023最新【软件测试面试300问】面试八股文教程，涵盖自动化测试/接口测试/性能测试/测试开发等内容
抓包 包 (Packet) 是TCP/IP协议通信传输中的数据单位，一般也称“数据包”。
我们平常测试过程中所说的数据包其实就是接口请求的数据，在HTTP请求中，包括请求头信息、请求内容、响应头信息、响应内容。
什么是抓包 用特定的工具获取客户端与服务端之间发送和返回的数据包。目的是分析数据包的协议、内容等，从而判断接口的设计是否符合要求，比如抓包某次请求的请求参数与响应参数，查看参数是否正确。
哪些场景下需要抓包 对于初学者或者没有接触过接口测试的同学而言，可能不太明白做接口测试或者接口自动化测试为什么一定要学会对接口数据进行抓包。
那么在哪些场景下需要抓包获取请求数据呢？
重现bug，需要截取数据定位问题时；判断问题是前端bug还是后端bug时；做接口测试，但开发没有提供接口文档时，需要抓包才能获取接口信息；某个功能场景或者某些功能场景我们不知道调用了哪些接口，或者不知道接口调用的先后顺序时；需要修改返回参数时（用于mock或者别的场景） 在实际测试过程中，用的最多的场景是1、2、3、4。
Fiddler 抓包工具有很多种，如Wireshark、Fiddler、Charlse、Tcpdump、浏览器工具(F12)等，但在软件测试工作中抓包对象一般是HTTP协议的接口，所以最多的是浏览器工具、Fiddler/Charlse。
Fiddler特点简单归纳如下：
Fiddler能抓取客户端和服务器之间的HTTP/HTTPS请求，可以对接口请求设置断点，甚至修改输入输出数据Fiddler只能抓取HTTP/HTTPS协议Fiddler除能对PC端浏览器抓包外，还支持对移动端进行抓包 Fiddler抓包原理 通常，我们使用浏览器浏览网页，或者使用手机上的APP，交互可以使用以下简化的流程图表示：
客户端(PC端或移动端) 向服务端通过发送HTTP请求进行数据交互，而我们的需求是，抓取这个交互过程中的数据。
我们只需要在客户端与服务端之间加上一个中介，让它们之间交互的数据都通过这个中介，中介记录这些通过自身的数据，就能获取到客户端与服务端之间具体的交互数据了。
Fiddler便可以充当这个中介角色，交互流程如下：
启动Fiddler其实就是启动了一台代理web服务器(Proxy)，代理地址为127.0.0.1，端口为8888。只要HTTP请求通过127.0.0.1:8888 (即Fiddler) 进行代理发送与接收，Fiddler就会记录经过自身的HTTP请求数据，便抓取到了HTTP请求的相关数据。
而怎样才能使得HTTP请求都通过127.0.0.1:8888进行代理？Fiddler启动时IE浏览器的代理会自动设置127.0.0.1:8888为代理地址，Chrome、Firefox需要在浏览器中手动修改，移动端则需要在手机里设置。
安装 进入官网下载，地址为：https://www.telerik.com/download/fiddler
需填写内容可填写如下，Windows系统点击【Download for Windows】，点击后会跳转页面并开始下载 (没有的话可以多尝试两次) ，如果没有下载可根据跳转页面提示进行点击。
下载后得到安装文件FiddlerSetup.exe，一路傻瓜式安装即可。目前下载的版本为Progress Telerik Fiddler Classic。
安装完成后，打开Fiddler，主界面如下：
如图所示，切换至Inspectors可查看对应请求的请求参数和返回参数请求参数、返回参数不同内容及格式的展示，可以切换图中对应展示窗口顶部的Tab按钮，如Headers、WebForms、Raw、Json等。会话窗口图标说明见文章末说明。 接下来介绍怎样使用Fiddler进行手机移动端抓包。
Fiddler移动端抓包 我们先来屡一下移动端抓包的大概思路：
Fiddler需要设置允许远程计算机连接，即允许手机移动端抓包；设置手机代理网络代理，使手机通过Fiddler代理发送HTTP请求 (即Fiddler充当数据发送接收的中介)；https请求抓包设置（如果只抓取http请求，以上两步设置就可以了，但实际工作中经常需要抓取https请求数据）。 按照如上思路我们开始进行具体设置。
第一步：允许远程计算机连接 设置步骤：Tools--&gt;Options--&gt;Connections--&gt;勾选Allow remote computers to connect--&gt;再点击OK，其他默认即可，如下图所示：
勾选后如果有弹窗确认页面，点击【确定】即可。顺便说一下，上图勾选页面中的8888为默认的端口号，在第二步设置时需要使用。
第二步，设置手机网络代理 首先，需要先获取到安装Fiddler的电脑的IPv4地址，在cmd中输入ipconfig，如下图所示：
然后，在手机上找到对应的WLAN网络，进行该网络代理的设置，以荣耀V20手机为例，操作步骤如下图所示：
手机系统设置--&gt;WLAN--&gt;修改网络--&gt;高级选项--&gt;代理--&gt;选择手动--&gt;主机名填入上一步IPv4--&gt;端口填入默认的8888--&gt;保存
注意：
手机必须与电脑连接的是同一个网络，即连同一个WIFI或手机直接连电脑的热点，再对这个网络进行代理设置，否则无法抓取数据。第2步选择修改网络时，手机型号不同可能需要不一样的操作才能进入到修改网络页面。 到这一步，重启Fiddler后，便可以对手机上的http请求进行抓包了。如果不能抓取的话，可以在手机里重新保存上图中的代理设置，再进行请求。到这一步后，手机上打开APP操作，抓包的http请求，如下图所示：
可以看到，这里面只抓取了http请求，如果要对https请求进行抓包，则还需要进行下面的操作。
第三步，允许捕获HTTPS连接 设置步骤：Tools--&gt;Options--&gt;HTTPS--&gt;勾选Decrypt HTTPS traffic--&gt;再勾选Ignore server certificate errors--&gt;点击OK
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b383582ca83369ac2b7123070524aa01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d0c7e3bf43a8477f8920ee6802160c9/" rel="bookmark">
			【Android】配置Gradle打包apk的环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
生成jks签名文件
配置build.gradle（app）
打包 生成jks签名文件 Java 密钥库（.jks 或 .keystore）是用作证书和私钥存储库的二进制文件。用于为用户设备上安装的 APK 签名的密钥。
详细解释请看官方文档：
为应用签名 | Android Studio | Android Developers
在菜单栏中，依次点击 Build &gt; Generate Signed Bundle/APK。
Generate Signed Bundle or APK 对话框中，选择 APK，然后点击 Next。 Key store path 字段下，点击 Create new。 选择秘钥文件保存的位置：
选择你当前项目的app位置，如：
填好剩余信息即可： 上面这步是用来打包的，我们只需要生成秘钥文件，现在不需要打包，取消即可。
通过下面这张图可以看到已经生成秘钥文件了，如果你的目录结构跟我的不一样，注意看图中的左上角，我选择的是Project的结构，你的应该是Android目录结构。如果你没有看到生成的秘钥文件，需要你鼠标右键app目录，选择Reload from Disk刷新下即可。 配置build.gradle（app） 我们需要先在项目的根目录新建一个keystore.properties文件，这个文件是用来将秘钥信息给抽离出来的。
storeFile= storePassword= keyAlias= keyPassword= 接下来加载配置：
// 加载签名配置 def keystoreFile = rootProject.file('keystore.properties') def keystore = new Properties() keystore.load(new FileInputStream(keystoreFile)) // 签名配置 signingConfigs { config { storeFile file(keystore['storeFile']) storePassword keystore['storePassword'] keyAlias keystore['keyAlias'] keyPassword keystore['keyPassword'] } } 配置好了后还需要在对应的包上使用，项目创建的时候提供好了一个release包，比如在release包中使用这个签名。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d0c7e3bf43a8477f8920ee6802160c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab032721aa4b7af091100d71cffc32be/" rel="bookmark">
			stable diffusion comfyui的api使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、为什么要使用comfyui的api?对比webui的api，它有什么好处？ 1、自带队列
2、支持websocket
3、无需关心插件是否有开放api接口，只要插件在浏览器中可以正常使用，接口就一定可以使用
4、开发人员只需关心绘图流程的搭建
5、切换模型、进度查询soeasy
6、轻松实现图片生成时的渐变效果
7、支持中断绘图任务
8、无需繁琐的base64图片转换
其实我们之前一直都是用web-ui的api,最近web-ui被我们给废弃掉了，主要是因为comfyui基本上解决了webui做开发所有的弊端，首先列队的问题不用去管，它自己有列队，插件这块是最方便的，用上comfyui以后就不要去管插件是怎么调用的，只要你在工作流里面用了什么插件，保存为api之后，他直接下发后台就会自动去运行，也不用去管插件具体怎么调用。如果是webui,有些比较良心的插件，直接把接口写好，然后暴露出来， 如果没写的话，你用起来就会非常的麻烦，还得去研究它是怎么去调用的。所以 ，小伙伴们，别再执着用webui的api了,那个确实反人类，假如做开发的话问题会很多，比较烦人，就像获取任务进度，还有这个线程锁，切换模型这块都非常繁琐。我为了研究那东西 ，看代码看得头都大了 ，整整研究了一个月才把代码改好。
二、接口详解 本文主要介绍 stable diffusion API 调用，准确来说是对 stable diffusion comfyui 的 API 调用。需要apifox接口文件的可以查看：
https://gitee.com/BTYY/wailikeji-chatgpt/blob/master/comfyui-api.md
1、绘图接口：POST /prompt 注意：该接口只做绘图任务的下发，然后返回任务ID信息。并不会直接返回最终的结果图！
与webui的api不同的是，comfyui的api并没有单独区分文生图、图生图的接口，而是所有的绘图任务的下发全部都使用POST /prompt。那具体是文生图、图生图、又或者是换脸、倒推关键词等，取决于你的参数！
需要上传的参数只有两个
请求参数 名称类型必选说明client_idstring是任务ID,由客户端生成，用于标记任务是谁发起的promptjson是任务参数 返回参数 名称类型说明prompt_idstring任务IDnumberint当前任务序号，可用于后续获取需要等待任务数的计算node_errorsjson错误信息 返回示例
{ "prompt_id": "bd2cfa2c-de87-4258-89cc-d8791bc13a61", "number": 501, "node_errors": {} } 使用说明 client_id：任务ID,由客户端生成，用于标记任务是谁发起的,相当于告诉comfyui，该绘图任务是由用户A发起的，后续comfyui就会通过websocket将属于用户A的绘图信息推送给你
prompt：prompt所传的是一个json数据，它是由comfyui浏览器通过保存api生成的json数据，如下图
至于正反、提示词、模型、vae、图片尺寸、批次、提示词相关性、随机种子、采样器、降噪值等参数，只需替换json中对应的参数为用户上传的参数即可
比如用户上传的图片尺寸是768*512，那你只需将json数据中的width改为768、height改为512即可，其他的参数也是同样的道理！
2、websocket：/ws?client_id=XXXXXXXX client_id后面的参数即为上面/prompt接口中上传给comfyui的client_id，假如没有上传client_id，那comfyui就不知道连上该websocket的用户是谁，也就无法进行信息推送！comfyui拿到client_id后，即可知道当前是哪个用户，后续就会通过websocket将属于该用户的绘图信息精准推送给他
注意：websocket只需做监听处理，无需通过websocket向comfyui发送任何消息
websocket数据解析：
主要有两种数据格式：
1、文本数据，文本数据主要通知以下几个绘图信息：
通知任务变更、当前执行的步骤、进度
2、二进制数据，即图片预览信息
（一）文本数据详解： （1）任务变更通知： { "type":"status", "data":{ "status":{ "exec_info":{ "queue_remaining":7 } } } } 当你收到type为status信息时，这是comfyui在告诉你，当前任务数发生变更，queue_remaining是指当前还有多少个任务需要处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab032721aa4b7af091100d71cffc32be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51cfdf4b6bd4d9f7a7d359828587a322/" rel="bookmark">
			【Python爬虫】Python3.8分布式爬虫scrapy-redis的搭建与运行（较为全面）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、scrapy-redis概念
（一）、何为scrapy-redis框架?
（二）、分布式原理
（三）、分布式爬虫实现的流程
二、分布式爬虫搭建
（一）、Windows（master节点）上要做的事情
1.安装python
2.下载相应的python包
3.创建你的爬虫项目
4.配置你项目中的settings文件
5. Windows上redis的配置（重要）
（二）、Linux（slave节点）要做的事情
1.配置网络
2.关闭防火墙
3.配置域名映射
4.配置ssh免密
5.安装python3所需要的环境
6.针对现在Urllib3放弃对 OpenSSL&lt;1.1.1 的支持
7.下载Python安装包解压
8.编译及安装python：
9.配置环境变量
10.验证pip
11.升级pip，安装scrapy,scrapy-redis
12.运行爬虫项目
一、scrapy-redis概念 （一）、何为scrapy-redis框架? 一个三方的基于redis的分布式爬虫框架，配合scrapy使用，让爬虫具有了分布式爬取的功能。
（二）、分布式原理 这样的意思是：
scrapy-redis实现分布式，其实从原理上来说很简单，这里为描述方便，我们把自己的核心服务器称为master，而把用于跑爬虫程序的机器称为slave。
我们知道，采用scrapy框架抓取网页，我们需要首先给定它一些start_urls，爬虫首先访问start_urls里面的url，再根据我们的具体逻辑，对里面的元素、或者是其他的二级、三级页面进行抓取。而要实现分布式，我们只需要在这个starts_urls里面做文章就行了
我们在master上搭建一个redis数据库`（注意这个数据库只用作url的存储)，并对每一个需要爬取的网站类型，都开辟一个单独的列表字段。通过设置slave上scrapy-redis获取url的地址为master地址。这样的结果就是，尽管有多个slave，然而大家获取url的地方只有一个，那就是服务器master上的redis数据库。
并且，由于scrapy-redis自身的队列机制，slave获取的链接不会相互冲突。这样各个slave在完成抓取任务之后，再把获取的结果汇总到服务器上。
好处：
程序移植性强，只要处理好路径问题，把slave上的程序移植到另一台机器上运行，基本上就是复制粘贴的事情
（三）、分布式爬虫实现的流程 使用三台机器，一台是win11（windows），两台是centos，分别在两台机器上部署scrapy来进行分布式抓取一个网站。
windows的ip地址为实际IP，用来作为redis的master端，centos的机器作为slave。
master的爬虫运行时会把提取到的url封装成request放到redis中的数据。库：“dmoz:requests”，并且从该数据库中提取request后下载网页，再把网页的内容存放到redis的另一个数据库中“dmoz:items”。
slave从master的redis中取出待抓取的request，下载完网页之后就把网页的内容发送回master的redis。
重复上面的3和4，直到master的redis中的“dmoz:requests”数据库为空，再把master的redis中的“dmoz:items”数据库写入到想要存储的数据库中。
master里的reids还有一个数据“dmoz:dupefilter”是用来存储抓取过的url的指纹（使用哈希函数将url运算后的结果），是防止重复抓取的。
使scrapy的工作流程变成这样：
好了，原理了解了，实现是关键！！！ 二、分布式爬虫搭建 （一）、Windows（master节点）上要做的事情 1.安装python 官网:https://www.python.org/downloads/
下载安装完成后，务必配置环境变量
2.下载相应的python包 pip install lxml
pip install scrapy
pip install scrapy-redis
3.创建你的爬虫项目 scrapy startproject 项目名
scrapy genspider 爬虫名 域名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51cfdf4b6bd4d9f7a7d359828587a322/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee4c0fba2ee48f3525e014dbfbc0db58/" rel="bookmark">
			数据同步工具调研选型：SeaTunnel 与 DataX 、Sqoop、Flume、Flink CDC 对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品概述 Apache SeaTunnel 是一个非常易用的超高性能分布式数据集成产品，支持海量数据的离线及实时同步。每天可稳定高效同步万亿级数据，已应用于数百家企业生产，也是首个由国人主导贡献到 Apache 基金会的数据集成顶级项目。
SeaTunnel 主要解决数据集成领域的常见问题：
* 数据源多样：常用的数据源有数百种，版本不兼容。随着新技术的出现，出现了更多的数据源。用户很难找到能够全面快速支持这些数据源的工具。
* 复杂同步场景：数据同步需要支持离线-全量同步、离线-增量同步、CDC、实时同步、全库同步等多种同步场景。
* 资源需求高：现有的数据集成和数据同步工具往往需要大量的计算资源或JDBC连接资源来完成海量小表的实时同步。这在一定程度上加重了企业的负担。
* 缺乏质量和监控：数据集成和同步过程经常会丢失或重复数据。同步过程缺乏监控，无法直观了解任务过程中数据的真实情况。
* 技术栈复杂：企业使用的技术组件各不相同，用户需要针对不同的组件开发相应的同步程序来完成数据集成。
* 管理维护困难：市面上的数据集成工具通常受限于不同的底层技术组件（Flink/Spark），使得离线同步和实时同步往往是分开开发和管理的，增加了管理和维护的难度。
SeaTunnel 产品实现了高可靠性、集中管理、可视化监控等一体的数据集成统一平台。
平台可以实现了标准化、规范化、界面化操作；实现了数据同步高速化，全量到增量无锁化自动切换，目前已经支持 100+ 种数据源；支持整库同步、表结构自动变更；同时无中心化设计确保系统的高可用机制，整体上做到简单易用，开箱即用。
同类产品横向对比 对比项Apache SeaTunnelDataXApache SqoopApache FlumeFlink CDC部署难度容易容易中等，依赖于 Hadoop 生态系统容易中等，依赖于 Hadoop 生态系统运行模式分布式，也支持单机单机本身不是分布式框架，依赖 Hadoop MR 实现分布式分布式，也支持单机分布式，也支持单机健壮的容错机制无中心化的高可用架构设计，有完善的容错机制易受比如网络闪断、数据源不稳定等因素影响MR 模式重，出错处理麻烦有一定的容错机制主从模式的架构设计，容错粒度比较粗，容易造成延时支持的数据源丰富度支持 MySQL、PostgreSQL、Oracle、SQLServer、Hive、S3、RedShift、HBase、Clickhouse等过 100 种数据源支持 MySQL、ODPS、PostgreSQL、Oracle、Hive 等 20+ 种数据源仅支持 MySQL、Oracle、DB2、Hive、HBase、S3 等几种数据源支持 Kafka、File、HTTP、Avro、HDFS、Hive、HBase等几种数据源支持 MySQL、PostgresSQL、MongoDB、SQLServer 等 10+ 种数据源内存资源占用少多多中等多数据库连接占用少(可以共享 JDBC 连接)多多多多(每个表需一个连接)自动建表支持不支持不支持不支持不支持整库同步支持不支持不支持不支持不支持(每个表需配置一次)断点续传支持不支持不支持不支持支持多引擎支持支持 SeaTunnel Zeta、Flink、Spark 3 个引擎选其一作为运行时只能运行在 DataX 自己引擎上自身无引擎，需运行在 Hadoop MR 上，任务启动速度非常慢支持 Flume 自身引擎只能运行在 Flink 上数据转换算子(Transform)支持 Copy、Filter、Replace、Split、SQL 、自定义 UDF 等算子支持补全，过滤等算子，可以 groovy 自定义算子只有列映射、数据类型转换和数据过滤基本算子只支持 Interceptor 方式简单转换操作支持 Filter、Null、SQL、自定义 UDF 等算子单机性能比 DataX 高 40% - 80%较好一般一般较好离线同步支持支持支持支持支持增量同步支持支持支持支持支持实时同步支持不支持不支持支持支持CDC同步支持不支持不支持不支持支持批流一体支持不支持不支持不支持支持精确一致性MySQL、Kafka、Hive、HDFS、File 等连接器支持不支持不支持不支持精确，提供一定程度的一致性MySQL、PostgreSQL、Kakfa 等连接器支持可扩展性插件机制非常易扩展易扩展扩展性有限，Sqoop主要用于将数据在Apache Hadoop和关系型数据库之间传输易扩展易扩展统计信息有有无有无Web UI正在实现中(拖拉拽即可完成)无无无无与调度系统集成度已经与 DolphinScheduler 集成，后续也会支持其他调度系统不支持不支持不支持无社区非常活跃非常不活跃已经从 Apache 退役非常不活跃非常活跃 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee4c0fba2ee48f3525e014dbfbc0db58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0154b7978df93e174b3631cb7cd6fb4c/" rel="bookmark">
			Python中的filter函数用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引言
一、filter函数基本用法
二、filter函数应用场景
1、筛选符合条件的元素
2、数据清洗和预处理
3、复杂条件筛选
4、与其他函数结合使用
三、filter函数与lambda表达式
四、filter函数与列表推导式
五、总结
引言 Python中的filter函数是一种内置的高效过滤器，用于从序列中筛选出符合特定条件的元素，生成一个由符合条件元素组成的新列表。filter函数在Python中广泛应用于数据清洗和预处理，是Python开发者必备的技能之一。本文将详细介绍filter函数的用法，并通过实例代码阐述其应用场景。
一、filter函数基本用法 语法结构
filter(function, iterable)
参数说明
function：用于筛选元素的函数，该函数应返回一个布尔值，表示元素是否符合筛选条件。
iterable：待筛选的序列，可以是列表、元组、集合等可迭代对象。
返回值
filter函数返回一个由符合条件的元素组成的新列表。
二、filter函数应用场景 1、筛选符合条件的元素 filter函数可以用于从序列中筛选出符合特定条件的元素。例如，从一个列表中筛选出所有偶数：
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] even_numbers = filter(lambda x: x % 2 == 0, numbers) print(list(even_numbers)) # Output: [2, 4, 6, 8] 在这个例子中，我们传递了一个匿名函数作为filter函数的第一个参数，该函数用于判断一个数字是否为偶数。filter函数将这个函数应用于序列中的每个元素，筛选出符合条件的偶数元素。
2、数据清洗和预处理 filter函数在数据清洗和预处理方面非常有用。例如，我们可以使用filter函数来删除一个列表中的空字符串和None值：
strings = ['hello', '', 'world', None, 'python', 'programming'] clean_strings = filter(lambda x: x or x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0154b7978df93e174b3631cb7cd6fb4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5d22d07a6e4fd1c911b0b4bd6cbe3a8/" rel="bookmark">
			copilot提示：很抱歉，目前无法连接到服务。请稍后重试或刷新 的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此前能正常使用Copilot的，后来出现如下情况，提示“很抱歉，目前无法连接到服务。请稍后重试或刷新”，刷新无效，...里的设置也打不开。
检查了windows设置的“语言和区域”选项，确认国家和地区是“美国”，vpn地址也是非大陆地区，但就是连不上。
后面思考了下，copilot是属于bing的一个扩展插件，可能跟bing的设置有些关联。然后在浏览器中打开bing，发现确实没有chat。这就知道是个老问题了。
解决方案如下：必应 (bing.com) 的首页里，点击汉堡图标，在下拉框里确认“国家/地区”为非大陆地区，建议选美国，确认后，页面刷新，出现Chat图标。
win+C，弹出copilot栏，刷新，熟悉的助手又回来了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb3f6e2bb6a3f9ba5a5dd5eefd2aa5af/" rel="bookmark">
			python的虚拟环境venv创建和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找了半天python多版本共存下配置虚拟环境，通过网上的资源学习，我将总结如下：
1.什么是虚拟环境 AI是这么说的：
虚拟环境是在计算机中创建的一种隔离的、独立的工作区域。它主要用于在一个计算机系统中同时管理多个项目，每个项目都有自己独立的运行环境和依赖项。
虚拟环境的主要目的是解决不同项目之间依赖冲突的问题。在开发过程中，不同项目可能会依赖不同版本的软件包，这样就会导致冲突。通过创建虚拟环境，每个项目都可以拥有自己独立的Python解释器和软件包依赖，互不干扰。
常见的虚拟环境工具包括Python中的venv、virtualenv以及Anaconda中的conda。它们都可以帮助开发者创建、管理和切换虚拟环境。
通过使用虚拟环境，开发者可以更好地组织和管理项目，同时也可以确保项目的依赖关系得到良好的控制，避免不同项目之间的冲突，提高开发效率和代码的可维护性。
说的很对，下来我就用python中的Venv来创建虚拟环境。
2、创建虚拟环境并激活 快捷键win+R，输入cmd，打开面板
输入： python -m venv 安装路径和虚拟环境的名字
或者可以指定版本下载： python3.8 -m venv 安装路径和虚拟环境的名字
3.8可以改成你的指定版本；
其中include是空文件夹；咱们要看的是Scripts和Lib文件夹；
Lib和真实的文件差不了多少；
Scripts中
我们是window-cmd激活，那我们就激活一下：activate.bat，
也其实不用管后缀，你在那个环境中他就会在那个环境中激活；
前面的括号，说明我们进入了虚拟环境；通过命令行和文件，让我们来看一下，
激活里面的pip下载文件：
未下载前
下载后：
pip list 看一下；
出现了；
3.在编辑器的应用 以VScode例：ctrl+shift+P，选择解释器然后找到，刚刚创建的虚拟环境路径；
就OK了；
4.虚拟环境的必要性 1. 避免依赖冲突：虚拟环境可以避免依赖冲突，当你需要在同一台计算机上运行多个应用程序时，它们可能会依赖于相同的库或软件包，容易出现版本冲突。
2. 开发环境复制：如果你要部署或分享你的应用程序，你的开发环境需要与其他人的环境相同。虚拟环境是为部署容易复制和分享开发环境的好方法。
3. 隔离测试环境：虚拟环境可以为测试环境提供隔离，这可以避免测试过程中引入错误或中断生产环境。
4. 避免变化：虚拟环境可以避免使用旧版本的库，从而防止应用程序出现错误或崩溃。
5. 增强可重复性：虚拟环境可以提供一个可重复的环境，因此你可以在不同计算机上，不同操作系统中运行同样的应用程序。
综上，虚拟环境有助于保证开发环境的规范性、稳定性和可重复性。这些对于软件开发和数据分析来说是非常重要的。
5.保存和复制虚拟环境 想让第二个人和我用到一模一样的虚拟环境，该怎么做呢；
这时需要用的pip中的另一个命令：
让我们来调用一下：
pip freeze
你这里面的所有包；都能看到，
让我们来保存一下：
pip freeze &gt; requirements.txt
这样发送给别人，别用的时候，输入命令：
pip install -r requirements.txt；重新下载就行了；
文字看起来费劲可以参考视频：
7分钟编程环境通俗讲解_哔哩哔哩_bilibili
1-什么是虚拟环境_哔哩哔哩_bilibili
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db1839056408c078cb4a780e62c630dc/" rel="bookmark">
			UE5&#43;数字人&#43;文心一言实现语音问答
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此项目主要包含三个功能（讯飞语音识别、百度文心一言问答、metahumanSDK文字转语音合成口型），所有功能均使用蓝图实现，不含C++代码。
项目所需插件；
Http通信插件；VaRest，在UE5中用于与文心一言建立连接，在Epic虚幻商城可免费下载。
文字转语音及合成口型动画插件；Metahuman SDK，在Epic虚幻商城可免费下载。
语音识别插件；XunFeiSpeechToText，插件连接；🍞正在为您运送作品详情（该插件非本人所著，如需使用，需自行购买）
以下是该项目实现的全流程，仅供学习参考。
一、前期准备
1.导入人物模型；打开Quixel Bridge插件，如果没有这个插件就去商城下载一个，在其中选择一个合适的人物模型，将其下载下来。人物模型也可自己进行捏脸，需要上Metahuman官网进行操作，捏完脸后点击左下角按钮进行导出，然后在UE5中打开Quixel Bridge插件，登录后就可以看到自己捏脸的人物模型了，下载后在UE5的内容浏览器中就可看到一个MetaHumans的文件，打开文件，将人物模型的蓝图类拖至场景中即可使用。
2、导入插件；在项目文件夹中新建Plugins目录，将下载的XunFeiSpeechToText插件解压到此目录下。另外2个插件直接在虚幻商城下载后安装到引擎即可，然后在插件中找到下载的插件，将其都打开，然后重启项目。
二、实现讯飞语音识别功能
创建新关卡，然后保存关卡，再打开关卡蓝图进行编辑，图中红色款内是定义的全局变量，可以将语音识别的文字存入该字符串中，以便其他地方使用，如果不需要让语音识别的文字显示在UI则可删除该部分。
三、实现文心一言问答功能
1、申请百度文心一言API，网址；百度智能云-登录 (baidu.com)
注册好账号后，进入计费管理界面，开通所需服务，最好是都勾选，下面费用高的可以不用勾选，只有你使用了才能计费。
随后点击应用接入，进入此界面后点击创建应用按钮，创建完成后就可以得到API Key和Secret Key。
2、编辑蓝图，将UE5与文心一言进行通信连接
继续在关卡蓝图中进行编辑，创建四个变量，第一个Message变量的类型为Va Rest Json Object数组、第二个为模型编号、第三个第四个为申请的API Key和Secret Key（将上面申请的2串代码对应赋给所创建的字符变量）红色框内的Content为需要输入的问题，将此与上一步语音识别的文字连接。
图中红色框内的字符串就是文心一言返回的答案，这里同样创建了一个全局变量，用来存储文心一言回复的答案，方便其他地方调用。
四、metahumanSDK实现文字转语音及口型合成
图中红色框为metahumanSDK文字转语音的目标文字，将上面文心一言传回的答案与这个Text连接，图中绿色框为所需要制作口型的人物模型，在场景的大纲视口中将人物拖进蓝图即可得到。
以上就是此项目的全部实现流程了，最终效果还行，就是速度太慢，第一个点是文心一言，它是将所有答案一起传回，字数越多则等待的时间越长。第二个点是metahumanSDK的文字转语音和语音转口型，同样也是受字数影响，字数越多耗时越长，同时也要受网速的影响。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bd240731e37109c33c581109decbf7a/" rel="bookmark">
			从零基础到精通：Flutter开发的完整指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💂 个人网站:【工具大全】【游戏大全】【神级源码资源网】🤟 前端学习课程：👉【28个案例趣学前端】【400个JS面试题】💅 寻找学习交流、摸鱼划水的小伙伴，请点击【摸鱼学习交流群】 第一部分：入门篇 Flutter是一种跨平台的移动应用开发框架，它允许开发者使用单一代码库构建高性能、美观且响应迅速的应用程序。本篇文章将引导你从零基础逐步深入学习Flutter开发，成为一名Flutter专业开发者。
1. 什么是Flutter？ Flutter是由Google推出的开源UI软件开发工具包，用于构建原生、精美的移动、web和桌面应用。它使用Dart语言作为开发语言，并通过自己的渲染引擎绘制UI。
2. 准备工作 在学习Flutter之前，你需要安装Flutter SDK和相应的开发工具。以下是安装Flutter的基本步骤：
# 下载Flutter SDK git clone https://github.com/flutter/flutter.git # 添加Flutter到系统环境变量 export PATH="$PATH:`pwd`/flutter/bin" # 运行flutter doctor检查环境 flutter doctor 3. 创建你的第一个Flutter应用 现在，让我们来创建一个简单的Flutter应用。使用VS Code或Android Studio，打开一个新的终端窗口并输入以下命令：
# 创建新应用 flutter create my_first_app # 进入应用目录 cd my_first_app # 运行应用 flutter run 这将启动你的第一个Flutter应用，并在模拟器或连接的设备上显示"Hello, World!"。
4. Dart语言基础 Dart是Flutter的官方编程语言。在深入Flutter开发之前，了解Dart语言的基础知识是至关重要的。下面是一些Dart语言的基本概念：
变量和数据类型控制流程（if语句、循环）函数类和对象 5. Flutter Widgets Flutter使用一种称为“Widget”的组件模型来构建用户界面。Widgets是构建UI元素的基本构建块。以下是一些常用的Widgets：
Container: 用于创建盒子模型，可以包含其他Widgets。Row和Column: 用于水平或垂直排列子Widgets。ListView和GridView: 用于滚动视图。AppBar和Scaffold: 用于创建应用栏和基本布局结构。 第二部分：进阶篇 在入门篇中，我们建立了一个基本的Flutter应用，并了解了一些基本概念。在进阶篇中，我们将深入学习一些更高级的主题。
6. 状态管理 Flutter应用中的状态管理是一个关键的话题。我们将介绍setState、Provider、和Bloc等常用的状态管理方式，并讨论何时使用它们。
// 示例代码：使用setState管理状态 class CounterApp extends StatefulWidget { @override _CounterAppState createState() =&gt; _CounterAppState(); } class _CounterAppState extends State&lt;CounterApp&gt; { int _counter = 0; void _incrementCounter() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('Counter App'), ), body: Center( child: Text('Count: $_counter'), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, child: Icon(Icons.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bd240731e37109c33c581109decbf7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0dde3384cc402eb818d96f064b1fe1d/" rel="bookmark">
			数学建模篇---2022国赛C题（二）（全程python,完整论文和代码可取！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接着上回我们继续第三题
问题 3 对附件表单 3 中未知类别玻璃文物的化学成分进行分析，鉴别其所属类型，并对 分类结果的敏感性进行分析。 我们的分析：
基于问题二的分类模型，计算出每个待测样本点与簇中心的平方欧式距离，与2中得到的变量与簇中心的理想距离范围进行比较，完成分类，通过给模型添加微小扰动，观察样本数据统计规律变化，给出敏感性分析。
结果及分析：
该新模型对问题二的数据判断错误个案数为6，计算准确率为92.5%，原问题二的判断个案准确率为98.6%，即给于10%的扰动，模型的准确率变化6.19% 且均方和显著性分析的结果也印证了分类结果的合理性和准确性，原样本点的情况也与实际分类结果大致符合，因此我们认为该模型稳定性在可控范围内。
题 4 针对不同类别的玻璃文物样品，分析其化学成分之间的关联关系，并比较不同类 别之间的化学成分关联关系的差异性。 我们的分析：
我们需要分别给出两种玻璃类型内部各化学成分之间的相关性，以及在两种玻璃类型之间的比较，我们使用灰色关联分析法，对于各个子系统或者两个系统之间的因素，给出变量或子序列之间的关联性大小的衡量。
在高钾玻璃和铅钡玻璃两种类型的前提下，我们根据题意选定用于比较的参考数列，确定各子序和参考序列的关联度，关联度越高，相关性越大。本题中，我们分别选取各化学成分序列作为参考序列，循环计算所有序列之间的相关关系，并用Python给出最终的可视化结果。通过结果我们比较两个类型之间的差异性。
解题过程：
1.确定比较的对象，我们循环将每一个化学成分变量作为D0主要参考对象，每种类型的样本数量为n,即D0 ={ D0k|k=1,2……n}评价标准为其13个化学成分，即有13个评价对象，Di ={ Dik|k=1,2……n}, i = 1,2……13。 2.对数据进行无量纲化和标准化处理，让数据更加准确和可靠，随后我们根据公式计算子序列之间灰色关联系数： 其中 ξi为参考对象以样本为观测的和评价对象之间的关联系数， ρ为分辨系数，本题我们采用均值来计算关联系数，分辨系数我们一般取0.5，min smin tx0t-xs(t)为我们取差值矩阵的最大值与最小值。 3.我们由（2）中计算的化学成分之间的相关性，利用 Python的 matplotlib和 numpy库对结果进行可视化的预览，分别给出高钾玻璃和铅钡玻璃的热力图结果，使结果更加直观，利于下一步的分析。 结果及分析：
附言：
由于篇幅有限，我只给出了部分的分析和结果图，完整Python代码和完整论文及数据可评论“代码”或者私信领取！希望能和大家一起交流学习！
给出链接了，希望帮到大家，接下来会更新今年国赛的参考
链接：https://pan.baidu.com/s/15y1cGYOGUJXaFB1eK2Zf2A?pwd=pqmx 提取码：pqmx --来自百度网盘超级会员V4的分享
最后我想说的是这是一次有些遗憾但是充满意义的一次经历，在后续的美赛也会更新和大家交流，预祝各位和我一样的同学取得一个更好的成绩！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2209f04e7ea969505dbf6f0b69cee90f/" rel="bookmark">
			C语言动态规划解决0-1背包问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动态规划（Dynamic Programming，简称DP）是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题，它能够将问题分解为相互独立的子问题，并将子问题的解存储起来，以便下次需要时直接使用，从而减少计算量，提高效率。最经典的例子就是0-1背包问题。
0-1背包问题描述：给定一组物品，每种物品都有自己的重量和价值，在限定的总重量内，选取若干种物品，使得物品的总价值最大。其中，每种物品只能选择一次或不选择。
基本思路 用子问题定义状态：f[i][c] 表示前 i 件物品放入一个容量为 c 的背包可以获得的最大价值。第 i 件物品的重量是 wi，价值是 vi，则其状态转移方程是：
f[i][c] = max(f[i-1][c], f[i-1][c-wi] + vi) 这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。分析子问题“将前 i 件物品放入容量为 c 的背包中”，考虑第 i 件物品放或不放入背包，可以转化为一个只牵扯前 i-1 件物品的问题：如果不放第 i 件物品，那么问题就转化为“前 i-1 件物品放入容量为 c 的背包中”，价值为 f[i-1][c]；如果放第 i 件物品，那么问题就转化为“前 i-1 件物品放入剩下的容量为 c-wi 的背包中”，此时能获得的最大价值就是 f[i-1][c-wi] 再加上通过放入第 i 件物品获得的价值 vi。所以按照这个方程递推完毕后，最终的答案一定是 f[i][c]。
示例程序 #include &lt;stdio.h&gt; #define max(a, b) a &gt; b ? a : b int knapsack(int weights[], int values[], int capacity, int n) { // f[i][c] 表示在前i个物品中选择若干个物品放入容量为c的背包中所能获得的最大价值 int f[n + 1][capacity + 1]; for (int i = 0; i &lt;= n; i++) { for (int c = 0; c &lt;= capacity; c++) { if (i == 0 || c == 0) { // 前0个物品，或者容量为0，价值也为0 f[i][c] = 0; } else if (c &lt; weights[i-1]) { // i表示前i个物品，所以第i个物品的重量是 weights[i-1]，对应前面公式中的 wi // 遍历到当前容量c小于当前物品的重量，无法放入该物品，保持背包现状 // 即：上一轮遍历物品的循环中同样数量物品的最大价值，所以是 f[i-1][c] f[i][c] = f[i-1][c]; } else { // i表示前i个物品，所以第i个物品的价值是 values[i-1]，对应前面公式中的 vi // 可以放入，判断放入该物品是否能使背包中物品价值最大 // 如果放入，可能需要腾出背包中同样重量的物品，所以是 f[i-1][c-weights[i-1]] // 然后 f[i-1][c-weights[i-1]] + values[i-1] 得到放入该物品后的价值 // 不放入该物品（保持背包现状），与放入该物品，取两者中的最大值 f[i][c] = max(f[i-1][c], f[i-1][c - weights[i-1]] + values[i-1]); } } } // 输出动态规划数组中的值，显示规划过程，用于分析理解 for (int i = 0; i &lt;= n; i++) { for (int c = 0; c &lt;= capacity; c++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2209f04e7ea969505dbf6f0b69cee90f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d42f52f9027ccb86770d9047868f655d/" rel="bookmark">
			mathtype7.6产品密钥在哪里？有mathtype7.6破解版吗？MathType- Win-安装包：https://souurl.cn/NMiwukMathType- Mac-安装包：ht
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mathtype7 .6产品密钥在哪里？mathtype7是一款强大专业的数学公式编辑器，但是不少朋友们由于没有对应的激活码，无法使用所有所有功能。今天小编就给大家分享一下2022最新的mathtype7产品密钥，帮助大家快速使用该软件。
MathType是一款功能强大的公式编辑软件，自升级至MathType 7后，软件又支持了中文，在使用上更加方便。但是，MathType需要激活后才可以使用。许多人会查找MathType 7激活密钥免费获取的方法，但是这些激活码常会官方禁用或收回。MathType怎么输入激活码？在安装了正式版本的软件后，通过【帮助】便可找到输入激活码的位置。下面我们来看详细介绍吧！
一、MathType7激活密钥免费获取
MathType 7数学公式编辑器已成为理科生们的必备工具之一，而且只有安装正版软件才能够体验更完善、全面的服务体系。同时MathType中文网站还会及时为用户进行软件升级、开发更完善的新功能。
MathType- Win-安装包：https://souurl.cn/NMiwuk
MathType- Mac-安装包：https:// souurl.cn/VQ2WIR
图1：MathType中文网站
通过MathType中文网站除了可以下载到MathType安装包外，还可以购买正版软件密钥，填写密钥后便可正常使用软件了。通过非法渠道获得的各版本MathType序列号-注册码-激活码常会被官方禁用或回收，还请用户到MathType中文网站购买正版软件授权码。
二、MathType怎么输入激活码
如果已通过MathType中文网站购买了正版软件授权码，那么该如何激活软件呢？
在购买正版软件授权时，会要求用户填写邮箱地址。购买成功后，该邮箱地址会收到一个正式版的软件下载链接，通过该链接下载安装软件后，在桌面会有软件图标，双击软件图标便可启动软件。
图2：帮助窗口
启动软件后，单击软件【帮助】选择激活软件，然后在【输入产品秘钥】位置输入【名字、电子邮箱、产品密钥】，勾选接受条款，单击【激活】便可将MathType激活了。
在word如何显示MathType面板？
如果成功安装MathType后，有时在桌面无法查找软件图标，仅能在word中找到MathType的菜单栏，此时我们要怎样启动MathType客户端来添加公式？
图3：客户端
单击word顶部菜单栏【MathType】，单击工具栏位置【显示】，便可将MathType客户端调取出来，直接选择客户端位置公式便可输入，使用快捷键【Ctrl+S】便可将MathType客户端内公式输入word（如图4）。
图4：输入公式
三、总结
以上便是，MathType7激活密钥免费获取，MathType怎么输入激活码的内容。虽然网上有一些免费的MathType7激活密钥，但许多已经被MathType官方禁用或收回了，无法再正常使用，想要获得真实的MathType密钥可以通过MathType中文网站。获得密钥后，通过软件客户端【帮助】便可填写密钥。
mathtype7产品密钥 MTWE691-011524-947zu
MTWE691-011800-fvydn
mathtype7激活步骤 1.单击“帮助”按钮，在其下拉选项选择注册，就会弹出如下图所示的输入产品密钥窗口；
2.双击桌面快捷图标打开安装好的MathType 7，单击“帮助”菜单，在其下拉选项选择注册，就会弹出如下图所示的输入产品密钥窗口。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a147b8abf395cba80242d0a28e9039b/" rel="bookmark">
			【Java】Java 17 新特性概览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 17 新特性概览 1. Java 17 简介2. Java 17 新特性类型推断 - 新的 var 关键字垃圾回收器改进JEP 356 增强的伪随机数生成器（1）提供了一个新接口 RandomGenerator（2）提供了一个新类 RandomGeneratorFactory（3）提供了四个新的专用 RandomGenerator 接口 JEP 398 删除弃用的 Applet APIJEP 406 - switch 表达式增强JEP 407 - 删除远程方法调用激活机制JEP 409 - 密封类（Sealed Classes）JEP 410 - 删除实验性的 AOT 和 JIT 编译器JEP 411 - 删除弃用的安全管理器JEP 412 - 外部函数和内存 API（孵化）JEP 414 - 向量（Vector） API（第二次孵化） 3. Java 17 升级实战 1. Java 17 简介 Java 17 于 2021年09月14日 正式发布，且为长期支持版本（Long-Term-Support - LTS）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a147b8abf395cba80242d0a28e9039b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a58e109f9e9c7e23cbefedff1f1b5c4/" rel="bookmark">
			Unable to make field private final java.lang.String java.io.File.path accessible: module java.base d
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体错误 &gt; Task :app:processDebugMainManifest FAILED Execution failed for task ':app:processDebugMainManifest'. &gt; Unable to make field private final java.lang.String java.io.File.path accessible: module java.base does not "opens java.io" to unnamed module @19799644 解决办法 降低成本JDK版本，如图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b43ddca2ed1d216b434cbe9f2499312a/" rel="bookmark">
			记CVE-2022-39227-Python-JWT漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言影响版本漏洞分析Newstar2023 Week5总结 前言 在Asal1n师傅的随口一说之下，说newstar week5出了一道祥云杯一样的CVE，于是自己也是跑去看了一下，确实是自己不知道的一个CVE漏洞，于是就从这道题学习到了python-jwt库中的身份验证绕过漏洞，顺带做了一下简单的代码分析。
影响版本 python-jwt &lt; 3.3.4
漏洞分析 这个漏洞造成的原因更像是库的作者在编写代码的时候疏忽导致的，使得验证的payload内容和返回的payload内容并不是一个payload导致的，下面来简单分析一下。
先给出github上作者漏洞修补的大致payload，利用payload进行测试，如下：
python-jwt库地址
from json import * from python_jwt import * from jwcrypto import jwk payload = {'role': "guest"} key = jwk.JWK.generate(kty='oct', size=256) jwt_json = generate_jwt(payload, key, 'HS256', timedelta(minutes=60)) [header, payload, signature] = jwt_json.split('.') parsed_payload = loads(base64url_decode(payload)) parsed_payload['role'] = "admin" fake = base64url_encode((dumps(parsed_payload,separators=(',', ':'))))#这里separators就是消除了空格，不加似乎也并不影响漏洞。 fake_jwt = '{" ' + header + '.' + fake + '.":"","protected":"' + header + '"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b43ddca2ed1d216b434cbe9f2499312a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f1586311eb934324bc712611e198d0b/" rel="bookmark">
			AFE芯片做什么用的？AFE（Analog Front End） 模拟前端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AFE 模拟前端电路和AFE模拟前端芯片 AFE在处理链的最前面，即输入端，进行模拟信号的处理的电路。称为模拟前端。
AFE指集成了ADC、放大器、基准源、激励电路、调制解调电路等的模拟系统，可以广泛应用于各类高精度测量领域，相对于ADC，AFE的集成度更高、功能更强大，一般与MCU共同使用。
AFE 芯片的运行原理可以分为以下几个步骤：
1、采样： AFE 芯片通过内置的 ADC（模数转换器）将传感器采集到的模拟信号转换成数字信号。ADC 采用的采样率越高，转换的数字信号精度就越高。
2、滤波： 由于传感器采集到的模拟信号中可能包含一些不必要的噪声和干扰，AFE 芯片会通过内置的滤波器对数字信号进行滤波处理，以提高数字信号的信噪比。
3、放大： AFE 芯片还可以对数字信号进行放大处理，以提高数字信号的灵敏度和分辨率。
4、数字处理： 经过上述处理后，AFE 芯片将数字信号发送到处理器进行数字信号处理。处理器可以对数字信号进行各种算法处理，例如滤波、FFT（快速傅里叶变换）、信号分析等。
5、输出： 处理后的数字信号可以通过多种方式进行输出，例如串口输出、并口输出、以太网输出等。
影响AFE采样精度的因素有哪些？ AFE（Analog Front End） 是模拟前端电路的缩写，它是模拟信号传感器和数字信号处理器之间的连接点。AFE采样精度是指模拟信号被数字化后的准确度，对于很多电子设备来说，这是一个至关重要的性能指标。本文将介绍影响AFE采样精度的因素，并提供一些解决方法。
1. 噪声 噪声是指信号中不必要的杂波，它会影响到信号的准确度。在AFE采集信号时，由于环境因素、电路自身等原因会产生噪声，因此要减少噪声对信号的影响，可以通过加大采样精度、提高信噪比、优化系统抗干扰性等方法。
2. 采样频率 采样频率是指采集模拟信号的时钟频率。采样频率越高，能够采集的信号波形越接近原始信号，因此采样频率对于AFE采样精度具有重要影响。不过，过高的采样频率也会导致处理器负担过大，因此需要在保证精度的前提下，找到一个合适的采样频率。
3. 放大器增益 AFE中的放大器是起到增强信号的作用。然而，过高或过低的放大器增益都会影响到AFE采样精度。如果增益过高，会导致信号饱和，无法提高采样精度；如果增益过低，信号则无法被充分放大，同样也无法提高采样精度。因此，需要在实际应用中调节放大器增益，以获得更好的采样精度。
4. 电源噪声 电源噪声是指电源本身的噪声，它可能会影响到AFE中的放大器和其他电路。在实际应用中，可以采用电源隔离、电源降噪、电源滤波等方法来降低电源噪声对AFE采样精度的影响。
5. 传输线路 AFE采集的信号需要通过传输线路传输到数字处理器进行处理。在传输过程中，信号可能会受到干扰或信号衰减，从而影响到采样精度。因此，在实际应用中，可以采用屏蔽线、平衡线、差分线等方法来减少传输线路对AFE采样精度的影响。
6. 温度 温度对AFE采样精度也有很大的影响。在不同的温度下，电路元件的特性会发生变化，这会直接影响到采样精度。因此，在实际应用中，需要对AFE进行温度补偿，以保证在不同温度下获得一致的采样精度。
7. ADC分辨率 ADC（Analog to Digital Converter）是将模拟信号转换成数字信号的核心器件。ADC的分辨率决定了数字信号的准确度，因此也会影响到AFE采样精度。一般来说，ADC的分辨率越高，能够采集到的信号细节就越多，采样精度也就越高。
8. 信号类型 不同的信号类型对于AFE采样精度也有很大的影响。例如，正弦波信号的采样精度要比方波信号高，因为正弦波信号的频谱比方波信号更加平滑，不会产生高频成分。因此，在实际应用中，需要根据信号类型来选择合适的AFE参数，以获得最佳的采样精度。
9. 器件匹配 AFE中的各个电路元件需要相互匹配，以保证电路的准确度和稳定性。如果各个元件的参数不匹配，会导致信号偏移、失真等问题，从而影响到采样精度。因此，在实际应用中，需要进行器件匹配和校准，以保证AFE的准确度和稳定性。
总结 AFE采样精度的影响因素非常多，需要综合考虑各种因素，并根据实际应用场景来选择合适的参数和方法。通过减少噪声、提高采样频率、调节放大器增益、降低电源噪声、优化传输线路、进行温度补偿、选择合适的ADC分辨率、根据信号类型选择合适的AFE参数、进行器件匹配和校准等方法，可以提高AFE的采样精度，从而更好地满足各种应用需求。
————————————————
版权声明：本文为CSDN博主「czf.Forver」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_45459486/article/details/129082406
AFE（Analog Front End） 模拟前端主要功能
模拟前端处理的对象是信号源给出的模拟电视、模拟声音信号，其主要功能包括以下几个方面：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f1586311eb934324bc712611e198d0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2025f4b808ac12cdcc7e1d14166883e5/" rel="bookmark">
			JWT简介&amp; JWT结构&amp; JWT示例&amp; 前端添加JWT令牌功能&amp; 后端程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. JWT简述
1.1 什么是JWT
1.2 为什么使用JWT
1.3 JWT结构
1.4 验证过程
2. JWT示例
2.1 后台程序
2.2 前台加入jwt令牌功能
1. JWT简述 1.1 什么是JWT Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。
JSON Web Token（JWT）是目前最流行的跨域身份验证解决方案
1.2 为什么使用JWT 传统的intenet服务的认证是通过session进行的，当用户通过了安全认证后，则在服务端的session对象中保存该用户的认证信息，这样该用户对服务的访问被认为是安全的。这种模式的最大问题是没有分布式架构，不方便进行横向扩展，这种模式只适合于单体应用模式。如果需要进行服务集群则需要处理好共享session的问题。 如果一个庞大的系统需要按服务分解为多个独立的服务，使用分布式架构，则这种方式更难处理。使用jwt可以方便的处理上面提到的问题。
1.3 JWT结构 JWT头：
JWT头部分是一个描述JWT元数据的JSON对象，通常如下所示。{"alg": "HS256","typ": "JWT"}。
有效载荷：
有效载荷部分，是JWT的主体内容部分，也是一个JSON对象，包含需要传递的数据。这些声明被JWT标准称为claims。
例如：{"sub":"123","name":"Tom","admin":true}，sub代表这个token的所有人，存储的是所有人的ID；name表示这个所有人的名字；admin表示所有人是否管理员的角色。当后面对JWT进行验证的时候，这些claim都能发挥特定的作用。
根据JWT的标准，这些claims可以分为以下三种类型：
A. Reserved claims(保留)
它的含义就像是编程语言的保留字一样，属于JWT标准里面规定的一些claim。JWT标准里面定义好的claim有：
iss (issuer)：签发人
exp (expiration time)：过期时间
sub (subject)：主题
aud (audience)：受众
nbf (Not Before)：生效时间
iat (Issued At)：签发时间
jti (JWT ID)：编号
B. Public claims，略（不重要）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2025f4b808ac12cdcc7e1d14166883e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3036b691c51b6336f5a841e35b08dbbc/" rel="bookmark">
			【Hadoop】YARN容量调度器详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🦄 个人主页——🎐开着拖拉机回家_Linux,Java基础学习,大数据运维-CSDN博客 🎐✨🍁
🪁🍁🪁🍁🪁🍁🪁🍁 🪁🍁🪁🍁🪁🍁🪁 🪁🍁🪁🍁🪁🍁🪁🍁🪁🍁🪁🍁
目录
一、CapacityScheduler简介
二、CapacityScheduler特性
三、CapacityScheduler配置
四、YARN WEB UI 参数详解
一、CapacityScheduler简介 Hadoop YARN的核心组件是ResourceManager，负责集群资源管理与调度，而ResourceManager组件的核心是调度器，负责统筹集群资源，满足应用的资源需求。调度器不仅需要优化整个集群的资源布局，避免热点等问题对应用的影响，最大程度利用集群资源；还要能协调好大量应用在集群的运行，基于多租户（队列）公平性、应用优先级等策略解决好资源竞争等问题；也要能满足个别应用在节点依赖、放置策略等方面的特殊需求。
YARN调度器是可拔插的插件，主要有FIFOScheduler、FairScheduler和CapacityScheduler三类。
FIFOScheduler：是最简单的调度器，不支持多租户（所有应用都提交到Default队列），不考虑集群的资源分布（节点上堆叠调度），只支持以FIFO（First In，First Out）策略依次调度应用，无其他控制与调度特性。只适用于及其简单的场景，因此很少应用于正式生产。FairScheduler：是CDH（Cloudera Distributed Hadoop）的默认调度器，与HDP（Hortonworks Data Platform）合并后的CDP（Cloudera Data Platform）不再使用（迁移到CapacityScheduler），Apache Hadoop社区也建议迁移到CapacityScheduler。FairScheduler支持较为完善的多租户管理与资源调度能力，包括多级队列、配额管理、ACL控制、弹性资源共享、租户间公平性调度策略、租户内应用调度策略、资源预留、抢占、异步调度等，然而在Apache Hadoop社区的发展相比CapacityScheduler仍稍显落后，核心调度未考虑整个集群的资源布局，也不支持Node Labels（分区调度）、Node Attributes（节点打标调度）、Placement Constraints（放置约束）等调度特性。CapacityScheduler：是Apache Hadoop社区、HDP（Hortonworks Data Platform）及合并后CDP（Cloudera Data Platform）的默认调度器，具有最完善的多租户管理与资源调度能力，不仅包含了FairScheduler的全部能力，还能协调好整个集群的资源布局（基于Global Scheduling），减少热点概率，最大程度利用集群资源，还支持Node Labels（分区调度）Node Attributes（节点打标调度）、Placement Constraints（放置约束）等调度特性。 下面重点对CapacityScheduler进行介绍，其他调度器的使用说明请参考社区文档。
二、CapacityScheduler特性 分层队列——支持分层队列，以确保在允许其他队列使用空闲资源之前，在组织的子队列之间共享资源，从而提供更多的控制和可预测性。 容量保证——队列被分配了网格容量的一小部分，在某种意义上，一定容量的资源将供它们使用。提交到队列的所有应用程序都可以访问分配给队列的容量。管理员可以对分配给每个队列的容量配置软限制和可选的硬限制，就是可以使用其他队列的剩余资源，也可以严格限制不能超出限制。安全性——每个队列都有严格的acl，它控制哪些用户可以向各个队列提交应用程序。此外，还有安全防护措施，以确保用户不能查看和/或修改来自其他用户的应用程序。此外，还支持每个队列和系统管理员角色。弹性资源共享——可以将空闲资源分配给超出其容量的任何队列。当队列配置资源有空闲时，可以分配给其他有资源需求的队列。当再次需要这些资源时可以抢夺回这些资源。这确保了资源以可预测和弹性的方式对队列可用，从而防止集群中人为的资源孤岛，从而有助于利用率。多租户——提供了一组全面的限制，以防止单个应用程序、用户和队列独占队列或整个集群的资源，以确保集群不会不堪重负。可操作性 运行时配置——管理员可以在运行时以安全的方式更改队列定义和属性(如容量、acl)，以尽量减少对用户的干扰。此外，还为用户和管理员提供了一个控制台，以查看系统中各种队列的当前资源分配情况。管理员可以在运行时添加额外的队列，但不能在运行时删除队列，除非队列已停止并且没有挂起/正在运行的应用程序。取消应用程序——管理员可以在运行时停止队列，以确保在现有应用程序运行到完成时，没有新的应用程序可以提交。如果队列处于STOPPED状态，则不能将新的应用程序提交给它自己或它的任何子队列。现有的应用程序将继续完成，因此可以正常地耗尽队列。管理员还可以启动已停止的队列。 基于资源的调度——支持资源密集型应用程序，其中应用程序可以选择指定比默认值更高的资源需求，从而容纳具有不同资源需求的应用程序。目前，内存是支持的资源需求。优先级调度——该功能允许应用程序以不同的优先级提交和调度。整数值越大，优先级越高。目前，应用程序优先级仅支持FIFO排序策略。绝对资源配置——管理员可以为队列指定绝对资源，而不是提供基于百分比的值。这为管理员提供了更好的控制，以便为给定队列配置所需的资源量。 三、CapacityScheduler配置 Ambari 2.7.4配置页面
配置队列层级如下：
root ├── acc └── ipva ├── bzv2 └── default Ambari-queue-manager配置如下：
capacity-scheduler.xml 配置文件
&lt;configuration xmlns:xi="http://www.w3.org/2001/XInclude"&gt; &lt;!-- 设置所有提交的job中ApplicationMaster的资源比例上限，该参数通常用于限制处于活动状态的job数量。--&gt; &lt;property&gt; &lt;name&gt;yarn.scheduler.capacity.maximum-am-resource-percent&lt;/name&gt; &lt;value&gt;0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3036b691c51b6336f5a841e35b08dbbc/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/60/">«</a>
	<span class="pagination__item pagination__item--current">61/71</span>
	<a class="pagination__item pagination__item--next btn" href="/page/62/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>