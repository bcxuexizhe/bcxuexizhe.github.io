<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.126.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程学习者的博客">
		<meta property="og:url" content="https://bcxuexizhe.github.io/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="编程学习者">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8478b964eb35d33ff01e882a9a6e0d81/" rel="bookmark">
			【动态规划】【map】【C&#43;&#43;算法】1289. 下降路径最小和 II
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者推荐 视频算法专题
本文涉及知识点 动态规划汇总
map
LeetCode1289. 下降路径最小和 II 给你一个 n x n 整数矩阵 grid ，请你返回 非零偏移下降路径 数字和的最小值。
非零偏移下降路径 定义为：从 grid 数组中的每一行选择一个数字，且按顺序选出来的数字中，相邻数字不在原数组的同一列。
示例 1：
输入：grid = [[1,2,3],[4,5,6],[7,8,9]]
输出：13
解释：
所有非零偏移下降路径包括：
[1,5,9], [1,5,7], [1,6,7], [1,6,8],
[2,4,8], [2,4,9], [2,6,7], [2,6,8],
[3,4,8], [3,4,9], [3,5,7], [3,5,9]
下降路径中数字和最小的是 [1,5,7] ，所以答案是 13 。
示例 2：
输入：grid = [[7]]
输出：7
提示：
n == grid.length == grid[i].length
1 &lt;= n &lt;= 200
-99 &lt;= grid[i][j] &lt;= 99
动态规划 动态规划的状态表示 multimap&lt;int,int&gt; mSumToIndex 的key，各行的最小和,value 列下标。 mSumToIndex不包括当前行，mDp包括当前行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8478b964eb35d33ff01e882a9a6e0d81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1b618d4002856fc03fa8c29b6e83597/" rel="bookmark">
			开源模型应用落地-工具使用篇-Spring AI-高阶用法（九）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 通过“开源模型应用落地-工具使用篇-Spring AI-Function Call（八）-CSDN博客”文章的学习，已经掌握了如何通过Spring AI集成OpenAI以及如何进行function call的调用，现在将进一步学习Spring AI更高阶的用法，如：传递历史上下文对话，调整模型参数等。
二、术语 2.1、Spring AI 是 Spring 生态系统的一个新项目，它简化了 Java 中 AI 应用程序的创建。它提供以下功能：
支持所有主要模型提供商，例如 OpenAI、Microsoft、Amazon、Google 和 Huggingface。支持的模型类型包括“聊天”和“文本到图像”，还有更多模型类型正在开发中。跨 AI 提供商的可移植 API，用于聊天和嵌入模型。支持同步和流 API 选项。支持下拉访问模型特定功能。AI 模型输出到 POJO 的映射。 三、前置条件 3.1、JDK 17+ 下载地址：Java Downloads | Oracle
​
3.2、创建Maven项目 SpringBoot版本为3.2.3
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.2.3&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; 3.3、导入Maven依赖包 &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-core&lt;/artifactId&gt; &lt;version&gt;5.8.24&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1b618d4002856fc03fa8c29b6e83597/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eb087f128d64600354f05bc00e35e11/" rel="bookmark">
			Fast-Planner(一)前端详解kinodynamic A*
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为无人机自主运动的入门路径规划算法，详细表述了路径规划的前端和后端，前端为路径搜索，后端未路径优化。具体参考代码。
一、kinodynamic a_star 路径搜索 这里参考的文章是Path Planning for Autonomous Vehicles in Unknown Semi-structured Environments
总的可以概括为融合动力学约束的A*搜索，通过共轭梯度下降求局部最优。
解析kinodynamic_astar.cpp Pathnode类(文章中motion Primitives)反向链表 class PathNode { public: /* -------------------- */ Eigen::Vector3i index; //voxel坐标 Eigen::Matrix&lt;double, 6, 1&gt; state; //基元状态,分别为xyz及其一阶导(vel) double g_score, f_score; //代价函数、启发函数 Eigen::Vector3d input; //输入，分别为xyz上的二阶导(acc) double duration; //输入持续时间 double time; // dyn int time_idx; PathNode* parent; //父节点 char node_state; /* -------------------- */ PathNode() { parent = NULL; node_state = NOT_EXPAND; } ~PathNode(){}; EIGEN_MAKE_ALIGNED_OPERATOR_NEW }; typedef PathNode* PathNodePtr; 主函数 /* kinodynamic A*的主函数 parameter： - start_pt：起点位置 - start_v: 起始速度 - start_a: 起始加速度 - end_pt: 终点位置 - end_v: 终点速度 - init： 初始化成功标志位 - dynamic：动静规划标志位 - time_start:起始时间 */ int KinodynamicAstar::search(Eigen::Vector3d start_pt, Eigen::Vector3d start_v, Eigen::Vector3d start_a, Eigen::Vector3d end_pt, Eigen::Vector3d end_v, bool init, bool dynamic, double time_start) 读取传入参数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5eb087f128d64600354f05bc00e35e11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e0ba8caedc131df76bc5071fa7047c6/" rel="bookmark">
			初级爬虫实战——麻省理工学院新闻
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 发现宝藏一、 目标二、 浅析三、获取所有模块四、请求处理模块、版面、文章1. 分析切换页面的参数传递2. 获取共有多少页标签并遍历版面3.解析版面并保存版面信息4. 解析文章列表和文章5. 清洗文章6. 保存文章图片 五、完整代码六、效果展示 发现宝藏 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。【宝藏入口】。
一、 目标 爬取news.mit.edu的字段,包含标题、内容，作者，发布时间，链接地址，文章快照 (可能需要翻墙才能访问)
二、 浅析 1.全部新闻大致分为4个模块
2.每个模块的标签列表大致如下
3.每个标签对应的文章列表大致如下
4.具体每篇文章对应的结构如下
三、获取所有模块 其实就四个模块，列举出来就好，然后对每个分别解析爬取每个模块
class MitnewsScraper: def __init__(self, root_url, model_url, img_output_dir): self.root_url = root_url self.model_url = model_url self.img_output_dir = img_output_dir self.headers = { 'Referer': 'https://news.mit.edu/', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) ' 'Chrome/122.0.0.0 Safari/537.36', 'Cookie': '替换成你自己的', } ... def run(): root_url = 'https://news.mit.edu/' model_urls = ['https://news.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e0ba8caedc131df76bc5071fa7047c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6542db2f82880639090d5e8585aa607/" rel="bookmark">
			vue前端获取本地IP地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新建js文件
getIpAddress.js
//获取本机的IP地址 function getNetworkIp() { let ip = 'localhost'; try { const network = Os.networkInterfaces();//获取本机的网路 for (const iter in network) { const faces = network[iter]; for (const interface of faces) { if (interface.family === 'IPv4' &amp;&amp; interface.address !== '127.0.0.1' &amp;&amp; !interface.internal) { ip = interface.address; return ip; } } } } catch (e) { } return ip; } module.exports = getNetworkIp; 在index.js文件中添加以下配置
dev: { // Paths assetsSubDirectory: 'static', assetsPublicPath: '/', proxyTable: {}, // Various Dev Server settings host: getNetworkIp(), // can be overwritten by process.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6542db2f82880639090d5e8585aa607/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d17af518549a5fd083f8d9369fa0fc45/" rel="bookmark">
			【Python】【Matplotlib】fig, ax = plt.subplots() 返回的fig和ax是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Python】【Matplotlib】fig, ax = plt.subplots() 返回的fig和ax是什么？
🌈 个人主页：高斯小哥
🔥 高质量专栏：Matplotlib之旅：零基础精通数据可视化、Python基础【高质量合集】、PyTorch零基础入门教程👈 希望得到您的订阅和支持~
💡 创作高质量博文(平均质量分92+)，分享更多关于深度学习、PyTorch、Python领域的优质内容！（希望得到您的关注~）
🌵文章目录🌵 📊 一、fig和ax简介🖼️ 二、fig的用法设置图形大小设置图形标题保存图形显示图形 📈 三、ax的用法绘制图形设置坐标轴标签和刻度设置坐标轴范围添加图例完整代码 🎨 四、多个子图🔍 五、fig和ax的交互使用 fig.add_axes() 添加 Axes 对象使用 ax.figure 获取所属的 Figure 对象共享坐标轴 🎭 六、fig和ax的进一步定制自定义颜色、线条样式和标记添加网格、边框和背景色 🤝七、期待与你共同进步🎉 结语🔍 关键词 📊 一、fig和ax简介 在Matplotlib库中，fig, ax = plt.subplots() 是一个常用的函数，用于创建一个新的图形窗口以及一个或多个子图。返回的 fig 和 ax 对象分别代表了整个图形和其中的一个子图。fig 是 Figure 类的实例，代表整个绘图窗口，而 ax 是 Axes 类的实例，代表其中的一个子图或坐标轴。
通过 fig 和 ax，我们可以方便地对整个图形和子图进行各种操作，比如设置标题、坐标轴标签、刻度等。
🖼️ 二、fig的用法 fig 对象提供了许多方法和属性，用于控制整个图形的外观和行为。以下是一些常用的用法：
设置图形大小 可以通过 figsize 参数在创建图形时设置其大小（宽和高，单位为英寸）。
import matplotlib.pyplot as plt fig, ax = plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d17af518549a5fd083f8d9369fa0fc45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fe55ab0c13b84f35c7476c07a3397c9/" rel="bookmark">
			Python AI 之Stable-Diffusion-WebUI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stable-Diffusion-WebUI简介 通过Gradio库，实现Stable Diffusion web 管理接口
Windows 11 安装Stable-Diffusion-WebUI 个人认为Stable-Diffusion-WebUI 官网提供的代码安装手册/自动安装不适合新手安装，我这边将一步步讲述我是如何搭建Python Conda虚拟环境来运行Stable-Diffusion-WebUI项目。在此文当中还会穿插一些AI知识点。
Stable-Diffusion-WebUI 源码下载 打开Git 命令窗口，右击选择-&gt;Open Git Base Here
执行如下指令，下载Stable-Diffusion-WebUI 源码。
git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git 构建Stable-Diffusion-WebUI 运行虚拟环境（stable-diffusion-webui）,并安装项目依赖 创建stable-diffusion-webui虚拟环境执行如下指令：
-- 创建pyotrch 虚拟环境，并指定Python版本 conda create -n stable-diffusion-webui python=3.10 -- 激活pytorch 环境 activate stable-diffusion-webui 解答:个人为什么不推荐各位新手安装Stable-Diffusion-WebUI 官网提供的文档进行项目部署调试（手动/自动安装），我先将官网对于提供的安装文档拷贝出来，以及大致梳理其中的关键点步骤。 Installation on Windows 10/11 with NVidia-GPUs using release package 手动安装 Download sd.webui.zip from v1.0.0-pre and extract its contents. Run update.bat. Run run.bat. For more details see Install-and-Run-on-NVidia-GPUs Automatic Installation on Windows 自动安装 Install Python 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fe55ab0c13b84f35c7476c07a3397c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1896f72630248abae705e7650d4cbd52/" rel="bookmark">
			H3C交换机配置IP与MAC绑定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IP+MAC方法一：
在全局模式使用arp static方式进行绑定，命令如下：
arp static 172.16.10.1 C400-AD7B-C220
IP+MAC方法二：
进入接口使用arp filter方式进行绑定，命令如下：
int GigabitEthernet1/0/1
arp filter binding 172.16.10.1 C400-AD7B-C220
IP+MAC方法三：
进入接口使用动态绑定表项的方式进行绑定，命令如下：
Int GigabitEthernet1/0/1
ip source binding ip-address 172.16.10.1 mac-address C400-AD7B-C220
ip verify source ip-address mac-address
也可在系统全局模式下使用动态绑定表项的方式进行绑定，命令如下：
ip source binding ip-address 172.16.10.1 mac-address C400-AD7B-C220
IP+MAC方法四：
如果本设备配置为DHCP服务器，且需要实现IP+MAC的静态绑定，命令如下：
dhcp enable
dhcp server ip-pool 123
static-bind ip-address 172.16.10.1 mask 255.255.255.0 hardware-address C400-AD7B-C220
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34bb5d80503e5288608c77a04fdd313a/" rel="bookmark">
			Time-LLM：为时间序列预测重新编程LLM 探索Time-LLM的架构，并在Python中将其应用于预测项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考资料：Time-LLM/ Reprogram an LLM for Time Series Forecasting.md
文章目录 探索Time-LLM输入补丁化重新编程层使用提示前缀增强输入输出投影 使用Time-LLM进行预测在 neuralforecast 中扩展 Time-LLM使用 Time-LLM 进行预测使用 N-BEATS 和 MLP 进行预测 我对 Time-LLM 的看法结论参考文献 研究人员尝试将自然语言处理（NLP）技术应用于时间序列领域并非首次。
例如，Transformer架构在NLP领域是一个重要的里程碑，但其在时间序列预测方面的表现一直平平，直到PatchTST的提出。
正如您所知，大型语言模型（LLMs）正在积极开发，并在NLP领域展示出令人印象深刻的泛化和推理能力。
因此，值得探索将LLM重新用于时间序列预测的想法，以便我们可以从这些大型预训练模型的能力中受益。
为此，Time-LLM被提出。在原始论文中，研究人员提出了一个框架，重新编程现有的LLM以执行时间序列预测。
在本文中，我们将探讨Time-LLM的架构以及它如何有效地使LLM能够预测时间序列数据。然后，我们将实现该模型并将其应用于一个小型预测项目。
要了解更多详情，请务必阅读原始论文。
让我们开始吧！
探索Time-LLM Time-LLM更应被视为一个框架，而不是一个具有特定架构的实际模型。
Time-LLM的一般结构如下所示。
Time-LLM的一般结构。图片由M. Jin, S. Wang, L. Ma, Z. Chu, J. Zhang, X. Shi, P. Chen, Y. Liang, Y. Li, S. Pan, Q. Wen提供，来源为Time-LLM: Time Series Forecasting by Reprogramming Large Language Models
Time-LLM的整个理念是重新编程一个嵌入可见的语言基础模型，如LLaMA或GPT-2。
请注意，这与微调LLM是不同的。相反，我们教导LLM接受一系列时间步的输入，并在一定的时间范围内输出预测。这意味着LLM本身保持不变。
在高层次上，Time-LLM首先通过自定义的补丁嵌入层对输入时间序列序列进行标记化。然后，这些补丁通过一个重新编程层，将预测任务本质上转化为语言任务。请注意，我们还可以传递一个提示前缀以增强模型的推理能力。最后，输出的补丁通过投影层，最终得到预测。
这里有很多内容需要深入探讨，让我们更详细地探讨每个步骤。
输入补丁化 第一步是对输入序列进行补丁化，就像在PatchTST中一样。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34bb5d80503e5288608c77a04fdd313a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/316de512359d29752545fb28568208c1/" rel="bookmark">
			【Spark编程基础】实验一Spark编程初级实践（附源代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、实验目的二、实验平台三、实验内容和要求1. 计算级数2. 模拟图形绘制3.统计学生成绩 一、实验目的 1.掌握 Scala 语言的基本语法、数据结构和控制结构；
2.掌握面向对象编程的基础知识，能够编写自定义类和特质；
3.掌握函数式编程的基础知识，能够熟练定义匿名函数。熟悉 Scala 的容器类库的基本
层次结构，熟练使用常用的容器类进行数据；
4.熟练掌握 Scala 的 REPL 运行模式和编译运行方法。
二、实验平台 操作系统：Ubuntu16.04；
Spark 版本：2.1.0；
Hadoop 版本：2.7.1。
三、实验内容和要求 1. 计算级数 请用脚本的方式编程计算并输出下列级数的前 n 项之和 Sn，直到 Sn 刚好大于或等于 q
为止，其中 q 为大于 0 的整数，其值通过键盘输入。
例 如 ，若 q 的 值 为 50.0 ， 则输出应为：Sn=50.416695请将源文 件保存为 exercise2-1.scala，在REPL模式下测试运行，测试样例：q=1时，Sn=2；q=30时，Sn=30.891459；
q=50 时，Sn=50.416695。
scala&gt; import io.StdIn._ import io.StdIn._ scala&gt; var Sn:Float = 0 Sn: Float = 0.0 scala&gt; var n:Float=1 n: Float = 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/316de512359d29752545fb28568208c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54564a8944b0302631830ca57815fd08/" rel="bookmark">
			JDK 11: “JDK 11：稳定、可靠、兼容性优秀的Java开发工具包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDK 11: "JDK 11：稳定、可靠、兼容性优秀的Java开发工具包 JDK 11: "JDK 11：稳定、可靠、兼容性优秀的Java开发工具包"摘要 🌟引言 🚀模块化系统：Java平台的重大变革 🌈模块化的概念：模块化的优势：在实际项目中应用模块化开发：新的HTTP客户端：更加现代化的网络编程新的HTTP客户端API特性：新的HTTP客户端API用法示例：局部变量类型推断：代码更简洁更易读局部变量类型推断的使用方法：局部变量类型推断的实际应用场景： 总结 📝参考资料 📚 博主 默语带您 Go to New World.
✍ 个人主页—— 默语 的博客👦🏻
《java 面试题大全》 《java 专栏》 🍩惟余辈才疏学浅，临摹之作或有不妥之处，还请读者海涵指正。☕🍭
《MYSQL从入门到精通》数据库是开发者必会基础之一~
🪁 吾期望此文有资助于尔，即使粗浅难及深广，亦备添少许微薄之助。苟未尽善尽美，敬请批评指正，以资改进。！💻⌨
JDK 11: “JDK 11：稳定、可靠、兼容性优秀的Java开发工具包” 摘要 🌟 作为Java开发者，我们经常需要依赖于稳定可靠的开发工具包来支持我们的项目。JDK 11作为Java生态系统中的一个重要版本，为我们带来了许多令人振奋的新特性和改进。本文将深入探讨JDK 11的各项特性，包括模块化系统、新的HTTP客户端、局部变量类型推断等，并分析其在实际开发中的应用场景和优势。
引言 🚀 随着软件开发的不断演进，Java作为一种稳定、可靠的编程语言，一直在不断地发展和完善。JDK 11作为Java平台的一个重要版本，不仅保留了之前版本的稳定性和可靠性，还引入了许多新特性和改进，进一步提升了开发者的编程体验。在本文中，我们将探讨JDK 11的各种特性，并探讨其对Java开发的影响。
模块化系统：Java平台的重大变革 🌈 模块化的概念： 模块化是一种软件设计和组织代码的方法，通过将代码划分为相互独立、可重用的模块，以提高可维护性、可扩展性和可重用性。在Java 9之前，Java应用程序主要以JAR文件的形式组织，缺乏明确的模块化结构。Java 9引入了模块系统，通过引入新的关键字module，将Java平台划分为一系列明确定义的模块。
模块化的优势： 更清晰的代码结构： 模块化系统通过明确定义模块之间的依赖关系，使得代码结构更加清晰，易于理解。每个模块都有自己的责任和功能，有助于降低代码耦合度。
更好的封装性： 模块化允许将相关功能封装在一个模块中，并限制对模块内部的访问。这提高了封装性，减少了模块之间的直接依赖，从而降低了系统的复杂性。
更好的可维护性： 模块化系统使得项目更易维护。由于每个模块都有清晰的职责，修改一个模块不会对其他模块产生意外影响，减少了维护工作的风险。
更好的版本管理： 模块可以明确声明对其他模块的依赖关系，从而更容易进行版本管理。这有助于确保在升级或更改一个模块时，不会对整个系统造成不必要的影响。
更高的安全性： 模块化系统允许在模块级别上定义访问控制，提高了安全性。只有被明确声明为公共API的模块才能被外部模块访问，其他模块的内部细节可以保持私有。
更轻松的构建和部署： 模块化的应用程序可以更轻松地进行构建、测试和部署。模块化系统提供了更精确的依赖关系，可以更有效地进行构建和部署，减少了潜在的冲突和问题。
在实际项目中应用模块化开发： 定义模块： 使用module-info.java文件来定义模块，声明模块的名称、依赖关系和导出的API。
划分功能模块： 根据项目需求划分模块，确保每个模块都有清晰的职责和功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54564a8944b0302631830ca57815fd08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3283e8e6e3eae6fabe70f7e395ba2e5/" rel="bookmark">
			ChatGPT4.0直接出图功能上线！神奇一键画，AI让创作更轻松(chatgpt4.0直接出圖)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGPT4.0直接出图功能上线！神奇一键画，AI让创作更轻松(chatgpt4.0直接出圖) ChatGPT4.0的核心功能 ChatGPT4.0是OpenAI发布的最新版本的ChatGPT，相较于之前的版本有许多新增的功能和特点。其中最显著的功能是新增了直接出图功能，使创作变得更轻松和高效。
ChatGPT4.0的语言理解能力 与之前的版本相比，ChatGPT4.0具备更强大的语言理解能力。它能够更准确地理解用户的指令，从而更好地满足用户的需求。
ChatGPT4.0直接出图功能 ChatGPT4.0新增了直接出图功能，使用户可以直接通过输入文本指令，让AI模型生成相应的图像。这意味着用户无需使用第三方插件或繁琐的操作流程，即可快速生成图像。
以下是ChatGPT4.0的一些重要特点：
更快的留学申请过程: 拥有了类似于GPT-4.0这样的AI工具之后，学生在留学申请过程中能够更容易地搜集到想要的信息，更快的完成文书。更高效的问答交流: ChatGPT4.0的问答功能使用户可以直接向模型提问，获得准确的回答。语音对话功能: ChatGPT4.0新增了语音对话功能，用户可以直接与模型进行语音交流，无需再打字。 ChatGPT4.0的应用场景 ChatGPT4.0在各行各业都有广泛的应用。以下是一些应用场景示例：
应用场景示例学术研究研究人员可以使用ChatGPT4.0进行文献调研和知识查询。创意设计设计师可以通过ChatGPT4.0快速生成设计图像，提升创作效率。教育培训教师可以使用ChatGPT4.0辅助教学，回答学生的问题并提供学习资料。 ChatGPT4.0的直接出图功能和强大的语言理解能力使得其应用范围更加广泛，并在多个领域带来了效率和便利性的提升。
使用ChatGPT4.0直接出图功能 升级至ChatGPT4.0 Plus用户 使用直接出图功能需要先升级至ChatGPT4.0的Plus版本。 安装并激活daigr.am插件 在ChatGPT的Beta设置中，通过搜索并安装daigr.am插件。激活插件，开启直接出图功能。 使用直接出图功能 在与ChatGPT4.0的对话过程中，通过文本指令触发直接出图功能。AI模型根据指令生成相应的图像，并以图像形式呈现给用户。 ChatGPT4.0直接出图的应用场景 ChatGPT 4.0是一款强大的语言模型，具备图片识别功能。通过先进的图像处理技术和训练模型，它可以准确识别图片中的元素、场景、颜色等信息。
尽管ChatGPT 4.0目前并不具备直接生成图片的功能，但可以通过结合Unsplash API和图像处理技术来实现ChatGPT4.0生成图片的效果。
AI生成图片和文案，还能进行图文带货？这是一个潜在的应用场景。通过ChatGPT4.0，只需要两张图片，二十四小时就能卖二十万。
除了基于图片的应用场景，ChatGPT4.0还提供了其他强大的功能，例如UML图绘制、图像描述和点评等。
UML图绘制 AI模型可以帮助用户直接绘制UML类图，简化操作流程，提升绘图效率。用户只需输入相关描述或指令，AI模型即可生成对应的UML类图。 图像描述和点评 通过ChatGPT4.0直接出图功能，用户可以让AI模型描述或点评一张图像。AI模型能够快速理解图像内容，并以语言形式进行描述或点评，帮助用户更好地理解图像。 根据提供的素材内容进行分析，得出以下核心观点和主要信息：
核心观点：
– ChatGPT4.0是一个具备普通对话功能和文本处理能力的模型。
– ChatGPT4.0分为默认模型和联网模型两种。
主要信息：
– ChatGPT4.0的默认模型是基础模型，用户可以直接使用该模型进行聊天对话或文本处理。
– ChatGPT4.0的联网模型可以通过联网获取更多信息，在联网状态下可以实现更加智能的对话和文本处理。
– ChatGPT4.0的默认模型支持上传图片，并可以对图片进行读取识别，但是暂不支持直接处理图片。
– ChatGPT4.0具备强大的识图能力，可以识别图片中的物体。
– ChatGPT4.0的语言输入限制提升至2.5万字，准确性也显著提高。
– ChatGPT4.0可以生成歌词和创意文本，并能够实现风格变化。
根据以上分析的核心观点和主要信息，进行标题匹配和内容填充：
ChatGPT4.0模型介绍 ChatGPT4.0的几种模型，包括4.0默认模型和4.0联网模型：
4.0默认模型 4.0默认模型是ChatGPT4.0的基础模型，具备一般对话功能和文本处理能力。
用户可以直接使用该模型进行聊天对话或文本处理。
4.0联网模型
4.0联网模型是ChatGPT4.0的扩展模型，通过联网可以获取更多信息。
用户在联网状态下，可以使用该模型进行更加智能的对话和文本处理。
ChatGPT4.0的默认模型 ChatGPT4.0的默认模型是基础模型，用户可以直接使用该模型进行聊天对话或文本处理。该模型具备一般对话功能和文本处理能力。此外，该模型还支持上传图片，并可以对图片进行读取识别，但不支持直接处理图片。如果需要处理图片，可以通过代码实现。
ChatGPT4.0的联网模型 ChatGPT4.0的联网模型是对默认模型的扩展，通过联网可以获取更多信息。在联网状态下，用户可以使用该模型进行更加智能的对话和文本处理。联网模型具备强大的识图能力，可以识别图片中的物体。除此之外，该模型在语言输入限制和回答准确性上也有显著提升。
为了展示更多关于ChatGPT4.0的信息，以下是一些相关细节和特点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3283e8e6e3eae6fabe70f7e395ba2e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d00908643285a5f9b0a35a0e8baee425/" rel="bookmark">
			一文带你深入浅出Web的自动化测试工具Selenium 4.xx【建议收藏】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言发现宝藏第01节 Selenium概述第02节 安装浏览器驱动（以Google为例）第03节 定位页面元素1. 打开指定页面2. id 定位3. name 定位4. class 定位5. tag 定位6. xpath 定位7. css 选择器8. link 定位9. 示例 有道翻译 第04节 浏览器控制1. 修改浏览器窗口大小2. 浏览器前进&amp;后退3. 浏览器刷新4. 浏览器窗口切换5. 常见操作6. 示例 CSDN页面元素交互 第05节 鼠标控制1.单击元素2.双击元素3.在元素上右键单击4.在元素上悬停（鼠标悬停）5.拖拽元素到另一个位置 第06节 键盘控制1.输入文本2.按键3.组合键4. 其他键盘操作 第07节 元素等待1. 隐式等待2. 显示等待3. 自定义等待4. 强制等待 第08节 切换操作1. 窗口切换2. 表单切换 第09节 滚轮操作总结 前言 为了巩固所学的知识，作者尝试着开始发布一些学习笔记类的博客，方便日后回顾。当然，如果能帮到一些萌新进行新技术的学习那也是极好的。作者菜菜一枚，文章中如果有记录错误，欢迎读者朋友们批评指正。
（博客的参考源码可以在我主页的资源里找到，如果在学习的过程中有什么疑问欢迎大家在评论区向我提出）
发现宝藏 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。【宝藏入口】。
第01节 Selenium概述 Selenium 是一个Web的自动化测试工具，最初是为网站自动化测试而开发的，Selenium 可以直接运行
在浏览器上，它支持所有主流的浏览器
因为 Selenium 可以控制浏览器发送请求，并获取网页数据，因此可以应用于爬虫领域
Selenium 可以根据我们的指令，让浏览器自动加载页面，获取需要的数据，甚至页面截屏，或者判断网
站上某些动作是否发生
Selenium 自己不带浏览器，不支持浏览器的功能，它需要与第三方浏览器结合在一起才能使用
Selenium 库的版本不同对应的方法名也会有所不同
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d00908643285a5f9b0a35a0e8baee425/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6101c63ffc8a869979660c278bb9c8f1/" rel="bookmark">
			SpringBoot和JDK版本兼容性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot和JDK版本兼容问题，就是SpringBoot的每个版本支持哪些JDK版本。
在spring官网、spring-boot项目的github地址都没有找到一个统一的总结，类似表格这样，所以到spring-boot的各个版本的文档中找出来。如果有官方的总结我没找到的，可以跟我说下。
下面的表格列出了SpringBoot版本、JDK版本的兼容性，以及兼容性的来源，都在spring-boot的各个版本的文档中，有链接、描述java版本的原文。
SpringBoot VersionsJDK Versions来源0.0 -1.16+(6 or higher)https://docs.spring.io/spring-boot/docs/0.0.x/reference/html/getting-started-installing-spring-boot.html Spring Boot can be used with “classic” Java development tools or installed as a command line tool. Regardless, you will need Java SDK v1.6 or higher.
https://docs.spring.io/spring-boot/docs/1.0.x/reference/html/getting-started-installing-spring-boot.html Spring Boot can be used with “classic” Java development tools or installed as a command line tool. Regardless, you will need Java SDK v1.6 or higher.
https://docs.spring.io/spring-boot/docs/1.1.x/reference/html/getting-started-installing-spring-boot.html Spring Boot can be used with “classic” Java development tools or installed as a command line tool.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6101c63ffc8a869979660c278bb9c8f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ca73814f369839bf68d859b38721fec/" rel="bookmark">
			SpringCloud-实现基于RabbitMQ的消息队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		消息队列是现代分布式系统中常用的通信机制，用于在不同的服务之间传递消息。在Spring Cloud框架中，我们可以利用RabbitMQ实现强大而可靠的消息队列系统。本篇博客将详细介绍如何在Spring Cloud项目中集成RabbitMQ，并创建一个简单的消息队列。
一、SpringCloud调用RabbitMQ架构图 Spring Cloud RabbitMQ Sends Message Listens for Message Invokes HTTP Request Exchange: default / Queue: hello MessageProducer MessageConsumer MessageController Queue: hello message 这里是一个简单的RabbitMQ消息队列架构图，表示了Spring Cloud框架中集成RabbitMQ的基本消息队列架构。在图中，RabbitMQ包含一个名为hello的队列。Spring Cloud中有三个组件，分别是消息生产者(MessageProducer)、消息消费者(MessageConsumer)和一个控制器(MessageController)。生产者通过RabbitMQ交换机发送消息到队列，而消费者通过监听队列接收和处理消息。控制器充当HTTP请求的入口，调用消息生产者发送消息。
二、SpringCloud调用RabbitMQ的实现步骤 1、添加依赖 首先，确保你的Spring Cloud项目中已经添加了RabbitMQ的依赖。在pom.xml文件中添加以下依赖：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt; &lt;/dependency&gt; 这个依赖将引入Spring Cloud Stream和RabbitMQ相关的库。
2、配置RabbitMQ连接信息 在application.yml或application.properties文件中配置RabbitMQ连接信息，包括主机、端口、用户名和密码等：
spring: rabbitmq: host: localhost port: 5672 username: guest password: guest 3、创建消息生产者 创建一个消息生产者（Producer）用于发送消息到RabbitMQ队列。创建一个类，并使用@EnableBinding(Source.class)注解开启消息绑定：
import org.springframework.cloud.stream.annotation.EnableBinding; import org.springframework.cloud.stream.messaging.Source; import org.springframework.messaging.support.MessageBuilder; @EnableBinding(Source.class) public class MessageProducer { private final Source source; public MessageProducer(Source source) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ca73814f369839bf68d859b38721fec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15e85fb088012fce71b4ae68dd356108/" rel="bookmark">
			Java学习：小程序微信登录开发实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此次开发的实现是基于B站黑马课程的学习；只涉及后端的实现，前端代码不会。。 微信官方小程序登录开发文档链接：小程序登录 | 微信开放文档|小程序登录 | 微信开放文档
前述 小程序实现微信登录，完成具体业务的实现参考下图：
登录的实现需要三个端口实现 ：小程序、开发者服务器、微信接口服务
在小程序端，通过wx.login()方法获取到临时登录凭证code，将code传给开发者服务器端。
开发者服务器端通过HttpClient创建请求，传递appid、sercet、code参数，请求微信接口服务获取openid和session_key等参数。
开发者服务器端接收到参数以后会将openid等参数与自定义登录态关联返回到微信小程序，小程序会将自定义登录态存储，在以后进行业务请求的时候都会携带自定义登录态，开发者服务器端会验证传递过来的自定义登录态是否合法，合法则返回请求业务的数据，不合法则拒绝访问。
注意：1、code只能使用一次，每次登录需要获取新的code；2、appid与sercet是小程序创建的id和密钥；3、OpenId是用户唯一标识，每个微信用户仅有一个；补充：openid是单个小程序对微信用户只有一个，换个小程序该微信用户的openid就会变，unionid是一个微信用户不在微信平台下的任何程序都只有一个
4、自定义登录态是因为小程序没有cookie，所以只能做伪Cookie来识别用户，此处采用JWT令牌来实现
小程序获取临时登录凭证code 调用wx.login（）,返回的res里面存储code，此处通过通知台将code打印出来
//获取微信登录用户的授权码 wx.login({ success: (res) =&gt; { console.log(res.code) } }) 开发者服务器端实现 登录的实现，返回结果应该为一个用户对象。
调用微信接口返回OpenId，通过OpenId查询用户数据库，如果能查询到，说明存在用户；查询不到就直接实现自动注册，即封装该OpenId的用户到数据库中，返回该用户对象。然后在Controller层生成jwt令牌，将该用户对象、OpenId和jwt令牌封装成返回对象，返回给小程序端。
Controller层实现 public class UserController { @Autowired private UserService userService; @Autowired JwtProperties jwtProperties; @PostMapping("/login") @ApiOperation("微信登录") public Result&lt;UserLoginVO&gt; login( @RequestBody UserLoginDTO userLoginDTO ){ log.info("微信登录，{}",userLoginDTO); //调用微信登录的实现 User user = userService.wxLogin(userLoginDTO); //为微信用户生成jwt令牌 传入（秘钥|过期时间|用户的唯一标识） Map&lt;String , Object&gt; claims = new HashMap&lt;&gt;(); claims.put(JwtClaimsConstant.USER_ID,user.getId()); String token = JwtUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15e85fb088012fce71b4ae68dd356108/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b34d7cbb000a248071367397633a9c35/" rel="bookmark">
			Linux-一篇文章，速通Hadoop集群之伪分布式，完全分布式，高可用搭建（附zookeeper，jdk介绍与安装）。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章较长，附目录，此次安装是在VM虚拟环境下进行。文章第一节主要是介绍Hadoop与Hadoop生态圈并了解Hadoop三种集群的区别，第二节和大家一起下载，配置Linux三种集群以及大数据相关所需的jdk，zookeeper，只需安装配置的朋友可以直接跳到文章第二节。同时，希望我的文章能帮助到你，如果觉得我的文章写的不错，请留下你宝贵的点赞，谢谢。
目录
一、了解Hadoop
Hadoop
什么是Hadoop
Hadoop的历史
Hadoop的特点
Hadoop的生态系统
1.HDFS
2.MapReduce
3.YARN
4.Hive
5.HBase
6.Oozie
7.Mahout
8.spark
9.Flink
10.zookeeper
二、下载安装包
jdk官网下载地址
Hadoop官网下载地址
zookeeper官网下载地址
三、Hadoop集群搭建
一、伪分布式搭建
二、完全分布式搭建
三、高可用搭建+zookeeper
拓展、Hadoop 与 HPCC的区别
一、了解Hadoop Hadoop 什么是Hadoop Hadoop官网介绍
Hadoop是一个由Apache基金会所开发的分布式系统基础架构，是一个开源的框架，用于编写和运行分布式应用以处理大规模数据。它最初是从Nutch项目中分离出来的，专门负责分布式存储以及分布式运算。Hadoop的核心主要包含HDFS（Hadoop Distributed File System，分布式文件系统）和MapReduce（分布式数据处理模型）。
HDFS用于分布式存储海量数据，而MapReduce则用于数据的分布式处理，其本质是并行处理。Hadoop的数据来源可以是任意类型的，它在处理半结构化和非结构化数据时与关系型数据库相比有更好的性能和灵活性。任何类型的数据最终都会转化成key/value的形式，这是Hadoop的基本数据单元。
Hadoop专为离线和大规模数据分析而设计，并不适合对少量记录进行随机在线处理的模式。在实际应用中，Hadoop常被用于日志分析等任务，还可以与Hive等工具配合使用以进一步提升数据处理能力。
总的来说，Hadoop是一个可以更容易开发和运行处理大规模数据的软件平台，用户可以在不了解分布式底层细节的情况下，开发分布式程序。
Hadoop的历史 Hadoop的历史
Hadoop起源于Apache Nutch项目，始于2002年，是Apache Lucene的子项目之一 [2]。2004年，Google在“操作系统设计与实现”（Operating System Design and Implementation，OSDI）会议上公开发表了题为MapReduce：Simplified Data Processing on Large Clusters（Mapreduce：简化大规模集群上的数据处理）的论文之后，受到启发的Doug Cutting等人开始尝试实现MapReduce计算框架，并将它与NDFS（Nutch Distributed File System）结合，用以支持Nutch引擎的主要算法 [2]。由于NDFS和MapReduce在Nutch引擎中有着良好的应用，所以它们于2006年2月被分离出来，成为一套完整而独立的软件，并被命名为Hadoop。到了2008年年初，hadoop已成为Apache的顶级项目，包含众多子项目，被应用到包括Yahoo在内的很多互联网公司
Hadoop的特点 Hadoop的特点
高可靠性：Hadoop采用分布式存储，将数据备份多份并分发至不同的机器进行保存，避免了因机器宕机导致的数据丢失，从而保证了数据的安全性和可靠性。即使Hadoop的某个计算元素或存储出现故障，也不会导致数据丢失。高扩展性：Hadoop是一个高度可扩展的系统，可以在集群间分配任务数据，方便地扩展到数以千计的节点。当现有集群的资源不足以完成数据处理和分析任务时，可以通过快速扩充集群规模进行扩容，从而加强集群的运算能力。高效性：Hadoop采用MapReduce编程模型，能够并行工作，以加快任务处理速度。它能够在节点之间动态地移动数据，并保证各个节点的动态平衡，因此处理速度非常快。相比传统的单台机器处理数据，Hadoop的效率得到了极大的提升。高容错性：Hadoop能够自动保存数据的多个副本，当某个节点宕机时，它可以自动地将副本复制给其他机器，保证数据的完整性。同时，Hadoop能够自动将失败的任务重新分配，确保任务的顺利完成。低成本：Hadoop可以运行在廉价的机器上，集群可以将程序并发处理，从而降低成本，提高效率，是处理海量数据的最佳选择。 Hadoop的生态系统 Hadoop的生态系统
Hadoop生态系统是大数据的核心，同时，Hadoop也是大量工具的合集。它们一起协同完成特定的任务，组成Hadoop的生态圈，在这里，我要讲的是Hadoop生态系统的版本为2.X，如上图所示。
1.HDFS HDFS是Hadoop生态系统的核心组成部分之一，它是一个分布式文件系统，用于存储和管理大规模数据集。HDFS的设计目标是提供高吞吐量的数据访问，适合处理超大规模数据集。它通过将数据分块并分布在集群中的多个节点上来实现数据的分布式存储，同时提供数据复制和容错机制以确保数据的安全性和可靠性。
2.MapReduce MapReduce是Hadoop的另一个核心组件，它是一种编程模型和执行环境，用于处理和分析大规模数据集。MapReduce将复杂的数据处理任务分解为两个主要阶段：Map阶段和Reduce阶段。在Map阶段，系统将数据划分为多个子集，并在集群中的节点上并行处理这些子集。在Reduce阶段，系统对Map阶段的结果进行汇总和合并，生成最终的处理结果。这种并行处理的方式大大提高了数据处理的速度和效率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b34d7cbb000a248071367397633a9c35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b0ca6b8ec427503b4a66fd81c839b8e/" rel="bookmark">
			spark和scala环境安装与部署（超详细版），我保证你敢看，你就学会了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.SPARK简介 Spark是一种基于内存的快速、通用、可扩展的大数据分析计算引擎。
是加州大学伯克利分校AMP实验室（Algorithms, Machines, and People Lab）开发的通用内存并行计算框架Spark得到了众多大数据公司的支持，这些公司包括Hortonworks、IBM、Intel、Cloudera、MapR、Pivotal、百度、阿里、腾讯、京东、携程、优酷土豆。当前百度的Spark已应用于大搜索、直达号、百度大数据等业务；阿里利用GraphX构建了大规模的图计算和图挖掘系统，实现了很多生产系统的推荐算法；腾讯Spark集群达到8000台的规模，是当前已知的世界上最大的Spark集群。
二.spark搭建准备 JDK1.8
Hadoop安装
版本：2.7.7
参考：https://blog.csdn.net/tangyi2008/article/details/121908766
虚拟机完全分布式加hive
三.scala与spark搭建与安装 1）scala下载安装 首先从Scala官网链接：The Scala Programming Language (scala-lang.org)下载scala安装包
all releases 是选择历史版本
在这里选择scala2.12.12版本
如果我们要给虚拟机安装就选择tgz后缀的安装包，如果要给windows安装就选择msi安装包的后缀
我们这边就演示虚拟机的所以我们下载Linux版本。
附上Linux版本的下载链接：https://downloads.lightbend.com/scala/2.12.12/scala-2.12.12.tgz
2）前往spark下载安装包 首先进入官网，官网链接：Apache Spark™ - Unified Engine for large-scale data analytics
下载spark安装包，然后进入download
可以在下载页面的下方进入它的release archives：https://archive.apache.org/dist/spark/ 选择想要的版本。
这里以3.1.1版本为例，我们下载的安装文件应该是形如：spark-3.1.1-bin-xxxxxx.tgz的文件，很多人很困惑如何选择这些版本。
之所以会有这么多版本的选择，是因为Spark需要一些Hadoop客户端的依赖包（需要访问HDFS和YARN）， 这些版本主要分为两类：
pre-packaged binary，将Hadoop客户端的依赖包编译到所下载的压缩包当中，比如spark-2.4.8-bin-hadoop2.6.tgz 和spark-2.4.8-bin-hadoop2.7.tgz ，
“Hadoop free” binary，需要自己通过配置 SPARK_DIST_CLASSPATH 变量，以便可以包含指定版本的Hadoop的相关jar包，比如：spark-3.1.1-bin-without-hadoop-scala-2.12.tgz、spark-2.4.8-bin-without-hadoop.tgz 。
我们这里选择“Hadoop free” binary形式的spark-3.1.1-bin-without-hadoop.tgz进行下载，直接使用浏览器下载过慢，可以使用迅雷加速下载，也可以去后面的网盘资源进行下载
3）上传安装包至虚拟机
我们如果是图形化界面可以进行直接拖拽，如果是mini版本的我们就需要xshell和xftp进行上传，我们这边是mini版本的我们就进行上传
我们用ifconfig命令查看我们主机的ip地址
打开xshell在文件新建中创建一个连接
然后在主机里输入我们刚刚查到的ip
之后我们点击用户身份验证在这里输入我们的用户名和密码即可连接
连接成功后我们选择xftp进行传输
把我们刚刚下载的安装包拖拽到虚拟机中，这里我推荐到opt目录里
3）进行scala的安装配置 解压安装包 tar -zxvf /opt/scala-2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b0ca6b8ec427503b4a66fd81c839b8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef7fb55ef1c8fbf826b472d008634ac2/" rel="bookmark">
			【前端】处理一次性十万条数据渲染方案（不考虑后端分页）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、定时渲染二、触底加载 一、定时渲染 思路：定时加载，分堆处理 1. 例如，前端请求到十五条数据以后，先不直接渲染，而是将这些数据分堆分批次渲染 2. 比如，一堆放10条数据，十万条数据就是一万堆 3. 然后使用定时器一次渲染一堆，渲染一万次即可 核心实现 // 渲染到页面表格的数据 let pagedata = []; const plan = async () =&gt; { // 例如 bigdata 是接口请求到的十万条数据 const bigdata = await getBigDat(); // 分堆处理 let arr = average(bigdata) // 渲染数据 for(let i=0; i&lt;arr.length; i++){ setTimeout(()=&gt;{ pagedata = [...pagedata, ...arr[i]] },20*i) } } const average = (arr) =&gt; { let i = 0; let res = []; while(i &lt; arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef7fb55ef1c8fbf826b472d008634ac2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e91b708f3c7ce3acff4931d8d4c36e10/" rel="bookmark">
			微信开发者工具的安装和使用以及小程序的创建和资源目录介绍（最全！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、安装开发者工具1.1. 了解微信开发者工具1.2. 下载1.3. 安装 二、使用开发者工具2.1. 扫码登录开发者工具2.2. 设置外观和代理 三、创建小程序项目3.1. 点击加号按钮3.2. 填写项目信息并选择模板3.3. 项目创建完成 四、查看项目效果4.1. 在模拟器上查看项目效果4.2. 在真机上预览项目效果 五、主界面的五个部分六、小程序代码的目录结构6.1. 了解项目的基本组成结构6.2. 小程序页面的组成部分6.3. JSON配置文件6.3.1. app.json 文件6.3.2. project.config.json 文件6.3.3. sitemap.json文件6.3.4. 页面的.json配置文件 6.4. 页面的.wxml文件6.4.1. 什么是WXML6.4.2. WXML和HTML的区别 6.5. 项目的.wxss文件6.5.1. 什么是WXSS6.5.2. WXSS和 CSS的区别 6.6. 项目的.js文件 七、快速新建小程序页面八、修改项目首页 一、安装开发者工具 1.1. 了解微信开发者工具 1.2. 下载 推荐下载和安装最新的稳定版(Stable Build)的微信开发者工具，
下载页面的链接如下
1.3. 安装 一路下一步即可，推荐自定义安装目录
二、使用开发者工具 2.1. 扫码登录开发者工具 相关：小程序账号注册登录和AppID的获取
2.2. 设置外观和代理 三、创建小程序项目 3.1. 点击加号按钮 3.2. 填写项目信息并选择模板 相关：小程序账号注册登录和AppID的获取
3.3. 项目创建完成 四、查看项目效果 4.1. 在模拟器上查看项目效果 4.2. 在真机上预览项目效果 五、主界面的五个部分 六、小程序代码的目录结构 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e91b708f3c7ce3acff4931d8d4c36e10/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/44/">«</a>
	<span class="pagination__item pagination__item--current">45/71</span>
	<a class="pagination__item pagination__item--next btn" href="/page/46/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>