<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.126.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程学习者的博客">
		<meta property="og:url" content="https://bcxuexizhe.github.io/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="编程学习者">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6ba672d5af4ba5983efb577377eabe9/" rel="bookmark">
			如何在新版的Android studio中创建Java项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新建项目的时候可能会出现选择不了Java的情况。
可以选择如下图标红的模版（No Activity）来新建项目，但是该模版没有没有activity,需要自己创建。
因为创建了一个 no activity的项目这里需要我们自己创建一个MainActivity.java:
另外当自己创建了MainActivity.java:后，在res/layout/的目录中找到布局文件activity_main.xml
这就和旧版本中，直接使用empty Activity的效果一样
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/077e6499b7044b52c07b16749c092d2d/" rel="bookmark">
			ai绘画免费图生图！这4款画图ai软件好用到爆！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日常想用一张精美的图片来装点工作项目，多数时候会遇到这么一种情况，想下载的图片需要付费，且图库的价格又高到飞起，辛辛苦苦找到的图片最终没法使用，很让人受伤。
但还好我们现在已步入 AI 时代，有了 ai 绘画免费图生图工具的加持，这些问题将不复存在。这些 ai 图生图绘画工具不仅能够帮助你一键生成免费可商用图片，而且还能让你节省大量的时间和精力。接下来就让我们深入了解一下这些神奇的 ai 绘画免费图生图软件，并探索它如何改变我们获取和使用图像的方式。
AI 绘画免费图生图是什么？ AI 绘画免费图生图，即利用 AI 人工智能技术模拟人类绘画过程，创作出具有艺术感的图像。这一技术背后的核心是深度学习和神经网络，尤其是卷积神经网络（CNN）和生成对抗网络（GAN），它们基于大量图像数据的训练，AI 学习并提取图像的特征和风格，从原有的图片迁移到新的图片，最终得到我们想要的效果。
AI 绘画免费图生图的应用场景非常广泛，从艺术创作到商业广告，从免费可商用图片到产品设计，AI 绘画都能提供高效且富有创意的解决方案，它不仅能够模仿过去以及现有的艺术风格，还能创造出前所未有的视觉效果。
*AI绘画免费图生图
AI 绘画免费图生图工具的优势 在众多 AI 绘画工具中，免费图生图工具尤其受到众多用户的欢迎。这些 AI 绘画图生图工具通常具有用户友好的界面设计，使得即便是没有设计背景或者掌握设计技能的用户，也能轻松上手软件的使用。
放在以前，这简直不可想象，而如今随着各类 AI 绘画工具的出现，曾经不可能的事情也逐渐变成现实，这些 AI 工具提供的一键生成图片能力，极大地提高了创作效率，用户只需输入简单的指令（提示词 prompts）或上传参考图像，AI 就能自动生成高质量、免费可商用的图片。
基于 AI 绘画工具生成的免费可商用图片，对于小型企业、初创公司和个人创作者来说，是一个巨大的福音。它不仅节省了设计成本，还避免了版权问题，使得创作者可以自由地将生成的图像用于各类场景，包括商业用途。
主流的 AI 绘画免费图生图工具 了解了 AI 绘画免费图生图工具的优势之后，我们可以来看看市场上主流的 AI 绘画工具，如 Midjourney、Bing Image Creator、boardmix AI、Pixso AI、Stable Diffusion 等，它们各有特色，适用于不同的需求和场景。
① AI 绘画免费图生图工具 boardmix AI boardmix AI，是一款在线的 AI 绘画工具，提供两大核心绘图功能——AI 绘画文生图和 AI 绘画图生图，后者即是 AI 基于已有的或者上传的图片，在配置不同的 AI 绘画模型和参数方式等参数，自动生成新的免费可商用图片。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/077e6499b7044b52c07b16749c092d2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe794351442ee12c80a60b0dabb6c29d/" rel="bookmark">
			kafka消费数据，有时消费不到原因？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kafka消费数据时有时消费不到的原因可能包括以下几点：
1：配置问题：首先需要检查Kafka的配置是否正确，比如是否设置了group.id ，对应的topic是否正确等。如果消费者尝试消费不存在的主题，则会发生错误。
2：消费者群组配置错误：如果消费者所属的消费群组配置错误，也可能导致无法消费数据。
3：生产速度与消费速度不匹配：如果生产速度过快而消费过慢，或者反之，都可能导致消息积压，从而影响到消费者的正常消费。
4：消费者处理能力不足：如果消费者的处理能力不足，例如处理逻辑复杂、计算密集，或者消费者数量较少，无法充分利用集群的并发处理能力，也会导致消费速度慢。
5：网络问题：由于网络问题，可能导致重复消费，因此消费者需要实现消费幂等。
6：下游数据处理不及时：如果是下游的数据处理不及时，也会导致Kafka消费能力不足。7：消费者客户端启动后未消费消息：如果发现一个消费者客户端已经启动了，但是就是不消费消息，应该检查该消费者所在的组中是否还有其他的消费者。
综上所述，解决Kafka消费数据不到的问题，需要从多个方面进行排查和优化，包括但不限于检查配置、调整生产与消费的速度匹配、提高消费者的处理能力、确保网络稳定以及及时处理下游数据等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70f620f720ab92b3d48f3efeb0ca05ce/" rel="bookmark">
			一个傻瓜式构建可视化 web的 Python 神器 ——streamlit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3.3 原生图表组件
Streamlit 原生支持多种图表：
st.line_chart：折线图
st.area_chart：面积图
st.bar_chart：柱状图
st.map：地图
下面一一展示
折线图
chart_data = pd.DataFrame(
np.random.randn(20, 3),
columns=[‘a’, ‘b’, ‘c’])
st.line_chart(chart_data)
面积图
chart_data = pd.DataFrame(
np.random.randn(20, 3),
columns = [‘a’, ‘b’, ‘c’])
st.area_chart(chart_data)
柱状图
chart_data = pd.DataFrame(
np.random.randn(50, 3),
columns = [“a”, “b”, “c”])
st.bar_chart(chart_data)
地图
df = pd.DataFrame(
np.random.randn(1000, 2) / [50, 50] + [37.76, -122.4],
columns=[‘lat’, ‘lon’]
)st.map(df)
3.4 外部图表组件
Streamlit 的一些原生图表组件，虽然做到了傻瓜式，但仅能输入数据、高度和宽度，如果你想更漂亮的图表，就像 matplotlib.pyplot、Altair、vega-lite、Plotly、Bokeh、PyDeck、Graphviz 那样，streamlit 也提供了支持：
st.pyplot
st.bokeh_chart
st.altair_chart
st.altair_chart
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70f620f720ab92b3d48f3efeb0ca05ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d5340d114fad4f3d2ddd61dc717981e/" rel="bookmark">
			Linux 安装 MySQL【CentOS】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装 MySQL 的准备工作 1. 查看系统版本 cat /etc/redhat-release 2. 查看系统是否已经安装过 MySQL 查看是否安装了 MySQL
rpm -qa | grep mysql 查看是否有安装 mariadb，该软件与 MySQL 数据库有冲突，需要手动卸载
# 如果是 CentOS7 可以检测出已经安装了 mariadb rpm -qa | grep mariadb 3. 移除 MySQL 相关的软件 如果系统中没有安装过与 MySQL 相关的软件，直接跳到下一步
rpm -e --nodeps mariadb-libs-5.5.68-1.el7.x86_64 二、安装 MySQL 官网传送门
1. 找到压缩包的下载链接 点击 MySQL Community Server
选择 MySQL 的版本
注意 MySQL 的版本需要与 Linux 的版本对应上
centos7 系统对应的 MySQL 是 el7centos8 系统对应的 MySQL 是 el8 一般情况下，直接选择第一个安装包即可，第一个安装包的版本会不定时的更新，与本文所用的安装包有略微的差别，但是并不影响具体的使用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d5340d114fad4f3d2ddd61dc717981e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a60bed5e26bd5768db0b135b3200acb3/" rel="bookmark">
			javaSE-----继承和多态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.初识继承：
1.1什么是继承，为什么需要继承：
1.2继承的概念与语法：
二.成员的访问：
2.1super关键字
2.2this和super的区别：
三.再谈初始化:
小结：
四.初识多态：
4.1多态的概念：
4.2多态的实现条件：
一.初识继承： 1.1什么是继承，为什么需要继承： Java中使用类对现实世界中实体来进行描述，类经过实例化之后的产物对象，则可以用来表示现实中的实体，但是现实世界错综复杂，事物之间可能会存在一些关联，那在设计程序是就需要考虑。👌👌👌 那具体来说是怎么样的呢？🧐🧐🧐举个例子，比如猫狗，他们都是一个动物： 用Java语言来描述就是：
class Cat{ public String name; public int age; public Cat(String name, int age) { this.name = name; this.age = age; } public void eat(){ System.out.println(this.name+"正在吃！"); } } class Dog{ public String name; public int age; public Dog(String name, int age) { this.name = name; this.age = age; } public void eat(){ System.out.println(this.name+"正在吃！"); } } public class Test1 { public static void main(String[] args){ Dog dog = new Dog("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a60bed5e26bd5768db0b135b3200acb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/893dc15f48834e627eec80de210df9a2/" rel="bookmark">
			此应用与最新版Android不兼容。请检查是否有更新，或与应用开发者联系。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当你打开app的时候，突然弹窗提醒你
是不是一脸懵逼？
别慌！请继续往下看。。。
原因：不兼容android14版本
解决：
一般情况下ndk的配置是这样的：
ndk { abiFilters 'armeabi-v7a' } 为了兼容android14，需要再加一个 'arm64-v8a'，如下：
ndk { abiFilters 'armeabi-v7a' , 'arm64-v8a' } 如此便可解决问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b671805a7ba0193a390807e3bbcdd778/" rel="bookmark">
			Python 数据持久层ORM框架 TorToise模块（异步）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Tortoise ORM 简介Tortoise ORM 特性Tortoise ORM 安装Tortoise ORM 数据库支持Tortoise ORM 创建模型aerich 迁移工具简介aerich 迁移工具安装aerich 迁移工具使用Trotoise ORM 查询数据Trotoise ORM 修改数据Trotoise ORM 删除数据Trotoise ORM 新增数据 Tortoise ORM 简介 Tortoise ORM 是一个为异步Python应用设计的ORM（对象关系映射）库；
它允许开发者以面向对象的方式与关系型数据库进行交互，同时充分利用异步编程的优势来提高应用的性能和响应速度；
Tortoise ORM 支持多种数据库后端，如PostgreSQL、MySQL和SQLite等。
核心概念
模型（Models）：Tortoise ORM 使用Python类来定义数据库中的表结构。每个类代表一个数据库表，类的属性对应表中的列。字段（Fields）：在模型中定义字段，这些字段映射到数据库表的列。Tortoise ORM 提供了多种字段类型，如整型、字符串型、日期型等。关系（Relations）：Tortoise ORM 支持定义模型之间的关系，如一对一、一对多、多对多等。异步操作：所有数据库操作都是异步的，使用async和await关键字来执行。 应用场景
构建高性能的异步Web应用，如使用FastAPI、Sanic或Starlette的应用；需要面向对象方式操作数据库的项目。需要异步数据库访问以提高应用性能的场景。 核心功能
模型定义：通过Python类定义数据库表结构。数据查询：支持复杂的查询构建和执行。数据操作：支持创建、更新、删除数据库记录。关系管理：支持定义和查询模型之间的关系。迁移和同步：提供数据库迁移工具，用于管理数据库模式的变更。 Tortoise ORM 特性 异步特性：Tortoise ORM 的所有数据库操作都是异步的，这意味着它们可以在单线程中同时处理多个数据库请求，而不会阻塞彼此。这大大提高了应用的并发性和性能。模型定义：在Tortoise ORM 中，开发者使用Python类来定义数据库表结构。这些类中的属性对应于数据库表中的列，这使得数据库操作更加直观和易于理解。查询构建：Tortoise ORM 提供了强大的查询构建功能，允许开发者构建复杂的查询条件，以检索所需的数据。这包括使用链式调用、比较运算符、逻辑运算符等。关系映射：Tortoise ORM 支持定义模型之间的关系，如一对一、一对多、多对多等。这使得开发者可以轻松地处理复杂的数据关系，并在代码中以直观的方式表示它们。迁移和同步：Tortoise ORM 还提供了数据库迁移工具，用于管理数据库模式的变更。这使得在应用开发过程中，可以轻松地添加、修改或删除表结构，而无需手动编写SQL语句。 Tortoise ORM 安装 Tortoise ORM 属于Python的第三方库，需要额外下载安装，命令如下：
pip install tortoise-orm Tortoise ORM 数据库支持 SQLite
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b671805a7ba0193a390807e3bbcdd778/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47c8fcccd7ab94ddce8782e55be70749/" rel="bookmark">
			深入理解 package.json 文件与 package-lock.json 文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是 package.json文件?
二、什么是 package-lock.json文件?
三、为什么有了package.json，还需要package-lock.json文件呢？
四、项目中如何生成package.json 和 package-lock.json 文件？
五、npm 安装包的方式
六、npm install 后发生了什么？
七、node 包版本号
八、版本符号含义
一、什么是 package.json文件? package.json 文件一般都在每个项目的根目录下面，定义了这个项目所需要的各种模块，以及项目的配置信息，包括名称、版本、许可证、依赖模块等元数据。格式是严格的JSON格式。
当你执行 npm install 的时候，node 会先从 package.json 文件中读取所有 dependencies 信息，然后根据 dependencies 中的信息与 node_modules 中的模块进行对比，没有的直接下载，已有的检查更新。另外，package.json 文件只记录你通过 npm install 方式安装的模块信息，而这些模块所依赖的其他子模块的信息不会记录。这样让我们远离了依赖地狱！
二、什么是 package-lock.json文件? package-lock.json 文件会保存 node_modules 中所有包的信息，包括精确版本 version 和下载地址 resolved 以及依赖关系 dependencies 等，用以记录当前状态下实际安装的各个模块的具体来源和版本号。这样 npm install 时速度就会提升。
npm5 以前没有 package-lock.json 这个文件，需要保存依赖信息，每次安装时都要加上 --save 参数；npm5以后版本加入了 package-lock.json 文件。当安装包的时候，不需要加上 --save 参数，它会自动保存依赖信息，且会生成或更新 package-lock.json 这个文件。
三、为什么有了package.json，还需要package-lock.json文件呢？ 当项目中已有package-lock.json 文件，在安装项目依赖时，将以该文件为主进行解析安装指定版本依赖包，而不是使用 package.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47c8fcccd7ab94ddce8782e55be70749/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f55e28afc2445086e8d7633494beac16/" rel="bookmark">
			MySQL中replace into详解、批量更新、不存在插入存在则更新、replace into的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、replace into原理二、`replace into`的三种形式三、replace into 使用案例3.1、replace into values3.1.1、只有主键且主键冲突3.1.2、有主键有唯一索引且主键冲突3.1.3、有主键有唯一索引且唯一索引冲突(有坑)3.1.4、有主键有唯一索引且与一条主键冲突与另一条唯一键冲突(有坑) 3.2、replace into select3.3、replace into set3.3.1、唯一索引不重复3.3.2、唯一索引重复 四、replace into与on duplicate key update的区别五、replace into的坑5.1、replace into与自动更新时间的坑5.2、replace into用唯一索引更新时会导致自增值+15.3、replace into同时有主键或唯一索引冲突时可能会删除多条记录 官网地址：https://dev.mysql.com/doc/refman/8.0/en/replace.html
以下内容基于mysql 8.0版本进行讲解。
replace into与on duplicate key update在一定程度上都能实现无记录时插入，有记录时更新这个需求。但是强烈推荐使用on duplicate key update 原因见下方两者的区别。replace into的坑太多，若要使用请详细阅读本文。
一、replace into原理 replace into 跟 insert 功能类似，不同点在于：replace into 首先尝试插入数据到表中， 1. 如果发现表中已经有此行数据（根据主键或者唯一索引判断）则先删除此行数据，然后插入新的数据。 2. 否则，直接插入新数据。
要注意的是：插入数据的表必须有主键或者是唯一索引！否则的话，replace into与insert into功能一致，会直接插入数据，这将导致表中出现重复的数据。
如果归纳一下 REPLACE INTO 语句的执行规则，基本会有以下几种情况：
当表没有主键和唯一键时，REPLACE INTO 相当于普通的 INSERT 操作；binlog 记录事件为 INSERT；返回影响行数为 INSERT 的数量。当表有主键没有唯一键时，REPLACE INTO 插入记录与主键冲突时会进行 DELETE+INSERT 操作；binlog 记录事件为 UPDATE；返回影响行数为 DELETE+INSERT 的数量；如果主键自增，则 AUTO_INCREMENT 值不变。当表有唯一键没有主键时，REPLACE INTO 插入记录与唯一键冲突时会进行 DELETE+INSERT 操作；binlog 记录事件为 UPDATE；返回影响行数为 DELETE+INSERT 的数量。当表同时存在主键和唯一键时，REPLACE INTO 插入记录与主键冲突的时候进行 DELETE+INSERT 操作；binlog 记录事件为 DELETE+INSERT；返回影响行数为 DELETE+INSERT 的数量。如果主键自增，则 AUTO_INCREMENT 值不变。当表同时存在主键和唯一键时，REPLACE INTO 插入记录与唯一键冲突的时候进行 DELETE+INSERT 操作；binlog 记录事件为 UPDATE；返回影响行数为 DELETE+INSERT 的数量。如果主键自增，则新插入的这条记录的主键会变成最新 AUTO_INCREMENT 的值，而对应的 AUTO_INCREMENT 值会 +1。当表同时存在主键和唯一键时，REPLACE INTO 插入记录与一条记录主键和一条记录唯一键都冲突的时候进行 DELETE+INSERT 操作；binlog 记录事件为 DELETE+UPDATE；返回影响行数为 DELETE*2+INSERT 的数量。 第五点会有副作用：见本文《3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f55e28afc2445086e8d7633494beac16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c1783cf9174763c7f443e5b97709ff0/" rel="bookmark">
			Android识别模拟器，判断是模拟器还是真机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 原理
禁止模拟器安装apk
代码识别
验证
最后
前言 对于android开发者来说，模拟器是开发工具，但是对用户来说，可能就是薅羊毛、找漏洞的赚钱工具。
不管是活动风控还是内容保护等等其他的出发点，应要求可能会要识别Android模拟器，甚至禁止模拟器登录或后续操作。
今天做个简单的探讨。
原理 识别模拟器的原理，其实就是找出模拟器和真机的差别，但是这些差别体现在哪呢，比如运营商、手机卡、蓝牙、各种传感器等等。
但是现在的模拟器也是越来越厉害了，可以模拟不同品牌的不同型号的不同版本的手机，而且有蓝牙、可以打电话。
是不是很头疼，一不小心就会误判了，所以现在市面上有一种方案也是根据模拟器和真机差别的次数来做一个容错机制，比如模拟器和真机超过3个差别，就判为模拟器。
但是实际上，有的老版本手机甚至还不如模拟器先进…所以容错机制中还可以加上对用户的区别对待，个别用户不检测等等。
禁止模拟器安装apk 模拟器一般的cpu架构都是x86的，我们可以在build.gradle中去掉对x86的支持。
ndk {
// 设置支持的SO库架构
abiFilters ‘armeabi-v7a’, ‘arm64-v8a’
}
当然也有一些手机可能也是x86的，这就误判了，因为目前来说还没有比较完善的解决方案，所以前面所说的容错机制就比较重要了。
自我介绍一下，小编13年上海交大毕业，曾经在小公司待过，也去过华为、OPPO等大厂，18年进入阿里一直到现在。
深知大多数初中级安卓工程师，想要提升技能，往往是自己摸索成长，但自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年最新Android移动开发全套学习资料》送给大家，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友，同时减轻大家的负担。
由于文件比较大，这里只是将部分目录截图出来，每个节点里面都包含大厂面经、学习笔记、源码讲义、实战项目、讲解视频
如果你觉得这些内容对你有帮助，可以添加下面V无偿领取！（备注Android）
学习分享 在当下这个信息共享的时代，很多资源都可以在网络上找到，只取决于你愿不愿意找或是找的方法对不对了
很多朋友不是没有资料，大多都是有几十上百个G，但是杂乱无章，不知道怎么看从哪看起，甚至是看后就忘
如果大家觉得自己在网上找的资料非常杂乱、不成体系的话，我也分享一套给大家，比较系统，我平常自己也会经常研读。
2021最新上万页的大厂面试真题
七大模块学习资料：如NDK模块开发、Android框架体系架构…
只有系统，有方向的学习，才能在段时间内迅速提高自己的技术。
这份体系学习笔记，适应人群：
**第一，**学习知识比较碎片化，没有合理的学习路线与进阶方向。
**第二，**开发几年，不知道如何进阶更进一步，比较迷茫。
**第三，**到了合适的年纪，后续不知道该如何发展，转型管理，还是加强技术研究。如果你有需要，我这里恰好有为什么，不来领取！说不定能改变你现在的状态呢！
由于文章内容比较多，篇幅不允许，部分未展示内容以截图方式展示 。如有需要获取完整的资料文档的朋友点击我的【GitHub】免费获取。 状态呢！
由于文章内容比较多，篇幅不允许，部分未展示内容以截图方式展示 。如有需要获取完整的资料文档的朋友点击我的【GitHub】免费获取。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a617710af5cba817aded80dc1f8fa74f/" rel="bookmark">
			QT5.14.2深入解析Qt QProcess用法之彻底掌控进程操作技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过今天的文章，我将带领大家彻底理解和掌握Qt QProcess的使用技巧，这将成为你控制进程的利器。我们的讨论将通过明确的示例，详细的代码案例，结合我在实际软件开发经验中遇到的问题进行说明。
1、Qt QProcess - 什么是进程? 在理解Qt QProcess之前，让我们先了解什么是进程。进程是操作系统的一个核心概念。当程序在执行时，它将产生多个进程，每个进程都有自己独立的数据空间，这样就可以同时有多个用户执行同一程序，而不会产生冲突。进程的状态有：新生、执行、等待、就绪和结束。每个进程都有自己的唯一标识符，我们称之为PID。
2、Qt QProcess - 如何操作？ 在Qt中，我们可以使用QProcess类来操作进程。这个类包含一系列功能丰富的函数，用于启动并控制外部进程。QProcess是QIODevice的子类，这让我们可以使用各种I/O函数来交互，并使得传输变得轻而易举。
3、QProcess实例 - 打开文本编辑器 以下是在Windows系统下如何用QProcess打开文本编辑器的简单示例。在这个例子中，我们设定了工作目录为"C:\Windows\System32"，然后启动"notepad.exe"程序并等待它结束。
QString filename="TEST.txt"; QProcess process; process.setWorkingDirectory("C:\\Windows\\System32"); process.start("notepad.exe", QStringList()&lt;&lt;filename); process.waitForFinished(-1); //等待进程结束 4、QProcess更多功能 - 利用信号和槽 Qt的一个主要特点是其信号和槽的机制，QProcess也不例外。你可以连接各种信号，比如started()、finished()、stateChanged()等，到你的槽函数中去进行响应。
例如，可以这样处理started和finished信号：
process = new QProcess(); connect(process, SIGNAL(started()), SLOT(started())); connect(process, SIGNAL(finished(int,QProcess::ExitStatus)), SLOT(finished())); 然后在槽函数中可以获取返回的数据和状态，比如：
void Widget::finished(intexitCode,QProcess::ExitStatus exitStatus) { qDebug()&lt;&lt;"finished"; qDebug()&lt;&lt;exitCode; // 被调用程序的main返回的int qDebug()&lt;&lt;exitStatus; // QProcess::ExitStatus(NormalExit) qDebug() &lt;&lt;"finished-output-readAll:"; qDebug()&lt;&lt;QString::fromLocal8Bit(process-&gt;readAll()); qDebug()&lt;&lt;"finished-output-readAllStandardOutput:"; qDebug()&lt;&lt;QString::fromLocal8Bit(process-&gt;readAllStandardOutput()); } 5、QProcess注意事项 （1）、关于start和startDetached
在QProcess中，start()和startDetached()函数提供了两种不同的启动进程的方式。虽然他们在大部分情况下能达到相同的效果，但在某些方面有着重要的不同。具体如下：
生命周期：start()函数创建的进程的生命周期与创建它的QProcess对象的生命周期相绑定。也就是说，当QProcess对象被销毁时，由它启动的进程也会被销毁。相比之下，startDetached()函数则会创建一个独立的进程，即使创建它的QProcess对象被销毁，启动的进程也会继续运行。
输入/输出：只有start()启动的进程可以使用QProcess类的一些重要功能。例如，使用setStandardInputFile()设置进程的标准输入，或者用readAllStandardOutput()和readAllStandardError()来获取进程的标准输出和标准错误。而startDetached()启动的进程则没有这样的功能，它的输入/输出不能由创建它的QProcess对象所控制。
进程间通信：start()启动的进程可以利用QProcess的信号/槽机制进行通信，例如用readyReadStandardOutput()和readyReadStandardError()信号获取到输出信息，并进行处理。而startDetached()则无法实现此类通信。
所以说，从上面的说明中，如果你需要对创建的进程进行控制的话，推荐使用start()函数。而如果你只是需要创建一个独立的进程，那么startDetached()可能会是更好的选择。
（2）、在QProcess中如何处理进程错误信息？
在QProcess中处理进程错误信息主要依靠信号和槽的机制实现。QProcess得到了很好的封装，因此，当有错误发生的时候，会发出errorOccurred信号。
下面是一段示例代码，提交了一个错误的外部进程路径，我们用errorOccurred信号来捕获错误，并在槽函数中处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a617710af5cba817aded80dc1f8fa74f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7811950b82d0ba72c619a0bc7c65ab2c/" rel="bookmark">
			数据大屏---＞前端实时更新数据的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考文章:实时数据更新 一、轮询:简单来说轮询就是客户端不停地调用服务端接口以获得最新的数据 1、短轮询:每隔3s向服务器发送一次请求- - -请求数据 优点:最大的优点就是实现简单 缺点:(1)无用的请求多,客户端不知道服务端什么时候数据更新,只能不停的向服务端发送请求, (2)数据实时性差:客户端还是需要一段时间(3s)才能拿到最新的数据 2、长轮询:长轮询，客户端发起请求后，服务端发现当前没有新的数据，这个时候服务端没有立即返回请求，而是将请求挂起，在等待一段时间后(一般为30s或者是60s)，发现还是没有数据更新的话，就返回一个空结果给客户端。客户端在收到服务端的回复后，立即再次向服务端发送新的请求。这次服务端在接收到客户端的请求后，同样等待了一段时间，这次好运的是服务端的数据发生了更新，服务端给客户端返回了最新的数据。客户端在拿到结果后再次发送下一个请求，如此反复。 优点:解决了短轮询每隔几秒向服务端频繁发送请求的问题; 缺点:(1)服务端资源大量消耗,服务端数据未更新时需要挂起客户端的请求 (2)难以处理数据更新频繁的情况 二、webSocket:用最简单的话来介绍WebSocket就是：客户端和服务器之间建立一个持久的长连接，这个连接是双工的，客户端和服务端都可以实时地给对方发送消息。首先客户端会给服务端发送一个HTTP请求，这个请求的Header会告诉服务端它想基于WebSocket协议通信，如果服务端支持升级协议的话，会给客户端发送一个Switching Protocal的响应，它们之间后面都是基于WebSocket协议来通信了。—需要服务端配合操作; webSocket优点: (1)客户端和服务端建立的连接次数小,理想情况下客户端只需要发送一个HTTP升级协议就可以升级到WebSocket连接,后面的消息推送都是通过这个通道进行通信,无需再次建立连接. (2)消息实时性高:因为客户端和服务端的连接一直是建立的,而且是全双工通信; 缺点:某些代理层软件(如Nginx)默认配置的长连接时间是有限制的，可能只有几十秒，这个时候客户端需要自动重连。要想突破这个限制你就需要将从客户端到服务端之间所有的代理层的配置都改掉，在现实中这可能是不可行的; 三、SSE(server-sent Events) 是一个基于HTTP协议的服务端向客户端推送数据的技术,单向—股票推送 客户端向服务端发起一个持久化的HTTP连接，服务端接收到请求后，会挂起客户端的请求，有新消息时，再通过这个连接将数据推送给客户端。需要注意的是和WebSocket长连接不同，SSE的连接是单向的，也就是说它不允许客户端向服务端发送消息。 优点: (1)连接次数小,一般客户端和服务端只有一个持久的HTTP连接,因此性能也是很好的 (2)数据实时性高:因为服务端和客户端是持久的连接,所以有新消息的话可以直接推送到客户端; 缺点:(1)单向通信:SSE建立的HTTP长连接是单向的,不允许客户端向服务端推送数据 (2)配置错误的话，客户端需要不断和服务端进行重连. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc09a98b8f58045ba6149d74ccca89d6/" rel="bookmark">
			【已解决】MySQL（Navicat）中如何一次性执行多个sql脚本文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
问题现象：
问题分析：
思路：
解决方法：
1、运行cmd命令窗口
2、执行文本文件内容合并命令
总结：
1、使用文本文件内容合并命令，将多个sql脚本文件的内容合并到一个新的sql文件中去。
2、然后在Navicat中打开对应数据库，运行该合并后的sql脚本文件即可。
问题现象： 今天在项目中遇到一个问题，有一个同事导出了项目A用到的所有数据库的所有表的sql文件（没有根据数据库分开存放，而是全部放在了同一个文件夹中），然后需要我按照sql文件前缀（前缀就是数据库名）来导入到项目B中对应的数据库去，sql文件如下：
所以就引出了本文的标题：
MySQL中如何一次性执行多个sql脚本文件？
问题分析： 当时接到这个任务，第一时间想到的就是：
在Navicat中在对应的数据库下，运行sql文件皆可：
但是感觉这样的一个文件一个文件地运行效率实在太低了，会浪费很多时间啊！因为同事给我的sql脚本文件压缩包里面有近200个sql文件。
于是我就去查资料，想看看Navicat中是否有点击一次按钮就能批量运行多个sql文件的功能？
很遗憾，我用的Navicat15没有这个功能！那估计Navicat目前应该是不支持这种一次性运行多个sql文件的功能。
那该如何是好？难道我真的要用最笨的方法：一个文件一个文件地去运行？
不信邪的我，再次上网查资料，最后发现了一个也很方便的方法，非常好的解决了我的问题！
思路： 既然Navicat中不支持一次性运行多个sql文件，那有没有办法可以把所有的sql文件中的sql都归纳到同一个汇总的sql文件去，然后在Navicat中运行这个汇总的sql文件不就可以了吗！！！
那就只需要查一下文本文件内容合并的命令就可以了。
很快我就查到了Windows系统中实现文本文件内容合并的命令，如下：
type 指定需要合并的文件 &gt;&gt;合并后的文件名 当然这里如果追求更高效率的话，建议学习一点文件检索相关的基础命令知识，因为我希望可以有命令能帮我检索出我需要合并的文件；因为我这200多个sql文件都来自于不同的数据库，我需要根据sql文件名的前缀，去检索出我在每个数据库中对应的需要用到的文件，然后将他们合并到一个sql文件中去，然后再去Navicat中对应的数据库执行这个合并后的sql文件即可。
至此，就相当于间接地解决了本文开头提出的问题！
然后由于数据库不同，不可能在一个数据库下去执行所有的sql脚本文件，所以需要根据对应的数据库名来检索对应的文件并生成对应的sql合并文件才行；但一般的项目中用到的数据库基本都不会超过20个。
解决方法： 1、运行cmd命令窗口 在200多个sql脚本文件所在目录中打开cmd命令窗口（直接在地址栏输入cmd然后按下enter键即可）：
2、执行文本文件内容合并命令 在打开的cmd窗口中执行命令如下：
type app_hp_*.sql &gt;&gt;app_hp.sql 意思是把所有文件名前缀为【app_hp_】的文本文件的内容都合并到一个新文件【app_hp.sql】中：
此时可以看到红框中的文件就是本次匹配到的sql文件，然后在当前文件目录下会生成了一个新的文件，即我们合并操作后的新文件【app_hp.sql】：
最后就是在Navicat中，根据数据库执行对应的sql文件即可：
执行完就能看见刚才匹配到的那3个sql脚本文件对应的表了：
总结： 目前我还未找到MySQL（Navicat）中一次性执行多个sql脚本文件的直接解决方法，但是找到了间接的解决方法：
1、使用文本文件内容合并命令，将多个sql脚本文件的内容合并到一个新的sql文件中去。 2、然后在Navicat中打开对应数据库，运行该合并后的sql脚本文件即可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29b6b44d41eac272f75562d6251bc032/" rel="bookmark">
			hashcat密码p解工具安装及使用（非常详细）零基础入门到精通，收藏这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hashcat是一款强大的密码p解工具，可以通过不同的攻击模式来p解各种加密算法（如MD5、SHA1\SHA256、MYSQL、PDF等）的密码。以下是Hashcat的安装及使用指南：
hashcat下载安装 从hashcat官网(https://hashcat.net/hashcat/)下载所需版本 当前最新版本为V6.2.6 ，binaries为直接安装使用版本 sources需要编译后安装。下载完成后，解压安装包即可在命令行使用，hashcat无图像化界面，所有命令通过cmd执行
打开cmd 进入安装包文件夹所在目录（本文为D盘：download/下） 后续可根据需求将路径加入到环境变量，这样便可以随时执行hashcat命令 hashcat 常见命令 hashcat -h 帮助命令 hashcat -a 攻击模式 0 Straight 直接p解 直接使用字典文件中的密码进行破解，逐个尝试每个密码。
1 Combination 组合攻击 将两个或多个字典文件中的密码进行组合，生成新的密码进行p解
3 Brute-force 掩码暴力p解
6 Hybrid Wordlist +Mask 混合攻击：字典+掩码，将字典中密码与指定掩码结合p解
7 Hybrid Mask + Wordlist 混合攻击：掩码+字典，先使用掩码模式生成密码，再与字典中密码结合p解
9 Association 联合攻击 结合多种攻击方式，如暴力p解、字典攻击等，以提高破解的效率和成功率
hashcat -V 查看版本 hashcat -m 查看哈希类型 内置字符
例如：?d?d?d?d?d?d?d?d?d 代表8位纯数字密码
?d?d?d?d?l?u 代表6位密码，前四位为纯数字，第五位为小写字母，第六位为大写字母 -force
忽略p解过程中的警告信息
-increment
启用增量p解模式,让hashcat在指定的密码长度范围内执行p解
Hashcat-m 1800 hashfile --increment --increment-min 6--increment-max 8 ?d?d?d?d?d?d?d?d ##破解hashfiel中纯数字密码，最小范围6位，最大8位 `黑客&amp;网络安全如何学习
今天只要你给我的文章点赞，我私藏的网安学习资料一样免费共享给你们，来看看有哪些东西。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29b6b44d41eac272f75562d6251bc032/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/569796e09b6197e1d7c0b90f00c7f309/" rel="bookmark">
			在虚拟机中进入hive出现ConnectException拒绝连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果输入进入hive的命令后出现以下问题
是因为没有开启HDFS，输入执行start-dfs.sh，然后再执行hive命令即可进入
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fccabdc2e2f3d56be9a7876314aa878/" rel="bookmark">
			【ESP32接入国产大模型之文心一言】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 怎样接入文心一言 视频讲解：
【ESP32接入国产大模型之文心一言】
【ESP32接入国产大模型之MiniMax】
【ESP32接入语言大模型之智谱清言】
【ESP32接入国产大模型之文心一言】
【ESP32接入语言大模型之通义千问】
下面是不标准测评，参考而已
模型响应时间内容质量免费token次数地址MiniMax3s8分500万https://www.minimaxi.com/智谱清言7s8分300万https://open.bigmodel.cn/文心一言10s9分500万https://cloud.baidu.com/doc/WENXINWORKSHOP/s/Nlks5zkzu通义千问8s8分800万https://tongyi.aliyun.com/qianwen/ 随着人工智能技术的不断发展，自然语言处理领域也得到了广泛的关注和应用。在这个领域中，文心一言作为一款强大的自然语言处理工具，具有许多重要的应用价值。本文将重点介绍如何通过ESP32接入国产大模型之文心一言api，以及其中的重点词汇或短语。
1.1 了解文心一言 文心一言是百度打造出来的人工智能大语言模型，具备跨模态、跨语言的深度语义理解与生成能力，文心一言有五大能力，文学创作、商业文案创作、数理逻辑推算、中文理解、多模态生成，其在搜索问答、内容创作生成、智能办公等众多领域都有更广阔的想象空间。文心一言企业服务由千帆大模型平台提供，包括推理服务及大模型微调等一系列开发和应用工具链。文心一言大模型现已升级至4.0，企业客户可通过百度智能云千帆大模型平台申请接入。
1.2 接入文心一言 API 列表
百度智能云千帆平台提供了丰富的API，保留对话Chat、续写Completions、向量Embeddings、插件应用、Prompt工程、大模型训练、管理及服务等API能力，详情请查看API列表。
大模型相关 对话Chat：支持创建chat，用于发起一次对话。续写Completions：支持创建completion，用于发起一次续写请求，不支持多轮会话等。向量Embeddings：支持Embeddings，用于根据输入内容生成对应的向量表示。自定义模型导入：支持HuggingFace Transformer架构的自定义模型导入，提供自定义模型导入相关API能力。图像Images：提供图像相关API能力。 插件应用：提供域内知识搜索增强插件API相关能力。Prompt工程：提供模版相关API能力。大模型训练：提供创建训练任务、任务运行、停止任务运行及获取任务运行详情等API能力。大模型管理：提供获取模型、模型版本详情及将训练任务发布为模型等API能力。大模型服务：提供创建服务、获取服务详情等API能力。 1.3 API 调用流程简介 API 的调用流程如下图所示。
创建一个千帆应用。根据实际需求创建千帆应用，创建成功后，获取AppID、API Key、Secret Key 等信息。API 授权。对应用的 AppID 进行授权。获取接口访问凭证 access_token 。根据第1步获取的 API Key 和 Secret Key ，调用获取access_token接口获取 access_token ，通过 access_token 鉴权调用者身份。调用API接口。例如调用ERNIE-Bot相关接口，详见API列表。 1.4 API 调用流程 1.4.1 步骤一. 创建千帆应用 （1）登录百度智能云千帆控制台。
请您注册并登录百度智能云千帆控制台 。
注意：为保障服务稳定运行，账户最好不处于欠费状态。
（2）创建千帆应用
进入控制台创建应用 。
（3）创建应用后，获取AppID、API Key、Secret Key。
1.4.2 步骤二. 服务授权 应用创建后，选择对应授权的公有云服务。
1.4.3 步骤三. 调用API接口 调用千帆提供的相关接口，如ERNIE-Bot等，详见API列表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fccabdc2e2f3d56be9a7876314aa878/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f34836ae25627386458ae2c8ce8d9a09/" rel="bookmark">
			头歌｜HBase的安装与简单操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第1关：Hbase数据库的安装 mkdir /app cd /opt tar -zxvf hbase-2.1.1-bin.tar.gz -C /app vim /app/hbase-2.1.1/conf/hbase-env.sh !!!进入vim界面按i进入编辑模式，将第28行的： # export JAVA_HOME=/usr/java/jdk1.8.0/ 换成： export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_111 !!!按ESC键退出编辑模式，按：再按wq，最后按回车保存退出 vim /app/hbase-2.1.1/conf/hbase-site.xml !!!进入vim界面按i进入编辑模式，在&lt;configuration&gt;标签中添加如下内容： &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;file:///root/data/hbase/data&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt; &lt;value&gt;/root/data/hbase/zookeeper&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.unsafe.stream.capability.enforce&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt; !!!按ESC键退出编辑模式，按：再按wq，最后按回车保存退出 vim /etc/profile !!!进入vim界面按i进入编辑模式，在文件末尾添加如下内容： # SET HBASE_enviroment HBASE_HOME=/app/hbase-2.1.1 export PATH=$PATH:$HBASE_HOME/bin !!!按ESC键退出编辑模式，按：再按wq，最后按回车保存退出 source /etc/profile start-hbase.sh 第2关：创建表 需要在第一关运行成功的条件下进行
hbase shell create 'test','data' create 'dept','data' create 'emp','data' 第3关：添加数据、删除数据、删除表 需要在第一、二关运行成功的条件下进行
hbase shell create 'mytable', 'data' put 'mytable', 'row1', 'data:1', 'zhangsan' put 'mytable', 'row2', 'data:2', 'zhangsanfeng' put 'mytable', 'row3', 'data:3', 'zhangwuji' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51ec911566092ed90b1e154ef07f556d/" rel="bookmark">
			论文撰写新利器：AI工具大集合，助你高效完成学术创作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文撰写新利器：AI工具大集合，助你高效完成学术创作 在学术研究的道路上，撰写论文无疑是一项既费时又费力的任务。幸运的是，随着人工智能技术的飞速发展，现在有了一系列AI工具，它们能够帮助我们高效地完成论文撰写工作。以下是几款你可能会发现非常有用的AI论文辅助工具。
学薯达：快速生成初稿 网址：学薯达
学薯达是一个提供快速论文初稿生成服务的平台。它不仅价格亲民，而且处理速度迅速，能够根据用户输入的新文献资料，快速整合信息，生成论文初稿。这个工具特别适合需要在短时间内完成大量写作任务的研究人员。
演示案例：B站视频 视频链接：2024年超强AI写论文
在这个B站视频中，你可以看到一个关于AI写作工具的演示案例。视频详细介绍了AI如何在短时间内完成一篇论文的撰写，并且能够对应关键文献，这对于需要大量引用文献的学术写作来说，是一个非常实用的功能。
艾师智写：专业学术辅助 网址：艾师智写
艾师智写是一个由技术开发人员和学术老师共同研发的AI写作工具，专注于学术论文的撰写。它不仅能够提供内容创作，还具备降重和润色的功能，适用于文学、法学、管理学、理工科等多个专业领域。
Kimi Chat：全知全能的AI助手 下载链接：Kimi Chat APP
Kimi Chat是一个全知全能的AI助手，它能够提供安全、有帮助、准确的回答，支持中文和英文对话。无论你在论文写作中遇到任何问题，Kimi Chat都能为你提供解决方案。
通过这些工具，你可以更加专注于研究的核心内容，而不是被繁琐的写作工作所困扰。现在就开始尝试这些AI工具，让你的学术创作变得更加轻松高效吧！
快速补充参考文献 视频链接：[如何补充呢](https://www.bilibili.com/video/BV1qv4y1V7F1/）
1、知网，参考别人的参考文献，学术期刊和学位论文
2、百度学术，找句子重复的
3、知网，高级检索，句子检索
4、查重
详细例子
知网句子检索：中文文献好帮手 功能介绍：知网句子检索
知网的句子检索功能可以帮助研究人员快速找到所需的中文文献资料。这个功能特别适合在撰写论文时需要引用大量中文文献的情况。
citexs斯特新思：文献语料库 网址：citexs斯特新思
citexs斯特新思提供了一个丰富的文献语料库，专注于英文写作和论文撰写。它还提供了SCI辅助写作、AI文献大数据挖掘与分析等科研工具，帮助研究人员更高效地获取和处理信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ce047d27ebe1c9af1d0ab350a557877/" rel="bookmark">
			完美解决： [Compile Result] A page configured in ‘main_pages.json‘ must have one and only one ‘@Entry‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、问题： 在鸿蒙ARKTS开发时遇到：
[Compile Result] A page configured in 'main_pages.json' must have one and only one '@Entry' decorator.
[Compile Result] Compile error occurred. Fix it based on the above message.
二、解决方法： 修改'main_pages.json'文件（文件路径：entry &gt; src &gt; main &gt; resources &gt; base &gt; profile &gt; main_pages.json）
main_pages.json文件内容：
{ "src": [ "pages/PageResource", "pages/HomePage" ] } 下面的所有page均须有@Entry 修饰符。刚才在HomePage中引用PageResource，两个页面均有修饰符，重复警告。
这时候我们删掉@Entry 还会报同样的错误，我们需要将main_pages.json文件中两个页面任意一个将其删掉即可。（!不能将其注释，会报错，同时记得删掉最后结尾的逗号）
正确文件内容：
{ "src": [ "pages/PageResource" ] } 或者
{ "src": [ "pages/HomePage" ] } 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/42/">«</a>
	<span class="pagination__item pagination__item--current">43/71</span>
	<a class="pagination__item pagination__item--next btn" href="/page/44/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>