<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.126.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程学习者的博客">
		<meta property="og:url" content="https://bcxuexizhe.github.io/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="编程学习者">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd6e1c96d57c53a3d847e73f9fce3c40/" rel="bookmark">
			【HarmonyOS尝鲜课】- 前言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 面向人群 本课程适用于HarmonyOS应用开发的初学者。
有无经验的开发者都可以轻松掌握ArkTS语言声明式开发范式，体验更简洁、更友好的HarmonyOS应用开发旅程。
什么是HarmonyOS HarmonyOS（鸿蒙操作系统）是由华为技术有限公司开发的全场景分布式操作系统。它旨在为各种智能设备提供支持。
HarmonyOS的设计目标是实现跨设备的无缝连接与协同工作，通过其超级终端功能，使得不同设备可以轻松协同，形成一个统一的操作体验。
对于开发者而言，HarmonyOS提供了应用开发和设备开发的一站式服务平台。
HarmonyOS的适用设备及应用场景 适用设备应用场景智能家居涵盖智能家电、中控交互中心、安防产品和个护产品等端到端领域，具备碰一碰获取服务、多模态交互等分布式交互入口能力，创造智能、省心、有趣的居家生活体验。智能手机、汽车覆盖出行前准备、出行中、出行后全场景，包含车载带屏设备、车载 IOT 设备、个人出行设备等。可穿戴设备涵盖智能健身、健康监测、健康保健三大健康场景。利用分布式能力，实现超级运动终端、智能运动私教、个人健康顾问。PC和平板融合涵盖个人多设备的移动办公，和多人多设备场景下的会议室办公两大场景，提供了具有竞争力的产品解决方案和开发平台，助力合作伙伴打造智慧办公生态。影音娱乐影音娱乐包含音视频播放、音视频录制以及相关配套件等丰富的生态设备，通过 HarmonyOS Connect 的接入以及分布式特性的使能，为用户带来全场景沉浸式娱乐体验。智能教育教育关怀解决方案, 提供全面而丰富的学习工具, 打造智慧书房和智慧课堂场景化解决方案, 赋能开发者研发各类教育智能产品, 助力合作伙伴打造健康生态。 能学到什么 开发工具（DevEco Studio）的简单使用及运行项目；初步了解ArkTS语言；了解常用布局组件的使用；了解组件状态管理装饰器的使用；实现卡片配对小游戏； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20d65efaface86e816cd83ed58633e8c/" rel="bookmark">
			基于微信小程序实现的【二手物品交易平台】后端 JAVA Springboot （内附设计LW &#43; PPT&#43; 源码&#43; 演示视频 下载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目名称 项目名称： 基于微信小程序的二手物品交易平台
项目技术栈 该项目采用了以下核心技术栈：
后端框架/库： Java, SSM框架数据库： MySQL前端技术： 微信小程序技术其他相关技术： HTML, MyEclipse开发工具 本文详细介绍了一个基于微信小程序的二手物品交易平台的设计和实现过程。项目采用Java语言结合SSM框架进行后端开发，MySQL作为数据库支撑，前端则利用微信小程序技术，打造了一个功能完备、用户友好的在线交易系统。系统设计遵循易操作、安全性、准确性、实用性和可维护性等原则，确保了高效稳定的信息管理。
系统功能涵盖了用户信息管理、商品信息管理、商品类型管理以及新闻信息管理等多个方面。通过具体的页面设计，管理员能够方便地进行信息的增删改查操作，并支持模糊查询等高级功能。系统还特别设计了登录功能和班级管理功能测试，确保了操作的安全性和准确性。
文章还对系统的性能和稳定性进行了测试，证明了系统能够长时间稳定运行，并且具备良好的用户操作反馈机制。作者在文中反思了开发过程中遇到的编程和数据库设计问题，并提出了相应的优化措施，如代码重构和数据库连接池技术的应用。
最后，作者分享了通过项目实践得到的宝贵经验，包括程序开发流程的熟悉、编码能力的提高、问题分析和解决能力的培养，以及对技术知识学习的重要性。同时，作者也表达了对导师、同学和母校的感激之情，感谢他们在整个项目制作过程中给予的帮助和支持。
项目展示 5.1 用户信息管理 管理员可以通过用户信息管理页面执行多种操作，包括查询、删除、修改和新增用户信息。此外，还支持对用户名称进行模糊查询。
5.2 商品信息管理 商品信息管理页面允许管理员查看、修改商品信息，作废或删除商品信息，并支持对商品信息名称和类型进行模糊查询。
5.3 商品类型管理 在商品类型管理页面，管理员能够根据商品类型进行查询，并执行新增、修改和查询商品类型的操作。
图5-1 用户信息管理页面 展示用户信息管理的具体界面和功能。
图5-2 商品信息管理页面 展示商品信息管理的具体界面和功能。
图5-3 商品类型管理页面 展示商品类型管理的具体界面和功能。
图5-4 新闻信息管理页面 展示新闻信息管理的具体界面和功能。
核心功能描述 用户信息管理： 允许管理员进行用户信息的增删改查操作。商品信息管理： 提供商品信息的全面管理，包括上架、下架和信息更新。商品类型管理： 使管理员能够高效地对商品分类进行管理。 使用该项目作为毕业设计的好处 迅速完成并展示成果： 该项目提供了一个完整的二手物品交易平台，可以迅速部署并展示。代码简洁高效： 代码经过优化，简洁而高效，便于理解和维护。功能完备，易于上手： 系统功能全面，界面友好，易于新用户快速上手。全面的学习资源： 项目提供了丰富的文档和学习资源，便于深入学习。学术实践结合： 结合了理论知识与实践操作，有助于学术和实践的双重提升。 配套文档展示 毕业设计文章及图片 设计文章预览图： 源码+配套文件下载，点击下方名片 ↓↓↓↓ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c9ba9284eb12d2085b08de2e4f9d2df/" rel="bookmark">
			【Hadoop】DataNode 数据盘进行磁盘DiskBalancer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
​一、问题原因
二、DiskBalancer介绍
三、DiskBalancer实战
3.1 生成plan json文件
3.2 执行plan json文件
一、问题原因 阿里云事件磁盘损坏后，使用新磁盘进行了替换，或者当发现HDFS容量不够需要扩展空间时，由运维管理人员陆陆续续为 datanode 节点增加了多块磁盘，并将这些磁盘挂载到了不同目录比如 /mnt/disk1, /mnt/disk2；此后由大数据系统管理人员配置 HDFS 使用了这些新的磁盘上的目录 （比如配置 dfs.datanode.data.dir=/mnt/disk1/dfs/data,/mnt/disk2/dfs/data,/mnt/disk3/dfs/data），并重启了 hdfs 服务使配置生效。
但是hdfs经过上述配置更改并重启生效之后，只有新增加的HDFS文件才会存储在新增加的目录下，已经存在的HDFS历史文件，其对应的底层数据是不会从原有目录移动到新增目录的。
即使使用了命令 hdfs balancer 来在集群内重新分布 HDFS 文件，由于该命令只会在不同host之间移动数据，也就是主要做的是 host 节点级别的负载均衡，上述单节点中多磁盘之间的负载不均衡问题，也不会由太大缓解。
二、DiskBalancer介绍 DiskBalancer是一个命令行工具，可在DataNode的所有磁盘上均匀分发数据。 此工具对给定的DataNode进行操作，并将块从一个磁盘移动到当前DataNode的另一个磁盘。DiskBalancer通过创建计划并继续在DataNode上执行该计划。 计划是一组陈述，描述了两个磁盘之间应该移动的数据。 计划由多个移动步骤组成。 移动步骤具有源磁盘，目标磁盘和移动的字节数。 可以针对运行数据节点执行计划。DiskBalancer是一个相对独立的线程，它可以对数据的复制进行限流。 集群默认是启用DiskBalancer的， 不启用DiskBalancer 需要在hdfs-site.xml中将dfs.disk.balancer.enabled设置为false。
三、DiskBalancer实战 需求：磁盘 /disk2是新挂的 ，需要将一台服务器的 4块磁盘 做数据平衡。 3.1 生成plan json文件 首先要确保DataNode的配置dfs.disk.balancer.enabled为true
hdfs-site.xml配置 &lt;property&gt; &lt;name&gt;dfs.disk.balancer.enabled&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; 通过-plan生成plan:
hdfs diskbalancer -plan winner-reid-datanode07 -maxerror 5 -bandwidth 50 -thresholdPercentage 5 参数介绍：
-bandwidth 平衡带宽，单位MB/s，默认10-maxerror 错误重试次数，默认5-thresholdPercentage 平衡阈值，默认10，即磁盘占用率大小相差&lt;=10%则认为是平衡的-out 执行计划json输出路径，注意为hdfs路径，且路径需要为空 生成文件位于 HDFS
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c9ba9284eb12d2085b08de2e4f9d2df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a53948b1c61422e652a5473ea9f29842/" rel="bookmark">
			在排序数组中查找元素的一个位置和最后一个位置-力扣
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一此次想到的解法是首先使用二分查找在排序数组中查找到一个指定元素，随后对该元素左右进行遍历，找到起始位置和结束位置，代码如下：
class Solution { public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) { int size = nums.size(); int min = 0; int max = size - 1; while(min &lt;= max){ int mid = min + (max - min)/2; if(target &lt; nums[mid]){ max = mid - 1; } else if(target &gt; nums[mid]){ min = mid + 1; } else{ while(nums[min] != target){ min++; } while(nums[max] != target){ max--; } return {min,max}; } } return {-1,-1}; } }; 执行虽然通过，但测试用时并不是很理想，在 代码随想录 看到的解法是将题目分为三种情况：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a53948b1c61422e652a5473ea9f29842/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c14e75ee2cfd314c3c7574227f32bdc/" rel="bookmark">
			【代码随想录】【算法训练营】【第14天】 [144]二叉树的前序遍历 [94]二叉树的中序遍历 [145]二叉树的后序遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 思路及算法思维，指路 代码随想录。
题目来自 LeetCode。
day 14，周二，好困~
题目详情 [144] 二叉树的前序遍历 题目描述 144 二叉树的前序遍历
解题思路 前提：二叉树的前序遍历，中左右
思路：递归实现 or 迭代实现。
重点：递归实现三要素：确定递归函数的参数和返回值，确定终止条件，确定单层递归逻辑。
代码实现 C语言 递归法 确定递归函数的参数和返回值：void traversal(struct TreeNode *root, int *ret, int *idx)；
确定终止条件：if (root == NULL) { return ; }；
确定单层递归逻辑：ret[(*idx)++] = root-&gt;val;// 中 traversal(root-&gt;left, ret, idx);// 左 traversal(root-&gt;right, ret, idx);// 右。
/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ /** * Note: The returned array must be malloced, assume caller calls free().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c14e75ee2cfd314c3c7574227f32bdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65d2140880a679d00e06e168ecef8e03/" rel="bookmark">
			【MySQL】MySQL在 Linux下环境安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL的安装 1.卸载不要的环境2.获取mysql官方yum源3.安装mysql yum源4.安装mysql服务5.登录问题5.配置my.cnf6.设置开机启动(可以不设) 说明：
安装与卸载中，用户全部切换成为root，一旦安装，普通用户也能使用的 1.卸载不要的环境 ps ajx | grep mariadb # 先检查云服务器是否配的有mariadb存在 像我这里就是没有的
如果有就先停止掉
systemctl stop mariadb.service # 停⽌mariadb 服务 检查是否安装过mysql
ps ajx | grep mysql 我这里就是安装过的
先切成root用户，然后暂停mysql服务，在查一下mysql就没有了在运行了
systemctl stop mysqld #关闭mysql服务 如果曾经安装过mariadb或mysql，系统里面一定会有各种安装包，一般通过yum的方式获取到的安装包都是 .rpm 为后缀的
rpm -qa | grep mysql #查看mysql安装包 下面把这些安装包卸载，当然你可以一个一个卸载，也可以一次卸载一批
xargs这个指令是将前面内容拼接到这条命令的最后面，因为以前是通过yum安装的，所以还通过yum卸载
rpm -qa | grep mysql | xargs yum -y remove 卸载完，再查一下发现没有了，这才是真的卸载完成
ls /etc/my.cnf #检查当前是否有这个文件，如果卸载了mysql这个是没有的 ls /var/lib/mysql #在系统中mysql默认在这个路径下 这个是上一个mysql残留下来的数据，mysql卸载时默认没把数据删掉，这个也是清理之中的，不影响后面的操作
2.获取mysql官方yum源 mysql官方yum源
注意：最好安装和自己系统⼀致的mysql版本，否则可能会存在软件兼容性问题
cat /etc/redhat-release #查看自己的系统版本 mysql有5.7 和8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65d2140880a679d00e06e168ecef8e03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f06534c76642ddbb53dc38edc4161ed8/" rel="bookmark">
			HBase 基础结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HBase 是一个分布式[集群]、可扩展[动态上下线]、支持海量存储的 NoSQL 数据库。相当于 BigTable，负责海量数据的存储。如果数据量小的时候不适合使用 HBase，因为生产上需要不断的切分和合并比较消耗资源。如果数据量比较大，可以做到几十亿条数据秒级查询。支持数据的增删改查，实现了 HDFS 的随机写操作。
一、数据模型 逻辑上，HBase 的数据模型同关系型数据库很类似，数据存储在一张表中，有行有列。但从 HBase 的底层物理存储结构（K-V）来看，HBase 更像是一个 multi-dimensional map。下图的整个内容成为一张表。
【1】行键 RowKey： 是一张表中自动生成的唯一的、且有序的，按照“字典序”进行排序的主键；
【2】列族： 不同的列族放在不同的文件夹中，列族中的列可以有多个或者一个，列可以动态增加；
【3】Region切片： 按照 RowKey 进行切分，如上是按照3个 rowkey 进行划分的。一般是按照数据量进行划分，这样访问时能够提高效率；
【4】store： 实际存储数据的文件，存放在 HDSF。如上表中的数据是放在 6个 store 中；
二、HBase 物理存储结构 根据每一个列进行存储，例如张三：包含RowKey、ColumnFamily列族、ColumnQualifier列名、TimeStamp时间戳[实现HD 的随机写操作，完全由次属性决定，它优化最大的地方就是时间戳，该属性非常重要，window与Linux 一个用来操作一个用来存放时，需要两个操作系统的时间一定要相同，否则会出现很多问题]、Type类型[Put表示插入]、Value存放的值。当修改一条数据时，其实会添加一条数据与旧数据不同的是时间戳和value，此时，在获取数据的时候，它只会获取时间戳最大的那条数据。当删除一条数据时，也是添加一条数据与旧数据不同的是时间戳和Type，Type类型是 Delete。在获取的时候发现Delete类型的时间戳比 PUT的时间戳大，那就不返回数据。那么旧的数据对用户而言就是垃圾数据了，此时HBase还会存储着，但是最终它还是会从内存中将垃圾干掉的。是在后期表的分合操作的时候删除的。
三、数据模型 【1】Name Space： 命名空间，类似于关系型数据库的 database概念，每个命名空间下有多张表。HBase 有两个自带的命名空间，分别是 hbase 和 default。hbase 中存放的是 HBase 内置的表，default 表是用户默认使用的命名空间。
【2】Region： 类似于关系型数据库的表的概念。不同的是，HBase定义表时只需要声明列族即可，不需要声明具体的列。意味着，往 HBase中写入数据时，字段可以动态、按需指定。因此和关系型数据库相比，HBase能够轻松应对字段变更的场景。
【3】ROW： HBase 表中的每行数据由一个 RowKey和多个 Column（列）组成，数据是按照 RowKey的字典顺序存储，并且查询数据时只能根据 RowKey 进行检索，所以 RowKey的设计十分重要。
【4】Column： HBase 中的每个列都由 Column Family（列族）和 Column Qualifier（列限定符）进行限定，例如：info: name,info: age。建表时，只需要声明列族，而列限定名无需预先定义。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f06534c76642ddbb53dc38edc4161ed8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5868da0402f2c29ef85ed7bc2e7be53f/" rel="bookmark">
			JavaScript 冷知识大赏：带你领略不一样的编程乐趣
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页：学习前端的小z
个人专栏：JavaScript 精粹
本专栏旨在分享记录每日学习的前端知识和学习笔记的归纳总结，欢迎大家在评论区交流讨论！
文章目录 💯JavaScript 中的小 tips📧1 严格模式💞1.1 "use strict" 严格模式💞1.2 开启严格模式💞1.3 全局变量显式声明💞1.4 静态绑定💞1.5 增强的安全措施💞1.6 禁止删除变量💞1.7 显式报错💞1.8 重名错误💞1.9 禁止八进制表示法💞1.10 arguments对象的限制💞1.11 函数必须声明在顶层💞1.12 保留字 📧2 值在各种场景的转换规则📧3 错误类型📧4 空值合并运算符 '??'💞4.1 与 || 比较💞4.2 优先级💞4.3 注意: 📧5 ===📧6 CONSOLE 控制台输入💞6.1 Console.assert()💞6.2 Console.clear()💞6.3 Console.count()💞6.4 Console.countReset()💞6.5 Console.debug()💞6.6 Console.dir()💞6.7 Console.dirxml()💞6.8 打印信息💞6.9 打印树状结构💞6.10 Console.table()💞6.11 定时器💞6.12 Console.trace()💞6.13 占位符 💯JavaScript 中的小 tips 📧1 严格模式 严格模式是ES5引入
严格模式主要有以下限制:
变量必须声明后再使用函数的参数不能有同名属性，否则报错不能使用with语句不能对只读属性赋值，否则报错不能使用前缀0表示八进制数，否则报错不能删除不可删除的属性，否则报错不能删除变量delete prop，会报错，只能删除属性delete global[prop]eval不会在它的外层作用域引入变量eval和arguments不能被重新赋值arguments不会自动反映函数参数的变化不能使用arguments.callee不能使用arguments.caller禁止this指向全局对象不能使用fn.caller和fn.arguments获取函数调用的堆栈增加了保留字（比如protected、static和interface） 💞1.1 “use strict” 严格模式 “use strict” 是ES5 中的新指令（ECMAScript version 5）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5868da0402f2c29ef85ed7bc2e7be53f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba68b1b6cd08a9fc856bfd66cd5f0079/" rel="bookmark">
			基于单片机电梯控制系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 摘 要: 介绍了电梯控制系统架构 ， 指出了该系统的硬件设计和控制系统的软件设计以及系统调试 ， 使系统可根据按键 要求完成载客任务，为电梯控制系统的优化提供了参考 。 关键词 : 电梯控制 ; 单片机 ; 系统设计 0 引言 在高层建筑中发挥着不可或缺作用的电梯 ， 在当今社会经济活动与生活中已经成为了一种重要运输工具。 电梯控制系统现阶段主要包括继电器控制、 可编程控制器控制 、 具有重量检测精度高、 成本低 、 功能与显示多样等优势的单片机 ( 微机 )控制 3 种控制方式 。 本文基于使系统可根据按键要求合理地做出判断的单片机 AT89C52 进行了电梯控制系统智能控制模块的设计， 保证高效 、 正确地完成载客任务 。 1 系统架构 首先是微控制器 AT89C52 用作电梯控制系统模块核心的系统架构。 在本设计中 ， 行列式键盘矩阵用于外部 ， LED 显示器则使用 4511 进行驱动 ， 电梯的楼层显示器采用 LVled 静态显示器， 使用 I/0 接口和外围电路进行协调控制 ， 呼叫内部选择电路。 2 个 LED 用于显示电梯的状态 。 建筑物楼层为 5 层 ，矩阵键盘为 4 × 4 。 每个楼层的 LV 外部呼叫键以及开始键 ， 当电梯向上行驶时， 左灯点亮 ， 紧急停止键和电梯演示密钥共有16 个键 ， 其中包括当电梯向下行驶时右灯点亮的 5 个内部电梯楼层选择键。 另外 ， 设置了一个由有机玻璃制成 、 无盖板六面体、 高度为 1． 2 m 的电梯轿厢井道指示灯 ， 由皮带轮悬挂并由电动机拉动， 以显示开 / 关门的状态 。 轿厢在井道空间中上下移动。 ① 系统功能 。 首先响应每层的要求确定每层的位置和高度， 并稳定速度 。 ② 准确定位运行位置 ， 正确显示电梯上下运行状态， 送至单片机进行过载判断和信号 ， 将其转换成数字信号， 显示准确检测重量 。 ③ 调平层的开启和关闭动作带有相应的指示灯， 实时显示电梯所在楼层的位置及在调平层的末端给出相应的信号。 按照 “ 方向优先 ， 距离第二 ” 的原则 ， 系统可以要求每层的平均工作时间， 找平层的位置误差应小于 10 mm ，并及时接收各层的呼叫信息。 ④ 具有 “ 不能逆向响应功能 ” 的该系统对外部呼叫信号进行判断和自动响应， 即在电梯的上行过程中， 自行选择操作路径 。 在下行链路过程中 ， 仅对上行呼叫进行相位响应并且反向调用无效。 2 硬件设计 1 ) 需要将多种类型的电源隔离以增强电梯控制系统抗干扰能力的电源控制。 系统可以根据实际需要使用系统中某些输出电压相同的模块。 选择单片机逻辑电路的电源为 5 V ， 可以选择放大电路的电源为 15 V ， 上述电源必须在同一地线 ， 作为 + 3． 3 V 电源可以选择 + 15 V 和 + 5 V 电压应隔离的单片机的电源， 并且应使用隔离的 － 5 V 和 + 24 V 电压分别提供开关传感器和开关信号的电源以及电梯设备电机的电源。 2 ) 在电梯控制系统中 ， 非常重要的组件模块是高精度检测电梯重量的重量检测模块。 价格便宜 、 检测精度高的重量检测用于基于单片机的电梯控制系统的重量检测模块中。 可以在0 ～ 1 kg 的压力下输出 0 ～ 20 mv 的电压信号的功能 ， 使得该重量传感器可以通过与传感器输出端相连的仪器或测量放大器传输到将其转换为/D 数字信号以进行过载判断和显示的单片机。 3 ) 为了提高系统在地板上的定位精度 ， 电梯控制系统关键内容的位置显示， 使用了非接触式光电反射传感器 。 有 2 种位置检测方法: 传感器具有抗干扰性能强的接触式和轿厢位置显示之一的非接触式。 在此设计中 ， 可靠性高 ， 响应速度快 ， 传感距离长的传感器在设计中， 将传感器信号处理为高 / 低电平 ， 精度高， 发散角小 ， 并在转换和隔离后将其发送到单片机 。 电梯控制系统电源电压为 15 V ， 安装在每个楼层和电梯的极限位置。 4 ) 基于单片机 AT89C52 根据系统设定速度值的电机控 制。 电梯控制系统的电机控制模块单片机输出不同占空比的 PWM， 电机速度控制可以实现硬件平滑滤波后对运行速度的 控制; 确定电梯上下线或停止位置的电机运行方向的控制 : 一 个引脚控制电梯设备继电器的接通状态的单片机， 根据控制系 统的输入信号进行逻辑分析， 然后实现电机的升降 。 处理电梯到达地面时的电梯轿厢比率: 可以在系统设计系统中使用反向 电压控制， 当电梯到达地面时 ， 控制系统直接切断电源的电梯 轿厢会引起地面错误 ， 具有一定提高调平精度的实用性 。 5 ) 单片机与上位机之间通过 RS232 串口连接的串行通 信。 基于 AT89C52 单片机的电梯控制系统在上位计算机接收 到单片机发送的呼叫信号后， 使用 RS232 串口三线 ， 两端与接 收端相连， 发送端与 5 个端接地 ， 在 RS232 和 TTL 电平的转换 下， 将难以控制的控制系统的操作信息通过交叉串口与单片机 连接， 发送给单片机 ， 实现系统的串行通信 。 3 软件设计 电梯控制系统的整个功能实现主要包括控制模块软件的实现和判断子程序。 1 ) 主程序模块 。 为了可以准确地进行相应的操作 ， 通过判 断相应的功能键， 系统的主程序主要用于变量和其他组件的初 始化， 以实现特殊功能 。 2 ) 判断子程序 。 系统判断子程序的实现过程中 ， 通常需要 根据当前楼层状态和对应的楼层进行相应的处理， 在相应的中 断子程序中， 对相应楼层进行逻辑判断 。 例如 ， 在应用了 2 个 楼层时， 如果第 2 层的应用比第 1 层的应用更接近当前层的状 态， 首先 ， 在上升状态下举升标志位 ， 响应第 2 个应用 ， 然后响 应其他应用程序。 如果出现故障 ， 它将以相反的顺序响应 ， 需要进一步的逻辑思考和判断。 同时 ， 如果当前楼层下面有 1 个 楼层应用程序， 则还应该根据升高和降低的标志位来判断 。 如 果它处于上升状态， 则应首先响应上层 ， 然 后 响 应 第 2 个 应用。 4 系统调试 1 ) 硬件测试 。 根据硬件电路图 ， 检查硬件电路的接线是否 与电路原理图一致。 从静态检查开始 ， 用万用表测试 ， 检查组 件的型号、 极性和安装 ， 检查电路组件是否已连接 。 另外 ， 进行 通电检查， 调试电源部分 ， 使用示波器检测单片机的复位和晶 体振荡器电路中是否存在复位信号和振荡信号 。 首先 ， 接上 220 VAC 电源 ， 整个电路只需要 + SV 电压 ， 测试变压器的输出 端是否与理论计算值一致。 2 ) 软件调试和整体调试 。 模拟器正常运行后 ， 由仿真器调 试。 将程序与刻录机一起刻录到 AT89CS1 单片机中 ， 并进行 离线调试。 5 结语 系统设计完成后 ， 连接电源进行调试 。 打开电梯电源 ， 在 电梯上升/ 下降队列的响应过程中 ， 选择各层钥匙 ， 相应的上 升/ 下降指示灯正常显示 ， 每个模块的功能都可以正常使用 ， 基 本实现了运行仿真， 电梯运行即可完成 。 基于单片机的电梯控 制系统 AT89C52 包括单片机系统 、 呼叫信号传输系统 、 电机控 制模块等。 系统利用模块设计思想进行了电梯各模块的硬件 设计和软件设计， 并对电梯进行了总体调试 ， 具有方向优先 、 距 离优先、 完成设计指标的功能 ， 得到了基于单片机的电梯控制 系统。 运行测试表明 ， 基于单片机的电梯控制系统设计具有很 多优点， 如成本低 、 功能多样 、 灵活性强 、 精度高等 ， 使系统可根 据按键要求， 合理地做出判断 ， 高效 、 正确地完成载客任务 ， 为 电梯控制系统的优化提供了参考。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/869238d9157db45602e1fbfd4fda2562/" rel="bookmark">
			LeetCode 1542.找出最长的超赞子字符串：前缀异或和（位运算）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【LetMeFly】1542.找出最长的超赞子字符串：前缀异或和（位运算） 力扣题目链接：https://leetcode.cn/problems/find-longest-awesome-substring/
给你一个字符串 s 。请返回 s 中最长的 超赞子字符串 的长度。
「超赞子字符串」需满足满足下述两个条件：
该字符串是 s 的一个非空子字符串进行任意次数的字符交换后，该字符串可以变成一个回文字符串 示例 1：
输入：s = "3242415" 输出：5 解释："24241" 是最长的超赞子字符串，交换其中的字符后，可以得到回文 "24142" 示例 2：
输入：s = "12345678" 输出：1 示例 3：
输入：s = "213123" 输出：6 解释："213123" 是最长的超赞子字符串，交换其中的字符后，可以得到回文 "231132" 示例 4：
输入：s = "00" 输出：2 提示：
1 &lt;= s.length &lt;= 10^5s 仅由数字组成 解题方法：前缀和+哈希表+位运算 回文串有两种情况：
所有字符都出现了偶数次、有且仅有一个字符出现了奇数次。 也就是说我们只用关心每个字符出现次数是奇数还是偶数即可。因此我们可以使用一个数 m a s k mask mask， m a s k mask mask的第 i i i位表示数字 i i i出现次数是否为奇数次。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/869238d9157db45602e1fbfd4fda2562/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f2f0a6a5dc8a49290d2f13877be79b0/" rel="bookmark">
			代码随想录算法训练营第五十九天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想想其实坚持下来也不是很难，不过有很多题做一遍应该是记忆没那么深，anyway，要继续往换工作的方向走啊。加油！！
503.下一个更大元素II 想对了地方，但是没有坚持，应该搞两遍，就把所有的i都遍历过整个数组了。学到了。。。
class Solution { public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt;result(nums.size(),-1); stack&lt;int&gt;st;//用来记序号 st.push(0); for(int i = 1;i&lt; nums.size() * 2;i++){ while(!st.empty() &amp;&amp; nums[i % nums.size()] &gt; nums[st.top()]){ result[st.top()] = nums[i % nums.size()]; st.pop(); } st.push(i % nums.size()); } return result; } }; 42. 接雨水 今日做题没有斗志，随想录扶的。这题用双指针基本理解操作在干啥。
class Solution { public: int trap(vector&lt;int&gt;&amp; height) { if(height.size() &lt;= 2)return 0; int sum = 0; vector&lt;int&gt;heightl_max(height.size(),0); vector&lt;int&gt;heightr_max(height.size(),0); int size = height.size(); heightl_max[0] = height[0]; heightr_max[size - 1] = height[size - 1]; for(int i = 1;i &lt; size; i++){ heightl_max[i] = max(height[i],heightl_max[i-1]); } for(int i = size -2;i &gt;= 0;i--){ heightr_max[i] = max(height[i],heightr_max[i+1]); } for(int i = 0;i &lt; size;i++){ if(i == 0 &amp;&amp; i == size-1)continue; int count = min(heightl_max[i],heightr_max[i]) - height[i]; if(count &gt; 0)sum += count; } return sum; } }; 单调栈法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f2f0a6a5dc8a49290d2f13877be79b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ab9ce653169f18ad7f72fca57344291/" rel="bookmark">
			继承初级入门复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：保护和私有在类中没有区别，但是在继承中有区别，private在继承的子类不可见，protect在继承的子类可见 记忆方法：先看基类的修饰符是private，那都是不可见的。如果不是，那就用继承的修饰和基类的修饰比较谁小取谁-----&gt;public&gt;protect&gt;private
#include &lt;iostream&gt; using namespace std; class Person { protected: string _name; string _sex; int _age; }; class Student :public Person { public: int _No; }; int main() { Person p; Student s; //子类和父类之间赋值兼容规则 //1、子类对象可以赋值父类对象/指针/引用 p = s; Person* p1 = &amp;s; Person&amp; p1 = s; return 0; } 注意：父类不可以赋值给子类，有一种情况就是父类指向子类，再赋值给另一个子类
不同作用域（隐藏（重定义）） class Person { protected: string _sex; int _age=111; }; class Student :public Person { public: void f() { cout &lt;&lt; _age &lt;&lt; endl; } public: int _age=99; }; int main() { Student s; s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ab9ce653169f18ad7f72fca57344291/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae16804d338d59496fab18dd56debe15/" rel="bookmark">
			题解：CF1969B（Shifts and Sorting）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题解：CF1969B（Shifts and Sorting） 一、题目翻译 给定一个二进制字符串，你可以将其中一个子段（注意不是子串，是连续的）进行循环移位——将最后一个字符放在第一个字符之前，其代价为该段的长度，求让该字符串变为若干个 0 0 0 在前面、若干个 1 1 1 在后面形式所需要花费的最小代价。
二、思路分析 考虑贪心。
每个点被移动一次都会直接产生 1 1 1 的代价，因此其实本题目的就是让被移动的点尽可能少。
首先明确，本题就是要让 0 0 0 都往前去， 1 1 1 都往后去，因此不难想到将一个由前面 x − 1 x-1 x−1 个 1 1 1 与后面 1 1 1 个 0 0 0 组成的字符串搞好的最小的代价。显然是该串长度——首先证明可行，整段做一遍， 0 0 0 到最前面，代价为长度 x x x；再证明最优，其它的方式无论怎么倒腾都不可能避免让每一个点都被移动过一次，那样答案就不可能比总长度更小。
我们这样处理：找出总字符串最靠前的一个形如上面所提到的那种串，然后处理，继续往后做相同的操作。这样做到最后一定能够达成目的，并且如果按照别的方式就会不可避免的进行一个点的多余调用，显然不会更优秀。
最后考虑如何实现，其实每次处理不需要遍历整段去移位，可以直接将开头的 1 1 1 和结尾的 0 0 0 进行交换，因此直接记录目前为止最靠前的 1 1 1，如果某一位为 0 0 0，那么将从那个 1 1 1 到这个 0 0 0 之间处理掉（因为 0 0 0 是第一个扫描到的，所以中间不存在其它 0 0 0），重复操作即可。具体见代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae16804d338d59496fab18dd56debe15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adb53c0edfd210de0c5b815022dd37bd/" rel="bookmark">
			力扣HOT100 - 169. 多数元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解题思路：
有点类似于Boyer-Moore 投票算法，但更加形象。
class Solution { public int majorityElement(int[] nums) { int winner = nums[0]; int cnt = 1; for (int i = 1; i &lt; nums.length; i++) { if (winner == nums[i]){ cnt++; } else if (cnt == 0) { winner = nums[i]; cnt++; } else { cnt--; } } return winner; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e968a58fb16236b0add8fceeed374bbe/" rel="bookmark">
			JavaScript 进阶征途：解锁Function奥秘，深掘Object方法精髓
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页：学习前端的小z
个人专栏：JavaScript 精粹
本专栏旨在分享记录每日学习的前端知识和学习笔记的归纳总结，欢迎大家在评论区交流讨论！
文章目录 🈵Function方法 与 函数式编程💝1 call 💝2 apply💝3 柯理化函数(currying) 💝4 bind💝5 偏函数 (partial)💝6 通道函数(compose)🏆6.1 柯理化与偏函数区别 🈵Object 方法 深入💝1 Object.defineProperty()💝2 Object.entries() 💝3 Object.keys() 💝4 Object.fromEntries() 💝5 Object.preventExtensions() 🈵Function方法 与 函数式编程 💝1 call 语法：call([thisObj[,arg1[, arg2[, [,.argN]]]]])
定义：调用一个对象的一个方法，以另一个对象替换当前对象。
说明：call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。
如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。
let myName = 'goudan'; let myAge = 13; function showMsg(msg){ return (msg + '').toLowerCase(); } showName(myName); // 'goudan' 这段代码很容易就能看懂，在实际开发工作中，我们会处理不同的数据集合，这时候声明单一变量已经无法满足胃口，需要通过json的形式来存储数据
let person = { name:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e968a58fb16236b0add8fceeed374bbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a1e3a8f44674c1df6f26cdef5fe5278/" rel="bookmark">
			【数据结构】解密链表之旅（双链表篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 哈喽大家好，我是野生的编程萌新，首先感谢大家的观看。数据结构的学习者大多有这样的想法：数据结构很重要，一定要学好，但数据结构比较抽象，有些算法理解起来很困难，学的很累。我想让大家知道的是：数据结构非常有趣，很多算法是智慧的结晶，我希望大家在学习数据结构的过程是一种愉悦的心情感受。因此我开创了《数据结构》专栏，在这里我将把数据结构内容以有趣易懂的方式展现给大家。
1.双向循环链表 1.1循环链表 对于单向链表，由于每个节点只存储了向后的指针，到了尾标志就停止了向后的操作，这样，某一节点就无法找到它的前驱节点，就像我们无法回到从前。比如，你是一个业务员，在石家庄工作，你需要经常出差，行程就是石家庄到重庆一路上的城市。你从石家庄乘坐火车或者高铁出发，乘坐火车或者高铁途径多个城市停留后，到达重庆，再乘坐飞机回到石家庄。以后，每隔一段时间你基本按照这样的行程开展业务，大致流程图如下：
假设有一次，你在西安开会，加下来要把上面的城市都走一遍，这时候有人就和你说了：哎呀，你得先回石家庄，因为石家庄是第一站，我想你的表情是：
根本没有必要直接回石家庄，可以先从西安开始，下一站襄阳，直到重庆，之后再考虑走完石家庄、济南、郑州3个城市。很显然你这是从其中的一个节点开始遍历链表，这都是原来的单向链表结构解决不了的问题。事实上，把石家庄和重庆之间连接起来，形成一个环就解决了前面所面临的困难，就像第一张图中的下部分那样，这就是我们要介绍的循环链表。
将单链表中的终端节点的指针端由空指针改为指向头节点，就使整个单链表形成一个环，这种头尾相接的单链表成为单向循环链表，简称循环链表。为了使空链表和非空链表处理一致，我们通常设一个头节点，当然，这并不是说，循环链表一定带头结点。其实循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断p-&gt;next指向是否为空，现在则是判断p-&gt;next不等于头节点，则循环结束。循环链表有以下几个特点：
头结点和尾节点相连：最后一个节点的下一个节点指向头节点，这样就能形成一个闭环。通过这种连接方式，可以轻松地在循环链表中从任何节点访问到其他节点。
遍历方式：由于循环链表是一个闭环，所以可以从任意节点开始遍历整个链表。可以选择从头节点开始遍历，也可以选择从任意节点开始。
插入和删除节点：在循环链表中插入和删除节点相对较为灵活。插入节点时，只需要更改相邻节点的指针即可；删除节点时，将待删除节点的前一个节点的指针指向待删除节点的下一个节点，然后释放待删除节点的内存即可。
1.2双向链表 继续刚才的例子，你平时都是一直从石家庄到重庆，可这一次你要到重庆开会，开完会后要例行公事，走访各个城市，此时你该怎么办呢？哪有那么麻烦，我一路从重庆坐火车或高铁倒着一个城市一个城市回去就好了嘛。
我们的单链表，总是从开头到尾找节点，难道就不可以正反遍历链表吗？这时候我们只需要加一点东西就可以，我们在单链表中，有了next指针，就可以使我们要查找下一节点的时间复杂度为O(1)。可是我们要查找的是上一个节点的话，那最坏的时间复杂度就是O(n)了，因为我们每次查找都要从头开始遍历查找。 为了解决单向性这一缺点，双向链表就被设计出来了。双向链表是在单链表的每个节点中，在设置一个前驱节点的指针域。所以在双向链表中的节点都有两个指针域，一个指向直接后继，另一个指向直接前驱。
typedef int LTDataType; typedef struct ListNode { LTDataType data; struct ListNode* next; struct ListNode* prev; }LTNode; 双向链表在某些情况下具有优势，例如：需要在某个节点之后或之前插入或删除节点的场景。需要注意的是，双向链表增加了指针的管理和维护，因此在插入、删除节点时需要额外的操作来维护前后指针的正确性。
1.3双向循环链表 双向循环链表是将循环链表和双向链表相结合的模式，它兼备两者的优点。双向循环链表在某些场景中具有优势，比如需要在一个环形结构中存储数据，并且需要双向遍历和操作节点。它可以方便地实现循环遍历，并且在插入和删除节点时具有灵活性。需要注意的是，在使用双向循环链表时，需要确保指针的正确性以避免出现死循环或空指针引用的问题。
2.双向循环链表的各个功能的实现 在上面我们已经详细介绍了双向循环链表，这里我们直接来对双向循环链表各个功能来实现，首先用C语言来描述单链表的结构指针：
typedef struct ListNode { LTDataType data; struct ListNode* next; struct ListNode* prev; }LTNode; 在这里我们主要详细介绍双向循环链表的插入删除等操作。在双向循环链表中插入有尾插、头插、任意位置插入等操作，每次插入都需要申请空间，每次申请空间的操作都相同，我们干脆写一个函数来实现申请空间，这样能使我们的操作更加方便。这里我们来实现一下这个函数：
LTNode* CreatNode(LTDataType x) { LTNode* newnode = (LTNode*)malloc(sizeof(LTNode)); if (newnode == NULL) { perror("malloc fail"); return -1; } newnode-&gt;data = x; newnode-&gt;next = NULL; newnode-&gt;prev = NULL; return newnode; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a1e3a8f44674c1df6f26cdef5fe5278/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fea4c3aa4f4a619fde336b562369b097/" rel="bookmark">
			CSS变量的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开篇 今天在学东西的时候看到了CSS变量的应用。简单来说，CSS变量，也称为CSS自定义属性，是一种允许开发者定义并重复使用的值的机制。它们以 – 开头，可以在整个样式表中使用，并通过 var() 函数引用。
话不多说，请看下面的例子。
主题切换代码 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; :root { --background-color: #f0f0f0; --text-color: #333; } .dark-theme { --background-color: #333; --text-color: #f0f0f0; } div { width: 100%; height: 100vh; background-color: var(--background-color); color: var(--text-color); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;button class="btn"&gt;切换主题&lt;/button&gt; &lt;div id="myDiv"&gt;测试&lt;/div&gt; &lt;script&gt; let btn = document.querySelector('.btn') let myDiv = document.querySelector('#myDiv') btn.addEventListener('click', () =&gt; { myDiv.classList.toggle('dark-theme') }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注 以上便是CSS变量的简单应用，希望对您有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2ae856c2d15b7ce0e3aca2dcec164af/" rel="bookmark">
			520表白html5爱心代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在HTML5中创建一个带有爱心动画的表白页面，可以通过结合CSS3动画和JavaScript来实现。以下是一个简单的示例代码，展示了如何制作一个带有动态爱心效果的表白页面：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;520 表白&lt;/title&gt; &lt;style&gt; @keyframes heartBeat { 0% { transform: scale(1); } 25% { transform: scale(1.1); } 50% { transform: scale(1); } 75% { transform: scale(0.9); } 100% { transform: scale(1); } } body { display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #f0e0d8; margin: 0; overflow: hidden; } .heart { position: relative; width: 100px; height: 90px; animation: heartBeat 1s infinite; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2ae856c2d15b7ce0e3aca2dcec164af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c42e63b7204cda25818340f3ae3964e/" rel="bookmark">
			14：00面试，14：06就出来了，问的问题过于变态了。。。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从小厂出来，没想到在另一家公司又寄了。
到这家公司开始上班，加班是每天必不可少的，看在钱给的比较多的份上，就不太计较了。没想到5月一纸通知，所有人不准加班，加班费不仅没有了，薪资还要降40%,这下搞的饭都吃不起了。
还在有个朋友内推我去了一家互联网公司，兴冲冲见面试官，没想到一道题把我给问死了：
如果模块请求http改为了https,测试方案应该如何制定，修改?
感觉好简单的题，硬是没有答出来，早知道好好看看一大佬软件测试面试宝典了。 全网首发-涵盖16个技术栈
第一部分，测试理论（测试基础+需求分析+测试模型+测试计划+测试策略+测试案例等等）
第二部分，Linux（ Linux基础+Linux练习题）
第三部分，MySQL（基础知识+查询练习+万年学生表经典面试题汇总+数据库企业真题）
第四部分，Web测试
第五部分，API测试
第六部分，App测试
第七部分，管理工具
第八部分，Python基础（Python基础+编程题+集合+函数+Python特性等等）
第九部分，Selenium相关
第十部分，性能测试
第十一部分，LordRunner相关
第十二部分，计算机网络
第十三部分，组成原理
第十四部分，数据结构与算法
第十五部分，逻辑题
第十六部分，人力资源
软件测试基础
软件测试的步骤是什么?
如何录制测试脚本?
应该考虑进行如何测试的测试方法
怎样估计测试工作量?
测试设计的问题
当测试过程发生错误时，有哪几种解决办法?
测试执行的问题
测试评估的目标
如何提高测试?
C/S模式的优点和缺点
B/S模式的优点和缺点
Linux
grep和find的区别? grep 都有哪些用法?
查看IP地址?
创建和删除一个多级目录?
在当前用户家目录中查找haha.txt文件?
如何查询出tomcat的进程并杀掉这个进程，写出linux命令?
动态查看日志文件?
查看系統硬盘空间的命令?
查看当前机器listen 的所有端口?
Python
统计python源代码文件中代码行数，去除注释，空行，进行输出?
python调用cmd并返回结果?
冒泡排序
1,2,3,4 这4个数字，能组成多少个互不相同的且无重复的三位数，都是多少?
请用 python 打印出 10000 以内的对称数（对称数特点：数字左右对称，如：1,2,11,121,1221 等）
给定一个整数 N，和一个 0-9 的数 K，要求返回 0-N 中数字 K 出现的次数
判断 101-200 之间有多少个素数，并输出所有的素数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c42e63b7204cda25818340f3ae3964e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78fe36420d5266f131590e13d1c2162e/" rel="bookmark">
			【C&#43;&#43;】探索STL中的高效容器：vector
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💞💞 前言 hello hello~ ，这里是大耳朵土土垚~💖💖 ，欢迎大家点赞🥳🥳关注💥💥收藏🌹🌹🌹
💥个人主页：大耳朵土土垚的博客
💥 所属专栏：C++入门至进阶
这里将会不定期更新有关C++的内容，希望大家多多点赞关注收藏💖💖
1.什么是STL C++标准模板库（Standard Template Library，简称STL）是C++的一个库，提供了一组通用的模板类和函数，实现了常用的数据结构和算法。C++中的vector就是是标准模板库（STL）提供的一种容器。
STL由六个组件组成：
其中：
✨容器（Containers）：提供了不同类型的数据结构，如vector、list、deque、set、map等。容器可以存储不同类型的元素，并提供了一系列操作元素的函数，如插入、删除、查找、排序等。容器是STL最常使用的部分。
✨迭代器（Iterators）：用于遍历容器中的元素，类似于指针的概念。迭代器可以指向容器中的一个或多个元素，并提供了访问和修改元素的方式。迭代器可以在容器中前进、后退、比较和解引用等。
✨算法（Algorithms）：提供了一系列通用算法，如排序、查找、比较、复制、转换等。算法可以用于不同类型的容器，并且可以通过迭代器来操作容器中的元素。
STL的设计思想是泛型编程（Generic Programming），即通过模板实现通用的数据结构和算法，以提高代码的重用性和可扩展性。STL提供了大量的模板类和函数，可以在不同的应用中被复用，减少了开发者编写重复代码的工作量。
2.vector介绍 C++中的vector是标准模板库（STL）提供的一种容器，用于存储和操作动态数组。功能类似于我们之前学习的顺序表，它可以在运行时动态调整大小，与C++内置的数组相比，提供了更多的功能和便利性。
✨vector特点 vector是表示可变大小数组的序列容器。vector可以根据需要自动调整大小，可以在运行时添加或删除元素，而不需要手动管理内存。就像数组一样，vector也采用的连续存储空间来存储元素。也就是意味着可以采用下标对vector的元素进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自动处理。本质讲，vector使用动态分配数组来存储它的元素。当新元素插入时候，如果空间不够，这个数组需要被重新分配大小，其做法是，分配一个新的数组，然后将全部元素移到这个数组。vector内部分配空间策略：vector会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存储空间更大，不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何在末尾插入一个元素的时候都应该是在常数时间的复杂度内完成的。与其它动态序列容器相比（deque, list and forward_list）， vector在访问元素的时候更加高效，在末尾添加和删除元素相对高效。对于其它不在末尾的删除和插入操作，效率更低。元素类型：vector可以存储任何类型的元素，包括基本类型、自定义类型和STL容器等。包含头文件：在使用vector之前，需要包含&lt;vector&gt;头文件。 3.vector使用 ✨构造函数 ①无参构造vector():
vector&lt;int&gt; v1; //构造int类型的空容器 ②拷贝构造vector (const vector&amp; x):
vector&lt;int&gt; v2(v1); //用v1拷贝构造int类型的v2容器 ③ 使用n个val构造vector（size_type n, const value_type&amp; val = value_type()）:
vector&lt;int&gt; v3(4, 0);//用4个0构造int类型的容器v3 ④使用迭代器进行初始化构造vector (InputIterator first, InputIterator last):
vector&lt;int&gt; v4(v3.begin(), v3.end());//使用v3的迭代器来初始化并构造v4 注意这里是InputIterator表示除了vector的迭代器，其他容器的迭代器也可以构造，例如string、list…，代码如下：
string s("hello world"); vector&lt;int&gt; v5(s.begin(), s.end()); ✨vector iterator迭代器 迭代器的接口使用说明begin获取第一个数据位置的iterator/const_iteratorend获取最后一个数据的下一个位置的iterator/const_iteratorrbegin获取最后一个数据位置的reverse_iteratorrend获取第一个数据前一个位置的reverse_iterator begin()和end()函数通过访问容器的第一个和最后一个的下一位来实现正向迭代器遍历：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78fe36420d5266f131590e13d1c2162e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/12/">«</a>
	<span class="pagination__item pagination__item--current">13/71</span>
	<a class="pagination__item pagination__item--next btn" href="/page/14/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>