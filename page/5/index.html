<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.126.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程学习者的博客">
		<meta property="og:url" content="https://bcxuexizhe.github.io/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="编程学习者">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/155d5c1e4d8819a3121228f6add43375/" rel="bookmark">
			Rust之函数、单元测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、函数 类似于C++函数。
1.1、普通函数 在Rust中，函数的定义使用fn关键字，后跟函数名、参数列表、返回类型和函数体。函数体由一系列语句组成，用于执行特定的操作和计算。
函数定义：
使用fn关键字定义函数，函数由函数签名和函数体组成。
函数签名由函数名、参数、返回值类型组成。函数体包含于{}内，是函数要执行的具体代码。
函数体：
函数体由一系列语句和一个可选的结尾表达式构成。
结尾表达式没有分号，代表这是一个表达式而非语句，将会自动返回表达式的值；
结尾表示式的结尾如果加上分号，就变成了语句，语句没有返回值。
函数参数：
是函数签名的一部分。
函数参数必须明确指定数据类型，但不能指定默认值。
函数参数可以分为可变和不可变参数，默认不可变参数，需要可变操作时，需要加上mut关键字。
返回值：
如果函数需要返回值给调用者，在函数定义时需要明确返回值类型。使用 -&gt; 数据类型来定义。
函数只能有一个返回值，需要返回多个值时，可以使用元组类型。
Rust中每个函数都有返回值，即使没有显示返回值的函数，也会隐式地返回一个单元值()。
一般，函数隐式地返回函数体最后一个表达式的值，可以使用return 语句来显示返回。
代码：
// 文件名: a-1/src/main.rs fn add(a: i32, b: i32) -&gt; i32 { a + b } fn main() { let result = add(3, 5); println!("Result: {}", result); } 结果：
[root@local_tmp]# [root@local_tmp]# cargo run Compiling a-1 v0.1.0 (/home/test/rust/a-1) Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.15s Running `target/debug/a-1` Result: 8 [root@local_tmp]# [root@local_tmp]# 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/155d5c1e4d8819a3121228f6add43375/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2213eb1703155fc0c04794ee4124ea46/" rel="bookmark">
			【开源】大学生竞赛管理系统 JAVA&#43;Vue&#43;SpringBoot&#43;MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、系统介绍
学生管理模块
教师管理模块
竞赛信息模块
竞赛报名模块
二、系统截图
三、核心代码
一、系统介绍 基于Vue.js和SpringBoot的大学生竞赛管理系统，分为管理后台和用户网页端，可以给管理员、学生和教师角色使用，包括学生管理、教师管理、竞赛信息、竞赛报名模块和系统基础模块，项目编号T101。
【开源】大学生竞赛管理系统 JAVA+Vue+SpringBoot+MySQL
学生管理模块 大学生竞赛管理系统的学生管理模块是一个专为高校学生量身定制的高效、便捷的管理工具，旨在帮助学生轻松参与各类竞赛活动，提高个人综合素质。该模块涵盖了学生信息管理、竞赛报名、成绩查询、证书管理等多个功能，通过智能化的数据整合与分析，为学生提供个性化的竞赛推荐，激发学生的创新精神和团队协作能力。同时，学生管理模块还具备实时更新竞赛信息、自动提醒报名截止日期等功能，确保学生不错过任何重要竞赛机会。此外，系统还提供了丰富的竞赛资源和经验分享，帮助学生在竞赛过程中不断成长和进步。总之，大学生竞赛管理系统的学生管理模块是一个全面、实用的竞赛参与平台，为学生提供了一个展示自我、实现梦想的舞台。
教师管理模块 大学生竞赛管理系统教师管理模块是一款专为教师量身定制的高效管理工具，旨在简化教师在竞赛组织、学生管理、成绩评定等方面的工作流程。通过这个模块，教师可以轻松创建和管理竞赛项目，实时查看学生报名情况，对参赛学生进行分组和指导，以及在线发布和更新竞赛相关信息。此外，教师还可以利用该模块对学生的竞赛成绩进行快速录入、审核和公布，确保竞赛的公平性和透明度。通过这一系统，教师可以更专注于竞赛的教学质量和学生的成长，从而提高竞赛的整体水平和影响力。
竞赛信息模块 大学生竞赛管理系统竞赛信息模块是一个专为高校学生量身定制的高效、便捷的竞赛信息管理平台，旨在帮助学生轻松获取各类竞赛信息，提高参赛积极性。该模块涵盖了丰富的竞赛类型，包括学术、科技、艺术、体育等多个领域，确保满足不同专业和兴趣的学生需求。通过实时更新竞赛信息，学生可以第一时间了解到最新的竞赛动态，不错过任何一次展示自己才华的机会。此外，该模块还提供了竞赛报名、资料提交、成绩查询等一系列功能，让学生在参赛过程中享受到一站式服务，节省时间和精力。大学生竞赛管理系统竞赛信息模块致力于激发学生的创新精神和团队协作能力，为学生提供一个展示自我、锻炼能力的舞台，助力他们在竞赛中取得优异成绩，为未来的学术和职业生涯打下坚实基础。
竞赛报名模块 大学生竞赛管理系统竞赛报名模块是一款专为高校学生量身定制的高效、便捷的竞赛报名工具，旨在帮助学生轻松参与各类学术、技能和创新竞赛。该模块通过简洁明了的界面设计，让学生能够快速了解竞赛信息、报名要求和截止日期，同时提供一键报名功能，简化报名流程。此外，系统还具备智能推荐功能，根据学生的专业背景和兴趣爱好，为学生推荐合适的竞赛项目，提高参赛积极性。通过竞赛报名模块，学生可以充分利用课余时间，提升自己的综合素质，拓宽知识视野，为未来的学术和职业生涯打下坚实基础。
二、系统截图 三、核心代码 @IgnoreAuth @RequestMapping(value = "/login") public R login(String username, String password, String captcha, HttpServletRequest request) { XueshengEntity user = xueshengService.selectOne(new EntityWrapper&lt;XueshengEntity&gt;().eq("xuehao", username)); if(user==null || !user.getMima().equals(password)) { return R.error("账号或密码不正确"); } String token = tokenService.generateToken(user.getId(), username,"xuesheng", "学生" ); return R.ok().put("token", token); } @IgnoreAuth @RequestMapping("/register") public R register(@RequestBody XueshengEntity xuesheng){ //ValidatorUtils.validateEntity(xuesheng); XueshengEntity user = xueshengService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2213eb1703155fc0c04794ee4124ea46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9c02b37bdcfc351cfa2baa3c52e8b2a/" rel="bookmark">
			指针(6)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. sizeof和strlen的对比 1.1 sizeof 在学习操作符的时候，我们学习了 sizeof ， sizeof 计算变量所占内存内存空间大小的，单位是字节，如果操作数是类型的话，计算的是使⽤类型创建的变量所占内存空间的大小。
sizeof 只关注占用内存空间的大小，不在乎内存中存放什么数据。
sizeof是操作符 不是函数
int main() { int a = 10; printf("%zd\n", sizeof(int)); printf("%zd\n", sizeof(a)); int arr[10] = { 0 };//里面放了什么数据不会影响 printf("%zd", sizeof(arr)); //只关注内存空间大小 } 1.2 strlen strlen库函数,求字符串的长度,只能针对字符串(字符数组)
统计的是从 strlen 函数的参数 str 中这个地址开始向后， \0 之前字符串中字符的个数。strlen 函数会⼀直向后找 \0 字符，直到找到为止，所以可能存在越界查找。
int main() { char arr[] = { 'a','b','c' }; //char 一个字符一个字节 char arr1[] = "abc"; int arr2[] = { 1,2 };//int 一个整形4个字节 //strlen函数 计算数组的元素个数(字符串) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9c02b37bdcfc351cfa2baa3c52e8b2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68cbbcb327ba185f1f899da45535929f/" rel="bookmark">
			数据结构----第二章线性表1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：数据结构三要素--逻辑结构、数据的运算、存储结构（物理结构）
一、线性表的基本操作
Tips：对数据的操作（记忆思路）--创销、增删改查；
C语言函数的定义--&lt;返回值类型&gt;函数名（&lt;参数1类型&gt;参数1，&lt;参数2类型&gt;参数2，......)
实际开发中，可根据实际需求定义其他的基本操作
函数名和参数的形式、命名都可改变（命名要有可读性）
二、顺序表
1.顺序表的实现----静态分配
2.顺序表的实现---动态分配
顺序表的特点：1.随机访问，即可以在O（1）时间内找到第i个元素。代码实现：data[i-1]；静态、动态分配都一样
2.存储密度高，每个节点只存储数据元素
3.拓展容量不方便（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高）
4.插入，删除操作不方便，需要移动大量元素
3.顺序表的插入删除
1）插入
注意位序、数组下标的关系，并从后面的元素依次移动
如果出现顺序表已经存满的情况，代码可以做如下修改
2）插入操作的时间复杂度
3）删除
4.顺序表的按位查找
5.顺序表的按值查找
三、单链表
一、单链表的定义
1.什么是单链表？
2. 用代码定义一个单链表
3.不带头结点的单链表
4.带头结点的单链表
5.不带头结点vs带头结点
二、单链表的插入与删除
1.按位序插入（带头结点）--平均时间复杂度：0（n）
2.按位序插入（不带头结点）
3.指定结点的后插操作
直接调用后插操作的函数就可以了
4.指定结点的前插操作
1）传入头指针
2）不传入头指针
5.按位序删除（带头结点）
6.指定结点的删除
如果不带头结点，删除第一个元素，是否需要特殊处理？
7.封装的好处
小功能模块化，代码逻辑清晰
三、单链表查找（基于带头结点的情况）
1.按位查找
2.封装（基本操作）的好处
避免重复代码，简洁，易维护
3.按值查找
4.求表的长度
四、单链表的建立
头插法，尾插法：核心就是初始化操作，指定结点的后插操作
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbd95b5281ee37311daf09642d545507/" rel="bookmark">
			【九十四】【算法分析与设计】练习四蛮力法练习,排列问题和组合问题,求解最大连续子序列和问题,求解幂集问题,求解0/1背包问题,求解任务分配问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		求解最大连续子序列和问题 给定一个有n（n≥1）个整数的序列，要求求出其中最大连续子序列的和。
例如：
序列（-2，11，-4，13，-5，-2）的最大子序列和为20
序列（-6，2，4，-7，5，3，2，-1，6，-9，10，-2）的最大子序列和为16。
规定一个序列最大连续子序列和至少是0（看成0个元素构成的子序列），如果小于0，其结果为0。
1.
子数组累加和最大值问题,如何划分问题,子数组应该如何划分?
可以划分为以某一个位置结尾的子数组,以i位置结尾的子数组.
所有的子数组被划分成以0下标结尾的子数组,以1下标结尾的子数组.......
我们只需要解决每一个划分出来的子数组集合对应的问题即可.
也就是解决以某一个位置结尾的子数组累加和最大值是多少.
2.
以i位置结尾的子数组可以划分成两种,第一种是只包含i位置元素,第二种是不只包含i位置元素.
只包含i位置元素的累加和最大值为arr[i],不只包含i位置元素的累加和最大值为arr[i]+(以i-1位置结尾的子数组累加和最大值).
我们要求最大值,所以以i位置结尾的子数组累加和最大值为max(arr[i],arr[i]+(以i-1位置结尾的子数组累加和最大值)).
3.
动态规划,自底向上的动态规划和自顶向下的动态规划.
自底向上的动态规划写法 #include&lt;bits/stdc++.h&gt; // 导入标准库头文件 using namespace std; // 使用标准命名空间 #define int long long // 将int类型定义为long long类型，便于处理大数 #define endl '\n' // 将endl定义为换行符 // 定义两个测试用的数组 vector&lt;int&gt;arr1 = { -2,11,-4,13,-5,-2 }; vector&lt;int&gt;arr2 = { -6,2,4,-7,5,3,2,-1,6,-9,10,-2 }; // 定义一个动态规划数组和一个存储当前数组的变量 vector&lt;int&gt;dp; vector&lt;int&gt;arr; // 定义存储最大子数组和的变量 int ret; // 初始化函数 void init() { dp.assign(arr.size(), 0); // 将dp数组初始化为和当前数组相同大小，并赋初值为0 ret = 0; // 将ret初始化为0 } // 求解最大子数组和的函数 void solve() { for (int i = 0; i &lt; arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbd95b5281ee37311daf09642d545507/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64ce1d18818998576a33638352e5f44e/" rel="bookmark">
			SVM兵王问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.流程 前面六个就是棋子的位置，draw就是逼和，后面的数字six就代表，白棋最少用六步就能将死对方。然后呢，可以看一下最后一个有几种情况：
2.交叉测试 leave one out： 留一个样本作测试集，其余的都作为训练
fold折数越多，结果越精确，但是耗时越久。
3.(可能遇到的一些关于测试结果的问题)支持向量： 1、如果训练后得到的支持向量很多的话（最多=样本数量），说明没有训练好（可能是参数错误）。
2、SVM没法分割开来。
3、样本本身不太好区分。
3.AUC与EER曲线 混淆矩阵的学习
auc：是指黄色曲线和x轴的面积。
eer：蓝色曲线与黄色曲线的交点的横坐标。
如何衡量：auc越大，性能越好，eer越小性能越好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bc610cd158b6a303d8dcd409c5563ef/" rel="bookmark">
			5月26（信息差）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌍 珠峰登顶“堵车”后冰架断裂 5人坠崖 2人没爬上来！
珠峰登顶“堵车”后冰架断裂 5人坠崖 2人没爬上来！
🎄 Windows 11 Beta 22635.3646 预览版发布：中国大陆地区新增“微软电脑管家”应用
✨ 成都限购解除即将满月：有新盘“基本每天都签单成交” 外地购房者明显增多
1.马斯克AI领域动作频频：规划“算力超级工厂” 根据最新报道，xAI不仅正在与马斯克的“老对手”扎克伯格争夺与定制化聊天机器人团队Character.ai合作的机会，同时公司在算力建设方面的消息也颇为吸引眼球。
与扎克伯格“冤家路窄”
随着马斯克收购推特（现在改名为X）后，他与Meta老板扎克伯格就成了直接竞争对手。而社交媒体平台对定制化聊天AI的独特需求，也使得他们同时叩响了硅谷创业公司Character.ai的大门。
Character.ai是一家专门开发AI聊天机器人创作平台的公司，致力于打造模拟真实人物（例如黄仁勋、爱因斯坦）或虚拟人物（例如游戏《原神》的里某个角色）语言风格的聊天机器人。
（由用户创建并发布在平台上的“爱因斯坦机器人”，来源：Character.ai）
值得强调的是，Character.ai的创始人Noam Shazeer，正是当年谷歌Transformer论文的作者之一。时隔多年，这批开创当今AI新格局的谷歌研究员们纷纷踏上了创业的道路。
（Transformer论文作者齐聚今年英伟达GTC大会，左二为Noam Shazeer，来源：英伟达）
据多名知情人士表示，Meta公司与xAI都与Character.ai展开了早期的讨论，主要涉及研究层面的合作，例如模型开发和预训练。
Meta此前曾表示，正在整合AI人物聊天机器人到旗下Facebook、Instagram等多个平台，其中也会包括一些“扮演名人”的机器人。与此同时，xAI也开发了聊天机器人Grok，供X平台的付费订阅用户使用。
对于马斯克和扎克伯格而言，他们在开发专属人物AI层面也有一项其他科技巨头不具备的优势——手里有着大量社交媒体的数据。
建设“算力超级工厂”
在AI领域要有一番作为，也离不开持续砸钱搞算力。
根据科创媒体The Information周六报道，在今年5月的一次投资者演示中，马斯克表示xAI计划建造一台规格惊人的超级计算机，直言这将是一个“算力超级工厂”。
今年早些时候，马斯克曾经透露，训练Grok 2模型大约需要2万个英伟达H100 GPU，而训练下一代模型以及更高版本则会需要10万个英伟达H100芯片。
颇为符合马斯克豪迈风格的是，他准备把所有芯片全串进一台“超级计算机”里。他对投资者们表示，这个项目如果能够完成，将至少是当今存在的最大GPU集群规模的四倍。马斯克同时也表态会亲自下场，推动这台机器在2025年秋季运作起来，并补充称可能会与甲骨文合作开发这台庞大的计算机。
虽然特斯拉自己也在开发Dojo超算，但“算力超级工厂”依然还是要排队抢购英伟达的芯片。在今年3月英伟达的Blackwell新闻稿中，马斯克就公开喊话称英伟达的人工智能硬件是“最好的”。
（来源：英伟达）
值得一提的是，本月中旬时曾有消息称，xAI接近与甲骨文达成一项持续多年、价值“百亿美元”的云算力供应协议，一度推高甲骨文股价。一边不断采购算力，同时自建“算力超级工厂”，xAI追赶市场领跑者的架势已经显露无疑。
有知情人士称，xAI正在以240亿美元的估值目标展开融资，计划在未来几周内筹集超过60亿美元。粗略估算，这笔钱大概够买20万个H100芯片。
从AI大厂的角度来看，60亿美元大概只够烧1-2年的功夫。马斯克自己也曾承认，现阶段要在AI赛道具有竞争力，每年至少要花几十亿美元。
题外话：AI大佬早早布局“泛AI赛道”
随着英伟达本周又一次交出验证AI景气度的财报，美股市场也呈现了新的动向——除了炒芯片股外，资金也开始运作电力、电厂、电气设备、光伏等与数据中心配套有关的板块。
马斯克自然不必多说，特斯拉旗下拥有成熟的储能业务，同时也是不少光伏发电厂、光伏设备制造商的供应商。
OpenAI首席执行官山姆·奥尔特曼投资的核裂变初创公司Oklo也在本月中旬登陆美股市场。公司的首席执行官Jacob DeWitte本周接受采访时表示，目前来询问电力采购的80%客户都是数据中心运营商，他预期这种状况只是“冰山一角”，未来数据中心的需求还会更多。
Oklo本周宣布签订了一份100兆瓦规模的数据中心园区供电协议。不过公司至今尚未获得建设小型核电站的许可，DeWitte也表示2027年前都不太可能有投入运营的电站。
2.​Mojo崛起：AI-first 的编程语言能否成为新流行 1.AI语言的上一个黄金时代 这并不是AI第一次推动新编程语言的浪潮。20世纪70年代和80年代是AI语言的黄金时代，如LISP和Prolog，它们引入了开创性的概念，如符号处理和逻辑编程。那时，AI也是热门话题。
值得注意的是，LISP语言对软件的未来产生了深远影响，推出了函数式编程范式，最终影响了现代语言如Python、Haskell和Scala的设计。LISP也是首批实现动态类型的语言之一，在这种类型中，类型与值相关联而不是变量，允许更多的灵活性和更容易的原型开发。它还引入了垃圾回收功能，自动回收不再使用的内存，这是许多现代编程语言（如Java、Python和JavaScript）所采用的功能。可以公平地说，没有LISP，我们今天可能不会在这里。
当AI领域在20世纪70年代和80年代经历了一段资金和兴趣减少的长时间时，被称为“AI寒冬”，对专门AI语言如LISP的关注开始减退。同时，通用计算的快速发展导致了通用语言如C的兴起，这些语言为各种应用（包括系统编程和数值计算）提供了更好的性能和可移植性。
图片
2.AI-first语言的回归 现在，历史似乎在重演，AI再次推动了新编程语言的发明，以解决其棘手的问题。现代AI算法所需的强大数值计算和并行处理突显了需要能够有效桥接抽象和充分利用底层硬件的语言。
可以说，这一趋势始于TensorFlow的Tensor计算语法、Julia以及重新燃起的对数组导向语言如APL和J的兴趣，这些语言提供了与机器学习和神经网络的数学基础相一致的领域特定构造。这些项目试图减少将数学概念转换为通用代码的开销，让研究人员和开发人员能够更多地关注核心AI逻辑，而不是低级实现细节。
最近，一波新的AI-first语言应运而生，它们从头开始设计，以解决AI开发的特定需求。Higher Order Company创建的Bend旨在为AI提供灵活和直观的编程模型，具有自动微分和与流行AI框架的无缝集成功能。Modular AI开发的Mojo则专注于高性能、可扩展性和构建与部署AI应用的易用性。Swift for TensorFlow是Swift编程语言的扩展，结合了Swift的高级语法和TensorFlow的机器学习能力。这些语言代表了朝向AI开发的专用工具和抽象的日益增长的趋势。
虽然Python、C++和Java等通用语言在AI开发中仍然很受欢迎，但AI-first语言的复兴表明，AI的独特需求需要专门为该领域量身定制的语言，就像早期的AI研究催生了LISP等语言一样。
3.Python在AI中的局限性 Python因其简单性、通用性和广泛的生态系统长期以来一直是现代AI开发者的首选。然而，它的性能限制对于许多AI用例来说是一个主要缺点。
用Python训练深度学习模型可能会非常慢——我们说的是像在DMV（车辆管理局）排队等候那样慢，等待收银员找零那样慢。像TensorFlow和PyTorch这样的库通过使用底层的C++来帮助提高性能，但Python仍然是瓶颈，特别是在预处理数据和管理复杂的训练工作流时。
在实时AI应用如自动驾驶或实时视频分析中，推理延迟至关重要。然而，Python的全局解释器锁（GIL）阻止了多个本机线程同时执行Python字节码，导致在多线程环境中表现不佳。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bc610cd158b6a303d8dcd409c5563ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd94139d29d3bc3aff30b43b3f7d3809/" rel="bookmark">
			Java 18 的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 18的发布时间是2022年3月22日。这个版本带来了许多新的特性和改进，包括模式匹配增强、协程支持、SIMD指令支持等，这些功能为开发人员提供了更多的灵活性和控制力，有助于他们构建出更高效、可靠的应用程序。
Java 18 的新功能为多种应用场景提供了支持和优化。以下是一些主要的新功能及其应用场景：
模式匹配增强： 应用场景：在处理复杂数据结构或进行条件判断时，模式匹配可以帮助开发人员更简洁、更直观地编写代码。它特别适用于解析和匹配特定模式的文本、数据结构或对象。协程支持： 应用场景：在编写需要处理异步操作、提高并发性能的代码时，协程是非常有用的。它们允许开发者编写类似于同步代码的异步代码，减少回调和嵌套，提高代码的可读性和可维护性。协程在I/O密集型应用中特别有用，如Web服务器、数据库访问等。SIMD（单指令多数据）支持： 应用场景：在处理大量数值计算或进行图像处理、音视频编解码等任务时，SIMD指令可以提高程序的性能。通过同时操作多个数据项，SIMD指令可以加速这些计算密集型任务。简化的编译器控制（JEP 400）： 应用场景：在开发过程中，开发人员可能需要调整编译器的行为以满足特定的需求。简化的编译器控制API允许开发人员更容易地配置编译器选项，如启用或禁用警告、设置诊断信息的详细程度等。这对于定制编译过程、优化代码质量非常有用。UTF-8默认编码（JEP 400）： 应用场景：在处理文本文件、网络通信或跨平台交互时，字符编码的一致性是至关重要的。Java 18将UTF-8设置为默认编码，避免了因不同系统、地区或环境之间产生的编码问题。这使得Java应用程序在不同平台上具有更好的一致性和可移植性。代码片段API（JEP 413）： 应用场景：在开发过程中，有时需要动态执行代码片段并捕获其输出。代码片段API允许开发人员在编译时执行代码片段，并获取其执行结果。这对于构建动态脚本、测试框架或教育工具等场景非常有用。简单Web服务器（JEP 408）： 应用场景：jwebserver命令提供了一个简单的静态Web服务器，适用于测试、教育或演示等需求。开发人员可以快速启动一个Web服务器来托管静态资源，并验证其Web应用程序的行为。这对于前端开发、API测试或快速原型开发等场景非常有用。文件系统链接支持： 应用场景：在需要创建和管理文件系统链接的场景中，如构建复杂的文件系统结构、实现跨目录的文件共享或构建版本控制系统等，文件系统链接支持是非常有用的。它允许开发人员使用Java API来创建、查询和删除符号链接和硬链接。 这些新功能为Java开发人员提供了更多的灵活性和控制力，使他们能够更高效地构建出高性能、可靠的应用程序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44a6d876bc6619b554bfa6408d905572/" rel="bookmark">
			MySQL入门学习-查询进阶.别名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		别名（Alias）是为数据库中的表、列或表达式赋予的一个临时名称。使用别名可以使查询结果更具可读性，并且在复杂的查询中更方便地引用和处理数据。
在 MySQL 中，别名可以通过 'AS' 关键字来定义，例如：
SELECT column_name AS alias_name FROM table_name; 在上述示例中，'column_name' 是要查询的列名，'alias_name' 是为该列定义的别名。
除了为列定义别名外，还可以为表定义别名，例如：
SELECT * FROM table_name AS table_alias; 在上述示例中，'table_alias' 是为表定义的别名。
别名的特点和使用方法如下： 1. 提高查询结果的可读性： 通过为列或表定义别名，可以使查询结果更具可读性，方便理解和处理数据。
2. 方便引用和处理数据： 在复杂的查询中，可以使用别名来更方便地引用和处理数据，避免重复书写表名或列名。
3. 与其他高级应用结合使用： 别名可以与其他高级应用结合使用，例如子查询、连接查询、聚合函数等，使查询更加灵活和强大。
例如，我们可以使用别名来创建子查询，例如：
SELECT * FROM ( SELECT column_name AS alias_name FROM table_name ) AS subquery; 在上述示例中，我们首先创建了一个子查询，并将查询结果命名为 'subquery'。然后，我们可以在主查询中使用 'subquery' 来引用子查询的结果。
总之，别名是 MySQL 查询中的一个重要概念，它可以使查询结果更具可读性，并且在复杂的查询中更方便地引用和处理数据。
(文章为作者在学习MySQL过程中的一些个人体会总结和借鉴，如有不当、错误的地方，请各位大佬批评指正，定当努力改正，如有侵权请联系作者删帖。)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d3151e29cc3cc861025f547f9a6d73d/" rel="bookmark">
			minikube start 可选项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		minikube start 常用可选项 输入minikube start -h &gt; a.txt
常用如下
--kubernetes-version='': The Kubernetes version that the minikube VM will use (ex: v1.2.3, 'stable' for v1.30.0, 'latest' for v1.30.0). Defaults to 'stable'. --image-mirror-country='': 需要使用的镜像镜像的国家/地区代码。留空以使用全球代码。对于中国大陆用户，请将其设置为 cn。 --image-repository='': 用于从中拉取 docker 镜像的备选镜像存储库。如果您对 gcr.io 的访问受到限制，则可以使用该镜像存储库。将镜像存储库设置为“auto”可让 minikube 为您选择一个存储库。对于中国大陆用户，您可以使用本地 gcr.io 镜像，例如 registry.cn-hangzhou.aliyuncs.com/google_containers	--cpus='2': Number of CPUs allocated to Kubernetes. Use "max" to use the maximum number of CPUs. Use "no-limit" to not specify a limit (Docker/Podman only) --memory='': Amount of RAM to allocate to Kubernetes (format: &lt;number&gt;[&lt;unit&gt;], where unit = b, k, m or g).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d3151e29cc3cc861025f547f9a6d73d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fbe8c5bf0be8755b568adb7d9c521d3/" rel="bookmark">
			Java中print,println,printf的功能以及区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java中，System.out.print, System.out.println, 和 System.out.printf 都是用于在控制台输出的方法，但它们在使用和功能上有所不同。
System.out.print: * 功能：将指定的内容输出到控制台，但不换行。
* 示例：System.out.print("Hello, World!");
* 这行代码将在控制台上打印“Hello, World!”，并且光标会停在该行末尾，不会跳到下一行。
System.out.println: * 功能：将指定的内容输出到控制台，并在内容后面添加一个换行符，使得后续输出从新的一行开始。
* 示例：System.out.println("Hello, World!");
* 这行代码将在控制台上打印“Hello, World!”，然后光标会跳到下一行。
System.out.printf: * 功能：使用格式化字符串将指定的内容按照指定的格式输出到控制台。它类似于C语言中的printf函数，允许用户控制输出的格式，如对齐、宽度、精度等。
* 示例：System.out.printf("Hello, %s! You have %d new messages.%n", "Alice", 5);
* 这行代码将在控制台上打印“Hello, Alice! You have 5 new messages.”，并且光标会跳到下一行（因为使用了%n，它在printf中代表平台相关的行分隔符）。
区别：
System.out.print 和 System.out.println 主要用于简单的文本输出，其中 println 会在输出后添加一个换行符。System.out.printf 提供了更复杂的格式化输出功能，允许用户精确控制输出的格式。它使用格式化字符串和可变数量的参数来生成输出。 在选择使用哪种方法时，应根据具体需求来决定。如果只需要简单地输出文本并且不需要换行，可以使用 System.out.print。如果需要在输出后换行，可以使用 System.out.println。如果需要精确控制输出的格式，如对齐、宽度、精度等，则应该使用 System.out.printf。
原文链接： Java的print,printf,println的功能以及区别 - [红客网]编程与渗透技术笔记
红客网（blog.hongkewang.cn)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4004ab285be0ebf409e0d18e9ad5a3dd/" rel="bookmark">
			MyBatis复习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3.Mybatis复习 3.1 xml配置 properties：加载配置文件
settings：设置驼峰映射
&lt;settings&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; &lt;/settings&gt; typeAliases：类型别名设置
#这样在映射器里面的resultType属性不需要写实体类的全路径名 &lt;typeAliases&gt; &lt;package name="com.sh.pojo"/&gt; &lt;/typeAliases&gt; mappers 映射器
加载接口，关联映射文件
&lt;mappers&gt; &lt;package name="com.itheima.sh.dao"/&gt; &lt;/mappers&gt; 3.2 getMapper底层 首先调用Proxy.newProxyInstance方法创建Mapper动态代理动态代理invoke方法里会传入代理对象的方法，通过method.getName()获得方法名，接着使用Xpath解析xml从而获得id=方法名的标签表达式解析resultType属性值，通过反射技术class.forName(“resultType属性值”)获取到Class对象，通过newInstance（）构造返回对象解析出sql语句，执行，并且查询结果封装到返回对象中
3.3 SQL语句的CRUD select
&lt;!--parameterType="int" 表示sql语句参数id的类型，int是Integer的别名--&gt; &lt;select id="queryById" resultType="user" parameterType="int"&gt; select * from user where id = #{id} &lt;/select&gt; insert
&lt;insert id="saveUser"&gt; insert into user values (null ,#{username},#{birthday},#{sex},#{address}) &lt;/insert&gt; update
&lt;update id="updateUser"&gt; update user set username = #{username},birthday=#{birthday},sex=#{sex},address=#{address} where id = #{id} &lt;/update&gt; delete
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4004ab285be0ebf409e0d18e9ad5a3dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10ed456bd824c5fcc86c4802c9707520/" rel="bookmark">
			光速入门python的OpenCV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 欢迎来到我的博客
个人主页:北岭敲键盘的荒漠猫-CSDN博客
本文整理python的OpenCV模块的关键知识点
争取用最短的时间入门OpenCV
并且做到笔记功能直接复制使用
OpenCV简介 不浪费时间的介绍:
就是类似于ps操作图片。
至于为什么不直接用ps，因为只有程序能完成ps的操作，这样才能完全自动化2小时不间断的执行一些程序，总不能执行到一定地方要等你人为的在ps中做好图片再来执行程序吧。
功能点罗列:
画图，图片高斯模糊，腐蚀膨胀等处理，开启摄像头。
最基本的使用 导入模块:import cv2 方法作用cv2.getVersionString()返回OpenCV的版本cv2.imread(文件地址,图片灰彩类型) 读取文件,用于实例化对象
灰彩类型:(可以不写)
cv2.IMREAD_COLOR读入彩色图像cv2.IMREAD_GRAYSCALE读入灰色图像
对象.shape返回图片的大小(像素)cv2.imshow(窗口名,图片对象)返回个窗口用于展示这个图片cv2.waitKey(自动关闭时间) 窗口不自动关闭，知道按下任意键或者到规定时间(时间为微秒)
返回他按得键的代号数字
到时间返回-1
cv2.imwrite(保存路径和文件名,保存的图片)保存编辑的图片 注意:
这个库不支持任何中文!!!!!
不管是图片文件命名还是窗口等
一律别用中文！！！！！！！
（至少我的版本不支持任何中文）
案例演示:
import cv2#导入库 print(cv2.getVersionString())#返回版本号 image=cv2.imread("konglong.jpg")#导入图片，实例化 print(image.shape)#返回图片的大小和通道 cv2.imshow("阿萨德",image)#展示图片 cv2.waitKey(1000)#设置暂停 cv2.imwrite("okok.jpg",image)#保存图片 结果:
打印信息
保存okok图片
展示图片(代码中用中文做窗口所以会乱码)
视频的打开方式 我们视频有两种：摄像头，视频文件
用到的函数:
读取视频或摄像头:cv2.VideoCapture(视频或者摄像头的指针) 返回视频读取的照片:cap.read() 开启摄像头
思路:原理就是对这摄像头一遍遍截图。然后我们不断的刷新显示的图片。
代码如下:
import cv2#导入库 cap=cv2.VideoCapture(0)#读取摄像头 while True:#循环 valu,video=cap.read()#读取摄像头内容 show=cv2.imshow("video",video)#展示摄像头 key=cv2.waitKey(1)#设置等待0.001秒刷新一次 print(key) if key!=-1:#如果不是到时间刷新的视频就退出视频 break 结果如下:
按下别的键就关闭了。(字母有时候不行，数字或者特殊按键相对靠谱点)
视频打开方式
代码:
import cv2#导入库 cap=cv2.VideoCapture("bingdu.mp4") while True: valu,video=cap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10ed456bd824c5fcc86c4802c9707520/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ada0bf4bbc94f6322880d7149e8f68e8/" rel="bookmark">
			Java---图书管理系统(练习版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.主函数 import book.Book; import book.BookList; import user.AdminUser; import user.NormalUser; import user.User; import java.util.Scanner; public class Main { public static User Login(){ //确认你的身份 System.out.println("请输如你的名字"); Scanner scanner=new Scanner(System.in); String name=scanner.nextLine(); System.out.println("请输如你的身份，1.管理员 2.普通用户"); int choice=scanner.nextInt(); if(choice==1){ //返回一个建立好的对象 return new AdminUser(name); }else{ return new NormalUser(name); } } public static void main(String[] args) { BookList bookList=new BookList(); User user=Login(); //根据用户输入的身份和输入的数字实现相对应的操作 while(true){ int choice= user.menu(); user.doIoperation(choice,bookList); } } } 2.user包 2.1User类 package user; import book.BookList; import ioperation.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ada0bf4bbc94f6322880d7149e8f68e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/983167cec9c693ab6ef9df3b66e7df32/" rel="bookmark">
			C&#43;&#43; 数据结构算法 学习笔记(32) -五大排序算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ 数据结构算法 学习笔记(32) -五大排序算法 选择算法 如下若有多个女生的身高需要做排序:
常规思维:
第一步先找出所有候选美女中身高最高的，与最后一个数交换 第二步再找出除最后一位美女外其它美女中的最高者，与倒数第二个美女交换位置 再找出除最后两位美女外其它美女中的最高者，与倒数第三个美女交换位置，因为倒数 第三个本身已是最大的，所以实际无需交换. 重复以上步骤，直到最后只剩下一人，此时，所有的美女均已按照身高由矮到高的 顺序排列 代码实现:
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; void swap(int* num1, int* num2)//交换两个变量的值 { int temp = *num1; *num1 = *num2; *num2 = temp; } void SelectSort1(int arr[], int len) { for (int i = 0; i &lt; len - 1; i++) { int max = 0; for (int j = 1; j &lt; len - i; j++) { //查找未排序的元素 if (arr[j] &gt; arr[max]) { //找到目前最小值 max = j; } } //printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/983167cec9c693ab6ef9df3b66e7df32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b8121d618a77f6e78fca0fd60bb8e3a/" rel="bookmark">
			基于YOLOv8&#43;PySide6的快递分类管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、背景 随着电子商务的飞速发展，快递行业所承受的数据处理需求愈发庞大。在这样的背景下，传统的手工分类方法已经显得力不从心，因其不仅耗时耗力，还存在着易出错的隐患。因此，迫切需要研发出一套高效而准确的自动化系统，以应对这一挑战，其重要性愈发凸显。这样的系统不仅能够有效地提升快递行业的运营效率，还能够降低人力成本，减少错误发生的可能性，从而为行业的可持续发展提供有力支撑。
2、PySide6 框架 PySide6是一套在Python环境下使用Qt6 API库的GUI开发框架，由Qt官方维护。它提供了一系列丰富的控件和组件，使得开发者可以轻松创建现代化的图形用户界面。PySide6的主要特点包括：
跨平台支持：PySide6支持Windows、MacOS和Linux等多个操作系统。丰富的控件：包括QWidget、QLabel等基础组件，以及更高级的控件如QSS皮肤和图标库。易于学习：有大量的中文教程和示例代码，方便初学者快速入门 3、软件界面 支持图片、视频及摄像头进行检测，同时支持图片的批量检测；界面可实时显示目标位置、目标总数、置信度、用时等信息;支持图片或者视频的检测结果保存； 4、数据集及训练 快递包裹数据集主要包含6类：纸箱子、气泡袋、泡沫箱、信封、防水袋、条形码，用于实时检测；
训练集：6544张图片，测试集：2254张图片，yolov标签可直接训练
nc: 6 names: 0: express box 1: bubble wrap 2: foam box 3: envelope 4: Waterproof bag 5: bar code data.yaml的具体内容如下：
train: E:\yolodetect\datasets\mydata2\train\images val: E:\yolodetect\datasets\mydata2\val\images nc: 6 names: 0: express box 1: bubble wrap 2: foam box 3: envelope 4: Waterproof bag 5: bar code 4.1 训练结果 4.2 训练结果评估 在深度学习中，我们通常用损失函数下降的曲线来观察模型训练的情况。YOLOv8在训练时主要包含三个方面的损失：定位损失(box_loss)、分类损失(cls_loss)和动态特征损失（dfl_loss），在训练结束后，可以在runs/目录下找到训练过程及结果文件，如下所示：
本文训练结果如下：
5. 检测结果识别 6. 结论与展望 基于YOLOv8+PySide6的快递分类管理系统是一个结合了先进图像处理技术和现代GUI开发框架的创新项目。通过使用YOLOv8算法，该系统能够高效地识别和分类各种快递包裹，极大地提高了物流处理的自动化水平和准确性。PySide6作为一个强大的Qt6 API库，为该系统提供了丰富的用户界面（UI）设计和交互功能，使得操作更加直观和便捷。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b8121d618a77f6e78fca0fd60bb8e3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/327c6294f32688adf56849585e55470c/" rel="bookmark">
			听说部门来了个00后测试开发，一顿操作给我整麻了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司新来了个同事，听说大学是学的广告专业，因为喜欢IT行业就找了个培训班，后来在一家小公司实习半年，现在跳槽来我们公司。来了之后把现有项目的性能优化了一遍，服务器缩减一半，性能反而提升4倍！给公司省了不少成本。
后来才知道，他在以前的公司，业务能力特别强，JVM调优经验丰富。
在他来之前我们公司从不不做JVM调优，之前也有朋友说，“我们公司的系统从来都没有经过性能调优，集成测试没问题后就上线了，上线后也几乎没出现过性能问题。”
这个新同事把他的自己用的面试资料发给了我，我觉得还不错，分享给大家。不管你是要入门学习还是想面试跳槽巩固基础，都可以免费领取一份。
盘里头是一整套软件测试面试必备文档PDF，看完之后直接给我老哥给跪了…这下面试果然稳了。
内容涵盖：包括测试理论、Linux基础、MySQL基础、Web测试、接口测试、App测试、管理工具、Python基础、Selenium相关、性能测试、LordRunner相关等… 质量非常高，需要的可文末自行领取（免费）！！
全网首发-涵盖16个技术栈
第一部分，测试理论（测试基础+需求分析+测试模型+测试计划+测试策略+测试案例等等）第二部分，Linux（ Linux基础+Linux练习题）第三部分，MySQL（基础知识+查询练习+万年学生表经典面试题汇总+数据库企业真题）第四部分，Web测试第五部分，API测试第六部分，App测试第七部分，管理工具第八部分，Python基础（Python基础+编程题+集合+函数+Python特性等等）第九部分，Selenium相关第十部分，性能测试第十一部分，LordRunner相关第十二部分，计算机网络第十三部分，组成原理第十四部分，数据结构与算法第十五部分，逻辑题第十六部分，人力资源 软件测试基础 软件测试的步骤是什么?如何录制测试脚本?应该考虑进行如何测试的测试方法怎样估计测试工作量?测试设计的问题当测试过程发生错误时，有哪几种解决办法?测试执行的问题测试评估的目标如何提高测试?C/S模式的优点和缺点B/S模式的优点和缺点… Linux grep和find的区别? grep 都有哪些用法?查看IP地址?创建和删除一个多级目录?在当前用户家目录中查找haha.txt文件?如何查询出tomcat的进程并杀掉这个进程，写出linux命令?动态查看日志文件?查看系統硬盘空间的命令?查看当前机器listen 的所有端口?… Python编程 统计python源代码文件中代码行数，去除注释，空行，进行输出?python调用cmd并返回结果?冒泡排序1,2,3,4 这4个数字，能组成多少个互不相同的且无重复的三位数，都是多少?请用 python 打印出 10000 以内的对称数（对称数特点：数字左右对称，如：1,2,11,121,1221 等）给定一个整数 N，和一个 0-9 的数 K，要求返回 0-N 中数字 K 出现的次数判断 101-200 之间有多少个素数，并输出所有的素数一个输入三角形的函数，输入后输出是否能组成三角形，三角形类型，请用等价类- 划分法设计测试用例… MySQL 你用的Mysql是哪个引擎，各引擎之间有什么区别?如何对查询命令进行优化?数据库的优化?Sql注入是如何产“生的，如何防止?NoSQL和关系数据库的区别?MySQL与MongoDB本质之间最基本的差别是什么Mysql数据库中怎么实现分页?Mysql数据库的操作?优化数据库?提高数据库的性能?什么是数据的完整性?… Web测试 Web测试和app测试区别？WEB测试环境搭建和测试方法WEB测试教程WEB测试要点及基本方法Web测试页面总结… 接口测试 什么是接口如果模块请求http改为了https,测试方案应该如何制定，修改?常用HTTP 协议调试代理I具有什么?详细说明抓取HTTPS协议的设置过程?描述TCP/IP协议的层次结构，以及每一-层中重要协议jmeter,一个接口的响应结果如下:接口产生的垃圾数据如何清理依赖第三方的接口如何处理测试的数据你放在哪?什么是数据驱动，如何参数化?… 性能测试 你认为性能测试的目的是什么?做好性能测试的工作的关键是什么?服务端性能分析都从哪些角度来进行?如何理解压力测试，负裁测试以及性能测试?如何判断是否有内存泄漏及关注的指标?描述软件产“生内存泄露的原因以及检查方式。(可以结合- 种开发语言进行描述)简述什么是值传递，什么是地址传递，两者区别是什么?什么是系统瓶颈?… selenium 如何开展自动化测试框架的构建?如何设计自动化测试用例:webdriver如何开启和退出一个浏览器?什么是自动化测试框架?Selenium是什么，流行的版本有哪些?你如何从命令行启动Selenium RC?在我的机器端口4444不是免费的。我怎样才能使用另一个端口?什么是Selenium Server,它与Selenium Hub有什么不同?你如何从Selenium连接到数据库?你如何验证多个页面上存在的一个对象?XPath中使用单斜杠和双斜杠有什么区别?如何编写SeleniumIDE/ RC的用户扩展?如何在页面加载成功后验证元素的存在?你对Selenium Grid有什么了解?它提供了什么功能?如何从你的Java Class启动Selenium服务器?Selenium中有哪些验证点?什么是XPath?什么时候应该在Selenium中使用XPath? …
计算机与网络 一台计算机的IP是192.168.10.71子网掩码255.255.255.64与192.168.10.201 …请简述DNS、活动目录、域的概念。10M兆宽带是什么意思?理论下载速度是多少?什么是IP地址?OSI七层网络模型的划分?TCP和UDP有什么不同?HTTP属于哪一层的协议?HTTP和HTTPS的区别?cookies和session的区别?HTTP的get请求和post请求的区别?HTTP1.0和HTTP1.1有什么区别TCP的连接建立过程，以及断开过程?客户端使用DHCP获取IP的过程?写出某个网段的网络地址和广播地址?… 人力资源 你的测试职业发展是什么？你自认为做测试的优势在哪里？你找工作时，最重要的考虑因素为何？为什么我们应该录取你？请谈谈你个人的最大特色。一个测试工程师应具备那些素质和技能？还有问一下你是怎样保证软件质量的，也就是说你觉得怎样才能最大限度地保证软件质量？为什么选择测试这行？如果我雇用你，你能给部门带来什么贡献？… 最后 这份文档，对于想从事【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴我走过了最艰难的路程，希望也能帮助到你！
完整版资料获取方式：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52518040ea83b8aedc90d98ac7a43cdc/" rel="bookmark">
			若依框架代码生成器详解：从入门到高级定制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		若依框架（RuoYi）作为一个基于Spring Boot和MyBatis的快速开发平台，提供了强大的代码生成器功能。通过代码生成器，开发者可以迅速创建基础的CRUD（增删改查）代码，大幅提高开发效率。本文将详细介绍若依框架代码生成器的使用方法，包括基本操作、模板定制、常见问题解决等方面，帮助开发者更好地掌握和利用这一工具。
一、代码生成器概述 若依代码生成器主要用于从数据库表生成对应的实体类、Mapper接口、Service层和Controller层代码，以及相应的前端页面代码。它通过读取数据库元数据（表结构和字段信息），自动生成标准化的代码模板，减少手工编码的工作量。
二、代码生成器基本使用方法 准备工作： 确保已经正确配置了数据源，使得若依框架能够访问到目标数据库。数据源配置在application-dev.yml文件中，如下所示：
spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/ruoyi?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC username: root password: your_password 进入代码生成器界面： 启动若依框架后，使用管理员账户登录后台管理系统，导航到“系统工具” -&gt; “代码生成” 页面。此时，你会看到数据库中所有表的列表。
选择表生成代码： 在表列表中，选择你要生成代码的表，点击“生成”按钮，弹出代码生成配置界面。
配置生成选项： 在代码生成配置界面，可以设置生成代码的包路径、模块名称、作者信息等。具体配置项包括：
包路径：Java类的包路径，如com.ruoyi.project.system.user。模块名称：生成代码所属模块，如system。作者：生成代码的作者信息。生成路径：代码生成后的保存路径。配置完成后，点击“生成”按钮，即可生成对应的代码文件。
查看生成代码： 生成的代码文件会存放在项目的ruoyi-generator/src/main/java目录下。生成的代码包括以下几个部分：
实体类：对应数据库表的实体类，通常位于domain包下。Mapper接口：数据访问层接口，位于mapper包下。Service层：业务逻辑层接口和实现类，位于service包下。Controller层：控制器类，位于controller包下。前端页面：生成对应的Vue.js页面文件，位于ruoyi-ui/src/views目录下。 三、代码生成器模板定制 若依框架的代码生成器使用Freemarker模板引擎进行模板生成，开发者可以根据实际需求定制自己的代码模板。
模板文件位置： 模板文件通常位于ruoyi-generator/src/main/resources/vm目录下，包括：
java/domain.java.vm：实体类模板。java/mapper.java.vm：Mapper接口模板。java/service.java.vm：Service接口模板。java/serviceImpl.java.vm：Service实现类模板。java/controller.java.vm：Controller类模板。 修改模板文件： 以实体类模板domain.java.vm为例，打开文件，修改模板内容，例如：
package ${packageName}; import java.io.Serializable; import java.util.Date; /** * ${table.comment} 实体类 * * @author ${author} * @date ${datetime} */ public class ${ClassName} implements Serializable { private static final long serialVersionUID = 1L; &lt;#list columns as column&gt; /** ${column.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52518040ea83b8aedc90d98ac7a43cdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24231a9c622c01f800f337ba3deaa3b8/" rel="bookmark">
			C# 深拷贝和浅拷贝
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.深拷贝2.浅拷贝3.拷贝类4.浅拷贝的实现5.深拷贝实现5.1 浅拷贝对象，对引用类型重新一个个赋值5.2 反射实现5.3 利用XML序列化和反序列化实现 1.深拷贝 拷贝一个对象时，不仅仅把对象的引用进行复制，还把该对象引用的值也一起拷贝。这样进行深拷贝后的拷贝对象就和源对象互相独立，其中任何一个对象的改动都不会对另外一个对象造成影响。
int source = 123; // 值类型赋值内部执行深拷贝 int copy = source; // 对拷贝对象进行赋值不会改变源对象的值 copy = 234; Console.WriteLine($"source = {source},copy = {copy}"); // 123 234 // 同样对源对象赋值也不会改变拷贝对象的值 source = 345; Console.WriteLine($"source = {source},copy = {copy}"); // 345 234 深拷贝示意图：
2.浅拷贝 ==拷贝一个对象时，仅仅拷贝对象的引用进行拷贝，但是拷贝对象和源对象还是引用同一份实体。==此时，其中一个对象的改变都会影响到另一个对象。
public class Person { public string Name { get; set; } } public static void Main(string[] args) { Person sourceP = new Person() { Name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24231a9c622c01f800f337ba3deaa3b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36e2db1230b7aef7d7d4311960d2c8dd/" rel="bookmark">
			如何解决VSCode Git插件差异查看器 无法读取文件 Error: 无法解析不存在的文件 的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述 问题：在使用VSCode的Git插件中的差异查看器时，有时会出现如下报错信息：
无法读取文件 'git:/d:/Desktop//UIInput.js?{"path":"d:\\Desktop\\UIInput.js","ref":"~"}' (Error: 无法解析不存在的文件 'git:/d:/Desktop//UIInput.js?{"path":"d:\\Desktop\\UIInput.js","ref":"~"}') 这个错误信息指示了一个文件路径的问题，表明不存在指定的文件或无法解析文件路径。
问题根源 对于这个问题，根本原因其实来源于版本控制的配置文件——.gitmodules。.gitmodules 文件主要用于管理Git子模块（submodule），其中存储了子模块的路径和URL信息。如果这个文件中存在不准确的信息或配置错误，就有可能引发文件路径解析的问题，从而造成差异查看器无法正常工作。
解决方案 幸运的是，解决这个问题的方法非常简单：删除.gitmodules文件。这样可以避免子模块的误配置对Git插件的影响。具体步骤如下：
步骤一：定位.gitmodules文件 首先，打开VSCode或其他文本编辑器，找到项目根目录中的.gitmodules文件。通常，该文件与.git文件夹位于同一层级。
步骤二：删除.gitmodules文件 确认无误后，将.gitmodules文件删除。如果你出于谨慎考虑，可以先备份该文件，然后再进行删除操作。
步骤三：重新打开VSCode 关闭并重新打开VSCode，重新载入工作区。这时，再次尝试打开Git插件的差异查看器，报错信息应该已经消失，功能应恢复正常。
注意事项 备份文件：在删除.gitmodules文件之前，建议先进行备份，以防万一需要恢复或进一步调整配置。检查子模块：如果你的项目确实需要使用子模块，那么删除.gitmodules文件可能无法解决问题，这种情况下需要检查并修正子模块的配置。更新VSCode：确保你的VSCode和相关的Git插件都是最新版本，有时错误可能因软件版本不一致或bug导致。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/4/">«</a>
	<span class="pagination__item pagination__item--current">5/71</span>
	<a class="pagination__item pagination__item--next btn" href="/page/6/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>