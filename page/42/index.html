<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.126.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程学习者的博客">
		<meta property="og:url" content="https://bcxuexizhe.github.io/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="编程学习者">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f633cc0bcfc457584e5d13c635afa27/" rel="bookmark">
			vue3&#43;Vite&#43;TS项目，配置ESlint和Prettier
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建vue3项目 实操过的有两种方式
1.vue脚手架2.vite（推荐，也是尤大大团队研发） 具体怎么新建一个vue3项目就不多讲了，可以按照官方文档来
创建后的文件目录长这样
多提一句，vite也会随着时间不断迭代，后续项目结构可能还会发生变化，当前使用的vue版本
和vite版本也一并贴出来
下面进入正题，为项目配置ESLint+Prettier
ESLint 1.ESLint介绍 是一个用于检测 ECMAScript/JavaScript 代码中的潜在问题和错误的工具，旨在使代码更一致并避免错误。它可以帮助开发者检测代码中的潜在问题，提高代码质量。
2.使用前提 必须安装Node.js（^12.22.0、 ^14.17.0 或&gt;=16.0.0）
3.安装ESLint 方式一：以问题的形式，根据用户选择配置属性
使用以下命令安装和配置 ESLint :
npm init @eslint/config # or yarn create @eslint/config # or pnpm create @eslint/config 注意：运行以上命令是假设您已经有了一个package.json文件。如果没有，请确保事先运行pnpm init、npm init或yarn init。
按照提示步骤一步一步选择, 回车即可:
使用ESLint做什么? 建议选择第三个, 检查语法, 发现问题, 强制代码风格
? How would you like to use ESLint? … To check syntax only To check syntax and find problems ❯ To check syntax, find problems, and enforce code style 项目模块类型?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f633cc0bcfc457584e5d13c635afa27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aa3739043b818ecaadc469f5df45703/" rel="bookmark">
			axios 传递参数的方式(data 与 params)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 提示：这里可以添加系列文章的所有文章的目录，目录需要自己手动添加
工作案例：在 vue 项目使用 axios 传递参数的方式(data 与 params)
提示：写完文章后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 系列文章目录前言一、data 的形式1). FormData的使用 二、params 的形式三、混合使用1）. 文件类传参 总结 前言 提示：这里可以添加本文要记录的大概内容：
工作中，用到的传递参数总结，后期一点点补齐。
提示：以下是本篇文章正文内容，下面案例可供参考
一、data 的形式 通常用于 POST、PUT 等请求方法的请求体中传递数据。适用于传递复杂的数据结构，例如 JSON 对象、FormData 等。当使用 data 传递参数时，参数会被包含在请求体中，适合传递需要修改服务器状态的数据。 例如，在发送 POST 请求时，使用 data 参数传递数据：axios.post('/api/url', data)
示例： data 形式的数据有可以做好多事情， 文件上传，表单提交 等
一般工作中使用data接收：
export function finalHandle(data) { return request({ url: '/uav/finalHandle', method: 'post', data, timeout: 30000, // 设置超时时间为30秒 }) } // 表单 let formdata = new FormData(); formdata.append("handleUuid", handleUuid); formdata.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3aa3739043b818ecaadc469f5df45703/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a67de820cb2799f6264cc4f1e69551d/" rel="bookmark">
			深入解析实时数仓Doris：介绍、架构剖析、应用场景与数据划分细节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		码到三十五 ： 个人主页 心中有诗画，指尖舞代码，目光览世界，步履越千山，人间尽值得 ! Doris是一款高性能、开源的实时分析数据仓库，旨在为用户提供毫秒级查询响应、高并发、高可用以及易于扩展的OLAP解决方案。它融合了MPP（大规模并行处理）架构与分布式存储，支持PB级别的数据存储和分析，是大数据场景下理想的实时数仓选择。
目录 1. Doris 介绍2. 使用场景2.1 报表分析2.2 即席查询（Ad-hoc Query）2.3 数仓构建2.4 数据湖联邦查询 3. 技术概述4. 数据划分4.1 基本概念4.2 数据划分 1. Doris 介绍 Apache Doris 是一个基于 MPP 架构的高性能、实时的分析型数据库，以极速易用的特点被人们所熟知，仅需亚秒级响应时间即可返回海量数据下的查询结果，不仅可以支持高并发的点查询场景，也能支持高吞吐的复杂分析场景。基于此，Apache Doris 能够较好的满足报表分析、即席查询、统一数仓构建、数据湖联邦查询加速等使用场景，用户可以在此之上构建用户行为分析、AB 实验平台、日志检索分析、用户画像分析、订单分析等应用。
Apache Doris 最早是诞生于百度广告报表业务的 Palo 项目，2017 年正式对外开源，2018 年 7 月由百度捐赠给 Apache 基金会进行孵化，之后在 Apache 导师的指导下由孵化器项目管理委员会成员进行孵化和运营。目前 Apache Doris 社区已经聚集了来自不同行业数百家企业的 600 余位贡献者，并且每月活跃贡献者人数也超过 120 位。 2022 年 6 月，Apache Doris 成功从 Apache 孵化器毕业，正式成为 Apache 顶级项目（Top-Level Project，TLP）
Apache Doris 如今在中国乃至全球范围内都拥有着广泛的用户群体，截止目前， Apache Doris 已经在全球超过 4000 家企业的生产环境中得到应用，在中国市值或估值排行前 50 的互联网公司中，有超过 80% 长期使用 Apache Doris，包括百度、美团、小米、京东、字节跳动、腾讯、网易、快手、微博、贝壳等。同时在一些传统行业如金融、能源、制造、电信等领域也有着丰富的应用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a67de820cb2799f6264cc4f1e69551d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89b8096d89840085e9a3af1b0720820c/" rel="bookmark">
			【mysql 127错误】mysql启动报错mysqld.service: Failed with result ‘exit-code‘.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无网环境，mysql 安装 出现如下错误
[root@mysql tools]# systemctl status mysqld.service ● mysqld.service - MySQL Server Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled) Active: failed (Result: exit-code) since Fri 2024-03-22 20:20:44 CST; 12s ago Docs: man:mysqld(8) http://dev.mysql.com/doc/refman/en/using-systemd.html Process: 12371 ExecStart=/usr/sbin/mysqld $MYSQLD_OPTS (code=exited, status=127) Process: 12340 ExecStartPre=/usr/bin/mysqld_pre_systemd (code=exited, status=0/SUCCESS) Main PID: 12371 (code=exited, status=127) Mar 22 20:20:44 mysql systemd[1]: mysqld.service: Service RestartSec=100ms expired, scheduling restart. Mar 22 20:20:44 mysql systemd[1]: mysqld.service: Scheduled restart job, restart counter is at 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89b8096d89840085e9a3af1b0720820c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38b38d52fdf6437de2850d40ad36f069/" rel="bookmark">
			Ai绘画工具，Stable Diffusion插件使用攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家分享一下Stable Diffusion的插件使用攻略。
一、什么是插件 Stable Diffusion的插件主要是用来丰富SD的一些功能，例如C站助手，提示词助手，图片信息助手等插件都是为了增强SD的实用性。
二、安装插件 我们以C站助手为例，C站助手可以将从C站（civitai.com）下载的Lora模型和大模型自动加载封面图和触发词等，此外还可以添加模型的访问地址，如下图就是我们安装好的C站助手。
下面我们开始告诉大家安装插件的3种方法。
1、通过网址安装 点击WebUI菜单栏里的扩展(Extentions)，选择从网址安装标签，复制粘贴下面的这个网址，点击安装即可。
https://github.com/butaixianran/Stable-Diffusion-Webui-Civitai-Helper
2、通过扩展列表安装 此外你也可以从“可下载”标签卡里查找自己需要的插件，然后点击“安装”即可。
3、网上下载存放到指定目录 此外你还可以直接将下载并解压好的插件安装包，放在SD的extensions目录下面，如下图：
如果你使用的秋叶大佬的整合包，那么这些插件默认都是提前给你安装好的。
三、插件功能介绍 我们以秋叶大佬默认提供的插件先给大家逐一介绍，不管你是初学者，还是炼丹师，基本都会用到这些插件。
秋叶整合包
百度网盘：https://pan.baidu.com/s/1ejV_tgfi3s7FClYNIrm5Xw?pwd=1024
提取码：1024
夸克网盘：https://pan.quark.cn/s/aca68291e67d
1、a1111-sd-webui-tagcomplete 这是文生图里面常用的一个提示词插件，其主要功能就是能够根据你输入的内容，自动联想词汇供你选择，如下图：
当我们输入：ma 两个字符，下面立马自动给你提供了备选单词。
此外还支持中文提示，当我们输入：女孩，下面也会自动提供与女孩相关的备选词汇。
插件下载地址：
https://github.com/DominikDoom/a1111-sd-webui-tagcomplete.git
2、adetailer 这款插件主要是用来修复人脸崩坏的情况，此外还可以优化人的手部和全身，是一款修图插件。
我们可以看一下使用前后的图片效果：
图片来源：迹寒编程
使用步骤
①、我们在SD的界面上找到ADetailer这个插件，点击“启用After Detailer”就可以使用它了。
②、选择我们需要使用的模型
每个模型适用场景有所不同，具体如下：
模型 适用对象 face_yolov8n.pt 2D / 真实人脸 face_yolov8s.pt 2D / 真实人脸 hand_yolov8n.pt 2D / 真实人手 person_yolov8n-seg.pt 2D / 真实全身 person_yolov8s-seg.pt 2D/真实全身 mediapipe_face_full 真实人脸 mediapipe_face_short 真实人脸 mediapipe_face_mesh 真实人脸 mediapipe_face_mesh_eyes_only 真实人眼 其它默认即可。
插件下载地址：
https://github.com/Bing-su/adetailer.git
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38b38d52fdf6437de2850d40ad36f069/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cae41cf6a319f223c78a69d05d6cce7/" rel="bookmark">
			LLAMA权重文件终于找到国内高速网盘链接了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LLaMA 7b 13b 65b大模型权重文件预训练文件国内镜像（百度网盘）（伸手党的福音！） 众所周知，llama官网下载非常恶心，所以找了个链接。这样大家能高速下载。还挺快的。
LLaMA 7b 13b 65b大模型
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c16d2004b21b0e67ca0d07faafa09c44/" rel="bookmark">
			玩转Python的fake-useragent库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python的fake-useragent库是一个神奇的工具，它能帮助我们在网络世界中隐身行走，摆脱身份束缚。接下来，我们将一起走进fake-useragent库的神秘世界，了解它的强大功能，并通过一些实例探讨如何使用它。
一、fake-useragent库简介 fake-useragent库是一个专门用于生成伪装身份的Python库，可以让我们在网络爬虫、自动化测试等场景中轻松绕过一些反爬机制。它主要有以下特点：
使用简单：只需要简单地调用一个函数，就可以轻松地生成各种浏览器的User-Agent。数据丰富：包含了大量现代浏览器、操作系统等的User-Agent数据。自动更新：可以根据需要自动更新User-Agent数据，保持数据的新鲜度。 二、安装fake-useragent库 要开始使用fake-useragent库，首先需要安装。安装方法非常简单，只需要使用以下命令：
pip install fake-useragent 三、使用fake-useragent库生成User-Agent 在安装完成fake-useragent库之后，我们可以开始尝试使用它来生成User-Agent了。让我们先来看一个简单的例子：
from fake_useragent import UserAgent ua = UserAgent() # 随机生成一个User-Agent random_user_agent = ua.random print(random_user_agent) 在这个例子中，我们导入了fake_useragent库中的UserAgent类，并创建了一个实例。接着，我们调用了实例的random属性，生成了一个随机的User-Agent，并将其打印出来。
除了随机生成User-Agent之外，我们还可以按照浏览器类型来生成User-Agent，如下所示：
from fake_useragent import UserAgent ua = UserAgent() # 生成Chrome浏览器的User-Agent chrome_user_agent = ua.chrome print(chrome_user_agent) # 生成Firefox浏览器的User-Agent firefox_user_agent = ua.firefox print(firefox_user_agent) 在这个例子中，我们分别调用了UserAgent实例的chrome和firefox属性，生成了对应浏览器的User-Agent，并将其打印出来。
举例选取了常见的几款款PC端浏览器类型 [ua.safari,ua.chrome, ua.firefox,ua.edge]
四、结合网络爬虫使用fake-useragent库 现在我们已经了解了如何使用fake-useragent库生成User-Agent，接下来让我们看一个实际的网络爬虫例子，演示如何在爬虫中使用fake-useragent库来伪装我们的身份。
import requests from fake_useragent import UserAgent ua = UserAgent() # 随机生成一个User-Agent random_user_agent = ua.random url = "https://www.example.com/" headers = { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c16d2004b21b0e67ca0d07faafa09c44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9ad279afc9a0e362598c8fdf50a9e78/" rel="bookmark">
			【C&#43;&#43; leetcode】双指针问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 611. 有效三角形的个数 题目
给定一个包含非负整数的数组 nums ，返回其中可以组成三角形三条边的三元组个数。
题目链接
. - 力扣（LeetCode）
画图 和 文字 分析
判断是否是三角形要得到三边，由于遍历三边要套三层循环，时间复杂度很大，所以这里我们需要借助双指针思想，可以降到 O（N * N），先将这个数组进行排序（升序），然后定义三个指针，一个开始固定在数组的最后一个元素的位置，另外两个指向第一个位置和最后一个元素的前一个位置
举例： 输入[4,2,3,4]，输出 4
如图
因为是排好序的，判断的时候，只需要拿 left , right 所指向的元素与 n 所指向的元素进行对比
比较过程会遇到两种情况：
第一种是不能构成三角形，则让 left++ ，
第二种是能构成三角形，则让 count += left - right (如果能构成三角形，则 right 和 n 不变，left 与 right 之间的区间都能构成三角形 ) ，right-- ,
直到 left &gt;= right（里层循环结束条件） , 再 n--， right = n - 1 , left = 0
外出循环结束条件：n &lt; 2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9ad279afc9a0e362598c8fdf50a9e78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4b36c8f5c6526403ce72da980a6c7cb/" rel="bookmark">
			2024年人工智能顶级会议投稿信息汇总（数据挖掘领域）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据挖掘是信息科学领域的重要分支，致力于挖掘和分析庞大数据集中的有价值模式与规律。它融合了统计学、机器学习和数据库技术，目的是从海量数据中抽取有用的知识，辅助决策制定过程。本文首先精选介绍数据挖掘领域内的重要会议，包括会议主题、稿件提交的截止日期、会议的时间与地点等关键信息，帮助读者深入了解。接着，将这些信息汇总至一张表格中，使得研究人员和实践者可以快速地获取并理解相关会议的细节，便于规划投稿或参会。所有会议的图片信息均直接来源于其官方网站。需要注意的是，由于会议详情可能会调整，具体信息可能发生变动。因此，我们建议准备投稿或参与会议的读者，以各会议官方网站公布的最新信息为准。本文作者为邱雪，审校为李杨和黄星宇。
一、会议介绍 1、SIGKDD——国际数据挖掘与知识发现大会 会议时间/地点：2024年8月25-29日，西班牙，巴塞罗那
第一次摘要截止日期：2024年2月1日
截稿时间：2024年2月8日
录用通知时间：2024年5月16日
会议官网：https://kdd2024.kdd.org/
SIGKDD（ACM Knowledge Discovery and Data Mining）会议是由ACM旗下的KDD组织主办的国际会议，专注于知识发现和数据挖掘领域。它汇集了理论探索、算法革新与实际应用等全方位议题，跨越数据处理、模式识别、机器学习、统计分析等众多学科，展示了学术界、政府机构和工业界的前沿成就。作为此领域最有权威的年会之一，SIGKDD每年都吸引着来自世界各地的业界精英参加会议。
2、SIGMOD——ACM数据管理国际会议 会议时间/地点：2024年6月9-15日，智利，圣地亚哥
第一次论文提交时间：2023年1月15日
最终截稿时间：2023年10月15日
录用通知时间：2024年2月23日
会议官网：https://2024.sigmod.org/
SIGMOD（ACM Conference on Management of Data）会议每年6月举行，专注于数据库管理系统和数据管理技术领域。会议内容广泛，涉及数据模型、数据库设计、数据存储、查询优化、数据挖掘、数据仓库、实时数据处理和数据隐私保护等众多研究方向，同时也包括这些领域的政策、系统实现、行业应用和学术研究的最新进展。作为数据库和数据管理研究的国际顶尖盛事，SIGMOD不仅是知名度高、参与国家和人数众多的学术会议，其发布的论文集也是该领域内极具权威的科研资料。该论文集对于追踪最新科研动态和学术交流至关重要，为数据库和数据管理领域的研究者提供了一个展示成果、交流思想、分享经验和建立合作的重要平台。
3、SIGIR——信息检索发展研究国际会议 会议时间/地点：2024年7月14-18日，美国，华盛顿
全文摘要提交时间：2024年1月18日
截稿时间：2024年1月25日
录用通知时间：2024年3月25日
会议官网：https://sigir-2024.github.io/
SIGIR（International Conference on Research on Development in Information Retrieval）会议每年7月份举行，致力于信息检索（IR）领域的研究，覆盖网络搜索、文本挖掘、数据挖掘、用户行为分析和用户界面设计等多样化主题。这个会议广泛关注信息检索领域的理论基础、系统开发和实践应用，涵盖了搜索引擎优化、信息过滤、推荐系统、自然语言处理、用户互动等关键研究议题，展示了技术革新、学术发现和行业实践的最新成果。作为信息检索领域内极富盛名、参与范围广泛的国际顶级会议，SIGIR成为了全球研究者、专家和行业从业者共聚一堂、分享最前沿研究成果和探讨行业趋势的重要平台。
4、VLDB——超大型数据库国际会议 会议时间/地点：2024年8月25-29日，中国，广州
论文提交开放时间：每个月20号
截稿时间：2024年3月1日
录用通知时间：最晚至2024年4月15日
会议官网：https://www.vldb.org/2024
VLDB（International Conference on Very Large Data Bases）会议通常在每年8月或9月举行，专注于数据库管理、数据处理技术及其相关领域的研究。它涉及数据库系统设计与实施、数据挖掘与分析、云计算、数据隐私与安全等众多研究话题，展示了这些领域中的技术创新、学术进展和行业实践的最新成就。作为国际数据库技术研究领域的顶尖学术事件，VLDB不仅汇集了全球数据库技术领域的先进研究成果，也为参会者提供了一个互换思想、分享经验、促进合作的高质量交流平台。
5、ICDE——国际数据工程会议 会议时间/地点：2024年5月13-17日，荷兰，乌特勒支
截稿时间：2023年12月3日
录用通知时间：2024年2月9日
会议官网：https://icde2024.github.io/
ICDE（IEEE International Conference on Data Engineering）会议每年春季举行，致力于数据库工程和数据管理系统的研究。它全面探讨了数据管理、数据库系统、数据挖掘、大数据、分布式系统、云计算以及数据隐私和安全等广泛主题，呈现了这一领域内的最新技术进展。作为全球数据库工程和数据管理领域最权威、参与广泛的学术会议之一，ICDE为来自世界各地的研究人员、学者和行业专家提供了一个优秀的交流平台。会议的论文集是掌握数据库工程和数据管理最前沿的宝贵资料，因此受到学术界和专业领域的高度评价，并被SCI和EI等主流学术索引广泛收录，是该领域内不可或缺的学术资源。
6、CIKM——信息与知识管理大会 会议时间/地点：2024年10月21-25日，美国，爱达荷州，博伊西
摘要全文提交时间：2024年5月13日
论文全文提交时间：2024年5月20日
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4b36c8f5c6526403ce72da980a6c7cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a244d0b3c0fcea0a78975990e506889d/" rel="bookmark">
			【C&#43;&#43;】stringstream类 最全超详细解析（什么是stringstream？ stringstrem有哪些作用? 如何在算法中应用？）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、stringstream 是什么 ？ 三、stringstream 的用法
✨构造函数
✨输出字符串
✨两种构造函数带来的不同
✨修改、清空 stringstream 内容
四、stringsteam 的用途
✨ 利用 stringstream 去除字符串空格
✨ 利用 stringstream 指定字符分割字符串
✨ 类型转换
五、常考面试题
✨计算字符串中的单词个数：
✨ 反转字符串中的单词 （重点）
六、共勉 一、前言 想必大家在做 LeetCode 算法题的时候会经常看到有使用 stringstream 类 处理字符串，由于自己对这个类不是很了解，查了资料在这里记录一下。
所以本文通过收集资料将其进行总结，主要介绍如何使用 stringstream 处理在算法练习或竞赛中遇到的输入输出问题。
二、stringstream 是什么 ？ stringstream 是 C++ 提供的专门用于处理字符串的 输入输出 流类。
这里稍微提一下c++中 “流” 的概念。在C++中，将数据从一个对象到另一个对象的流动抽象为“流”。流在使用前要被创建，使用后要被删除。数据的输入与输出是通过 I/O 流实现的，cin 和 cout 是c++预定义的流类对象。 stringstream 定义于头文件 &lt;sstream&gt;，它其实是个别名，具体定义如下： typedef basic_stringstream&lt;char&gt; stringstream; 类模板 std::basic_stringstream 实现基于字符串的流上的输入与输出操作。它等效地存储一个 std::basic_string 的实例，并在其上进行输入与输出操作。继承图如下： 三、stringstream 的用法 ✨构造函数 stringstream 的构造函数有很多，这里列举最为常用的两个构造函数： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a244d0b3c0fcea0a78975990e506889d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd04704ee7dce3e3b814ea87ead7ba5f/" rel="bookmark">
			【Java初阶（三）】方法的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		❣博主主页: 33的博客❣
▶文章专栏分类: Java从入门到精通◀
🚚我的代码仓库: 33的代码仓库🚚
目录 1.前言2.方法的概念2.1方法定义2.2 实参和形参的关系 3. 方法的重载3.1方法重载的概念 4.递归4.1递归的概念4.2递归过程分析4.3 递归练习 5.总结 1.前言 在前面的学习中，我们已经学习了Java的部分知识，包括数据类型与变量，运算符，分支与循环以及输入和输出这些基础知识，我们继续对Java的学习进行深入，一起来学习Java的方法。
本章重点
讲述方法的定义和使用，方法传参，方法重载，方法递归。
2.方法的概念 方法一个代码片段. 类似于 C 语言中的 “函数”。
2.1方法定义 修饰符 返回值类型 方法名称[参数类型 形参...]{ 方法体代码; [return 返回值] } 注意
1.修饰符：现阶段直接使用public static 固定搭配。
2. 返回值类型：如果方法有返回值，返回值类型必须要与返回的实体类型一致，如果没有返回值，必须写成void。
3. 参数列表：如果方法没有参数，()中什么都不写，如果有参数，需指定参数类型，多个参数之间使用逗号隔开。
4. 在java当中，方法必须写在类当中。
5.定义方法的时候, 不会执行方法的代码. 只有调用的时候才会执行。
例子：计算两个整数相加
public static int add(int a,int b){ return a+b; } 2.2 实参和形参的关系 形参只是方法在定义时需要借助的一个变量，用来保存方法在调用时传递过来的值。：在Java中，实参的值永远都是拷贝到形参中，形参和实参本质是两个实体。
举例：交换两个整型变量
public static void main(String[] args) { int a = 10;//实参 int b = 20; swap(a, b); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd04704ee7dce3e3b814ea87ead7ba5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3828acc2b5124f3afcbab85bc54e0ae3/" rel="bookmark">
			前端Vue篇之Vue3响应式：Ref和Reactive
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Vue3响应式：Ref和ReactiveRef和Reactive概述用途 Ref基本用法及在setup()中的使用基本用法在setup()中使用`&lt;script setup&gt;`语法为何使用ref Reactive基本概念及在模板中的使用基本概念在模板中使用Reactive深层响应式与Ref区别为何使用Reactive Ref和Reactive比较和选择性能和适用场景对象的处理局限性和注意事项比较和选择建议 Ref和Reactive示例和场景简单场景：使用Ref管理计数器复杂场景：使用Reactive管理用户信息和订单小结 总结RefReactive比较和选择小结 Vue3响应式：Ref和Reactive 在Vue3中，响应式编程是非常重要的概念，其中Ref和Reactive是两个关键的API。
Ref：Ref用于创建一个响应式的基本数据类型，比如数字、字符串等。它将普通的数据变成响应式数据，可以监听数据的变化。使用Ref时，我们可以通过.value来访问和修改数据的值。
Reactive：Reactive则用于创建一个响应式对象，可以包含多个属性。通过Reactive，我们可以将整个对象变成响应式，使对象的任何属性发生变化时都能被检测到。
使用这两个API，可以让我们在Vue3中更便捷地处理数据的响应式变化，从而更好地实现数据驱动的开发方式。
Ref和Reactive 概述 在Vue3中，Ref和Reactive是用于处理响应式数据的重要工具。它们帮助开发者管理数据的变化并自动更新相关的视图。
用途 Ref：
用于创建响应式的基本数据类型，如数字、字符串等。可以在setup()函数中使用，管理简单的数据状态。通过.value来访问和修改数据值。适用于管理简单的单一数据，如计数器、输入框的值等。 Reactive：
用于创建包含多个属性的响应式对象。可以处理复杂的对象数据结构，使对象的属性发生变化时能够被检测到。适用于管理复杂对象，如用户信息、表单数据等。会递归地将对象的所有嵌套属性都变成响应式，确保整个对象的变化能够被追踪。 在Vue3中，Ref和Reactive为开发者提供了灵活且高效的方式来处理各种数据类型的响应式需求，帮助构建可靠的响应式应用程序。
Ref基本用法及在setup()中的使用 基本用法 在Vue3中，Ref用于创建一个响应式的基本数据类型，如数字、字符串等。通过ref()函数创建一个Ref对象，然后可以通过.value来访问和修改数据值。
import { ref } from 'vue'; const count = ref(0); // 创建一个Ref对象，初始值为0 console.log(count.value); // 访问Ref对象的值 count.value = 1; // 修改Ref对象的值 在setup()中使用 在setup()函数中，我们可以使用ref()来创建响应式数据，以便在组件中使用。
import { ref } from 'vue'; export default { setup() { const count = ref(0); return { count }; } }; &lt;script setup&gt;语法 在Vue3中，&lt;script setup&gt;语法是一种简洁的写法，可以在单文件组件中更便捷地使用ref。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3828acc2b5124f3afcbab85bc54e0ae3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fed182d18aad686df0e93c18c6a9ccc3/" rel="bookmark">
			10分钟教你用Python爬取Baidu文库全格式内容，Flutter尽然还能有这种操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		driver = webdriver.Chrome(r’F:\driver\chromedriver.exe’)
driver.get(url)
怎么样，是不是浏览器自动打开了?现在我们尝试输出这个driver，就可以看见，网页的正确源代码已经在里面了。
现在我们仔细研究一下源代码就可以看到，我们需要的内容在下面这个位置。
现在正确的源代码也有了，内容的位置也知道了，直接解析，爬取，完事就好了。
想得美，经过这样的爬取之后，对内容进行解析，让我们看看究竟爬到没有。
from lxml import etree
import re
html=etree.HTML(driver.page_source)
links=html.xpath(“//div[@class=‘reader-pic-item’]/@style”)
part = re.compile(r’url([)]')
qa=“”.join(links)
z=part.findall(qa)
我们可以知道，其实我们只爬到3张PDF，其他的都没有爬到。这是为什么呢？
这是百度文库为了防止大家去爬，专门设置的一个小机关。
返回百度文库，我们仔细看看源代码，其实我们可以发现，随着页面的变化，源代码是不断改变的，每次都只有3张图片的url。并且这个页码数也有一定的规律，如果在第二页，那么图片就是1，2，3，如果在第三页，图片就是2，3，4。
那么我们的疑惑一下就解决了，只需要不断地进行换页的爬取，就可以了。接下来就是如何实现换页的操作了。
这个需要两个步骤，先是点击继续阅读，然后进行页面输入实现换页。先实现点击的操作，代码如下。
button = driver.find_element_by_xpath(“//*[@id=‘html-reader-go-more’]/div[2]/div[1]/span”)
button.click()
driver.execute_script(“arguments[0].click();”, button)
整个操作是通过JS来进行的，大家可以把这个记住，以后需要点击的时候直接用就可以。
然后就是输入页面实现换页，这个其实涉及的比较多，细分的话，步骤分为获取总页数，依次输入页面并点击。
import re
寻找页面 source = re.compile(r’/(.*?)')
number = int(source.findall(driver.page_source)[0])
输入页面并点击 driver.find_element_by_class_name(“page-input”).clear()
driver.find_element_by_class_name(“page-input”).send_keys(‘2’)
driver.find_element_by_class_name(“page-input”).send_keys(Keys.ENTER)
如果小伙伴成功实现了上面的操作，其实大体的爬取工作已经差不多了，接下来就是保存我们的PPT和PDF了。
因为爬取PDF和PPT的时候，我们是爬取的图片的源地址，那么我们要获得这张图片并保存下来就必须对这个地址发起请求，然后将返回头以二进制保存下来。
for m in range(3):
pic = requests.get(z[m]).content
方法一 file = open(f’./照片/{m+1}.jpg’,‘wb’) file.write(pic) file.close() 方法二 with open(f’./照片/{m+1}.jpg’,‘wb’) as f:
f.write(pic)
f.close()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fed182d18aad686df0e93c18c6a9ccc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4de5a5b8ba5a568f8fbf0535ab902e0/" rel="bookmark">
			【QT入门】 Qt槽函数五种常用写法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明：该专栏为本人学习Qt知识点时候的笔记汇总，希望能给初学的朋友们一点帮助(加油！)
往期回顾：
【QT入门】实现一个简单的图片查看软件-CSDN博客
【QT入门】图片查看软件(优化)-CSDN博客
【QT入门】 lambda表达式(函数)详解-CSDN博客
【QT入门】 Qt槽函数五种常用写法介绍 一、信号槽基本概念 Qt的信号槽是一种用于处理事件和通信的机制，是Qt框架中的一个重要特性。信号槽机制使得对象之间可以进行异步通信，无需显式调用对方的方法，从而实现了对象之间的解耦和灵活的交互。
1、信号（Signal）： 信号是一种特殊的成员函数，用于通知其他对象发生了某个事件或状态的改变。信号在类中声明为signals关键字，并不包含实际的实现代码。信号可以带有参数，用于传递额外的信息给槽函数。
2、槽（Slot）： 槽是用于响应信号的成员函数，可以执行相应的操作或处理逻辑。槽在类中声明为slots关键字，并实现具体的逻辑，槽函数的参数列表必须与信号的参数列表一致，或者可以接受更多参数。 通过connect函数将信号与槽连接起来，使得当信号被发射时，相关的槽函数会被调用。
连接可以是一对多的关系，即一个信号可以连接多个槽函数，也可以是多对一的关系，即多个信号可以连接到同一个槽函数。我们来看看其四个参数
connect（1.信号的发送者、2.发送的信号（函数的地址）、3.信号的接收者、4.接收后信号的处理(槽函数)的地址）
3、示例： connect(ui-&gt;pushButton,&amp;QPushButton::clicked,this,&amp;MainWindow::btnslot); 一一对应， ui里的pushButton控件时信号的发送者，发送了一个cliced点击信号，当前主窗口接收了这个信号，接收后调用当前窗口的btnslot方法，也就是所说的槽函数，进行了响应。
4、第五个参数 当然，实际上Qt的connect是五个参数，还有最后一个参数用于指定信号槽连接类型，但是我们一半不写，因为默认是自动连接类型。我们看看第五个参数类型：
AutoConnection自动连接，Qt会根据信号发送者和接收者的线程自动选择连接类型。DirectConnection直接连接，信号发送时，槽函数会立即在发送者所在的线程中执行。QueuedConnection队列连接，信号发送时，槽函数会被投递到接收者所在的线程的事件队列中，在接收者线程空闲时执行。BlockingQueuedConnection阻塞队列连接，与QueuedConnection类似，但发送者会等待槽函数执行完成后才继续执行。UniqueConnection唯一连接，确保相同的信号和槽不会被重复连接。 在Qt中使用这些连接类型来控制信号槽的行为，以确保在多线程环境下正确地处理信号和槽的执行顺序和线程关系。
二、五种槽函数写法 1、第一种: Qt4写法 connect(ui-&gt;pushButton,SIGNAL(clicked()),this,SLOT(btnslot()))
现在呢已经不推荐这种写法，因为如果SIGNAL写错了，或者信号名字、槽函数名字写错了，
编译器检查不出来，导致程序无响应，引起不必要的误解，也不便于找到问题。
2、第二种: Qt5写法 connect(ui-&gt;pushButton,&amp;QPushButton::clicked,this,&amp;MainWindow::btnslot);
推荐使用这种写法，信号名字、槽函数名字写错了，编译器会直接报错。
3、第三种：lambda表达式写法 connect(ui-&gt;pushButton,&amp;QPushButton::clicked,[=](参数){
//具体代码
QMessageBox::information(this,"title","Qt5_signal_slot");
}); 推荐使用，适用于slot代码比较少的逻辑
注：槽函数里写参数，可以比实际的参数数量少，比如实际有一个形参，我们就可以不写，可以写那一个，但是不可以写两个 。
4、第四种：牵线法 这种方法就是在ui控件上，点击控件绑定一个槽函数，然后再自己写槽函数逻辑，但是看着比较混乱，不太推荐。
5、第五种：自动生成法 在ui设计界面里直接点击控件，选择转到槽，再在里面选择槽函数。(通过这个方式，还可以很直观的看到某个控件有哪些槽函数)
而且这个方法用的挺多的，很方便，同时也可以选择自己手写，命名是on_控件名_信号名；分别在.h声明和.cpp实现就是，如果是自定义的槽函数一般都是do开头
比如我对ui界面的一个pushbutton控件绑定槽函数
void MainWindow::on_pushButton_clicked()
{
QMessageBox::information(this,"title","Qt5_signal");
close();
}
以上就是Qt槽函数五种常用写法介绍。
都看到这里了，点个赞再走呗朋友~
加油吧，预祝大家变得更强！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9ecbcc99866c0ef127d6a3061a52541/" rel="bookmark">
			Hive自定义GenericUDF函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hive自定义GenericUDF函数
当创建自定义函数时，推荐使用 GenericUDF 类而不是 UDF 类，因为 GenericUDF 提供了更灵活的功能和更好的性能。以下是使用 GenericUDF 类创建自定义函数的步骤：
编写Java函数逻辑：编写继承自 GenericUDF 类的自定义函数，实现 evaluate 方法来定义函数逻辑。打包函数为JAR文件：将编写的函数代码打包成一个JAR文件。在Hive中注册函数：使用 ADD JAR 命令加载JAR文件，并使用 CREATE FUNCTION 注册函数。在Hive查询中使用函数：在Hive查询中调用自定义函数。 以下是一个示例，展示如何使用 GenericUDF 类创建一个将字符串转换为大写的自定义函数： import org.apache.hadoop.hive.ql.exec.Description; import org.apache.hadoop.hive.ql.exec.UDFArgumentException; import org.apache.hadoop.hive.ql.exec.UDFArgumentLengthException; import org.apache.hadoop.hive.ql.metadata.HiveException; import org.apache.hadoop.hive.ql.udf.generic.GenericUDF; import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector; import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorConverters; import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorConverters.Converter; import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory; /** * 自定义函数：将字符串转换为大写 */ @Description(name = "to_upper", value = "Converts a string to uppercase") public class UpperGenericUDF extends GenericUDF { private transient Converter converter; /** * 初始化函数 * @param arguments 函数参数的ObjectInspector数组 * @return 函数返回值的ObjectInspector * @throws UDFArgumentException 如果参数数量不正确 */ @Override public ObjectInspector initialize(ObjectInspector[] arguments) throws UDFArgumentException { // 检查参数数量是否为1 if (arguments.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9ecbcc99866c0ef127d6a3061a52541/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5a4940c8f3d6284e458c55ca7aafb99/" rel="bookmark">
			实战whisper语音识别第一天，部署服务器，可远程访问，实时语音转文字（全部代码和详细部署步骤）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Whisper是OpenAI于2022年发布的一个开源深度学习模型，专门用于语音识别任务。它能够将音频转换成文字，支持多种语言的识别，包括但不限于英语、中文、西班牙语等。Whisper模型的特点是它在多种不同的音频条件下（如不同的背景噪声水平、说话者的口音、语速等）都能实现高准确率的语音识别，这得益于它在训练过程中使用的大量多样化的音频数据。
Whisper模型使用了一系列先进的深度学习技术和架构，主要包括：
自注意力机制（Self-Attention）：Whisper模型中使用了自注意力机制，特别是变种形式的Transformer架构，这在处理序列数据（如音频）中尤其有效。端到端学习：Whisper采用端到端的训练方式，直接从原始音频数据学习到文本输出，无需人工提取特征。大规模数据集训练：它是在广泛的数据集上进行训练的，包括各种语言、口音和音频质量，这有助于提高模型的泛化能力和鲁棒性。 Whisper的开发和发布对于语音识别和人工智能领域有着重要的意义：
提高语音识别的准确率：Whisper在多种测试集上显示出优越的性能，尤其是在噪声环境下和非英语语言的识别上。多语言支持：Whisper的多语言识别能力对于打破语言障碍、促进全球信息的交流和共享具有重要作用。开源共享：作为一个开源项目，Whisper为研究人员和开发者提供了一个强大的工具，可以在此基础上进一步开发定制化的语音识别应用，促进了技术的创新和应用的多样化。推动人工智能技术的发展：通过对Whisper模型的研究和应用，可以进一步推动相关领域，如自然语言处理、机器学习等领域的技术进步。 pip install -U openai-whisper pip install git+https://github.com/openai/whisper.git # on Ubuntu or Debian sudo apt update &amp;&amp; sudo apt install ffmpeg # on Arch Linux sudo pacman -S ffmpeg # on MacOS using Homebrew (https://brew.sh/) brew install ffmpeg # on Windows using Chocolatey (https://chocolatey.org/) choco install ffmpeg # on Windows using Scoop (https://scoop.sh/) scoop install ffmpeg pip install setuptools-rust 运行：
whisper 5.wav --language Chinese python代码： import whisper model = whisper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5a4940c8f3d6284e458c55ca7aafb99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/929249167de18fab10ed2d7b79120de3/" rel="bookmark">
			人工智能在心理健康评估和干预中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 心理健康评估的现状
2 人工智能在心理健康中的应用
3 人工智能的优势与面临的挑战
3.1 优势
3.1.1 精准度与实时性
3.1.2 规模和效率
3.2 挑战
4 总结与展望
4.1 总结
4.2 展望
5 参考文献
1 心理健康评估的现状 （1）心理健康概念与重要性。心理健康不仅仅是对抗精神疾病或心理问题，它涵盖了广泛的情感、认知和社会因素。个人的心理健康状态与其生活质量密切相关，影响着情感稳定性、自我认同、情感表达、人际关系以及适应社会的能力。心理健康评估的重要性不容忽视，因为它有助于提前发现潜在的心理健康问题，为及时干预和治疗创造机会。通过提高心理健康，个体可以更好地应对生活中的压力，提高生活质量，增进工作效率，并对社会建设产生积极的影响。
（2）传统心理健康评估方法。传统的心理健康评估方法通常包括面对面的临床面谈和使用标准化的心理测量工具，如问卷调查，临床面谈为患者提供了与专业心理医生或心理治疗师的互动机会，允许深入探讨和个性化评估。然而，这些方法存在主观性，可能受到双方的偏见影响。此外，传统方法通常需要耗费大量时间和资源，虽然问卷调查是一种常见的评估工具，但其局限性在于受试者的主观自我报告，可能不准确或不完整。
（3）现代心理健康批战。现代社会面临着多种心理健康挑战，其中包括日益增加的工作压力、社交媒体的消极影响以及心理健康问题的不断上升。快节奏的生活方式、经济不稳定、社交孤立和其他因素都对个体的心理健康产生了不利影响。焦虑症、抑郁症和其他情感问题的首遍性正在逐年增加，对个体和社会都造成了负担，这些挑战也凸显了提高心理健康评估的必要性，以更好地了解、预防和干预这些问题。
（4）人工智能的崛起。人工智能的崛起为心理健康领域带来了新的希想，这些技术可以大规模地外理多种类型的数据，从文字到图像，以要全面地了解小理健康状况，自然语言外理 (NLP) 技术能多分析大量的文本数据，从中识别情感、情感表达和情感变化。图像处理和计算机视觉技术可以用于分析图像和面部表情，以检测焦虑、抑郁或其他情感问题的迹象。智能推荐系统可以根据个体的需求和健康状况提供个性化的干预和建议。这些技术的应用可以改进心理健康评估的效率和精度，为更好地治疗和支持提供基础。
2 人工智能在心理健康中的应用 心理健康数据的获取与处理。在心理健康领域，数据的获取和处理至关重要，数据可以来自多个来源，包括临床记录、医疗问卷、社交媒体帖子、应用程序的使用数据和生理参数，这些数据可能包括文字、图像、音领和视频等多媒体信息。数据预处理是关键的一步，它包括数清洗、去曝声、数据规范化和特征工程，数据清洗有助于去除错误或不一致的数据点，确保数据的质量、特征工程涉及选择和构建与心理健康相关的特征，以供机器学习模型使用。例如，情感文本分析中的情感词汇、情感强度和情感极性是常见的特征。
机器学习模型的应用。机器学习模型在心理健康评估中发挥关键作用，这些模型可以应用于不同的任务，如情感分析、情感检测、情感分类和症状识别。自然语言处理（NLP）模型如 BERT、GPT-3 等可用于分析文本教据，识别情感表达，并帮助了解情感变化。计算机视觉模型可以分析图像和面部表情，以检测情感迹象，例如采用卷积神经网络（CNN）。机器学习模型还可以用于预判心理健康问题的风险，如焦虑、抑郁或自杀风险。这些模型基于历史数据和特定特征，可以帮助识别个体可能面临的心理健康挑战。
心理健康评估案例研究。了解具体的心理健康评估案例对于理解机器学习和人工智能的应用至关重要，研究人员和医疗专业人员已经开始使用这些技术来改进心理健康评估，例如，一些研究国队已经开发了应用程序，通过分析用户在社交媒体上的帖子来识别情感状态的变化，从而提供个性化的支持。这些案例研究有助于证明这些技术的实际应用和潜在优势。
机器学习在干预和治疗中的角色。机器学习不仅仅用于评估，还在心理健康干预和治疗中发挥重要作用，智能推荐系统可以基于个体的心理健康状况和需求，提供个性化的干预和建议。这可以包括认知行为疗法、心理款育、应对策略等，机器学习还可以帮助医疗专业人员更好地了解患者的需求，提供更个性化的治疗方案，这些方面的洋细论述有助于进一步了解机器学习和人工智能在心理健康领域的应用，以及它们如何有助于评估、干预和治疗心理健康问题，这些技术的实际案例研究将更具体地说明它们如何应用于实践。
3 人工智能的优势与面临的挑战 3.1 优势 3.1.1 精准度与实时性 人工智能在心理健康评估中的一个明显优势是提供更高的精确度和实时性。这些传术可以分析大规模的数据，检测微小的模式和趋势，以更准确地评估个体的心理健康状况。例如，在情感分析中，机器学习模型能够识别文本中微妙的情感表达，从而更准确地了解情感状态。实时性是另一个关键优势，因为机器学习模型可以实时监测个体的心理状态。这意味着在出现问题或紧急情况时，能够及时采取行动。例如，在社交媒体上监测用户的情感变化，可以及早识别可能的心理健康问题，并提供支持。
3.1.2 规模和效率 机器学习和人工智能技术能够处理大规模数据，这在心理健康评估中尤为重要。传统方法可能受限于小样本的问题，而机器学习可以处理数百万条文本、图像或声音片段，从中提取有用的信息。这样的规模使研究人员能够更全面地了解心理健康问题的复杂性。
3.2 挑战 数据隐私和伦理问题。机器学习和人工智能的应用引发了一系列数据隐私和伦理问题。处理心理健康数据时，保护个体的隐私至关重要。心理健康数据通常包含敏感信息，如情感状态、心理病史和治疗记录。因此，必须采取适当的数据安全措施，确保数据不会被滥用或泄露。此外，伦理问题也需要认真考虑。例如，应该如何处理患者的数据?是否有必要获得患者的明示同意?如何保证数据分析的公正性和透明性，这些问题需要在机器学习和人工智能应用中进行仔细考虑。
4 总结与展望 4.1 总结 在面对现代社会中不断增加的心理健康问题时，人工智能技术提供更精确、高效和实时的评估和干预手段。然而，保护数据隐私、解决伦理问题、提高模型可解释性以及跨学科合作都是前进的关键，这一领域的发展将继续促进技术的融合。
4.2 展望 （1）提升数据隐私和伦理标准。随着机器学习在心理健康领域的应用增多，保护数据隐私和遵循伦理标准至关重要。采用强化的数据隐私保护措施，如数据脱敏、加密和访问控制，以确保心理健康数据的机密性。确保数据使用遵守伦理规范，如明示同意、数据最小化和透明性。机构和研究者需要积极推动并遵守这些标准，以保护患者和用户的权益。
（2）发展可解释的机器学习模型。为了提高机器学习在心理健康评估中的可接受性和实用性，应重点发展可解释的模型。这些模型应该能够解释其决策过程和推断，以帮助患者和医疗专业人员理解模型的依据。可解释性模型可以通过可视化、模型解释工具和透明性的算法来实现。这些努力将有助于建立信任，并提高模型在心理健康领域的可用性。
（3）针对特定人群的个性化干预。了解每个患者或个体的独特需求和特征是提高心理健康干预的关键。机器学习可以帮助识别个性化的干预策略，以更好地满足患者的需求。例如，基于模型的个性化推荐系统可以根据患者的心理状态和健康历史提供特定的治疗建议。这种个性化方法有望提高治疗效果和患者满意度。
5 参考文献 基于人工智能和机器学习的健康评估与干预系统设计
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d186e316d6c8ce0d9f786fa7342ba00/" rel="bookmark">
			IDEA启动提示Downloading pre-built shared indexes
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示内容：
Download pre-built shared indexes
Reduce the indexing time and CPU load with pre-built JDK shared indexes
Always download
Download once
Dont't show again
Configure...
"Download pre-built shared index" 是IDEA中的一个功能选项。这个选项通常用于加快项目的构建和索引过程。
当打开一个新的项目或者重新导入一个项目时，IDEA会扫描项目文件并构建索引，以便提供代码补全、导航和其他功能。在某些情况下，为了加快这个过程，IDEA会提供一个选项来下载预先构建好的共享索引，而不是在本地计算机上重新构建索引。
选择下载预构建的共享索引可以节省时间，特别是对于大型项目或者首次导入项目时。这样可以避免 IDEA 在本地重新构建索引所需的时间。
如果看到这个选项，可以选择下载预构建的共享索引以加快项目的导入和构建过程，更快地开始在 IntelliJ IDEA 中开发项目。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2c548885a7701cd87db33c8db98b30c/" rel="bookmark">
			探索PyQt-Fluent-Widgets：优雅地构建Python GUI应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		探索PyQt-Fluent-Widgets：优雅地构建Python GUI应用 项目地址:https://gitcode.com/zhiyiYo/PyQt-Fluent-Widgets
项目简介 PyQt-Fluent-Widgets 是一个基于Python和Qt库的UI组件集合，它旨在提供更加现代化、直观且易于使用的图形界面元素。该项目的目标是简化PyQt开发过程，通过流畅的设计和API，让开发者能够快速、高效地创建美观的应用程序。
技术分析 1. 基于PyQt5/6: PyQt-Fluent-Widgets构建在广泛使用的PyQt框架之上，提供了与Qt原生组件的无缝兼容性。这使得开发者可以利用其强大的功能，如多平台支持、丰富的控件集和事件处理机制。
2. Fluent API 设计: 这个项目的亮点在于它的Fluent API设计。类似于JavaScript中的类链式调用，这种设计允许开发者在一个连续的语句中设置多个属性或方法，提高代码的可读性和简洁性。
Button().with_text('Hello').on_clicked(print).into(grid_layout) 3. 可定制性: PyQt-Fluent-Widgets不仅提供了预定义的样式，还允许自定义外观和行为。这意味着你可以轻松地调整颜色、尺寸，甚至添加新的交互逻辑。
4. 组件丰富: 包含各种常见的UI元素，如按钮、输入框、标签、布局等，满足日常开发需求。随着时间的推移，项目还会持续更新和扩展组件库。
应用场景 PyQt-Fluent-Widgets适用于需要创建GUI应用程序的各个领域，包括但不限于：
工具软件：如文本编辑器、图像处理工具等。数据可视化：用于展示数据图表、仪表板等。控制台替代品：为命令行工具提供友好的图形界面。教育软件：如学习管理系统或教学资源浏览器。实验室应用：如科学数据分析和控制实验设备。 特点总结 易用性：Fluent API使得编写GUI代码变得简单直观。灵活性：组件高度可定制，适应不同的设计需求。高性能：基于PyQt，保证了跨平台的稳定性和性能。社区驱动：持续的更新和优化，响应用户的反馈和建议。 如果你是Python开发者，正在寻找一种更优雅的方式来构建你的GUI应用，那么PyQt-Fluent-Widgets绝对值得尝试。无论是初学者还是经验丰富的开发人员，这个项目都能帮助你提升工作效率，让你的程序看起来更加专业和吸引人。立即加入并体验吧！
项目地址:https://gitcode.com/zhiyiYo/PyQt-Fluent-Widgets
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f537b47d0f973d962c855b25ddcad3f8/" rel="bookmark">
			【Java】使用 Java 语言实现一个冒泡排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是全栈小5，欢迎阅读小5的系列文章。
这是《Java》系列文章，每篇文章将以博主理解的角度展开讲解，
特别是针对知识点的概念进行叙说，大部分文章将会对这些概念进行实际例子验证，以此达到加深对知识点的理解和掌握。
温馨提示：博主能力有限，理解水平有限，若有不对之处望指正！
目录 前言冒泡排序介绍通俗理解代码实现动图演示冒泡降序排序每日小技巧快速搜索预览搜索结果 常见排序算法文章推荐 前言 上一篇文章已经学习了，如何使用IDE集成开发工具编写Java代码，并输出了一段Hello World的代码。
本篇文章将通过IDE使用 Java 语言实现一个冒泡排序。
冒泡排序介绍 冒泡排序也是一种简单直观的排序算法。
冒泡排序的基本思想是多次遍历要排序的数组，每次比较相邻的元素，如果顺序不对就交换它们的位置，一次遍历会将一个最大（或最小）的元素"冒泡"到数组的末尾（或开头）。
通过多次遍历，直到没有任何元素需要交换，整个数组就排序完成了。
通俗理解 当你需要对一组数字进行排序时，冒泡排序就像是在一个装有很多颜色不同的气泡的水槽里，不断地把气泡按照大小顺序排列。
在这个简单的排序算法中，我们会从数组的开头开始，比较相邻的两个数字，如果前一个数字比后一个数字大，就把它们交换位置。
这样，每一轮比较，都会让一个最大的数字“冒泡”到当前尚未排序的部分的末尾。
举个例子，假设我们有一组数字：3, 38, 5, 44, 15, 47, 36, 26, 27, 2, 46, 4, 19, 50, 48。
下面是冒泡排序的执行过程：
1.第一轮比较后，最大的数字 50 被冒泡到了数组末尾，数组变为：3, 5, 38, 15, 44, 36, 26, 27, 2, 46, 4, 19, 47, 48, 50
2.第二轮比较后，第二大的数字 48 被冒泡到了倒数第二的位置，数组变为：3, 5, 15, 38, 36, 26, 27, 2, 44, 4, 19, 46, 47, 48, 50
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f537b47d0f973d962c855b25ddcad3f8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/41/">«</a>
	<span class="pagination__item pagination__item--current">42/71</span>
	<a class="pagination__item pagination__item--next btn" href="/page/43/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>