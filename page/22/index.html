<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.126.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程学习者的博客">
		<meta property="og:url" content="https://bcxuexizhe.github.io/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="编程学习者">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/524bb11d2f1b49b8cdb558eec66e3505/" rel="bookmark">
			OpenAI将推出搜索产品；阿里通义千问2.5大模型发布，多项能力赶超GPT-4 | AI头条...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整理 | 王轶群
出品 | AI 科技大本营（ID：rgznai100）
一分钟速览新闻点！
谷歌DeepMind AlphaFold 3论文登上《自然》，生物分子结构预测准确率比现有方法高50%
DeepMind 首席执行官通过 AlphaFold 瞄准 1000 亿美元以上的人工智能药物发现业务
OpenAI 正在准备一款搜索产品来与谷歌、Perplexity竞争
OpenAI 推出模型规范指定了模型的行为方式，包括目标、规则和默认行为
Stack Overflow用户集体抗议和OpenAI合作
阿里通义千问2.5大模型发布，多项能力上赶超GPT-4
Yellow.ai 业界首创生成式 AI 代理模型
微软计划投资33亿美元在美国威斯康星州建立数据中心，并投资威斯康星大学人工智能实验室 微软正在通过新的 Copilot AI 功能“将每个人变成快速工程师”
前 DeepMind 和 Meta AI 研究员创办的 DatologyAI A轮融资筹集近5000万美元
英特尔正在与 14 家日本公司合作，以实现“后端”芯片制造流程自动化
消息称苹果硬件工程主管约翰·特努斯是蒂姆·库克最有可能的长期继任者
全球 AI 要闻
谷歌DeepMind AlphaFold 3论文登上《自然》，生物分子结构预测准确率比现有方法高50%
北京时间5月8日晚间，科学顶刊《自然》杂志刊登了谷歌DeepMind AlphaFold团队和伦敦药物研发公司Isomorphic Labs共同署名的论文，介绍了AlphaFold 3，这是AlphaFold的第三代版本，全新的蛋白质结构预测系统能以前所未有的精度预测“蛋白质数据库（Protein Data Bank）”内几乎所有分子类型的复合物结构。
论文称，AlphaFold 3是一款革命性的系统。对于蛋白质与其他分子类型的相互作用，AlphaFold 3在基准测试中的准确率比现有最好的传统方法高出50%，且无需输入任何结构信息，这使得AlphaFold 3成为首个在生物分子结构预测方面超越基于物理工具的方法的人工智能系统。（每日经济新闻） DeepMind 首席执行官通过 AlphaFold 瞄准 1000 亿美元以上的人工智能药物发现业务
谷歌 DeepMind 首席执行官 Demis Hassabis 表示，生物学研究领域的人工智能突破可能是一项价值数千亿美元的业务，将通过 DeepMind 衍生公司 Isomorphic Labs 实现商业化。Demis Hassabis 告诉彭博社，首批人工智能设计的药物可能会在“未来几年”内准备好进行测试。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/524bb11d2f1b49b8cdb558eec66e3505/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7598168e1bc4ddba96e83c6cd2d0d922/" rel="bookmark">
			【SpringBoot篇】基于Redis分布式锁的 误删问题 和 原子性问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🍔Redis的分布式锁🛸误删问题🎈解决方法🔎代码实现 🛸原子性问题🌹Lua脚本 ⭐利用Java代码调用Lua脚本改造分布式锁🔎代码实现 🍔Redis的分布式锁 Redis的分布式锁是通过利用Redis的原子操作和特性来实现的。在分布式环境中，多个应用程序或服务可能同时访问共享资源，为了保证数据的一致性和避免冲突，可以使用分布式锁来进行同步控制。
以下是一种常见的使用Redis实现分布式锁的方式：
获取锁：当一个应用程序需要获取锁时，它可以通过执行以下操作在Redis中设置一个特定的键值对： SET lock_key unique_value NX PX lock_timeout 这里的lock_key是锁的唯一标识，unique_value是唯一的值，可以是随机生成的UUID，NX表示只有当键不存在时才会设置成功，PX表示设置键的过期时间。通过设置过期时间，即使获取锁的应用程序崩溃或异常退出，锁也会在一段时间后自动释放，避免出现死锁。
释放锁：当应用程序完成对共享资源的操作后，它可以通过执行以下操作释放锁： if GET lock_key == unique_value then DELETE lock_key end 应用程序首先获取锁的当前值，然后比较是否与自己持有的唯一值相等，如果相等则删除该键，表示释放锁。这样可以确保只有持有锁的应用程序才能释放锁，避免误释放其他应用程序的锁。
需要注意的是，分布式锁并不是绝对安全和可靠的。在高并发的环境中，可能存在竞争条件和死锁等问题。因此，在实际使用中，需要考虑更复杂的场景和解决方案。
🛸误删问题 遇到下面的情况的话，会出现Redis分布式锁的误删问题
这种情况下。线程1首先获取锁，但是发生了阻塞，于是线程2拿到了执行权，在线程2执行的过程中，线程1苏醒了，继续执行，到后面，线程1执行到了删除锁的操作，此时就会把本应该属于线程2的锁删除，这样子就造成了误删问题
🎈解决方法 就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。
🔎代码实现 public class SimpleRedisLock implements ILock { private String name; private StringRedisTemplate stringRedisTemplate; public SimpleRedisLock(String name, StringRedisTemplate stringRedisTemplate) { this.name = name; this.stringRedisTemplate = stringRedisTemplate; } private static final String KEY_PREFIX = "lock:"; //使用uuid，在获取锁的时候存入线程标识 private static final String ID_PREFIX = UUID.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7598168e1bc4ddba96e83c6cd2d0d922/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51f8e5288cf3f4ed812e17562b993479/" rel="bookmark">
			Java数组（如果想知道Java中有关数组的知识点，那么只看这一篇就足够了！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同,Java 语言中提供的数组是用来存储固定大小的同类型元素。
✨✨✨这里是秋刀鱼不做梦的BLOG
✨✨✨想要了解更多内容可以访问我的主页秋刀鱼不做梦-CSDN博客
先让我们看一下本篇文章的大致内容：
目录
1.数组的定义与创建
（1）数组的定义
（2）数组的创建及初始化
补充：
（1）数组的创建及初始化的分离
（2）数组不进行初始化时会有默认值
2.数组的遍历
（1）使用for循环
（2）使用增强for循环
（3）使用Array.toString方法
3.数组中常用的API
（1）binarySearch
（2）copyOf
（3）copyOfRange
（4）equals
（5）fill
（6）sort
（7）toString
4.二维数组
（1）二维数组的定义
（2）二维数组的遍历
【1】使用for循环
【2】使用增强for循环
【3】使用Array.deepToString方法
1.数组的定义与创建 从前言中我们可以知道数组可以看成是相同类型元素的一个集合，在内存中是一段连续的空间。那么数组是如何定义的呢？
（1）数组的定义 数组的定义如下：
T[] 数组名 = new T[N] ;
其中：
T：表示数组中存放元素的类型。
T[ ]：表示数组的类型。
N：表示数组的长度。
看了上边数组的定义之后还是不太懂到底数组是如何定义的，那么可以看一下下面的案例进一步理解。
int[] array1 = new int[10]; // 一个可以容纳10个int类型元素的数组 double[] array2 = new double[5]; // 一个可以容纳5个double类型元素的数组 String[] array3 = new double[3]; // 一个可以容纳3个字符串元素的数组 这样我们就大致了解了数组的定义形式了，那么数组又该如何去进行创建呢？
（2）数组的创建及初始化 对于数组的创建及初始化大致可以分为两种：动态初始化 和 静态初始化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51f8e5288cf3f4ed812e17562b993479/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae1dd3dd04a499bb557aec71d75cbf26/" rel="bookmark">
			【数据结构】栈的实现以及数组和链表的优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页：一代…
个人专栏：数据结构
1.栈 1.1栈的概念及结构 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端
称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。
压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。
出栈：栈的删除操作叫做出栈。出数据也在栈顶。
栈的实现 栈的实现可以用两种线性结构来实现，一种是数组，另一种是链表。
那么用哪种来实现栈比较合适呢？
那我们就要来考虑数组和链表的各自的好处了。
**学过顺序表的小伙伴都知道顺序表的底层是用数组来实现的。那么顺序表和链表有什么区别呢？
存储空间：
顺序表的物理和逻辑上是连续的
链表的物理上不一定连续，但逻辑上连续随机访问
顺序表随机访问某一个元素时时间复杂度为O(1)
链表访问某一个元素时时间复杂度尾O(N)在任意位置插入和删除元素
顺序表插入和删除元素的时间复杂度为O(N)
链表的时间复杂度为O(N)空间利用
动态顺序表空间不够是需要扩容，可能造成空间浪费
链表没容量的概念，新增一个节点就malloc一个大小为STDataType的空间缓存利用率
顺序表的缓存利用率高
链表的缓存利用率低 缓存利用率
这里主存就相当于内存，本地磁盘就相当于硬盘，这两个的一个区别就是带点和不带电的区别，内存和硬盘在带电状态下都能正常工作，但它们的工作方式和工作内容完全不同。
内存是易失性的，即当电源关闭时，内存中的数据会丢失。而硬盘是非易失性的，即使电源关闭，数据也会保留。
在不带电状态下，硬盘可以更安全地进行物理操作，而内存则无法进行任何操作（因为内存模块本身不包含任何电源或机械部件）。
这里我浅浅讲一下顺序表和链表缓存利用率的区别 数组（顺序表）和链表在缓存利用率上的区别主要体现在它们的物理存储结构和访问方式上。
在访问一块数据内存空间时，要先把内存加载到缓存，在对其进行访问，而其并不是没此访问一个内存就将其加载到缓存，而是访问一块内存时将其后面的连续的内存一起加载到缓存，然后在对其进行访问。
数组是一块连续的内存空间，元素紧密排列，空间效率更高。这种物理空间的连续性使得数组在访问数据时具有更高的缓存利用率。当CPU执行指令运算需要访问数据时，会先去缓存中查找这个数据。如果数据已经在缓存中（缓存命中），那么CPU就可以直接从缓存中读取数据，而不需要从主存中读取，从而提高了程序的运行效率。由于数组的物理地址是连续的，因此数组中的数据在缓存中的命中率更高，减少了从主存中读取数据的次数，从而提高了缓存利用率。
相比之下，链表是由节点组成，节点之间通过引用（指针）连接。链表在添加和删除元素时只需要改变指针的指向，以节点为单位进行动态内存分配和回收，灵活并且插入和删除效率高。但是，链表的节点在物理存储上是不连续的，因此链表中的数据在缓存中的命中率相对较低。当CPU需要访问链表中的数据时，可能需要频繁地从主存中读取数据到缓存中，降低了缓存利用率，并且会造成缓存污染。
综上所述，数组（顺序表）由于物理空间的连续性，在缓存利用率上通常优于链表。这也是为什么在需要频繁访问数据的场景下，如数组的遍历、查找等操作，使用数组通常会比链表更高效。
所以链表和数组实现栈的区别并不大，但数组比链表更优一些。
（注：链表实现栈可以用单链表，用首元结点作栈顶，也可以用双链表来实现）
下面我们就开是讲解栈的实现
栈的初始化
void StackInit(Stack* ps) { assert(ps); ps-&gt;_capacity = 0; //top指向栈顶数据的下一个位置 ps-&gt;_top = 0; //top指向栈顶数据 //ps-&gt;_top = -1; ps-&gt;_a = NULL; } 这里初始化top既可以为0，也可以为-1，为0为top指向栈顶数据的下一个位置，为-1时指向栈顶数据。
栈的销毁
void StackDestroy(Stack* ps) { assert(ps); free(ps-&gt;_a); ps-&gt;_a = NULL; ps-&gt;_top = ps-&gt;_capacity = 0; } 入栈
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae1dd3dd04a499bb557aec71d75cbf26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6ffed89bcf11dfed5f1ec54a7299cff/" rel="bookmark">
			【MySQL数据库】丨一文详解 JdbcTemplate(Spring中的CRUD)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 JdbcTemplate 是 Spring框架 中提供的一个对象，用于简化JDBC操作。它使得数据库操作变得更为简单和方便，大大提高了开发效率。
文章目录 前言为何要使用JdbcTemplate在JdbcTemplate中执行SQL语句的方法大致分为3类：案例代码 JdbcTemplate实现增删改案例代码 JdbcTemplate查询-queryForInt返回一个int整数案例代码 JdbcTemplate查询-queryForObject返回String案例代码 JdbcTemplate查询-queryForMap返回一个Map集合处理结果 JdbcTemplate查询-queryForList返回一个List集合处理结果 JdbcTemplate查询-RowMapper返回自定义对象案例代码 JdbcTemplate查询-BeanPropertyRowMapper返回自定义对象 为何要使用JdbcTemplate JDBC已经能够满足大部分用户最基本的需求，但是在使用JDBC时，必须自己来管理数据库资源如：获取PreparedStatement，设置SQL语句参数，关闭连接等步骤。
当初看到jdbctempate时感觉很诧异，但是用到时候感觉这样使用真的方便，类似于mybatis的封装，但是却比他简单，明了。
org.springframework.jdbc.core.JdbcTemplate类是JDBC核心包中的中心类。它简化了JDBC的使用，并有助于避免常见的错误。 它执行核心JDBC工作流，留下应用程序代码来提供SQL并提取结果。 该类执行SQL查询或更新，在ResultSet类上启动迭代并捕获JDBC异常，并将它们转换为org.springframework.dao包中定义的通用更详细的异常层次结构。使用这个类的代码只需要实现回调接口，给它们一个明确定义的协定。 Preparedstatementcreator 回调接口在给定 Connection 的情况下创建一个准备好的语句，提供 SQL 和任何必要的参数。 Resultsetextractor 接口从 ResultSet 中提取值。 请参阅 PreparedStatementSetter 和 RowMapper 了解两个流行的可选回调接口。
JdbcTemplate是Spring对JDBC的封装，目的是使JDBC更加易于使用。JdbcTemplate是Spring的一部分。JdbcTemplate处理了资源的建立和释放。他帮助我们避免一些常见的错误，比如忘了总要关闭连接。他运行核心的JDBC工作流，如Statement的建立和执行，而我们只需要提供SQL语句和提取结果
在JdbcTemplate中执行SQL语句的方法大致分为3类： execute：可以执行所有SQL语句，一般用于执行DDL语句。update：用于执行INSERT、UPDATE、DELETE等DML语句。queryXxx：用于DQL数据查询语句。 JdbcTemplate配置连接池
org.springframework.jdbc.core.JdbcTemplate类方便执行SQL语句
public JdbcTemplate(DataSource dataSource) 创建JdbcTemplate对象，方便执行SQL语句 public void execute(final String sql) execute可以执行所有SQL语句，因为没有返回值，一般用于执行DDL语句。 JdbcTemplate使用步骤
准备DruidDataSource连接池
导入依赖的jar包
spring-beans-4.1.2.RELEASE.jar
spring-core-4.1.2.RELEASE.jar
spring-jdbc-4.1.2.RELEASE.jar
spring-tx-4.1.2.RELEASE.jar
com.springsource.org.apache.commons.logging-1.1.1.jar
public void execute(final String sql)
execute可以执行所有SQL语句，因为没有返回值，一般用于执行DDL语句。
创建JdbcTemplate对象，传入Druid连接池
调用execute、update、queryXxx等方法
案例代码 public class Demo04 { public static void main(String[] args) { // 创建表的SQL语句 String sql = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6ffed89bcf11dfed5f1ec54a7299cff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b68fabb53e8d1b6d112aacf7e5a2d3d5/" rel="bookmark">
			C#进阶-OleDb操作Excel和数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C#编程中，使用OleDb可以方便地实现对Excel文件和数据库的操作。本文探讨了在C#中使用OleDb技术操作Excel和数据库的策略。文章详述了OleDb的定义、配置环境的步骤，并通过实际代码示例演示了如何高效读写Excel文件和交互数据库。文中还评估了OleDb技术的优缺点，为需要处理多种数据源的开发者提供了一种有效的数据操作方案。
一、OleDb简介 OleDb（Object Linking and Embedding, Database）是微软的一套数据库访问接口，支持对多种数据源的访问，包括SQL Server、Access以及Excel等。它提供了一种统一的方法来访问不同的数据源。在.NET环境下，OleDb可以通过System.Data.OleDb命名空间提供的类来使用。
二、OleDb安装前准备 1. 环境准备 .NET Framework: 确保您的开发环境中安装了.NET Framework，因为OleDb类库是基于.NET Framework的。
引用设置: 在Visual Studio中，需要添加对System.Data.dll的引用，以确保项目可以使用System.Data.OleDb命名空间。
2. 安装相应的驱动 使用 OLE DB 操作数据库或 Excel 时，你需要确保安装了适当的 OLE DB 驱动程序，这取决于你要连接的具体数据库系统。每种数据库系统都可能有一个或多个专用的 OLE DB 驱动，这些驱动允许应用程序通过 OLE DB 接口与数据库通信。
Excel 的 OLE DB 驱动：
对于Excel文件的数据操作，你可以使用Microsoft提供的OLE DB驱动来进行读取和写入操作。这些驱动允许通过OLE DB接口与Excel文件进行交互。具体使用的驱动取决于Excel文件的版本和你的系统类型（32位或64位）。
① 🎯Microsoft Access Database Engine OLE DB Provider
适用版本：Excel 2007 及更高版本的文件（.xlsx）。驱动名称： 对于旧版本或需要兼容性的，可以使用 Microsoft.ACE.OLEDB.12.0。对于更高版本的Office，可以使用 Microsoft.ACE.OLEDB.16.0。 ② 🔥Microsoft Jet OLE DB Provider
适用版本：Excel 2003 及更早版本的文件（.xls）。驱动名称：Microsoft.Jet.OLEDB.4.0。注意：这个驱动仅支持32位系统。 驱动下载地址
Access Database Engine最新版本下载地址：(https://learn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b68fabb53e8d1b6d112aacf7e5a2d3d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/098f5d8d0e435fdd97db7f79160bbfca/" rel="bookmark">
			Go 使用 MongoDB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MongoDB 安装(Docker)安装 MongoDB Go 驱动使用 Go Driver 连接到 MongoDB在 Go 里面使用 BSON 对象CRUD 操作 插入文档更新文档查询文档删除文档 下一步 MongoDB 安装(Docker) 先装个 mongo，为了省事就用 docker 了。
docker 的 daemon.json 加一个国内的源地址：
"registry-mirrors": [ "http://hub-mirror.c.163.com" ] 然后拉取 mongo 镜像:
docker pull mongodb 启动 mongo:
docker run -p 27017:27017 mongo 安装 MongoDB Go 驱动 go get go.mongodb.org/mongo-driver 基础代码 创建 main.go 文件，并且导入 bson，mongo 和 mongo/options 包。
package main import( "context" "fmt" "log" "go.mongodb.org/mongo-driver/bson" "go.mongodb.org/mongo-driver/mongo" "go.mongodb.org/mongo-driver/mongo/options" ) // 在后面的代码中将会使用这个 Trainer 结构体 type Trainer struct { Name string Age int City string } func main() { // } 使用 Go Driver 连接到 MongoDB 一旦 MongoDB 的 Go 驱动被导入之后，我们就可以使用 mongo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/098f5d8d0e435fdd97db7f79160bbfca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76f834dd5267a70b729ec4cc42db21c0/" rel="bookmark">
			JavaScript中的深拷贝与浅拷贝详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥 个人主页：空白诗 文章目录 📚 引言❓什么是拷贝🌟 浅拷贝：表面功夫浅拷贝常用方法1. 扩展运算符 (`...`)2. `Object.assign()`3. 手动遍历对象属性 🌠 深拷贝：彻底分离深拷贝常用方法1. Lodash 的 `_.cloneDeep`2. JSON 的序列化与反序列化方法3. 小贴士 📊 深拷贝与浅拷贝的抉择💯 面试考点🎯 总结 📚 引言 在JavaScript编程的奇妙之旅中，理解数据拷贝的机制是每位开发者绕不开的必修课。本文将带你深入浅出地探索深拷贝（Deep Copy）与浅拷贝（Shallow Copy）的概念、区别及其实现方法，让你的数据操作更加得心应手。🥳
❓什么是拷贝 「拷贝」，顾名思义，就是在计算机编程中创建一个已有对象或数据结构的副本的过程。根据拷贝的深度不同，可以分为 浅拷贝（Shallow Copy） 和 深拷贝（Deep Copy） 两种类型，它们在实际应用中扮演着不同的角色
🌟 浅拷贝：表面功夫 「浅拷贝」仅涉及对象的第一层属性拷贝过程。当遇到嵌套的引用类型（比如对象、数组），浅拷贝并不会深入这些内部结构去创建新实例，而是直接复制这些内部对象的引用地址。这就意味着，尽管原对象与拷贝对象在表面上看似分离，实则在深层次结构上依旧紧密相连，彼此共享相同的数据。稍有不慎的修改，就可能在二者之间产生意料之外的联动效果。
实际作用：
性能考虑：由于只复制一层，浅拷贝相对较快，占用内存较少，适合于大型对象或深度嵌套结构中不需要完全独立的情况。快速创建类似对象：当需要一个对象作为模板快速生成相似对象，但部分属性可能根据需要修改时，浅拷贝可以保留可共享的部分，仅修改差异部分。资源节约：在某些场景下，如果确实不需要或不允许完全独立的副本，浅拷贝可以避免不必要的内存消耗。 下面通过一段代码来直观展现浅拷贝的特点：
const obj1 = { name : "Alice", age : 18 } const obj2 = obj1 // obj2现在指向与obj1相同的内存地址 console.log("obj1",obj1) // 输出 obj1 { name: 'Alice', age: 18 } console.log("---修改obj2的值后----") obj2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76f834dd5267a70b729ec4cc42db21c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcd4735d9d04a0214c35abc23a8663ea/" rel="bookmark">
			【荣耀笔试题汇总】2024-05-09-荣耀春招笔试题-三语言题解(CPP/Python/Java)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍭 大家好这里是清隆学长 ，一枚热爱算法的程序员
✨ 本系列打算持续跟新荣耀近期的春秋招笔试题汇总～
💻 ACM银牌🥈| 多次AK大厂笔试 ｜ 编程一对一辅导
👏 感谢大家的订阅➕ 和 喜欢💗
📧 清隆这边最近正在收集近一年互联网各厂的笔试题汇总，如果有需要的小伙伴可以关注后私信一下 清隆领取，会在飞书进行同步的跟新。
文章目录 🚗 01.K小姐的数字游戏题目描述输入格式输出格式样例输入样例输出数据范围题解参考代码 🚕 02.K小姐的在线学习系统题目描述输入格式输出格式样例输入样例输出数据范围题解参考代码 🚙 03.元素圈的奇妙组合题目描述输入格式输出格式样例输入样例输出数据范围题解参考代码 写在最后📧 清隆这边最近正在收集近一年互联网各厂的笔试题汇总，如果有需要的小伙伴可以关注后私信一下 清隆领取，会在飞书进行同步的跟新。 🚗 01.K小姐的数字游戏 题目描述 K小姐非常喜欢玩数字游戏。这一次，她想要判断给定的数字序列是否满足特定的规则。
存在多个数字序列，每个数字序列由 N N N 个正整数组成，数字之间以空格隔开，并且这些数字都大于 0 0 0 小于 100 100 100。
规则如下：
如果相邻的数字是两位数和一位数交替出现，则该序列是合法的。如果序列中第一个和最后一个数是两位数，且中间数字都是一位数，则序列是合法的。如果序列中第一个和最后一个是一位数，且中间数字都是两位数，则序列是合法的。 输入格式 输入多个数字序列，每个数字序列独占一行。每个数字序列由 N N N 个正整数组成，所有整数都大于 0 0 0 小于 100 100 100，每个整数之间由空格分隔， 2 ≤ N ≤ 100 2 \leq N \leq 100 2≤N≤100。输入保证合法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcd4735d9d04a0214c35abc23a8663ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a61d73e33732a1e9f5618584f0c01610/" rel="bookmark">
			Elasticsearch 索引、类型、文档、分片与副本等核心概念介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🐇明明跟你说过：个人主页
🏅个人专栏：《洞察之眼：ELK监控与可视化》🏅
🔖行路有良友，便是天堂🔖
目录
一、引言
1、Elasticsearch简介
2、分布式搜索引擎的工作原理
二、Elasticsearch核心组件
1、索引（Index）
2、类型（Type，注：自Elasticsearch 7.x开始已弃用）
3、文档（Document）
4、节点（Node）
5、集群（Cluster）
6、分片（Shard）与副本（Replica）
7、Elasticsearch与MySQL的对应关系
一、引言 1、Elasticsearch简介 Elasticsearch 是一个开源的分布式搜索和分析引擎，最初由 Elasticsearch N.V. 公司开发，并于 2010 年首次发布。它建立在 Apache Lucene 基础之上，提供了分布式的实时搜索和分析功能，被广泛应用于各种场景，包括日志分析、全文搜索、监控和可视化等。
以下是 Elasticsearch 的一些重要特点和功能：
1. 分布式架构：
Elasticsearch 是一个分布式系统，数据可以水平扩展到多个节点上存储和处理。数据被分割成多个分片（Shard），每个分片可以被复制到多个副本（Replica），以提高数据的可用性和容错性。 2. 实时搜索：
Elasticsearch 提供了快速的实时搜索功能，可以在大规模数据集上快速地进行搜索、过滤和排序。支持复杂的搜索查询语法和全文搜索功能，可以满足各种搜索需求。 3. 多种数据类型：
Elasticsearch 支持多种数据类型的存储和索引，包括文本、数字、日期、地理位置等。支持结构化数据和非结构化数据的索引和查询。 4. 强大的聚合和分析：
Elasticsearch 提供了丰富的聚合（Aggregation）功能，可以对数据进行统计、分组、计算等操作。支持各种聚合函数和桶（Bucket）操作，可以生成复杂的数据分析报表和可视化。 5. RESTful API：
Elasticsearch 提供了基于 RESTful API 的接口，支持各种 HTTP 请求和 CRUD 操作。开发者可以使用各种编程语言和工具与 Elasticsearch 进行交互，实现数据的索引、搜索和分析。 6. 可扩展性和灵活性：
Elasticsearch 提供了丰富的插件和扩展机制，可以根据需求定制和扩展功能。支持与其他开源工具和系统集成，如 Logstash、Kibana、Beats 等，构建完整的日志分析和监控解决方案。 2、分布式搜索引擎的工作原理 数据采集：分布式搜索引擎从多个来源采集数据，这些数据可以是网页、文档、日志、数据库等。数据采集可以通过网络爬虫、日志收集器等方式进行。数据处理和索引构建：采集到的数据需要进行处理和索引构建，以便后续的快速搜索。在这个阶段，文本数据会被分词、分析，并构建索引结构。索引结构通常包括倒排索引等，用于加快搜索速度和提高搜索精度。索引分片和分布式存储：索引构建完成后，索引数据会被分片存储在多个节点上，以确保数据的高可用性和可扩展性。分布式存储系统通常使用分布式文件系统（如HDFS）、分布式数据库（如Elasticsearch、Apache Solr）、NoSQL数据库（如MongoDB、Cassandra）等。搜索请求处理：当用户提交搜索请求时，搜索引擎会接收到请求并进行处理。搜索请求处理包括解析用户查询、检索相关文档、计算文档相关度等步骤。通常情况下，搜索请求会被路由到多个索引分片上并行处理，以提高搜索速度。结果聚合和排序：搜索引擎会将检索到的文档按照相关度排序，并返回给用户。搜索结果可能还包括分页、高亮显示、聚合等功能，以提高用户体验。搜索结果缓存：为了提高搜索性能，搜索引擎通常会使用缓存来存储热门搜索结果。这样，对于相同的查询请求，可以直接从缓存中获取结果，而不需要重新计算。系统监控和优化：搜索引擎会持续监控系统性能、用户行为等指标，并根据监控结果进行系统优化和调整，以提高搜索效率和用户满意度。 二、Elasticsearch核心组件 1、索引（Index） Elasticsearch 的核心组件之一是索引（Index）。索引是 Elasticsearch 中存储和组织数据的基本单位，类似于关系型数据库（MySQL）中的表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a61d73e33732a1e9f5618584f0c01610/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18b5cd43b1e6d1603ae72c22388656ab/" rel="bookmark">
			【Golang入门教程】Go语言整型(整数类型)的详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序员的实用神器 文章目录 程序员的实用神器强烈推荐引言常见的整型类型相对于的应用场景整型类型的示例强烈推荐专栏集锦写在最后 强烈推荐 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站:人工智能
推荐一个个人工作，日常中比较常用的人工智能工具，无需魔法，忍不住分享一下给大家。点击跳转到网站:人工智能工具
引言 在编程中，处理整数是一项基本的任务，而Go语言提供了各种整型类型，以满足不同场景下的需求。
从表示小范围的计数器到处理大型的时间戳和哈希值，选择适当的整型类型对于确保程序的正确性和性能至关重要。
本文将介绍Go语言中常见的整型类型及其应用场景，帮助大家更好地理解和利用这些类型。
常见的整型类型 int:
根据具体的平台，它可能是32位或64位。在32位系统上，它是32位的，而在64位系统上，它是64位的。这使得它的大小根据不同的平台而变化。
int8:
有符号8位整数，范围是-128到127。
int16:
有符号16位整数，范围是-32768到32767。
int32:
有符号32位整数，范围是-2147483648到2147483647。
int64:
有符号64位整数，范围是-9223372036854775808到9223372036854775807。
uint:
无符号整数，大小与int相同，但不能表示负数。
uint8 (或者 byte):
无符号8位整数，范围是0到255。
uint16:
无符号16位整数，范围是0到65535。
uint32:
无符号32位整数，范围是0到4294967295。
uint64:
无符号64位整数，范围是0到18446744073709551615。
相对于的应用场景 以下是各种整型类型的常见应用场景：
int: 通常用于表示一般整数值，例如计数器、索引、循环计数等。由于其大小会根据底层平台变化，因此适用于需要动态选择大小的情况。int8: 当需要节省内存空间，并且知道值不会超出-128到127的范围时，可以使用int8。例如，表示ASCII字符的值或处理小型计数器时。int16: 当整数值位于-32768到32767的范围内，并且需要比int8更大的范围时，可以使用int16。例如，处理一些中等规模的计数器或需要较小内存占用的整数。int32: 通常是默认的整型类型，用于表示普通整数值。如果确定值不会超出int32的范围，或者需要与C语言的int类型进行交互，则可以使用int32。int64: 当整数值可能超出int32的范围时，或者需要处理大型整数值时，可以使用int64。例如，处理时间戳、文件大小等大型数值时常会使用int64。uint: 通常用于表示不需要负数的情况，例如处理位操作、表示索引、哈希值等。uint8 (或者 byte): 常用于表示字节数据，例如图像处理、网络通信等，因为它们的范围在0到255之间。uint16: 适用于需要大于255但小于65535的无符号整数值的情况，例如端口号等。uint32: 用于表示无符号整数值，范围在0到4294967295之间，例如IP地址等。uint64: 当需要处理大型无符号整数值时，例如大型哈希值、内存地址等，可以使用uint64。 在选择整型类型时，应根据数值范围、内存占用和符号性等方面的需求来做出合适的选择，以确保程序能够正确地处理数据并避免溢出错误。
整型类型的示例 int:
var count int = 10 int8:
var temperature int8 = -20 int16:
var population int16 = 32700 int32:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18b5cd43b1e6d1603ae72c22388656ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcbf3f5c7c873fb513e0baabe0e2aed8/" rel="bookmark">
			Java版【植物大战僵尸&#43;源码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上期回顾： 今天给大家推荐一个Gtihub开源项目：PythonPlantsVsZombies，翻译成中就是植物大战僵尸。
《植物大战僵尸》是一款极富策略性的小游戏。可怕的僵尸即将入侵，每种僵尸都有不同的特点，例如铁桶僵尸拥有极强的抗击打能力，矿工僵尸可以挖地道绕过种植在土壤表面的植物等。玩家防御僵尸的方式就是栽种植物。49种植物每种都有不同的功能，例如樱桃炸弹可以和周围一定范围内的所有僵尸同归于尽，而食人花可以吃掉最靠近自己的一只僵尸。玩家可以针对不同僵尸的弱点来合理地种植植物，这也是胜利的诀窍。游戏根据玩法不同分为五种游戏模式：冒险模式、迷你模式、解谜模式、生存模式、禅境花园。加之黑夜、屋顶、浓雾以及泳池之类的障碍增加了其挑战性。该游戏近乎永无止境。
文章地址：Python版【植物大战僵尸 +源码】
粉丝福利： 文章目录 上期回顾：粉丝福利：写在前面：一、环境准备：二、游戏内容：三、实现思路：3.1 游戏架构设计：3.2 游戏元素实现：3.3 游戏逻辑处理：3.4 图形和动画：3.5 音效和背景音乐： 四、项目获取：欢迎添加微信，加入我的核心小队，请备注来意 写在前面： 小伙伴儿们大家好，我们又见面啦。在上一篇文章中，我向大家介绍了如何使用Python编程语言来实现经典的游戏——植物大战僵尸，并且分享了完整的源代码。这篇文章发布后，反响热烈，受到了众多小伙伴的热情追捧和积极反馈。在众多留言中，我注意到有不少小伙伴对Java版本的实现表现出了浓厚的兴趣。为了满足大家的期待，今天我特别准备了一份精心制作的内容——深入剖析Java版“植物大战僵尸”的实现原理，并细致解读其代码结构。
今天，我就为大家带来了另一款同样精彩的游戏分享——Java版的植物大战僵尸。在这篇文章中，我们将深入探讨Java语言实现植物大战僵尸的原理，并对代码进行详细的分析和讲解。无论你是Java初学者，还是有一定基础的开发者，相信这篇文章都能给你带来不少启发和收获。
那么，废话不多说，让我们共同开启今天的游戏之旅，一起领略Java版植物大战僵尸的魅力吧！希望通过这篇文章，大家能够更加深入地了解Java编程语言的强大功能，以及如何将这些功能应用到实际项目中，创造出更多有趣、实用的作品。
一、环境准备： 为了准备Java版植物大战僵尸的开发环境，你需要以下具体工具和版本：
JDK: Oracle JDK 8。确保安装了Java 8版本，因为它提供了广泛的库支持和稳定性。进行Java环境变量配置。
IDE: IntelliJ IDEA Community Edition 2021-03 或 Eclipse IDE 。这些IDE提供了用户友好的界面和强大的开发工具，适合Java开发。
版本控制系统: Git。用于代码的版本管理和协作开发。
依赖管理: Maven 3.8.3。帮助你管理项目的依赖库和构建过程。
二、游戏内容： 2.1、 游戏目标：
玩家的目标是在僵尸不断进攻的情况下，保护好房间不被僵尸闯入。玩家需要策略性地种植各种植物来抵御僵尸的进攻。
2.2 、植物卡牌系统：
游戏的左侧设有一个滚轮机会，它会不断地随机生成各种植物的卡牌。玩家可以通过鼠标点击来选中想要的植物卡牌，选中的植物卡牌会显示高亮或改变颜色，表示已被激活。当植物被选中后，鼠标指针会变成该植物的图标，并且可以移动到草地的任何位置进行放置。再次点击鼠标或空格键，玩家可以将选中的植物种植在指定的草地上，建立起防御阵线。 2.3 、植物功能介绍：
豌豆射手：基础攻击植物，可以发射豌豆攻击前方的僵尸。寒冰射手：发射冰冻豌豆，不仅能攻击僵尸，还能减缓僵尸的移动速度。三头豌豆射手：同时发射三颗豌豆，具有更强的攻击力。坚果：具有高耐久性，可以阻挡僵尸前进，为其他植物争取攻击时间。吹风草：具有特殊能力，可以一次性将所有屏幕上的僵尸吹出屏幕。地刺：放置在草地上后，会对经过的僵尸造成持续伤害。 2.4 、僵尸介绍：
游戏中有多种类型的僵尸，每种僵尸都有不同的血量和移动速度。击杀特定类型的僵尸，如足球僵尸，可以获得随机奖励，这些奖励会对僵尸产生特殊效果，如全屏僵尸死亡或全屏僵尸静止两秒等。 2.5 、游戏互动：
如果玩家对放置的植物不满意，可以使用铲子图标移除已种植的植物，为重新布局防御提供灵活性。游戏过程中，玩家需要注意植物的阳光产出，阳光是种植植物的货币，合理管理阳光资源对于建立有效的防御至关重要。 2.6 、游戏结束与重新开始：
如果有僵尸成功闯入房间，游戏即宣告结束。玩家可以选择点击重新开始游戏，进入新的一轮挑战。游戏可以设定不同的难度级别，随着游戏的进行，僵尸的数量和强度会逐渐增加，为玩家带来更大的挑战。 三、实现思路： 3.1 游戏架构设计： 采用面向对象的设计原则，将游戏中的各个元素（如植物、僵尸、子弹等）设计为不同的对象类。
使用MVC（Model-View-Controller）设计模式分离游戏的数据模型、用户界面和控制逻辑，以提高代码的可维护性和可扩展性。
3.2 游戏元素实现： 植物：定义不同类型的植物类，如向日葵、豌豆射手等，每种植物都有其特定的属性和行为，例如生成阳光、攻击僵尸等。僵尸：创建僵尸类，具有不同的类型和行为模式，例如普通僵尸、路障僵尸等，它们会沿着特定路径移动并向植物发起攻击。 铁桶僵尸：
package core.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcbf3f5c7c873fb513e0baabe0e2aed8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61029032429313b03016e43f55504499/" rel="bookmark">
			用20行python写一个最简单的网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先安装flask框架，cmd命令行 pip install flask，或pycharm -&gt; setting -&gt; project -&gt; python interpreter 搜索安装
# 引入Flask框架 from flask import Flask # 实例化Flask应用 app = Flask(__name__) # 定义一个路由，当用户访问网站根目录时触发 @app.route('/') def home(): # 返回一个HTML格式的响应 return "&lt;html&gt;&lt;head&gt;&lt;title&gt;简单网站&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;欢迎来到我的网站！&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;" # 当这个Python脚本被执行时，启动Flask服务器 if __name__ == '__main__': # 运行Flask开发服务器 # host=0.0.0.0表示允许所有IP地址访问 # port=5000是Flask的默认端口 app.run(host='0.0.0.0', port=5000) 直接运行，会输出
WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.
* Running on all addresses (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61029032429313b03016e43f55504499/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/060aafbfb1e4670c66ca7378c32d61b2/" rel="bookmark">
			如何在树莓派 Raspberry Pi中本地部署一个web站点并实现无公网IP远程访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 安装 Raspberry Pi OS2. 测试 web 站点3. 安装静态样例站点4. 将web站点发布到公网4.1 安装 Cpolar4.2 cpolar进行token认证4.3 生成cpolar随机域名网址4.4 生成cpolar二级子域名4.5 将参数保存到cpolar配置文件中4.6 测试修改后配置文件4.7 配置cpolar服务开机自启动 前言 本文主要介绍如何在树莓派 Raspberry Pi中搭建一个简单的web网站并结合cpolar内网穿透工具实现将本地站点发布至公网，使用生成的公网链接轻松访问本地搭建的网站。
1. 安装 Raspberry Pi OS 下载适用于您的操作系统的树莓派镜像工具。它支持大多数操作系统（Windows、Mac 和 Linux）。
https://www.raspberrypi.org/downloads/
运行并安装树莓派镜像工具选择 Raspberry Pi OS -&gt; Raspberry Pi OS (32-bit)将 SD 卡插入计算机点击 Write 按钮 设置 Apache Web 服务器
Apache 是一种流行的 Web 服务器应用程序，您可以将其安装在 Raspberry Pi 上以允许它为网页提供服务。
Apache 本身可以通过 HTTP 提供 HTML 文件。通过附加模块，它可以使用 PHP 等脚本语言提供动态网页。
sudo apt-get install apache2 -y sudo service apache2 restart 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/060aafbfb1e4670c66ca7378c32d61b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2411d30e81bc8e0cf2a7ec4354159eec/" rel="bookmark">
			【粉丝福利 | 第6期】K邻算法：在风险传导中的创新应用与实践价值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序员的实用神器 ⛳️ 写在前面参与规则！！！
✅参与方式：关注博主、点赞、收藏、评论，任意评论（每人最多评论三次）
⛳️本次送书1~4本【取决于阅读量，阅读量越多，送的越多】
这里写目录标题 程序员的实用神器01 前言02 K邻算法的实践意义03 创新应用与案例分析延伸阅读《图算法：行业应用与实践》 01 前言 在当今工业领域，图思维方式与图数据技术的应用日益广泛，成为图数据探索、挖掘与应用的坚实基础。本文旨在分享嬴图团队在算法实践应用中的宝贵经验与深刻思考，不仅促进业界爱好者之间的交流，更期望从技术层面为企业在图数据库选型时提供新的视角与思路。
02 K邻算法的实践意义 K邻算法（K-Hop Neighbor），即K跳邻居算法，是一种基于广度优先搜索（BFS）[1] 的遍历策略，用于探索起始节点周围的邻域。该算法在关系发现、影响力预测、好友推荐等预测类场景中得到了广泛应用。
在图论中，沿着一条边移动被视为一跳（hop）。在遍历图中的顶点时，我们需要考虑多跳问题。图论起源于数学家欧拉在1836年提出的哥尼斯堡七桥问题，它奠定了图计算的数学基础。自20世纪80年代以来，图计算技术迅速发展，成为现代计算领域的重要组成部分。
在现实世界中，危机的传播正是K邻搜索的一个典型应用。以发生危机的实体为起点，顺着或逆着（取决于边的具体定义）边的方向进行1步、2步、3步乃至更深层次的查询，得到的就是先后会被危机波及到的实体。
03 创新应用与案例分析 以某知名房地产企业HD的供应链图谱为例，我们可以通过持股方向、资金流向等信息，清晰直观地揭示危机的传播路径和传递对象。
以HD为例，危机发生后，风险传播路径如下：
第一层：影响HD的关联公司； 第二层：影响公司员工和供应商； 第三层：影响购房者（供应商停止供货、工人停工，可能导致HD的在建工程停滞）。 …… 风险从HD集团开始，逐步扩散至关联公司、员工、供应商、购房者等，形成了一张复杂的“网络”，呈现出明显的“链条效应”。
然而，许多与风险传导相关的实际应用并未采用图计算，而是依赖于手工计算，如银行KYC部门在计算UBO时仍使用Excel表。这种做法的效率和准确率可想而知。这与金融机构IT系统的陈旧和工作方法的落后有直接关系，阻碍了业务的开展，如企业影响力分析。
企业影响力分析不仅涉及持股关系、生产供求关系等传统问题，还应包括与企业相关的所有金融行为和事件，以及与这些行为事件直接或间接相关的事务。分析的视角不应仅限于企业实体，而应扩展至企业发布的产品、债券等。
如图3所示，分析的核心是企业的某个债券，其价格下跌可能直接影响其他债券的价格：
图4则标出了持有该债券的、可能受影响的省内其他企业：
图3和图4展示的是该债券的1步邻居，从这些邻居继续向外探寻就能得到该债券价格下跌后产生的危机传递效应，如图5所示：
专家们已越来越认识到，金融风险并不是孤立存在的，不同风险间具有链条效应，任何一只蝴蝶扇动翅膀，都有可能造成跨市场的风险传染——风险的关联性具有相互转化、传递和耦合的特点——图技术与蝴蝶效应在本质上是不谋而合的，即通过深度挖掘不同来源的数据，以网络化分析的方式去洞察。
此外，金融场景是一种基于长链条计算的场景，这就导致技术实现时的规则更为复杂，因为会涉及到各种回溯、归因，而且数据的计算量更大，同时也更注重时效性。只有实现真正的实时、全面、深度穿透、逐笔追溯、精准计量的监测和预警，才能保障金融风控中不会出现“蝴蝶效应”式的风险发生。
值得注意的是，图往往包含着复杂的属性及定义，例如：边的有向、无向，边的属性权重，K 邻是否包含 K-1 邻，如何处理计算环路等等，这些问题会导致 K 邻算法具体实现的差异。此外，在一些实际场景中，图自身拓扑结构的变化，过滤条件的设定，节点、边属性的变化都会影响到 K 邻计算的结果。
在行业应用中，K邻算法通常应用于多模态的异构图，即将多个单一信息的图融合在一起形成的综合性图谱。这对算法实现者的数据收集和构图能力提出了高要求，同时也对K邻算法的灵活性和功能性提出了更高标准。嬴图的高密度并发图算法库是目前全球运行最快、最丰富的图算法集合，支持通过EXTA接口进行热插拔和扩展。
如果在公开资料中看到K邻算法的应用多是同构图（只有一种点、一种边），可能是因为作者想通过简单的例子阐明观点，或者因为构图能力不足限制了算法的应用，也可能是K邻算法的实现不尽人意，无法对异构图进行恰当处理。K邻算法的应用应该是广泛且实际的，能够解决现实问题的，如果是因为后面两种情况而限制了算法的“大展宏图”，那么相关图厂商就应该反思一二并提高自身了！
最后，一个优秀的算法设计不仅应具备解决问题的能力，还应关注计算效率，即算力。我们列举了一些高性能图计算系统应具备的核心能力，以供企业在评估市场上各种图计算产品时作为参考：
高速图搜索能力：高QPS/TPS、低延时，实时动态剪枝能力； 对任何规模图的深度、实时搜索与遍历能力（10层以上）； 高密度、高并发图计算引擎：极高的吞吐率； 成熟稳定的图数据库、图计算与存储引擎、图中台等； 可扩展的计算能力：支持垂直与水平可扩展； 3D+2D高维可视化、高性能的知识图谱Web前端系统； 便捷、低成本的二次开发能力（图查询语言、API/SDK、工具箱等）。 K邻算法：在风险传导中的创新应用与实践价值
本文摘编自《图算法：行业应用与实践》，经出版方授权发布。
延伸阅读《图算法：行业应用与实践》 推荐语：这是一本全面讲解当下主流图算法原理与工程实践的著作，旨在帮助读者在分析和处理各种复杂的数据关系时能更好地得其法、善其事、尽其能。本书概念清晰、内容丰富、实用性强、语言流畅，深入浅出、重点突出，既适合入门读者阅读，又适合有一定图数据库基础的进阶人员阅读。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eadfbb69e9e7987b765c0399448e9add/" rel="bookmark">
			AI时代：人工智能大模型引领科技创造新时代
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一. AI在国家战略中有着举足轻重的地位1.1 战略1.2 能源1.3 教育 二. AI在日常生活中扮演着重要角色2.1 医疗保健2.2 智能客服2.3 自动驾驶2.4 娱乐和媒体2.5 智能家居 三. AI的未来发展趋势 总结 前言 随着AI技术的进步，新一代的AI技术已经开始尝试摆脱依赖人类活动数据的限制，并探索自我学习和自我进化的可能性。例如，OpenAI正在训练下一代的人工智能，暂名为“Q*”，这是一种可能首次采用“从零开始”的方式训练的人工智能，其智能不来自人类活动的数据，并且有潜力修改自身的代码以适应更复杂的学习任务。
一. AI在国家战略中有着举足轻重的地位 1.1 战略 AI在战略中的作用表现在多个方面，包括但不限于数据分析、预测建模、资源优化和决策支持。AI正在成为战略规划中不可或缺的工具，通过提供数据支持、预测未来、优化资源分配、辅助决策、增强适应性和灵活性，以及促进跨部门协作，AI正在重塑企业的战略管理方式。随着技术的不断进步，AI在战略中的作用将越来越重要。
数据驱动的洞察
AI能够处理和分析大量数据，包括市场趋势、竞争对手行为和消费者偏好。通过机器学习算法，AI可以识别数据中的模式和关联，为战略规划提供数据支持。
预测建模
AI的预测模型可以基于历史数据和当前趋势来预测未来的市场变化。这种前瞻性的分析有助于企业在竞争激烈的市场中提前布局，制定有效的长期战略。
资源优化
AI可以优化资源分配，确保资源在最需要的地方得到最有效的利用。例如，在供应链管理中，AI可以预测需求变化，调整库存水平，减少过剩或缺货的情况。
1.2 能源 AI在能源领域的应用正在逐步深化，对能源产业产生了显著影响，AI有助于解决可再生能源（如太阳能和风能）的间歇性问题，通过智能调度和储能系统的优化，提高其在能源结构中的比例。AI可以优化电池存储系统的充放电周期，提高储能效率，为电网提供更稳定的支持。
智能电网
在电力系统中，AI被用于智能电网的构建，以优化电力的分配和使用。例如，AI可以预测电力需求的变化，从而提前调整发电计划，确保电力供应的稳定性。
2. 能源交易
AI在能源交易中的应用包括自动化交易平台的开发，这些平台能够实时分析市场数据，为投资者提供交易建议。此外，AI还可以帮助企业在复杂的能源市场中进行风险管理。
3. 可再生能源
AI在太阳能和风能等可再生能源领域的应用，如通过优化风力涡轮机的布局和太阳能电池板的角度，以最大化能源捕获。AI还可以用于预测天气条件，从而提前调整能源产出。
1.3 教育 人工智能（AI）在教育领域的应用正在迅速扩展，其潜力巨大且影响深远。AI在教育领域的应用正在不断发展，它为教育带来了革命性的变化，提高了教学效率，同时为学生提供了更加个性化和互动的学习体验。随着技术的进步，AI有望在教育中发挥更加核心的角色。
个性化学习
AI可以通过分析学生的学习数据，识别学生的学习风格、知识掌握程度和兴趣点，从而提供个性化的学习路径和资源。这种个性化的学习体验有助于提高学生的参与度和学习成效。
语言学习
AI在语言学习中的应用，如智能语音识别和自然语言处理，帮助学生通过模拟对话和即时反馈来提高语言能力。
AI在语言学习中的应用正在改变传统的学习模式，为学生提供了更加灵活、高效和个性化的学习体验。随着技术的不断进步，预计AI将在语言学习领域发挥越来越重要的作用。
二. AI在日常生活中扮演着重要角色 2.1 医疗保健 AI在医疗保健领域的作用日益显著，它正在改变医疗实践的许多方面，从诊断到治疗，再到药物研发和患者护理。AI在医疗保健中的应用正在不断发展和完善，它为医疗专业人员提供了强大的工具，以提高患者护理的质量和效率。随着技术的进步，AI有望在未来的医疗实践中发挥更加核心的角色。
-诊断辅助：
AI算法，特别是深度学习技术，被用于分析医学影像数据，如X射线、CT扫描和MRI图像。这些算法可以辅助医生检测病变、肿瘤和其他异常结构，有时甚至能发现肉眼难以识别的微妙变化。例如，Google Health的病理学图像分析工具已经在某些情况下证明能够与放射科医师的诊断相媲美或更优。
-医疗影像处理：
AI在医疗影像处理中的应用包括图像增强、分割和识别。这些技术可以帮助医生更清晰地看到影像中的细节，提高诊断的准确性。例如，AI算法可以自动标记出肿瘤的边界，为放射治疗提供精确的定位。
个性化医疗：
IBM Watson等AI系统能够分析大量的患者数据，包括基因组学、临床记录和治疗响应，以识别疾病模式和治疗效果。这种分析有助于医生为患者制定个性化的治疗计划，尤其是在癌症治疗中，AI辅助的决策支持系统可以提供基于证据的治疗建议。
2.2 智能客服 人工智能（AI）在智能客服领域的应用正在快速增长，并对客户服务行业产生了显著影响。AI在智能客服的应用正逐步改变客户服务行业的面貌，未来智能客服将更加智能、高效和个性化，为企业和消费者带来更大的便利和价值。
聊天机器人（Chatbots)
AI在智能聊天上的作用主要体现在其强大的自然语言处理能力。通过深度学习和机器学习技术，AI能够理解和生成接近人类的语言，实现流畅、自然的对话体验。此外，AI还具备记忆功能，能够根据聊天历史提供个性化的回应，增强用户互动。AI的这些特性使得智能聊天成为了一种高效、便捷的沟通方式，广泛应用于客户服务、社交媒体、在线教育等领域。随着技术的不断进步，AI在智能聊天领域的应用将更加广泛和深入。
2.3 自动驾驶 人工智能（AI）在自动驾驶技术领域的应用正在重塑交通行业，并对社会产生深远影响。人工智能（AI）在自动驾驶技术领域的应用正在重塑交通行业，并对社会产生深远影响。以下是AI在自动驾驶方面的一些主要影响：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eadfbb69e9e7987b765c0399448e9add/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01566a13064e203ea23c44b6658ce807/" rel="bookmark">
			【优选算法】——双指针——15. 三数之和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.题目
2.解法（排序+双指针）：
算法思路：
3.代码实现
1.题目 15. 三数之和
提示
给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请
你返回所有和为 0 且不重复的三元组。
注意：答案中不可以包含重复的三元组。
示例 1：
输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 解释： nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。 nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。 nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。 不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。 注意，输出的顺序和三元组的顺序并不重要。 示例 2：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01566a13064e203ea23c44b6658ce807/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5ad2712816a9364bae0e758e091f82f/" rel="bookmark">
			植物大战僵尸游戏【python】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图 引言： 塔防游戏一直以其简单而又富有策略性的玩法备受玩家喜爱，《植物大战僵尸》就是其中一款经典的塔防游戏。在本文中，我们将使用Python编程来实现这个有趣的游戏，通过代码解释游戏的核心机制和实现细节。让我们一起来探索如何使用Python编程语言打造属于自己的《植物大战僵尸》游戏吧！
实现步骤 初始化游戏环境
介绍使用Pygame库来初始化游戏的过程。解释如何设置游戏窗口的大小、标题等属性。 创建植物和僵尸类
解释如何创建植物和僵尸的类，并引入图像资源。分别介绍植物和僵尸类的属性和方法，例如位置、图像、攻击力等。 游戏循环和事件处理
解释游戏循环的作用和实现方式。介绍如何处理用户事件，例如关闭窗口和鼠标点击事件。 绘制游戏元素
解释如何在游戏窗口中绘制植物和僵尸。提到使用Pygame提供的绘图函数来实现元素的绘制和更新。 植物和僵尸的移动和碰撞检测
解释如何更新植物和僵尸的位置，使其移动。介绍如何进行碰撞检测，以判断植物和僵尸是否发生碰撞。 添加攻击和生命值
引入植物和僵尸的攻击和生命值属性。解释如何处理植物和僵尸之间的互动，包括攻击和生命值的变化。 用户输入和植物种植
解释如何处理用户输入，特别是鼠标点击事件。引入玩家可以通过点击屏幕来种植植物的功能，并解释如何实现这一功能。 游戏结束和计分系统
解释如何判断游戏是否结束，例如当植物或僵尸的生命值降至零时。提到添加计分系统，以记录玩家的得分和成就。 优化和扩展
提供一些建议，如如何优化游戏性能和改进用户体验。引入一些扩展功能的想法，例如不同类型的植物和僵尸，关卡设计等。 完整代码： import pygame import random # 初始化游戏 pygame.init() screen_width, screen_height = 800, 600 screen = pygame.display.set_mode((screen_width, screen_height)) pygame.display.set_caption("植物大战僵尸") # 定义植物类 class Plant(pygame.sprite.Sprite): def __init__(self, x, y): super().__init__() self.image = pygame.image.load("plant.png") # 植物的图片 self.rect = self.image.get_rect() self.rect.x = x self.rect.y = y self.attack = 10 # 植物的攻击力 self.health = 100 # 植物的生命值 def update(self): # 植物的更新逻辑 pass # 定义僵尸类 class Zombie(pygame.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5ad2712816a9364bae0e758e091f82f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c91b66bcd71092872b10b92998e1464/" rel="bookmark">
			班级综合测评|基于Springboot&#43;vue的班级综合测评管理系统(源码&#43;数据库&#43;文档)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
基于Springboot+vue的“智慧食堂”系统
一、前言
二、系统设计
三、系统功能设计 1 管理员功能模块
2学生功能模块
3教师功能模块
四、数据库设计
五、核心代码 六、论文参考
七、最新计算机毕设选题推荐
八、源码获取：
博主介绍：✌️大厂码农|毕设布道师，阿里云开发社区乘风者计划专家博主，CSDN平台Java领域优质创作者，专注于大学生项目实战开发、讲解和毕业答疑辅导。✌️
主要项目：小程序、SpringBoot、SSM、Vue、Html、Jsp、Nodejs等设计与开发。
🍅文末获取源码联系🍅
基于Springboot+vue的班级综合测评管理系统 一、前言 随着互联网技术的高速发展，人们生活的各方面都受到互联网技术的影响。现在人们可以通过互联网技术就能实现不出家门就可以通过网络进行系统管理，交易等，而且过程简单、快捷。同样的，在人们的工作生活中，也就需要互联网技术来方便人们的日常工作生活，实现工作办公的自动化处理，实现信息化，无纸化办公。
本课题在充分研究了在Springboot框架基础上，采用B/S模式，以Java为开发语言，MyEclipse为开发工具，MySQL为数据管理平台，实现的内容主要包括首页，个人中心，学生管理，教师管理，班级管理，综合测评管理等功能。
关键词班级综合测评管理；Java；Springboot
二、系统设计 系统功能结构图，如下：
三、系统功能设计 1 管理员功能模块 管理员输入账号和密码，选择登录角色进行登录，管理员登录界面如图5-1所示：
图5-1管理员登录界面
2学生功能模块 学生功能：学生登录到班级综合测评管理系统后，可以对首页、个人中心、综合测评管理等进行操作，如图5-7所示：
图5-7学生功能界面
3教师功能模块 教师功能：教师登录到班级综合测评管理系统后，可以对首页、个人中心、学生管理、综合测评管理等进行操作，如图5-10所示：
图5-10教师功能界面
四、数据库设计 学生管理实体图如图4-2所示：
图4-2学生管理实体图
数据库表的设计，如下表：
表4-1：用户表
字段名称
类型
长度
字段说明
主键
默认值
id
bigint
主键
主键
username
varchar
100
用户名
password
varchar
100
密码
role
varchar
100
角色
管理员
addtime
timestamp
新增时间
CURRENT_TIMESTAMP
五、核心代码 package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c91b66bcd71092872b10b92998e1464/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c80091eedb1d432c464c7e93453c7cc0/" rel="bookmark">
			华为OD机试2024年最新题库（Python、JAVA、C&#43;&#43;合集）C卷&#43;D卷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是一名软件开发培训机构老师，我的学生已经有上百人通过了华为OD机试，学生们每次考完试，会把题目拿出来一起交流分享。
重要：2024年5月份开始，考的都是OD统一考试（D卷），题库已经整理好了，命中率95%以上。
2024年5-10月份考的就是这个题库，都是原题，大家如果发现解法不全的请私信我，谢谢。
据参加D卷考试的同学反映，目前D卷题目跟C卷是一样的，发现新题会及时跟新。祝大家考试顺利。
以下是D卷100分题目：
序号题目分值通过率试卷类型语言1寻找身高相近的小朋友100100%OD统一考试（C卷）python、java、C++2围棋的气100100%OD统一考试（C卷）python、java、C++3用连续自然数之和来表达整数100100%OD统一考试（C卷）python、java、C++4开源项目热榜100100%OD统一考试（C卷）python、java、C++5API集群负载统计100100%OD统一考试（C卷）python、java、C++6整数对最小和100100%OD统一考试（C卷）python、java、C++7素数之积100100%OD统一考试（C卷）python、java、C++8CPU算力分配100100%OD统一考试（C卷）python、java、C++9最大坐标值100100%OD统一考试（C卷）python、java、C++10寻找最富裕的小家庭100100%OD统一考试（C卷）python、java、C++11查找接口成功率最优时间段100100%OD统一考试（C卷）python、java、C++12分割均衡字符串100100%OD统一考试（C卷）python、java、C++13虚拟游戏理财100100%OD统一考试（C卷）python、java、C++14靠谱的车100100%OD统一考试（C卷）python、java、C++15执行时长100100%OD统一考试（C卷）python、java、C++16万能字符单词拼写100100%OD统一考试（C卷）python、java、C++17来自异国的客人100100%OD统一考试（C卷）python、java、C++18求最多可以派出多少支团队100100%OD统一考试（C卷）python、java、C++19最长子字符串的长度(一)100100%OD统一考试（C卷）python、java、C++20机场航班调度程序100100%OD统一考试（C卷）python、java、C++21数的分解100100%OD统一考试（C卷）python、java、C++22智能成绩表 100100%OD统一考试（C卷）python、java、C++23提取字符串中的最长数学表达式并计算100100%OD统一考试（C卷）python、java、C++24小朋友来自多少小区100100%OD统一考试（C卷）python、java、C++25停车场车辆统计100100%OD统一考试（C卷）python、java、C++26执行任务赚积分100100%OD统一考试（C卷）python、java、C++27最多购买宝石数目100100%OD统一考试（C卷）python、java、C++28求字符串中所有整数的最小和100100%OD统一考试（C卷）python、java、C++29堆内存申请100100%OD统一考试（C卷）python、java、C++30测试用例执行计划100100%OD统一考试（C卷）python、java、C++31按身高和体重排队100100%OD统一考试（C卷）python、java、C++32攀登者1100100%OD统一考试（C卷）python、java、C++33分披萨100100%OD统一考试（C卷）python、java、C++34计算面积100100%OD统一考试（C卷）python、java、C++35考勤信息100100%OD统一考试（C卷）python、java、C++36字符串变换最小字符串100100%OD统一考试（C卷）python、java、C++37分配土地100100%OD统一考试（C卷）python、java、C++38小华最多能得到多少克黄金100100%OD统一考试（C卷）python、java、C++39英文输入法100100%OD统一考试（C卷）python、java、C++40游戏分组100100%OD统一考试（C卷）python、java、C++41精准核酸检测100100%OD统一考试（C卷）python、java、C++42内存冷热标记100100%OD统一考试（C卷）python、java、C++43密码解密100100%OD统一考试（C卷）python、java、C++44密码输入检测100100%OD统一考试（C卷）python、java、C++45螺旋数字矩阵100100%OD统一考试（C卷）python、java、C++46火星文计算100100%OD统一考试（C卷）python、java、C++47灰度图恢复100100%OD统一考试（C卷）python、java、C++48找朋友100100%OD统一考试（C卷）python、java、C++49求幸存数之和100100%OD统一考试（C卷）python、java、C++50多段线数据压缩100100%OD统一考试（C卷）python、java、C++51生成哈夫曼树100100%OD统一考试（C卷）python、java、C++52机器人仓库搬砖100100%OD统一考试（C卷）python、java、C++53数组去重和排序100100%OD统一考试（C卷）python、java、C++54找座位100100%OD统一考试（C卷）python、java、C++55计算三叉搜索树的高度100100%OD统一考试（C卷）python、java、C++56小明找位置100100%OD统一考试（C卷）python、java、C++57转盘寿司100100%OD统一考试（C卷）python、java、C++58 手机App防沉迷系统100100%OD统一考试（C卷）python、java、C++59传递悄悄话100100%OD统一考试（C卷）python、java、C++60小明找位置100100%OD统一考试（C卷python、java、C++61字符串序列判定100100%OD统一考试（C卷python、java、C++62田忌赛马100100%D统一考试（C卷python、java、C++63幼儿园篮球游戏100100%D统一考试（C卷python、java、C++64部门人力资源分配100100%D统一考试（C卷python、java、C++65Wonderland游乐园100100%D统一考试（C卷python、java、C++66特殊的加密算法100100%D统一考试（C卷python、java、C++67信道分配100100%D统一考试（C卷python、java、C++68最大N个数与最小N个数的和100100%D统一考试（C卷python、java、C++68字符串序列判断100100%D统一考试（C卷python、java、C++69剩余银饰的重量100100%D统一考试（C卷python、java、C++70查找众数及中位数100100%D统一考试（C卷python、java、C++ 以下是D卷200分题目：
序号题目分值通过率试卷类型语言1分月饼 200100%OD统一考试（C卷）python、java、C++2找城市200100%OD统一考试（C卷）python、java、C++3两个字符串间的最短路径问题200100%OD统一考试（C卷）python、java、C++4电脑病毒感染200100%OD统一考试（C卷）python、java、C++5项目排期200100%OD统一考试（C卷）python、java、C++65G网络建设200100%OD统一考试（C卷）python、java、C++7可以组成网络的服务器200100%OD统一考试（C卷）python、java、C++8田忌赛马200100%OD统一考试（C卷）python、java、C++9 任务处理200100%OD统一考试（C卷）python、java、C++10石头剪刀布游戏200100%OD统一考试（C卷）python、java、C++11最小矩阵宽度200100%OD统一考试（C卷）python、java、C++12部门人力分配200100%OD统一考试（C卷）python、java、C++13中文分词模拟器200100%OD统一考试（C卷）python、java、C++14Wonderland200100%OD统一考试（C卷）python、java、C++15跳马200100%OD统一考试（C卷）python、java、C++16符号运算200100%OD统一考试（C卷）python、java、C++17孙悟空吃蟠桃200100%OD统一考试（C卷）python、java、C++18最长子字符串的长度(二)200100%OD统一考试（C卷）python、java、C++19求满足条件的最长子串的长度200100%OD统一考试（C卷）python、java、C++20最长的指定瑕疵度的元音子串200100%OD统一考试（C卷）python、java、C++21抢7游戏200100%OD统一考试（C卷）python、java、C++22贪心歌手200100%OD统一考试（C卷）python、java、C++23考古学家200100%OD统一考试（C卷）python、java、C++24解密犯罪时间200100%OD统一考试（C卷）python、java、C++25员工派遣200100%OD统一考试（C卷）python、java、C++26字符串拼接200100%OD统一考试（C卷）python、java、C++27查找一个有向网络的头节点和尾节点200100%OD统一考试（C卷）python、java、C++28文件缓存系统200100%OD统一考试（C卷）python、java、C++29园区参观路径200100%OD统一考试（C卷）python、java、C++30快递员的烦恼200100%OD统一考试（C卷）python、java、C++31文本统计分析200100%OD统一考试（C卷）python、java、C++32矩阵匹配200100%OD统一考试（C卷）python、java、C++33图像物体的边界200100%OD统一考试（C卷）python、java、C++34 寻找最优的路测线路200100%OD统一考试（C卷）python、java、C++35运输时间200100%OD统一考试（C卷）python、java、C++36高效货运200100%OD统一考试（C卷）python、java、C++37贪吃的猴子200100%OD统一考试（C卷）python、java、C++38最长的指定瑕疵度的元音子串200100%OD统一考试（C卷）python、java、C++39反射计数200100%OD统一考试（C卷）python、java、C++40伐木工200100%OD统一考试（C卷）python、java、C++41二叉树的广度优先遍历200100%OD统一考试（C卷）python、java、C++42攀登者2200100%OD统一考试（C卷）python、java、C++43二叉树的计算200100%OD统一考试（C卷）python、java、C++44学生重新排队200100%OD统一考试（C卷）python、java、C++45智能驾驶200100%OD统一考试（C卷）python、java、C++46路口最短时间问题200100%OD统一考试（C卷）python、java、C++47跳格子3200100%OD统一考试（C卷）python、java、C++48模拟目录管理200100%OD统一考试（C卷）python、java、C++49根据IP查找城市200100%OD统一考试（C卷）python、java、C++50会议室占用时间200100%OD统一考试（C卷）python、java、C++51亲子游戏200100%OD统一考试（C卷）python、java、C++52启动多任务排序200100%OD统一考试（C卷）python、java、C++53欢乐的周末200100%OD统一考试（C卷）python、java、C++54找数字200100%OD统一考试（C卷）python、java、C++55推荐多样性200100%OD统一考试（C卷）python、java、C++56数据单元的变化替换200100%OD统一考试（C卷）python、java、C++57模拟数据序列化传输200100%OD统一考试（C卷）python、java、C++ 送给看到最后的人，华为OD机考交流QQ群：291649488，里面可以OD统一考试（C卷D卷）交流机试、面试经验，我也会定期答疑~
华为OD招聘，每年的1-5月份是高峰期，这个阶段呢，offer多，面试简单，薪资高，大家可以利用年前的时间好好准备和复习，取得一个不错的机试成绩~
机考题库大概每半年更新一次，也就是说一直到2024年10月份，考的都是这份题库，大家有充足的时间来复习和准备~
另外，这些题目是给大家参考的，考试过程中要注意重复率，重复率过高很判定作弊嫌疑，切记~
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/21/">«</a>
	<span class="pagination__item pagination__item--current">22/71</span>
	<a class="pagination__item pagination__item--next btn" href="/page/23/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>