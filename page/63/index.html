<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.126.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程学习者的博客">
		<meta property="og:url" content="https://bcxuexizhe.github.io/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="编程学习者">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f58cf7ee77c268a5acf19a73a55638d/" rel="bookmark">
			哈希表C&#43;&#43;哈希表详解（知识点&#43;相关LeetCode题目）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、什么是哈希表
二、哈希表的操作
2.1 操作时间复杂度
2.2 哈希表通用API
2.3 建立哈希表
2.3 哈希表常见结构介绍
Set（集合）
Map（映射）
unordered_map（哈希表）
三、哈希表的力扣经典题目
有效的字母异位词242
两个数组的交集 349
两数之和1
四数相加II 454
三数之和 15
四数之和 18
前言 本文将从哈希表的概念、复杂度、STL实现函数、哈希表相关经典题目展开叙述。
一、什么是哈希表 哈希表是散列表，就是通过关键码值而直接进行访问的一种数据结构
哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素
其内部由一个个key：value 样式的键值对组成。
哈希表中的key通过哈希函数得到内存地址，然后将key和value放到对应的内存地址，从而实现通过key获取Value的方式
哈希碰撞：2个不同的key通过哈希函数（hash function）得到了相同的内存地址，也就是是内存地址已经被一个占用了，解决方法是将其中之一变为链表结构，使用next指向。这样内存地址就不会重复，但是会影响查询
二、哈希表的操作 2.1 操作时间复杂度 1) 搜索：1.无哈希碰撞，直接用哈希函数通过Key定位到内存地址,复杂度O(1) 2.有哈希碰撞，因为存在内存地址需要通过链表查询,复杂度O(N)
2) 插入：通过key找到内存地址插入即可,复杂度 O(1)--自动插入
unorder_map&lt;int,int&gt; InquireMap; InquireMap[val] = 1; 3) 删除：通过key找到内存地址删除即可,复杂度 O(1)
2.2 哈希表通用API begin()：该函数返回一个指向哈希表开始位置的迭代器end()：返回一个指向哈希表结尾位置的下一个元素的迭代器empty()：判断哈希表是否为空，空则返回true，非空返回falsesize()：返回哈希表的大小erase()： 删除某个位置的元素，或者删除某个位置开始到某个位置结束这一范围内的元素， 或者传入key值删除键值对at()：根据key查找哈希表中的元素clear()：清空哈希表中的元素find()：以key作为参数寻找哈希表中的元素，如果哈希表中存在该key值则返回该位置上的迭代器，否则返回哈希表最后一个元素下一位置上的迭代器count()： 统计某个key值对应的元素个数 （注：因为unordered_map不允许重复元素，所以返回值为0或1） 2.3 建立哈希表 unordered_map&lt;char,int&gt; correspond{ {'I',1}, {'V',5}, {'X',10}, {'L',50}, {'C',100}, {'D',500}, {'M',1000}, }; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f58cf7ee77c268a5acf19a73a55638d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c919ab4b16493509c001ef650265792e/" rel="bookmark">
			详解Leetcode中关于malloc模拟开辟二维数组问题，涉及二维数组的题目所给函数中的各个参数的解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 相关题目介绍二维数组的模拟开辟函数参数解读此列题的解题代码 相关题目介绍 最近博主一直再刷Leetcode上有关c语言的题目，有些题目第一步就将我卡死了。为什么呢？因为题目中所给的函数里的参数的具体含义我既然都不知道是什么意思。当然在请教了一些大佬后我也顺利解决了，不然也不会有人和你们分享了，哈哈哈~
我就已一个典型的题目来介绍吧：题目链接： 2373. 矩阵中的局部最大值
int** largestLocal(int** grid, int gridSize, int* gridColSize, int* returnSize, int** returnColumnSizes) { } 我将从以下几个方面对此题及此类问题进行剖析：
1. malloc模拟开辟二维数组
2. 涉及二维数组的题目所给函数中的各个参数的解读
3. 二维数组每一维长度的更新
二维数组的模拟开辟 此题要求返回一个矩阵，我们都知道矩阵可以当作一个二维数组来看待。返回的二维数组是需要我们自己创建的，即要用malloc函数动态开辟。下面讲解具体思路：
使用指针数组
以row*col的数组为例 //动态开辟一个指针数组 int** pArr=(int**)malloc(sizeof(int*)*row); //使row个指针分别指向每次动态开辟的地址 for(int i=0;i &lt; col;i++) { pArr[i] = (int*)malloc(sizeof(int)*col); } 首先malloc动态开辟一个数组指针，其大小为row * sizeof(int*)，row代表想开辟二维数组的行数，sizeof(int*)便是每个指针的大小；我们都知道一维数组名其实都是一个指向首元素的地址，那么我们就可以每次开辟一个长度为col的一维数组，并将首地址赋给pArr[i]这样我们同样可以使用pArr[i][j]调用第i行第j列的元素。
但是有一点需要注意：这种方法模拟开辟的二维数组的每行之间并不是连续存放的，因为每次malloc开辟的地址是随机的，但一维数组之间是连续存放的·。
使用数组指针
同样以一个row * col的二维数组为例 int(*pArr)[col]=(int(* )[row])malloc(row * col * sizeof(int)) 首先malloc直接动态开辟整个二维数组的大小，并将返回值强转为int(* )[col]型，这样每当pArr加一操作时，跳过的就是一个长度为col的一维数组吗。那么想要访问二维数组第i行，第j列就可以使用pArr[i][j]来实现。
同样需要注意的是：pArr的类型为int(* )[col]所以一般在做题时不使用此创建方法，但单纯模拟创建二维数组是没有问题的。此方法动态开辟的二维数组在内存中是连续存放的。
一维数组方式
同样以一个row * col的二维数组为例 int* pArr=(int* )malloc(row * col * sizeof(int)); 相较于上面的两个方法这个就比较鸡肋了，既不能直接使用下标访问，返回类型也为int*。那他的访问方式是怎样的呢？即：pArr(i*col+j)这里的i代表行数，j代表列数，这里i * col是为了使i++时每次跳过一行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c919ab4b16493509c001ef650265792e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f200d53ee8ebee64bfb0d4a40ac01ca9/" rel="bookmark">
			MySQL的指令大全和注意事项(强烈推荐收藏)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL基础知识点和快速查询 MySQL基础MySql基本指令1、MySQL常用命令2、修改mysql中root的密码：3、grant授权4、增加新用户5、删除授权：6、创建一个用户custom在特定客户端it363.com登录，可访问特定数据库fangchandb7、重命名表:8、mysqldump9、恢复数据库 mysql命令一 . 安装与配置MYSQL二 . 常用mysql命令行命令1 .mysql的启动与停止2 .查看被监听的端口 , findstr用于查找后面的端口是否存在3 . 在命令行中登陆MYSQL控制台 , 即使用 MYSQL COMMEND LINE TOOL5 . 切换连接数据库的语法 :6 . 显示所有数据库 :7 . 显示数据库中的所有表 :8 . 显示某个表创建时的全部信息 :9 . 查看表的具体属性信息及表中各字段的描述 三 . MySql中的SQL语句习题： 四. 字符集出现错误解决办法五. 学习MySQL常用操作命令1、启动MySQL服务器2、进入mysql交互操作界面3、退出MySQL操作界面4、第一条命令5、多行语句6、一行多命令7、显示当前存在的数据库8、选择数据库并显示当前选择的数据库9、显示当前数据库中存在的表10、显示表(db)的内容11、命令的取消 六. mysql命令一、连接MYSQL。1、连接到本机上的MYSQL。2、连接到远程主机上的MYSQL。3、退出MYSQL命令： exit (回车) 二、修改密码。1、给root加个密码ab12。2、再将root的密码改为djg345。 三、增加新用户。 七. MYSQL中有关数据库方面的操作。一、操作技巧二、显示命令1、显示当前数据库服务器中的数据库列表：2、显示数据库中的数据表：3、显示数据表的结构：4、建立数据库：5、建立数据表：6、删除数据库：7、删除数据表：8、将表中记录清空：9、显示表中的记录：10、往表中插入记录：11、更新表中数据：12、用文本方式将数据装入数据表中：13、导入.sql文件命令：14、命令行修改root密码：15、显示use的数据库名：16、显示当前的user： 三、一个建库和建表以及插入数据的实例四、将文本数据转到数据库中五、备份数据库1.导出整个数据库2.导出一个表3.导出一个数据库结构4.带语言参数导出 六、导入数据库**数据库及表导出导入示例：****导入数据库：****其他** 使用MySql的管理心得, 八. 全局管理权限： MySQL基础 MySql基本指令 1、MySQL常用命令 # 创建数据库 create database name; #选择数据库 use databasename; #直接删除数据库，不提醒 drop database name ; #显示表 show tables; #表的详细描述 describe tablename; select 中加上distinct去除重复字段 #删除数据库前，有提示。 mysqladmin drop databasename #显示当前mysql版本和当前日期 select version(),current_date; 2、修改mysql中root的密码： mysql -u root -p update user set password=password(”123456″) where user=’root’; flush privileges #刷新数据库 use dbname; #打开数据库： show databases; #显示所有数据库 show tables; #显示数据库mysql中所有的表：先use mysql；然后 describe user; #显示表mysql数据库中user表的列信息)； 3、grant授权 创建一个可以从任何地方连接服务器的一个完全的超级用户，但是必须使用一个口令something做这个
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f200d53ee8ebee64bfb0d4a40ac01ca9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97d527bed06cd1442f5157f90c5da949/" rel="bookmark">
			文心一言API使用教程（python版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：在做项目的时候需要调用文心一言，发现网上的版本很乱，基本都止步在官方文档的代码上，所以写了一篇博客来记录自己的尝试实现了对文心一言的循环调用和自定义询问，本篇文章不需要有任何对api的基础知识，代码全部成功运行，并引用官方文档，祝大家成功实现自己的调用
预置准备部分 注册百度千帆平台账户，并注册api 文心一言的使用需要注册一个百度账户，可以使用百度网盘的账户进行登录百度智能云-登录 (baidu.com)申请以后，进入文心千帆大模型操作百度智能云控制台 (baidu.com)选择右侧边栏的应用接入，再点击创建应用就可以申请一个api了创建过程中只需要填写当前api的名称以及描述，默认所有服务都是勾选的（对api的使用没有任何影响）创建成功后会返回到应用接入的界面，记录下此时AppID、API Key、Secret Key 配置api，开通服务接口 1.点击控制台右上角的计费管理开通服务
注意文心一言的api的调用是需要付费的，并且提供多个大模型可以根据自己的选择进行开通，博主只开通了 ERNIE-Bot-turbo大模型公有云在线调用服务和ERNIE-Bot大模型公有云在线调用服务，不同服务的差别可以参考API列表API列表 - 千帆大模型平台 | 百度智能云文档 (baidu.com)
python装配库 下载requsets库下载json库 程序编写部分 获取Acees Token: 需要通过Acess Token来访问文心一言，注意：access_token默认有效期30天，生产环境注意及时刷新。可参考官方文档获取access_token - 千帆大模型平台 | 百度智能云文档 (baidu.com) import requests import json def main(): # client id = API Key, client_secret = Secret Key 修改成自己的API Key 和Sercet Key client_id="4YqbzGV59w6BU3Hh1GlBsaA1" client_secret="3mM6ys4yAG5j******v" url = "https://aip.baidubce.com/oauth/2.0/token?grant_type= client_credentials &amp; client_id= 4Y****saA1 &amp; client_secret = 3mM6ys4yAG5j*****PnH0yDHlv " payload = "" headers = { 'Content-Type': 'application/json', 'Accept': 'application/json' } response = requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97d527bed06cd1442f5157f90c5da949/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf5f0a4947de51211ed777cc7b64f034/" rel="bookmark">
			Eureka（服务注册和发现）——Eureka的简介和原理 &amp; Eureka的使用和分析 &amp; 心跳续约策略，服务的下线和剔除，自我保护 &amp; Eureka集群的搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Eureka：服务注册与发现组件，用于实现服务的自动注册与发现，Spring Cloud Eureka 是对Netflix公司的Eureka的二次封装，它实现了服务治理的功能，Spring Cloud Eureka提供服务端与客户端，服务端即是Eureka服务注册中心，客户端完成微服务向Eureka服务的注册与发现。服务端和客户端均采用Java语言编写。
Eureka作为初代的服务注册和发现组件，其基本思想和原理对于后来的Nacos有深远的影响，在nacos中也能隐约看到其身影。
本篇博客介绍Eureka的简介和原理，结合实际使用阐述Eureka的使用并进行分析，此外，介绍了心跳续约策略，服务的下线和剔除以及自我保护，还有Eureka集群的搭建方式。
git代码仓库：https://gitee.com/pet365/spring-cloud-eureka
目录 前言引出Eureka初识有趣故事Eureka是啥？Eureka简介原理 Eureka使用Hello案例注册中心Eureka引入依赖eureka的配置文件配置说明： 主启动类浏览器访问查看日志 搭建生产者Provider引入依赖配置yml文件主启动类@EnableEurekaClient和@EnableDiscoveryClient区别 查看日志 搭建消费者consumer引入依赖配置等雷同在生产端提供controller在消费端调用生产者 心跳和续约策略常见概念Renew 服务续约（心跳机制）Fetch Registries 获取注册列表信息 服务的下线和剔除Cancel 服务下线Eviction 服务剔除自我保护 Eureka集群搭建1.启动第一个2.再启动一个3.访问集群4.客户端注册5.注册效果 总结 引出 1.Eureka的简介和原理；
2.结合实际使用阐述Eureka的使用并进行分析；
3.介绍了心跳续约策略，服务的下线和剔除以及自我保护；
4.Eureka集群的搭建方式，高可用；
Eureka初识 Eureka架构中的三个核心角色：
服务注册中心
Eureka的服务端应用，提供服务注册和发现功能，就是刚刚我们建立的eureka-server。
服务提供者
提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供的是Rest风格服务即可。本例中就是我们实现的spring-provider。
服务消费者
消费应用从注册中心获取服务列表，从而得知每个服务方的信息，知道去哪里调用服务方。本例中
就是我们实现的spring-consumer。
有趣故事 Eureka的故事来源于人人追求真善美的古希腊，“Eureka”是希腊语，意思是“我发现了！”
这个有魔力的单词是来源于阿基米德。在公元前200多年，他在洗澡时发现了证明王冠是否纯金的方法(黄金密度)，他激动地一边大喊“Eureka！”一边跳出澡盆奔去王宫，连衣服都忘了穿。后来人们用Eureka这个词来形容洞察浮现的瞬间。
SMS、库存、积分服务器，服务迁移变更等需要修改相应的URL地址，怎么不修改URL地址？
在微服务中，spring-provider对外提供服务，需要对外暴露自己的地址。而consumer（调用者）需要记录服务提供者的地址。将来地址出现变更，还需要及时更新。这在服务较少的时候并不觉得有什么，但是在现在日益复杂的互联网环境，一个项目肯定会拆分出十几，甚至数十个微服务。此时如果还人为管理地址，不仅开发困难，将来测试、发布上线都会非常麻烦
这就好比是 网约车出现以前，人们出门叫车只能叫出租车。一些私家车想做出租却没有资格，被称为黑车。而很多人想要约车，但是无奈出租车太少，不方便。私家车很多却不敢拦（没有人告诉哪些车私家车可以拉人），而且满大街的车，谁知道哪个才是愿意载人的。一个想要，一个愿意给，就是缺少引子，缺乏管理啊。
此时滴滴这样的网约车平台出现了，所有想载客的私家车全部到滴滴注册，记录你的车型（服务类型），身份信息（联系方式）。这样提供服务的私家车，在滴滴那里都能找到，一目了然。
此时要叫车的人，只需要打开APP，输入你的目的地，选择车型（服务类型），滴滴自动安排一个符合需求的车到你面前，为你服务，完美！
Eureka做什么？
Eureka就好比是滴滴中心，负责管理、记录服务提供者的信息。服务调用者无需自己寻找服务，而是把自己的需求告诉Eureka，然后Eureka会把符合你需求的服务告诉你。
同时，服务提供方与Eureka之间通过“心跳” 机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。
这就实现了服务的自动注册、发现、状态监控。
Eureka是啥？ Eureka简介 Spring Cloud Eureka 是对Netflix公司的Eureka的二次封装，它实现了服务治理的功能，Spring Cloud Eureka提供服务端与客户端，服务端即是Eureka服务注册中心，客户端完成微服务向Eureka服务的注册与发现。服务端和客户端均采用Java语言编写。
一个消费者和一个生产者
多个消费者与多个生产者
下图显示了Eureka Server与Eureka Client的关系
Eureka Server是服务端，负责管理各个微服务结点的信息和状态。在微服务上部署Eureka Client程序，远程访问Eureka Server将自己注册在Eureka Server。微服务需要调用另一个微服务时从Eureka Server中获取服务调用地址，进行远程调用。 原理 服务提供方启动后将注册到注册中心，提供IP, 名字，什么服务等信息，服务调用方作为客户端注册到注册中心后，拉取注册中心的服务列表，在通过负载均衡调用对应的服务提供方。注册中心可以建立集群，生成多台eureka，注册中心为了监测各个服务的心跳，将在每30S 向所注册的服务发起请求判断服务是否挂掉，如果挂掉90S后将会将服务从注册中心剔除。一个服务可以监测多台服务实例，从而可实现均衡负载。 Eureka使用Hello案例 注册中心Eureka 引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf5f0a4947de51211ed777cc7b64f034/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16c9bdb6f7e7503bc9ff4cab595c3677/" rel="bookmark">
			第十三章 DFS与BFS（保姆级教学！！超级详细的图示！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第十三章 DFS与BFS 一、深度优先搜索1、什么是DFS？2、DFS代码模板（1）问题：（2）分析：（3）模板： 3、DFS代码分析 二、广度优先搜索1、什么是BFS？2、BFS代码模板（1）问题：（2）代码： 3、BFS代码分析（1）问题1：为什么要用队列？（2）问题2：方向向量怎么用？（3）问题3：为什么最后的输出是最短路？ 一、深度优先搜索 1、什么是DFS？ DFS即Depth First Search，深度优先搜索。简单地理解为一条路走到黑。那么什么叫一条路走到黑呢？假设我们想在如下的地图中走出一条最长的路，那么最粗暴的方式就是枚举出每一种情况。
因此，按照DFS一条路走到黑的思想，我们将会出现如下路线：
先走A，然后到B，到了B有三种情况，意味着这条路还没走完，那我就接着走，从B走到E，走到E之后没路了。那我就回溯到B,为什么呢？
因为我原本走到B的时候就有三种情况，但是刚刚只走了一种情况，因此我要回到B再去尝试第二条路，于是我们就从E回到B，然后从B去F。到了F，又没路了，那我们就回到B走第三种情况，从B到G。这样我们就走完了从A-&gt;B的三种情况。又因为在A处其实还有三种情况，因此我们走完B的三种情况后，回到A,去走除了从A-&gt;B的第二种情况，即A-&gt;C。由此以往。
简而言之，就是我们一头扎进去，撞了南墙，我就退一步，但是决不放弃，在原基础上做出局部的改变去尝试第二条路，直到所有的情况我都试了，实在没有其他情况了，那我就回到A，从头出发，再做选择，再一头扎进去，直到成功。
2、DFS代码模板 （1）问题： （2）分析： 我们将其各种选择，继续画成一棵树：
这张图就清晰很多了，因此想要用DFS，我们首先要有逻辑地画出一张地图，有了地图才能去搜。
（3）模板： #include&lt;iostream&gt; using namespace std; const int N=10; int ans[N]; bool mark[N]; int n; void dfs(int u) { //"回头"的条件 if(u==n) { for(int i=0;i&lt;n;i++)cout&lt;&lt;ans[i]&lt;&lt;" "; puts(""); return; } for(int i=1;i&lt;=n;i++) { if(mark[i]==false) { mark[i]=true; ans[u]=i; dfs(u+1); //复原 mark[i]=false; ans[u]=0; } } } int main() { cin&gt;&gt;n; dfs(0); return 0; } 3、DFS代码分析 当然这个过程很抽象，那么我就帮大家模拟一下函数进行的过程吧^ _ ^（这里只模拟一部分，不理解的读者可自己模拟完。）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16c9bdb6f7e7503bc9ff4cab595c3677/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59f443737d1583da7a1cb97cb69311cd/" rel="bookmark">
			2023年（2024届）211低rank计算机保研记录（中南大数据、北邮软院、东南软院、中科院、大工软院等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.背景
2.夏令营
2.1 夏令营成果
2.2 申请汇总
2.3 参营情况
中南大数据研究院
1）申请志愿
2）通知形式
3）考核要求
4）复习准备
5）考核过程
①笔试（第一天晚上）
②宣讲（第二天上午）
③机试（第二天下午）
④面试（第三天上午）
6）后续情况
北邮软件1组
1）申请志愿
2）通知形式
3）考核要求
4）复习准备
5）面试过程
6）后续情况
浙大计算机学院暑期实习生
1）官网通知
2）系统志愿+邮件交材料
​编辑
3）后续情况
2.4 其他
中科大
关于夏令营阶段
3.预推免
3.1 预推免成果
3.2 申请汇总
3.3 复试情况
东南软院
1）官网通知
2）联系导师
3）活动安排
4）复习准备
5）面试过程
6）后续情况
中科院
软件所
信工所
计算机网络信息中心
北航
大工软院
中南
4.九推
1.背景 学校背景：211专业背景：计算机科学与技术综测排名：前五学期15/115（夏令营）、前六学期13/112（预推免）英语成绩：四级627、六级599获奖竞赛：蓝桥杯省二*2、数学建模水赛省奖*2（五一数模、华数杯）、创新创业类校赛奖项*2（互联网+、3D大赛）、英语水赛*3（IEERA、LSCAT、词汇大赛…）科研经历：约等于无，作为组长参加学校校级科研训练，但是偏项目开发，无实际科研工作，且之前在帮老师干杂活，大三下暑假才有实际产出，即夏令营阶段没有任何科研经历可以写。个人定位：想保外，华五不报期望，最想冲华科武大（我是湖北er~） 2.夏令营 2.1 夏令营成果 中南大数据研究院优营北邮软件1组面试无结果 2.2 申请汇总 地域学校学院类别结果北京人大高瓴需要推荐信未报北航计算机学院 邮件报名
可报多个院
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59f443737d1583da7a1cb97cb69311cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bca6c0a1d0bb444dcac310762b06e471/" rel="bookmark">
			Python与CAD系列基础篇（一）操作AutoCAD与读写CAD文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 0 简述1 应用2 python连接AutoCAD3 python读写CAD文件（不需要AutoCAD软件）4 结语 0 简述 对于Python与CAD进行联动而言，首要的就是建立Python与AutoCAD软件的连接以及操作CAD文件。
作为本系列文章的开篇，将介绍：①如何通过python连接到AutoCAD软件；②如何使用python进行cad文件的读写。两者的区别是①通过win32com.client或pyautocad连接AutoCAD进行处理（需要AutoCAD软件，可以操作各种CAD格式文件）②通过ezdxf处理dxf格式文件（不需要AutoCAD软件，格式较单一）。在后面基础篇文章将以这两种方式来介绍各种功能的实现。
文章的开头，简单介绍一下本系列文章可能存在的部分应用价值。
1 应用 CAD数据提取：使用Python可以将CAD文件中的几何数据提取出来，进行进一步的分析和处理。例如，可以提取出CAD文件中的点、线、圆等几何对象，并计算它们的长度、面积等属性。这对于进行CAD数据的质量控制和分析非常有用。数据可视化：Python提供了各种强大的数据可视化库，可以将CAD数据可视化展示。通过绘制图表、散点图、三维模型等，可以更直观地理解和分析CAD数据。数据处理和建模：Python在数据处理和建模方面非常强大，可以使用诸如NumPy、Pandas和Scikit-learn等库对CAD数据进行统计分析、回归分析、聚类等操作。这对于CAD数据的优化、建模和预测具有重要意义。批量处理：使用Python可以编写脚本来批量处理CAD文件，例如批量导出文件、批量修改图层、批量添加标注等。这可以极大地提高工作效率，减少重复性的任务。参数化设计：Python可以与CAD软件结合，实现参数化设计。通过定义参数和公式，可以自动调整CAD模型的尺寸、形状等属性，快速生成不同变体的设计方案。自动化生成报告：使用Python可以编写脚本来自动生成CAD设计报告。通过提取CAD数据、计算指标并生成图表，可以自动生成详细的设计报告，节省大量的手工操作时间。 2 python连接AutoCAD Python连接AutoCAD的方式有多种，介绍常见的两种方式。
①win32com.client
import win32com.client as win32 # 连接到AutoCAD应用程序 acad = win32.Dispatch("AutoCAD.Application") # 提示信息，验证是否连接成功 acad.ActiveDocument.Utility.Prompt("Hello, Autocad from Python\n") # 打开CAD文件 doc = acad.Documents.Open("test1.dwg") 效果展示：
②pyautocad
from pyautocad import Autocad acad = Autocad(create_if_not_exists=True) acad.Application.Documents.Open("test1.dwg") 3 python读写CAD文件（不需要AutoCAD软件） 目前了解到的Python第三方库中，能够不依赖AutoCAD软件直接读写dwg文件的甚少，且不稳定。通过ezdxf库来对dxf文件进行读写和处理较为方便。
import ezdxf # 读取现有CAD文件 doc = ezdxf.readfile("path_to_cad_file") # 新建文件 doc = ezdxf.new() # 保存CAD文件 doc.saveas("path_to_new_cad_file") 4 结语 后续基础篇将进一步介绍Python与CAD的基础操作方法，如创建点、线、多边形几何对象；创建文本及图案填充；图形移动与复制；图层相关；标注相关等，通过①通过win32com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bca6c0a1d0bb444dcac310762b06e471/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4a0bc65cac71683f892a99851883b8c/" rel="bookmark">
			计算机毕业答辩常见50道问题整理以及注意事项 Java Python安卓APP微信小程序asp.net项目PHP毕业设计500个热门选题推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、答辩时的流程介绍
二、答辩常见问题
1、项目使用的技术
2、项目开发中遇到什么问题，是怎么解决的分享一下
3、你觉得你的这个系统有什么比较新颖的地方？技术或功能点都可以。
4、你的这个图形统计报表是如何进行实现的？
5、请您介绍一下XX模块的基本业务流程，讲解一下相关代码。
6、项目某个功能（如登陆、注册、查询等功能）数据流程是怎样的 ？
7、你介绍一下你项目中所用到的各个表以及他们之间的业务关联。
8、数据库用的什么数据库，该数据库有什么特点？
9、有购物车功能的同学，购物车怎么实现的
10、MVC设计模式是指什么，其优缺点，怎样用到在你的程序里
11、SSM/SSH框架是指什么，其优缺点，怎样用到在你的程序里
12、检索功能支持模糊查询吗？怎么实现的？
13、你是怎么实现后台与数据库连接的，能看看你的代码吗?
14、你能说说varchar 和 char 的区别吗？
15、你系统中用到了什么算法，请说一下？
16、你的系统的安全性是如何保障的？
17、你觉得你的课题那些地方还需要改进？
18、基本知识普及B/S结构与CS架构
19、数据库的设计分为哪几步？
20、解释ER图并说明它的作用。
21、实体之间联系的类型有几种？详细解释他们的含义。
22、说说你在设计数据库表时是如何考虑的？
23、论文是你写的吗？程序是你设计的吗？
24、Java项目类型划分、以及代码分层
三、总结
1、项目准备：
2、论文观看：
3、技术查看：
4、核心模块：
5、答辩PPT：
6、对回答不出的问题，不可强辩。
一、答辩时的流程介绍 1、开场⽩ 这时主要介绍㇐下你是谁，是什么专业，你的指导⽼师是谁，你论⽂的题⽬是什么。 参考： 尊敬的评委⽼师：⼤家早上好，我是XX级XX专业的XX,我的知道老师是XX,毕业设计题目是XX,希望今天能为我的学⽣⽣涯画上㇐个完满的句号。 2、项目功能演示以及PPT解说 本部分主要是演示项目的主要功能以及使用的技术，演示时间控制在5-10分钟之间，介绍某个功能的时候可以提及该功能使用的相关技术，避免干巴巴的介绍，项目中的亮点可以重点介绍。 项目演示过程中保证项目可以正常使用（答辩前项目运行好），没有明显的漏洞（比如登录不上、出现空指针异常、页面出现404错误），功能逻辑合理（不需要很商业化）， 防止项目答辩演示的时候项目出问题，可以提前录制好视频，最好带功能解说； 3、结束语 这部分可以说㇐下⾃⼰项目中的特色以及不足之处，以及⾃⼰在论⽂写作及修改过程中的㇐些感悟，⽐如感觉到⾃⼰知识的缺乏呀，如此相关的。最后，请给位⽼师多批评指正，⾃⼰以后会继续学习等等。 4、评委提问 提问应该是论⽂答辩必不可少的㇐个环节。当⽼师提问时，如果⼿边有纸和笔，可以对关键词进⾏㇐下记录，这样有助于我们记录和减压。如果对问题不太清楚，可以请⽼师做㇐个解释，不能不懂装懂，东拉西扯。 5、评委点评 在⽼师点评时，要认真听取⽼师的点评，深思⽼师⽼师提出的意见和建议，总结论⽂写作的经验和教训。 二、答辩常见问题 1、项目使用的技术 答： 例如： 前端使用XX(css、javascript、jQuery、Vue框架、 AngularJS、React、 Layui框架、Bootstrap等) 后台使用了XX（java语言-Springboot|SSM|javaweb技术 、Python、.net） 数据库使用的是XX（Mysql数据库、Sql Server、Redis） 每个技术在项目中的使用要有基本认识 项目类型：网站|系统、小程序、App 2、项目开发中遇到什么问题，是怎么解决的分享一下 1）数据库链接问题 账号密码不对或者是数据库驱动与数据库服务器版本不一直导致项目发布异常 2）浏览器缓存问题，图片文字改了，但是在浏览器不显示 不要使用eclipse内置的浏览器访问，应该用外置浏览器比如谷歌并且清理浏览器的缓存可以 按住 ctrl+shift+delete键清理浏览器缓存，同时要重新发布项目就好了 3）中文乱码问题 ①数据库中的数据出现了中文乱码问题 这两个地方的值 latin1 改成 utf8 然后重启mysql数据库服务器 之前创建的数据库删掉 drop dababase '需要删除的数据库' ②代码的中文出现中文乱码-改下开发工具工作空间编码 Window——preferences——General——Workspace最下面字符编码为utf-8 如果是utf-8，就改成gbk 改完后，要重新运行项目 ③工作空间编码和数据库安装都是正常 但是发送到数据库中的中文还是出现乱码 找到数据库链接的url地址 看下是否有 characterEncoding=utf-8 ④小程序真机访问出现接口异常
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4a0bc65cac71683f892a99851883b8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c76b0b10d82e93ceb714bed3fa770cde/" rel="bookmark">
			如何在Mac中编辑hosts文件配置访问地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、桌面左上角点击访达 --&gt; 然后点击偏好设置 :
会出现以下界面，勾选显示所有文件扩展名：
2、然后点击（我是用触控板双指一起按出现的，鼠标的话是左键点中访达图标后，按住不动）访达图标选择前往文件夹：
3、会弹出一个窗口，让你输入文件夹的路径。因为hosts文件在/etc目录下，所以输入/etc/，然后点击前往：
4、选择hosts文件打开
5、但是当你编辑时，会提示我们没有权限，询问是否复制。
6、于是点击复制按钮，会生成一个新窗口，在里面进行编辑
7、编辑完成后，保存到桌面，会生成一个hosts副本.txt
8、点击重命名将名称改为hosts并去掉txt后缀，会弹窗口询问你是否移除后缀，点击移除即可。
9、最后将修改后的hosts直接替换掉原本的hosts，完成✅。
10、最后打开你刚刚输入的地址就可以政策访问啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/323ca20369a10133a45414342107dbd4/" rel="bookmark">
			Open JDK Windows下载安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文涉及的开发环境：
操作系统：Windows 10JDK版本：JDK17 介绍 OpenJDK（Open Java Development Kit）是一个开源的Java开发工具包，由Oracle公司主导开发并发布。它包含了Java编译器（javac）、Java虚拟机（JVM）、Java运行时环境（JRE）等组件。
Oracle JDK（Java Development Kit）是由Oracle公司开发和维护的Java开发工具包。它基于OpenJDK代码库，并添加了一些专有的功能和工具，如JavaFX图形用户界面库、Java Flight Recorder性能分析工具等。
正文 一、下载Open JDK17 链接：https://jdk.java.net/java-se-ri/17
根据需要选择版本下载（下载后是一个压缩包，解压到一个目录当中，温馨提示：身为程序员，不要解压到有中文路径的目录中了）
二、配置环境变量 为了防止有人还找不到设置环境变量的位置：此电脑=》右键=》属性=》高级系统设置=》环境变量
都来安装Open JDK了应该都能找到了吧
设置JAVA_HOME，变量值为Open JDK解压目录
新建CLASS_PATH变量，并设置变量值 CLASS_PATH %Java_Home%\bin;%Java_Home%\lib\dt.jar;%Java_Home%\lib\tools.jar; 编辑系统变量path，添加两个值 %JAVA_HOME%\bin %JAVA_HOME%\jre\bin 三、检查是否安装成功 java -version
写在后面 Windows 10安装Open JDK17全文完，希望对你有所帮助。
欢迎指正
2023/10/07 sm76，发布于北京
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a8021c8bad5bbca43eb70a5df871876/" rel="bookmark">
			mac怎么卸载软件没有叉的那种，别慌看这里
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ac电脑对于很多人来说是一个高效、优雅的工作工具，但就像所有电子设备一样，有时候也需要进行软件的添加和删除以保持其最佳性能。然而，对于一些特殊类型的软件—也就是那些没有"叉"标志来直接卸载的—如何正确地从Mac上删除它们呢？对于这一疑问，本文将为您提供详尽的解答和步骤。
mac怎么卸载软件没有叉的那种
一、为何有些软件没有"叉"
在解决问题之前，让我们先了解为何会有这样的软件存在。一般来说，没有“叉”的软件通常是因为它们需要更深层次的系统访问，或者是因为设计者希望用户不要轻易卸载它们。这类软件可能包括一些系统级别的工具或者安全软件。
软件
二、mac怎么卸载软件没有叉的那种
1、手动删除方法
前往“应用程序”文件夹：双击“应用程序”文件夹，找到你想要卸载的软件。
打开“信息”面板：右击目标软件图标，选择“显示简介”。
查找并删除相关文件：在“信息”面板中，找到软件的安装路径，然后前往该路径手动删除所有相关文件和文件夹。
清空回收站：将这些文件移到回收站后，记得清空回收站以彻底删除它们。
2、使用终端命令
另一种方法是使用Mac的终端（Terminal）来执行卸载。输入特定的命令可以帮助您找到并删除软件及其所有相关文件。具体步骤如下：
打开终端：您可以通过搜索或者在“实用工具”文件夹中找到“终端”。
输入命令：在终端窗口中输入相关命令（例如，sudo rm-rf/应用程序/目标软件）来删除软件。
输入密码：执行命令后，系统可能会要求您输入密码以确认操作。
注意：使用终端命令进行软件卸载是一种高风险操作，请确保您明确知道自己在做什么。
3、第三方卸载工具
除了以上两种方法，您还可以使用第三方的卸载工具来帮助您更方便地卸载没有“叉”的软件。在这里，我们强烈推荐使用CleanMyMac这款软件。CleanMyMac不仅提供用户友好的界面，还能彻底扫描并删除软件的所有相关文件，确保软件被完全卸载，无残留。其操作简单明了，是一个非常值得信赖的卸载工具。
CleanMyMac X 4.13.4下载地址：https://souurl.cn/jEUxB8
如果您感觉文章不错可以给小编进行点赞收藏分享呦，如果有问题也可以在评论区进行留言，小编会第一时间帮您解决！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32d76c98a78aeac0c6c34d9a656c7de2/" rel="bookmark">
			【算法与数据结构】归并排序的代码实现（详细图解）以及master公式的讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、归并排序
1.1、算法描述
1.2、图解说明
2、代码实现 3、master公式
3.1、公式以及结论
3.2、适用于某些特殊的递归
3.3、计算归并排序的时间复杂度
1、归并排序 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用递归或者说是分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。
若将两个有序表合并成一个有序表，称为二路归并。
1.1、算法描述 把长度为n的输入序列分成两个长度为n/2的子序列；对这两个子序列分别采用归并排序；将两个排序好的子序列合并成一个最终的排序序列。 而将两个的有序数列合并成一个有序数列，我们称之为"归并"，这就是归并排序名字的由来。
1.2、图解说明 一句话简单说：对L到R范围排序，可以先求出L到R的中点M。先让左侧数据排好序，然后再让右侧数据排好序，此时再将两个有序子序列整合成一个新的有序序列。
​
例如：
对一个数组[8,3,6,4,2,1,5,7]进行归并排序。
第一步：把长度为n的输入序列分成两个长度为n/2的子序列，新的子序列再分别分成两个长度为自身一半也就是n/4的子序列，以此类推。当分到单个子序列只剩下一个数字时，一个数字就是天然了有序，即此时左侧和右侧都排好序了。
​
第二步：将两个排序好的子序列合并成一个新的排序序列。首先在每个子序列中都有一个指针指向子序列的第一个元素，两个指针的元素两两比较，较小的元素先放入新的子序列中，然后指针挪动继续比较，直至全部放入新的子序列当中，即完成一次子序列合并。慢慢合并最终使所有元素都成有序，即完成归并排序。
​
这个思路过程是非常精髓的，理解了这个思路之后，就可以试着用代码实现了。
2、代码实现 要使用归并，首先需要知道数组arr以及数组最左L下标和最右R下标，因此需要求出并带入MergeSort当中。
int main() { int arr[10] = { 8,3,6,4,2,1,5,7 }; int sz = sizeof(arr) / sizeof(arr[0]); MergeSort(arr, 0, sz - 1); int i = 0; for ( i = 0; i &lt; sz; i++) { printf("%d ", arr[i]); } return 0; } 接下来看看MergeSort的实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32d76c98a78aeac0c6c34d9a656c7de2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76f4e293c63d73951b548e04df42b68e/" rel="bookmark">
			网络爬虫——urllib（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言🍭 ❤️❤️❤️网络爬虫专栏更新中，各位大佬觉得写得不错，支持一下，感谢了！❤️❤️❤️
前篇简单介绍了什么是网络爬虫及相关概念，这篇开始讲解爬虫中的第一个库——urllib。
urllib🍭 urllib是Python标准库中的一个模块，提供了一些用于处理URL的功能。
使用urllib可以进行URL的解析、发送HTTP请求、文件下载等操作。
1、urllib的基本使用🍉 使用urIlib来获取百度首页的源码🍓 # 使用urI1ib来获取百度首页的源码 import urllib.request # (1)定义一个urI 赢是你要访问的地址 url = 'http://www.baidu.com/' # (2)模拟浏微器向服务器发达求 response阿应 response = urllib.request.urlopen(url) # (3)获取响应中的页面的源码 (content 内容意思) # read方法 返回的是字节形式的二进制数据 content = response.read() # (4)打印数据 print(content) 打印结果：
b'&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html;charset=utf-8"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt;&lt;meta content="always" name="referrer"&gt;&lt;meta name="theme-color" content="#ffffff"&gt;&lt;meta name="description" content="\xe5\x85\xa8\xe7\x90\x83\xe9\xa2\x86\xe5\x85\x88\xe7\x9a\x84\xe4\xb8\xad\xe6\x96\x87\xe6\x90\x9c\xe7\xb4\xa2\xe5\xbc\x95\xe6\x93\x8e\xe3\x80\x81\xe8\x87\xb4\xe5\x8a\x9b\xe4\xba\x8e\xe8\xae\xa9\xe7\xbd\x91\xe6\xb0\x91\xe6\x9b\xb4\xe4\xbe\xbf\xe6\x8d\xb7\xe5\x9c\xb0\xe8\x8e\xb7\xe5\x8f\x96\xe4\xbf\xa1\xe6\x81\xaf\xef\xbc\x8c\xe6\x89\xbe\xe5\x88\xb0\xe6\x89\x80\xe6\xb1\x82\xe3\x80\x82\xe7\x99\xbe\xe5\xba\xa6\xe8\xb6\x85\xe8\xbf\x87\xe5\x8d\x83\xe4\xba\xbf\xe7\x9a\x84\xe4\xb8\xad\xe6\x96\x87\xe7\xbd\x91\xe9\xa1\xb5\xe6\x95\xb0\xe6\x8d\xae\xe5\xba\x93\xef\xbc\x8c\xe5\x8f\xaf\xe4\xbb\xa5\xe7\x9e\xac\xe9\x97\xb4\xe6\x89\xbe\xe5\x88\xb0\xe7\x9b\xb8\xe5\x85\xb3\xe7\x9a\x84\xe6\x90\x9c\xe7\xb4\xa2\xe7\xbb\x93\xe6\x9e\x9c\xe3\x80\x82"&gt;&lt;link rel="shortcut icon" href="https://www.baidu.com/favicon.ico" type="image/x-icon" /&gt;&lt;link rel="search" type="application/opensearchdescription+xml" href="/content-search.xml" title="\xe7\x99\xbe\xe5\xba\xa6\xe6\x90\x9c\xe7\xb4\xa2" /&gt;&lt;link rel="icon" sizes="any" mask href="https://www.baidu.com/favicon.ico"&gt;&lt;link rel="dns-prefetch" href="//dss0.bdstatic.com"/&gt;&lt;link rel="dns-prefetch" href="//dss1.bdstatic.com"/&gt;&lt;link rel="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76f4e293c63d73951b548e04df42b68e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b5ff3c4db4a4c027801ed7aae8b857d/" rel="bookmark">
			简单讲讲在一台机器上用docker部署hadoop HDFS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么写这篇文章? 老东西叫我用vmvare部署hadoop,我觉得这简直蠢毙了,让我们用docker和docker-compose来快速的过一遍如何使用docker-compose来部署简单的hadoop集群范例
写在前面,一定要看我!!! windows。。。看着用吧
hadoop版本不同改下Dockerfile中的内容，具体来说是这里-3.3.6改成你的版本比如3.1.3
还有注意！Hadoop中的主机名不能带-或者_
注意了!一定注意存储空间大小,确保机器至少有10G左右的空余,不然跑不起来的
如果出现如下问题,请调整docker-compose文件中分给容器的容量,然后删除并重建容器:
$ hdfs namenode
WARNING: /export/server/hadoop/logs does not exist. Creating.
mkdir: cannot create directory '/export/server/hadoop/logs': No space left on device
ERROR: Unable to create /export/server/hadoop/logs. Aborting.
Hadoop HDFS 简摘 Hadoop HDFS需要三个角色:
NameNode,主节点管理者DateNode,从节点工作者SecondaryNameNode,主节点辅助 我们需要三个容器:
暂且称之为
masternode,slavenode1,slavenode2
这三个容器扮演的角色分别是 masternode:NameNode,DateNode,SecondaryNameNodeslavenode1:DateNodeslavenode2: DateNode 使用脚本跳过所有的前置工作（假设你已经对Hadoop有了解） 注意！建立在你会的基础上，不会的话看着脚本敲命令
克隆项目后确保目录如：
git clone https://github.com/rn-consider/Hadoop_docker.git
然后确保使用docker-compose up -d 创建的容器也可以运行
给所有sh脚本附加执行权限，然后运行./一键式部署请确保已经下载了hadoop压缩包.sh，然后等待脚本执行完成像是：
，完成后直接跳转到运行hadoop章节
前置工作 我们需要三个docker容器来实现masternode,slavenode1,slavenode2,它们需要一些基本的配置,比如说固定的Ip,ssh的安装,jdk8的安装等,所幸我们可以使用docker-compose来大大简化这些基本的配置工作,新建一目录假设命名为hadoop_t,然后按照以下命令,(注意!因为我们使用的是docker所以只需要按照我的步骤来且docker,docker-compose版本号满足要求,那么环境配置必然会成功)
git clone https://github.com/rn-consider/Hadoop_docker.git 项目结构应该如,其中hadoop压缩包也可从官方获得,或者使用RumMeFirst下载在项目结构如下时在往下阅读:确保机器上docker版本大于等于20.10.25,docker-compose版本大于等于2.20.3,不清楚docker-compose二进制安装方式可以看为Linux安装软件包时后面标注的arm,aarch到底是什么玩意儿以二进制安装docker-compose为例_生生世世是所说的的博客-CSDN博客运行docker-compose up -d 后运行docker ps可以看到:接下来我们所有的环境设置都将在这三个容器中进行 环境配置 基本配置 主机名以及IP地址映射 docker-compose会自动创建docker网络和dns映射让各个容器可以通过容器的服务名来访问各自的容器,我们可以愉快的跳过这个配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b5ff3c4db4a4c027801ed7aae8b857d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d90472bd4c77dc8f915a7e12fbcaa7a/" rel="bookmark">
			this指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、关于this指针的一个经典问题
二、this指针的特点
（一）本质
（二）应用
1. 不使用this指针
2. 使用this指针
3. 两者代码对比
三、代码举例
1. 举例1 2. 举例2
一、关于this指针的一个经典问题 当你进入一个房子后， 你可以看见桌子、椅子、地板等， 但是房子你是看不到全貌了。 对于一个类的实例来说， 你可以看到它的成员函数、成员变量， 但是实例本身呢？ this是一个指针，它时时刻刻指向你这个实例本身
二、this指针的特点 this指针的类型：类类型* const，即成员函数中，不能给this指针赋值只能在“成员函数”的内部使用 this指针本质上是“成员函数”的形参，当对象调用成员函数时，将对象地址作为实参传递给this形参。所以对象中不存储this指针 this指针是“成员函数”第一个隐含的指针形参，通常this指针在系统中是隐含存在的，也可以把它显式表示出来 非静态成员函数中可以直接使用this来代表指向该函数作用对象的指针，静态成员函数中不能使用this指针，因为静态成员函数并不具体作用与某个对象，因此，静态成员函数真实的参数的个数，就是程序中写出的参数个数 （一）本质 （二）应用 1. 不使用this指针 #include&lt;iostream&gt; using namespace std; class A { private: int i; public: void set(int x) { i = x; } int get() { return i; } }; int main() { A a; a.set(9); cout &lt;&lt; a.get() &lt;&lt; endl; return 0; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d90472bd4c77dc8f915a7e12fbcaa7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/451ef7bc2f6893fd932a856719fea5d0/" rel="bookmark">
			Linux配置hadoop文件报错 ERROR: JAVA_HOME is not set and could not be found（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、hadoop配置文件的一些报错情况
1、ERROR: JAVA_HOME is not set and could not be found
（1）查看我们的jdk所在的位置 代码：pwd
（2）进入配置环境
（3）最重要的事情！！记得更新环境变量 （4）查看java版本
（5）最后再去运行就好了
2、ERROR: JAVA HOME /cpt/jieya/jdk does not exist .
（1）注意：
（2）进入hadoop的配置文件
（3）修改jdk地址
（4）最后再去运行就好了
3、网页无法加载
（1）解决办法1：
（2）解决办法2：
4、与此同时，我们又遇到了另一个问题
一、hadoop配置文件的一些报错情况 1、ERROR: JAVA_HOME is not set and could not be found 答：首先这种情况应该是JAVA_HOME配置环境的时候出了问题
（1）查看我们的jdk所在的位置 代码：pwd （2）进入配置环境 vi /etc/profile（如果vi 不行那就用vim /etc/profile ，这个的区别在于你虚拟机使用的图形界面创建和纯命令界面创建） 把刚才的地址复制过来，如果担心用键盘会出错，可以直接选中鼠标右键复制/粘贴
图形界面：
纯命令界面：
进入不可直接编辑，按键盘 i 可编辑
保存时按键盘的 Esc键 输入 ：wq 回车即可退出
（3）最重要的事情！！记得更新环境变量 source /etc/profile （或者. /etc/profile 注意：点.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/451ef7bc2f6893fd932a856719fea5d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7631ec0b22da6e0b5723088c26dde59/" rel="bookmark">
			csp初赛总结 &amp; 那些年编程走过的坑 &amp; 初高中信竞常考语法算法点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😘个人主页：@曲终酣兴晚的小书屋💖
😕作者介绍：一个莽莽撞撞的🐻
💖专栏介绍：日常生活&amp;往事回忆
😶‍🌫️每日金句：祝大家心有山水不造作，静而不争远是非，且听且忘且随风，且行且看且从容.
祝大家千山暮雪，海棠依旧，不畏岁月惊扰，平添忧愁.
本专栏的每篇不求刻意📖，不求刻意👍，😍就好.
又是一年竞赛时，今年是第三年参加信奥的比赛，可以说，除了第一年的奖状，去，今两年相当于陪跑了，相当的不甘，但是无奈已经初一，初二不出成绩，初三无论如何也不能再打了，今年的分数线虽然还没有出，但是以往年的分数线来看，我的分大抵是不可能了，心里挺失落的，写篇博客好好反思总结一下.
今年的错误主要是分为两点：第一点是我是先从16年的真题倒着先往前刷的，因为19年以后的题是和以前的题目不一样，一是改变了形式，二是后面程序阅读的大题难度大大增加，21年考的时候我就觉得我的阅读程序不好，需要多练，可是做完16年的题以后觉得并不是很难（因为改版之前的程序阅读和填空是较简单的），当时的我天真的以为是我的水平提高了，做这些题没难度了，所以就放松了警惕，把精力重点放在了前十五道题，但是前十五道题最多也只能拿到30分，最后的5道大题是有足足70分的，后来刷到19年以后的题我才盘然醒悟，用最后的20天紧急冲刺大题，是从一开始的大题18分提到了大题40分，这时候我的22年真题是做到了64的分数，距离22年的线还有4分，记得临近考试的前一天晚上用了1晚上的时间来整理了错题，第二天来考试；
说说考试那天吧，因为具体哪些题错了我还未可知，但是我知道前面15道题错了4道，失去了8分，有两道是知道知识点但是就是推不出四个答案中的任意一个，当时把他们压到了最后做，就有点慌，中间因为疏忽想错了一个点，使得原本可以拿到的两分直接没了，有点后悔，但是为时已晚。后面的大题整体做的情况我还不太知道，但是今天的大题出的比较仁慈，有三道是可以爆算，有两道一道考了贪心+dp，最后一道程序填空的大题考的是哈夫曼树的dp算法，我没学，是整个一道全是蒙的，我觉得哈夫曼树应该跟最短路径有点相似，看着部分代码也很眼熟，遂是使用了最短路的思想去蒙的，索性，应该对了三个空，剩下的大题中有一问考了文字游戏，那个弯我没绕过来，扣了3分。。
那些年，编程走过的坑 现在的编程越来越卷，许多4,5年级的小朋友就开始学习，我也是从5年级开始了编程之路，6年级拿到小学组二等奖，那个时候的还是很好考的。
学数据结构觉得还是挺轻松的，和语法一起学，并没有觉得太困难，后面学算法是彻底让我头秃，我的困难点是理论全会，代码全费，拿过一道题没有什么太好的思路，只能是一步步模拟，或者是根据经验照着算法模板照葫芦画瓢。。这个东西我觉得还是要深入理解的，首先编程这个东西是想联通的，可能一个题会运用到多种算法，一个算法不会，整个题可能就会崩，在学图论的时候，我当时的链式前向星的没理解就对我造成了很大的困扰，后面也是写了篇博客理了理思路才想通顺了。
编程可能不需要天赋，但是编程的高等竞赛是需要天赋的。
以前不需要内卷，但是现在的比赛是一定需要内卷的，从初赛-复赛，从头卷到尾。。
在这么卷的环境，我们唯一能做的就是让自己更卷，必须紧跟潮流。
这不是鸡汤，只是你不这么做你以后可能都没有工作。为什么很多人会选择去那种北欧地方？因为那地方卷的不是那么厉害呀，不是说逃避，就是说想要在一个相对安稳的环境生活一辈子吧，我希望我以后也能那样，不想这么卷，而且中国的有些思想我是挺为厌倦的，不想继续这么活一辈子，，
今年普及组的考点 前十五道题考了3道数学，一道前缀中缀后缀表达式，一道前中后序遍历，一道哈弗曼编码，剩下的就是一点计算机基础或者别的东西。其中那道前中后序遍历我是推了三四遍没有推出来结果的，最后成功蒙错，一道数学的排列组合我最后想出了方法但是慌了，遗憾写错了。
哦，还有一道三叉树的新型题，也是慌了，忘记+1，扣了2分。。
后面有两道可以直接模拟的，数据也很小，一道dp，一个查找升序子序列的哪个序列不是一直升序了，但是他没用一个for直接粗暴考你，用的是二分查找，很恶心，最后一道是哈夫曼树的dp，，
就讲这么多吧，困了，写完学校作业来写篇博客总结，现在主攻学业了，明年想直接打提高组，普及组太卷了，，下篇具体讲解题目和语法点，后续把所有初赛笔记免费发到资源里，帮助每个初小学生来考普及，祝有天赋的哥哥姐姐弟弟妹妹们信奥加油！
10.21过了初赛的大佬们加油！后续成绩可以打在评论区让我被卷死
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fb70e5a633145da15f2f642b86d08d5/" rel="bookmark">
			在SQL中，可以使用不同的函数来转换字符串日期格式。以下是一些常用的函数：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. STR_TO_DATE(): 将字符串转换为日期格式。它接受两个参数：要转换的字符串和日期格式。 示例：
SELECT STR_TO_DATE('2023-07-04', '%Y-%m-%d') AS converted_date; 这将把字符串 ‘2023-07-04’ 转换为日期格式，并返回结果作为 converted_date。
2. CAST(): 将字符串转换为日期格式。它接受两个参数：要转换的字符串和目标数据类型。 示例：
SELECT CAST('2023-07-04' AS DATE) AS converted_date; 这将把字符串 ‘2023-07-04’ 转换为日期格式，并返回结果作为 converted_date。
3. CONVERT(): 将字符串转换为日期格式。它接受三个参数：要转换的字符串、目标数据类型和可选的样式参数。 示例：
SELECT CONVERT('2023-07-04', DATE) AS converted_date; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9359c01556ec5cc9f01ff67749964a07/" rel="bookmark">
			【Java】快速排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、什么是快速排序二、基准元素的选择1、选择第一个元素2、随机选择 三、元素的交换1、双边循环法2、单边循环法 一、什么是快速排序 快速排序是由冒泡排序演变而来，比冒泡排序更快的排序算法。之所以快，是因为快速排序用了分治法。
相同的是，与冒泡排序一样，快速排序也属于交换排序，通过元素之间的比较和交换来排序。
不同的是，冒泡排序每一轮只把一个元素冒泡到数列的一端，而快速排序每轮挑选一个基准元素，让比它小的元素移动到一端，让比它大的元素移动到另一端，从而把数列拆解成两个部分。
这种每次将数列分为两个部分的方法就叫做分治法。
分治法的好处体现在相比于冒泡排序它会有更小的时间复杂度，对于n的元素的冒泡排序时间复杂度为O(n2),而快速排序总体的平均时间复杂度为O(nlogn)。
二、基准元素的选择 在使用分治法的过程中以基准元素为中心把其他元素移到它的两边，那么如何选择基准元素呢？
1、选择第一个元素 最简单的方法是直接选择数列第一个元素为基准元素，但是这种方法在有些特殊情况下会出现问题：
对于这种原本是逆序的数列，每轮都只能确定基准元素的位置，这种情况下快速排序需要进行n轮，时间复杂度退化到了O(n2)。
2、随机选择 为了解决时间复杂度过大的情况，我们可以随机选择一个元素，并与首位元素互换位置，虽然这种情况下也有几率选到数列的最大或最小值，但大多情况下都是可以的。
所以，虽然快速排序的平均时间复杂度为O(nlogn)，但最坏情况下也可以达到O(n2)。
三、元素的交换 选好了基准元素，就要将其他元素移到基准元素两边，具体实现有两种方法：
双边循环法单边循环法 1、双边循环法 对以下数列按从小到大进行排序：
首先，选定基准元素p，并设置左右两个指针 l 和 r
开始循环后，从r指针开始，让r指针元素与基准元素做比较，如果大于等于p，则r指针向左移动；如果小于p，则停止移动，换到l指针。
对于当前数列，r指针元素为1，1&lt;4，所以r指针停止移动，换到l指针。
换到l指针后，让l指针元素与基准元素做比较，如果小于等于p，则l指针向右移动；如果大于p，则停止移动。
按照此思路，后续步骤如下：
实现代码如下：
import java.util.Arrays; public class quickSort { public static void quickSort(int arr[],int startIndex,int endIndex){ //递归结束条件为startIndex大于或等于endIndex if(startIndex&gt;=endIndex){ return; } //得到基准元素位置 int pIndex=partition(arr,startIndex,endIndex); //根据基准元素分两部分进行递归排序 quickSort(arr,startIndex,pIndex-1); quickSort(arr,pIndex+1,endIndex); } /* * 分治法（双边循环法） * arr 待排序数组 * startIndex 起始下标 * endIndex 结束下标 * */ public static int partition(int arr[],int startIndex,int endIndex) { int p=arr[startIndex];//基准元素(可取随机位置) int l=startIndex;//左指针 int r=endIndex;//右指针 while(l!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9359c01556ec5cc9f01ff67749964a07/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/62/">«</a>
	<span class="pagination__item pagination__item--current">63/71</span>
	<a class="pagination__item pagination__item--next btn" href="/page/64/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>