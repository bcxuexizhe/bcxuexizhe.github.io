<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.126.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程学习者的博客">
		<meta property="og:url" content="https://bcxuexizhe.github.io/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="编程学习者">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db7ba364c4917716c2b333a984b6f562/" rel="bookmark">
			Spring Boot 3.0：未来企业应用开发的基石
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Spring Boot 3.0的核心特性二、Spring Boot 3.0的优势三、如何在项目中应用Spring Boot 3.01.更新项目依赖2.调整代码结构3.测试和部署 《学习Spring Boot 3.0》内容简介作者简介目录内容介绍 随着技术的飞速发展，企业应用开发的需求也在不断演变。Spring Boot，作为Java生态系统中一颗璀璨的明星，一直以其易用性、高效性和灵活性受到开发者的青睐。而Spring Boot 3.0的发布，更是为企业应用开发带来了新的机遇和挑战。
一、Spring Boot 3.0的核心特性 更强大的自动化配置：Spring Boot 3.0进一步增强了自动化配置能力，减少了开发者在配置方面的工作量。通过智能分析项目的依赖关系，Spring Boot 3.0能够自动配置更多的组件和库，使开发者能够更专注于业务逻辑的实现。
原生支持GraalVM和Quarkus：Spring Boot 3.0原生支持GraalVM和Quarkus，这使得Java应用能够拥有接近甚至超越C/C++应用的启动速度和运行性能。这一特性对于构建高性能、低延迟的微服务应用具有重要意义。
增强的安全性和合规性：Spring Boot 3.0加强了应用的安全性和合规性。它提供了更多的安全配置选项，如加密、认证和授权等，以确保应用的数据安全和隐私保护。此外，Spring Boot 3.0还支持多种安全标准和协议，如OAuth 2.0、OpenID Connect等，以满足不同行业和场景的安全需求。
改进的监控和诊断能力：Spring Boot 3.0在监控和诊断方面进行了大量改进。它提供了更丰富的监控指标和诊断工具，帮助开发者更好地了解应用的运行状态和性能瓶颈。此外，Spring Boot 3.0还支持与第三方监控系统的集成，如Prometheus、Grafana等，以实现更全面的监控和诊断。
二、Spring Boot 3.0的优势 提高开发效率：通过强大的自动化配置和简化的依赖管理，Spring Boot 3.0能够大大提高开发效率。开发者可以更快地构建和部署应用，减少在配置和调试方面的时间投入。降低运维成本：Spring Boot 3.0的原生支持GraalVM和Quarkus等高性能运行时环境，使得应用具有更高的运行效率和更低的资源占用。这有助于降低运维成本，提高系统的可扩展性和稳定性。增强应用安全性：Spring Boot 3.0提供了丰富的安全配置选项和支持多种安全标准和协议，能够确保应用的数据安全和隐私保护。这有助于降低因安全漏洞而带来的风险和损失。提高应用性能：通过优化代码生成和运行时环境，Spring Boot 3.0能够显著提升应用的启动速度和运行性能。这使得应用能够更快地响应请求和处理数据，提高用户体验和业务效率。 三、如何在项目中应用Spring Boot 3.0 要在项目中应用Spring Boot 3.0，需要遵循以下步骤：
1.更新项目依赖 将项目的Spring Boot版本更新为3.0，并更新相关的依赖库和插件。
迁移配置文件：根据Spring Boot 3.0的配置要求，迁移和更新项目的配置文件（如application.properties或application.yml）。
2.调整代码结构 根据Spring Boot 3.0的API变化和最佳实践，调整和优化项目的代码结构。
3.测试和部署 在本地环境中测试应用的功能和性能，确保没有问题后将其部署到生产环境中。
通过遵循以上步骤，可以将Spring Boot 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db7ba364c4917716c2b333a984b6f562/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f912dada0bdfe4705ad7bee27582485/" rel="bookmark">
			Android 项目中自定义多个 RadioButton 并排一列选择效果实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、静态版实现1.1、实现要求1.2、实现步骤1.3、代码实现1.4、代码实现说明1.5、结论 2、项目版实现(动态)1、先看效果图2、main的布局文件3、定义RadioButton的属性4、最后在代码中生成我想要的东东5、说明 3、后续优化方向 1、静态版实现 1.1、实现要求 我们需要在Android中创建多个RadioButton并排成一行，且能够左右滑动。我们将使用HorizontalScrollView来实现左右滑动的功能，并在其内部放置一个RadioGroup来排列RadioButton。
1.2、实现步骤 1、创建布局文件：在res/layout文件夹下创建一个XML布局文件。
2、在布局文件中使用HorizontalScrollView和RadioGroup：在HorizontalScrollView中包含一个RadioGroup，并在其中添加多个RadioButton。
3、在Activity中加载布局：设置Activity的布局文件，并在代码中处理RadioButton的逻辑（如果需要）。
4、运行效果：展示代码的运行结果。
1.3、代码实现 1、 布局文件（XML）
在res/layout文件夹中创建一个名为activity_main.xml的布局文件，内容如下：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:padding="16dp"&gt; &lt;HorizontalScrollView android:layout_width="match_parent" android:layout_height="wrap_content" android:scrollbars="none"&gt; &lt;RadioGroup android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;RadioButton android:id="@+id/radioButton1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Option 1" /&gt; &lt;RadioButton android:id="@+id/radioButton2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Option 2" /&gt; &lt;RadioButton android:id="@+id/radioButton3" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Option 3" /&gt; &lt;RadioButton android:id="@+id/radioButton4" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Option 4" /&gt; &lt;RadioButton android:id="@+id/radioButton5" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Option 5" /&gt; &lt;!-- 可以继续添加更多的 RadioButton --&gt; &lt;/RadioGroup&gt; &lt;/HorizontalScrollView&gt; &lt;/LinearLayout&gt; 2、Activity文件（Java）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f912dada0bdfe4705ad7bee27582485/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa66ca1275e089ccda3363632876fc16/" rel="bookmark">
			【数据结构】排序详解（希尔排序，快速排序，堆排序，插入排序，选择排序，冒泡排序）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
0. 前情提醒：
1. 插入排序
1.1 基本思想：
1.2 直接插入排序
实现步骤：
动图演示：
特性总结：
代码实现：
1.3 希尔排序（缩小增量排序）
基本思想：
步骤演示：
特性总结：
代码实现：
2. 交换排序
2.1 基本思想：
2.2 冒泡排序
特性总结：
代码实现：
2.3 快速排序
3.选择排序
3.1 基本思想：
3.2 直接选择排序
步骤思路：
动图演示： 特性总结：
代码实现：
3.3 堆排序
代码实现：
0. 前情提醒： 下面的所有代码实现均为升序
1. 插入排序 1.1 基本思想： 把待排序的记录按其关键码值的大小逐个插入到一个已经排序好的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列。
1.2 直接插入排序 实现步骤： 当插入第i（i&gt;=1）各元素时，前面的array[0]，array[1]，......，array[i-1]已经排好序，此时用array[i]的排序码与array[i-1]，array[i-2]，......的排序码顺序进行比较，找到插入位置即将array[i]插入，原来位置上的元素顺序后移
动图演示： 特性总结： 元素集合越接近有序，直接插入排序算法的时间效率越高时间复杂度：O(N^2)空间复杂度：O(1)，它是一种稳定的排序算法4.稳定性：稳定 代码实现： void InsertSort(int* a, int n) { for (int i = 0; i &lt; n; i++) { int m = a[i]; int end = i; while (end &gt; 0 &amp;&amp; a[end - 1] &gt; m) { a[end] = a[end - 1]; end--; } a[end] = m; } } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa66ca1275e089ccda3363632876fc16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df34a47041ce6c93d6125b4c3d3c910e/" rel="bookmark">
			Lua常用C Api接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Lua 5.4 是 Lua 语言的一个版本，它提供了许多 C API 函数，这些函数允许开发者在 C 语言中嵌入和扩展 Lua 的功能。以下是一些常用的 Lua 5.4 C API 函数，以及它们的简单示例：
lua_newstate - 创建一个新的 Lua 状态。
lua_State *L = lua_newstate(0, 0); // 创建一个新的 Lua 状态 lua_close - 关闭一个 Lua 状态。
lua_close(L); // 关闭 Lua 状态 lua_openlibs - 打开 Lua 的标准库。
lua_openlibs(L); // 打开所有标准库 lua_getglobal - 获取全局变量。
lua_getglobal(L, "myGlobal"); // 获取名为 'myGlobal' 的全局变量 lua_setglobal - 设置全局变量。
lua_pushnumber(L, 42); // 将数字 42 推入栈 lua_setglobal(L, "myGlobal"); // 将栈顶的值设置为全局变量 'myGlobal' lua_pcall - 调用一个函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df34a47041ce6c93d6125b4c3d3c910e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d30fe173e00e4910c5de00c0c08d6a3/" rel="bookmark">
			Android中华为手机三态位置权限申请理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住也分享一下给大家，
👉点击跳转到教程
前言：
使用的华为MATE 20,Android10的系统。
&lt;!--精准定位权限，如：GPS定位--&gt; &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt; &lt;!--近似定位权限 如：网络定位 注：这个权限会在应用安装时由用户授予，并且不需要动态请求--&gt; &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt; 下面我们进行GPS定位权限的获取，在AndroidManifest.xml文件中声明相应的权限，之后在Activity中中进行动态申请。
以下是三个选项的含义：
仅使用期间允许：
当用户选择"仅使用期间允许"选项时，应用程序将仅在用户正在使用应用程序的时候才能获取位置信息。一旦用户退出应用程序，应用程序将立即失去对位置信息的访问权限。这意味着应用程序无法在后台继续获取位置信息，即使它仍在运行。这种设置有效保护了用户在离开应用程序后的隐私。
允许本次使用：
当用户选择"允许本次使用"选项时，应用程序将在接下来的一段时间内（通常为5分钟左右）持续获取位置信息，即使用户已经退出了应用程序。在这段时间内，应用程序可以在前台或后台继续获取位置信息。这种设置适用于需要在用户离开应用程序后仍然持续使用位置信息的场景，但也会增加一定程度上的隐私风险。
总的来说，"仅使用期间允许"更加严格，确保应用程序只能在用户使用应用程序的时候获取位置信息，而"允许本次使用"则允许应用程序在一定时间内持续获取位置信息，即使用户已经离开应用程序。在实际使用中，用户可以根据自己的隐私偏好和安全需求选择适合的权限控制选项。
禁止：设备的位置信息绝不会向应用显示。
以下是博主本人实际验证：
1、点击仅使用期间允许，在该应用的位置信息权限页面，显示仅使用期间允许被选中。
2、点击允许本次使用，在该应用的位置信息权限页面，显示每次使用询问被选中。
3、点击禁止，在该应用的位置信息权限页面，显示禁止被选中
思考：如果我们点击了允许本次使用，那我们在位置信息权限页面则会看到每次使用询问被选中，那是不是每次进入APP如果需要用到位置权限，岂不是每次都要申请权限，但是我测试发现并不是这样，并不需要再去获取权限了。
解惑：
对于某些应用程序，当用户首次访问时，可能会要求用户授予一些权限或许可，比如访问摄像头、麦克风、位置等。如果用户选择了"允许"，应用程序可能会将这些权限信息保存在用户设备上。这样，在下次用户再次打开应用程序时，应用程序可以直接使用之前获得的权限，而不需要再次请求用户的授权。
这种行为是由操作系统和应用程序的权限管理机制共同实现的。操作系统会为每个应用程序分配一个唯一的标识符（如包名或应用ID），并在用户授权时将该标识符与所授权的权限绑定。应用程序在后续启动时，操作系统会检查该应用程序的标识符和之前已授权的权限，如果匹配，则应用程序可以直接使用权限而无需再次请求授权。
需要注意的是，这种自动授权的行为仅限于相同设备上的同一应用程序。如果用户在不同的设备上或者使用不同的应用程序版本，可能仍然需要重新授权。此外，某些敏感权限（如通讯录、短信等）可能会更加严格，需要用户每次都进行授权。
总结来说，点击允许本次使用并保存权限的行为是为了提供更好的用户体验，避免在每次应用程序启动时都要求用户重复授权。这是操作系统和应用程序的一种权限管理机制，旨在简化用户的操作流程。
如果我们想要APP在后台能持续获取位置信息，应该怎么做呢？
在Android 10之前，应用程序可以通过ACCESS_FINE_LOCATION权限或使用后台服务来获取后台位置权限。但是，从Android 10开始，需要使用更精确的后台位置权限（ACCESS_BACKGROUND_LOCATION）来在后台获取位置信息。
这里指的是Android 10指的是手机系统，和项目的targetSdk无关，这个一定要注意。
我们要在ACCESS_FINE_LOCATION权限申请后，再申请ACCESS_BACKGROUND_LOCATION
因为在targetSdkVersion=android11,在android11手机上，同时申请，普通定位权限和后台定位权限，将不会弹窗，直接授权失败。
比如这样写，申请权限弹窗都没有，android11之后的的手机，都是这样。
requestPermissions(arrayOf(Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_BACKGROUND_LOCATION), 100) 点击保持每次使用询问设置，在该应用的位置信息权限页面，每次使用询问被选中。
如果我们点击了，权限管理，会跳转到位置信息权限页面，如果点击了始终允许，则表示APP在后台也可以持续获取位置信息(前提是APP一直是活着的，没有被系统kill掉)。
点击了始终允许后，我们会在权限申请页面，回调到该方法onRequestPermissionsResult。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd0157c7209cfcc62d9f01da987fc46a/" rel="bookmark">
			经典面试题：MySQL如何调优？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 前言1. SQL查询优化2. 索引优化3. 表结构设计4. 硬件与配置优化5. 日常维护6. 性能测试与基准测试 前言 MySQL如何进行调优？这是面试中容易被问到的高频问题。
1. SQL查询优化 避免使用select* ：只选取需要的列，减少数据传输量。使用覆盖索引：设计索引以涵盖查询中所有列，减少回表查询。利用EXPLAIN分析查询：理解查询执行计划，优化索引使用。减少子查询：尽可能用连接查询（JOIN）替代复杂的子查询。使用LIMIT进行分页：避免一次性加载大量数据，特别是在网页分页场景中。优化IN操作：IN操作符中元素过多会影响性能，考虑使用JOIN或临时表。 2. 索引优化 合理添加索引：对经常用于查询条件的列添加索引，尤其是主键和外键。索引类型选择：根据数据分布选择合适的索引类型，如B-Tree、Hash等。定期分析和优化索引：使用ANALYZE TABLE和OPTIMIZE TABLE命令保持索引的最新状态。避免冗余索引：删除不必要的重复索引，减少写操作的开销。 3. 表结构设计 合适的数据类型：选择最合适的字段类型，避免不必要的空间占用和处理时间。分区表：对于大型表，可以考虑使用分区提高查询效率。归一化与反归一化：根据实际情况平衡数据规范性和查询效率。 4. 硬件与配置优化 内存：增加内存，扩大InnoDB缓冲池（innodb_buffer_pool_size），让热点数据尽可能驻留在内存中。CPU：根据负载情况考虑增加CPU核心数。磁盘：使用SSD提高I/O速度，或配置RAID以提高可靠性或性能。配置调整：根据实际负载调整MySQL配置文件中的各项参数，如线程池大小、连接数限制等。 5. 日常维护 定期备份：制定备份策略，使用mysqldump或mysqlhotcopy等工具。监控与日志：使用工具（如MySQL Enterprise Monitor、Prometheus+Grafana）监控数据库状态，分析慢查询日志。清理和归档：定期归档或删除不再需要的历史数据，减少数据库体积。安全维护：定期检查权限分配，避免过度使用root账户，及时更新安全补丁。 6. 性能测试与基准测试 在实施任何重大变更前后，进行性能测试和基准测试，确保优化措施有效且没有引入新的问题。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3975b6ffdc224a34b3c4e720e8abff3d/" rel="bookmark">
			代码随想录-算法训练营day46【动态规划08：单词拆分、多重背包！背包问题总结篇！】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码随想录-035期-算法训练营【博客笔记汇总表】-CSDN博客
第九章 动态规划part08 ● 139.单词拆分 ● 关于多重背包，你该了解这些！ ● 背包问题总结篇！ 详细布置 关于 多重背包，力扣上没有相关的题目，所以今天大家的重点就是回顾一波 自己做的背包题目吧。 139.单词拆分 视频讲解：https://www.bilibili.com/video/BV1pd4y147Rh https://programmercarl.com/0139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86.html 关于多重背包，你该了解这些！ https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85.html 背包问题总结篇！ https://programmercarl.com/%E8%83%8C%E5%8C%85%E6%80%BB%E7%BB%93%E7%AF%87.html 往日任务 ● day 1 任务以及具体安排：https://docs.qq.com/doc/DUG9UR2ZUc3BjRUdY ● day 2 任务以及具体安排：https://docs.qq.com/doc/DUGRwWXNOVEpyaVpG ● day 3 任务以及具体安排：https://docs.qq.com/doc/DUGdqYWNYeGhlaVR6 ● day 4 任务以及具体安排：https://docs.qq.com/doc/DUFNjYUxYRHRVWklp ● day 5 周日休息 ● day 6 任务以及具体安排：https://docs.qq.com/doc/DUEtFSGdreWRuR2p4 ● day 7 任务以及具体安排：https://docs.qq.com/doc/DUElCb1NyTVpXa0Jj ● day 8 任务以及具体安排：https://docs.qq.com/doc/DUGdsY2JFaFhDRVZH ● day 9 任务以及具体安排：https://docs.qq.com/doc/DUHVXSnZNaXpVUHN4 ● day 10 任务以及具体安排：https://docs.qq.com/doc/DUElqeHh3cndDbW1Q ●day 11 任务以及具体安排：https://docs.qq.com/doc/DUHh6UE5hUUZOZUd0 ●day 12 周日休息 ●day 13 任务以及具体安排：https://docs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3975b6ffdc224a34b3c4e720e8abff3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f6f9fcf1e3417c9a884f1816c6a567f/" rel="bookmark">
			在家庭影院音频中应用的D类音频放大器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		家庭影院的主要组成部分包括显示设备、音响设备、信号源和接线设备等。家庭影院的音响信号需要进行处理和输出，以获得高质量的音效。音响设备通常需要一台功率适当的数字、模拟混合的处理器，对音源进行降噪、均衡、扩展等处理操作，以达到高品质的音效表现。
模拟功放芯片在家庭影院音频系统中扮演着至关重要的角色；相比传统的功放芯片，具有更高的效率、更清晰的音质和更小的体积，能够对音频信号进行精确的处理和调整，从而实现高保真的音质表现；无论是细腻的音乐演奏还是震撼的电影场景，数字功放芯片都能让你身临其境，感受到每一个音符的精细之处。
D类放大器，是通过控制开关单元的ON/OFF，驱动扬声器的放大器。D类放大器首次提出于1958年，近些年已逐渐流行起来。D类放大器在过去的几代产品中，已经得到了巨大的发展，系统设计者极大地改善了系统的耐用性，并提高了其音频质量。
用控制器将模拟或数字音频信号在被集成到功率后端设备中的功率MOSFET管放大之前，转换成PWM信号。这些放大器效率很高，使用很小的散热器或根本不需要散热器，且降低了对电源输出功率的要求。然而，与传统的A/B类放大器相比，它们本身也存在固有的成本、性能和EMI方面的问题，解决这些问题就是D类放大器的发展新趋势。
此外，功放芯片的输出阻抗也要与音箱的输入阻抗匹配，以确保音频信号的传输稳定。其次要考虑芯片的音质表现；不同的数字功放芯片有不同的音质特点，有的音质细腻柔和，有的音质爆发力强。最后要考虑功放芯片的功能和接口。
模拟功放芯片采用数字信号处理技术，能将音频信号转换为数字信号，并通过数字放大技术进行放大；相比传统的功放芯片，能源利用率更高，可以有效地避免传统模拟功放中容易出现的失真、噪声等问题；同时，还具有自动保护功能，能够防止因过热、过流等因素造成的损坏。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d725df861c2462078b7ed513c7236051/" rel="bookmark">
			在Windows环境下安装GPU版的PyTorch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows环境下安装GPU版的PyTorch，是PyTorch深度学习的第一个门槛。本文详解GPU版的PyTorch安装步骤。
2.3.1 确认显卡是否支持CUDA 在深度学习中，我们经常要对图像数据进行处理和计算，而处理器CPU因为需要处理的事情多，并不能满足我们对图像处理和计算速度的要求，显卡GPU就是用来帮助CPU解决这个问题的，GPU特别擅长处理图像数据。
为什么GPU特别擅长处理图像数据呢？这是因为图像上的每一个像素点都有被处理的需要，而且每个像素点处理的过程和方式都十分相似，GPU就是用很多简单的计算单元来完成大量的计算任务，类似于纯粹的人海战术。GPU不仅可以在图像处理领域大显身手，它还被用在科学计算、密码破解、数值分析、海量数据处理（比如排序、Map-Reduce）、金融分析等需要大规模并行计算的领域。
而CUDA（Compute Unified Device Architecture）是显卡厂商NVIDIA推出的只能用于自家GPU的并行计算架构，只有安装这个软件，才能够进行复杂的并行计算。该架构使GPU能够解决复杂的计算问题。它包含CUDA指令集架构（Instruction Set Architecture，ISA）以及GPU内部的并行计算引擎，安装CUDA之后，可以加快GPU的运算和处理速度，主流的深度学习框架也都是基于CUDA进行GPU并行加速的。
想要使用GPU加速，则需要安装CUDA，首先需要自己的计算机显卡支持CUDA的安装，也就是查看自己的计算机有没有NVIDA的独立显卡。在NVIDA官网列表（https://developer.nvidia.com/cuda-gpus）中可以查看自己的显卡型号是否包括在NVIDA列表中。
在计算机桌面上右击，在弹出的菜单中如果能找到NVIDIA控制面板，如图2-9所示，则说明该计算机配有GPU。
打开NVIDIA控制面板窗口，可以查看NVIDIA的一些信息，包括显卡的驱动版本，通过单击“帮助”菜单，并选择“系统信息”选项，查看系统信息获取支持的CUDA版本。如图2-10所示，选择“组件”，在3D设置模块找到NVCUDA64.DLL，在该行可以看到该NVCUDA的版本，可以看到图中显示的版本是 11.8。
2.3.2 安装CUDA 我们已经知道，CUDA是显卡厂商NVIDIA推出的通用并行计算架构，能利用英伟达GPU的并行计算引擎。目前已经确认系统已有支持CUDA的显卡，这时可以到NVIDIA网站 （https://developer.nvidia.com/cuda-toolkit-archive）下载CUDA，如图2-11所示。注意，安装CUDA Driver时，需要与Nvidia GPU Driver的版本驱动一致，CUDA才能找到显卡。
根据实际情况选择合适的版本，比如计算机操作系统是Windows 10，这里下载CUDA 11.8.0的本地安装包，如图2-12所示。
2.3.3 安装cuDNN 接下来下载与CUDA对应版本的cuDNN，cuDNN是用于深度神经网络的GPU加速库，下载地址为https://developer.nvidia.com/rdp/cudnn-archive，页面如图2-13所示。
下载cuDNN，需要注册英伟达开发者计划的会员账号才能下载，如图2-14所示，读者请自行注册账户，加入会员。
进入下载页面后，注意不要选择错误的版本，一定要找到对应CUDA的版本号。另外，如果使用的是Windows 64位的操作系统，那么需要对应下载x86版本的cuDNN。
cuDNN就是个压缩包，解压会生成bin、lib、include三个目录（见图2-15），里面的文件复制到CUDA安装目录（这里是C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.0目录）下对应的目录即可。注意，不是替换文件夹，而是将文件放入对应的文件夹中。
接下来安装Visual Studio 2015、2017、2019和 2022支持库，这个支持库务必安装，否则后面安装PyTorch支持库会出现各种“坑”。支持库不大，有十多MB，安装完成后重启系统。其下载地址为https://docs.microsoft.com/zh-CN/cpp/windows/latest-supported-vc-redist?view=msvc-160，下载页面如图2-16所示。
2.3.4 安装GPU版PyTorch 安装GPU版本的PyTorch稍微复杂，前提是需要安装CUDA、cuDNN并行计算框架，然后安装PyTorch。PyTorch官网（地址为https://pytorch.org）给出了匹配的版本号及安装命令，如图2-17所示。
运行命令（Run this command）字段中的命令如下：
pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118
后面安装是否成功，就请读者自行验证了。
《PyTorch深度学习与企业级项目实战（人工智能技术丛书）》(宋立桓，宋立林)【摘要 书评 试读】- 京东图书 (jd.com)
本文节选自《PyTorch深度学习与企业级项目实战》，获出版社和作者授权发布。
【赠书活动第5期】《PyTorch深度学习与企业级项目实战》-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26c6110cd8c49c6a55abaaf2a747227c/" rel="bookmark">
			物体检测算法-R-CNN，SSD，YOLO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		物体检测算法-R-CNN，SSD，YOLO 1 R-CNN2 SSD3 Yolo总结 1 R-CNN R-CNN（Region-based Convolutional Neural Network）是一种基于区域的卷积神经网络，是第一个成功将深度学习应用到目标检测上的算法。它主要由三个步骤组成：区域提议、特征提取和目标分类。
首先，R-CNN使用选择性搜索（Selective Search）算法生成可能包含物体的候选区域。这些候选区域被认为是可能包含有意义物体的区域，并被作为输入传递给后续的卷积神经网络（CNN）模型。
接下来，R-CNN使用一个已经预训练好的卷积神经网络（CNN），比如AlexNet或VGGNet，对每个候选区域进行特征提取。它通过将候选区域调整为相同的大小，然后将其输入到CNN中，从而得到每个区域的固定长度特征向量。
最后，这些特征向量被送入一个多类别支持向量机（SVM）分类器中，以预测候选区域中所含物体属于每个类别的概率值。每个类别训练一个SVM分类器，从特征向量中推断其属于该类别的概率大小。为了提升定位准确性，R-CNN还训练了一个边界框回归模型，通过边框回归模型对框的准确位置进行修正。
R-CNN在多个领域都有广泛的应用，如物体检测、图像理解等。在自动驾驶、无人机、监控系统等中，R-CNN可以帮助系统识别并定位道路上的车辆、行人、障碍物等。在图像搜索引擎、社交媒体平台中，R-CNN可帮助自动标注图片，提高用户体验。
然而，R-CNN也存在一些缺点。例如，它需要对候选区域进行尺度的变换以固定大小，这可能会使候选区域发生形变失真而损失原有的特征信息。此外，R-CNN要对得到的所有候选区域逐个进行特征提取，带来了巨大的计算消耗，进而导致目标检测速度十分缓慢。此外，R-CNN并不是端到端的整体网络，需要进行多次繁琐耗时的训练，浪费大量存储空间，导致该算法难以应用到工业领域中。为了解决这些问题，后续的研究者提出了Fast R-CNN、Faster R-CNN等改进算法。
2 SSD SSD (Single Shot MultiBox Detector) 是一种单阶段（one-stage）的目标检测算法，它直接在多个不同尺度的特征图上进行目标分类和边界框回归，从而实现了高速和准确的目标检测。SSD 相比于早期的 R-CNN 系列（如 R-CNN, Fast R-CNN, Faster R-CNN）等双阶段（two-stage）检测算法，在速度上有显著的提升，同时保持了相当的检测精度。
SSD 的主要特点包括：
多尺度特征图：SSD 在多个不同尺度的特征图上进行预测，每个特征图对应一个不同尺度的感受野。这使得 SSD 能够检测不同大小的目标，尤其是在小目标检测上表现出色。
先验框（Default Boxes 或 Anchor Boxes）：SSD 在每个特征图的每个位置上预设了一组不同大小和长宽比的先验框，这些先验框作为目标边界框的初始估计。然后，网络通过训练学习这些先验框的偏移量以及每个先验框的类别置信度。
端到端训练：SSD 是一个端到端的网络，可以直接从原始图像中预测目标类别和位置，无需像 Faster R-CNN 那样需要额外的区域提议网络（RPN）。
卷积预测器：SSD 使用多个卷积层来预测不同特征图上的目标类别和位置。这些卷积层能够共享计算，并使得 SSD 能够在不同尺度上并行地处理特征图。
非极大值抑制（NMS）：在预测阶段，SSD 会为每个类别生成多个边界框预测。然后，使用非极大值抑制（NMS）来消除重叠度过高的边界框，从而得到最终的检测结果。
SSD 在许多实际应用中都取得了很好的效果，尤其是在需要高速目标检测的场景中，如自动驾驶、实时视频监控等。同时，由于其端到端的训练和简洁的网络结构，SSD 也成为了目标检测领域的一个重要基准算法。
多分辨率下的，速度很快，但是精度不如R-CNN.
3 Yolo YOLO (You Only Look Once) 是一种先进的目标检测算法，它采用了一种全新的思路来解决目标检测问题。与之前的 R-CNN 系列算法不同，YOLO 将目标检测任务视为一个回归问题，从而实现了单次前向传播即可完成检测，大大提升了检测速度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26c6110cd8c49c6a55abaaf2a747227c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74cb3a83987a34c2f3e79148e0a8b1c3/" rel="bookmark">
			【postgresql初级使用】基于表达式或者函数的索引，字符串拼接可以使用索引了，带来不一样的优化效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		带表达式的索引 ​专栏内容：
postgresql使用入门基础手写数据库toadb并发编程 个人主页：我的主页
管理社区：开源数据库
座右铭：天行健，君子以自强不息；地势坤，君子以厚德载物.
文章目录 带表达式的索引概述 创建语法 场景分析 函数表达式 普通表达式 总结 结尾 概述 在postgresql 中，一个索引不仅仅是基于表的一列或多列来创建，还可以基于函数，或者一个表达式来创建。
本文就来分享在postgresql 如何基于表达式来创建索引。
创建语法 基于表达式创建索引，它的SQL语法如下所示：
CREATE INDEX index_name ON table_name (expression); index_name 指定当前索引的名称 ；ON子句 指定当前索引 引用的数据表；expression 指定表达式内容；普通索引这里指定的是列名； 场景分析 在大数据时代，查询语句各式各样，过滤条件中带有函数，字符拼接等等，组成各种条件变量，下面我们按不同场景来举例说明。
函数表达式 经常会遇到将字符串转换为小字，或者在大小写不敏感时，就可以转换为大写或者小写，再来比较。
有一张人员信息表，名字分为first_name,last_name两部分，而名字又是大小字不敏感，所以经常转换为小写字符来比较。
postgres=&gt; create table userInfo (uid integer primary key, first_name varchar, last_name varchar); CREATE TABLE postgres=&gt; INSERT INTO userinfo(uid, first_name, last_name) select id, 'firstname' || id::int, 'lastname'||id::int FROM generate_series(1, 100000) as id; INSERT 0 100000 表中插入了10万条测试数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74cb3a83987a34c2f3e79148e0a8b1c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/229dc76b90237e3b56d25c4ed7bd69e8/" rel="bookmark">
			【微信小程序开发】小程序前后端交互--发送网络请求实战解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨✨ 欢迎大家来到景天科技苑✨✨
🎈🎈 养成好习惯，先赞后看哦~🎈🎈
🏆 作者简介：景天科技苑
🏆《头衔》：大厂架构师，华为云开发者社区专家博主，阿里云开发者社区专家博主，CSDN全栈领域优质创作者，掘金优秀博主，51CTO博客专家等。
🏆《博客》：Python全栈，前后端开发，小程序开发，人工智能，js逆向，App逆向，网络系统安全，数据分析，Django，fastapi，flask等框架，linux，shell脚本等实操经验，网站搭建，数据库等分享。
所属的专栏：微信小程序开发零基础教学，难点与应用实战总结
景天的主页：景天科技苑
文章目录 发送网络请求1.微信发送网络请求2.后端接口3.发送请求4.loading提示框5.结合爬虫实战案例 发送网络请求 在之前的小程序开发章节中，全是在微信小程序端操作，没有加入后端内容。
本文将详细讲讲如何从后端获取数据，需要在微信小程序端，发送网络请求，获取数据，显示在小程序上
1.微信发送网络请求 注意：发送网络请求的域名，必须在微信公众平台配置
本地环境去除，只适用于开发版和体验版 配置域名：
登录小程序后台–开发管理
必须配置在工信部备案的域名
未备案的域名不能填写
我们本地开发，不需要域名，只需要在开发者工具中，详情配置里面，勾选不校验合法域名即可
这样，开发和体验的微信号就不用域名也可以访问
2.后端接口 使用django后端：写个接口，返回用户信息微信小程序端：发送请求，获取数据，显示在微信小程序端 视图层：
from django.shortcuts import render from django.http import JsonResponse import time import json import requests # Create your views here. #写个接口，返回数据 def index(request): # time.sleep(3) return JsonResponse({"name":"彭于晏","age":39,"hobby":"抽烟"}) url路由
from django.contrib import admin from django.urls import path from app import views urlpatterns = [ path('admin/', admin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/229dc76b90237e3b56d25c4ed7bd69e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9453df5d4439d741a80500d322087f85/" rel="bookmark">
			【C语言】C语言零基础纯干货教学（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页~
C语言零基础纯干货教学（上）
C语言零基础纯干货教学（中）
C语言入门 四、数组1、概念2、一维数组（1）一维数组创建（2）数组的初始化 3、一维数组的使用（1）访问下标（2）数组输入和打印 4、一维数组在内存中的存储5、sizeof计算数组元素个数6、二维数组（1）概念（2）二维数组的创建 7、二维数组的初始化8、二维数组的使用（1）下标访问（2）二维数组的输入输出 9、二维数组在内存中的存储 五、函数1、函数的概念2、库函数3、自定义函数（1）概念（2）例子 4、形参和实参5、return语句6、数组做函数参数7、函数的声明和定义（1）单文件（2）多文件（3）extern和static 六、函数递归1、概念2、例子（1）n的阶乘（2）斐波那契数列 在这里插入图片描述 四、数组 1、概念 数组是一组相同类型元素的集合，分为一维数组和多维数组，其中多维数组中二维数组用的最多，至于三维数组及其以后的多维数组在生产生活中用的是比较少的
2、一维数组 （1）一维数组创建 type name[n]; type是指数据类型，这里是你希望你创建的数组当中所有元素的数据类型
name是数组的名字
n是指数组的元素个数，是个常量，用方括号括起来
数组的类型是type[n]
（2）数组的初始化 C语言的初始化一般使用大括号，分为完全初始化以及不完全初始化
//完全初始化，此时数组元素的值就对应着这几个数字 int arr[5] = {1,2,3,4,5}; //不完全初始化，此时除了被初始化有值的元素外，其他的元素都是0 char ch[3] = {1}; //错误初始化，此时初始化的项数超过了数组的最大规格 double do[2] = {1,2,3}; 3、一维数组的使用 （1）访问下标 一维数组通过下标访问来使用，数组的第一个元素的下标为0，最后一个元素的下标为n-1
（2）数组输入和打印 通过循环来进行输入和输出
#include &lt;stdio.h&gt; int main() { int arr[10] = { 0 }; for (int i = 0; i &lt; 10; i++) { arr[i] = i + 1; } for (int i = 0; i &lt; 10; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9453df5d4439d741a80500d322087f85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8242c00cf129cd8f22982bb414d9a402/" rel="bookmark">
			Hadoop 安装及目录结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优质博文IT-BLOG-CN
一、准备工作 【1】创建用户： useradd用户名
【2】配置创建的用户具有root权限，修改/etc/sudoers文件，找到下面一行，在root下面添加一行，如下所示：（注意：需要先给sudoer文件赋权限，修改完会后，将权限修改回来）修改完毕，现在可以用创建的帐号登录，然后用命令su - ，即可获得root权限进行操作。
## Allow root to run any commands anywhere root ALL=(ALL) ALL 创建的用户 ALL=(ALL) ALL 【3】在/opt目录下创建module、software文件夹，同时修改文件的所有者 sudo chmod 777文件地址。
sudo mkdir module sudo mkdir software 二、下载地址 下载地址
解压：tar -zxvf hadoop-2.7.2.tar.gz -C /opt/module/
三、配置环境变量 【1】查看Hadoop解压目录
[zzx@localhost hadoop-2.7.2-src]$ pwd /opt/module/hadoop-2.7.2-src 【2】打开/etc/profile
[zzx@localhost etc]$ sudo vi profile 【3】在文件中添加Hadoop的环境变量
##HADOOP_HOME export HADOOP_HOME=/opt/module/hadoop-2.7.2 export PATH=$PATH:$HADOOP_HOME/bin export PATH=$PATH:$HADOOP_HOME/sbin 【4】重启配置文件，让修改的配置文件生效
[root@localhost etc]# source /etc/profile 【5】测试是否安装成功（如果Hadoop命令不生效就重启试试reboot)
[root@localhost soft]# hadoop version Hadoop 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8242c00cf129cd8f22982bb414d9a402/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4be6d3184867faf82ea43b4927281926/" rel="bookmark">
			使用api和rpc的一个综合使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		type ( LoginRequest { Username string `json:"username"` Password string `json:"password"` } RegistRequest { Username string `json:"username"` Password string `json:"password"` } RegistResponse { UserId uint `json:"userId"` Err string `json:"err"` } ) @server ( prefix: /api/users ) service users { @handler login post /login (LoginRequest) returns (string) @handler register post /regist (RegistRequest) returns (RegistResponse) } type ( UserInfoRequest { Id uint `json:"id"` } UserInfoResponse { Username string `json:"username"` } ) @server ( prefix: /api/users jwt: Auth //开启jwt认证 ) service users { @handler userInfo get /info (UserInfoRequest) returns (UserInfoResponse) } 首先是api文档，然后通过命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4be6d3184867faf82ea43b4927281926/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34a2a69b6f9e54719f31bfa579344099/" rel="bookmark">
			在 Visual Studio Code 中集成 ESLint新手教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将指导您在 Angular 项目中集成 ESLint，并在 Visual Studio Code (VS Code) 中配置和使用 ESLint。
安装必要的依赖项
首先，确保您已在项目中安装 Angular CLI。如果还没有，请运行以下命令： npm install -g @angular/cli 然后，进入您的项目目录并安装以下必要的 ESLint 相关依赖项：
npm install @angular-eslint/builder @angular-eslint/eslint-plugin @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint --save-dev 配置 ESLint
创建或修改项目根目录下的 eslint.config.mjs 文件，内容如下： import typescriptEslintPlugin from '@typescript-eslint/eslint-plugin'; import typescriptEslintParser from '@typescript-eslint/parser'; /** @type {import('eslint').Linter.FlatConfig[]} */ const config = [ { files: ['**/*.ts'], // 仅针对 TypeScript 文件 languageOptions: { ecmaVersion: 2020, sourceType: 'module', parser: typescriptEslintParser, }, plugins: { '@typescript-eslint': typescriptEslintPlugin, }, rules: { 'semi': ['error', 'always'], // 确保使用分号 // 在此添加其他 ESLint 规则 }, }, ]; export default config; 更新 Angular 项目配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34a2a69b6f9e54719f31bfa579344099/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cf37a453575f050f0db39d03124f9bc/" rel="bookmark">
			轻松拿捏C语言——二分查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🥰欢迎关注 轻松拿捏C语言系列，来和 小哇 一起进步！✊
🌈感谢大家的阅读、点赞、收藏和关注💕
目录🎉
一、介绍🌈
二、步骤🌙
三、代码☀️
一、介绍 二分查找是一种在有序数组中查找某一特定元素的搜索算法。
举个生活中的例子，当我们要去图书馆借书时，知道了要找的图书编号，我们可以在一个大致范围的中间查找，然后在决定往前找还是往后找。这样就能比一本一本地找更加快速。
搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；
如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。
如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。
二、步骤 确定搜索范围，即数组的下标范围left和right。计算中间元素的下标mid = (left + right) / 2(注意整数除法）。 但是像这样求平均值，如果数字太大了超过int类型能表示的最大范围，这种算法就会有问题，整数会溢出。
所以我们可以换一个思路，把两数的差值的一半 加到另一个数字中：
mid = left + (right-left) /2 判断中间元素与目标值的大小关系。 如果相等，则返回中间元素的下标。如果目标值小于中间元素，则在左半部分继续搜索（right = mid - 1）。如果目标值大于中间元素，则在右半部分继续搜索（left = mid + 1）。如果搜索范围left大于right，则表示数组中没有目标值，返回-1或其他表示未找到的值。 三、代码 法一：用递归实现
#include &lt;stdio.h&gt; int Sort(int arr[], int left, int right, int Key) { if (left &gt; right) return -1; // 搜索范围无效 int mid = left + (right - left) / 2; //这种写法可避免溢出 if (arr[mid] == Key) { return mid; // 找到目标，返回下标 } else if (arr[mid] &gt; Key) { return Sort(arr, left, mid - 1, Key); // 在左半部分继续搜索 } else { return Sort(arr, mid + 1, right, Key); // 在右半部分继续搜索 } } int main() { int arr[] = {1, 3, 5, 7, 9}; int key = 5; int n = sizeof(arr) / sizeof(arr[0]); int ret = Sort(arr, 0, n - 1, key); if (ret !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cf37a453575f050f0db39d03124f9bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27e1981835329266759bece3d1b79782/" rel="bookmark">
			HTML新春烟花盛宴
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
写在前面
烟花盛宴
完整代码
修改文字
系列推荐
写在后面
写在前面 本期小编给大家分享一场绝美的烟花盛宴，无论你用手机还是电脑都可以直接打开哦！
烟花盛宴 春节放烟花这个传统习俗，可是咱们古老文化中一道璀璨夺目的风景线呢！每年农历新年的到来，家家户户燃放烟花炮竹的场景，那可是热闹非凡，充满了喜庆与吉祥的气息。
这习俗最早源于古代人们对新的一年的美好祝愿和对邪恶力量的驱赶。在很久很久以前，人们相信燃烧火把和竹子可以发出巨大的声响和耀眼的火花，这些都能帮助他们赶走那些可能带来病痛和灾难的瘟疫、邪灵。后来随着技术的发展，竹子内的火药被发明出来，就演变成了我们现在看到的烟花爆竹。
到了除夕夜，也就是一年中的最后一天，大家会通过燃放烟花来庆祝旧岁的过去、新年的到来，寓意着辞旧迎新，破旧立新，把所有不好的东西都留在过去，希望新的一年能够红红火火、平安吉祥。同时，那绚丽多彩的烟花绽放在夜空中，也象征着生活丰富多彩、幸福美满，给人们带来了无尽的欢乐和憧憬。
所以，每当春节来临之际，我们都会欢欢喜喜地放烟花，不仅是为了传承这份深厚的文化底蕴，更是为了表达对家人和朋友的祝福，以及对未来的期待与向往。
完整代码 &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;新春快乐&lt;/title&gt; &lt;style&gt; html, body { margin: 0px; width: 100%; height: 100%; overflow: hidden; background: #000; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id="canvas" style="position:absolute;width:100%;height:100%;z-index:8888"&gt;&lt;/canvas&gt; &lt;canvas style="position:absolute;width:100%;height:100%;z-index:9999" class="canvas"&gt;&lt;/canvas&gt; &lt;div class="overlay"&gt; &lt;div class="tabs"&gt; &lt;div class="tabs-labels"&gt;&lt;span class="tabs-label"&gt;Commands&lt;/span&gt;&lt;span class="tabs-label"&gt;Info&lt;/span&gt;&lt;span class="tabs-label"&gt;Share&lt;/span&gt;&lt;/div&gt; &lt;div class="tabs-panels"&gt; &lt;ul class="tabs-panel commands"&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; function initVars() { pi = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27e1981835329266759bece3d1b79782/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4607d0a67c90a3527143a4d1bd5bfa94/" rel="bookmark">
			2024新数据库入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.官网下载MySQL 下载Mysql链接: 点击下载mysql
下载完成后解压到某一个文件夹（记住这个路径，一会要用到）
2.配置初始化文件my.ini 在根目录下创建一个txt文件，名字叫my，文件后缀为ini
以下代码除安装目录和数据的存放目录需修改，其余不用修改 [mysqld] # 设置3306端口 port=3306 # 设置mysql的安装目录 ----------是你的文件路径------------- basedir=E:\mysql\mysql # 设置mysql数据库的数据的存放目录 ---------是你的文件路径data文件夹自行创建 datadir=E:\mysql\mysql\data # 允许最大连接数 max_connections=200 # 允许连接失败的次数。 max_connect_errors=10 # 服务端使用的字符集默认为utf8mb4 character-set-server=utf8mb4 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB # 默认使用“mysql_native_password”插件认证 #mysql_native_password default_authentication_plugin=mysql_native_password [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8mb4 [client] # 设置mysql客户端连接服务端时默认使用的端口 port=3306 default-character-set=utf8mb4 3.初始化MySQL 以管理员身份运行命令提示符（CMD）
进入mysql的bin目录
在MySQL目录下的bin目录下执行命令：
mysqld --install mysql 会得到密码：****
4.安装mysql服务并启动+修改密码 （1）安装mysql服务
mysqld --install mysql 之后会提示服务已经成功安装
（2）启动mysql服务
net start mysql 输入之后提示以下内容
（3）连接mysql
输入以下命令修改密码(把新的密码修改成你想要的密码)
ALTER USER 'root'@'localhost' IDENTIFIED BY '新的密码'; 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4607d0a67c90a3527143a4d1bd5bfa94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54380931fcad1b78ff9fb88319b40451/" rel="bookmark">
			基于Java的地震震中附近城市分析实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、空间数据说明
1、空间查询
二、Java后台开发
1、模型层设计与实现
2、控制层设计与实现
三、Leaflet地图开发
1、地震震中位置展示
2、附近城市展示
3、成果展示
总结
前言 随着全球气候变化和地壳活动的不断演变，地震作为一种自然灾害，其发生的频率和影响力日益受到人们的关注。当一个城市或地区遭受地震的威胁时，对其进行详尽的分析显得尤为必要。地震附近城市分析的必要性主要包含以下几个方面：
一、了解地震风险，保障居民安全
地震附近城市的分析，首要目的是了解该城市的地震风险。通过对城市地质结构、地震历史数据、地震活动频率和强度等方面的深入研究，可以准确评估城市面临的地震风险等级。这种评估对于城市规划和防灾减灾措施的制定至关重要，能够确保城市居民的生命财产安全。
二、指导城市规划和建设
地震附近城市的分析还能够为城市规划和建设提供重要指导。在了解城市地震风险的基础上，可以合理规划城市布局，避免在地震活动频繁或地质条件脆弱的区域进行重要建筑和基础设施的建设。此外，分析结果还可以为建筑物的抗震设计提供科学依据，确保建筑物在地震发生时能够保持相对稳定，减少倒塌和破坏的风险。
三、提高城市应急管理能力
地震灾害的突发性和不可预测性要求城市必须具备高效的应急管理能力。地震附近城市的分析可以为城市的应急管理工作提供重要支持。通过对城市地震风险的评估，可以制定相应的应急预案和救援计划，确保在地震发生后能够迅速、有效地进行救援和恢复工作。同时，分析结果还可以帮助城市完善应急设施，提高应对地震灾害的能力。
四、促进城市可持续发展
地震附近城市的分析不仅关注当前的地震风险，还着眼于城市的未来发展。通过深入分析城市的地质条件和地震活动规律，可以为城市的可持续发展提供重要支持。在规划城市未来发展时，可以充分考虑地震风险因素，采取科学合理的措施来降低地震对城市的影响。这有助于实现城市的可持续发展，确保居民在享受城市带来的便利和舒适的同时，也能够享受到安全和稳定的生活环境。
本文基于中国地震台网的数据，以及全国城市点位数据，通过分析地震震中位置100公里范围内的城市列表，以及震中位置与城市的直线距离，为后面做空间分析打下坚实的基础，通过本文，您可以了解到如何在PostGIS数据库中进行空间范围查询，同时可以了解如何将查询结果进行Web空间可视化的具体方法。
博文首先介绍空间数据的基本情况，即如何在空间数据中如何进行空间分析，然后讲解如何使用Java进行后台空间分析的应用，其次介绍如何在Leaflet对分析的结果进行Web可视化，最后给出实际的运行例子，让大家知道程序最终的成果。
一、空间数据说明 本节将对空间数据结构和数据，100公里范围的空间分析查询进行简单介绍。让大家了解如何进行地震位置指定范围城市查询。
1、空间查询 在空间数据库中，要想实现100公里范围内的指定目标查询。采用的是我们熟悉的范围查询函数。st_dwithin () ,为了方便将两个空间对象进行以米为单位的距离换算， 我们将geometry对象转换为geography类型。具体使用的查询语句如下所示：
SELECT T.pk_id, T.NAME, T.pinyin, T.classz, T.bz, T.slx, st_x ( T.geom ) lon, st_y ( T.geom ) lat, st_distance ( T.geom :: geography, t1.geom :: geography ) dist FROM biz_geographic_name T, biz_ceic_earthquake t1 WHERE t1.pk_id = 1792871415574196226 AND st_dwithin ( T.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54380931fcad1b78ff9fb88319b40451/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/10/">«</a>
	<span class="pagination__item pagination__item--current">11/71</span>
	<a class="pagination__item pagination__item--next btn" href="/page/12/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>