<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.126.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程学习者的博客">
		<meta property="og:url" content="https://bcxuexizhe.github.io/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="编程学习者">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3d392782a74d8e32366bd9e31a2ee14/" rel="bookmark">
			jdk17 环境easyexcel导入excel报错java.lang.NoClassDefFoundError: org/apache/commons/io/build/AbstractStream
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		liunx环境报错本地window不报错 个人推测本地运行时可能子工程缓存的原因，清空maven 缓存后运行也报错。
报错:com.dtp.core.thread.NamedThreadFactory$DtpUncaughtExceptionHandler:uncaughtException:68: thread Thread[test-1,5,main] throw exception java.lang.IllegalAccessError: class com.ai.aif.log4x.util.Strings (in unnamed module @0x6833ce2c) cannot access class sun.security.action.GetPropertyAction (in module java.base) because module java.base does not export sun.security.action to unnamed module @0x6833ce2c
com.alibaba.excel.exception.ExcelAnalysisException: java.lang.NoClassDefFoundError: org/apache/commons/io/build/AbstractStreamBuilder
at com.alibaba.excel.analysis.ExcelAnalyserImpl.&lt;init&gt;(ExcelAnalyserImpl.java:61)
at com.alibaba.excel.ExcelReader.&lt;init&gt;(ExcelReader.java:30)
at com.alibaba.excel.read.builder.ExcelReaderBuilder.build(ExcelReaderBuilder.java:214)
at com.alibaba.excel.read.builder.ExcelReaderBuilder.sheet(ExcelReaderBuilder.java:251)
at com.alibaba.excel.read.builder.ExcelReaderBuilder.sheet(ExcelReaderBuilder.java:243)
at com.basic.system.utils.ExcelUtil.readExcel(ExcelUtil.java:30)
at com.basic.system.service.impl.SysAddressBookServiceImpl.addStaff(SysAddressBookServiceImpl.java:259)
at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.base/java.lang.reflect.Method.invoke(Method.java:568)
at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:343)
at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:196)
at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)
at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:751)
at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:123)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3d392782a74d8e32366bd9e31a2ee14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee1e6a2e8241f05ea2b292efcbf1873a/" rel="bookmark">
			JAVA poi-tl 制作word模板 表格数据行循环 带有复选框勾选的表格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 @[TOC](文章目录) 前言一、需要的依赖二、制作word模板1. 原word表单文件2. 制作word模板3. 最后通过代码生成的word数据表格 三、示例代码1.测试工具类2. 表单对象3. 表单行数据循环对象 四、参考或相关文档 前言 java项目实际开发中经常会遇到制作word表单且表格数据行循环功能，甚至带有复选框勾选功能，本文简单介绍如何制作模板以及使用poi-tl生成word。
提示：以下是本篇文章正文内容，下面案例可供参考
一、需要的依赖 如果只用到word那么需要导入的依赖如下(本案例只需要如下2个依赖生成word)：
&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.0.M2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.deepoove&lt;/groupId&gt; &lt;artifactId&gt;poi-tl&lt;/artifactId&gt; &lt;version&gt;1.9.1&lt;/version&gt; &lt;/dependency&gt; 正常企业项目还有excel等其他office工具，所以需要导入其他依赖：
&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-scratchpad&lt;/artifactId&gt; &lt;version&gt;4.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;ooxml-schemas&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;4.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;4.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml-schemas&lt;/artifactId&gt; &lt;version&gt;4.1.2&lt;/version&gt; &lt;/dependency&gt; 注意：一定要看清楚导入的poi-tl的版本，不同版本对应的jdk，Apache POI版本都不一样，且代码中需要调用的函数也可能会不一样。
poi-tl不同版本相关文档介绍
二、制作word模板 以下都是示例模板 1. 原word表单文件 2. 制作word模板 模板文件链接：https://pan.baidu.com/s/1Lvo43xkYp6ec2RonHpEeKA
提取码：0617
3. 最后通过代码生成的word数据表格 三、示例代码 1.测试工具类 import cn.hutool.core.bean.BeanUtil; import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee1e6a2e8241f05ea2b292efcbf1873a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e410c17ade307f6a433be12759a9daf9/" rel="bookmark">
			Android malloc_debug实现原理及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、malloc_debug工具使用 malloc_debug作用：用于调试单个native进程内存问题，如检测内存损坏、内存泄漏、内存访问越界、内存释放再使用等。
1.1 打开malloc_debug开关 adb shell setprop libc.debug.malloc.program app_process(proc name) ---指定 app_process，即malloc_debug 只针对 app_process 这个进程生效 adb shell setprop libc.debug.malloc.options "\"backtrace front_guard=16 rear_guard=16 backtrace_dump_prefix=/sdcard/Download/heap"\" 1.2 malloc_debug 的 options // bionic/libc/malloc_debug/Config.h constexpr uint64_t FRONT_GUARD = 0x1; // 设置前置保护区，用于检测内存越界访问 constexpr uint64_t REAR_GUARD = 0x2; // 设置后置保护区，用于检测内存越界访问 constexpr uint64_t BACKTRACE = 0x4; // 打印堆栈信息 constexpr uint64_t FILL_ON_ALLOC = 0x8; // 内存分配时填充0xeb constexpr uint64_t FILL_ON_FREE = 0x10; // 内存释放时填充0xef constexpr uint64_t EXPAND_ALLOC = 0x20; // 增加额外的内存 constexpr uint64_t FREE_TRACK = 0x40; // 记录内存释放信息 constexpr uint64_t TRACK_ALLOCS = 0x80; // 记录内存分配信息 constexpr uint64_t LEAK_TRACK = 0x100; // 记录内存泄漏信息 constexpr uint64_t RECORD_ALLOCS = 0x200; // 记录线程的内存分配与释放信息 constexpr uint64_t BACKTRACE_FULL = 0x400; // 以Java frames展开 constexpr uint64_t ABORT_ON_ERROR = 0x800; constexpr uint64_t VERBOSE = 0x1000; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e410c17ade307f6a433be12759a9daf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/778ccbd7eeb02faf63c13c73af2db0a9/" rel="bookmark">
			2024统计建模：大数据与人工智能时代的统计研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 题目解读你需要具备的知识点课题推荐视频分析 题目解读 主要做的是“大数据”与“人工智能”。
其中“大数据”所涉及的的第一个就是大量的数据，数据从哪里来？拿到数据后，我们需要做基本的数据分析，如何对大量的数据进行合适的处理？数据处理规整后，如何分析,用什么算法进行建模？
接着说道“人工智能”，这个可能和前面大数据中的算法建模类似，我们需要在这里把它升华到"深度学习“，”时间序列“等。在我看来，大数据主要涉及的是机器学习，人工智能涉及的是深度学习。
你需要具备的知识点 在上面的解读中，我们提到”数据从哪里来？“，我们可能很难找到公开的数据用于研究。就算找得到，那就是已经被别人研究过了，你的课题可能就没多少新意了。因此，如果你想真的做一个具有价值的项目，你需要学习”爬虫“知识抓取自己想要的数据。推荐本人的爬虫著作：《Python网络爬虫入门到实战》，相信你一定用得到。
假设你已经完成数据搜集步骤，接下来你需要做的是数据处理和数据的算法建模。其中必备的肯定是Python的pandas和sklearn模块，如果你没有Python基础，你可能还需要学习相关环境搭建以及基本的知识。推荐本人的Python3零基础到机器学习实战著作：《Python3编程从零基础到实战》
接下来，你可能还需要学习深度学习完成更高阶的模型训练，其中主要用到的为tensorflow和pytorch，优选tensorflow。这块需要学习的知识众多，我推荐大家学习我免费提供的大量深度学习项目代码，自己拿下来跑几个感受下就差不多：tensorflow
接着你可能依然无法短时间完成这样的课题，你可能需要一个高级的助手辅助你完成代码开发，这里我依然推荐自己开发GPT4站点：ChatGPT4.0国内站
基于这样的全套知识和工具，基本能辅助大家完成任意的数学建模比赛以及毕业论文等。
课题推荐 主要涉及：健康，金融，安全，教育，工业等领域
以下是我认为推荐到几篇文章，希望对大家有所启发。
知网原文：人工智能技术在金融风控中的应用研究知网原文：知识产权视域下非法获取商业大数据的刑法规制知网原文： 基于知识图谱的图书馆大数据应用分析知网原文：基于大数据的师范生数据素养培育路径知网原文：基于大数据分析的非侵入式电力负荷数据分类知网原文：煤矿瓦斯灾害大数据智能识别与预警方法等等… 上述仅仅是我初步的一些建议和找的相关文献，并不唯一。欢迎大家与我一起探讨交流方案：2024数学建模学习交流
视频分析 见我B站更新：川川菜鸟
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67003c56a9ff638f9dea25f54d7f68c1/" rel="bookmark">
			JavaScript变量及数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
概述：
变量：
前言：
变量的命名：
定义变量：
为变量赋值：
变量提升：
let和const关键字：
JS数据类型：
前言：
typeof操作符：
JS基本数据类型：
String（字符串）：
Number（数值）：
Boolean（条件）：
Null（空）：
Undefined（未定义）：
Symbol（独一无二）：
JS引用数据类型：
Object（对象）：
Array（数组）：
Function（函数）：
概述： 在JavaScript中我们可以使用变量来存储数据，而我们存储的数据又可以分为：字符串，数字，布尔值，数组等，并可以更改变量的值，因为变量如其名可变的量。数据类型，指的是对数据进行操作时数据的类型，不同的数据可以使用不同的类型来存储，如123这个数值，或者'字'文本等等。如下图所示：JavaScript简介-CSDN博客 还可以参考：C语言操作符和数据类型的存储详解_f2(&amp;b)运算的是主函数还是调用函数-CSDN博客
变量： 前言： 在编程中我们要对数据进行操作就很难离开变量这个东西，因为我们得有数据才能对数据进行操作而有数据，数据又该放到哪里，所以就使用变量来存储数据，变量可以存储字符串("abc"),数字(123),布尔值(true,false)，数组等等，并且我们可以随时读取变量的值，和修改变量的值。变量是一个可变的量。
变量的命名： 在JavaScript我们若想定义变量，那就需要遵循以下命令规则。如下：
变量名中可以有数字（134），字母（abcd），下划线（_），美元符（$）.变量名中不能出现中文(不能使用中文)。变量名中不能包含空格(如：a b 这种是错误的)。变量不能是JavaScript中的关键字，保留字(如：var var)。变量名不能以数字开头，如:(1abd 错误 ) (ab1 正确)。 我们在定义变量的时候，要使变量有意义，这样更容易让他人看懂，如name就是名字意思我们可以使用这个变量来存储名字，不能是awe这样用这个来存储名字，这样虽然并无问题，但是别人看不明白你这玩意存的是啥。
定义变量： 在JavaScript中我们可以使用var关键字来定义变量，其语法格式如下：
var 变量名;
如下几个例子：
var name;//定义了变量name var age;//定义了变量age var gender;//定义了变量gender 定义变量时，可以一次定义几个变量，或者一次一个的定义(如上)，如果一次要定义多个变量，那么变量名之间要使用逗号,进行分开，如下所示：
var name,age,gender;//一次性定义了多个变量 定义完变量后，如果没有赋值，那么变量的默认值会是undefined(未定义)。
为变量赋值： 我们定义变量的时候，可以使用等于号=来给变量赋值，等号左边是变量的名字，等号右边是变量的值，如下所示：
var age=15;//定义了age变量，并赋予了初始值15 我们定义完变量之后也可以使用=等于号来给变量赋值，等号左边是变量的名字，等号右边是变量的值，如下所示：
var age;//定义了变量age age=20;//给变量age赋值20 变量提升： JavaScript在预编译期会先预先处理声明的变量，但是变量的赋值操作发生在JavaScript执行期，而不是预编译期。
document.write(name);//打印name变量里面的值 name = "wee";//给name变量赋予一个值：wee document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67003c56a9ff638f9dea25f54d7f68c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35ae848e008d4e4e682c9e83c25e5815/" rel="bookmark">
			新测试基准发布，最强开源Llama 3尴尬了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		梦晨 发自 凹非寺
量子位 | 公众号 QbitAI 如果试题太简单，学霸和学渣都能考90分，拉不开差距……
随着Claude 3、Llama 3甚至之后GPT-5等更强模型发布，业界急需一款更难、更有区分度的基准测试。
大模型竞技场背后组织LMSYS推出下一代基准测试Arena-Hard，引起广泛关注。
Llama 3的两个指令微调版本实力到底如何，也有了最新参考。
与之前大家分数都相近的MT Bench相比，Arena-Hard区分度从22.6%提升到87.4%，孰强孰弱一目了然。
Arena-Hard利用竞技场实时人类数据构建，与人类偏好一致率也高达89.1%。
除了上面两个指标都达到SOTA之外，还有一个额外的好处：
实时更新的测试数据包含人类新想出的、AI在训练阶段从未见过的提示词，减轻潜在的数据泄露。
并且新模型发布后，无需再等待一周左右时间让人类用户参与投票，只需花费25美元快速运行测试管线，即可得到结果。
有网友评价，使用真实用户提示词而不是高中考试来测试，真的很重要。
新基准测试如何运作？ 简单来说，通过大模型竞技场20万个用户查询中，挑选500个高质量提示词作为测试集。
首先，挑选过程中确保多样性，也就是测试集应涵盖广泛的现实世界话题。
为了确保这一点，团队采用BERTopic中主题建模管道，首先使用OpenAI的嵌入模型（text-embedding-3-small）转换每个提示，使用 UMAP 降低维度，并使用基于层次结构的模型聚类算法 (HDBSCAN) 来识别聚类，最后使用GPT-4-turbo进行汇总。
同时确保入选的提示词具有高质量，有七个关键指标来衡量：
具体性：提示词是否要求特定的输出？
领域知识：提示词是否涵盖一个或多个特定领域？
复杂性：提示词是否有多层推理、组成部分或变量？
解决问题：提示词是否直接让AI展示主动解决问题的能力？
创造力：提示词是否涉及解决问题的一定程度的创造力？
技术准确性：提示词是否要求响应具有技术准确性？
实际应用：提示词是否与实际应用相关？
使用GPT-3.5-Turbo和GPT-4-Turbo对每个提示进行从 0 到 7 的注释，判断满足多少个条件。然后根据提示的平均得分给每个聚类评分。
高质量的问题通常与有挑战性的话题或任务相关，比如游戏开发或数学证明。
新基准测试准吗？ Arena-Hard目前还有一个弱点：使用GPT-4做裁判更偏好自己的输出。官方也给出了相应提示。
可以看出，最新两个版本的GPT-4分数高过Claude 3 Opus一大截，但在人类投票分数中差距并没有那么明显。
其实关于这一点，最近已经有研究论证，前沿模型都会偏好自己的输出。
研究团队还发现，AI天生就可以判断出一段文字是不是自己写的，经过微调后自我识别的能力还能增强，并且自我识别能力与自我偏好线性相关。
那么使用Claude 3来打分会使结果产生什么变化？LMSYS也做了相关实验。
首先，Claude系列的分数确实会提高。
但令人惊讶的是，它更喜欢几种开放模型如Mixtral和零一万物Yi，甚至对GPT-3.5的评分都有明显提高。
总体而言，使用Claude 3打分的区分度和与人类结果的一致性都不如GPT-4。
所以也有很多网友建议，使用多个大模型来综合打分。
除此之外，团队还做了更多消融实验来验证新基准测试的有效性。
比如在提示词中加入“让答案尽可能详尽”，平均输出长度更高，分数确实会提高。
但把提示词换成“喜欢闲聊”，平均输出长度也有提高，但分数提升就不明显。
此外在实验过程中还有很多有意思的发现。
比如GPT-4来打分非常严格，如果回答中有错误会狠狠扣分；而Claude 3即使识别出小错误也会宽大处理。
对于代码问题，Claude 3倾向于提供简单结构、不依赖外部代码库，能帮助人类学习编程的答案；而GPT-4-Turbo更倾向最实用的答案，不管其教育价值如何。
另外即使设置温度为0，GPT-4-Turbo也可能产生略有不同的判断。
从层次结构可视化的前64个聚类中也可以看出，大模型竞技场用户的提问质量和多样性确实是高。
这里面也许就有你的贡献。
Arena-Hard GitHub：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35ae848e008d4e4e682c9e83c25e5815/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9a1d4c3e0cd268973c44604a9ee9774/" rel="bookmark">
			Android studio配置Flutter（看这一篇就够了）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flutter 是 Google 推出并开源的移动应用开发框架，主打跨平台、高保真、高性能。开发者可以通过 Dart 语言开发 App，一套代码同时运行在 iOS 和 Android平台。 Flutter 提供了丰富的组件、接口，开发者可以很快地为 Flutter 添加 Native（即原生开发，指基于平台原生语言来开发应用，flutter可以和平台原生语言混合开发） 扩展。
目录
1.下载Flutter SDK
2.使用镜像
3.在Windows上搭建Flutter开发环境
3.1配置环境变量
3.2运行 flutter doctor命令
3.3Android studio配置Flutter插件和Dart插件：
4.在Android studio新建Flutter项目：
4.1在Android studio点击File-&gt;New-&gt;New Flutter Project
4.2选择 Flutter application 作为 project 类型, 填写下载的Flutter SDK的路径，然后点击 Next。
4.3输入项目名称，然后点击 Create。
4.4 创建了一个Flutter项目 ​编辑 4.5运行结果
1.下载Flutter SDK 在Flutter官网：Make Android apps | FlutterArchive | FlutterMake Android apps | Flutter 下载
解压到本地目录：
2.使用镜像 由于在国内访问Flutter会受到限制，Flutter官网为中国开发者搭建了临时镜像，把以下环境变量添加到用户环境变量中：
export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9a1d4c3e0cd268973c44604a9ee9774/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/730650449657e3b55c72667c9691b933/" rel="bookmark">
			查询效率至少提高4倍的MySQL技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL语句中IN包含的值不应过多 MySQL对于IN做了相应的优化，即将IN中的常量全部存储在一个数组里面，而且这个数组是排好序的。但是如果数值较多，产生的消耗也是比较大的。再例如：select id from t where num in(1,2,3) 对于连续的数值，能用between就不要用in了;再或者使用连接来替换。
SELECT语句务必指明字段名称 SELECT*增加很多不必要的消耗(CPU、IO、内存、网络带宽);增加了使用覆盖索引的可能性;当表结构发生改变时，前断也需要更新。所以要求直接在select后面接上字段名。
当只需要一条数据的时候，使用limit 1 这是为了使EXPLAIN中type列达到const类型
如果排序字段没有用到索引，就尽量少排序
如果限制条件中其他字段没有索引，尽量少用or
or两边的字段中，如果有一个不是索引字段，而其他条件也不是索引字段，会造成该查询不走索引的情况。很多时候使用union all或者是union(必要的时候)的方式来代替“or”会得到更好的效果。
尽量用union all 代替 union union和union all的差异主要是前者需要将结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的CPU运算，加大资源消耗及延迟。当然，union all的前提条件是两个结果集没有重复数据。
不使用ORDER BY RAND() SELECT id FROM `dynamic` ORDER BY rand( ) LIMIT 1000; 上面的SQL语句，可优化为：
SELECT id FROM `dynamic` t1 JOIN ( SELECT rand( ) * ( SELECT max( id ) FROM `dynamic` ) AS nid ) t2 ON t1.id &gt; t2.nid LIMIT 1000; 区分in和exists、not in和not exists SELECT * FROM 表 A WHERE id IN ( SELECT id FROM 表 B ) 上面SQL语句相当于
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/730650449657e3b55c72667c9691b933/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcb4eedac849ef63b837686bc15a8d52/" rel="bookmark">
			芋道SpringBoot配置Maven、创建SpringBoot项目、创建Web接口、读取配置信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌹作者主页：青花锁 🌹简介：Java领域优质创作者🏆、Java微服务架构公号作者😄
🌹简历模板、学习资料、面试题库、技术互助
🌹文末获取联系方式 📝
系列文章目录 第一章 芋道 Spring Boot 快速入门
文章目录 系列文章目录前言1、芋道网站2、下载和安装maven工具3、第一个SpringBoot 项目3.1、初始化项目3.2、配置maven3.3、启动项目3.4、定义一个hello world接口3.4.1、在Controller包下创建类，并编写hello world接口3.4.2、通过浏览器访问接口 3.5、解决接口跨域问题3.5.1、类或方法解决接口跨域问题3.5.2、配置全局跨域 4、接收参数4.1、通过HttpServletRequest 接收参数4.2、通过@RequestParam接收参数4.3、通过@PathVariable 接收参数4.4、通过@RequestBody 接收参数 5、starter机制6、YAML标记语言6.1、application.properties6.2、application.yml6.2.1、YAML 简介6.2.2、YYAML 支持以下三种数据结构6.2.2.1、对象：键值对的集合6.2.2.2、数组：一组按次序排列的值6.2.2.3、字面量：单个的、不可拆分的值 7、配置文件与JavaBean绑定7.1、使用 @ConfigurationProperties 注解7.2、使用 @Value 注解7.3、@Value 与 @ConfigurationProperties 对比7.3.1、 使用位置不同7.3.2、功能不同7.3.3、松散绑定支持不同@ConfigurationProperties：支持松散绑定（松散语法），例如实体类 Person 中有一个属性为 firstName，那么配置文件中的属性名支持以下写法：7.3.4、 SpEL 支持不同7.3.5、复杂类型封装7.3.6、应用场景不同 7.4、非application配置文件 往期热门专栏回顾 前言 芋道 SpringBoot是一款国产的SpringCloud微服务框架，包括Outh2.0、微服务网关、微服务注册中心、配置中心、消息队列、任务调度、链路追踪、服务保障等。
今天介绍下芋道 SpringBoot入门，包括SpringBoot介绍、第一个SpringBoot案例，所需要下载安装的基础工具等。
1、芋道网站 源码分析首页：https://www.iocoder.cn/
芋道 SpringBoot快速入门章：https://www.iocoder.cn/Spring-Boot/quick-start/?github
下面是我自己整理的Spingboot、微服务学习专栏，从Spingboot 零基础到微服务实战。
SpringBoot框架学习专栏：https://blog.csdn.net/s445320/category_12273537.html
SpringCloud微服务学习专栏 :https://blog.csdn.net/s445320/category_12439818.html
微服务实战专栏：https://blog.csdn.net/s445320/category_12345409.html
2、下载和安装maven工具 https://maven.apache.org/download.cgi
常用版本3：https://dlcdn.apache.org/maven/maven-3（只有最新的几个版本）
更新下载站：https://archive.apache.org/dist/maven/maven-3/ （包含从3.0 到 3.9的大多数版本）
下载解压，修改conf下的setting.xml,优先从阿里云镜像拉取关联包
&lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcb4eedac849ef63b837686bc15a8d52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1862eaf0d838d48ddb0790bf02f70abb/" rel="bookmark">
			.Net4.0 Web.config 配置实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
关于 Web.config
运行环境
配置实践
请求验证模式兼容旧版本
上传文件限制
Request.Path危险值配置
全站应用UTF-8编码
设置日期格式
每个会话的限制并发请求数
正常运行指定扩展名的文件
Json字符串超出最大长度限制
控件早期版本的呈现方式
C# 操作 Web.config
小结
关于 Web.config 当通过.NET 新建一个Web应用程序项目后，默认情况下会在根目录自动创建一个默认的Web.config文件，其是一个XML文本文件，内容包括运行应用默认的所有运行基础配置。
除根目录外，可以每个要特殊配置的子目录下新建一个Web.config文件。它可以在继承父目录的配置信息以外，可以自定义重写或修改父目录中定义的设置。
在应用运行时对 Web.config 文件的修改不需要重启服务就可以生效，因此请注意正确的修改内容，否则会引起应用站点异常并报错。
Web.config 文件可以自定义配置进行扩展，通过自定义配置参数，满足我们日常对应用程序的其它配置需求。
运行环境 操作系统： Windows Server 2019 DataCenter
.net版本： .netFramework4.0 或以上
编辑工具：VS2019 或其它任何文本编辑器
配置实践 请求验证模式兼容旧版本 请求验证模式定义了如何处理客户端请求中的输入内容的安全性，我们运行的是 .netFrameword 4.7.1 版本，为保证兼容性，最好配置
&lt;system.web&gt; &lt;httpRuntime requestValidationMode="3.5" /&gt; &lt;/system.web&gt; 上传文件限制 这是经常用到和遇到的一个问题，对于默认配置 maxRequestLength 一般仅允许上传不超过4Mb的文件，我们可以通过修改下列配置节：
&lt;system.web&gt; &lt;httpRuntime maxRequestLength="20480000" /&gt; &lt;/system.web&gt; 我们还可以配置些节点：
&lt;system.webServer&gt; &lt;security&gt; &lt;requestFiltering&gt; &lt;requestLimits maxAllowedContentLength="2147483647" /&gt; &lt;/requestFiltering&gt; &lt;/security&gt; &lt;/system.webServer&gt; 如果不起作用还可以配置如下节（如果存在）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1862eaf0d838d48ddb0790bf02f70abb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c2e09499759ea37d76790eee36390a8/" rel="bookmark">
			AIGC的崛起：定义未来内容创作的新纪元
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌟文章目录 🌟AIGC简介🌟 AIGC的相关技术与特点🌟AIGC有哪些应用场景？🌟AIGC对其他行业影响🌟面临的挑战与问题🌟AIGC未来发展 🌟AIGC十大热门网站推荐：
文心一言：https://aigc.izzi.cn/sites/50.html
文心一格：https://yige.baidu.com/?aigc.izzi.cn
GoogleDeepMind：https://aigc.izzi.cn/go/?url=aHR0cHM6Ly9kZWVwbWluZC5nb29nbGUvP2FpZ2MuaXp6aS5jbg==
WPS AI：https://ai.wps.cn/?aigc.izzi.cn
OpenAI：https://openai.com/?aigc.izzi.cn
讯飞星火：https://xinghuo.xfyun.cn/?ch=nt_feb_D8rW2tI
字节即创：https://aic.oceanengine.com/login
ChatGPT：https://aigc.izzi.cn/sites/112.html
阿里通义：https://aigc.izzi.cn/sites/102.html
堆友AI绘画：https://aigc.izzi.cn/sites/42.html
🌟AIGC简介 AIGC官网：https://aigc.izzi.cn/
AIGC，全称为Artificial Intelligence Generated Content，即人工智能生成内容。它是指利用人工智能技术，如深度学习、自然语言处理（NLP）和计算机视觉等，自动生成各类文本、图像、音频和视频等多模态内容的过程，是继用户生产内容（UGC）、专业生产内容（PGC）之后新型利用AI技术自动生成内容的生产方式。AIGC的兴起，标志着人工智能技术在内容创作领域的广泛应用和深度融合。
🌟 AIGC的相关技术与特点 AIGC的核心技术原理是基于大量的数据训练和复杂的算法模型。它通过对大量文本、图像、音频和视频数据的分析，学习其中的模式和规律，然后通过构建神经网络模型，AIGC能够从大量数据中学习并生成新的内容。随着计算能力的提升和数据资源的日益丰富，AIGC技术得以快速发展。从最初的简单文本生成，到如今的图像、音频和视频等多模态内容创作，AIGC不断刷新着内容生成的边界。AIGC的特点包括高效性、创新性、多样性和个性化，可以快速地生成大量内容，同时保持一定的创意和独特性。
🌟AIGC有哪些应用场景？ AIGC的应用场景非常广泛，涵盖了新闻、广告、娱乐、教育、艺术等多个领域。以新闻为例，AIGC可以快速生成新闻报道、摘要和评论等内容，提高新闻生产的效率。在娱乐领域，AIGC可以生成音乐、画作、视频等，为创作者提供更多的灵感。在游戏领域，AIGC则可用于自动生成游戏场景、角色和对话等，丰富了游戏的可玩性和趣味性。
写作与编辑 AIGC写作编辑工具：
AIGC技术可以通过自然语言处理和机器学习算法，从大量的文本数据中学习和生成语言，从而快速高效地完成写作和编辑任务。比如，智能写作工具可以自动生成新闻报道、行业分析报告、小说、广告语等文本内容。此外，AIGC技术还可以进行文本校对、语法纠正、翻译等任务，提高文本的质量和可读性。
艺术与设计 AIGC设计工具：
AIGC技术可以用于生成具有特定风格和主题的图像、音频和视频等多媒体内容。例如，通过图像生成算法，可以生成具有特定风格和主题的绘画作品、摄影作品和设计作品等。另外，AIGC技术也可以用于音乐制作、声音合成等领域，实现音乐和声音的自动生成。
语音合成 AIGC音频工具：
AIGC技术可以用于生成人工语音，从而用于语音助手、智能客服、虚拟人物等领域。通过语音合成算法，可以将文本转化为语音，从而实现语音的自动播放。目前，许多公司已经推出了基于AIGC技术的智能语音助手和智能客服系统。
视频生成 AIGC视频生成工具:
AIGC技术可以用于快速生成短视频、宣传片、动画片等视频内容。通过图像生成算法和视频处理技术，可以自动生成具有特定风格和内容的视频作品。此外，AIGC技术还可以用于视频修复、视频剪辑等领域，提高视频的质量和效果。
社交媒体 AIGC技术可以用于自动生成社交媒体平台的帖子、评论和回复等内容。通过自然语言处理和文本生成算法，可以自动学习和生成特定主题和风格的文本内容，并将其发布到社交媒体平台上。此外，AIGC技术还可以用于社交媒体平台的监控和分析，帮助企业了解用户行为和需求。
🌟AIGC对其他行业影响 AIGC的崛起对内容创作行业产生了深远的影响。首先，它极大地提高了内容生产的效率，降低了成本。其次，AIGC丰富了内容的形式和多样性，为创作者提供了更多的灵感和选择。AIGC也加速了内容传播的速度，使信息更加快速、广泛地传播。随着技术的不断进步，AIGC将在未来成为内容创作领域的重要力量，为行业带来更多的机遇和挑战。
🌟面临的挑战与问题 尽管AIGC具有巨大的潜力和优势，但它也面临着一些挑战和问题。其中包括技术难题，如何保证生成内容的真实性和准确性；Al数据是人工智能和机器学习的基础，人工智能相关企业想要自身的算法能做到处理更多、更复杂的场景，需要收集海量标注数据来对算法模型进行不断训练与调优，AIGC算法的本质是基于深度神经网络模型，其对数据量的要求较高。AIGC在处理敏感和复杂问题时可能产生误导性信息，对社会造成不良影响。此外，AIGC还涉及到数据隐私和伦理道德等问题，需要加以关注和规范，以及法律和监管问题，如如何制定相应保存的法规来规范AIGC的发展。
🌟AIGC未来发展 在未来，AIGC将继续在技术、应用等方面取得突破。在技术方面，随着深度学习、强化学习等技术的不断发展，AIGC将能够生成更加真实、自然和富有创意的内容。在应用方面，AIGC将进一步拓展其应用领域，如教育、医疗、娱乐等，为更多行业提供智能化内容解決方案。在商业模式方面，AIGC将与社交媒体、电商平台等结合，形成更加多元化的商业生态，AIGC将迎来更加广阔的发展前景。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9f60d90dac8af6739baee7af43af0e3/" rel="bookmark">
			图文详解Redis中常见的缓存问题及解决方案：缓存更新策略，缓存穿透，缓存雪崩，缓存击穿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.缓存技术与Redis
Redis作为缓存的原因
二.缓存更新策略
场景示例
三.缓存问题
缓存穿透
解决方案：缓存空对象
解决方案：布隆过滤
缓存雪崩
解决方案
缓存击穿
解决方案：互斥锁
解决方案：逻辑过期
一.缓存技术与Redis 缓存是计算机中的一种技术，用于存储临时数据，以便在后续访问相同数据时能够更快地获取。在数据被缓存后，将会被存储在一个临时的快速存储介质中，例如计算机内存或专门的高速缓存存储器中。
缓存可以减少对慢速存储介质（如硬盘或网络）的访问次数，从而提高系统的响应速度和性能。当需要访问某个数据时，计算机首先会检查缓存中是否存在该数据。如果存在，就可以直接从缓存中获取，而无需访问慢速存储介质。如果缓存中不存在该数据，计算机则会从慢速存储介质中读取，并将数据存入缓存中，以便后续的访问。
Redis作为缓存的原因 对于Web开发来说，缓存的实现是必要的。首先，频繁的直接操作数据库是不好的，一是速度慢效率低，二是可能会带来很多隐形的问题。
为了解决这些问题，我们就可以通过Redis来实现对数据的缓存操作，我们知道Redis的读写操作是非常快的，基本上都在微秒级别，在数据请求和数据库之间，我们加上一层Redis的数据存储，将Redis作为数据的缓存区域，就可以大大提高系统整体的运行速度和性能。
将Redis作为缓存在Web系统中是已经是非常常见的做法，主要由以下几个原因：
性能高效：Redis是基于内存的数据库，读写速度非常快。它的数据结构设计和高效的持久化方式使得它在缓存场景下表现优秀，能够快速地响应大量请求。数据结构丰富：Redis支持多种数据结构，如字符串、哈希表、列表、集合、有序集合等，这使得它适用于各种不同的缓存需求。持久化支持：虽然Redis是内存数据库，但它支持将内存中的数据定期或者实时地持久化到磁盘上，确保数据的安全性和可靠性。高可用性：Redis支持主从复制和哨兵模式，可以构建高可用性的集群架构，提供数据的备份和故障转移功能，保证系统的稳定运行。丰富的功能：除了作为缓存外，Redis还提供了许多其他功能，如发布订阅、事务、Lua脚本等，可以满足各种不同的业务需求。 二.缓存更新策略 当我们将数据放入缓存之后，我们就需要考虑数据的存储策略，因为我们的缓存并不是无限大的，当我们不断的将新数据放入缓存，缓存所剩余的空间就会越来越小，面对这样的情况，我们有俩种解决方案：
增加缓存空间的大小合理规划数据的存储，合理更新缓存中的数据 第一种方案在一定程度上确实可以缓解我们的压力，但是这是解决不了根本问题的，因为数据是无限的，我们不可能将数据库中的数据完全同步在缓存空间中，这样也会失去缓存空间原本的意义。因此，合理规划数据的存储就成了最正确的选择，也就是选择缓存更新策略。
常见的缓存更新策略包括：
缓存失效策略：当数据更新时，直接将缓存中对应的数据删除，下次访问时重新加载最新数据到缓存中。这种策略简单直接，但可能会导致缓存雪崩问题（大量缓存同时失效，导致数据库压力增大），因此可以考虑在删除缓存时加上随机的失效时间，使得缓存失效的时间分散开来，减少雪崩的概率。定期刷新策略：定期地（例如每隔一段时间）刷新缓存中的数据，保持缓存数据与数据库中的数据同步。这种策略能够一定程度上减轻缓存失效带来的压力，但可能导致缓存中的数据不是最新的。基于事件驱动的主动更新策略：当数据更新时，发布一个事件通知缓存系统，使得缓存系统能够及时更新对应的缓存数据。这种策略能够保证缓存数据的及时更新，但需要在系统中引入事件机制。读写分离策略：将缓存中的数据与数据库中的数据分开存储，读操作优先从缓存中获取数据，写操作则更新数据库并删除或者更新缓存中的数据。这种策略可以有效减轻数据库的压力，但需要保证缓存中的数据与数据库中的数据保持一致。淘汰策略：当缓存空间不足时，根据一定的策略淘汰一部分缓存数据，以腾出空间存储新的数据。常见的淘汰策略包括最近最少使用（LRU）和最少使用（LFU）等。 对于缓存更新策略的探索一直是企业发展中必须直视的难题，相关的技术和理论也在不断的发展，至于如何选择缓存更新策略，则需要根据具体的业务场景来定制。
比如在对一致性需求要求较低的业务场景下，我们就可以合理使用淘汰策略，当空间不足的时候淘汰掉一部分缓存数据，将新的缓存数据存入；而在对一致性需求要求较高的业务场景下，我们往往可以结合多种缓存更新策略，将他们组合起来使用，以得到更高效的运作方式。这些策略看似简单，但研究起来其中却大有门道。
场景示例 假如我们现在有一个查询关键数据的业务需要执行，对数据的一致性也有所要求。我们可以做出如下策略：在进行查询业务的时候，在修改数据库的数据的同时更新缓存，然后对于缓存的数据，我们也给出一个时间限制，当超过时间限制的时候，我们就让这块数据在缓存中失效，删除这块缓存数据。
对于这样的缓存更新策略，我们还有些许问题需要考虑：
操作缓存是删除缓存还是更新缓存？如何保证缓存和数据库中数据的一致性？ 如果是每一次操作数据库的时候我们都对缓存中的数据进行更新，就会导致出现很多无重复操作，因此我们一般选择在更新数据库的时候让缓存失效，查询的时候再更新缓存。而我们为了保证缓存和数据库的一致性，往往需要引入事务机制，对于一些分布式的方案我们往往还需要诸如TCC这样的分布式解决方案。除了以上的问题，我们往往还得考虑缓存和数据库操作的线程安全问题... ...
因此，根据具体的业务流程来具体定制并仔细推敲是我们在选择缓存更新策略前必须要执行的一步。
三.缓存问题 前面介绍了缓存在企业开发中的基础用法和策略，而对于缓存技术所带来的一些问题也同样成为了面试中的的高频问题，常见的缓存问题诸如缓存穿透，缓存雪崩，缓存击穿等。
缓存穿透 缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样的缓存永远都不会生效，而这些请求最后都会到数据库中，造成了性能的极大损耗。严重的甚至直接会导致系统的崩溃。
笔者这里给出图示：
解决方案：缓存空对象 当查询的数据在数据库中不存在时，我们将这个空结果作为一个空值(null)缓存到Redis中，对于这个空值(null)，我们设置一段时间(TTL)后这个空值(null)失效过期。这样就可以大大的减轻数据库的压力，即使有恶意请求发起不存在的查询，在Redis中也会查询到对应的空结果并返回，这个值虽然没有意义，但是却可以避免进一步向数据库发起请求。
对于这样的解决方案
优点：实现简单，维护方便缺点：会造成额外的内存消耗，并且可能会造成短期的数据不一致 这里做出解释：假如空值(null)还没有过期的时候用户来查询这个值的，与此同时我们在数据库中插入了用户想要查询的值，用户就会从Redis中拿到这个空值(null)，而非用户想要查询的值，也就是缺点中所说的短期的数据不一致。
解决方案：布隆过滤 在缓存查询之前，先使用布隆过滤器判断该查询是否有可能存在于数据库中。如果布隆过滤器认为查询不存在，直接返回，避免真正去查询数据库，从而减轻数据库压力。这里的布隆过滤器并不是说真的记录了所有的数据，它只是通过一定的算法，对于数据库中的数据进行了哈希，使得它有能力去判断这个数据在数据库中是否存在。
对于这样的解决方案
优点：内存占用少，没有多余的key缺点：实现复杂，存在误判可能 缓存雪崩 缓存雪崩是指在同一时间段，大量的缓存key同时失效或者Redis服务宕机，导致大量请求同时到达数据库，从而给数据库带来非常大的压力。
为了解决或者避免这样的问题，我们做出相对应的对策，既然大量key同时失效就会导致雪崩，那我们就可以对于key的失效时间做出干预，使用随机的TTL来限制key的失效时间，避免他们同一时间失效；或者增加Redis的集群服务；又或者给业务添加多级缓存... ...
解决方案 我们做出总结如下：
设置不同的缓存失效时间：可以在缓存失效时间上加上一个随机值，使得缓存失效的时间分散开来，避免大量缓存同时失效。
使用多级缓存：可以将缓存分为多级，如本地缓存、分布式缓存等，不同级别的缓存设置不同的失效时间，当一级缓存失效时，可以尽量从其他级别的缓存中获取数据，减少对数据库的直接访问。
缓存预热：在系统启动或者数据更新时，预先将热点数据加载到缓存中，避免在高并发时才去加载数据导致缓存失效。
使用限流措施：在缓存失效后，可以对数据库的访问进行限流，避免大量请求同时访问数据库，可以采用队列等方式进行排队处理。
使用集群模式：利用Redis集群的高可用性，通过哨兵模式在主机宕机后立刻在从机中选择一台机器来顶替主机的工作。
使用备份缓存：可以设置备份缓存，当主缓存失效时，可以从备份缓存中获取数据，保证系统的稳定性。
缓存击穿 缓存击穿是指针对某个热点数据，它的key失效了，由于缓存中没有该数据，导致大量的请求直接打到数据库上，造成数据库瞬时压力过大的现象。与缓存雪崩不同的是，缓存击穿是针对某个特定的缓存键（Key）失效导致的问题，而不是整个缓存层失效。
举个例子来说，前些天小米汽车发布了，对于发售那一刻，全国各地大量的请求数据同时来访问小米汽车这一个商品，而这里的小米汽车也就是我们所说的热点数据key。
缓存击穿通常发生在如下场景下：某个热点数据的缓存过期，此时有大量的请求同时访问这个热点数据，由于缓存中没有该数据，每个请求都直接访问数据库，造成数据库瞬时压力过大。
在前文中，我们有说到缓存的更新策略，对于缓存中不存在的数据，我们会查询数据库然后重新载入缓存。而如果这个流程发生在一个热点数据的情景下，就可能会发生缓存击穿的问题。笔者这里给出一个图示例子：
如上图所示，在短时间内就会有大量的请求同时访问数据库中的某个热点数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9f60d90dac8af6739baee7af43af0e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eacc761b070bdb7d9dae9ff626d9c7b/" rel="bookmark">
			Android Studio超级详细讲解下载、安装配置教程（建议收藏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌专注于前后端、机器学习、人工智能应用领域开发的优质创作者、秉着互联网精神开源贡献精神，答疑解惑、坚持优质作品共享。本人是掘金/腾讯云/阿里云等平台优质作者、擅长前后端项目开发和毕业项目实战，深受全网粉丝喜爱与支持✌有需要可以联系作者我哦！
🍅文末三连哦🍅
👇🏻 精彩专栏推荐订阅👇🏻 不然下次找不到哟
前言 Android背景介绍 Android 是一个由 Google 开发的移动操作系统，它主要用于智能手机和平板电脑。Android 是目前全球使用最广泛的移动操作系统，因其开放性、灵活性和可定制性而受到用户和开发者的喜爱。
Android 的起源可以追溯到 2003 年，由 Andy Rubin、Rich Miner、Nick Sears 和 Chris White 在美国加利福尼亚州的帕洛阿尔托创立 Android 公司。2005 年，Google 收购了 Android 公司，并投入大量资源进行研发。2008 年，Android 1.0 版本正式发布，标志着 Android 开始在移动设备市场上崭露头角。
从那时起，Android 经历了多个主要版本的更新，如 Eclair、Froyo、Gingerbread、Ice Cream Sandwich、Jelly Bean、KitKat、Lollipop、Marshmallow、Nougat、Oreo、Pie、Android 10、Android 11 和 Android 12，不断完善其功能和性能，以适应不断变化的市场需求。
Android 在全球移动设备市场中的影响力不断增强，根据统计数据，Android 操作系统在全球智能手机市场的份额超过了 70%。其广泛的用户群体、丰富的应用生态系统和多样化的硬件选择都使其成为首选的移动操作系统。
除了智能手机市场，Android 也在其他领域取得了成功，如智能家居、智能穿戴、汽车信息娱乐系统等，展现了其无限的潜力和应用价值。
技术架构 Android 的技术架构主要分为四层：Linux 内核、系统库、应用框架和应用程序。
Linux 内核：作为 Android 的基石，提供了核心的系统功能，如进程管理、内存管理和网络驱动程序。
系统库：包括一系列的 C/C++ 库，提供了许多常用的系统功能，如图形渲染、数据库访问和文件系统操作。
应用框架：为开发者提供了创建应用所需的 API，如活动管理、视图系统和通知管理。
应用程序：运行在 Android 上的应用，可以是预装的系统应用或从 Google Play 商店下载的第三方应用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1eacc761b070bdb7d9dae9ff626d9c7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fb0526ec464e9242ddcf5a0420d2fa6/" rel="bookmark">
			【数据结构】顺序表：与时俱进的结构解析与创新应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到白刘的领域 Miracle_86.-CSDN博客 系列专栏 数据结构与算法 先赞后看，已成习惯 创作不易，多多支持！ 目录
一、数据结构的概念
二、顺序表（Sequence List）
2.1 线性表的概念以及结构
2.2 顺序表分类
2.2.1 顺序表和数组的区别
2.2.2 顺序表的分类
2.3 顺序表的实现
2.3.1 初始化
2.3.2 销毁
2.3.3 尾插
2.3.4 头插
2.3.5 尾删
2.3.6 头删
2.3.7 在指定位置插入
2.3.8 在指定位置删除
2.3.9 查找
2.4 总代码
2.4.1 SeqList.h
2.4.2 SeqList.c
一、数据结构的概念 数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。数据结构反映数据的内部构成，即数据由哪部分构成，以什么方式构成，以及数据之间存在的相互关系。
数据结构可以分为两类：线性数据结构和非线性数据结构。线性数据结构以线性的方式组织数据，例如数组、链表和栈。非线性数据结构是一种通过多个节点之间的关联来组织数据的方式，例如树和图。数据结构的选取和设计对于解决特定问题和提高算法效率非常重要。
我们可以将这个词拆分成“数据”和“结构”两部分。
什么是数据？数据可以是数字、文字、图像等。比如超市购物时的价格、数量，天气预报中的温度、湿度，或是社交媒体上的浏览量、点赞数，都是数据。它们为我们提供信息，帮助我们做出决策，让生活更加便捷。
什么是结构？当我们想要使用大量使用同类型的数据时，通过手动定义大量的独立的变量对于程序来说，可读性非常差，我们可以借助数组这样的数据结构将大量的数据组织在一起，结构也可以理解为组织数据的方式。
比如，想要在世界上找到“喜羊羊”的这只羊很难，但是我告诉你在青青草原找，那就特别好找。青青草原这一块地方就可以看成一个结构，有效地将羊群组织起来。
总结：
1.数据结构可以存储数据。
2.存储的数据能够方便查找。
那为什么我们需要数据结构呢？
在生活中，假如我们开了个餐馆，不借助排队的方式来管理客户，会导致客户就餐感受差、等餐时间长、餐厅营业混乱等情况。同理，程序中如果不对数据进行管理，可能会导致数据丢失、操作数据困难、野指针等情况。
良好的数据结构和算法设计对于确保程序的稳定性和效率至关重要。通过合理地组织和管理数据，我们可以提高程序的性能，减少错误，并为用户提供更好的体验。
我们曾学过最基础的数据结构：数组。
C语言中的百宝箱——数组（1）-CSDN博客
C语言中的百宝箱——数组（2）-CSDN博客
既然我们已经学过数组这种数据结构了，那我们还需要学其它的数据结构嘛？存在即合理，显然数组是有一定的局限性的。
假定数组有10个空间，已经使用了5个，向数组中插入数据的步骤应该是：
1. 求数组的长度（这里是10）。
2. 求数组的有效数据个数（这里是5）。
3. 判断数组是否已满（如果有效数据个数等于数组长度，则数组已满）。
4. 如果数组未满，向下标为有效数据个数的位置插入数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fb0526ec464e9242ddcf5a0420d2fa6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/617a8b29a312d20beb181c40504409ee/" rel="bookmark">
			离线数仓（五）【数据仓库建模】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今天开始正式数据仓库的内容了, 前面我们把生产数据 , 数据上传到 HDFS , Kafka 的通道都已经搭建完毕了, 数据也就正式进入数据仓库了, 解下来的数仓建模是重中之重 , 是将来吃饭的家伙 ! 以及 Hive SQL 必须熟练到像喝水一样 !
第1章 数据仓库概述 1.1 数据仓库概念 数据仓库 (dataware,简称 DW) 是一个为数据分析而设计的企业级数据管理系统。数据仓库可集中、整合多个信息源的大量数据，借助数据仓库的分析能力，企业可从数据中获得宝贵的信息进而改进决策。同时，随着时间的推移，数据仓库中积累的大量历史数据对于数据科学家和业务分析师也是十分宝贵的。
数据仓库必须具备存储 , 管理 , 分析和计算的能力 !
数据仓库并不是数据的最终目的地 , 而是提供给数据仓库下游的应用 !
1.2 数据仓库核心架构 Hive 一般都是用来作为我们数据仓库的主体 , 因为它具备数仓必备的存储 (底层是 HDFS , 所以可以存储海量数据) , 管理 (Hive 可以将我们 HDFS 中的数据映射成一张张的二维表) 以及分析计算 (Hive 支持通过 Hive SQL 来对二维表进行分析查询, 它的引擎可以是 MR / Tez / Spark)
业务系统: 就是企业当中支撑公司核心业务的系统 , 比如电商公司的核心就是电商业务系统 , 那么它产生的大量的业务数据(比如订单数据,用户信息数据等)和用户行为日志数据(比如点击某个按钮,收藏) 对我们数据的分析都是非常有意义的,都需要采集到数仓当中 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/617a8b29a312d20beb181c40504409ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13b6616b3b81b8128b3a766e558cff17/" rel="bookmark">
			【C&#43;&#43;】日期类Date（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥个人主页：Forcible Bug Maker
🔥专栏：C++
目录
前言
日期类
日期类实现地图
获取某年某月的天数：GetMonthDay
检查日期合法，构造函数，拷贝构造函数，赋值运算符重载及析构函数
日期类的+=day和+day
日期类的-=day和-day
前置++和后置++
前置--和后置--
比大小运算符的重载
日期-日期返回天数
暴力++法
直接相减法
const成员
流插入和流提取重载
友元（friend）
结语
前言 本篇主要内容：日期类的实现
上篇我们介绍了拷贝构造函数和赋值运算符重载两大类的默认成员函数，本篇将会介绍更多关于操作符重载的实例运用。日期类，是与日期相关的类，主要用于处理与日期和时间相关的操作。我们将在完善一个日期类的过程中加深对运算符重载的理解和运用。在理解操作符重载之后，最后两个默认成员函数学习起来也就不是什么大问题了。
日期类 日期类实现地图 在实现日期类之前，需事先要知道要实现哪些内容。我会给出一份类的指南，也就是成员变量和成员函数的声明，然后根据声明一步步实现其中的成员函数。在代码编写过程中，成员函数是可以直接定义在类内部的；但是在实际开发过程中，考虑到工程级项目的规模，一般采用声明和定义分离的方式经行类的实现。将声明统一放在 Date.h 中，把成员函数的定义统一放在 Date.cpp 中，道理跟C语言的声明定义分离一样。
#include&lt;iostream&gt; #include&lt;cassert&gt; using namespace std; class Date { // 友元 friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const Date&amp; d); friend istream&amp; operator&gt;&gt;(istream&amp; in, Date&amp; d); public: // 获取某年某月的天数 int GetMonthDay(int year, int month); // 检查日期是否合法 bool CheckDate(); // 全缺省的构造函数 Date(int year = 1900, int month = 1, int day = 1); // 拷贝构造函数 // d2(d1) Date(const Date&amp; d); // 赋值运算符重载 // d2 = d3 -&gt; d2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13b6616b3b81b8128b3a766e558cff17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81e4de5dd86a617d2fa5a2de8991bb9b/" rel="bookmark">
			Rust面试宝典第6题：快乐数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 编写一个算法，判断一个数n是不是快乐数。快乐数的定义如下：
对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。然后重复这个过程直到这个数变为 1，也可能是无限循环，但始终变不到1。如果这个过程的结果为1，那么这个数就是快乐数。如果n是快乐数 就返回 true；如果不是，则返回false。
示例 1：
输入：n = 19 输出：true 解释： 1^2 + 9^2 = 82 8^2 + 2^2 = 68 6^2 + 8^2 = 100 1^2 + 0^2 + 0^2 = 1 示例 2：
输入：n = 2 输出：false 解析 这道题主要考察的是算法设计与实现、循环与迭代、数据结构应用，以及对“快乐数”这一概念的理解和实现。具体来说，主要涉及以下几点。
1、算法设计与实现：解题者需要设计一个有效的算法来判断一个数是否为快乐数。这要求解题者对问题的本质有深入的理解，并能够将这些理解转化为可执行的代码。
2、循环与迭代：在处理数字的过程中，需要不断地重复计算平方和，直到满足终止条件（数字变为1或者进入循环），这要求解题者能够熟练使用循环和迭代结构。
3、数据结构应用：为了检测是否进入了循环，需要使用一个数据结构来存储已经出现过的数字。在这个问题中，哈希集合（HashSet）是一个理想的选择，因为它可以快速地检查一个元素是否已经存在。解题者需要熟悉这种数据结构的使用，并能够将其有效地应用于算法中。
4、对“快乐数”概念的理解：解题者需要理解“快乐数”的定义，即一个数通过不断将其各个位上的数字平方后求和，最终能够得到1，或者进入一个不包含1的循环，这个理解是设计算法的基础。
为了解决本题，我们可以使用一个哈希集合来跟踪在重复平方和过程中产生的所有数。算法的基本步骤如下。
1、初始化一个空的哈希集合来存储已经出现过的数字。
2、进入一个循环，每次循环都计算当前数字的每个位上的数字的平方和。
3、在计算平方和之前，检查这个数字是否已经在哈希集合中出现过。如果出现过，说明我们已经进入了一个循环，且这个循环不会导向数字1。因此，我们可以断定这个数字不是一个快乐数，返回false。如果没有出现过，将其添加到哈希集合中，并继续下一次循环，使用新计算的平方和作为当前数字。
4、如果在某次循环中，当前数字变为1，则说明我们找到了一个快乐数，返回true。
根据上面的算法思路，我们给出了下面的示例代码。
use std::collections::HashSet; pub fn is_happy(n: i32) -&gt; bool { let mut seen = HashSet::new(); let mut num = n; while num !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81e4de5dd86a617d2fa5a2de8991bb9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5a077f4205302d41a8389b9101bc458/" rel="bookmark">
			RK3588 &amp; Android13 调试RTL8852BS（WIFI&amp;BT）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近在搞广告机项目，用到RTL8852BS的模块，发现这个模块的相关文章比较少（大多都是AP的），虽然wifi-bt的调试都差不多，但是还是想记录一下调试的过程，做一下总结，如有错误之处，还望各位大佬指教！
平台：RK3588 &amp; Android13 &amp; kernel-5.10
模块芯片：RTL8852BS
接口：SDIO &amp; UART
内容：调试RTL8852BS模块的WiFi以及BT功能
一、WIFI 1. dst配置 调试的第一步，先根据原理图配置dts，让sdio可以扫描到模块，部分原理图如下：
sdio及wifi节点的相关配置
/* SDIO接口Wi-Fi专用配置： WIFI_REG_ON: Wi-Fi的电源使能PIN脚 */ sdio_pwrseq: sdio-pwrseq { compatible = "mmc-pwrseq-simple"; clocks = &lt;&amp;hym8563&gt;; // 外部时钟，蓝牙需要 clock-names = "ext_clock"; pinctrl-names = "default"; pinctrl-0 = &lt;&amp;wifi_enable_h&gt;; reset-gpios = &lt;&amp;gpio2 RK_PB5 GPIO_ACTIVE_LOW&gt;; /*跟电源使能状态恰好相反：高有效为LOW，低有效则为HIGH。切记：这个配置跟下面的WIFI,poweren_gpio是互斥的，不能同时配置！！！*/ /*特别注意：reset-gpios的GPIO_ACTIVE 配置跟poweren_gpio配置的电源使能状态恰好是相反的*/ }; /* Wi-Fi节点 */ wireless_wlan: wireless-wlan { compatible = "wlan-platdata"; wifi_chip_type = "rtl8852bs"; pinctrl-names = "default"; pinctrl-0 = &lt;&amp;wifi_host_wake_irq&gt;; WIFI,host_wake_irq = &lt;&amp;gpio2 RK_PB4 GPIO_ACTIVE_HIGH&gt;; //WIFI,poweren_gpio = &lt;&amp;gpio2 RK_PB5 GPIO_ACTIVE_HIGH&gt;; status = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5a077f4205302d41a8389b9101bc458/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9bb53f6c6cff7e59242299f372ab856/" rel="bookmark">
			基于Zookeeper 简单实现分布式任务协调组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优质博文：IT-BLOG-CN
一、什么是 Zookeeper ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。
它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。
二 、 分布式任务协调组件的需求是什么 【1】现在有名称为ECAS的应用并集群运行在两台服务器上，分别为ECAS_1和CAS_2。而我们希望有一个任务TASK_1可以在两台ECAS应用中的任何一个应用来运行，可以是ECAS_1也可以是ECAS_2。
【2】假设TASK_1运行在ECAS_1上，而此时ECAS_1所在的服务器由于某些原因宕机了，ECAS_2需要接管任务TASK_1，使其可以继续运行。
需求分析：
a) 任务TASK_1既可以运行在ECAS_1上，也可以运行在ECAS_2上，任务吭启动时，由ECAS_1和CAS_2竞争运行权
b) 当ECAS集群中某台服务器宕机了，原来运行在这台服务器上的ECAS运行的应用应该由另外一台接管运行
三、基于Zookeeper实现需求 【1】可能需要使用到的Zookeeper的特性：监听节点发化，当有节点被增加、删除、修改时，通知关注节点发化的客户端
【2】实现需求一
a) 在Zookeeper上新增ROOT/Tasks节点，用于存放任务子节点（PS：ROOT节点是根节点，用于存放本次功能实现相关的子节点）
b) 所有客户端客户端关注节点ROOT/Tasks的子节点变化情况。
1、当有节点被新增进来时，触发竞争任务执行权操作
2、当有节点被移除时，触发任务停止操作
c) 如何竞争子任务，Zookeeper提供了基于Version的乐观锁操作，多个客户端尝试修改任务节点的属性时，叧有一个客户端可以修改成功，修改成功的客户端既竞争到了任务的执行权
【3】实现需求二
a）在Zookeeper上新增ROOT/Workers节点，用于存放当前存活的客户端实例（PS：ROOT节点是根节点，用于存放本次功能实现相关的子节点）
b) 所有客户端在Workers节点下添加代表自身的临时子节点，在Zookeeper中，临时子节点的特性是，当所属客户端断开了与Zookeeper的连接，子节点会被移除。
c) 所有客户端关注节点ROOT/Workers的子节点发化情况
1. 当有新的节点添加进来时，表示集群中有新的客户端启动了
2. 当有节点被移除时，表示有客户端离开了集群，此时遍历ROOT/Tasks下所有子节点，接管离开客户端所属的任务。
【4】下面是一个简单的 Zookeeper上的节点层次图
四、更强大的分布式调组件 4.1 可灵活定制任务负载策略
4.2 宕机应用返回集群后，任务的重新负载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf04a3facc2ac2fa2dfa1ddf2ac966d5/" rel="bookmark">
			图像生成模型浅析（Stable Diffusion、DALL-E、Imagen）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言1. 速览图像生成模型1.1 VAE1.2 Flow-based Model1.3 Diffusion Model1.4 GAN1.5 对比速览 2. Diffusion Model3. Stable Diffusion3.1 Text Encoder3.2 Decoder3.3 Generation Model 总结参考 前言 简单学习下图像生成模型的相关知识🤗
以下内容来自于李宏毅老师的视频讲解
课程主页：https://speech.ee.ntu.edu.tw/~hylee/ml/2023-spring.php
视频链接：机器学习2023（生成式AI）
1. 速览图像生成模型 这节我们来讲图像生成模型，在开始之前呢，我们先讲图像生成有什么特别的地方，那图像生成有什么特别的地方呢？大家都知道俗话说一张图胜过前言万语，所以今天假设我们图像生成的任务是拿一段文字去生成一张图，比如说你把 “一只奔跑的狗” 这段文本丢给 Midjourney 然后它就会生成一张图给你
但是我们知道一张图胜过千言万语，如果要把一张图描述成文字那它可以描述的语句远比 “一只在奔跑的狗” 还要多，比如说这只狗奔跑的位置是在街道上或者这只狗是一只柯基，有很多的描述是不在你做图像生成的时候输入的文字里面的，所以你输入的文字只是千言万语的部分，在做图像生成的时候有很多部分不在人类输入的文字里面，机器需要进行大量脑补才能够生成好的图像。
那这就是图像生成跟文字生成比较不一样的地方，当然文字生成输入跟输出也不是一对一的关系，但是很多文字生成的任务比如说翻译，你一旦给定了输入的句子你输出的可能性其实是蛮有限的，但图像不一样，你给定一个句子它输出的可能性有非常多不同的样貌，也就是我们的输入只是输出的一小部分，机器需要大量的脑补才能够产生正确的结果，那等下我们要跟大家讲说这个需要进行大量脑补这件事造成模型的设计上有什么特别的地方
OK，那我们知道文字生成多采用 Autoregressive 的方法，那之前跟大家讲过在在文字生成的时候有两种策略，Autoregressive 各个击破或者是 Non-Autoregressive 一次到位的方法
那我们知道文字生成是这样，给定一个句子，不管你是像 GPT 一样通通都是 Decoder 还是一个 Sequence to Sequence 的 Model，给一个输入，一个句子，然后接下来你要输出一个机率的分布，然后根据这个机率的分布去做 sample 取出一个文字，根据取出来的文字再产生新的机率分布再取出新的文字，这样就可以产生一个回答的结果
那对于图像生成来说，其实直觉上你会觉得应该也可以套用几乎一模一样的做法，一个图像生成的模型应该可以是一段文字接下来它输出的这个 distribution 不是文字的 distribution 而是颜色的 distribution
比如绿色产生的机率是多少，黄色产生的机率是多少，通常用 Pixel 像素来表示，也就是说现在要画一只奔跑的狗，那你第一个像素中放红色像素的机率有多少，要放一个绿色像素的机率有多少
那我们知道说图像中的一个 Pixel 它是由 RGB 三个颜色组成的，而 RGB 分别又是由一个 0 到 255 的数字所表示的，所以按理说应该有 256x256x256 种不同的颜色，不过你实际在做图像生成的时候其实你也用不上那么多的颜色，你可以选个比如说 256 色其实往往就蛮足够的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf04a3facc2ac2fa2dfa1ddf2ac966d5/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/33/">«</a>
	<span class="pagination__item pagination__item--current">34/71</span>
	<a class="pagination__item pagination__item--next btn" href="/page/35/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>