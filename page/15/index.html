<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.126.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程学习者的博客">
		<meta property="og:url" content="https://bcxuexizhe.github.io/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="编程学习者">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e18001a0c6fe08053181240e2332faf/" rel="bookmark">
			前端报错npm ERR! cb() never called!问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境使用node版本v14.21.3，npm版本6.14.18 1.问题描述 1.1使用npm install后报错 npm ERR! cb() never called! npm ERR! This is an error with npm itself. Please report this error at: npm ERR! &lt;https://npm.community&gt; npm ERR! A complete log of this run can be found in: 2.解决问题过程 2.1看网上大部分的解决方式是： 删除 node_modules 目录，删除 package-lock.json 文件，清除缓存，再重新npm install，不过一般出现这个问题并不会生成 package-lock.json 文件
2.2网上还有部分的解决方式是： 使用npm uninstall -g npm更新npm版本来解决这个问题，不过我们一般会安装node和npm的匹配版本。
如果node和npm版本不匹配就会报这个问题
ERROR: npm v10.5.0 is known not to run on Node.js v14.21.3. This version of npm supports the following node versions: `^18.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e18001a0c6fe08053181240e2332faf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6da9031b7f65b239b9122f43966e4700/" rel="bookmark">
			【数据结构|C语言版】树、二叉树和堆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言1. 树1.1 树的概念1.2 树的表示1.3 树在实际中的运用1.4 树的实现 2. 二叉树2.1 二叉树的概念和结构2.2 二叉树的性质2.3 二叉树的存储结构2.4 二叉树的代码实现 3. 堆4. 二叉树顺序结构的实现5. 二叉树链式结构的实现结语 #include&lt;GUIQU.h&gt;
int main {
上期回顾: 【数据结构|C语言版】栈和队列
个人主页：C_GUIQU
归属专栏：【数据结构（C语言版）学习】
return 一键三连;
}
前言 各位小伙伴大家好！上次小编给大家讲解了数据结构中的栈和队列，接下来我们讲解一下树、二叉树和堆！
1. 树 1.1 树的概念 树（Tree）是一种抽象数据类型（ADT），用于模拟具有层次关系的数据集合。在树形结构中，数据以节点（Node）的形式存储，并且每个节点都可以有零个或多个子节点。以下是树相关的基本概念：
节点（Node）：树的基本单元，包含数据元素和指向其子节点的链接。根节点（Root）：树的最顶端节点，没有父节点。子节点（Child）：从某个节点延伸出的节点称为该节点的子节点。父节点（Parent）：如果一个节点拥有子节点，那么这个节点称为其子节点的父节点。叶节点（Leaf）：没有子节点的节点称为叶节点或终端节点。兄弟节点（Sibling）：共享同一父节点的节点互称为兄弟节点。节点的层（Level）：节点的层级从根节点开始定义，根节点为第一层，其子节点为第二层，以此类推。树的深度（Depth）或高度（Height）：树中节点的最大层级数称为树的深度或高度。树的深度通常从1开始计数，而树的高度通常从0开始计数。子树（Subtree）：树的任意节点及其后代节点构成的树称为该节点的子树。路径（Path）：从一个节点到另一个节点的序列，其中包含了经过的节点和边的序列。边（Edge）：连接两个节点的线段，表示节点之间的关系。度（Degree）：一个节点拥有的子节点数称为该节点的度。树的遍历（Traversal）：按照一定的顺序访问树中的所有节点。常见的遍历方法有：前序遍历（Preorder）、中序遍历（Inorder）和后序遍历（Postorder）。查找（Search）：在树中查找一个特定的节点。插入（Insertion）：向树中添加一个新的节点。删除（Deletion）：从树中移除一个节点。
树的应用非常广泛，例如在数据库、文件系统、组织结构、决策树、游戏AI等领域。树的不同类型包括二叉树、二叉搜索树（BST）、平衡树（如AVL树、红黑树）、堆（Heap）、B树、Trie（前缀树）等，每种类型都有其特定的用途和特性。 1.2 树的表示 树的数据结构可以用多种方式表示。以下是一些常见的树表示方法：
链接表示法： 节点和指针：每个节点通常由一个数据元素和多个指向其子节点的指针组成。对于二叉树，通常有两个指针，一个指向左子节点，另一个指向右子节点。结构体定义：在C语言中，可以使用结构体来定义树的节点。例如，一个二叉树的节点可以定义为：struct TreeNode { int data; struct TreeNode *left; struct TreeNode *right; }; 数组表示法： 顺序存储：对于完全二叉树或满二叉树，可以使用数组来表示。在这种表示法中，数组的第一个元素（通常索引为1）用于根节点，而节点的左子节点位于2*i的位置，右子节点位于2*i + 1的位置，其中i是节点在数组中的索引。紧凑表示：这种表示方法节省空间，但不适用于非完全二叉树，因为可能会浪费数组中的空间。 嵌套集合表示法： 左孩子右兄弟表示法：在这种表示法中，每个节点除了指向其第一个子节点的指针外，还包含一个指向其下一个兄弟节点的指针。这种表示法适用于多叉树。结构体定义：在C语言中，可以使用以下结构体来定义节点：struct TreeNode { int data; struct TreeNode *firstChild; struct TreeNode *nextSibling; }; 字符串表示法： 括号表示法：在这种表示法中，树被表示为一个括号嵌套的字符串，其中每个节点的子树被一对括号括起来。例如，二叉树的括号表示法可以是(A(B,C))，其中A是根节点，B和C是子节点。 图形表示法： 可视化工具：使用图形界面工具来绘制树的形状，使得树的结构更加直观。这在教学和文档中非常常见。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6da9031b7f65b239b9122f43966e4700/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5690b4bc8ca405452e32874d8690bb76/" rel="bookmark">
			精通C&#43;&#43; STL（一）：解开string类的面纱与高效应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
string的定义方式
string的插入
string的拼接
string的删除
string的查找
string的比较
string的替换
string的交换
string的大小和容量
string中元素的访问
string中运算符的使用
string中与迭代器相关的函数
string与字符串之间的转换
string中子字符串的提取
string中的getline函数
string的定义方式 string()：默认构造函数，创建一个空字符串。
string (const string&amp; str)：拷贝构造函数，创建一个新的字符串对象，它是给定字符串str的一个副本。
string (const string&amp; str, size_t pos, size_t len = npos)：从已存在的字符串str中提取子串构造新字符串。pos是开始位置的索引，len是要提取的字符数；如果省略或设为npos，则提取从pos到字符串末尾的所有字符。
string (const char* s)：从C风格字符串s构造字符串对象。
string (const char* s, size_t n)：从C风格字符串s的前n个字符构造字符串对象。
string (size_t n, char c)：创建一个长度为n，每个字符都为c的字符串。
template &lt;class InputIterator&gt; string (InputIterator first, InputIterator last)：这是一个模板构造函数，它接受一对迭代器（first和last），在这对迭代器所指定的范围内构造字符串。这使得可以从任何支持迭代访问的对象（如数组、容器等）中构造字符串。
代码演示：
#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { // 1. 默认构造函数 string strDefault; cout &lt;&lt; strDefault &lt;&lt; endl; // 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5690b4bc8ca405452e32874d8690bb76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64ab23115e979161338109f01b57d0ec/" rel="bookmark">
			基于SSM实现的新生报到系统源码&#43;数据库&#43;论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目简介 基于SSM实现的新生报到系统，主要分为五种用户角色，分别是：
学院管理员管理所有内容，涵盖了班级，专业，学院，学生，缴费以及宿舍等方面的信息，学院管理员可以统计缴费信息以及学生报到信息
宿舍管理员管理宿舍，查看入住宿舍的学生，管理学生，发布与维护消息通知财务管理员统计缴费信息，增删改学生缴费信息，管理学生和消息通知辅导员统计学生报到信息，管理班级和消息通知学生查询缴费信息，查看所有管理人员发布的消息通知 技术栈 后端框框：spring/springmvc/mybatis/jsp
前端框架：HTML/JavaScript/Css/layui/elementui
前后端分离：否
数据库：MySQL
运行环境：JDK8+MySQL5.6+Maven3.6+idea+
功能点 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f44986662078759c12090792e2a0c3e7/" rel="bookmark">
			【百度云盘项目实践(1)】：探索JSON与Bundle库的结合应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hello ！大家好呀！ 欢迎大家来到我的Linux项目实战系列之《【百度云盘项目实践】：探索JSON与Bundle库的结合应用》，在这篇文章中，你将会学习到json数据格式，bundle库内对文件进行压缩与解压缩的过程，以及手绘UML图来帮助大家来理解，希望能让大家更能了解网络编程技术！！！
希望这篇文章能对你有所帮助，大家要是觉得我写的不错的话，那就点点免费的小爱心吧！（注：这章对于高性能服务器的实现非常重要哟！！！）
目录
一.Json
1.1 json数据
JSON对象
JSON数组
JSON语法规则
JSON与C++的结合使用
1.2 Value实例
主要特性
常用操作
使用场景
1.3 json数据的序列化与反序列化
newStreamWriter()
newCharReader()
1.4 代码实例
二. bundle库 文件压缩：
文件解压：
一.Json 1.1 json数据 JSON（JavaScript Object Notation）是一种轻量级的数据交换格式。它基于JavaScript编程语言的一个子集，但因其文本格式清晰、易于解析和生成，被广泛用于数据交换和存储。JSON格式支持的数据结构包括对象（Object）和数组（Array）。
JSON对象 JSON对象是一个无序的键:值对集合。每个键值对中的键是一个字符串，后跟一个冒号，然后是值。值可以是字符串、数值、布尔值、数组、对象或null。例如：
{ "name": "张三", "age": 30, "isStudent": false, "courses": ["数学", "物理", "化学"], "address": { "city": "北京", "street": "长安街" } } 在这个例子中，name、age、isStudent、courses和address是键，它们对应的值分别是字符串、数值、布尔值、数组和另一个对象。
JSON数组 JSON数组是一个有序的值列表，可以通过索引访问。数组中的值可以是字符串、数值、布尔值、数组、对象或null。例如：
[ { "name": "张三", "age": 30 }, { "name": "李四", "age": 25 } ] 这个例子中，数组包含两个对象，每个对象都有name和age属性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f44986662078759c12090792e2a0c3e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea3e02e3c6640c0de81beb6e7d753e0f/" rel="bookmark">
			【开源】2024最新python豆瓣电影数据爬虫&#43;可视化分析项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目介绍 【开源】项目基于python+pandas+flask+mysql等技术实现豆瓣电影数据获取及可视化分析展示，觉得有用的朋友可以来个一键三连，感谢！！！
项目演示 【开源】2024最新python豆瓣电影数据爬虫+可视化分析项目
项目截图 首页
列表页
爬虫演示
项目地址 https://github.com/mudfish/python-douban-view
项目结构 核心模块 电影爬虫 """ 异步并发爬虫 """ # 本次运行获取的最大页数 MAX_PAGES = 5 # 进度控制文件 PAGE_PROGRESS_FILE = "page_progress.json" # 电影类型 MOVIE_TYPES = ["剧情", "喜剧", "动作", "爱情", "科幻", "动画"] # CSV文件名 CSV_NAME = "movie_data.csv" # CSV头 CSV_HEADS = [ "id", "movie_id", "title", "year", "directors", "casts", "rating", "cover", "country", "summary", "types", "lang", "release_date", "time", "url", ] # 上映日期匹配正则，剔除非数字和- RELEASE_DATE_REMOVE_RE = r"[^0-9-]" engine = create_engine("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea3e02e3c6640c0de81beb6e7d753e0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d35c9b2f62ace64bb201e660477145d/" rel="bookmark">
			使用fme工具把数据入到数据库中，如MySQL，Oracle，postgresql等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：打开安装好的fme data inspector工具，然后file下面的文件夹开始配置连接数据库的环境
第二步：forant这里选择数据库，我这里以postgresql为例，可以选择Oracle，mysql等
conaection这里就是选择下面的add database配置相关的数据库信息，比如连接信息等。
第三步：配置好相关信息，点击test测试一下连接，出现Successfully connected to database.就好了
第四步：上面配置完数据库后开始选择xlsx文件入库了，先打开fmework工具，然后选择2的按钮,
最后在3这里选择xlsx文件和配置。然后点击OK，注意如果你需要入csv文件或者其他的修改就行
注意哈，需要等这个红色的按钮变绿才是加载或者导入完成哈
第五步：选择1那个按钮，然后2的话就是刚才配置的数据库，然后下面就应该出现两个sheet1文件。
第六步：可以直接用拉线的方式把两个表快速建立联系，然后就可以点击绿色按钮导入数据了
需要注意哈：如果某个字段对应不是绿色的需要手动拉一下。可以设置表名称和字段长度。根据需要修改
修改表名称
修改字段长度和类型
第七步：就可以查表看到数据已经导入进来了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01996668a617db73937141019bb388d0/" rel="bookmark">
			ISSC-原神启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：
f12
python代码攻击Tomcat漏洞 import struct def pack_string(s): if s is None: return struct.pack("&gt;h", -1) l = len(s) return struct.pack("&gt;H%dsb" % l, l, s.encode('utf8'), 0) def unpack(stream, fmt): size = struct.calcsize(fmt) buf = stream.read(size) return struct.unpack(fmt, buf) def unpack_string(stream): size, = unpack(stream, "&gt;h") if size == -1: # null string return None res, = unpack(stream, "%ds" % size) stream.read(1) # \0 return res class NotFoundException(Exception): pass class AjpBodyRequest(object): # server == web server, container == servlet SERVER_TO_CONTAINER, CONTAINER_TO_SERVER = range(2) MAX_REQUEST_LENGTH = 8186 def __init__(self, data_stream, data_len, data_direction=None): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01996668a617db73937141019bb388d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9181d2cbf40f20366713cb6a794e677a/" rel="bookmark">
			Gin框架学习笔记(五) ——文件上传与路由中间件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件上传 单文件上传 这里我准备了一张图片,我们想要实现当我们上传了一个图片的时候，这张图片可以出现在服务器中我们指定的位置，图片如下：
我们可以基于Gin框架来实现我们上述的操作
package main import "C" import ( "fmt" "github.com/gin-gonic/gin" ) func main() { r := gin.Default() r.MaxMultipartMemory = 8 &lt;&lt; 20 // 8 MiB, r.POST("/upload", func(c *gin.Context) { file, _ := c.FormFile("file") fmt.Println(file.Filename) dst := "./Source/" + file.Filename c.SaveUploadedFile(file, dst) }) r.Run(":8080") } 编译运行:
保存上传文件 SaveUploadedFile函数
函数签名： func (c *Context) SaveUploadedFile(file *multipart.FileHeader, dst string) file:要保存的文件
dst:保存的路径
Create and Copy
这个方法其实也好理解，我们读取上传文件的内容,并且以这份文件的名字创建一个文件，将读到的内容储存到这个文件中，代码如下: package main import "C" import ( "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9181d2cbf40f20366713cb6a794e677a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/181f1886010248c99a9de61034d45795/" rel="bookmark">
			【大模型】Spring AI对接ChatGpt使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、spring ai介绍
2.1 什么是Spring AI
2.2 Spring AI 特点
2.3 Spring AI 为开发带来的便利
2.4 Spring AI应用领域
2.4.1 聊天模型
2.4.2 文本到图像模型
2.4.3 音频转文本
2.4.4 嵌入大模型使用
2.4.5 矢量数据库支持
2.4.6 用于数据工程ETL框架
三、Spring AI对接ChatGPT
3.1 前置准备
3.2 添加依赖
3.3 接入流程
3.3.1 配置文件
3.3.2 增加一个测试接口
3.3.3 接口测试
3.4 OpenAiChatClient 使用
3.4.1 call使用Prompt传递参数方式1
3.4.2 call使用Prompt传递参数2
3.5 OpenAiImageClient使用
3.5.1 其他参数传递使用情况
3.6 OpenAiAudioTranscriptionClient 使用
3.7 OpenAiAudioSpeechClient使用
四、Spring AI对接Ollama
4.1 Ollama介绍
4.2 Ollama本地部署
4.2.1 下载安装包
4.2.2 执行安装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/181f1886010248c99a9de61034d45795/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f2a2344224c98d6d927028845e5bdc0/" rel="bookmark">
			土家风景文化|基于SSM＋vue的土家风景文化管理平台的设计与实现(源码&#43;数据库&#43;文档)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		土家风景文化管理平台
目录
基于SSM＋vue的土家风景文化管理平台的设计与实现
一、前言
二、系统设计
三、系统功能设计 1平台功能模块
2管理员功能模块
3用户功能模块
四、数据库设计
五、核心代码 六、论文参考
七、最新计算机毕设选题推荐
八、源码获取：
博主介绍：✌️大厂码农|毕设布道师，阿里云开发社区乘风者计划专家博主，CSDN平台Java领域优质创作者，专注于大学生项目实战开发、讲解和毕业答疑辅导。✌️
主要项目：小程序、SpringBoot、SSM、Vue、Html、Jsp、Nodejs等设计与开发。
🍅文末获取源码联系🍅
基于SSM＋vue的土家风景文化管理平台的设计与实现 一、前言 土家风景文化管理平台是土家风景文化管理必不可少的一个部分。在风景文化管理的整个过程中，平台担负着最重要的角色。为满足如今日益复杂的管理需求，各类土家风景文化管理平台也在不断改进。本课题所设计的土家风景文化管理平台，使用java技术进行开发，它的优点代码不能从浏览器查看，保密性非常好，比其他的平台更具安全性。java还容易修改和调试，毕竟土家风景文化是在不断发展过程中，难免有更多需求，这点很重要。而且，本平台对土家风景文化的管理，是为了满足土家风景文化更深层次的需求。除了上述优势外，本平台还具有：查询迅速，搜索资料方便，可靠性强等等。
关键词：土家风景文化；java；可靠性。
二、系统设计 系统功能结构如图
三、系统功能设计 1平台功能模块 土家风景文化管理平台，在平台首页可以查看首页，热门景点，旅游线路，排行榜，网站公告，个人中心，后台管理，在线客服等内容，并进行详细操作；如图5-1所示。
图5-1平台首页界面图
用户注册，在用户注册页面通过填写用户账号，密码，确认密码，用户姓名，联系方式，邮箱，验证码等信息进行注册操作，如图5-2所示。
图5-2用户注册界面图
2管理员功能模块 管理员进行登录，进入平台前在登录页面根据要求填写用户名和密码，选择角色等信息，点击登录进行登录操作，如图5-7所示。
图5-7管理员登录界面图
3用户功能模块 用户登录进入土家风景文化管理平台可以对首页,个人中心,门票订单管理，景点评价管理等功能进行相应操作，如图5-12所示。
图5-12用户功能界面图
四、数据库设计 用户注册实体图如图4-2所示：
图4-2用户注册实体图
数据库表的设计，如下表：
表4-1：token表
字段名称
类型
长度
字段说明
主键
默认值
id
bigint
主键
主键
userid
bigint
用户id
username
varchar
100
用户名
tablename
varchar
100
表名
role
varchar
100
角色
token
varchar
200
密码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f2a2344224c98d6d927028845e5bdc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/346e13780987f388b56cbbb3e2e80aac/" rel="bookmark">
			人工智能视觉：基于OpenCV的人脸识别技术的深度解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🚀一、OpenCV简介🔥1. 安装 OpenCV 模块💥2. OpenCV 基本使用 🌈二、人脸检测🎬1. Haar 级联的概念🚀2. 使用 OpenCV 进行人脸检测🌈3. 视频中的人脸检测 🚀三、人脸识别🎬1. 基于 LBPH 的人脸识别 🚀一、OpenCV简介 OpenCV 的全称是 Open Source Computer Vision Library，是一个跨平台的计算机视觉库。OpenCV 是由英特尔公司发起并参与开发，以 BSD 许可证授权发行，可以在商业和研究领域中免费使用。OpenCV 可用于开发实时的图像处理、计算机视觉以及模式识别程序。该程序库也可以使用英特尔公司的 IPP 进行加速处理。
OpenCV 用 C++语言编写，它的主要接口也是 C++语言，但是依然保留了大量的 C 语言接口。该库也有大量的 Python、Java and MATLAB/OCTAVE（版本 2.5）的接口。这些语言的 API 接口函数可以通过在线文档获得。如今也提供对于 C#、Ch、Ruby、GO 的支持。
🔥1. 安装 OpenCV 模块 OpenCV 已经支持 python 的模块了，直接使用 pip 就可以进行安装，命令如下：
pip install opencv-python -i https://pypi.tuna.tsinghua.edu.cn/simple some-package
💥2. OpenCV 基本使用 ❤️读取图片
显示图像是 OpenCV 最基本的操作之一，imshow()函数可以实现该操作。如果使用过其他 GUI 框架背景，就会很自然第调用 imshow()来显示一幅图像。imshow()函数有两个参数：显示图像的帧名称以及要显示的图像本身。直接调用 imshow()函数图像确实会显示，但随即会消失。要保证图片一直在窗口上显示，要通过 waitKey()函数。waitKey()函数的参数为等待键盘触发的时间，单位为毫秒，其返回值是-1（表示没有键被按下）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/346e13780987f388b56cbbb3e2e80aac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31d418189308af79bfd07a3c6ff87332/" rel="bookmark">
			[JAVASE] 类和对象(四) - 多态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 多态的定义
1.1 基本概念
二. 多态的实现条件 2.0 基本介绍
2.1 向上转型 与 向下转型
2.1.1 向上转型
2.1.2 向上转型的方式
2.1.3 向下转型
2.2 重写 与 动态绑定
2.2.1 重写
2.2.2 重写的注意事项 2.2.3 静态绑定 与 动态绑定
三. 重写与重载的区别
重写:
重载:
四. 总结 一. 多态的定义 1.1 基本概念 多个不同的对象进行同一行为时, 所产生的结果不同.
以上三个类, 在子类 Rect 与 Cycle 中,重写了父类中的draw 方法. 在测试类 Test 中, 实现了向上转型.
至此, 多态的定义以及多态的实现条件 已经呈现, 接下来,详细的解读一下多态的三个实现条 件.
二. 多态的实现条件 2.0 基本介绍 多态的实现条件:
1. 在继承体系下
2. 实现向上转型
3. 实现重写 与 动态绑定 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31d418189308af79bfd07a3c6ff87332/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/004df8915c5efe0845dbb39e0358e25f/" rel="bookmark">
			轻松拿捏C语言——【保姆级·指针讲解】期末C语言＜指针＞急救包，全是干货，诚意满满！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🥰欢迎关注 轻松拿捏C语言系列，来和 小哇 一起进步！✊
🌈感谢大家的阅读、点赞、收藏和关注💕
目录👑
一、指针与内存🪐
二、指针变量 、取地址操作符&amp;和解引用操作符* 🌏
三、指针变量类型的意义🌔
1.指针变量类型不同决定了在解引用的时候能访问的字节数不同💛
2.指针变量类型决定了指针向前或向后的步长🧡
3.void*指针🩵
四、const修饰指针☀️
五、指针运算🌈
1、指针加减运算🌸
2、指针相减🌺
3、指针关系运算🌷
六、野指针🏵️
1.指针变量没有初始化
2.指针越界访问
3.指针指向的空间被释放掉了
七、传值调用与传址调用🌻
八、一维数组与指针🌼
1.数组名的理解
2.用指针访问数组
3.一维数组传参本质
九、指针数组🌙
1.定义 2.用指针数组模拟二维数组 十、字符指针变量 💙
十一、数组指针变量💜
1.定义
2.数组指针变量的初始化：
3、二维数组传参的本质： 十二、函数指针变量💗
1.定义
2.使用
3.两段代码
十三、函数指针数组💖
1.定义
2.区分两个数组，两个指针变量 3.函数指针数组用途——转移表
一、指针与内存 有一栋楼，里有200个房间，假如我们要去某个房间找某个人，然后他说他在C304，我们就能通过门牌号C304快速找到他所在房间。
在计算机中内存划分为一个个内存单元，每个内存单元也有编号，每个内存单元占1字节的空间大小，1字节又等于8个比特位
这相当于，内存就是一栋楼，每个内存单元就是一个房间，内存单元编号就是房间门牌号，房间里有8个床位。
内存单元编号==地址==指针
二、指针变量 、取地址操作符&amp;和解引用操作符* int a = 10;
这里创建了一个整型变量a，占四个字节，所以就会向内存申请四个字节大小的连续空间，每个字节的内存单元都有编号。
通过取地址符&amp; 我们可以得到a所占四个字节中 地址最小的内存单元 的地址，该地址就是变量a的地址
因为这四个字节的空间连续，我们得到了这一个地址，就能挨着访问另外的地址
拿到地址有什么用？
我们可以将地址存储在一个变量中，用来存储地址的这个变量就叫做指针变量
int a = 10;
int* b = &amp;a;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/004df8915c5efe0845dbb39e0358e25f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c328a997b6255d4c25dca0f2b7cdd024/" rel="bookmark">
			超级好用的C&#43;&#43;实用库之DNS解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💡 需要该C++实用库源码的大佬们，可扫码关注文章末尾的微信公众号二维码，或搜索微信公众号“希望睿智”。添加关注后，输入消息“超级好用的C++实用库”，即可获得源码的下载链接。
概述 DNS（Domain Name System，域名系统）是一种分布式数据库服务，用于将人们容易记忆的域名与计算机网络中用于寻址和定位的IP地址进行映射。在互联网上，每一台设备都有一个唯一的IP地址。但由于IP地址通常是一串难以记忆的数字，因此DNS系统应运而生，它提供了一种将人类可读的、具有一定逻辑结构的域名转换为IP地址的服务。
当用户在浏览器中输入一个网址时，实际上是触发了一个DNS解析过程，这个过程包括如下步骤。
查询本地DNS缓存：首先检查本机是否有该域名对应的IP地址记录。
递归查询：如果没有命中缓存，则请求发送到用户的ISP提供的本地DNS服务器，由本地DNS服务器负责发起递归查询流程，逐级向上询问根域名服务器、顶级域名服务器以及权威域名服务器，直到找到目标域名的IP地址。
响应并缓存：一旦权威域名服务器返回了域名对应的IP地址，这个信息会沿着查询路径返回给用户，并被沿途的DNS服务器缓存起来，以加快后续相同域名的查询速度。
CHP_DNS类 在C++中，获取DNS域名对应的IP地址通常不直接通过编写原始的DNS查询协议来实现（虽然理论上可以这样做），而是调用操作系统提供的网络库或API来进行解析。这是因为直接处理DNS协议细节相当复杂且容易出错，而操作系统和标准库已经封装好了这些功能。
gethostbyname函数和getaddrinfo函数用于获取域名对应的IP地址，但这两个函数都是阻塞的。在非阻塞的使用场景下，直接使用这两个函数不太合适。为了方便应用层使用，我们封装了异步DNS解析类CHP_DNS。CHP_DNS类是一个单实例类，从CHP_BaseThread类派生。CHP_DNS类的头文件，可参考下面的示例代码。
#pragma once #include &lt;string&gt; #include &lt;map&gt; #include "HP_BaseThread.h" #include "HP_Mutex.h" class CHP_DNS : public CHP_BaseThread { public: static void Open(); static CHP_DNS *&amp;Singleton(); static void Close(); unsigned int FetchIP(const char *pszIP); void DefetchIP(const char *pszIP); static int GetIP(const char *pszIP, unsigned int &amp;uiIP); protected: CHP_DNS(); virtual ~CHP_DNS(); virtual unsigned int Run(); private: typedef struct _TDNSInfo { _TDNSInfo() { uiIP = 0; uiLastGotTick = 0; uiLastActiveTick = 0; } unsigned int uiIP; unsigned int uiLastGotTick; unsigned int uiLastActiveTick; }TDNSInfo; typedef std::map&lt;std::string, TDNSInfo&gt; IPToDNSInfoMap; static CHP_DNS *m_pThis; IPToDNSInfoMap m_mapIPToDNSInfo; bool m_bMapChanged; CHP_Mutex m_mutexMap; }; CHP_DNS类导出了两个实例成员函数和一个静态成员函数，下面分别进行介绍。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c328a997b6255d4c25dca0f2b7cdd024/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adcabcfc264d425e848a3c6eb985cb93/" rel="bookmark">
			AIGC从入门到实战：基建：人工智能时代的变迁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 背景介绍 1.1 人工智能的黎明 人工智能，这个曾经只存在于科幻小说中的概念，如今已经深深地融入了我们的生活。从智能手机上的语音助手，到电商平台的个性化推荐，人工智能已经无处不在，悄然改变着我们的世界。
1.2 AIGC的崛起 近年来，随着深度学习技术的飞速发展，一种全新的人工智能内容创作方式——AIGC (Artificial Intelligence Generated Content) 悄然兴起。AIGC利用人工智能技术，自动生成各种形式的内容，例如文本、图像、音频、视频等等，为内容创作领域带来了前所未有的变革。
1.3 AIGC的基建：人工智能时代的基石 AIGC的蓬勃发展离不开坚实的技术基础设施，即AIGC的基建。AIGC的基建包括了数据、算法、算力和平台等多个方面，它们共同构成了AIGC发展的基石，为AIGC的应用落地提供了强有力的支撑。
2. 核心概念与联系 2.1 数据：AIGC的燃料 数据是AIGC的燃料，它为AIGC模型的训练提供了原材料。AIGC模型需要大量的、高质量的数据才能进行有效的学习，从而生成高质量的内容。
数据类型: AIGC所需的数据类型非常广泛，包括文本、图像、音频、视频等等。数据质量: 数据的质量对于AIGC模型的训练至关重要。高质量的数据可以帮助模型更好地理解内容的特征，从而生成更准确、更自然的内容。数据规模: AIGC模型通常需要大量的训练数据才能达到理想的效果。数据规模越大，模型的泛化能力就越强，生成的内容质量也就越高。 2.2 算法：AIGC的大脑 算法是AIGC的大脑，它决定了AIGC模型如何学习和生成内容。AIGC领域常用的算法包括：
深度神经网络 (DNN): DNN是一种强大的机器学习算法，它可以学习复杂的数据模式，并将其应用于内容生成。生成对抗网络 (GAN): GAN是一种特殊的深度神经网络，它由两个相互竞争的网络组成，一个网络负责生成内容，另一个网络负责判断内容的真实性。通过这种竞争机制，GAN可以生成非常逼真的内容。自然语言处理 (NLP): NLP是一种专门处理文本数据的算法，它可以理解文本的语义，并将其应用于文本内容的生成。 2.3 算力：AIGC的引擎 算力是AIGC的引擎，它为AIGC模型的训练和推理提供了计算能力。AIGC模型通常需要大量的计算资源才能进行有效的训练和推理。
GPU: GPU是一种专门用于图形处理的芯片，它具有强大的并行计算能力，非常适合用于AIGC模型的训练和推理。TPU: TPU是谷歌专门为深度学习设计的芯片，它具有更高的计算能力和效率，可以进一步加速AIGC模型的训练和推理。 2.4 平台：AIGC的舞台 平台是AIGC的舞台，它为AIGC的应用落地提供了基础设施和服务。AIGC平台通常提供以下功能：
模型训练: AIGC平台提供模型训练的工具和环境，用户可以使用平台提供的工具和数据来训练自己的AIGC模型。模型部署: AIGC平台提供模型部署的服务，用户可以将训练好的AIGC模型部署到平台上，并通过API接口调用模型进行内容生成。应用开发: AIGC平台提供应用开发的工具和SDK，用户可以使用平台提供的工具和SDK来开发基于AIGC的应用程序。 3. 核心算法原理具体操作步骤 3.1 深度神经网络 (DNN) 3.1.1 前馈神经网络 前馈神经网络是一种最基本的深度神经网络，它由多个神经元层组成，信息从输入层流向输出层，没有反馈连接。
操作步骤:
定义网络结构: 确定网络的层数、每层的神经元数量以及激活函数。初始化网络参数: 为网络中的每个连接赋予随机权重。前向传播: 将输入数据输入到网络中，计算每个神经元的输出值。计算损失函数: 将网络的输出值与真实值进行比较，计算损失函数值。反向传播: 根据损失函数值计算网络参数的梯度，并使用梯度下降算法更新网络参数。重复步骤 3-5: 直到网络收敛，即损失函数值不再下降。 3.1.2 卷积神经网络 (CNN) 卷积神经网络是一种专门用于处理图像数据的深度神经网络，它利用卷积操作来提取图像的特征。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adcabcfc264d425e848a3c6eb985cb93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55c890d838043bcd5547b67cfd7744c9/" rel="bookmark">
			AI机器学习实战|假设对NBA比赛结果进行预测，如何使用机器学习库（如scikit-learn）来构建一个基本的预测模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		专栏集锦，大佬们可以收藏以备不时之需：
Spring Cloud 专栏：http://t.csdnimg.cn/WDmJ9
Python 专栏：http://t.csdnimg.cn/hMwPR
Redis 专栏：http://t.csdnimg.cn/Qq0Xc
TensorFlow 专栏：http://t.csdnimg.cn/SOien
Logback 专栏：http://t.csdnimg.cn/UejSC
量子计算：
量子计算 | 解密著名量子算法Shor算法和Grover算法
AI机器学习实战：
AI机器学习实战 | 使用 Python 和 scikit-learn 库进行情感分析
AI机器学习 | 基于librosa库和使用scikit-learn库中的分类器进行语音识别
Python实战：
Python实战 | 使用 Python 和 TensorFlow 构建卷积神经网络（CNN）进行人脸识别
Spring Cloud实战：
Spring Cloud实战 |分布式系统的流量控制、熔断降级组件Sentinel如何使用
Spring Cloud 实战 | 解密Feign底层原理，包含实战源码
Spring Cloud 实战 | 解密负载均衡Ribbon底层原理，包含实战源码
1024程序员节特辑文章：
1024程序员狂欢节特辑 | ELK+ 协同过滤算法构建个性化推荐引擎，智能实现“千人千面”
1024程序员节特辑 | 解密Spring Cloud Hystrix熔断提高系统的可用性和容错能力
1024程序员节特辑 | ELK+ 用户画像构建个性化推荐引擎，智能实现“千人千面”
1024程序员节特辑 | OKR VS KPI谁更合适？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55c890d838043bcd5547b67cfd7744c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e5a26f68045cdc99a79681e0b9e2d6b/" rel="bookmark">
			websocket的压缩和wireshark如何解码tls
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. websocket的压缩
见Compression EXPERIMENTAL那一节。
官方文档：gorilla/websocket
2. 如何wireshark如何解码tls
下文中代码中去掉sudo。正常执行
Mac电脑安装配置Wireshark 抓包工具，解决Https无法抓包问题_mac winshark抓不到-CSDN博客
如果wireshark没有en0网卡的权限，导致报错无法抓包。可以参考下面这篇文章
https://www.cnblogs.com/rab3it/p/14980582.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfcbf0b27c52c18c550ba1171c83b91e/" rel="bookmark">
			大型语言模型现状发展分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大型语言模型（Large Language Models，简称LLMs）是一类使用深度学习技术训练的自然语言处理（NLP）模型，它们在大量的文本数据上进行训练，以理解和生成人类语言。这些模型通常具有数亿甚至数千亿个参数，使它们能够捕捉到语言的复杂性和细微差别。
上图显示了大型语言模型的出现引起的涟漪，可以分为六个带或区。随着这些涟漪的扩大，对产品和服务的要求和机会也随之而来。
其中一些机会已经被发现，一些还有待发现。我认为，与5区相比，6区作为产品被取代的危险更大。
第5区提供了更大的差异化机会、大量的内置知识产权和一流的用户体验，使企业能够利用LLM的力量。5区令人兴奋的发展包括量化、小语言模型、模型花园/中心和以数据为中心的工具。
区域 1 — 可用的大型语言模型
就LLM而言，本质上LLM是语言绑定的，然而，在图像、音频等方面已经引入了多模态模型或多模态。这种转变催生了一个更通用的术语，即基础模型。
除了模式的增加之外，大型商业提供商还实现了模型多样化，提供了更针对特定任务的多种模型。还提供了大量开源模型。开源模型的可用性和性能带来了简单的无代码托管选项，用户可以通过无代码方式选择和部署模型。
新的提示技术说明了如何增强模型性能，以及市场如何朝着利用数据发现、数据设计、数据开发和数据交付来实现这种水平的模型自治的场景发展。
区域2 — 一般用途案例
随着大型语言模型的出现，功能更加细分化……模型被训练用于特定任务。Models Sphere 和 Side 专注于知识问答；Meta 称之为 KI-NLP。像 DialoGPT、GODEL、BlenderBot 等模型则专注于对话管理。
还有一些模型专注于语言翻译、特定语言等。
LLMS的最新发展采用了一种模式，模型融合了这些特性，一个模型整合了大部分（如果不是全部）这些功能。除了这种令人震惊的表现之外，还可以使用不同的提示技术。
这里列出了LLMs的主要实现，文本生成包括摘要、改写、关键词提取等任务。
文本分析和 RAG 变得越来越重要，嵌入对于这些类型的实现至关重要。
语音识别，也称为 ASR，是将音频语音转换为文本的过程。任何 ASR 过程的准确性都可以通过称为字错误率 (WER) 的方法轻松测量。ASR 开放大量记录的语言数据供 LLM 培训和使用。
该区域的显着变化是：
知识回答和知识密集型 NLP (KI-NLP) 方法在推理时被 RAG 提示工程所取代。LLM的功能包括几个要素：对话与上下文管理、逻辑与推理、非结构化输入和输出、自然语言生成以及知识密集型基础模型。除了LLMs的知识密集特性之外，所有这些要素都被广泛利用。LLMs的基础知识密集特性正在被推断中的上下文学习策略所取代。这里最值得注意的是RAG，它是大多数技术提供商正在标准化的标准。对话生成是由 GODEL 和 DialoGPT 等开发技术引领的。这些已被 ChatGPT、HuggingChat 和 Cohere Coral 等特定实现所取代。此外，还通过提示工程方法，其中使用提示中呈现的对话上下文进行少量训练。 区域 3 — 具体实施
该区域列出了一些特定用途的型号。如前所述，模型已不再那么特定于用例，并且模型已开始将多个（如果不是全部）这些元素合并到一个模型中。
区域 4 — 模型
这里列出了最显著的大型语言模型供应商。大多数LLMs都具有内置的知识和功能，包括人类语言翻译、解释和编写代码的能力，以及通过提示工程实现的对话和上下文管理。
其中一些模型供应商提供API，一些模型是开源的，可以免费使用。唯一的障碍是托管、管理和维护这些API。
区域 5 — 基础工具
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfcbf0b27c52c18c550ba1171c83b91e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/231a19ea5e5fc5358b534ef48b85e6ca/" rel="bookmark">
			【SpringBoot】SpringBoot整合jasypt进行重要数据加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页：哈__
期待您的关注 目录
📕jasypt简介 🔥SpringBoot使用jasypt
📂创建我需要的数据库文件
📕引入依赖
🔓配置数据库文件（先不进行加密）
🌙创建mapper接口
🔒配置文件加密 一、通过测试获取加密后的数据
二、通过build插件
📕jasypt简介 Jasypt（Java Simplified Encryption）是一个专注于简化Java加密操作的开源工具。它提供了一种简单而强大的方式来处理数据的加密和解密，使开发者能够轻松地保护应用程序中的敏感信息，如数据库密码、API密钥等。
Jasypt的设计理念是简化加密操作，使其对开发者更加友好。它采用密码学强度的加密算法，支持多种加密算法，从而平衡了性能和安全性。其中，Jasypt的核心思想之一是基于密码的加密（Password Based Encryption，PBE），通过用户提供的密码生成加密密钥，然后使用该密钥对数据进行加密和解密。此外，Jasypt还引入了盐（Salt）的概念，通过添加随机生成的盐值，提高了加密的安全性，防止相同的原始数据在不同的加密过程中产生相同的结果，有效抵御彩虹表攻击。
Jasypt的功能非常丰富，包括加密属性文件、Spring Framework集成、加密Hibernate数据源配置、URL加密的Apache Wicket集成等。它还可以与Acegi Security（即Spring Security）整合，用于加密任务与应用程序，如加密密码、敏感信息和数据通信，以及创建完整检查数据的sums等。此外，Jasypt还提供了一个开放的API，使得任何Java Cryptography Extension都可以使用它。
在Spring Boot应用中，Jasypt Spring Boot Starter是一个方便的集成工具，可以简化加密功能的配置。它支持多种加密算法，包括对称加密和非对称加密，可以根据实际需求选择合适的加密方式。通过使用Jasypt Spring Boot Starter，可以轻松地将加密功能集成到Spring Boot应用中，无需手动配置复杂的加密相关的代码和配置文件。
⭐jasypt的优点 提供简单的单向（摘要）和双向加密技术。用于任何JCE提供程序的开放API，而不仅仅是默认的Java VM提供程序。为您的用户密码提供更高的安全性。二进制加密支持。Jasypt允许对二进制文件（字节数组）进行摘要和加密。数值加密支持。除了文本和二进制文件，它还允许对数值进行摘要和加密（BigInteger和BigDecimal，加密Hibernate持久性时支持其他数字类型）。完全线程安全。支持加密/摘要池，以在多处理器/多核系统中实现高性能。包括库的轻量级（“精简”）版本，以便在移动平台等大小受限的环境中具有更好的可管理性。 🔥SpringBoot使用jasypt 📂创建我需要的数据库文件 -- ---------------------------- -- Table structure for student -- ---------------------------- DROP TABLE IF EXISTS `student`; CREATE TABLE `student` ( `s_id` varchar(20) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL DEFAULT '', `s_name` varchar(20) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL DEFAULT '', `s_birth` varchar(20) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL DEFAULT '', `s_sex` varchar(10) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL DEFAULT '', PRIMARY KEY (`s_id`) USING BTREE ) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_bin ROW_FORMAT = Compact; -- ---------------------------- -- Records of student -- ---------------------------- INSERT INTO `student` VALUES ('01', '赵雷', '1990-01-01', '男'); INSERT INTO `student` VALUES ('02', '钱电', '1990-12-21', '男'); INSERT INTO `student` VALUES ('03', '孙风', '1990-05-20', '男'); INSERT INTO `student` VALUES ('04', '李云', '1990-08-06', '男'); INSERT INTO `student` VALUES ('05', '周梅', '1991-12-01', '女'); INSERT INTO `student` VALUES ('06', '吴兰', '1992-03-01', '女'); INSERT INTO `student` VALUES ('07', '郑竹', '1989-07-01', '女'); INSERT INTO `student` VALUES ('08', '王菊', '1990-01-20', '女'); SET FOREIGN_KEY_CHECKS = 1; 📕引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/231a19ea5e5fc5358b534ef48b85e6ca/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/14/">«</a>
	<span class="pagination__item pagination__item--current">15/71</span>
	<a class="pagination__item pagination__item--next btn" href="/page/16/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>