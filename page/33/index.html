<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.126.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程学习者的博客">
		<meta property="og:url" content="https://bcxuexizhe.github.io/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="编程学习者">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3fc035bb181f7bc414a699b0af9c9d3/" rel="bookmark">
			深入浅出 Spring Boot 3.x：从原理到实战，全面解锁 Java 后端开发新潮流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💂 个人网站:【 摸鱼游戏】【神级代码资源网站】【工具大全】🤟 一站式轻松构建小程序、Web网站、移动应用：👉注册地址🤟 基于Web端打造的：👉轻量化工具创作平台💅 想寻找共同学习交流，摸鱼划水的小伙伴，请点击【全栈技术交流群】 在 Java 后端开发领域，功能强大的 Spring 开源框架不仅是首选，也是事实上的标准。但由于 Spring 存在配置烦琐、部署不易、依赖管理困难等问题，因此基于 Spring 的快速开发框架 Spring Boot 应运而生，它能大大简化 Spring 应用程序的配置和部署过程。
Spring Boot 采用“约定优于配置”的规则，大部分情况下，依赖它提供的 starter就可以使用默认的约定，然后通过属性文件减少大量的代码，使开发更为简单。
《深入浅出Spring Boot 2.x》时隔5年的全面更新；
来自一线开发者的实战经验总结，全方位讲解Spring Boot 3.x企业级开发采用Java 8之后的新语法和新技术，全面讲解Spring Boot 3.x；从理论到实践，全面介绍Spring Boot 3.x的原理和应用；紧扣互联网企业的实际需求，追上微服务和云服务的潮流。 在互联网世界中，分布式已经是一种必然的趋势，而在分布式架构中，微服务架构已成为当前的主流。Spring Boot作为业界流行的微服务开发框架，也渐渐成为企业级开发的主流选择。
Spring Boot 3.x正式版于2022年11月推出。本书在《深入浅出Spring Boot 2.x》的基础上进行全新升级，全面讲解Spring Boot 3.x技术，从开发环境的搭建入手，讲解全注解下的Spring IoC和Spring AOP、数据库编程（JPA、MyBatis和JDBC）、数据库事务、NoSQL数据库（Redis和MongoDB）技术、Spring MVC、REST风格、互联网抢购业务、监控与容器部署、Spring Cloud Alibaba微服务开发等内容，从而帮助读者掌握Spring Boot企业级开发的要点。
本书采用Java 8之后的新语法，涵盖从理论到互联网微服务后端的实践，无论是Java互联网后端开发人员，还是从传统Spring项目转向Spring Boot的开发人员，抑或是Java微服务开发人员，都可以从本书中获益。
📚 京东购买链接：《深入浅出Spring Boot 3.x》
内容简介 Spring框架是Java EE开发的强有力的工具和事实标准，而Spring Boot采用“约定优于配置”的原则简化 Spring的开发，成为业界流行的微服务开发框架，被越来越多的企业采用。为了适应新潮流，本书对Spring Boot 3.x技术进行深入讲解。
本书从一个简单的项目开始讲解Spring Boot企业级开发，其内容包含全注解下的Spring IoC和Spring AOP、数据库编程（JPA、MyBatis和JDBC）、数据库事务、NoSQL数据库（Redis和MongoDB）技术、Spring MVC、REST风格、互联网抢购业务、监控与容器部署、Spring Cloud Alibaba微服务开发等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3fc035bb181f7bc414a699b0af9c9d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94934a933473f9dbca7cd7c38c72bfcc/" rel="bookmark">
			【Go语言快速上手(四)】面向对象的三大特性引入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💓博主CSDN主页:杭电码农-NEO💓
⏩专栏分类:Go语言专栏⏪
🚚代码仓库:NEO的学习日记🚚
🌹关注我🫵带你学习更多Go语言知识
🔝🔝
GO快速上手 1. 前言2. 初识GO中的结构体3. 结构体的方法的引入4. GO中的封装与继承5. GO语言中的接口与多态6. 总结以及拓展 1. 前言 GO语言也支持面向对象编程,但是和传统的面向对象语言(如CPP)有明显的区别,GO并不是纯粹的面对对象编程语言.所以说GO是支持面向对象编程特性的,这样说比较合理
本章重点:
本篇文章会讲解GO中的结构体是如何定义并且使用的,并且会讲解结构体的方法与普通的函数有什么区别.再会讲解GO中的继承是如何实现的.最后会引入GO中接口的概念,并且由接口的用法衍生出GO的多态是如何实现的
2. 初识GO中的结构体 GO语言中没有class类,只有struct结构体,GO中的struct和其他语言中的class有着同等的地位.GO语言的面向对象非常简洁,没有复杂的重载,构造函数,以及析构函数,更没有什么隐藏的this指针.
语法使用:
type Teacher struct{ Name string//姓名,string类型 Age int//年龄,int类型 ID int //学号,int类型 } func main(){ var t1 Teacher t1.Name = "neo_kou" t1.Age = 21 t1.ID = 1001 fmt.Println(t1) } GO的结构体变量支持多种定义方式:
type Teacher struct{ Name string//姓名,string类型 Age int//年龄,int类型 ID int //学号,int类型 } func main(){ var t2 Teacher = Teacher{"小明",25,1005) var t3 *Teacher = New(Teacher) t3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94934a933473f9dbca7cd7c38c72bfcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74a0b469ad2c323e7cb2c36f90f61eef/" rel="bookmark">
			【prometheus】监控MySQL并实现可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、概述
1.1下载解压mysqld_exporter
1.2创建MySQL授权用户
1.3配置my.cnf
1.4启动mysqld_exporter
1.5prometheus配置修改
二、Grafana展示 【Prometheus】概念和工作原理介绍_prometheus工作原理
【Prometheus】k8s集群部署node-exporter
【prometheus】k8s集群部署prometheus server-CSDN博客
【prometheus】k8s集群部署Grafana安装和配置
【prometheus】k8s集群部署AlertManager实现邮件和钉钉告警-CSDN博客
一、概述 mysqld_exporter 是一个用于监控 MySQL 服务器的开源工具，它是由 Prometheus 社区维护的一个官方 Exporter。该工具通过连接到 MySQL 服务器并执行各种查询来收集关于 MySQL 服务器性能和状态的指标，并将这些指标暴露给 Prometheus 监控系统。
以下是 mysqld_exporter 的一些主要特点和功能：
指标收集: mysqld_exporter 通过执行 SQL 查询来收集关于 MySQL 服务器的各种指标，包括查询性能、连接状态、InnoDB 状态、复制状态等。Prometheus 兼容: mysqld_exporter 输出的指标符合 Prometheus 的指标格式，并且可以直接由 Prometheus 进行收集和存储。灵活的配置: 用户可以通过配置文件或命令行参数来配置 mysqld_exporter 的行为，包括指定要监控的 MySQL 实例、连接参数、指标的收集频率等。安全性: mysqld_exporter 支持通过 TLS/SSL 进行安全连接，以确保监控数据的机密性和完整性。多版本支持: mysqld_exporter 可以与多个 MySQL 版本兼容，并且可以通过配置选择性地启用或禁用特定版本的指标收集。自定义查询: 用户可以通过配置文件自定义要执行的 SQL 查询，以收集特定于其环境的自定义指标。易于部署: mysqld_exporter 可以作为一个独立的二进制文件部署，并且支持多种部署方式，包括 Docker 容器、系统服务等。 总的来说，mysqld_exporter 是一个功能强大且易于使用的工具，可以帮助用户监控和诊断其 MySQL 服务器的性能和健康状态，从而及时发现和解决潜在的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74a0b469ad2c323e7cb2c36f90f61eef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5242cd2f61665d07196aa965552bd0f6/" rel="bookmark">
			【C&#43;&#43;干货基地】深度理解C&#43;&#43;中的高效内存管理方式 new &amp; delete
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎬 鸽芷咕：个人主页 🔥 个人专栏: 《C++干货基地》《粉丝福利》 ⛺️生活的理想，就是为了理想的生活! 引入 哈喽各位铁汁们好啊，我是博主鸽芷咕《C++干货基地》是由我的襄阳家乡零食基地有感而发，不知道各位的城市有没有这种实惠又全面的零食基地呢？C++ 本身作为一门篇底层的一种语言，世面的免费课程大多都没有教明白。所以本篇专栏的内容全是干货让大家从底层了解C++，把更多的知识由抽象到简单通俗易懂。
⛳️ 推荐 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站。
文章目录 引入⛳️ 推荐一、C/C++内存分布1.1 内存布局图：1.2 C/C++程序内存分配的几个区域： 二、C语言的内存管理方法三、C/C++ 中的内存管理方法3.1 new 和 delete 的使用3.2 new 和 delete 在创建自定义类型时候的动作 四、new和delete的实现原理4.1 operator new与函数4.3 使用new 和new[ ] 是如何获取大小的4.4 delete 和 delete[ ] 的区别 五、 malloc/free和new/delete的区别 一、C/C++内存分布 1.1 内存布局图： 用通俗易懂的话来描述就是：
栈区（stack）：存放的是我们平常创建的变量 形参 等 临时变量！堆区（heap）：目前我们学的动态内存分配 都是在堆区开辟的！数据段（静态区）（static）存放全局变量、静态数据。程序结束后由系统释放。代码段： 可执行代码 和 只读 常量 1.2 C/C++程序内存分配的几个区域： 栈区（stack）：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 栈区主要存放运行函数而分配的局部变量、函数参数、返回数据、返回地址等。堆区（heap）：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。分
配方式类似于链表。数据段（静态区）（static）存放全局变量、静态数据。程序结束后由系统释放。代码段：存放函数体（类成员函数和全局函数）的二进制代码。 二、C语言的内存管理方法 在C 语言中 我们通常都是使用 malloc 来申请空间，使用 free 来释放空间
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5242cd2f61665d07196aa965552bd0f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e84af0dcc49f22c171864018491088d/" rel="bookmark">
			AI大模型探索之路-训练篇2：大语言模型预训练基础认知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、预训练流程分析二、预训练两大挑战三、预训练网络通信四、预训练数据并行五、预训练模型并行六、预训练3D并行七、预训练代码示例总结 前言 在人工智能的宏伟蓝图中，大语言模型（LLM）的预训练是构筑智慧之塔的基石。预训练过程通过调整庞大参数空间以吸纳数据中蕴含的知识，为模型赋予从语言理解到文本生成等多样化能力。本文将深入探讨预训练过程中的技术细节、所面临的挑战、通信机制、并行化策略以及如何通过这些技术的融合提升预训练的效率和性能。
一、预训练流程分析 预训练大语言模型涉及对海量参数的优化。这个过程起始于一个简单的前提：
给定输入（X）和相应的输出（Y），模型通过不断迭代学习，不断更新修改参数，使得其生成的输出尽可能接近真实结果（Y）。
当模型输出与实际结果之间的差距—通常由损失函数量化—减小到一个可接受的阈值时，我们可以认为预训练过程达到预期效果。在这个过程中，模型参数经历从随机初始化到精细调整的转变，逐步捕捉并内化语言的复杂规律。
大语言模型预训练过程核心：
1）输入 Batch 数据
2）前向传播计算损失
3）后向传播计算梯度
4）优化器更新大模型参数
5）反复迭代循环
二、预训练两大挑战 随着模型规模向百亿甚至千亿参数迈进，预训练任务面临两大主要挑战：
1.显存效率：模型参数量的巨大使得即便是最先进的GPU也难以单独容纳所有参数，这直接导致了显存溢出的问题。例如，一个具有1750亿参数的GPT-3模型，其参数本身就需要消耗约700GB的显存，加上Adam优化器的状态，总共需要超过2.8TB的显存
2.计算效率：巨大的模型参数和海量的训练数据使得计算量激增，导致单机训练时间长达数年，这对于计算资源的有效利用提出了极大的挑战。
三、预训练网络通信 网络通信是多机多GPU预训练过程中不可或缺的环节。点对点通信方式因其一对一的数据交换模式，虽然成本较低，但传输速率较慢，成为速度瓶颈。相对而言，集体通信方式通过同时进行多个进程间的数据传输，大大提升了通信速度，但相应地增加了成本。选择合适的通信方式对于提高预训练效率至关重要。
1.点对点通信：一个进程发送数据，一个进程接收数据，速度慢，成本低。
2.集体通信：多个进程发送数据，多个进程接收数据，速度快，成本高。
四、预训练数据并行 1. 数据并行：数据并行是处理大规模数据集的常用策略，它通过将整个数据集分割成多个子集，每张GPU分配一部分数据独立进行模型训练。
2. 数据并行三个提高效率的技巧
1）梯度分桶：动机是集体通信在大张量上比在小张量上效率更高。
2）计算与通信重叠：有了梯度分桶之后，在等待同一个桶内的梯度计算完后，就可以进行通信操作。
3）跳过梯度同步：梯度累加，减少梯度通信的频次。
五、预训练模型并行 当单张GPU无法装载整个模型时，模型并行成为解决之道。
1.流水线并行
层间划分，将不同的层划分到不同的 GPU 上；比如：前 3 层在 0 号卡上，后 3 层在 1 号卡上
2.张量并行
层内划分，切分一个独立的层划分到不同的 GPU 上；比如：0 号卡和 1 号卡分别计算某个层的不同部分
六、预训练3D并行 3D并行是一种综合性策略，它结合了数据并行、张量并行和流水线并行的优势，以平衡显存利用率和计算效率。在此框架下，每种并行方法承担着不同的角色：数据并行提供高效的计算利用率，张量并行减少单个层的显存占用，而流水线并行则降低跨层通信的频率。
1. 数据并行：计算效率高、实现简单。
• 显存效率：每张卡上都保存了完整的模型、梯度、优化器状态，因此显存效率不高。
• 计算效率：当增加并行度时，单卡的计算量是保持恒定的，可以实现近乎完美的线性扩展。但规约梯度的通信开销，与模型大小成正相关。
2. 张量并行：因模型结构而异，实现难度大。
• 显存效率：随着并行度增加，成比例地减少显存占用。是减少单层神经网络中间激活的唯一方法。
• 计算效率：频繁的通信，限制了两个通信阶段之间的计算量，影响了计算效率，计算效率很低。
3. 流水线并行：通信成本最低
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e84af0dcc49f22c171864018491088d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5b2cfc17eeba4905ffe3da56fe0c982/" rel="bookmark">
			我们该如何看待AIGC（人工智能）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
AIGC的概述：
AIGC的发展经历：
AIGC的发展带来的机遇：
我们该如何去看待AIGC：
AIGC的概述： @[TOC]( 🚀文章目录)
---
AIGC全称为AI-Generated Content，指基于生成对抗网络GAN、大型预训练模型等人工智能技术，通过已有数据寻找规律，并通过适当的泛化能力生成相关内容的技术。与之相类似的概念还包括Synthetic media，合成式媒体，主要指基于AI生成的文字、图像、音频等。
从字面意思上看，AIGC是相对于过去的 PCG、UCG 而提出的。因此，AIGC的狭义概念是利用Al自动生成内容的生产方式。但是 AIGC已经代表了AI技术发展的新趋势。文心一言 (baidu.com)
它是一个涵盖了人工智能、计算机图形学和深度学习等领域技术的综合平台。AIGC技术的核心是利用人工智能算法对系统进行建模和预测，实现对系统的智能控制。它不需要对系统进行精确的建模，而是通过对系统的大量数据进行学习，自动发现系统的规律和特征，从而实现对系统的智能控制。
AIGC的主要应用领域包括图像生成、音视频创作与生成、电影与游戏制作、科研与创新等。在智能安防领域，AIGC可以通过图像识别技术实现人脸识别、车辆识别等功能，提升安全监控的效率和准确性；在游戏和虚拟现实领域，AIGC可以实现高度逼真的图像渲染和物理模拟，提升游戏体验。此外，AIGC还可以应用于药物设计、材料科学等领域，加速技术创新和发展。
AIGC的发展历程中，从初期的学术界研究人员和感兴趣的学生组成的组织，逐渐扩大影响力并吸引了越来越多的人工智能专家和科技公司加入。现在，AIGC已经成为一个全球性的人工智能社群组织，与各个领域的专家学者、企业家、政府官员等建立了广泛的合作关系。
那么，AIGC是怎么产生和发展的呢？接下来谈谈AIGC的崛起历程。
AIGC的发展经历： # 🚀AIGC发展历程和典型事件
虽然从严格意义上来说，1957 年莱杰伦·希勒(Lejaren Hiller)和伦纳德·艾萨克森(Leon-ard saacson)
在AIGC发展的初期阶段，主要是在实验室中进行探索和研究。研究人员开始使用深度学习算法，尝试生成图片、音乐、文本等内容，以及将不同类型的内容进行结合和生成。
完成了人类历史上第一支由计算机创作的音乐作品就可以看作是 AIGC的开端，距今已有 65 年，这期间也不断有各种形式的生成模型、Al 生成作品出现。
但是 2022年才真正算是 AIGC 的爆发之年，人们看到了 AIGC无限的创造潜力和未来应用可能性。目前，AIGC 技术沉淀、产业生态已初步形成，保持强劲发展和创新势头。
## 🚀主流生成模型诞生历程
生成算法、预训练模型、多模态等AI技术累积融合，催生了AIGC 的大爆发。
### 🚀一是，基础的生成算法模型不断突破创新。
2014年，伊恩·古德费洛(lan Goodfellow)提出的生成对抗网络(Generative Adversarial Network，GAN)成为早期最为著名的生成模型。
GAN 使用合作的零和博弈框架来学习，被广泛用于生成图像、视频、语音和三维物体模型等。GAN 也产生了许多流行的架构或变种，如DCGAN，StyleGAN，BigGAN，StackGAN.Pix2pix，Age-cGAN，CycleGAN、对抗自编码器(Adversarial Autoencoders，AAE)、对抗推断学习(Adversarially Learned Inference，ALI)等。
随后，Transformer、基于流的生成模型(Flow-based models)、扩散模型(Diffusion Model)等深度学习的生成算法相继涌现。其中，Transformer 模型是一种采用自注意力机制的深度学习模型，这一机制可以按照输入数据各部分重要性的不同而分配不同的权重，可以用在自然语言处理(NLP)、计算机视觉(CV)领域应用。后来出现的 BERT、GPT-3、LaMDA等预训练模型都是基于Transformer 模型建立的。
而扩散模型(Diffusion Mode)是受非平衡热力学的启发，定义一个扩散步骤的马尔可夫链，逐渐向数据添加随机噪声，然后学习逆扩散过程，从噪声中构建所需的数据样本。扩散模型最初设计用于去除图像中的噪声。随着降噪系统的训练时间越来越长并且越来越好，它们最终可以从纯噪声作为唯一输入生成逼直的图片。
然而，从最优化模型性能的角度出发，扩散模型相对 GAN 来说具有更加灵活的模型架构和精确的对数似然计算，已经取代 GAN 成为最先进的图像生成器。2021年6月，OpenAl 发表论文已经明确了这个结论和发展趋势。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5b2cfc17eeba4905ffe3da56fe0c982/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7ae2536cb29a6cf12d461a94f40580f/" rel="bookmark">
			SpringCloud-搭建XXL-JOB任务调度平台教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、XXL-JOB任务调度平台介绍 XXL-JOB是一个轻量级分布式任务调度框架，旨在解决分布式系统中的任务调度问题，提高系统的处理效率和任务管理的便捷性。
1. XXL-JOB任务调度概念 XXL-JOB任务调度平台通过中心化管理方式，使得任务的调度更加高效和集中。平台不仅提供了丰富的任务调度功能，例如：CRON表达式、任务依赖、失败重试、任务超时处理、任务分片等，还提供了实时的任务日志、运行结果监控等功能，大大简化了任务调度的复杂性。
2. XXL-JOB任务调度平台架构 XXL-JOB的基本架构主要包括以下几个组成部分：
调度中心（Admin）：负责任务的添加、编辑、删除以及触发任务执行。执行器（Executor）：负责接受调度中心的命令，执行具体的任务逻辑。 在实际开发中，XXL-JOB的任务调度中心负责管理和分配任务，而各个服务或应用需要集成执行器以注册到XXL-JOB任务调度中心。执行器负责实际执行这些任务，并向调度中心报告执行结果。
3. XXL-JOB功能 XXL-JOB具有强大且实用的功能，具体如下：
功能描述任务调度支持CRON表达式，动态设置执行频率任务依赖支持跨任务依赖，任务链的形式执行失败处理支持失败重试机制，自定义重试次数超时处理支持任务执行超时设置，超时后自动终止日志监控支持实时日志监控，查看任务执行详情负载均衡执行器支持集群部署，实现任务负载均衡 二、XXL-JOB搭建流程 搭建XXL-JOB平台涉及到多个步骤，包括环境准备、调度中心的部署、执行器的集成和配置等。
1、环境准备 Java环境：JDK1.8或更高版本。数据库：MySQL5.5及以上。Maven：用于项目构建。可运行的SpringCloud项目。 2、调度中心部署 克隆 XXL-JOB 的代码仓库：
git clone https://github.com/xuxueli/xxl-job.git 导入 doc/db/tables_xxl_job.sql 到 MySQL 数据库，创建所需的数据库和表。
修改调度中心配置文件 application.properties，配置数据库信息。
spring.datasource.url=jdbc:mysql://localhost:3306/xxl_job?Unicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false spring.datasource.username=root spring.datasource.password=yourpassword 复制到 xxl-job 项目目录下。
IDEA内修改父级项目的 pom.xml 的模块引用，将 xxl-job 引入到项目里作为一个独立的模块。
引入成功后，xxl-job 模块颜色变为黑色。
启动 xl-job-admin 项目。
任务调度中心成功启动。
初始登录信息：admin/123456
3、执行器集成 在 SpringCloud 项目的 pom.xml 文件中添加 XXL-JOB 的依赖：
&lt;dependency&gt; &lt;groupId&gt;com.xuxueli&lt;/groupId&gt; &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt; &lt;version&gt;2.4.2&lt;/version&gt; &lt;/dependency&gt; 这里 2.4.2 是我的 xxl-job 的版本号，不知道可以去下载的 xxl-job 包下的 pom.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7ae2536cb29a6cf12d461a94f40580f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72e525d1e6bb924f2b2105317156aa6b/" rel="bookmark">
			【基于netty&#43;zookeeper的rpc远程调用框架】首篇——缘起
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🐼作者简介：一名大三在校生🎋
空有想法，没有实践
文章目录 第一章 概述缘起一、为什么要手写一个rpc项目二、什么是rpc三、rpc怎么使用四、rpc的通信流程 欢迎添加微信，加入我的核心小队，请备注来意 第一章 概述 缘起 作为一名即将步入社会的大三学生，我深知一份优秀的简历对于求职的重要性。暑期实习作为大学生涯中的一个重要节点，不仅是锻炼自己、积累经验的宝贵机会，更是向未来雇主展示自己能力和潜力的关键时期。我开始着手准备自己的求职简历，同时也在积极寻找能够提升个人竞争力的项目经验。
在这个过程中，我意识到，一个好项目不仅能够丰富我的简历，更能在面试中成为我与面试官沟通的桥梁，展现我的实际操作能力和解决问题的思路。因此，我开始在网上寻找各种资源，希望找到一个既符合我专业背景，又能体现我技术实力的项目。
在众多的技术资源中，RPC（Remote Procedure Call，远程过程调用）框架引起了我的注意。RPC框架作为一种允许程序调用另一个地址空间的子程序的机制，广泛应用于分布式系统中，对于提高系统的模块化和可扩展性具有重要意义。于是跟着楠哥一起来手写属于自己的rpc项目，该专栏详细记录着学习中的点点滴滴，感兴趣的可我一起开始这颇有挑战的时光吧！
一、为什么要手写一个rpc项目 只要你学习过dubbo，学习过微服务，你一定会对rpc这个概念很熟悉。最近几年，不管是在实际的工作中，还是面试中，我们经常可以看到rpc的影子，现在，他几乎成了我们工作中必不可少的一个基础组件，值得我们学习。有些朋友可能会提出疑问，我们已经有了很成熟的rpc框架，比如dubbo、grpc那么我们为什么还要自己去手写呢？
这个问题我们要这样来看：
1、学习本身就是为了增长知识，只有懂其原理，才能更好的利用框架，才能更好的解决问题。
2、大厂都有自己的中间件部门，很多组件必须要自行研发，一方面是自研组件可以更好的满足自己的业务需要，
一方面是防止开源作者停更无法维护、甚至卡脖子。
很重要的一点：如果我们可以在简历中写出一个很完善的rpc项目，并且能在面试中讲出其中的核心知识点，那对于校招、或者找工作来说，简直无敌。
二、什么是rpc RPC（Remote Procedure Call，远程过程调用）是一种允许一个程序调用另一个程序的函数或方法，而这两个程序可以位于同一台计算机上，也可以位于不同的计算机上，甚至可以运行在不同的操作系统中。RPC使得开发者可以像调用本地函数一样调用远程函数，从而实现分布式计算和通信。
RPC的关键特性包括：
位置透明性：调用远程过程就像调用本地过程一样，无需关心远程过程的位置。网络通信抽象：RPC框架负责处理底层的网络通信细节，开发者不需要直接处理网络编程。协议支持：RPC可以支持多种通信协议，如TCP/IP、HTTP等。参数传递：远程过程调用允许参数从客户端传递到服务器端，并且将结果返回给客户端。异步调用：很多RPC框架支持异步调用，允许客户端在等待远程调用结果时继续执行其他任务。错误处理：RPC需要能够处理远程调用过程中可能出现的错误，如网络故障、服务不可用等。安全性：确保远程调用过程的安全性，包括认证、授权和数据加密等。 除了基本的远程调用能力，现代RPC框架通常还提供以下高级功能：
负载均衡：将请求分发到多个服务器，以提高系统的性能和可用性。优雅启停：确保服务在启动和停止时能够优雅地处理当前的请求，避免数据丢失或不一致。链路追踪：跟踪请求在系统中流动的路径，帮助调试和监控系统。灰度发布：逐步推出新版本的服务，以测试其稳定性和性能。 RPC框架的实现通常涉及以下几个关键组件：
客户端存根（Client Stub）：在客户端模拟远程服务接口的代理对象。服务器端存根（Server Stub）：在服务器端接收客户端请求并调用实际服务的代理对象。通信协议：定义客户端和服务器之间如何交换消息。序列化/反序列化：将数据结构转换为可以在网络上传输的格式，并在接收端将其转换回原始格式。 常见的RPC框架包括gRPC、Apache Thrift、RMI（Java远程方法调用）等。这些框架为分布式系统的开发提供了强大的支持，使得开发者可以更容易地构建和管理分布式应用程序。
三、rpc怎么使用 目前我们对rpc有了一个基本的了解，那 rpc 在项目中应该如何使用呢，如果有同学熟悉dubbo、grpc、或者openFegin那一定很清楚这个问题的答案。
我们就以dubbo为例，大家可以参考dubbo的官网讲解，在springboot中，服务提供者和消费者只要依赖相同接口，就可以使用如下的方式进行远程调用了。
1、服务端只需要使用 @DubboService 注解将对应接口的实现暴露出去。
@DubboService public class DemoServiceImpl implements DemoService { @Override public String sayHello(String name) { return "Hello " + name; } } 2、客户端就可以直接使用 @DubboReference 直接注入使用了。
@Component public class Task implements CommandLineRunner { @DubboReference private DemoService demoService; @Override public void run(String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72e525d1e6bb924f2b2105317156aa6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/490592b5c913a9ec80262a7cb6f357ce/" rel="bookmark">
			MacOS使用ollama部署codellama&#43;openui以及llama.cpp部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在AI这么火，你是不是也渴望能够在本地部署并运行属于自己的大模型，然而，高昂的硬件成本又往往成了一大障碍，限制了你继续在AI领域去探索和创新。如果告诉你，无需换电脑，无需额外花钱买GPU或换显卡，你现在的电脑就可以本地跑一些大模型，那将是多么酷的一件事！！！ 先来强调下对于硬件的要求：基本的配置只需是Intel i5处理器 + 16G内存（内存8G也ok，但是能慢一些，但你CPU起码de得是i5的，相信这个配置对于大多数人来说还是可以满足的），你就能够顺利运行多种开源的大模型，例如33亿参数、7亿参数的模型，但是70b那种跑不起来。需要注意的是，这里讨论的是利用大型模型进行推理，而非训练或微调模型。如果你的显卡性能更强，那么在大模型训练和微调方面的能力也会对应增强。不过，今天我们主要关注如何在现有硬件条件下运行大模型，所以重点不在此，就不详细介绍显卡相关部分了。
重点来了，这里介绍两个可以运行在本地的大模型工具：ollama和llama.cpp，尤其是ollama，本地跑一个大模型特别简单，后面将会重点介绍。这里还有一个小知识补充一下，无论是Ollama还是llama.cpp都是运行的量化后的模型（GGUF格式的），所以对电脑配置的要求大幅降低。
Ollama运行开源LLM
Ollama是一个轻量级且可扩展的框架，通过提供命令行界面，可以帮助用户在本地电脑上运行、创建和管理大语言模型（LLMs），整体感觉和Docker很像。
官网：https://ollama.com/
如何使用呢？很简单，下载安装后，只需在CMD命令行窗口，执行下面的命令（比如我这里启动Google刚开源的codegemma模型），就可以启动快速下载和直接运行一个大模型。
ollama run codegemma
运行后，就可以在命令行窗口进行交互了，但是整体还是不太方便，我们期待的是有个web页面可以进行交互，方便使用。
到了这里，配套的再推荐另一个开源项目：Open-webui。它可以快速基于Ollama构筑本地UI。具体使用方法可以参照官网：https://github.com/open-webui/open-webui
我们用docker命令（docker的安装和基本使用这里就不详细说明了），快速启动Open-webui，自动关联本地的ollama。
docker run -d -p 3000:8080 --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main
启动成功之后，访问：http://localhost:3000 我们就可以使用了。
上面简单给大家演示了，如何只用两行命令（一行是用ollama去运行一个大模型，一行是用docker启动web页面，自动关联本地ollama），基于Ollama + Open-webui去构筑本地大模型，并且可以通过web操作页面进行访问，是不是特别方便和简单。到这里，大家可能还会有下面的疑问：
问题1、ollama可以下载和运行哪些开源大模型？
可以参照网站：https://ollama.com/library 这里列出了ollama支持的开源大模型。
模型更新得很快，比如刚开源的llama3立刻就支持。并且Ollama它还允许用户通过编写Modelfile来导入更多的自定义模型，具有灵活的扩展性，并能与许多工具集成。它还支持GPU/CPU混合模式，可以根据用户的硬件配置进行优化。
问题2、ollama还有哪些常用的命令？
可以执行 ollama -h 去获取ollama支持的命令，真的很少，很简单。
问题3、ollama可以支持本地跑多个大模型吗？
必须可以，只要你电脑配置足够，同样的方法，使用ollama run 去运行你想运行的大模型。具体使用的时候，可以在open-webui提供的页面进行切换大模型即可：
问题4、为什么下载的模型要比原始模型小？
之前上面也提过，Ollma运行的是量化后的模型，将权重参数的精度压缩为4位整数精度，大幅减小了显存需求。此外，Ollama提供了对模型的量化和推理优化能力，这使得模型能够在有限计算资源下进行高效推理。
相信介绍到这里，大家都清楚了如何用ollama本地电脑玩转大模型，是不是看起来很简单，很酷。。。赶紧回去试一试吧。
-----------------
llama.cpp运行开源LLM
这个就比ollama复杂一些了，下面也简单介绍下，具体详细使用可以参照我的知识星球，里面写得很详细。
llama.cpp 是一个C++库，用于简化LLM推理的设置，它使得在本地机器上运行大模型（GGUF格式）成为可能。
官网：https://github.com/ggerganov/llama.cpp
具体如何使用呢？主要分下面这三步：
1、将项目clone到本地，然后使用make命令进行安装。
2、自行去huggingface上去找gguf格式的大模型（注意，一定是gguf格式，否则跑不起来），然后将大模型下载到本地。这里下载的过程，我推荐使用从hf-mirror镜像站中下载，速度会提升很多。大家可以参照网站：https://hf-mirror.com/
3、使用llama.cpp去运行大模型，常用的命令有./main、./server等。比如下面我用server指令去运行刚出的llama3大模型，并在web页面上进行操作。
./server -m /Users/chiliangxu/Documents/03_src/clx/ai/models/Llama-3-8B/Meta-Llama-3-8B-Instruct.Q2_K.gguf -c 2048
llama.cpp的使用比ollama复杂一些，技术门槛稍微高一些，所以对于初学者的话，我还是推荐使用ollama。但是llama.cpp方式要比ollama+open-webui方式要占用硬件资源小，自带图形页面。两者各种利弊，大家选择最合适的就好。
----------------
具体使用的过程中，如果有不明白的地方，可以参照星球或留言，也可以私信我，看到我都会第一时间答复。
相信通过上面介绍的内容，为广大开发者和研究者在硬件资源有限的情况下，降低了AI使用的门槛，可以使更多人接触到大模型，而不只是单纯使用一些别人的AI产品。如果你感兴趣，那现在是时候行动起来了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12c680307d0d262b831e7f8c8269069e/" rel="bookmark">
			【热门话题】AI作画算法原理解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页: 鑫宝Code
🔥热门专栏: 闲话杂谈｜ 炫酷HTML | JavaScript基础 ​💫个人格言: "如无必要，勿增实体" 文章目录 AI作画算法原理解析AI作画算法概述基础原理：机器学习与深度学习卷积神经网络（CNNs）生成对抗网络（GANs） AI作画算法的关键步骤数据准备与预处理模型训练模型优化与调参生成与迭代 AI作画算法的应用实例风格迁移图像合成与修复创意生成 未来展望与挑战结语 AI作画算法原理解析 在艺术与科技的交汇点上，人工智能（AI）作画算法如同一股不可阻挡的潮流，正逐渐改变我们对创造性艺术的理解与实践。本文将深入探讨AI作画算法的原理，并通过清晰的条理和细致的解释，为读者揭示这一领域的奥秘。
AI作画算法概述 在开始深入之前，我们需要明确什么是AI作画算法。简单来说，AI作画算法是指利用人工智能技术来生成或辅助生成视觉艺术作品的计算机程序。这些算法通常基于机器学习，尤其是深度学习模型，如卷积神经网络（CNNs）和生成对抗网络（GANs）。
基础原理：机器学习与深度学习 机器学习是AI作画算法的核心，它使得计算机能够从数据中学习并做出决策。深度学习是机器学习的一个子领域，它使用多层神经网络来模拟人脑处理信息的方式，从而识别复杂的模式。
卷积神经网络（CNNs） CNNs是一种专门用于处理具有类似网格结构的数据的深度学习网络，例如图像（2D网格）和音频（1D序列）。在AI作画中，CNNs通常用于理解输入图像的内容，提取特征，并将这些特征用于创作新的作品。
生成对抗网络（GANs） GANs由两个网络组成：生成器（Generator）和判别器（Discriminator）。生成器创建新的图像，而判别器评估这些图像是否足够真实。这两个网络相互竞争，生成器不断学习制造越来越真实的图像，而判别器则不断提高其鉴别能力。
AI作画算法的关键步骤 数据准备与预处理 在训练AI作画模型之前，需要大量的图像数据集。这些数据集需要经过预处理，包括归一化、大小调整和数据增强等步骤，以提高模型的训练效率和效果。
模型训练 模型训练是AI作画算法的核心部分。在这一阶段，模型通过大量的图像数据进行学习，不断调整其参数以最小化损失函数。损失函数衡量了模型输出与实际目标之间的差异。
模型优化与调参 为了提高模型的性能，需要进行优化和调参。这包括选择合适的激活函数、损失函数、学习率以及调整网络结构等。这一过程往往需要多次迭代和实验。
生成与迭代 一旦模型训练完成，就可以开始生成新的图像。这个过程往往是迭代的，模型会根据用户的反馈或其他评价指标不断改进其输出。
AI作画算法的应用实例 风格迁移 风格迁移是AI作画的一个常见应用，它将一张图像的风格应用到另一张图像上。这通常是通过将图像的内容和风格特征分离，然后将风格特征融合到目标图像中来实现的。
图像合成与修复 AI作画算法也可以用于图像合成，即将多个图像的元素结合在一起形成一个全新的图像。此外，它们还可以用于图像修复，比如去除图像中的噪声或填补缺失的部分。
创意生成 除了模仿和复制，AI作画算法还能够进行创意生成。通过训练，模型可以学会创造全新的艺术作品，这些作品可能从未在现实世界中出现过。
未来展望与挑战 AI作画算法的发展为我们提供了无限的想象空间，但同时也带来了一系列挑战，如版权问题、伦理争议以及技术的普及与教育等。随着技术的不断进步，我们可以预见，AI将在艺术创作中扮演更加重要的角色。
结语 AI作画算法是人工智能与艺术结合的产物，它不仅展示了技术的力量，也激发了我们对艺术本质的思考。通过理解这些算法的原理，我们能够更好地把握AI在艺术创作中的应用，并探索人类创造力的新境界。
在这篇文章中，我们从AI作画算法的基础概念出发，逐步深入到关键技术细节，最后讨论了实际应用和面临的挑战。希望这能帮助读者对AI作画算法有一个全面而深入的理解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f480a4dce1ed04889f79b13e415a430/" rel="bookmark">
			Seal^_^【送书活动第2期】——《Flink入门与实战》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Seal^_^【送书活动第2期】——《Flink入门与实战》 一、参与方式二、本期推荐图书2.1 作者简介2.2 编辑推荐2.3 前 言2.4 本书特点2.5 内容简介2.6 本书适用读者2.7 书籍目录 三、正版购买 一、参与方式 评论："掌握Flink，驭大数据，实战无惧！"，即可参与成功。
1、关注博主的账号。
2、点赞、收藏、评论博主的文章。
3、在文章下留下评论，每位参与者最多可以评论三次。
📚 本次抽奖将 送出1至3本 书籍，具体数量取决于活动期间的阅读量，阅读量越高，送出的书籍数量也会相应增加。
🕚 活动截止时间为 2024年4月30日晚上8点整。博主将会抽奖程序随机抽取幸运观众，并在动态中公布抽奖结果。
如果您有特殊需求或想要获取更多福利，请添加博主的微信号（文末）、加入粉丝福利群。
⚡ 注意： 活动结束后，中奖观众将会收到博主的私信通知，请留意查看您的私信消息、关注博主动态查看中奖信息。
二、本期推荐图书 2.1 作者简介 汪明，中国矿业大学硕士，徐州软件协会副理事长，某创业公司合伙人。从事软件行业十余年，发表论文数十篇。著有图书《Python大数据处理库PySpark实战》《TypeScript实战》《Go并发编程实战》。
2.2 编辑推荐 1、由于阿里对Flink的收购以及改进，目前Flink社区非常活跃，社区一直致力于统一流处理和批处理API，并逐步增强Flink SQL相关功能，即期望通过SQL来满足大部分的大数据ETL处理场景。
2、Flink在百度、阿里、字节跳动、小米和腾讯等商业巨头中有成熟的应用，每日可以处理万亿的事件，且可以维护TB级别的状态信息。
3、如果你对实时大数据处理感兴趣，致力于构建分布式大数据处理应用程序，并且有一点Java编程基础，那么本书适合你。
4、本书先对Flink基本的安装过程进行说明，并对Flink分布式架构、内部数据处理过程等进行详细分析，最后结合一个综合案例讲解大数据实时处理过程。
5、本书以实例为主线，激发读者的阅读兴趣，让读者能够真正学习到Flink 最实用、最前沿的技术。
2.3 前 言 随着物联网、5G以及大数据技术的发展，人类已经进入大数据时代，毫不夸张地说，未来IT相关的职位，一项必备技能就是大数据处理能力。当前，人类基于大数据和人工智能等技术，在特定领域中可以大大提升业务系统的智能化水平。
人类对于计算速度的追求从未停止，即使面对海量的数据，我们也希望大数据框架可以在非常低的延迟下进行响应，从而提升用户的体验。
主流的分布式大数据计算框架有Storm、Spark和Flink，由于阿里对Flink的收购以及改进，目前Flink社区非常活跃，社区一直致力于统一流处理和批处理API，并逐步增强Flink SQL相关功能，即期望通过SQL来满足大部分的大数据ETL处理场景。另外，随着Flink SQL功能的增强和发展，也大大降低了Flink学习的难度。
目前，Flink在百度、阿里、字节跳动、小米和腾讯等商业巨头中有成熟的应用，每日可以处理万亿的事件，且可以维护TB级别的状态信息。Flink支持多种编程语言，可以用Java、Scala以及Python进行大数据业务处理。与此同时，Flink支持灵活的窗口计算以及乱序数据处理，这相对于其他大数据计算框架来说，有比较强的优势。
如果你对实时大数据处理感兴趣，致力于构建分布式大数据处理应用程序，并且有一点Java编程基础，那么本书适合你。本书作为Flink的入门教材，由浅入深地对Flink大数据处理方法进行介绍，特别对常用的DataStream API和DataSet API、Table API 和SQL进行了详细的说明，最后结合实战项目，将各个知识点有机整合，做到理论联系实际。
本书涉及的技术和框架：
本书涉及的技术和框架包括Flink、IntelliJ IDEA、Java、Kafka、jQuery、HTML5、Node.js、Maven。
2.4 本书特点 （1）理论联系实际。本书先对Flink基本的安装过程进行说明，并对Flink分布式架构、内部数据处理过程等进行详细分析，最后结合示例代码进行说明，做到理论联系实际。
（2）深入浅出、轻松易学。本书以实例为主线，激发读者的阅读兴趣，让读者能够真正学习到Flink 最实用、最前沿的技术。
（3）技术新颖、与时俱进。本书结合当前最热门的技术，如Node.js和HTML5等，让读者在学习Flink的同时，了解更多相关的先进技术。
（4）贴心提醒。本书根据需要在各章使用了很多“注意”小栏目，让读者可以在学习过程中更轻松地理解相关知识点及概念。
2.5 内容简介 Apache Flink是一个框架和分布式处理引擎，用于对无界和有界数据流进行有状态的计算，广泛应用于大数据相关的实际业务场景中。本书是一本从零开始讲解Flink的入门教材，学习本书需要有Java编程基础。
本书共分10章，内容包括Flink开发环境搭建、Flink架构和原理、时间和窗口、状态管理和容错机制、数据类型与序列化、DataStream API和DataSet API、Table API和SQL、Flink并行、Flink部署与应用，最后以一个Flink实战项目为例，对Flink相关知识进行综合实践，其中涉及Web页面展示、WebSocket协议和Node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f480a4dce1ed04889f79b13e415a430/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccac50a752f26fb7ce3ec586ef39a0e0/" rel="bookmark">
			【ElasticSearch】DSL查询文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页：五敷有你 🔥系列专栏：elasticsearch
⛺️稳中求进，晒太阳
上文种，实现了elasticsearch的数据存储功能。但elasticsearch最擅长的还是搜索和数据分析。
1.DSL查询文档 elasticsearch的查询依然是基于JSON风格的DSL来实现的。
1.1.DSL查询分类 Elasticsearch提供了基于JSON的DSL（Domain Specific Language）来定义查询。常见的查询类型包括：
查询所有：查询出所有数据，一般测试用。例如：match_all
全文检索（full text）查询：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：
match_query
multi_match_query
精确查询：根据精确词条值查找数据，一般是查找keyword、数值、日期、boolean等类型字段。例如：
ids
range
term
地理（geo）查询：根据经纬度查询。例如：
geo_distance
geo_bounding_box
复合（compound）查询：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：
bool
function_score
查询的语法基本一致：
GET /indexName/_search { "query": { "查询类型": { "查询条件": "条件值" } } } 我们以查询所有为例，其中：
查询类型为match_all
没有查询条件
// 查询所有 GET /indexName/_search { "query": { "match_all": { } } } 其它查询无非就是查询类型、查询条件的变化。
1.2.全文检索查询 1.2.1.使用场景 全文检索查询的基本流程如下：
对用户搜索的内容做分词，得到词条
根据词条去倒排索引库中匹配，得到文档id
根据文档id找到文档，返回给用户
比较常用的场景包括：
商城的输入框搜索
百度输入框搜索
例如京东：
因为是拿着词条去匹配，因此参与搜索的字段也必须是可分词的text类型的字段。
1.2.2.基本语法 常见的全文检索查询包括：
match查询：单字段查询
multi_match查询：多字段查询，任意一个字段符合条件就算符合查询条件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccac50a752f26fb7ce3ec586ef39a0e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4792cac344b38dbc3062f32fe57e09fb/" rel="bookmark">
			【预测】小米汽车电子电气架构的猜想
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
前言
整车EEA
硬件平台
软件平台
总结
参考资料
前言 见《【Review】小米汽车发布会》
整车EEA 小米汽车整车电子电气架构方面的信息，小米官方并没有对外介绍，但是从近日流出的整车BOM和供应商列表中看到，车上各种控制器一个都不少。智能驾驶控制器、智能座舱控制器（德赛西威）、电池管理系统（宁德时代）、电机控制器（联合电子）、整车控制器、车身控制器、制动系统（博世）、转向系统、网关控制器、T-box。如果流出的这些信息都是真实的话，那么可以看出各个控制单元的集成度并不高，所以可以初步猜测，其整车电子电气架构还是传统的分布式阶段。
硬件平台 本文以小米SU7 Max创始版为例，器智能驾驶控制采用的是水冷散热，如下所示：
PCB采用了三防处理，两颗英伟达DRIVE Orin X算力芯片（这种布局与特斯拉的很像），综合算力达到508TOPS，DRIVE Orin X采用7nm工艺，2022年正式面向车厂量产，如下所示：
软件平台 Xiaomi Polit，小米全栈自研智能驾驶技术，如下所示：
总结 总体而言，小米的电子电气架构采用的是中规中矩的成熟主流方案。如果还要更上一层楼的话，那就是在不远的将来，架构形式还要向集成化更高的域控阶段迈进。最终随着高级别自动驾驶的大规模应用，汽车电子及软件功能大幅增长，还要向基于中央计算平台的整车集中式电子电气架构演进。各采集、执行节点将原始数据通过网关传输到中央控制器处理，所有数据的处理与决策制定都在这里完成。其中，与自动驾驶相关的传感数据也将由中央控制器处理后进行决策。
参考资料 《小米汽车合集》——@杨长顺维修家
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7635a1fc8fb78affaed7fe044fd6456/" rel="bookmark">
			【Websokect】服务器https协议下ws连接失败问题及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在服务器使用HTTPS协议下连接WebSocket时，通常会出现一些常见的问题导致连接失败。以下是一些可能的原因和解决办法：
SSL证书配置问题： 确保您的服务器上已正确配置SSL证书，并且证书有效。如果证书配置不正确或者过期，客户端可能无法建立安全连接。请检查服务器的SSL证书配置，并确保证书链完整、证书有效。
未配置WebSocket容器支持TLS： WebSocket服务需要在HTTPS协议下运行时，需要WebSocket容器（如Tomcat、Jetty等）支持TLS。确保您的WebSocket容器已正确配置，以支持WebSocket over TLS（wss协议）。您可能需要在容器配置中启用TLS支持，并且将WebSocket协议升级到TLS。
防火墙或网络配置问题： 某些防火墙或网络设备可能会阻止WebSocket连接，特别是在使用非标准端口时。确保您的网络配置允许WebSocket流量通过，并且端口没有被防火墙或其他安全设备所阻止。
跨域资源共享（CORS）问题： 如果WebSocket服务与您的HTTPS网站位于不同的域名下，可能会遇到跨域问题。在服务器端配置合适的CORS规则以允许WebSocket连接跨域访问。
客户端证书验证问题： 如果您的服务器配置了客户端证书验证，确保客户端证书已正确配置，并且客户端可以提供有效的证书以建立连接。
日志调试： 在服务器和客户端启用详细的日志记录，以便排查连接失败的原因。查看服务器和客户端的日志文件，查找与WebSocket连接相关的错误或异常信息，以确定具体的问题。
问题场景： 前端地址：ws://127.0.0.1:19004/webSocket
当放在https协议下的情况下，ws会报异常
DOMException: Failed to construct ‘WebSocket’: An insecure WebSocket connection may not be initiated from a page loaded over HTTPS.
解决办法：
1、把ws协议换成wss协议
2、nginx配置反向代理
location /websocket { # 指向部署websocket的项目 proxy_pass http://127.0.0.1:19004/websocket; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "Upgrade"; proxy_set_header X-real-ip $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; } 3、最后前端访问地址：wss://example.com/websocket
4、测试连接成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a3b1ee5d2e1959b1bb7ba44e10d5270/" rel="bookmark">
			【前后端】django与vue的结合使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、前后端分离的简介二、django与vue的结合使用三、总结 前言 随着开发语言及人工智能工具的普及，使得越来越多的人会主动学习使用一些开发工具，本文主要介绍了django和vue的结合使用。
一、前后端分离的简介 前后端分离是一种软件架构模式，旨在将应用程序的前端和后端部分分开开发、部署和维护。在传统的单体应用中，前端和后端通常紧密耦合在一起，而前后端分离则将它们解耦，使得前端和后端可以独立地进行开发、测试和部署。
在前后端分离的架构中，前端负责用户界面和用户体验，而后端则负责业务逻辑、数据处理和持久化。前端通常由HTML、CSS和JavaScript等技术构建，而后端则可以使用各种后端编程语言和框架，比如Python的Django、Java的Spring、Node.js等。
以下是前后端分离的一些优势：
分工明确：前端和后端可以由不同的团队或开发者独立开发，减少了开发过程中的耦合和依赖。
技术选型灵活：前端和后端可以使用不同的技术栈，根据具体需求选择最合适的技术和工具。
提高开发效率：通过并行开发前后端，可以加快开发速度，缩短上线时间。
更好的可维护性：前后端分离使得代码结构更清晰，便于维护和扩展。
更好的用户体验：前端可以专注于用户界面和交互体验，提高用户满意度。
支持跨平台开发：通过API接口，前后端分离的应用可以更容易地支持多平台，如Web、移动端和桌面端。
然而，前后端分离也存在一些挑战：
跨域问题：前后端分离可能导致跨域请求问题，需要额外处理跨域请求。
部署复杂性：需要额外的部署步骤和配置来同时部署前端和后端，可能增加部署的复杂性。
数据传输格式：需要定义和维护前后端之间的数据传输格式，确保数据的一致性和正确性。
安全性：前后端分离可能增加一些安全风险，如跨站脚本攻击（XSS）和跨站请求伪造（CSRF）等。
二、django与vue的结合使用 Django和Vue.js结合使用是一种常见的方式，可以实现前后端分离，提高开发效率和灵活性。下面是一般的步骤：
创建Django项目：
使用Django的命令行工具创建一个新的Django项目。定义你的数据库模型，配置路由和视图。详细可以参考博客Django与Django REST Framework的结合使用 创建Vue.js应用：
在Django项目中创建一个新的文件夹，用于存放Vue.js应用。使用Vue CLI等工具初始化Vue.js应用。详细可以参考博客项目中如何快速构建vue脚手架 配置Vue.js应用：
在Vue.js应用中配置API请求，与Django后端进行通信。编写Vue组件来展示数据和处理用户交互。
集成Vue.js应用到Django项目：
将Vue.js应用构建后的静态文件（如HTML、CSS、JavaScript文件）放置在Django的静态文件目录中。在Django的模板中嵌入Vue.js应用的入口文件，以便在页面上加载Vue.js应用。
跨域请求处理（可选）：
如果Vue.js应用和Django后端部署在不同的域名下，可能需要处理跨域请求问题。可以通过Django的CORS中间件或者在Nginx/Apache等服务器上配置来实现。
开发和调试：
开发时可以使用Django的开发服务器和Vue CLI提供的开发服务器来分别运行后端和前端代码，并使用代理配置等方式解决跨域问题。在开发过程中，确保前后端的接口和数据格式一致，以便顺利通信。 部署：
当开发完成后，将Vue.js应用构建为生产环境的静态文件，并将其部署到生产服务器上。配置Django项目的生产环境，确保静态文件能够正确地被加载和提供。 这些是一般性的步骤，具体实现方式会根据项目需求和团队偏好有所不同。确保在整个过程中，前后端团队能够协作顺畅，保持沟通和交流。
三、总结 总的来说，前后端分离是一种灵活而强大的架构模式，适用于需要高度可扩展性和灵活性的应用程序开发。通过合适的技术选型和良好的设计实践，可以克服前后端分离可能带来的挑战，提高应用程序的质量和用户体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c206b948fa6b8383e8afe47f2f991e6/" rel="bookmark">
			Java 【数据结构】 二叉树（Binary_Tree）【神装】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		登神长阶
第五神装 二叉树 Binary-Tree
目录
🎷一.树形结构
🪗1.概念
🎸2.具体应用
🎹 二.二叉树（Binary Tree）
🎺1.概念
🎻2.表现形式
🪕3.特殊类型
🥁3.1完全二叉树（Complete Binary Tree）
🪘3.2满二叉树（Full Binary Tree）
🔋4.性质 🪫5.二叉树的遍历
💿5.1前中后序遍历
📀 5.2层序遍历
🔎 三.总结与反思
🎷一.树形结构 🪗1.概念 树形结构是一种在Java中常见的数据结构，它由节点（node）组成，这些节点之间以分支（branch）相连的方式形成层次关系。树形结构中通常包含一个根节点（root node），以及每个节点可能有零个或多个子节点（child nodes）。每个节点可以有一个父节点（parent node），除了根节点，它没有父节点。
在Java中，树形结构通常通过类和对象来表示。每个节点可以是一个类的实例，这个类通常包含一个指向父节点的引用和一个指向子节点的引用。通过这些引用，可以在树形结构中导航和操作节点。
树形结构在计算机科学中有广泛的应用，例如在文件系统中用于表示文件和文件夹的层次结构，在数据库中用于表示层次化数据，以及在图形用户界面（GUI）中用于构建菜单和组织UI元素等。
注意：树形结构中，子树之间不能有交集，否则就不是树形结构 🎸2.具体应用 树形结构在计算机科学和软件工程中有着广泛的应用，以下是一些常见的应用场景：
文件系统
文件系统通常以树形结构的形式来组织文件和目录，每个目录可以包含零个或多个子目录和文件，形成层次化的结构。这种结构使得用户可以方便地组织和管理文件。 数据库
在数据库中，树形结构常用于表示层次化数据，例如组织结构、产品分类、论坛板块等。通过树形结构，可以方便地进行数据检索、添加、删除和更新操作，同时保持数据的层次关系。 图形用户界面（GUI）
GUI 应用程序中经常使用树形结构来构建菜单、导航栏和组织 UI 元素。例如，文件资源管理器中的目录树、网站导航菜单等都是树形结构的应用。 编程语言中的抽象语法树（AST）
在编译器和解释器中，树形结构被用来表示源代码的抽象语法结构。抽象语法树（AST）将源代码表示为树的形式，每个节点代表源代码中的一个语法结构，如表达式、语句、函数等，方便进行语法分析和程序转换。 网络路由与拓扑排序
在网络领域，树形结构可以用于路由算法的实现，例如通过构建路由表来确定数据包的传输路径。此外，在计算机网络的拓扑结构中，也可以使用树形结构来表示网络节点之间的关系，进行拓扑排序和数据传输优化。 树形结构的应用不仅局限于以上几个领域，还涵盖了许多其他领域，如人工智能、游戏开发、数据可视化等。其灵活性和可扩展性使得树形结构成为解决各种复杂问题的有力工具。
🎹 二.二叉树（Binary Tree） 🎺1.概念 二叉树是树形结构中最常见的一种，具有以下基本概念：
结点的度：一个结点含有子树的个数称为该结点的度； 如上图：A的度为6 树的度：一棵树中，所有结点度的最大值称为树的度； 如上图：树的度为6 叶子结点或终端结点：度为0的结点称为叶结点； 如上图：B、C、H、I...等节点为叶结点 双亲结点或父结点：若一个结点含有子结点，则这个结点称为其子结点的父结点； 如上图：A是B的父结点 孩子结点或子结点：一个结点含有的子树的根结点称为该结点的子结点； 如上图：B是A的孩子结点 根结点：一棵树中，没有双亲结点的结点；如上图：A 结点的层次：从根开始定义起，根为第1层，根的子结点为第2层，以此类推树的高度或深度：树中结点的最大层次； 如上图：树的高度为4 树的以下概念只需了解，在看书时只要知道是什么意思即可： 非终端结点或分支结点：度不为0的结点； 如上图：D、E、F、G.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c206b948fa6b8383e8afe47f2f991e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32e5f6575ca50321b9c6278617f14d05/" rel="bookmark">
			LLama的激活函数SwiGLU 解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Swish激活函数
1. Swish函数公式
LLaMA模型中的激活函数
1. SwiGLU激活函数
2. SwiGLU激活函数的表达式
3. SwiGLU激活函数的优势
Swish激活函数 Swish是一种激活函数，其计算公式如下：
1. Swish函数公式 Swish(x) = x * sigmoid(x)
其中，sigmoid(x)是sigmoid函数，计算公式为：
sigmoid(x) = 1 / (1 + exp(-x))
Swish函数结合了线性函数和非线性函数的特点，能够自适应地调整激活函数的形状，因此在某些深度学习模型中，Swish函数的表现优于常见的ReLU函数。
LLaMA模型中的激活函数 在LLaMA模型中，使用的激活函数是SwiGLU[1][2][3]。
1. SwiGLU激活函数 SwiGLU是LLaMA模型在前馈神经网络（FFN）阶段使用的激活函数[2:1]。它取代了ReLU非线性函数，以提高模型的性能[3:1]。
2. SwiGLU激活函数的表达式 SwiGLU是Gated Linear Units（GLU）激活函数的一种变体，其公式为：
SwiGLU(x,W, V, b, c) = Swish_1(xW + b) ⊗ (xV + c)
其中，Swish_β(x) = x σ(β x)，σ为sigmoid函数，⊗为逐元素乘[1][2][3]。
3. SwiGLU激活函数的优势 SwiGLU的优势主要体现在以下几个方面：
3.1 提升性能：SwiGLU被应用于Transformer架构中的前馈神经网络（FFN）层，用于增强性能[1:1][2:1][3:1]。
3.2 可微性：SwiGLU是处处可微的非线性函数[1:2]。
3.3 自适应性：GLU是一种类似于长短期记忆网络（LSTM）带有门机制的网络结构，通过门机制控制信息通过的比例，来让模型自适应地选择哪些单词和特征对预测下一个词有帮助[3:2]。
import numpy as np import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32e5f6575ca50321b9c6278617f14d05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82143de029ee31a4ce1e305089deb200/" rel="bookmark">
			本地环境运行Llama 3大型模型：可行性与实践指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介： Llama 是由 Meta（前身为 Facebook）的人工智能研究团队开发并开源的大型语言模型（LLM），它对商业用途开放，对整个人工智能领域产生了深远的影响。继之前发布的、支持4096个上下文的Llama 2模型之后，Meta 进一步推出了性能更卓越的 Meta Llama 3系列语言模型，包括一个8B（80亿参数）模型和一个70B（700亿参数）模型。Llama 3 70B 的性能媲美 Gemini 1.5 Pro，全面超越 Claude 大杯，而 400B+ 的模型则有望与 Claude 超大杯和新版 GPT-4 Turbo 掰手腕
在各种测试基准中，Llama 3系列模型展现了其卓越的性能，它们在实用性和安全性评估方面与市场上其他流行的闭源模型相媲美，甚至在某些方面有所超越。Meta Llama 3系列的发布，不仅巩固了其在大型语言模型领域的竞争地位，而且为研究人员、开发者和企业提供了强大的工具，以推动语言理解和生成技术的进一步发展。
项目地址： https://github.com/meta-llama/llama3
llama2和llama3的差异 llama3和GPT4的差异 指标Llama 3GPT-4模型规模70B、400B+100B、175B、500B参数类型TransformerTransformer训练目标Masked Language Modeling、PerplexityMasked Language Modeling、Perplexity训练数据Books、WebTextBooks、WebText性能SOTA（问答、文本摘要、机器翻译等）SOTA（问答、文本摘要、机器翻译等）开源是否 Llama 3 的亮点 面向所有人开放：Meta 通过开源 Llama 3 的轻量版本，让前沿的 AI 技术变得触手可及。无论是开发者、研究人员还是对 AI 技术好奇的小伙伴，都可以自由地探索、创造和实验。 Llama 3 提供了易于使用的 API，方便研究人员和开发者使用。
模型规模大：Llama 3 400B+ 模型的参数规模达到了 4000 亿，属于大型语言模型。
即将融入各种应用： Llama 3 目前已经赋能 Meta AI，Meta AI体验地址：https://www.meta.ai/
在 Windows 上使用 Ollama，运行Llama3模型 访问https://ollama.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82143de029ee31a4ce1e305089deb200/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acb05b2bc8af2f45cd5e897d1e87597a/" rel="bookmark">
			【Java--数据结构】模拟实现ArrayList
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎关注个人主页：逸狼
创造不易，可以点点赞吗~
如有错误，欢迎指出~
目录
LIst
顺序表ArrayList
顺序表优点
IList接口
ArrayList中定义要操作的数组
在MyArrayList中 重写接口方法
新增元素
在指定位置插入元素
pos不合法异常
判断和查找元素
获取和更新元素
删除元素和清空顺序表
获取顺序表的长度和打印顺序表
LIst List是个接口，并不能直接用来实例化。 如果要使用，必须去实例化List的实现类。在集合框架中，ArrayList和LinkedList都实现了List接口。
ArrayList：实现了List接口，底层为动态类型顺序表LinkedList：实现了List接口，底层为双向链表 Java类和接口总览
顺序表ArrayList 顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存储。在数组上完成 数据的增删查改。
顺序表优点 适合根据 下标进行 查找 和 更新 的场景
访问速度比较快（在给定下标的情况下可以达到O（1））
下面我们要自己模拟实现一个 顺序表MyArrayList,理解它底层的数据结构原理，方便我们未来更好的使用ArrayList中的方法。
IList接口 package arrayList; public interface IList { // 新增元素,默认在数组最后新增 void add(int data); // 在 pos 位置新增元素 void add(int pos, int data) ; // 判定是否包含某个元素 boolean contains(int toFind); // 查找某个元素对应的位置 int indexOf(int toFind) ; // 获取 pos 位置的元素 int get(int pos) ; //给 pos 位置的元素设为 value void set(int pos, int value) ; //删除第一次出现的关键字key void remove(int toRemove) ; // 获取顺序表长度 int size() ; // 清空顺序表 void clear(); // 打印顺序表，注意：该方法并不是顺序表中的方法，为了方便看测试结果给出的 void display() ; boolean isFull(); } ArrayList中定义要操作的数组 package arrayList; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acb05b2bc8af2f45cd5e897d1e87597a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/344b6ec242a75a0508057622ceea74f9/" rel="bookmark">
			HBase的简单学习三
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 过滤器 1.1相关概念 1.过滤器可以根据列族、列、版本等更多的条件来对数据进行过滤，
基于 HBase 本身提供的三维有序（行键，列，版本有序），这些过滤器可以高效地完成查询过滤的任务，带有过滤器条件的 RPC 查询请求会把过滤器分发到各个 RegionServer（这是一个服务端过滤器），这样也可以降低网络传输的压力。
2.使用过滤器至少需要两类参数：
一类是抽象的操作符，另一类是比较器
3.过滤器的作用是在服务端判断数据是否满足条件，然后只将满足条件的数据返回给客户端
4.过滤器的类型很多，但是可以分为三大类：
比较过滤器：可应用于rowkey、列簇、列、列值过滤器
专用过滤器：只能适用于特定的过滤器
包装过滤器：包装过滤器就是通过包装其他过滤器以实现某些拓展的功能
1.2 CompareOperator 比较运算符 比较运算符
LESS &lt;
LESS_OR_EQUAL &lt;=
EQUAL =
NOT_EQUAL &lt;&gt;
GREATER_OR_EQUAL &gt;=
GREATER &gt;
NO_OP 排除所有
1.3 常见的六大比较器 BinaryComparator 按字节索引顺序比较指定字节数组，采用Bytes.compareTo(byte[])
BinaryPrefixComparator 通BinaryComparator，只是比较左端前缀的数据是否相同
NullComparator 判断给定的是否为空
BitComparator 按位比较
RegexStringComparator 提供一个正则的比较器，仅支持 EQUAL 和非EQUAL
SubstringComparator 判断提供的子串是否出现在中
二 常用的过滤器 2.1 行键过滤器 1.先将表名封装成一个TableName的对象
TableName tn = TableName.valueOf("表名");
2.获取表对象 使用数据库连接对象conn中的getTable获取表对象，参数是TableName的对象
Table table = conn.getTable(tn);
3.创建sacn对象
Scan scan = new Scan();
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/344b6ec242a75a0508057622ceea74f9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/32/">«</a>
	<span class="pagination__item pagination__item--current">33/71</span>
	<a class="pagination__item pagination__item--next btn" href="/page/34/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>