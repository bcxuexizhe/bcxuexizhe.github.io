<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python-VBA函数之旅-open函数 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/047cfa4448b03692f9c8955ad9b23c83/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Python-VBA函数之旅-open函数">
  <meta property="og:description" content="目录
一、open函数的常见应用场景
二、open函数使用注意事项
三、如何用好open函数？
1、open函数：
1-1、Python：
1-2、VBA：
2、推荐阅读：
个人主页：神奇夜光杯-CSDN博客 一、open函数的常见应用场景 open函数在Python中是一个非常重要的内置函数，用于打开文件以便进行读取、写入或追加等操作，常见的应用场景有：
1、读取文件内容：当你需要从一个文件中读取数据(如文本、配置、日志等)时，你可以使用 open()函数以只读模式(&#39;r&#39;)打开文件，并使用文件对象的 read()、readline()或readlines()方法来读取内容。
2、写入文件内容：如果你需要将数据写入一个文件(如生成报告、保存配置、记录日志等)，你可以使用open()函数以写入模式(&#39;w&#39;)或追加模式(&#39;a&#39;)打开文件，并使用文件对象的write()方法来写入内容。
3、处理二进制文件：对于需要处理图像、音频、视频等二进制文件时，你可以使用&#39;b&#39;标志来以二进制模式打开文件，这允许你读取和写入原始的字节数据。
4、逐行读取文件：当文件非常大或你只需要逐行处理文件时，可以使用readline()方法逐行读取文件，这可以减少内存使用并提高性能。
5、文件搜索和替换：你可以使用open()函数读取文件内容，然后使用字符串操作或正则表达式来搜索和替换文本，完成修改后，可以将新内容写回到原始文件或新文件中。
6、配置和数据存储：配置文件(如INI文件、JSON文件或YAML文件)和数据文件(如CSV文件)经常使用open()函数进行读取和写入，这些文件通常包含应用程序的配置信息或用户数据。
7、文件复制和移动：虽然open()函数本身不直接支持文件复制和移动，但你可以使用它结合其他文件操作函数(如shutil.copy()或os.rename())来实现这些功能。
8、文件锁定和并发访问：在多线程或多进程环境中，你可能需要锁定文件以防止并发访问导致的冲突。虽然Python标准库没有直接提供文件锁定机制，但你可以使用第三方库(如`fcntl`在Unix系统上)或操作系统特定的命令来实现文件锁定。
9、临时文件处理：使用open()函数与`tempfile`模块结合可以创建和管理临时文件，这对于需要临时存储数据的场景(如数据处理、文件转换等)非常有用。
10、与标准输入/输出交互：虽然不直接通过open()函数实现，但你可以使用文件对象与Python的标准输入(`sys.stdin`)和标准输出(`sys.stdout`)进行交互，这些文件对象与常规文件对象类似，允许你以类似的方式读取和写入数据。
11、文件备份与恢复：你可以使用open()函数来读取原始文件的内容，并将其写入另一个文件以创建备份；同样地，你也可以从备份文件中读取内容并将其写入原始文件以恢复数据。
12、文件加密和解密：在处理敏感数据时，加密是一个重要的安全措施。你可以使用open()函数来读取未加密的文件，使用加密算法对其进行加密，并将加密后的数据写入另一个文件；类似地，你也可以读取加密的文件，使用解密算法恢复原始数据，并将其写入一个新文件。
13、文件传输：在网络编程中，你可能需要从一个服务器读取文件并将其写入到另一个服务器，或者从一个文件读取数据并通过网络发送，open()函数可以用于这些场景中的文件读取和写入操作。
14、文本处理和数据分析：使用open()函数读取大量文本数据(如日志文件、文档等)，并使用Python的文本处理库(如正则表达式、NLTK等)进行分析；也可以结合数据科学库(如Pandas、NumPy等)进行更高级的数据处理和分析。
15、文件映射：对于非常大的文件，你可能希望将它们映射到内存中以便更高效地访问，虽然这不是open()函数直接提供的功能，但你可以使用`mmap`模块来映射已打开的文件。
16、监视文件变化：虽然这通常不是open()函数直接提供的功能，但你可以结合其他库(如`watchdog`)来监视文件系统的变化，包括新文件的创建、文件的修改或删除等。
17、网络文件和特殊设备： open()函数不仅限于处理本地文件系统上的文件，在某些情况下，你可以使用它来访问网络上的文件(如使用`ftplib`或`smbclient`等库)或特殊设备(如串口设备、数据库连接等)，这通常涉及到将设备或网络连接抽象为文件描述符或文件对象，并使用open()函数或类似机制进行访问。
总之，由于open()函数的灵活性和强大性，其在Python编程中几乎无处不在，几乎任何涉及文件操作的场景都会使用到它。
二、open函数使用注意事项 在使用Python的open()函数处理文件时，为了确保代码的正确性、安全性和性能，需注意以下事项：
1、文件路径和名称：确保文件路径和名称是正确的，并且指向了有效的文件；使用原始字符串(在字符串前加上`r`)来处理包含反斜杠(`\`)的Windows路径，以避免转义字符的问题。
2、文件打开模式：仔细选择正确的文件打开模式(如&#39;r&#39;、&#39;w&#39;、&#39;a&#39;、&#39;b&#39;等)，错误的模式可能导致数据丢失或无法访问文件；当你需要在读取和写入之间切换时，使用&#39;r&#43;&#39;、&#39;w&#43;&#39;或&#39;a&#43;&#39;模式。
3、文件关闭：使用`with`语句来自动关闭文件，即使发生异常也是如此，这可以避免资源泄露和潜在的安全风险；避免在`with`语句之外打开文件并忘记关闭它。
4、异常处理：当处理文件时，应准备好捕获并处理可能出现的异常，如`FileNotFoundError`、`PermissionError`等；使用`try-except`块来捕获和处理这些异常。
5、编码问题：在读取或写入文本文件时，确保指定了正确的字符编码(如&#39;utf-8&#39;)，错误的编码可能导致乱码或解码错误；如果不确定文件的编码，可以尝试使用`chardet`等库来检测文件的编码。
6、二进制文件：当处理二进制文件时(如图像、音频、视频等)，应使用二进制模式(在模式字符串后添加&#39;b&#39;)；避免在二进制模式下读取或写入文本数据，这可能导致数据损坏或不可读。
7、文件锁定和并发：在并发环境中，多个进程或线程可能同时访问同一个文件，为了避免数据竞争和不一致，可以考虑使用文件锁定机制；注意，Python标准库并没有直接提供文件锁定的功能，但你可以使用第三方库(如`fcntl`在Unix系统上)来实现。
8、文件大小和内存使用：在处理大文件时，避免一次性读取整个文件到内存中，使用逐行读取、块读取或其他内存友好的方法；考虑使用生成器或迭代器来逐步处理文件内容，以减少内存使用。
9、权限和安全性：确保你有足够的权限来读取或写入文件，如果文件受到保护或具有特定的权限设置，你可能需要额外的权限或认证；避免在代码中硬编码敏感信息(如密码、密钥等)，特别是当这些信息与文件访问相关时。
10、备份和恢复：在修改或删除文件之前，考虑先备份原始文件，这可以防止意外数据丢失或损坏；确保你有一种机制来恢复意外删除或修改的文件。
总之，只有牢记这些注意事项，你才能更安全、更有效地使用Python的open()函数来处理文件。
三、如何用好open函数？ 要用好Python中的open()函数，请遵循一下建议：
1、始终使用`with`语句：使用`with`语句可以确保文件在操作完成后被正确关闭，即使发生异常也是如此，这是处理文件时的最佳实践。
2、明确指定文件打开模式：根据你要进行的操作(读取、写入、追加、二进制等)明确指定文件打开模式。
3、异常处理：使用`try-except`块来处理可能出现的异常，如FileNotFoundError、PermissionError等。
4、编码问题：当读取或写入文本文件时，确保指定正确的字符编码，对于大多数情况，建议使用UTF-8编码。
5、避免硬编码：避免在代码中硬编码文件路径、文件名或打开模式，将这些值放在配置文件、环境变量或命令行参数中，以便更容易地修改它们。
6、二进制文件处理：当处理二进制文件时，使用二进制模式(在模式字符串后添加&#39;b&#39;)。
7、文件读写效率：对于大文件，避免一次性读取整个文件到内存中，使用逐行读取、块读取或其他内存友好的方法；写入大文件时，可以考虑使用write()方法的缓冲区(如果未指定，则使用默认的缓冲区大小)，或者调用flush()方法来手动刷新缓冲区。
8、文件锁定：在并发环境中，如果需要确保文件访问的原子性，可以考虑使用文件锁定机制，但是请注意，Python标准库并不直接提供跨平台的文件锁定机制，你可能需要使用第三方库。
9、安全性：避免在代码中硬编码敏感信息，如密码或密钥；如果你的应用程序需要处理来自不受信任来源的文件，请确保对它们进行适当的验证和清理，以防止安全漏洞(如目录遍历攻击)。
10、备份和版本控制：在修改或删除重要文件之前，始终备份原始文件；使用版本控制系统(如Git)来跟踪和管理文件的变化，以便在需要时可以轻松地回滚到以前的版本。
11、代码可读性和可维护性：使用有意义的变量名来代表文件对象；注释你的代码，解释你正在做什么以及为什么这样做；遵循一致的代码风和最佳实践，以提高代码的可读性和可维护性。
总之，通过遵循这些最佳实践和建议，你可以更好地利用Python中的open()函数来处理文件，并确保你的代码是健壮、安全和易于维护的。
1、open函数： 1-1、Python： # 1.函数：open # 2.功能：用于打开文件，返回一个文件读写对象，然后对文件进行相应读写操作 # 3.语法：open(file, mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) # 4.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-05T18:23:15+08:00">
    <meta property="article:modified_time" content="2024-05-05T18:23:15+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python-VBA函数之旅-open函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong><span style="color:#1a439c;">目录</span></strong></p> 
<p id="%E4%B8%80%E3%80%81open%E5%87%BD%E6%95%B0%E7%9A%84%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:80px;"><strong><a href="#%E4%B8%80%E3%80%81open%E5%87%BD%E6%95%B0%E7%9A%84%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow"><span style="color:#1a439c;">一、open函数的常见应用场景</span></a></strong></p> 
<p id="%E4%BA%8C%E3%80%81open%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-toc" style="margin-left:80px;"><strong><a href="#%E4%BA%8C%E3%80%81open%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" rel="nofollow"><span style="color:#1a439c;">二、open函数使用注意事项</span></a></strong></p> 
<p id="%E4%B8%89%E3%80%81%E5%A6%82%E4%BD%95%E7%94%A8%E5%A5%BDopen%E5%87%BD%E6%95%B0%EF%BC%9F-toc" style="margin-left:80px;"><strong><a href="#%E4%B8%89%E3%80%81%E5%A6%82%E4%BD%95%E7%94%A8%E5%A5%BDopen%E5%87%BD%E6%95%B0%EF%BC%9F" rel="nofollow"><span style="color:#1a439c;">三、如何用好open函数？</span></a></strong></p> 
<p id="1%E3%80%81open%E5%87%BD%E6%95%B0%EF%BC%9A-toc" style="margin-left:120px;"><strong><a href="#1%E3%80%81open%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow"><span style="color:#1a439c;">1、open函数：</span></a></strong></p> 
<p id="1-1%E3%80%81Python%EF%BC%9A-toc" style="margin-left:120px;"><strong><a href="#1-1%E3%80%81Python%EF%BC%9A" rel="nofollow"><span style="color:#1a439c;">1-1、Python：</span></a></strong></p> 
<p id="1-2%E3%80%81VBA%EF%BC%9A-toc" style="margin-left:120px;"><strong><a href="#1-2%E3%80%81VBA%EF%BC%9A" rel="nofollow"><span style="color:#1a439c;">1-2、VBA：</span></a></strong></p> 
<p id="2%E3%80%81%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0%EF%BC%9A-toc" style="margin-left:120px;"><strong><a href="#2%E3%80%81%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0%EF%BC%9A" rel="nofollow"><span style="color:#1a439c;">2、推荐阅读：</span></a></strong></p> 
<p id="%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%EF%BC%9Ahttps%3A%2F%2Fblog.csdn.net%2Fygb_1024%3Fspm%3D1010.2135.3001.5421%C2%A0-toc" style="margin-left:120px;"><strong><a href="#%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%EF%BC%9Ahttps%3A%2F%2Fblog.csdn.net%2Fygb_1024%3Fspm%3D1010.2135.3001.5421%C2%A0" rel="nofollow"><span style="color:#1a439c;">个人主页：神奇夜光杯-CSDN博客 </span></a></strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c6/2e/nssEDykL_o.gif"><img alt="" src="https://images2.imgbox.com/14/99/NG60NMqw_o.png"><img alt="" src="https://images2.imgbox.com/80/5f/KZdlcew0_o.gif"></p> 
<h4 id="%E4%B8%80%E3%80%81open%E5%87%BD%E6%95%B0%E7%9A%84%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><strong><span style="color:#1a439c;">一、open函数的常见应用场景</span></strong></h4> 
<p>        <strong><span style="color:#fe2c24;">open函数</span></strong>在Python中是一个非常重要的内置函数，<strong><span style="color:#fe2c24;">用于打开文件以便进行读取、写入或追加等操作</span></strong>，常见的应用场景有：</p> 
<p><strong><span style="color:#fe2c24;">1、读取文件内容：</span></strong>当你需要从一个文件中读取数据(如文本、配置、日志等)时，你可以使用 open()函数以只读模式('r')打开文件，并使用文件对象的 read()、readline()或readlines()方法来读取内容。</p> 
<p><span style="color:#fe2c24;"><strong>2、写入文件内容：</strong></span>如果你需要将数据写入一个文件(如生成报告、保存配置、记录日志等)，你可以使用open()函数以写入模式('w')或追加模式('a')打开文件，并使用文件对象的write()方法来写入内容。</p> 
<p><strong><span style="color:#fe2c24;">3、处理二进制文件：</span></strong>对于需要处理图像、音频、视频等二进制文件时，你可以使用'b'标志来以二进制模式打开文件，这允许你读取和写入原始的字节数据。</p> 
<p><strong><span style="color:#fe2c24;">4、逐行读取文件：</span></strong>当文件非常大或你只需要逐行处理文件时，可以使用readline()方法逐行读取文件，这可以减少内存使用并提高性能。</p> 
<p><span style="color:#fe2c24;"><strong>5、文件搜索和替换：</strong></span>你可以使用open()函数读取文件内容，然后使用字符串操作或正则表达式来搜索和替换文本，完成修改后，可以将新内容写回到原始文件或新文件中。</p> 
<p><strong><span style="color:#fe2c24;">6、配置和数据存储：</span></strong>配置文件(如INI文件、JSON文件或YAML文件)和数据文件(如CSV文件)经常使用open()函数进行读取和写入，这些文件通常包含应用程序的配置信息或用户数据。</p> 
<p><span style="color:#fe2c24;"><strong>7、文件复制和移动：</strong></span>虽然open()函数本身不直接支持文件复制和移动，但你可以使用它结合其他文件操作函数(如shutil.copy()或os.rename())来实现这些功能。</p> 
<p><strong><span style="color:#fe2c24;">8、文件锁定和并发访问：</span></strong>在多线程或多进程环境中，你可能需要锁定文件以防止并发访问导致的冲突。虽然Python标准库没有直接提供文件锁定机制，但你可以使用第三方库(如`fcntl`在Unix系统上)或操作系统特定的命令来实现文件锁定。</p> 
<p><strong><span style="color:#fe2c24;">9、临时文件处理：</span></strong>使用open()函数与`tempfile`模块结合可以创建和管理临时文件，这对于需要临时存储数据的场景(如数据处理、文件转换等)非常有用。</p> 
<p><strong><span style="color:#fe2c24;">10、与标准输入/输出交互：</span></strong>虽然不直接通过open()函数实现，但你可以使用文件对象与Python的标准输入(`sys.stdin`)和标准输出(`sys.stdout`)进行交互，这些文件对象与常规文件对象类似，允许你以类似的方式读取和写入数据。</p> 
<p><strong><span style="color:#fe2c24;">11、文件备份与恢复：</span></strong>你可以使用open()函数来读取原始文件的内容，并将其写入另一个文件以创建备份；同样地，你也可以从备份文件中读取内容并将其写入原始文件以恢复数据。</p> 
<p><strong><span style="color:#fe2c24;">12、文件加密和解密：</span></strong>在处理敏感数据时，加密是一个重要的安全措施。你可以使用open()函数来读取未加密的文件，使用加密算法对其进行加密，并将加密后的数据写入另一个文件；类似地，你也可以读取加密的文件，使用解密算法恢复原始数据，并将其写入一个新文件。</p> 
<p><strong><span style="color:#fe2c24;">13、文件传输：</span></strong>在网络编程中，你可能需要从一个服务器读取文件并将其写入到另一个服务器，或者从一个文件读取数据并通过网络发送，open()函数可以用于这些场景中的文件读取和写入操作。</p> 
<p><strong><span style="color:#fe2c24;">14、文本处理和数据分析：</span></strong>使用open()函数读取大量文本数据(如日志文件、文档等)，并使用Python的文本处理库(如正则表达式、NLTK等)进行分析；也可以结合数据科学库(如Pandas、NumPy等)进行更高级的数据处理和分析。</p> 
<p><strong><span style="color:#fe2c24;">15、文件映射：</span></strong>对于非常大的文件，你可能希望将它们映射到内存中以便更高效地访问，虽然这不是open()函数直接提供的功能，但你可以使用`mmap`模块来映射已打开的文件。</p> 
<p><strong><span style="color:#fe2c24;">16、监视文件变化：</span></strong>虽然这通常不是open()函数直接提供的功能，但你可以结合其他库(如`watchdog`)来监视文件系统的变化，包括新文件的创建、文件的修改或删除等。</p> 
<p><strong><span style="color:#fe2c24;">17、网络文件和特殊设备：</span></strong> open()函数不仅限于处理本地文件系统上的文件，在某些情况下，你可以使用它来访问网络上的文件(如使用`ftplib`或`smbclient`等库)或特殊设备(如串口设备、数据库连接等)，这通常涉及到将设备或网络连接抽象为文件描述符或文件对象，并使用open()函数或类似机制进行访问。</p> 
<p>        总之，由于<strong><span style="color:#fe2c24;">open()函数</span></strong>的灵活性和强大性，其在Python编程中几乎无处不在，<strong><span style="color:#fe2c24;">几乎任何涉及文件操作的场景都会使用到它。</span></strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/16/29/mjxftLqK_o.png"></p> 
<h4 id="%E4%BA%8C%E3%80%81open%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><strong><span style="color:#1a439c;">二、open函数使用注意事项</span></strong></h4> 
<p>        在使用Python的<strong><span style="color:#fe2c24;">open()函数</span></strong>处理文件时，为了确保代码的正确性、安全性和性能，需注意以下事项：</p> 
<p><strong><span style="color:#fe2c24;">1、文件路径和名称：</span></strong>确保文件路径和名称是正确的，并且指向了有效的文件；使用原始字符串(在字符串前加上`r`)来处理包含反斜杠(`\`)的Windows路径，以避免转义字符的问题。</p> 
<p><strong><span style="color:#fe2c24;">2、文件打开模式：</span></strong>仔细选择正确的文件打开模式(如'r'、'w'、'a'、'b'等)，错误的模式可能导致数据丢失或无法访问文件；当你需要在读取和写入之间切换时，使用'r+'、'w+'或'a+'模式。</p> 
<p><strong><span style="color:#fe2c24;">3、文件关闭：</span></strong>使用`with`语句来自动关闭文件，即使发生异常也是如此，这可以避免资源泄露和潜在的安全风险；避免在`with`语句之外打开文件并忘记关闭它。</p> 
<p><strong><span style="color:#fe2c24;">4、异常处理：</span></strong>当处理文件时，应准备好捕获并处理可能出现的异常，如`FileNotFoundError`、`PermissionError`等；使用`try-except`块来捕获和处理这些异常。</p> 
<p><strong><span style="color:#fe2c24;">5、编码问题：</span></strong>在读取或写入文本文件时，确保指定了正确的字符编码(如'utf-8')，错误的编码可能导致乱码或解码错误；如果不确定文件的编码，可以尝试使用`chardet`等库来检测文件的编码。</p> 
<p><strong><span style="color:#fe2c24;">6、二进制文件：</span></strong>当处理二进制文件时(如图像、音频、视频等)，应使用二进制模式(在模式字符串后添加'b')；避免在二进制模式下读取或写入文本数据，这可能导致数据损坏或不可读。</p> 
<p><strong><span style="color:#fe2c24;">7、文件锁定和并发：</span></strong>在并发环境中，多个进程或线程可能同时访问同一个文件，为了避免数据竞争和不一致，可以考虑使用文件锁定机制；注意，Python标准库并没有直接提供文件锁定的功能，但你可以使用第三方库(如`fcntl`在Unix系统上)来实现。</p> 
<p><strong><span style="color:#fe2c24;">8、文件大小和内存使用：</span></strong>在处理大文件时，避免一次性读取整个文件到内存中，使用逐行读取、块读取或其他内存友好的方法；考虑使用生成器或迭代器来逐步处理文件内容，以减少内存使用。</p> 
<p><strong><span style="color:#fe2c24;">9、权限和安全性：</span></strong>确保你有足够的权限来读取或写入文件，如果文件受到保护或具有特定的权限设置，你可能需要额外的权限或认证；避免在代码中硬编码敏感信息(如密码、密钥等)，特别是当这些信息与文件访问相关时。</p> 
<p><strong><span style="color:#fe2c24;">10、备份和恢复：</span></strong>在修改或删除文件之前，考虑先备份原始文件，这可以防止意外数据丢失或损坏；确保你有一种机制来恢复意外删除或修改的文件。</p> 
<p>        总之，只有牢记这些注意事项，你才能更安全、更有效地使用Python的<strong><span style="color:#fe2c24;">open()函数</span></strong>来处理文件。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/df/c9/a6E5mYqS_o.png"></p> 
<h4 id="%E4%B8%89%E3%80%81%E5%A6%82%E4%BD%95%E7%94%A8%E5%A5%BDopen%E5%87%BD%E6%95%B0%EF%BC%9F"><strong><span style="color:#1a439c;">三、如何用好open函数？</span></strong></h4> 
<p>        要用好Python中的<strong><span style="color:#fe2c24;">open()函数</span></strong>，请遵循一下建议：</p> 
<p><strong><span style="color:#fe2c24;">1、始终使用`with`语句：</span></strong>使用`with`语句可以确保文件在操作完成后被正确关闭，即使发生异常也是如此，这是处理文件时的最佳实践。</p> 
<p><strong><span style="color:#fe2c24;">2、明确指定文件打开模式：</span></strong>根据你要进行的操作(读取、写入、追加、二进制等)明确指定文件打开模式。</p> 
<p><strong><span style="color:#fe2c24;">3、异常处理：</span></strong>使用`try-except`块来处理可能出现的异常，如FileNotFoundError、PermissionError等。</p> 
<p><strong><span style="color:#fe2c24;">4、编码问题：</span></strong>当读取或写入文本文件时，确保指定正确的字符编码，对于大多数情况，建议使用UTF-8编码。</p> 
<p><strong><span style="color:#fe2c24;">5、避免硬编码：</span></strong>避免在代码中硬编码文件路径、文件名或打开模式，将这些值放在配置文件、环境变量或命令行参数中，以便更容易地修改它们。</p> 
<p><strong><span style="color:#fe2c24;">6、二进制文件处理：</span></strong>当处理二进制文件时，使用二进制模式(在模式字符串后添加'b')。</p> 
<p><strong><span style="color:#fe2c24;">7、文件读写效率：</span></strong>对于大文件，避免一次性读取整个文件到内存中，使用逐行读取、块读取或其他内存友好的方法；写入大文件时，可以考虑使用write()方法的缓冲区(如果未指定，则使用默认的缓冲区大小)，或者调用flush()方法来手动刷新缓冲区。</p> 
<p><strong><span style="color:#fe2c24;">8、文件锁定：</span></strong>在并发环境中，如果需要确保文件访问的原子性，可以考虑使用文件锁定机制，但是请注意，Python标准库并不直接提供跨平台的文件锁定机制，你可能需要使用第三方库。</p> 
<p><strong><span style="color:#fe2c24;">9、安全性：</span></strong>避免在代码中硬编码敏感信息，如密码或密钥；如果你的应用程序需要处理来自不受信任来源的文件，请确保对它们进行适当的验证和清理，以防止安全漏洞(如目录遍历攻击)。</p> 
<p><strong><span style="color:#fe2c24;">10、备份和版本控制：</span></strong>在修改或删除重要文件之前，始终备份原始文件；使用版本控制系统(如Git)来跟踪和管理文件的变化，以便在需要时可以轻松地回滚到以前的版本。</p> 
<p><strong><span style="color:#fe2c24;">11、代码可读性和可维护性：</span></strong>使用有意义的变量名来代表文件对象；注释你的代码，解释你正在做什么以及为什么这样做；遵循一致的代码风和最佳实践，以提高代码的可读性和可维护性。</p> 
<p>        总之，通过遵循这些最佳实践和建议，你可以更好地利用Python中的<span style="color:#fe2c24;"><strong>open()函数</strong></span>来处理文件，并确保你的代码是健壮、安全和易于维护的。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e0/ee/Q573llag_o.png"></p> 
<h5 id="1%E3%80%81open%E5%87%BD%E6%95%B0%EF%BC%9A">1、open函数：</h5> 
<h5 id="1-1%E3%80%81Python%EF%BC%9A">1-1、Python：</h5> 
<pre><code class="language-python"># 1.函数：open
# 2.功能：用于打开文件，返回一个文件读写对象，然后对文件进行相应读写操作
# 3.语法：open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
# 4.参数：
# 4-1、file(必须)：一个字符串或整数
# 4-1-1、相对路径：一个字符串，若文件在当前工作目录中或子文件夹下，则表示要打开的文件名/子文件夹下的文件名
# 4-1-2、绝对路径：一个字符串，若文件不在当前工作目录中，则表示需要输入包含盘符的完整文件路径
# 4-1-3、文件描述符：一个整数，用于在底层文件系统中打开的文件描述符
# 4-2、mode(可选)：一个字符串，用于指定文件的打开模式
#      使用前提：文件必须存在
# 4-2-1、r：默认模式，以只读模式打开文件，文件的指针将会放在文件的开头
# 4-2-2、rb：以二进制格式打开文件，并且采用只读模式，文件的指针将会放在文件的开头，一般用于图片、音频等
# 4-2-3、r+：打开文件后，可以读取文件内容，也可以写入新的内容覆盖原有内容(从文件开头进行覆盖)
# 4-2-4、rb+：以二进制格式打开文件，并且采用读写模式，文件的指针将会放在文件的开头，一般用于非文本文件，如图片、音频等
#      使用前提：文件可以不存在，但必须保证文件所在的目录存在
# 4-2-5、w：以只写模式打开文件，若文件存在，则将其覆盖；反之，则创建新文件
# 4-2-6、wb：以二进制格式打开文件，并且采用只写模式，一般用于非文本文件，如图片、音频等
# 4-2-7、w+：打开文件后，先清空原有内容，使其变为一个空的文件，对这个空文件拥有读写权限
# 4-2-8、wb+：以二进制格式打开文件，并且采用读写模式，一般用于非文本文件，如图片、音频等
#      其他情形：文件/文件所在的目录存在与否，不做要求
# 4-2-9、a：以追加模式打开文件，若文件存在，文件指针将放在文件末尾，即新内容会被追加写入到已有内容之后；反之，则创建新文件用于写入
# 4-2-10、ab：以二进制格式打开文件，并且采用追加模式，若文件存在，文件指针将放在文件的末尾，即新内容会被追加写入到已有内容之后；反之，则创建新文件用于写入
# 4-2-11、a+：以读写模式打开文件，若文件存在，文件指针将放在文件末尾，即新内容会被追加写入到已有内容之后；反之，则创建新文件用于写入
# 4-2-12、ab+：以二进制格式打开文件，并且采用追加模式，若文件存在，文件指针将放在文件的末尾，即新内容会被追加写入到已有内容之后；反之，则创建新文件用于读写
# 4-2-13、x：创建并写入模式，若文件存在，则会发生异常；反之，则创建新文件用于写入
# 4-2-14、t：文本模式，默认模式，通常不需要明确指定
# 4-3、buffering(可选)：用于指定读写文件的缓冲模式/策略
# 4-3-1、-1：默认模式，表示使用默认缓冲策略(通常是全缓冲或行缓冲，取决于平台和模式)
# 4-3-2、0：表示无缓冲(所有写入操作都直接写入磁盘)
# 4-3-3、1：表示行缓冲(仅在文本模式下有效)
# 4-3-4：&gt;1：如果设置为大于1的整数，则表示缓冲区大小
# 4-3-5：io.DEFAULT_BUFFER_SIZE：使用系统默认的缓冲区大小
# 4-4、encoding(可选)：用于解码或编码文件的编码方式，默认为None，表示使用现有平台默认的编码方式，一般为UTF-8；常见的编码方式有utf-8、ascii、latin1等
# 4-5、errors(可选)：表示读写文件时遇到错误的报错级别
# 4-5-1、strict：严格级别，字符编码有报错即抛出异常，默认级别，errors传入None即按此级别处理
# 4-5-2、ignore：忽略级别，字符编码有错误，忽略掉
# 4-5-3、replace：替换级别，字符编码有错的，替换成符号“？”
# 4-6、newline(可选)：表示控制文件读取和写入时如何处理换行符，只对文本模式有效，可以是 None、''、'\n'、'\r' 或 '\r\n'等，这对于跨平台文件兼容性可能很重要，因为不同的操作系统使用不同的换行符
# 4-7、closefd(可选)：表示传入的file参数类型，默认为True,传入文件路径时，一定为True;传入文件句柄，则为False
# 4-8、opener(可选)：一个可调用对象，用于打开文件描述符，默认为None;这通常不是必需的，但在需要自定义底层文件打开逻辑时可能会很有用
# 5.返回值：一个文件对象(file object)，也被称为文件句柄(file handle)
# 6.说明：
# 6-1、文件路径注意需要使用单引号或双引号括起来
# 6-2、使用read()方法读取文件内容时，如果文件大于可用内存，则不能实现文件的读取，而是返回空字符串
# 6-3、使用tell()方法返回的位置与为read()方法指定的size参数不同. tell()方法返回的不是字符的个数，而是字节数，其中汉字所占的字节数根据其采用的
#      编码有所不同，如果采用GBK编码，则一个汉字按两个字符计算；如果采用UTF-8编码，则一个汉字按3个字符计算
# 6-4、在指定encoding参数时，指定的编码一定是文件采用的编码，否则将抛出异常
# 7.示例：
# 用dir()函数获取该函数内置的属性和方法
print(dir(open))
# ['__call__', '__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__',
# '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__name__',
# '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__self__', '__setattr__', '__sizeof__',
# '__str__', '__subclasshook__', '__text_signature__']

# 用help()函数获取该函数的文档信息
help(open)

# 应用一：读取文件内容
# 示例1：读取整个文件内容
# 使用 'with' 语句打开文件
with open('file.txt', 'r') as file:
    content = file.read()  # 读取文件全部内容
    print(content)
    # 不需要显式调用 file.close()，因为 'with' 语句会自动处理
# 121314536273838390
# 123A
# 456B
# 789C
# 587
# 1024

# 示例2：逐行读取文件
# 使用 'with' 语句打开文件
with open('file.txt', 'r') as file:
    for line in file:  # 逐行读取文件
        print(line, end='')  # 打印每一行内容，end='' 用来避免默认的换行符
# 同样，'with' 语句会自动关闭文件
# 121314536273838390
# 123A
# 456B
# 789C
# 587
# 1024

# 示例3：读取指定字节数的文件内容
# 使用 'with' 语句打开文件，并指定读取的字节数
with open('file.txt', 'rb') as file:  # 'rb' 模式用于二进制读取
    content = file.read(10)  # 读取前10个字节
    print(content)
    # 注意：如果文件内容不是二进制数据（如文本），这种方式可能导致输出不可读
# b'1213145362'

# 示例4：跳过文件的开头部分并读取
with open('file.txt', 'r') as file:
    # 跳过开头的10个字符(或字节，在文本模式下)
    # 注意：在文本模式下，这可能不是完全准确的10个字符，因为编码问题
    file.seek(10)
    content = file.read()  # 从第10个字符之后开始读取
    print(content)
    # 'with' 语句结束时文件会被关闭
# 73838390
# 123A
# 456B
# 789C
# 587
# 1024

# 示例5：读取文件并处理每行内容(使用列表推导式)
# 使用 'with' 语句打开文件，并使用列表推导式处理每行内容
with open('file.txt', 'r') as file:
    lines = [line.strip() for line in file]  # 去除每行首尾的空白字符，并将结果存储到列表中
    print(lines)
    # 文件在 'with' 语句结束时被关闭，lines 列表包含了处理后的行内容
# ['121314536273838390', '123A', '456B', '789C', '587', '1024']

# 应用二：写入文件内容
# 示例1：写入整个字符串到文件
# 使用 'with' 语句打开文件，如果不存在则创建
with open('test.txt', 'w') as file:
    file.write('Hello, World!')  # 写入字符串到文件
# 'with' 语句结束时文件会被自动关闭

# 示例2：写入多行内容到文件
# 使用 'with' 语句打开文件
with open('test.txt', 'w') as file:
    file.write('I am Myelsa.\n')  # 写入第一行并添加换行符
    file.write('I love Python very much.\n')  # 写入第二行并添加换行符
# 文件在 'with' 语句结束时被关闭

# 示例3：写入列表中的每一行到文件
lines = ['Myelsa', 'Jimmy', 'Bruce']
# 使用 'with' 语句打开文件
with open('test.txt', 'w') as file:
    for line in lines:
        file.write(line + '\n')  # 写入每一行并添加换行符
# 文件在 'with' 语句结束时被关闭

# 示例4：追加内容到文件
# 使用 'a' 模式打开文件，用于追加内容
with open('test.txt', 'a') as file:
    file.write('Myelsa love Python very much.\n')  # 追加内容到文件末尾
# 文件在 'with' 语句结束时被关闭

# 示例5：写入二进制数据到文件
data = b'\x00\x01\x02\x03\x04'  # 二进制数据
# 使用 'wb' 模式打开文件用于二进制写入
with open('example.bin', 'wb') as file:
    file.write(data)  # 写入二进制数据到文件
# 文件在 'with' 语句结束时被关闭

# 应用三：处理二进制文件
# 示例1：读取二进制文件
# 使用 'rb' 模式打开二进制文件用于读取
with open('example.bin', 'rb') as file:
    binary_data = file.read()  # 读取整个文件作为二进制数据
# 处理二进制数据，例如打印前10个字节的十六进制表示
print(binary_data[:10].hex())
# 文件在 'with' 语句结束时被关闭
# 0001020304

# 示例2：写入二进制数据到文件
# 二进制数据，这里我们使用一个简单的字节字符串作为示例
binary_data = b'\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09'
# 使用 'wb' 模式打开二进制文件用于写入
with open('example.bin', 'wb') as file:
    file.write(binary_data)  # 写入二进制数据到文件
# 文件在 'with' 语句结束时被关闭

# 示例3：逐块读取大文件
chunk_size = 1024  # 设置每次读取的块大小为1024字节
# 使用 'rb' 模式打开二进制文件用于读取
with open('example.bin', 'rb') as file:
    while True:
        chunk = file.read(chunk_size)  # 读取一个块的数据
        if not chunk:  # 如果返回空字节串，表示已经到达文件末尾
            break
            # 在这里处理你的块数据，例如打印或处理
        print(chunk.hex())
        # 文件在 'with' 语句结束时被关闭
# 00010203040506070809

# 示例4：修改二进制文件
# 使用 'rb' 模式打开原始二进制文件用于读取
with open('example.bin', 'rb') as file:
    binary_data = file.read()  # 读取整个文件作为二进制数据
# 修改二进制数据，例如将前4个字节设置为0xFF, 0xFF, 0xFF, 0xFF
binary_data = b'\xFF\xFF\xFF\xFF' + binary_data[4:]
# 使用 'wb' 模式打开一个新文件用于写入修改后的数据
with open('modified_binary_file.bin', 'wb') as file:
    file.write(binary_data)  # 写入修改后的二进制数据到新文件
# 原始文件和新文件现在都有各自的文件句柄，并且都已在 'with' 语句结束时被关闭

# 应用四：逐行读取文件
# 示例1：逐行读取文本文件
# 使用 'with' 语句打开文件，并使用 'r' 模式（默认）来读取文件
with open('test.txt', 'r') as file:
    for line in file:  # 逐行读取文件
        print(line, end='')  # 打印每一行内容，end='' 避免默认的换行符（如果你想要保留原文件的换行符，可以去掉 end=''）
# 'with' 语句结束时文件会被自动关闭
# Myelsa
# Jimmy
# Bruce
# Myelsa love Python very much.

# 示例2：逐行读取并处理文件内容
total = 0
# 使用 'with' 语句打开文件
with open('file.txt', 'r') as file:
    for line in file:
        # 去除每行末尾的换行符，并将字符串转换为整数（假设每行只包含一个整数）
        number = int(line.strip())
        total += number  # 累加每行的数字
print(f"The total sum of numbers in the file is: {total}")
# 文件在 'with' 语句结束时被关闭
# The total sum of numbers in the file is: 121314536273841369

# 示例3：逐行读取并跳过空行
# 使用 'with' 语句打开文件
with open('test.txt', 'r') as file:
    for line in file:
        if line.strip():  # 如果行不是空的(即去除空白字符后还有内容)
            print(line, end='')  # 打印行内容
# 文件在 'with' 语句结束时被关闭
# Myelsa
# Jimmy
# Bruce
# Myelsa love Python very much.

# 应用五：文件搜索和替换
# 原始文件和目标文件可以是同一个文件，但这样操作会有风险，建议先写入临时文件再替换
original_file = 'file.txt'
# 如果要将结果写回到原文件，可以注释掉下面这行，并在最后将临时文件重命名为原文件名
temp_file = 'test.txt'
# 要搜索的字符串
search_string = '1'
# 要替换成的字符串
replace_string = 'm'
# 使用 'with' 语句打开原始文件以读取内容，同时打开临时文件以写入修改后的内容
with open(original_file, 'r', encoding='utf-8') as file, open(temp_file, 'w', encoding='utf-8') as temp:
    for line in file:
        # 替换文件中的字符串
        new_line = line.replace(search_string, replace_string)
        # 将替换后的行写入到临时文件中
        temp.write(new_line)
# 如果需要将结果写回到原文件，删除原文件并将临时文件重命名为原文件名
import os
if original_file != temp_file:
    os.remove(original_file)  # 删除原文件
    os.rename(temp_file, original_file)  # 重命名临时文件为原文件名
print(f"Search and replace operation completed in {original_file}")

# 应用六：配置和数据存储
# 示例1：写入JSON数据到文件
# 要写入的数据
data = {
    "name": "John Doe",
    "age": 30,
    "city": "New York"
}
# 使用 'w' 模式打开文件以写入内容
with open('data.json', 'w') as data_file:
    # 将Python字典写入文件为JSON格式
    json.dump(data, data_file)
    # data.json 文件现在包含了写入的数据

# 示例2：读取和写入INI配置文件
import configparser
# 读取INI配置文件
config = configparser.ConfigParser()
config.read('config.ini')
# 访问配置项
print(config['section_name']['setting_name'])
# 写入INI配置文件
config['new_section'] = {'new_setting': 'new_value'}

with open('config.ini', 'w') as config_file:
    config.write(config_file)
    # config.ini 文件现在包含了新的配置项

# 示例3：读取和写入CSV文件
import csv
# 读取CSV文件
with open('data.csv', 'r', newline='') as csv_file:
    reader = csv.reader(csv_file)
    for row in reader:
        print(row)
# 写入CSV文件
data = [['Name', 'Age'], ['Myelsa', 18], ['Bruce', 6]]
with open('data.csv', 'w', newline='') as csv_file:
    writer = csv.writer(csv_file)
    writer.writerows(data)
    # data.csv 文件现在包含了写入的数据

# 应用七：文件锁定和并发访问
import fcntl
import os
def lock_file(file_path):
    # 打开文件，以写入模式（这会创建文件如果它不存在）
    with open(file_path, 'w+') as file_obj:
        # 尝试获取独占锁（写锁）
        try:
            fcntl.flock(file_obj, fcntl.LOCK_EX | fcntl.LOCK_NB)
            print(f"文件 {file_path} 已锁定")
            # 在这里进行文件操作，如读写等
            # ...
        except IOError:
            print(f"无法锁定文件 {file_path}，可能已被其他进程锁定")
        finally:
            # 释放锁
            fcntl.flock(file_obj, fcntl.LOCK_UN)
# 使用示例
lock_file('example.lock')

# 应用八：临时文件处理
# 示例1：创建临时目录
import tempfile
import os
# 创建一个临时目录
with tempfile.TemporaryDirectory() as temp_dir:
    print(f"临时目录已创建：{temp_dir}")
    # 在临时目录中创建一个文件
    with open(os.path.join(temp_dir, 'file_1.txt'), 'w') as f:
        f.write('这是一个在临时目录中的文件\n')
        # 你可以在这里做其他与临时目录相关的操作
# 临时目录在with块结束后会被自动删除
# 临时目录已创建：C:\Users\Administrator\AppData\Local\Temp\tmp_v1na9w7

# 应用九：与标准输入/输出交互
# 示例1：重定向标准输入/输出
import sys
# 将标准输出重定向到一个文件
with open('file.txt', 'w') as f:
    sys.stdout = f  # 现在print将写入到文件而不是控制台
    print("这条消息将被写入到file.txt")
# 恢复标准输出到控制台
sys.stdout = sys.__stdout__
print("Myelsa love Python very much.")
# Myelsa love Python very much.

# 应用十：文件备份与恢复
# 示例1：备份文件
def backup_file(source_file, backup_file):
    try:
        with open(source_file, 'rb') as source, open(backup_file, 'wb') as backup:
            backup.write(source.read())
        print(f"文件 {source_file} 已成功备份到 {backup_file}")
    except FileNotFoundError:
        print(f"文件 {source_file} 不存在，无法备份。")
    except Exception as e:
        print(f"备份文件时发生错误：{e}")
# 使用示例
backup_file('original.txt', 'original_backup.txt')

# 示例2：恢复文件
def restore_file(backup_file, source_file):
    try:
        with open(backup_file, 'rb') as backup, open(source_file, 'wb') as source:
            source.write(backup.read())
        print(f"文件 {source_file} 已成功从 {backup_file} 恢复。")
    except FileNotFoundError:
        print(f"备份文件 {backup_file} 不存在，无法恢复。")
    except PermissionError:
        print(f"没有权限写入文件 {source_file}，无法恢复。")
    except Exception as e:
        print(f"恢复文件时发生错误：{e}")
# 使用示例(假设你已经备份了original.txt)
# 警告：这将会覆盖原始文件！确保这是你想要的。
restore_file('original_backup.txt', 'original.txt')

# 应用十一：文件加密和解密
# 示例1：加密文件
from cryptography.fernet import Fernet
import os
def encrypt_file(input_filename, output_filename, key):
    cipher_suite = Fernet(key)
    with open(input_filename, "rb") as file:
        # 读取文件内容
        data = file.read()
    # 加密文件内容
    encrypted_data = cipher_suite.encrypt(data)
    with open(output_filename, "wb") as file:
        # 写入加密后的内容
        file.write(encrypted_data)
# 示例使用
key = Fernet.generate_key()  # 生成一个随机的密钥，实际应用中需要安全地存储这个密钥
encrypt_file('input.txt', 'encrypted.txt', key)
print("文件已加密并保存为 encrypted.txt")

# 示例2：解密文件
from cryptography.fernet import Fernet
def decrypt_file(input_filename, output_filename, key):
    cipher_suite = Fernet(key)
    with open(input_filename, "rb") as file:
        # 读取加密的文件内容
        encrypted_data = file.read()
    # 解密文件内容
    decrypted_data = cipher_suite.decrypt(encrypted_data)
    with open(output_filename, "wb") as file:
        # 写入解密后的内容
        file.write(decrypted_data)
# 示例使用，使用与加密时相同的密钥
decrypt_file('encrypted.txt', 'decrypted.txt', key)
print("文件已解密并保存为 decrypted.txt")

# 应用十二：文件传输
import os
import shutil
def copy_file(source_path, destination_path):
    # 检查源文件是否存在
    if not os.path.exists(source_path):
        print(f"源文件 {source_path} 不存在。")
        return
    # 检查目标目录是否存在，如果不存在则创建
    if not os.path.exists(os.path.dirname(destination_path)):
        os.makedirs(os.path.dirname(destination_path))
    # 使用shutil库复制文件，但为了模拟使用open()函数，我们手动实现
    try:
        with open(source_path, 'rb') as source_file, open(destination_path, 'wb') as destination_file:
            # 读取源文件内容并写入目标文件
            while True:
                data = source_file.read(1024)  # 每次读取1024字节
                if not data:
                    break
                destination_file.write(data)
        print(f"文件已成功从 {source_path} 传输到 {destination_path}")
    except Exception as e:
        print(f"文件传输过程中发生错误：{e}")
# 使用示例
source_file = 'path/to/source/file.txt'
destination_file = 'path/to/destination/file.txt'
copy_file(source_file, destination_file)

# 应用十三：文本处理和数据分析
import csv
# 假设CSV文件有两列：姓名,年龄
total_age = 0
age_count = 0
min_age = float('inf')  # 初始化为正无穷大
max_age = float('-inf')  # 初始化为负无穷大
with open('data.csv', 'r', encoding='utf-8', newline='') as csvfile:
    reader = csv.reader(csvfile)
    next(reader, None)  # 跳过表头(如果有的话)
    for row in reader:
        name, age_str = row  # 假设CSV中没有其他额外的列或空值
        try:
            age = int(age_str)  # 转换年龄为整数
            total_age += age
            age_count += 1
            if age &lt; min_age:
                min_age = age
            if age &gt; max_age:
                max_age = age
        except ValueError:
            print(f"无法解析年龄：{age_str}（跳过此行）")
# 计算平均年龄
average_age = total_age / age_count if age_count &gt; 0 else 0
# 输出结果
print(f"总年龄：{total_age}")
print(f"年龄数量：{age_count}")
print(f"最小年龄：{min_age}")
print(f"最大年龄：{max_age}")
print(f"平均年龄：{average_age}")

# 应用十四：文件映射
# 创建一个颜色到RGB值的映射字典
color_to_rgb = {
    'red': '(255, 0, 0)',
    'green': '(0, 255, 0)',
    'blue': '(0, 0, 255)',
    # ... 其他颜色
}
# 打开文本文件以进行读取和写入（由于我们将覆盖原文件，所以需要写入权限）
with open('colors.txt', 'r', encoding='utf-8') as file, open('colors_mapped.txt', 'w', encoding='utf-8') as outfile:
    # 逐行读取文本文件
    for line in file:
        # 对每一行进行文本映射（替换颜色名称）
        for color, rgb in color_to_rgb.items():
            line = line.replace(color, rgb)
            # 将映射后的行写入新的文件
        outfile.write(line)
        # 现在'colors_mapped.txt'文件包含了映射后的颜色值

# 应用十五：监视文件变化(使用watchdog替代方案)
import time
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
class MyHandler(FileSystemEventHandler):
    def on_modified(self, event):
        if not event.is_directory:
            print(f"文件 {event.src_path} 已被修改")
# 你还可以添加其他事件处理方法，如 on_created, on_deleted, on_moved 等
if __name__ == "__main__":
    path_to_watch = "/path/to/directory"  # 替换为你想要监视的目录路径
    event_handler = MyHandler()
    observer = Observer()
    observer.schedule(event_handler, path_to_watch, recursive=True)  # recursive=True 表示递归监视子目录
    observer.start()
    try:
        while True:
            time.sleep(1)  # 保持主线程活跃，以便监视器可以运行
    except KeyboardInterrupt:
        observer.stop()
    observer.join()

# 应用十六：网络文件和特殊设备
# 示例1：处理网络文件(例如，通过HTTP下载文件)
import requests
def download_file_from_url(url, save_path):
    response = requests.get(url, stream=True)
    if response.status_code == 200:
        with open(save_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)
    else:
        print(f"Failed to download file, status code: {response.status_code}")
# 使用示例
url = 'http://example.com/somefile.txt'
save_path = 'local_copy_of_somefile.txt'
download_file_from_url(url, save_path)

# 示例2：处理特殊设备(例如，通过串口通信读取数据)
# 对于特殊设备(如串口设备)，你可以使用pySerial库
import serial
def read_from_serial_port(port, baudrate):
    ser = serial.Serial(port, baudrate, timeout=1)
    if ser.isOpen():
        print('Serial port is open.')
        data = ser.readline().decode('utf-8').rstrip()  # 读取一行数据并解码
        print('Received:', data)
        ser.close()  # 关闭串口
    else:
        print('Unable to open serial port')
# 使用示例
port = '/dev/ttyUSB0'  # 对于Linux系统，串口可能类似于/dev/ttyUSB0或/dev/ttyS0
baudrate = 9600
read_from_serial_port(port, baudrate)

# 示例3：处理网络文件系统(例如，通过SSH/SFTP访问远程文件)
# 对于网络文件系统，如SSH或SFTP，你可以使用paramiko库
import paramiko
def sftp_get_file(hostname, port, username, password, remote_path, local_path):
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())  # 自动添加主机名及主机密钥到本地HostKeys对象，并保存  
    ssh.connect(hostname, port, username, password)
    sftp = ssh.open_sftp()
    sftp.get(remote_path, local_path)  # 从远程路径下载文件到本地路径  
    sftp.close()
    ssh.close()
# 使用示例  
hostname = 'remote.example.com'
port = 22
username = 'your_username'
password = 'your_password'
remote_path = '/path/to/remote/file.txt'
local_path = '/path/to/local/file.txt'
sftp_get_file(hostname, port, username, password, remote_path, local_path)</code></pre> 
<h5 id="1-2%E3%80%81VBA%EF%BC%9A">1-2、VBA：</h5> 
<pre><code class="language-vbnet">略，待后补。</code></pre> 
<h5 id="2%E3%80%81%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0%EF%BC%9A">2、推荐阅读：</h5> 
<p><strong>2-1、<a class="link-info" href="https://myelsa1024.blog.csdn.net/article/details/138326048?spm=1001.2014.3001.5502" rel="nofollow" title="Python-VBA函数之旅-object基类">Python-VBA函数之旅-object基类</a></strong></p> 
<p id="Myelsa%E7%9A%84Python%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85(%E9%AB%98%E9%93%81%E7%9B%B4%E8%BE%BE)%EF%BC%9AMyelsa%E7%9A%84Python%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85(%E9%AB%98%E9%93%81%E7%9B%B4%E8%BE%BE)-CSDN%E5%8D%9A%E5%AE%A2"><strong><span style="color:#956fe7;">Python算法之旅：</span><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><a href="https://blog.csdn.net/ygb_1024/article/details/136889623?spm=1001.2014.3001.5501" title="Algorithm">Algorithm</a></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p> 
<p><strong><span style="color:#956fe7;">Python函数之旅：</span><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><a href="https://myelsa1024.blog.csdn.net/article/details/137436363?spm=1001.2014.3001.5502" rel="nofollow" title="Functions">Functions</a></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p> 
<h5 id="%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%EF%BC%9Ahttps%3A%2F%2Fblog.csdn.net%2Fygb_1024%3Fspm%3D1010.2135.3001.5421%C2%A0"><strong><span style="color:#956fe7;">个人主页：</span><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><a href="https://blog.csdn.net/ygb_1024?spm=1010.2135.3001.5421" title="神奇夜光杯-CSDN博客">神奇夜光杯-CSDN博客</a></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong> </strong></h5>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/45928ea0c7fb643f997c0b0f83d91afa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">微调llama 3 — PEFT微调和全量微调</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b80b7614400090840c4f0fb32fcaa964/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Angular进阶-NVM管理Node.js实现不同版本Angular环境切换</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>