<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深入探索 Python 中的动态数组：实现、操作、优化及其与传统数组和其他数据结构的性能比较 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/645d81e0a9266195b2458f1e91794ec4/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="深入探索 Python 中的动态数组：实现、操作、优化及其与传统数组和其他数据结构的性能比较">
  <meta property="og:description" content="文章目录 1. 简介1.1 什么是动态数组？1.2 Python 中的动态数组与传统数组的比较1.3 动态数组与其他数据结构的性能比较 2. Python 中的动态数组实现2.1 Python 列表的基本特性2.2 如何在 Python 中使用列表模拟动态数组 3. 内部工作原理3.1 列表的存储结构：如何在内存中表示3.2 动态调整大小：当数组达到当前容量时，Python 如何调整其大小3.3 时间复杂度分析：对添加元素的平摊时间复杂度进行分析 4. 列表的缩减4.1 使用 `del` 语句删除元素4.2 重新分配或通过切片调整大小 5. 优化和局限性5.1 如何优化列表操作5.2 动态数组的局限性 动态数组作为一种灵活的数据结构，其重要性不言而喻。
1. 简介 1.1 什么是动态数组？ 动态数组是一种数组，它可以在运行时动态调整其大小，以适应需要存储的数据量的变化。与静态数组不同，静态数组在创建时需要指定大小，并且其大小在整个生命周期中保持不变。动态数组通过在数组达到其容量极限时自动重新分配内存，并将元素复制到新的、更大的内存区域中来实现这一点。这种灵活性使得动态数组成为很多编程任务中非常受欢迎的数据结构。
在 Python 中，动态数组通常是通过列表（list）数据类型实现的。列表允许程序员在不关心底层数据存储细节的情况下，添加、删除和修改元素。
1.2 Python 中的动态数组与传统数组的比较 大小调整： 传统数组（如 C 或 Java 中的数组）：通常需要在编写代码时确定数组的大小，且一旦设置，数组的大小不能更改。Python 列表：不需要事先声明大小。列表的大小是动态和灵活的，可以根据需要增长或缩减。 性能考虑： 传统数组：访问元素的时间复杂度为 O(1)，因为它们提供直接的内存访问。Python 列表：同样提供 O(1) 时间复杂度的元素访问。但是，当列表需要扩容时（例如添加更多元素超过当前容量时），需要重新分配内存和复制现有元素到新的内存地址，这个操作的平均时间复杂度是 O(n)。 内存使用： 传统数组：可能会有内存浪费，如果数组的分配大小大于实际需要。Python 列表：更加灵活地管理内存，只有在需要更多空间时才进行内存重新分配，并且通常会按比当前需要稍大的量进行分配，以减少频繁的内存分配。 易用性： 传统数组：使用起来可能较为复杂，需要处理低级的内存管理问题。Python 列表：极大简化了数组操作，用户无需直接管理内存，可以使用多种便捷的方法进行列表操作，如 append(), remove(), pop() 等。 1.3 动态数组与其他数据结构的性能比较 动态数组（Python 列表）与其他数据结构如字典、集合和元组的性能比较主要集中在几个方面：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-29T10:20:52+08:00">
    <meta property="article:modified_time" content="2024-04-29T10:20:52+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深入探索 Python 中的动态数组：实现、操作、优化及其与传统数组和其他数据结构的性能比较</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#1__5" rel="nofollow">1. 简介</a></li><li><ul><li><a href="#11__7" rel="nofollow">1.1 什么是动态数组？</a></li><li><a href="#12_Python__13" rel="nofollow">1.2 Python 中的动态数组与传统数组的比较</a></li><li><a href="#13__28" rel="nofollow">1.3 动态数组与其他数据结构的性能比较</a></li></ul> 
   </li><li><a href="#2_Python__42" rel="nofollow">2. Python 中的动态数组实现</a></li><li><ul><li><a href="#21_Python__44" rel="nofollow">2.1 Python 列表的基本特性</a></li><li><a href="#22__Python__54" rel="nofollow">2.2 如何在 Python 中使用列表模拟动态数组</a></li></ul> 
   </li><li><a href="#3__103" rel="nofollow">3. 内部工作原理</a></li><li><ul><li><a href="#31__105" rel="nofollow">3.1 列表的存储结构：如何在内存中表示</a></li><li><a href="#32_Python__112" rel="nofollow">3.2 动态调整大小：当数组达到当前容量时，Python 如何调整其大小</a></li><li><a href="#33__119" rel="nofollow">3.3 时间复杂度分析：对添加元素的平摊时间复杂度进行分析</a></li></ul> 
   </li><li><a href="#4__128" rel="nofollow">4. 列表的缩减</a></li><li><ul><li><a href="#41__del__132" rel="nofollow">4.1 使用 `del` 语句删除元素</a></li><li><a href="#42__142" rel="nofollow">4.2 重新分配或通过切片调整大小</a></li></ul> 
   </li><li><a href="#5__153" rel="nofollow">5. 优化和局限性</a></li><li><ul><li><a href="#51__155" rel="nofollow">5.1 如何优化列表操作</a></li><li><a href="#52__166" rel="nofollow">5.2 动态数组的局限性</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<blockquote> 
 <p>动态数组作为一种灵活的数据结构，其重要性不言而喻。</p> 
</blockquote> 
<h3><a id="1__5"></a>1. 简介</h3> 
<h4><a id="11__7"></a>1.1 什么是动态数组？</h4> 
<p>动态数组是一种数组，它可以在运行时动态调整其大小，以适应需要存储的数据量的变化。与静态数组不同，静态数组在创建时需要指定大小，并且其大小在整个生命周期中保持不变。动态数组通过在数组达到其容量极限时自动重新分配内存，并将元素复制到新的、更大的内存区域中来实现这一点。这种灵活性使得动态数组成为很多编程任务中非常受欢迎的数据结构。</p> 
<p>在 Python 中，动态数组通常是通过列表（<code>list</code>）数据类型实现的。列表允许程序员在不关心底层数据存储细节的情况下，添加、删除和修改元素。</p> 
<h4><a id="12_Python__13"></a>1.2 Python 中的动态数组与传统数组的比较</h4> 
<ol><li><strong>大小调整：</strong> 
  <ul><li><strong>传统数组（如 C 或 Java 中的数组）</strong>：通常需要在编写代码时确定数组的大小，且一旦设置，数组的大小不能更改。</li><li><strong>Python 列表</strong>：不需要事先声明大小。列表的大小是动态和灵活的，可以根据需要增长或缩减。</li></ul> </li><li><strong>性能考虑：</strong> 
  <ul><li><strong>传统数组</strong>：访问元素的时间复杂度为 O(1)，因为它们提供直接的内存访问。</li><li><strong>Python 列表</strong>：同样提供 O(1) 时间复杂度的元素访问。但是，当列表需要扩容时（例如添加更多元素超过当前容量时），需要重新分配内存和复制现有元素到新的内存地址，这个操作的平均时间复杂度是 O(n)。</li></ul> </li><li><strong>内存使用：</strong> 
  <ul><li><strong>传统数组</strong>：可能会有内存浪费，如果数组的分配大小大于实际需要。</li><li><strong>Python 列表</strong>：更加灵活地管理内存，只有在需要更多空间时才进行内存重新分配，并且通常会按比当前需要稍大的量进行分配，以减少频繁的内存分配。</li></ul> </li><li><strong>易用性：</strong> 
  <ul><li><strong>传统数组</strong>：使用起来可能较为复杂，需要处理低级的内存管理问题。</li><li><strong>Python 列表</strong>：极大简化了数组操作，用户无需直接管理内存，可以使用多种便捷的方法进行列表操作，如 <code>append()</code>, <code>remove()</code>, <code>pop()</code> 等。</li></ul> </li></ol> 
<h4><a id="13__28"></a>1.3 动态数组与其他数据结构的性能比较</h4> 
<p>动态数组（Python 列表）与其他数据结构如字典、集合和元组的性能比较主要集中在几个方面：</p> 
<ul><li><strong>访问速度</strong>： 
  <ul><li>列表提供了快速的索引访问（O(1)），适合于有序集合和需要按索引访问的场景。</li><li>字典和集合提供了基于哈希的快速查找（平均 O(1)），更适合于需要快速查找、添加和删除的场景。</li></ul> </li><li><strong>内存效率</strong>： 
  <ul><li>列表可能在存储大量数据时占用更多内存，因为它们需要额外的空间来支持动态调整大小。</li><li>元组是不可变的，通常比列表更内存效率高，适合存储不需要修改的数据集。</li></ul> </li><li><strong>操作性能</strong>： 
  <ul><li>对于大量的插入和删除操作，特别是在列表中间，列表的性能可能会受到影响。在这种情况下，双端队列（如 <code>collections.deque</code>）可能提供更好的性能。</li><li>数值计算或大规模元素操作中，NumPy 数组提供了比列表更优化的性能。</li></ul> </li></ul> 
<h3><a id="2_Python__42"></a>2. Python 中的动态数组实现</h3> 
<h4><a id="21_Python__44"></a>2.1 Python 列表的基本特性</h4> 
<p>Python 列表是一种灵活的数据结构，它允许用户存储不同类型的数据项。这些特性使 Python 列表成为实现动态数组的理想选择：</p> 
<ul><li><strong>动态类型</strong>：列表可以同时包含不同类型的元素，例如整数、字符串、对象等。</li><li><strong>可变大小</strong>：列表的大小不是固定的，可以随时添加或删除元素，列表会自动调整其内存大小。</li><li><strong>支持切片操作</strong>：可以非常方便地访问列表的子集，这对于进行数据分析和处理特别有用。</li><li><strong>内置方法</strong>：Python 提供了丰富的列表操作方法，如 <code>append()</code>, <code>pop()</code>, <code>extend()</code>, <code>insert()</code> 和 <code>remove()</code> 等，这些方法简化了列表的操作并使其功能强大。</li><li><strong>迭代支持</strong>：列表支持迭代，意味着可以直接在循环结构中使用列表，或者通过列表推导式进行高效的数据处理。</li></ul> 
<h4><a id="22__Python__54"></a>2.2 如何在 Python 中使用列表模拟动态数组</h4> 
<p>在 Python 中，列表由于其内部实现的灵活性，<strong>本质上就是一个动态数组</strong>。下面是如何使用 Python 列表来模拟动态数组的一些基本操作：</p> 
<ul><li> <p><strong>初始化</strong>：创建一个空列表或使用一组初始值填充列表。</p> <pre><code class="prism language-python">list1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>           <span class="token comment"># 空列表</span>
list2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>    <span class="token comment"># 初始化包含元素的列表</span>
</code></pre> </li><li> <p><strong>添加元素</strong>：使用 <code>append()</code> 方法在列表末尾添加元素，这是 O(1) 操作的平摊时间复杂度。</p> <pre><code class="prism language-python">list1<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>    <span class="token comment"># 在 list1 添加元素 'a'</span>
</code></pre> </li><li> <p><strong>插入元素</strong>：使用 <code>insert()</code> 方法在列表的指定位置插入一个元素。这通常是 O(n) 操作，因为它需要移动插入点后的所有元素。</p> <pre><code class="prism language-python">list1<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">)</span> <span class="token comment"># 在索引 1 的位置插入元素 'b'</span>
</code></pre> </li><li> <p><strong>删除元素</strong>：可以使用 <code>pop()</code> 来删除并返回列表中的最后一个元素（这是一个 O(1) 操作），或者使用 <code>pop(index)</code> 来删除特定位置的元素（这是一个 O(n) 操作，因为它需要移动之后的所有元素）。</p> <pre><code class="prism language-python">list1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token comment"># 删除并返回最后一个元素</span>
list1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>         <span class="token comment"># 删除并返回索引 0 处的元素</span>
</code></pre> </li><li> <p><strong>扩展列表</strong>：<code>extend()</code> 方法用于一次性添加多个元素到列表末尾。这个方法可以接受任何可迭代对象（如另一个列表、元组、集合等），将其所有元素添加到当前列表中。这比使用多次 <code>append()</code> 方法更为高效，尤其是在添加大量元素时。</p> 
  <ul><li><code>extend(other)</code>：如果 <code>other</code> 的大小是 k，则整个操作的复杂度是 O(k)，假设不需要扩容。如果需要扩容，复杂度可能达到 O(n+k)。</li><li>扩容：当执行操作如 <code>append()</code> 导致容量不足时，列表会自动扩容，这通常涉及到一次成本较高的内存重新分配和数据复制，但其平摊复杂度为 O(1)。</li></ul> <pre><code class="prism language-python">list1<span class="token punctuation">.</span>extend<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 在 list1 的末尾添加多个元素</span>
</code></pre> </li><li> <p><strong>删除元素</strong>：<code>remove()</code> 方法用于删除列表中第一次出现的指定元素。如果该元素在列表中存在，则会被移除；如果不存在，则抛出一个 <code>ValueError</code> 异常。这是一个 O(n) 操作，因为在最坏的情况下，可能需要遍历整个列表以找到要删除的元素。</p> <pre><code class="prism language-python">list1<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>  <span class="token comment"># 删除列表中第一个出现的 'a'</span>
</code></pre> <p>使用 <code>remove()</code> 方法时需要注意，它只删除第一个匹配的元素。如果列表中有多个相同的元素且需要删除它们，可能需要使用循环或其他方法来处理。</p> </li><li> <p><strong>调整大小</strong>：当添加元素超出当前容量时，Python 的列表会自动增加其容量，通常增加到原来的大约 1.125 倍，这是通过内部的重新分配和元素复制完成的。</p> </li></ul> 
<h3><a id="3__103"></a>3. 内部工作原理</h3> 
<h4><a id="31__105"></a>3.1 列表的存储结构：如何在内存中表示</h4> 
<p>Python 的列表是通过一个动态数组实现的。在内存中，这意味着<strong>列表元素存储在一块连续的内存区域中</strong>，这允许快速的元素访问和高效的迭代操作。每个列表有一个指向这个连续内存块的指针，以及记录当前列表长度和总容量的属性。</p> 
<ul><li><strong>内存布局</strong>：列表的内存布局包括元素的引用数组，即每个列表项实际上是指向对象的引用。</li><li><strong>容量与长度</strong>：列表的“容量”是指内存中已分配的空间大小，而“长度”是列表当前实际包含的元素数量。容量通常大于或等于长度。</li></ul> 
<h4><a id="32_Python__112"></a>3.2 动态调整大小：当数组达到当前容量时，Python 如何调整其大小</h4> 
<p>当元素被添加到列表中，如果添加该元素会超出当前的容量，Python 需要进行一次内存重新分配来增加列表的容量。</p> 
<ul><li><strong>大小调整策略</strong>：通常，Python 会为列表分配比当前元素数量稍多的空间，以避免每次添加元素时都进行内存分配。这个“过度分配”有助于优化添加元素的性能，因为它减少了内存分配的频率。</li><li><strong>增长因子</strong>：Python 的列表增长因子大约是 1.125。这意味着每次容量不足时，新容量会比旧容量大约多 12.5%。</li></ul> 
<h4><a id="33__119"></a>3.3 时间复杂度分析：对添加元素的平摊时间复杂度进行分析</h4> 
<p>虽然每次添加元素时可能需要进行内存重新分配，这个操作的时间复杂度是 O(n)，但是由于列表通常过度分配内存，所以内存重新分配不是每次添加元素时都会发生。</p> 
<ul><li><strong>单次添加</strong>：如果不需要扩容，添加一个元素到列表的末尾是 O(1) 操作。</li><li><strong>平摊分析</strong>：当考虑到内存重新分配的过度分配策略，平摊时间复杂度仍然是 O(1)。这是因为每次重新分配后，列表可以在需要下一次重新分配之前接受多次 O(1) 的插入操作。</li></ul> 
<p>这种设计使得 Python 列表在实际应用中表现出良好的性能，特别是在执行大量数据添加操作时。虽然在特定操作（如扩容时的元素复制）中会有较高的成本，但平摊成本很低，使得列表操作在大多数情况下都是非常高效的。这种动态数组的实现细节是 Python 提供高效灵活数据结构的关键。</p> 
<h3><a id="4__128"></a>4. 列表的缩减</h3> 
<p>虽然 Python 的列表非常灵活，在自动增长以适应更多元素的同时，它们不会自动缩小内存占用。在某些情况下，特别是在处理大量数据并删除多数数据后，可能需要手动减少列表所占用的内存。这里有几种方法可以实现这一目的：</p> 
<h4><a id="41__del__132"></a>4.1 使用 <code>del</code> 语句删除元素</h4> 
<p><code>del</code> 语句可以用来删除列表中的一个或多个元素，并且可以帮助减少列表的长度。这个操作不直接减少分配给列表的内存，但可以通过删除不再需要的元素来减小列表的有效大小。</p> 
<pre><code class="prism language-python">list1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span>
<span class="token keyword">del</span> list1<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token punctuation">]</span>  <span class="token comment"># 删除索引5及之后的所有元素</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>list1<span class="token punctuation">)</span>  <span class="token comment"># 输出: [1, 2, 3, 4, 5]</span>
</code></pre> 
<h4><a id="42__142"></a>4.2 重新分配或通过切片调整大小</h4> 
<p>如果列表中删除了很多元素，且想要缩小底层内存的使用，最直接的方法是创建一个新的列表，这个新列表只包含还需要保留的元素。这种方法有效地释放了原列表多余的内存（Python 的标准列表没有 <code>resize()</code> 方法）</p> 
<pre><code class="prism language-python">old_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span>
new_list <span class="token operator">=</span> old_list<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span>  <span class="token comment"># 创建一个新列表，只包含前五个元素</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>new_list<span class="token punctuation">)</span>  <span class="token comment"># 输出: [1, 2, 3, 4, 5]</span>
<span class="token comment"># old_list 如果不再有其他引用指向它，可以被垃圾回收</span>
</code></pre> 
<h3><a id="5__153"></a>5. 优化和局限性</h3> 
<h4><a id="51__155"></a>5.1 如何优化列表操作</h4> 
<p>虽然 Python 列表已经是一个非常高效的动态数组实现，但在某些情况下，使用一些策略可以进一步提高其性能：</p> 
<ul><li><strong>最小化插入和删除的开销</strong>： 
  <ul><li>尽量使用 <code>append()</code> 和 <code>pop()</code> 操作来避免中间位置的插入和删除，因为这些操作是 O(1) 的，而在列表中间位置插入或删除是 O(n) 的。</li><li>如果需要频繁在列表前端添加或移除元素，考虑使用 <code>collections.deque</code>，它是专为高效地在两端进行插入和删除操作设计的。</li></ul> </li><li><strong>批量操作以减少扩容次数</strong>：当预知需要添加多个元素时，可以先通过一次性增加列表大小的方式（如使用 <code>extend()</code>），这样可以减少内存重新分配的次数。</li><li><strong>使用生成器和列表推导</strong>：对于转换或过滤列表中的元素，使用列表推导或生成器表达式通常比手动循环更快且更内存高效。</li><li><strong>内存管理</strong>：如果确定不再需要列表中的大量数据，可以使用 <code>del</code> 关键字来删除这些元素，或者通过 <code>list.clear()</code> 清空列表来帮助减少内存占用。</li></ul> 
<h4><a id="52__166"></a>5.2 动态数组的局限性</h4> 
<p>尽管 Python 的动态数组（列表）非常强大和灵活，但它们也有一些局限性和不适用的场景：</p> 
<ul><li><strong>大量元素的中间插入和删除效率低下</strong>：如前所述，中间位置的插入和删除操作是 O(n) 的，对于非常大的数据集，这可能会成为性能瓶颈。</li><li><strong>内存占用</strong>：由于过度分配策略，列表有时可能会占用比实际存储的数据更多的内存。在内存受限的环境中，这可能导致问题。</li><li><strong>不适合特定类型的查询</strong>：列表不支持像哈希表那样的快速查找操作（即平均情况下 O(1) 的访问时间）。对于需要快速访问的场景，字典或集合可能是更好的选择。</li><li><strong>数值运算效率低</strong>：对于涉及数值计算的应用，列表不如数组或特别是 NumPy 提供的 ndarray 那样高效，因为后者提供了硬件级优化和高级数学运算功能。</li></ul> 
<hr> 
<blockquote> 
 <p>推荐我的相关专栏：</p> 
 <ul><li><a href="https://blog.csdn.net/lph159/category_12621751.html?spm=1001.2014.3001.5482">python 错误记录</a></li><li><a href="https://blog.csdn.net/lph159/category_12630185.html?spm=1001.2014.3001.5482">python 笔记</a></li></ul> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/03f1597542f5fade6d56946b159a6992/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">寝室快修|基于SprinBoot&#43;vue的贵工程寝室快修小程序(源码&#43;数据库&#43;文档)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0dc9df6b054d5424b623c2bdd7290f8a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在HTML中使用JavaScript实时显示当前日期和时间（结尾完整例程）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>