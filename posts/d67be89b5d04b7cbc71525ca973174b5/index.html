<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【头歌】数据结构-队列的应用 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/d67be89b5d04b7cbc71525ca973174b5/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【头歌】数据结构-队列的应用">
  <meta property="og:description" content="第1关：循环队列
任务描述
本关任务：编写一个循环队列，实现入队、出队操作，判断队空、队满等特殊情况。
相关知识
为了完成本关任务，你需要掌握：1.循环队列定义，2.入队、出队的定义，3.队空、队满的情况。
循环队列定义
循环队列将数组存储区看成是一个首尾相接的环形区域（下图）。当数据存放到尾地址后，下一个地址就跳转到首地址。循环队列定义如下：
struct Queue{int maxSize; // 队列最大长度int *data; // 数据指针int front; // 头指针索引int rear; // 尾指针索引}; 入队出队定义
入队操作：队列未满，在队尾插入一个元素item，使得data[rear&#43;1]=item，若超过存储空间则尾指针索引取模(rear&#43;1)%maxSize；
出队操作：队列不空，返回队首元素值data[front]，并移除队首元素front&#43;1，若超过存储空间则头指针索引取模(front&#43;1)%maxSize。
队空队满情况
初始化创建空队时，令front=rear=0， 其中front指向队首元素，rear指向队尾元素的下一个元素：
当队空时：front==rear当队满时：front==rear 亦成立 因此只凭等式front==rear无法判断队空还是队满。 一个方法是少用一个元素空间，约定：队列头指针front在队尾指针rear的下一个位置上作为队列“满”状态的标志（如上图），即：
队空时： front==rear队满时： (rear&#43;1)%maxSize==front 编程要求
本关的编程任务是补全右侧代码片段isFull、isEmpty、enQueue和deQueue中Begin至End中间的代码，具体要求如下：
在isFull中，判断队列是否为满，若满返回true并在一行打印The queue is Full，否则返回false；在isEmpty中，判断队列是否为空，若空返回true并在一行打印The queue is Empty，否则返回false；在enQueue中，实现入队操作：将元素item加入队列尾部；在deQueue中，实现出队操作：移除队列首部元素，并返回元素值。 测试说明
平台将自动编译补全后的代码，并生成若干组测试数据，接着根据程序的输出判断程序是否正确。
以下是平台的测试样例：
测试输入： 10 7 enqueue 30 enqueue 98 dequeue enqueue 96 dequeue dequeue enqueue 0 预期输出： 0 The queue is Empty
输入说明： 第一行n m分别表示循环队列大小、入队出队操作记录数量。 接下来m行，enqueue表示入队操作，后面接待入队元素；dequeue表示出队操作。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-05-25T21:01:14+08:00">
    <meta property="article:modified_time" content="2023-05-25T21:01:14+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【头歌】数据结构-队列的应用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> <strong>第1关：循环队列</strong></p> 
<p>任务描述</p> 
<p>本关任务：编写一个循环队列，实现入队、出队操作，判断队空、队满等特殊情况。</p> 
<p>相关知识</p> 
<p>为了完成本关任务，你需要掌握：1.循环队列定义，2.入队、出队的定义，3.队空、队满的情况。</p> 
<p>循环队列定义</p> 
<p>循环队列将数组存储区看成是一个首尾相接的环形区域（下图）。当数据存放到尾地址后，下一个地址就跳转到首地址。循环队列定义如下：</p> 
<pre></pre> 
<ol><li><code>struct Queue{<!-- --></code></li><li><code>int maxSize; // 队列最大长度</code></li><li><code>int *data; // 数据指针</code></li><li><code>int front; // 头指针索引</code></li><li><code>int rear; // 尾指针索引</code></li><li><code>};</code></li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/78/5f/fUpaHhgX_o.jpg"></p> 
<p>入队出队定义</p> 
<p>入队操作：队列未满，在队尾插入一个元素<code>item</code>，使得<code>data[rear+1]=item</code>，若超过存储空间则尾指针索引取模<code>(rear+1)%maxSize</code>；</p> 
<p>出队操作：队列不空，返回队首元素值<code>data[front]</code>，并移除队首元素<code>front+1</code>，若超过存储空间则头指针索引取模<code>(front+1)%maxSize</code>。</p> 
<p>队空队满情况</p> 
<p>初始化创建空队时，令<code>front=rear=0</code>， 其中<code>front</code>指向队首元素，<code>rear</code>指向队尾元素的下一个元素：</p> 
<ul><li>当队空时：<code>front==rear</code></li><li>当队满时：<code>front==rear</code> 亦成立</li></ul> 
<p>因此只凭等式<code>front==rear</code>无法判断队空还是队满。 一个方法是少用一个元素空间，约定：队列头指针<code>front</code>在队尾指针<code>rear</code>的下一个位置上作为队列“满”状态的标志（如上图），即：</p> 
<ul><li>队空时： <code>front==rear</code></li><li>队满时： <code>(rear+1)%maxSize==front</code></li></ul> 
<p>编程要求</p> 
<p>本关的编程任务是补全右侧代码片段<code>isFull</code>、<code>isEmpty</code>、<code>enQueue</code>和<code>deQueue</code>中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p> 
<ul><li>在<code>isFull</code>中，判断队列是否为满，若满返回<code>true</code>并在一行打印<code>The queue is Full</code>，否则返回<code>false</code>；</li><li>在<code>isEmpty</code>中，判断队列是否为空，若空返回<code>true</code>并在一行打印<code>The queue is Empty</code>，否则返回<code>false</code>；</li><li>在<code>enQueue</code>中，实现入队操作：将元素<code>item</code>加入队列尾部；</li><li>在<code>deQueue</code>中，实现出队操作：移除队列首部元素，并返回元素值。</li></ul> 
<p>测试说明</p> 
<p>平台将自动编译补全后的代码，并生成若干组测试数据，接着根据程序的输出判断程序是否正确。</p> 
<p>以下是平台的测试样例：</p> 
<p>测试输入： <code>10</code> <code>7</code> <code>enqueue</code> <code>30</code> <code>enqueue</code> <code>98</code> <code>dequeue</code> <code>enqueue</code> <code>96</code> <code>dequeue</code> <code>dequeue</code> <code>enqueue</code> <code>0</code> 预期输出： <code>0 The queue is Empty</code></p> 
<p>输入说明： 第一行<code>n</code> <code>m</code>分别表示循环队列大小、入队出队操作记录数量。 接下来<code>m</code>行，<code>enqueue</code>表示入队操作，后面接待入队元素；<code>dequeue</code>表示出队操作。</p> 
<p>输出说明： 输出<code>m</code>个操作之后的所有队列元素。</p> 
<hr> 
<p>开始你的任务吧，祝你成功！</p> 
<p> </p> 
<pre><code class="language-cpp">//
//  queue_.cpp
//  Queue
//
//  Created by ljpc on 2018/5/29.
//  Copyright © 2018年 ljpc. All rights reserved.
//

#include "queue_.h"


void creatQueue(Queue* que, int maxSize)
//  创建一个循环队列指针que，队列最大长度为maxSize
{
    que-&gt;maxSize = maxSize;
    que-&gt;data = (int*)malloc(maxSize * sizeof(int));
    que-&gt;front = que-&gt;rear = 0;
}

void destroyQueue(Queue* que)
//  释放队列内存空间
{
    free(que-&gt;data);
}

bool isFull(Queue* que)
//  判断队列que是否为满
//  若满返回 true 并在一行打印  The queue is Full 末尾换行！！！
//  否则返回 false

{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if((que-&gt;rear+1)%que-&gt;maxSize==que-&gt;front)
    {
        printf("The queue is Full\n");
        return true;
    }
    else return false;
    /********** End **********/
}

bool isEmpty(Queue* que)
//  判断队列que是否为空
//  若空返回 true 并在一行打印 The queue is Empty 末尾换行！！！
//  否则返回 false
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if(que-&gt;rear==que-&gt;front)
    {
        printf("The queue is Empty\n");
        return true;
    }   
    else 
    return false;

    /********** End **********/
}

int enQueue(Queue* que, int item)
//  实现入队操作：将元素item加入队列que尾部
//  若队列没满，编写加入操作，返回 1
//  若队列满了，不做任何操作，返回 -1
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    
    if(isFull(que))
    {
        return -1;
    }
    else 
    {
        que-&gt;data[que-&gt;rear]=item;
        que-&gt;rear=(que-&gt;rear+1)%que-&gt;maxSize;
        return 1;
    }
    /********** End **********/
}

int deQueue(Queue* que)
//  实现出队操作：移除队列que首部元素，并返回元素值
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    int x;
    if(que-&gt;front==que-&gt;rear)
    {
        return false;
    }
    else 
    {
        x=que-&gt;data[que-&gt;front];
        que-&gt;front=(que-&gt;front+1)%que-&gt;maxSize;        
    }
    return x;

    /********** End **********/
}

void printQueue(Queue* que)
//  打印队列
{
    while (isEmpty(que)==false) {
        int item = deQueue(que);
        printf("%d ", item);
    }
}
</code></pre> 
<p><strong> 第二关-链队列</strong></p> 
<p>任务描述</p> 
<p>本关任务：编写一个链队列，实现入队、出队操作，判断队空等特殊情况。</p> 
<p>相关知识</p> 
<p>为了完成本关任务，你需要掌握：1.链队列定义，2.入队、出队的定义，3.队空的情况。</p> 
<p>链队列定义</p> 
<p>链队列的定义是在单链表的基础上，增加一个尾指针。队列的特点是“先进先出”，因此只需要一头一尾两个指针，就可以快速地在队头取出数据，在队尾插入数据。</p> 
<p>链队列动态创建节点，不需要预设大小，内存空间不需要连续，入队、出队更容易实现。但是存取速度慢，操作也比数组的方式更加复杂。</p> 
<pre></pre> 
<ol><li><code>struct Node // 数据节点</code></li><li><code>{<!-- --></code></li><li><code>int data; // 数据类型</code></li><li><code>Node *next; // 指向下一个节点的指针</code></li><li><code>};</code></li><li><code>struct LinkQueue // 链表队列</code></li><li><code>{<!-- --></code></li><li><code>Node *front; // 头指针</code></li><li><code>Node *rear; // 尾指针</code></li><li><code>};</code></li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/4a/55/artph6eP_o.jpg"></p> 
<p>入队出队定义</p> 
<p>入队操作：</p> 
<ul><li>第一步：为待入队元素创建数据节点<code>Node* node</code>；</li><li>第二步：将队尾节点<code>next</code>指向新节点<code>rear-&gt;next = node</code>;</li><li>第三步：修改队尾指针<code>rear</code>指向新节点<code>rear = node</code>。</li></ul> 
<p>出队操作：队列不空，返回队首元素值。</p> 
<ul><li>第一步：获取队首节点<code>Node *node = front-&gt;next</code>，注意<code>front-&gt;next</code>才是指向队列头节点，<code>front</code>本身不具备任何意义。</li><li>第二步：移除队首节点，修改<code>front-&gt;next = node-&gt;next</code>；</li><li>特殊情况：当队列最后一个元素被删除后，队列尾指针也丢失了，因此需对队尾指针重新赋值，即指向头结点<code> rear = front</code>。</li></ul> 
<p>队空情况</p> 
<p>初始化创建空队时，令<code>rear = front</code>，即队空的情况是<code>rear == front</code>。</p> 
<p>编程要求</p> 
<p>本关的编程任务是补全右侧代码片段<code>isEmpty</code>、<code>enQueue</code>和<code>deQueue</code>中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p> 
<ul><li>在<code>isEmpty</code>中，判断队列是否为空，若空返回<code>true</code>并在一行打印<code>The queue is Empty</code>，否则返回<code>false</code>；</li><li>在<code>enQueue</code>中，实现入队操作：将元素<code>item</code>加入队列尾部；</li><li>在<code>deQueue</code>中，实现出队操作：移除队列首部元素，并返回元素值。</li></ul> 
<p>测试说明</p> 
<p>平台将自动编译补全后的代码，并生成若干组测试数据，接着根据程序的输出判断程序是否正确。</p> 
<p>以下是平台的测试样例：</p> 
<p>测试输入： <code>7</code> <code>enqueue</code> <code>30</code> <code>enqueue</code> <code>98</code> <code>dequeue</code> <code>enqueue</code> <code>96</code> <code>dequeue</code> <code>dequeue</code> <code>enqueue</code> <code>0</code> 预期输出： <code>0 The queue is Empty</code></p> 
<p>输入说明： 第一行<code>m</code>分别表示链队列入队出队操作记录数量。 接下来<code>m</code>行，<code>enqueue</code>表示入队操作，后面接待入队元素；<code>dequeue</code>表示出队操作。</p> 
<p>输出说明： 输出<code>m</code>个操作之后的所有队列元素。</p> 
<hr> 
<p>开始你的任务吧，祝你成功！</p> 
<pre><code class="language-cpp">//
//  queue_.cpp
//  LinkQueue
//
//  Created by ljpc on 2018/5/30.
//  Copyright © 2018年 ljpc. All rights reserved.
//

#include "queue_.h"

void creatLinkQueue(LinkQueue* que)
//  创建一个循环队列指针que
{
    que-&gt;front = (Node*)malloc(sizeof(Node));
    que-&gt;rear = que-&gt;front;
    que-&gt;rear-&gt;next = NULL;
}

bool isEmpty(LinkQueue* que)
//  判断队列que是否为空
//  若空返回 true 并在一行打印 The queue is Empty 末尾换行！！！
//  否则返回 false
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if(que-&gt;front==que-&gt;rear)
    {
        printf("The queue is Empty\n");
        return true;
    }
    else 
    return false;

    /********** End **********/
}

void enQueue(LinkQueue* que, int item)
//  实现入队操作：将元素item加入队列que尾部
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    Node *newque=(Node*)malloc(sizeof(Node));
    if(newque!=NULL)
    {
        newque-&gt;data=item;
        newque-&gt;next=NULL;
        que-&gt;rear-&gt;next=newque;
        que-&gt;rear=newque;
    }
    /********** End **********/
}

int deQueue(LinkQueue* que)
//  实现出队操作：移除队列que首部元素，并返回元素值
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    Node *p;
    int item;
    if(que-&gt;front==que-&gt;rear)
       return false;

    p=que-&gt;front-&gt;next;
    que-&gt;front-&gt;next=p-&gt;next;
    item=p-&gt;data;

    if(que-&gt;rear==p)
    {
        que-&gt;rear=que-&gt;front;
    }
    free(p);
    return item;
    /********** End **********/
}

void printQueue(LinkQueue* que)
//  打印队列
{
    while (isEmpty(que)==false) {
        int item = deQueue(que);
        printf("%d ", item);
    }
}
</code></pre> 
<h4>第3关：单链表循环队列</h4> 
<p>任务描述</p> 
<p>本关任务：编写一个单链表循环队列，实现入队、出队操作，判断队空等特殊情况。</p> 
<p>相关知识</p> 
<p>为了完成本关任务，你需要掌握：1.单链表循环队列定义，2.入队、出队的定义，3.队空的情况。</p> 
<p>单链表循环队列</p> 
<p>单链表循环队列设一个尾指针<code>rear</code>，不设头指针。队尾添加数据的时候，只需要在<code>rear</code>和<code>rear-&gt;next</code>之间插入该数据节点，然后将<code>rear</code>指向这个节点。因为没有头指针，所以添加一个整形变量<code>size_</code>来判定队列空的情况。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ce/df/LKoKY3Vw_o.png"></p> 
<pre></pre> 
<ol><li><code>struct Node // 数据节点</code></li><li><code>{<!-- --></code></li><li><code>int data; // 数据类型</code></li><li><code>Node *next; // 指向下一个节点的指针</code></li><li><code>};</code></li><li><code>struct CycleQueue // 循环链表队列</code></li><li><code>{<!-- --></code></li><li><code>int size_; // 目前队列元素个数</code></li><li><code>Node *rear; // 尾指针</code></li><li><code>};</code></li></ol> 
<p>入队出队定义</p> 
<p>注意初始队列时，尾指针<code>rear = NULL</code>以及<code>rear-&gt;next = NULL</code>。</p> 
<p>入队操作：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/69/35/hOzg7lXV_o.png"></p> 
<ul><li>为待入队元素创建数据节点<code>Node* node</code>；</li><li>如果队列为空，则尾节点指向新节点<code>rear = node</code>，<code>rear-&gt;next</code>指向队首节点<code>rear-&gt;next = node</code>。</li><li>如果队列非空，则在<code>rear</code>和<code>rear-&gt;next</code>之间插入新节点： <pre></pre> 
  <ol><li><code>Node *temp = rear-&gt;next;</code></li><li><code>rear-&gt;next = node;</code></li><li><code>node-&gt;next = temp;</code></li><li><code>rear = node;</code></li><li><code>rear-&gt;next = temp;</code></li></ol></li></ul> 
<p>出队操作：队列不空，返回队首元素值。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/77/ef/xfXVlPR8_o.png"></p> 
<ul><li>第一步：获取队首节点<code>Node *node = rear-&gt;next</code>;</li><li>第二步：移除队首节点，修改<code>rear-&gt;next = node-&gt;next</code>。</li></ul> 
<p>队空情况</p> 
<p>队列中不含数据节点，通过变量<code>size_</code>来判定队列空的情况。</p> 
<p>编程要求</p> 
<p>本关的编程任务是补全右侧代码片段<code>isEmpty</code>、<code>enQueue</code>和<code>deQueue</code>中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p> 
<ul><li>在<code>isEmpty</code>中，判断队列是否为空，若空返回<code>true</code>并在一行打印<code>The queue is Empty</code>，否则返回<code>false</code>；</li><li>在<code>enQueue</code>中，实现入队操作：将元素<code>item</code>加入队列尾部；</li><li>在<code>deQueue</code>中，实现出队操作：移除队列首部元素，并返回元素值。</li></ul> 
<p>测试说明</p> 
<p>平台将自动编译补全后的代码，并生成若干组测试数据，接着根据程序的输出判断程序是否正确。</p> 
<p>以下是平台的测试样例：</p> 
<p>测试输入： <code>7</code> <code>enqueue</code> <code>30</code> <code>enqueue</code> <code>98</code> <code>dequeue</code> <code>enqueue</code> <code>96</code> <code>dequeue</code> <code>dequeue</code> <code>enqueue</code> <code>0</code> 预期输出： <code>0 The queue is Empty</code></p> 
<p>输入说明： 第一行<code>m</code>分别表示链队列入队出队操作记录数量。 接下来<code>m</code>行，<code>enqueue</code>表示入队操作，后面接待入队元素；<code>dequeue</code>表示出队操作。</p> 
<p>输出说明： 输出<code>m</code>个操作之后的所有队列元素。</p> 
<hr> 
<p>开始你的任务吧，祝你成功！</p> 
<pre><code class="language-cpp">//
//  queue_.cpp
//  Cycle
//
//  Created by ljpc on 2018/5/30.
//  Copyright © 2018年 ljpc. All rights reserved.
//

#include "queue_.h"


void creatCycleQueue(CycleQueue* que)
//  创建一个循环队列指针que
{
    que-&gt;size_ = 0;
    que-&gt;rear = NULL;
}

bool isEmpty(CycleQueue* que)
//  判断队列que是否为空
//  若空返回 true 并在一行打印 The queue is Empty 末尾换行！！！
//  否则返回 false
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    if(que-&gt;size_==0){
    	printf("The queue is Empty\n");
    	return true;
	}else{
		return false;
	}

    /********** End **********/

}

void enQueue(CycleQueue* que, int item)
//  实现入队操作：将元素item加入队列que尾部
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    Node *newque=(Node*)malloc(sizeof(Node));
    newque-&gt;data=item;
    if(que-&gt;size_&gt;0)
    {
        newque-&gt;next=que-&gt;rear-&gt;next;
        que-&gt;rear-&gt;next=newque;
        que-&gt;rear=newque;
        que-&gt;size_++;
    }
    else
    {
        que-&gt;rear=newque;
        que-&gt;rear-&gt;next=newque;
        que-&gt;size_++;
    }

    /********** End **********/

}

int deQueue(CycleQueue* que)
//  实现出队操作：移除队列que首部元素，并返回元素值
{
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    Node *p;
    int item;
    if(isEmpty(que))
        return false;
    if(que-&gt;size_==1)
    {
    	item=que-&gt;rear-&gt;data;
        p=que-&gt;rear;
	    que-&gt;rear=NULL;
	    free(p);
    } 
    else if(que-&gt;size_&gt;1)   
    {
        p=que-&gt;rear-&gt;next;
        que-&gt;rear-&gt;next=p-&gt;next;
        item=p-&gt;data;
        free(p);
    }
    que-&gt;size_--;
    return item;
    /********** End **********/

}

void printQueue(CycleQueue* que)
//  打印队列
{
    while (isEmpty(que)==false) {
        int item = deQueue(que);
        printf("%d ", item);
    }
}
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a2f68efc920d1103b6cb1714c46cff5c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数据结构】树的认识</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f03c2d46c73e6fda36d1e27bee728299/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">RabbitMQ手动ACK与死信队列</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>