<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据复制的艺术：深拷贝与浅拷贝在JavaScript中的实现方式 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/272ee618a7cc6416b322d215e5495198/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="数据复制的艺术：深拷贝与浅拷贝在JavaScript中的实现方式">
  <meta property="og:description" content="前言
📫 大家好，我是南木元元，热爱技术和分享，欢迎大家交流，一起学习进步！
🍅 个人主页：南木元元
目录
赋值和拷贝
浅拷贝与深拷贝区别
浅拷贝的实现方式
1.Object.assign()
2.扩展运算符
3.Array.prototype.slice()
4.Array.prototype.concat()
5.手写实现浅拷贝
深拷贝的实现方式
1.JSON.stringify()
2.函数库lodash
3.手写实现深拷贝
结语
赋值和拷贝 js中的数据类型分为两大类：
基本数据类型引用数据类型 基本数据类型保存在栈里面，可以直接访问它的值，赋值时，会完整复制变量值。
let a = 10; let b = a; // 赋值 b = 20; console.log(a); // 10 上面代码中，两个变量保存了两个不同的内存地址，所以b的改变不会引起a的变化。过程如下：
而引用数据类型保存在堆里面，栈里面保存的是地址，通过栈里面的地址去访问堆里面的值。
var obj1 = {} var obj2 = obj1; obj2.name = &#34;yuanyuan&#34;; console.log(obj1.name); // yuanyuan 上面代码在赋值时，复制的是栈中的引用地址，两个变量指向堆内存中的同一个对象，所以更改obj2会对obj1产生影响。赋值过程如下：
这是直接赋值的情况，要想两个值互不影响，就需要进行拷贝，js中的拷贝分为浅拷贝和深拷贝。
浅拷贝与深拷贝区别 浅拷贝是按位拷贝对象，它会创建一个新对象，如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址（只拷贝一层）。如果其中一个对象改变了这个地址，就会影响到另一个对象。
深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象，且修改新对象不会影响原对象。
浅拷贝的实现方式 1.Object.assign() Object.assign()方法用于将所有可枚举的自有属性从一个或多个源对象复制到目标对象，并返回这个目标对象。可以使用它来实现浅拷贝。
// 初始对象 const obj = { name: &#39;yuanyuan&#39;, des: { age: 21, gender: &#39;male&#39; } }; // 使用 Object.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-29T18:29:51+08:00">
    <meta property="article:modified_time" content="2024-04-29T18:29:51+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据复制的艺术：深拷贝与浅拷贝在JavaScript中的实现方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>前言</strong></p> 
<blockquote> 
 <p> 📫 大家好，我是南木元元，热爱技术和分享，欢迎大家交流，一起学习进步！</p> 
 <p> 🍅 <strong>个人主页：<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><a href="https://blog.csdn.net/weixin_43288600" title="南木元元">南木元元</a></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p> 
</blockquote> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E8%B5%8B%E5%80%BC%E5%92%8C%E6%8B%B7%E8%B4%9D-toc" style="margin-left:0px;"><a href="#%E8%B5%8B%E5%80%BC%E5%92%8C%E6%8B%B7%E8%B4%9D" rel="nofollow">赋值和拷贝</a></p> 
<p id="%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB-toc" style="margin-left:0px;"><a href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB" rel="nofollow">浅拷贝与深拷贝区别</a></p> 
<p id="%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F" rel="nofollow">浅拷贝的实现方式</a></p> 
<p id="1.Object.assign()-toc" style="margin-left:40px;"><a href="#1.Object.assign%28%29" rel="nofollow">1.Object.assign()</a></p> 
<p id="2.%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:40px;"><a href="#2.%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6" rel="nofollow">2.扩展运算符</a></p> 
<p id="3.Array.prototype.slice()-toc" style="margin-left:40px;"><a href="#3.Array.prototype.slice%28%29" rel="nofollow">3.Array.prototype.slice()</a></p> 
<p id="4.Array.prototype.concat()-toc" style="margin-left:40px;"><a href="#4.Array.prototype.concat%28%29" rel="nofollow">4.Array.prototype.concat()</a></p> 
<p id="5.%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E6%B5%85%E6%8B%B7%E8%B4%9D-toc" style="margin-left:40px;"><a href="#5.%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E6%B5%85%E6%8B%B7%E8%B4%9D" rel="nofollow">5.手写实现浅拷贝</a></p> 
<p id="%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F" rel="nofollow">深拷贝的实现方式</a></p> 
<p id="1.JSON.stringify()-toc" style="margin-left:40px;"><a href="#1.JSON.stringify%28%29" rel="nofollow">1.JSON.stringify()</a></p> 
<p id="2.%E5%87%BD%E6%95%B0%E5%BA%93lodash-toc" style="margin-left:40px;"><a href="#2.%E5%87%BD%E6%95%B0%E5%BA%93lodash" rel="nofollow">2.函数库lodash</a></p> 
<p id="3.%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D-toc" style="margin-left:40px;"><a href="#3.%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D" rel="nofollow">3.手写实现深拷贝</a></p> 
<p id="%E7%BB%93%E8%AF%AD-toc" style="margin-left:0px;"><a href="#%E7%BB%93%E8%AF%AD" rel="nofollow">结语</a></p> 
<hr id="hr-toc"> 
<h2>赋值和拷贝</h2> 
<p>js中的数据类型分为两大类：</p> 
<ul><li><strong>基本数据类型</strong></li><li><strong>引用数据类型</strong></li></ul> 
<p>基本数据类型保存在<strong>栈</strong>里面，可以直接访问它的值，赋值时，会完整复制变量值。</p> 
<pre><code class="language-javascript">let a = 10;
let b = a; // 赋值
b = 20;
console.log(a); // 10</code></pre> 
<p>上面代码中，两个变量保存了两个不同的内存地址，所以b的改变不会引起a的变化。过程如下：</p> 
<p><img alt="" height="264" src="https://images2.imgbox.com/42/76/bt0Qu4WX_o.png" width="655"></p> 
<p>而引用数据类型保存在<strong>堆</strong>里面，栈里面保存的是地址，通过栈里面的地址去访问堆里面的值。</p> 
<pre><code class="language-javascript">var obj1 = {}
var obj2 = obj1;
obj2.name = "yuanyuan";
console.log(obj1.name); // yuanyuan
</code></pre> 
<p> 上面代码在赋值时，复制的是栈中的引用地址，两个变量指向堆内存中的同一个对象，所以更改<code>obj2</code>会对<code>obj1</code>产生影响。赋值过程如下：</p> 
<p><img alt="" height="627" src="https://images2.imgbox.com/a0/00/ccARBbsV_o.png" width="687"></p> 
<p>这是直接赋值的情况，要想两个值互不影响，就需要进行拷贝，js中的拷贝分为浅拷贝和深拷贝。</p> 
<h2 id="%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB" style="background-color:transparent;">浅拷贝与深拷贝区别</h2> 
<p>浅拷贝是按位拷贝对象，它会创建一个新对象，如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址（只拷贝一层）。如果其中一个对象改变了这个地址，就会影响到另一个对象。</p> 
<p class="img-center"><img alt="" height="277" src="https://images2.imgbox.com/27/2d/dmbTiXUr_o.png" width="634"></p> 
<p>深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象，且修改新对象不会影响原对象。</p> 
<p class="img-center"><img alt="" height="373" src="https://images2.imgbox.com/8a/23/zT43w6X2_o.png" width="634"></p> 
<h2 id="%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F" style="background-color:transparent;">浅拷贝的实现方式</h2> 
<h3 id="1.Object.assign()">1.Object.assign()</h3> 
<p>Object.assign()方法用于将所有可枚举的自有属性从一个或多个源对象复制到目标对象，并返回这个目标对象。可以使用它来实现浅拷贝。</p> 
<pre><code class="language-javascript">// 初始对象
const obj = {
    name: 'yuanyuan',
    des: {
        age: 21,
        gender: 'male'
    }
};

// 使用 Object.assign 进行浅拷贝
const obj2 = Object.assign({}, obj);

// 修改原始对象中的属性
obj.name = '元元';
obj.des.age = 22;

// 输出
console.log(obj); // { name: '元元', des: { age: 22, gender: 'male' } }
console.log(obj2); // { name: 'yuanyuan', des: { age: 22, gender: 'male' } }</code></pre> 
<p>在上述示例中，Object.assign()创建了一个新对象 obj2并复制了obj中的所有属性。修改obj.name 只影响初始对象obj，不会影响拷贝后的对象，因为字符串是基本数据类型，被复制的是值。</p> 
<p style="text-align:justify;">但是，对于初始对象obj的des的修改影响了拷贝后对象obj2的des，因为对象的des属性是一个对象，而Object.assign()复制的是这个对象的引用。因此，当修改obj.des.age时，由于obj.des和obj2.des引用的是同一个对象，所以拷贝后的对象obj2中的des也会被改变。</p> 
<p>从这个例子可以看到，浅拷贝是<strong>按位拷贝对象，仅拷贝一层</strong>，适用于那些不包含深层次嵌套对象的情况。</p> 
<h3 id="2.%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6">2.扩展运算符</h3> 
<p>扩展运算符是一个es6的特性，它提供了一种非常方便的方式来执行浅拷贝，与object.assign实现的浅拷贝相同。</p> 
<pre><code class="language-javascript">let obj1 = {a:1,b:{c:1}}
let obj2 = {...obj1};
obj1.a = 2;
console.log(obj1); //{a:2,b:{c:1}}
console.log(obj2); //{a:1,b:{c:1}}
obj1.b.c = 2;
console.log(obj1); //{a:2,b:{c:2}}
console.log(obj2); //{a:1,b:{c:2}}</code></pre> 
<h3 id="3.Array.prototype.slice()">3.Array.prototype.slice()</h3> 
<p>Array.prototype.slice()方法可以从已有数组中返回选定的元素，不会改变原始数组。</p> 
<pre><code class="language-javascript">let arr = [1, 2, 3];
let newArr = arr.slice();
newArr[1] = 100;
console.log(arr);//[ 1, 2, 3 ]</code></pre> 
<h3 id="4.Array.prototype.concat()">4.Array.prototype.concat()</h3> 
<p>Array.prototype.concat()方法用于合并两个或多个数组，此方法不会更改原始数组，而是返回一个新数组。</p> 
<pre><code class="language-javascript">let arr = [1, 2, 3];
let newArr = arr.concat();
newArr[1] = 100;
console.log(arr);//[ 1, 2, 3 ]
</code></pre> 
<h3 id="5.%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E6%B5%85%E6%8B%B7%E8%B4%9D">5.手写实现浅拷贝</h3> 
<p>实现浅拷贝的思路：</p> 
<ul><li> <p>对基础类型做最基本的拷贝；</p> </li><li> <p>对引用类型开辟新的存储，并且拷贝一层对象属性。</p> </li></ul> 
<pre><code class="language-javascript">//实现浅拷贝
function shallowCopy (obj){
    // 只拷贝对象，基本类型或null直接返回
    if(typeof obj !== 'object' || obj === null) {
    	return obj;
    }
    // 判断是新建一个数组还是对象
    let newObj = Array.isArray(obj) ? []: {};
    //for…in会遍历对象的整个原型链，如果只考虑对象本身的属性，需要搭配hasOwnProperty
    for(let key in obj ){
        //hasOwnProperty判断是否是对象自身属性，会忽略从原型链上继承的属性
        if(obj.hasOwnProperty(key)){
        	newObj[key] = obj[key];//只拷贝对象本身的属性
        }
    }
    return newObj;
}

</code></pre> 
<h2 id="%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">深拷贝的实现方式</h2> 
<h3 id="1.JSON.stringify()">1.JSON.stringify()</h3> 
<pre><code class="language-javascript">JSON.parse(JSON.stringify());
</code></pre> 
<p>JSON.parse(JSON.stringify(obj))方法是常用的深拷贝方法之一，它的原理就是利用JSON.stringify将JavaScript对象序列化成为JSON字符串，并将对象里面的内容转换成字符串，再使用JSON.parse来反序列化，将字符串生成一个新的JavaScript对象。</p> 
<pre><code class="language-javascript">let obj1 = {  
  a: 0,
  b: {
    c: 0
  }
};
let obj2 = JSON.parse(JSON.stringify(obj1));
obj1.a = 1;
obj1.b.c = 1;
console.log(obj1); // {a: 1, b: {c: 1}}
console.log(obj2); // {a: 0, b: {c: 0}}</code></pre> 
<p>这个方法虽然简单，但也存在一些问题：</p> 
<ul><li>⽆法解决循环引用问题</li><li>无法拷贝一些特殊的对象，如 RegExp （会变成空对象）、 Date （被转成字符串）</li><li>无法拷贝函数</li></ul> 
<pre><code class="language-javascript">function Obj() {
 this.func = function () { alert(1) };
 this.obj = {a:1};
 this.arr = [1,2,3];
 this.und = undefined;
 this.reg = /123/;
 this.date = new Date(0);
 this.NaN = NaN;
 this.infinity = Infinity;
 this.sym = Symbol(1);
}
let obj1 = new Obj();
Object.defineProperty(obj1,'innumerable',{
 enumerable:false,
 value:'innumerable'
});
console.log('obj1',obj1);
let str = JSON.stringify(obj1);
let obj2 = JSON.parse(str);
console.log('obj2',obj2);</code></pre> 
<p>结果如下： </p> 
<p class="img-center"><img alt="" height="330" src="https://images2.imgbox.com/3c/7e/r4u9ZIWA_o.png" width="466"></p> 
<h3 id="2.%E5%87%BD%E6%95%B0%E5%BA%93lodash">2.函数库lodash</h3> 
<p>可以使用一些第三方库如lodash，它提供了<code>_.cloneDeep</code>用来做深拷贝，可以直接引入并使用：</p> 
<pre><code class="language-javascript">var _ = require('lodash');
var obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
var obj2 = _.cloneDeep(obj1);
console.log(obj1.b.f === obj2.b.f);// false
</code></pre> 
<h3 id="3.%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D">3.手写实现深拷贝</h3> 
<p>实现深拷贝的思路就是，使用for in来遍历传入参数的属性值，如果值是基本类型就直接复制，如果是引用类型就进行递归调用该函数，实现代码如下：</p> 
<pre><code class="language-javascript">function deepCopy (obj, map = new WeakMap()){
    // 基本类型或null直接返回
    if(typeof obj !== 'object' || obj === null) {
    	return obj;
    }
    if (obj instanceof Date) return new Date(obj);
    if (obj instanceof RegExp) return new RegExp(obj);
    // 判断是新建一个数组还是对象
    let newObj = Array.isArray(obj) ? []: {};
    //利用map解决循环引用
    if (map.has(obj)) {
        return map.get(obj);
    }
    map.set(obj, newObj);//将当前对象作为key，克隆对象作为value
    for(let key in obj ){	
        if(obj.hasOwnProperty(key)){
        	newObj[key] = deepCopy(obj[key], map);	//递归
        }
    }
    return newObj
}

</code></pre> 
<h2 id="%E7%BB%93%E8%AF%AD" style="background-color:transparent;">结语</h2> 
<p>🔥如果此文对你有帮助的话，欢迎💗<strong>关注</strong>、👍<span style="color:#ff9900;"><strong>点赞</strong></span>、⭐<span style="color:#4da8ee;"><strong>收藏</strong></span>、✍️<span style="color:#9c8ec1;"><strong>评论</strong></span>，支持一下博主~ </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/08b42f8b818a87d3ea2bc6fdca973971/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">利用Lama Cleaner本地实现AIGC试玩：擦除对象、替换对象、更换风格等等</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e8786f1a014a88d37b28f340b2cea774/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43;】：const成员，取地址及const取地址操作符重载</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>