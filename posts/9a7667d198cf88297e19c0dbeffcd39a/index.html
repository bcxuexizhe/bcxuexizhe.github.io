<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言数据在内存中的存储 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/9a7667d198cf88297e19c0dbeffcd39a/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="C语言数据在内存中的存储">
  <meta property="og:description" content="C语言数据在内存中的存储 个人主页：大白的编程日记
个人专栏：C语言学习之路
文章目录 C语言数据在内存中的存储前言一.整数在内存中的存储1.1整数的表示形式1.2整数在内存中的存放 二.大小端字节序和字节序判断2.1大小端的概念2.2为什么有大小端 三.练习3.1整型提升3.2算术转换3.3练习一（百度笔试题）3.4练习二3.5练习三3.6练习四3.7练习五3.8练习六 四.浮点数在内存中的存储4.1练习4.2浮点数的存储4.3浮点数存的过程4.4浮点数取的过程 后言 前言 哈喽，各位小伙伴大家好！我们都知道计算机的数据都是存储在内存中的。那它是如何存储，以什么形式存储，存储方法又是什么呢？今天小编就带着大家一起去学习数据在内存中的存储。向着大厂冲锋！
一.整数在内存中的存储 1.1整数的表示形式 整数的2进制表示方法有三种，即原码、反码和补码。
三种表示方法均有符号位和数值位两部分，
符号位都是用0表示“正”，用1表示“负”，
而数值位最高位的⼀位是被当做符号位，剩余的都是数值位。
正数：
正整数的原、反、补码都相同。
负数：
负整数的三种表示方法各不相同。
原码：直接将数值按照正负数的形式翻译成⼆进制得到的就是原码。
反码：将原码的符号位不变，其他位依次按位取反就可以得到反码。
补码：反码&#43;1就得到补码。
注意，补码转原码有两种方式。
一：先-1后取反。
二：先取反后&#43;1。
1.2整数在内存中的存放 对于整形来说：数据存放内存中其实存放的是补码。
在计算机系统中，数值⼀律⽤补码来表示和存储。
为什么呢？
使用补码，可以将符号位和数值域统⼀处理。加法和减法也可以统⼀处理（CPU只有加法器），可以将减法转化为加法运算。这是用原码计算是错误的，使用补码才能正确运算。
补码与原码相互转换，其运算过程是相同的，都可以按取反&#43;1转化，不需要额外的硬件电路。 二.大小端字节序和字节序判断 当我们了解了整数在内存中存储后，我们调试看⼀个细节：
#include &lt;stdio.h&gt; int main() { int a = 0x11223344; return 0; } 调试的时候，我们可以看到在a中的 0x11223344 这个数字是按照字节为单位，倒着存储的。
这是为什么呢？
这就涉及到大小段字节序的问题了。
2.1大小端的概念 其实超过⼀个字节的数据在内存中存储的时候，就有存储顺序的问题。
我们来想一个问题
#include &lt;stdio.h&gt; int main() { int a = 0x11223344; return 0; } 如果我们要把a存在内存里我们该怎么存。
比如这四种存放顺序。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-03T10:15:58+08:00">
    <meta property="article:modified_time" content="2024-05-03T10:15:58+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言数据在内存中的存储</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="C_0"></a>C语言数据在内存中的存储</h2> 
<blockquote> 
 <p>个人主页：<a href="https://blog.csdn.net/2301_81670477?type=blog">大白的编程日记</a><br> 个人专栏：<a href="https://blog.csdn.net/2301_81670477/category_12572839.html">C语言学习之路</a><br> <img src="https://images2.imgbox.com/fb/21/MwSqfo9R_o.jpg" alt=""></p> 
</blockquote> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#C_0" rel="nofollow">C语言数据在内存中的存储</a></li><li><ul><li><a href="#_8" rel="nofollow">前言</a></li><li><a href="#_13" rel="nofollow">一.整数在内存中的存储</a></li><li><ul><li><a href="#11_14" rel="nofollow">1.1整数的表示形式</a></li><li><a href="#12_36" rel="nofollow">1.2整数在内存中的存放</a></li></ul> 
   </li><li><a href="#_45" rel="nofollow">二.大小端字节序和字节序判断</a></li><li><ul><li><a href="#21_64" rel="nofollow">2.1大小端的概念</a></li><li><a href="#22_93" rel="nofollow">2.2为什么有大小端</a></li></ul> 
   </li><li><a href="#_106" rel="nofollow">三.练习</a></li><li><ul><li><a href="#31_107" rel="nofollow">3.1整型提升</a></li><li><a href="#32_151" rel="nofollow">3.2算术转换</a></li><li><a href="#33_166" rel="nofollow">3.3练习一（百度笔试题）</a></li><li><a href="#34_204" rel="nofollow">3.4练习二</a></li><li><a href="#35_252" rel="nofollow">3.5练习三</a></li><li><a href="#36_297" rel="nofollow">3.6练习四</a></li><li><a href="#37_339" rel="nofollow">3.7练习五</a></li><li><a href="#38_375" rel="nofollow">3.8练习六</a></li></ul> 
   </li><li><a href="#_411" rel="nofollow">四.浮点数在内存中的存储</a></li><li><ul><li><a href="#41_414" rel="nofollow">4.1练习</a></li><li><a href="#42_439" rel="nofollow">4.2浮点数的存储</a></li><li><a href="#43_464" rel="nofollow">4.3浮点数存的过程</a></li><li><a href="#44_504" rel="nofollow">4.4浮点数取的过程</a></li></ul> 
   </li><li><a href="#_538" rel="nofollow">后言</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_8"></a>前言</h3> 
<blockquote> 
 <p>哈喽，各位小伙伴大家好！我们都知道计算机的数据都是存储在内存中的。那它是如何存储，以什么形式存储，存储方法又是什么呢？今天小编就带着大家一起去学习数据在内存中的存储。向着大厂冲锋！<br> <img src="https://images2.imgbox.com/c1/62/UE5WJ8e9_o.gif" alt=""></p> 
</blockquote> 
<hr> 
<h3><a id="_13"></a>一.整数在内存中的存储</h3> 
<h4><a id="11_14"></a>1.1整数的表示形式</h4> 
<p>整数的2进制表示方法有三种，即原码、反码和补码。</p> 
<p>三种表示方法均有符号位和数值位两部分，<br> 符号位都是用0表示“正”，用1表示“负”，<br> 而数值位最高位的⼀位是被当做符号位，剩余的都是数值位。</p> 
<ul><li> <p>正数：<br> 正整数的原、反、补码都相同。<br> <img src="https://images2.imgbox.com/11/2d/NVvB7Si4_o.png" alt=""></p> </li><li> <p>负数：<br> 负整数的三种表示方法各不相同。<br> 原码：直接将数值按照正负数的形式翻译成⼆进制得到的就是原码。<br> 反码：将原码的符号位不变，其他位依次按位取反就可以得到反码。<br> 补码：反码+1就得到补码。<br> <img src="https://images2.imgbox.com/19/c6/2G30rm1t_o.png" alt=""><br> 注意，补码转原码有两种方式。<br> 一：先-1后取反。<br> 二：先取反后+1。</p> </li></ul> 
<hr> 
<h4><a id="12_36"></a>1.2整数在内存中的存放</h4> 
<p>对于整形来说：数据存放内存中其实存放的是补码。<br> 在计算机系统中，数值⼀律⽤补码来表示和存储。<br> 为什么呢？</p> 
<ul><li>使用补码，可以将符号位和数值域统⼀处理。</li><li>加法和减法也可以统⼀处理（CPU只有加法器），可以将减法转化为加法运算。这是用原码计算是错误的，使用补码才能正确运算。<br> <img src="https://images2.imgbox.com/70/0b/80eaUnIi_o.png" alt=""></li><li>补码与原码相互转换，其运算过程是相同的，都可以按取反+1转化，不需要额外的硬件电路。</li></ul> 
<hr> 
<h3><a id="_45"></a>二.大小端字节序和字节序判断</h3> 
<p>当我们了解了整数在内存中存储后，我们调试看⼀个细节：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0x11223344</span><span class="token punctuation">;</span>
 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/99/94/TqIYCFx2_o.png" alt=""></p> 
<p>调试的时候，我们可以看到在a中的 0x11223344 这个数字是按照字节为单位，倒着存储的。<br> 这是为什么呢？<br> 这就涉及到大小段字节序的问题了。</p> 
<hr> 
<h4><a id="21_64"></a>2.1大小端的概念</h4> 
<p>其实超过⼀个字节的数据在内存中存储的时候，就有存储顺序的问题。<br> 我们来想一个问题</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0x11223344</span><span class="token punctuation">;</span>
 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果我们要把a存在内存里我们该怎么存。<br> <img src="https://images2.imgbox.com/f1/a6/BcmjEaS8_o.png" alt=""><br> 比如这四种存放顺序。<br> 其实只要保证存放时的数据和我们拿出来的数据是一样的，<br> 任何顺序都可以。<br> 但是为了为了方便理解，我们就选用第一和第二种存放方式。<br> 这两种就会大端字节序存放和小端字节序存放。、</p> 
<ul><li> <p>大端字节序存储<br> 将一个数据低位字节的内容存放到高地址，把高位字节的内容存放到低地址处。</p> </li><li> <p>小端字节序存储<br> 将一个数据高位字节的内容存放到高地址，把低位字节的内容存放到低地址处。</p> </li></ul> 
<p>注意无论是大端还是小段存储，我存放的是什么，从内存拿出来时就是什么。不会因为倒着存放，拿出来的数据就是倒着的。</p> 
<hr> 
<h4><a id="22_93"></a>2.2为什么有大小端</h4> 
<p>这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着⼀个字节，⼀个字节为8bit位，<br> 但是在C语言中除了8bit的 char 之外，还有16bit的 short 型，32bit的 long 型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，<br> 由于寄存器宽度大于⼀个字节，那么必然存在着⼀个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。</p> 
<ul><li>举例<br> ⼀个 16bit 的 short 型 x ，在内存中的地址为 0x0010 ， x 的值为 0x1122 ，那么0x11 为高字节， 0x22 为低字节。<br> 对于大端模式，就将 0x11 放在低地址中，即 0x0010 中，<br> 0x22 放在高地址中，即 0x0011 中。<br> 小端模式，刚好相反。我们常用的 X86 结构是小端模式，而KEIL C51 则为大端模式。很多的ARM，DSP都为小段模式。<br> 有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。</li></ul> 
<hr> 
<h3><a id="_106"></a>三.练习</h3> 
<h4><a id="31_107"></a>3.1整型提升</h4> 
<p>C语言中整型算术运算总是至少以默认整型类型的精度来进行的。<br> 为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为整型提升。</p> 
<ul><li>整型提升的意义<br> 表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度⼀般就是int的字节长度，同时也是CPU的通用寄存器的长度。<br> 因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度。<br> 通用CPU（general-purposeCPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令中可能有这种字节相加指令）。所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算。</li></ul> 
<pre><code class="prism language-c"><span class="token comment">//实例1 </span>
<span class="token keyword">char</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
a <span class="token operator">=</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
</code></pre> 
<p>b和c的值被提升为普通整型，然后再执行加法运算。<br> 加法运算完成之后，结果将被截断，然后再存储于a中。</p> 
<p>那如何整型提升呢？</p> 
<ul><li>有符号整数提升是按照变量的数据类型的符号位来提升的。</li><li>无符号整数提升，高位补0。</li></ul> 
<pre><code class="prism language-c"><span class="token comment">//负数的整形提升 </span>
<span class="token keyword">char</span> c1 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
变量c1的⼆进制位<span class="token punctuation">(</span>补码<span class="token punctuation">)</span>中只有<span class="token number">8</span>个⽐特位：
<span class="token number">1111111</span>
因为 <span class="token keyword">char</span> 为有符号的 <span class="token keyword">char</span>
所以整形提升的时候，⾼位补充符号位，即为<span class="token number">1</span>
提升之后的结果是：
<span class="token number">11111111111111111111111111111111</span>
<span class="token comment">//正数的整形提升 </span>
<span class="token keyword">char</span> c2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
变量c2的⼆进制位<span class="token punctuation">(</span>补码<span class="token punctuation">)</span>中只有<span class="token number">8</span>个⽐特位：
<span class="token number">00000001</span>
因为 <span class="token keyword">char</span> 为有符号的 <span class="token keyword">char</span>
所以整形提升的时候，⾼位补充符号位，即为<span class="token number">0</span>
提升之后的结果是：
<span class="token number">00000000000000000000000000000001</span>
<span class="token comment">//⽆符号整形提升，⾼位补0 </span>
</code></pre> 
<hr> 
<h4><a id="32_151"></a>3.2算术转换</h4> 
<p>如果某个操作符的各个操作数属于不同的类型，那么除非其中⼀个操作数的转换为另⼀个操作数的类型，否则操作就无法进行。下⾯的层次体系称为寻常算术转换。</p> 
<pre><code class="prism language-c"><span class="token keyword">long</span> <span class="token keyword">double</span>
<span class="token keyword">double</span>
<span class="token keyword">float</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span>
<span class="token keyword">long</span> <span class="token keyword">int</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span>
<span class="token keyword">int</span>
</code></pre> 
<p>如果某个操作数的类型在上面这个列表中排名靠后，那么首先要转换为另外⼀个操作数的类型后执行运算。</p> 
<hr> 
<h4><a id="33_166"></a>3.3练习一（百度笔试题）</h4> 
<p>请简述大端字节序和小端字节序的概念，设计⼀个小程序来判断当前机器的字节序。（10分）-百度笔试题<br> <img src="https://images2.imgbox.com/ee/67/i4ttzYkE_o.png" alt=""><br> 以1为例。<br> 我们只需要拿到低地址处的字节内容即可。<br> 那怎样才能拿到呢？</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">check_sys</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//拿到低地址处的字节内容</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">check_sys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"⼩端\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"⼤端\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们只需要取出变量i的地址,因为&amp;取出的总是低地址的那个字节地址。<br> 但是因为是int类型，而我们只需要一个字节，所以我们强制类型转化为char*。<br> 再解引用即可访问低地址的那个字节，再判断是1还是0即可。</p> 
<ul><li>验证：<br> <img src="https://images2.imgbox.com/5f/34/YCwBKUce_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/1d/68/w1IneN9y_o.png" alt=""></li></ul> 
<hr> 
<h4><a id="34_204"></a>3.4练习二</h4> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">signed</span> <span class="token keyword">char</span> b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a=%d,b=%d,c=%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面的代码会输出啥？<br> 首先我们需要知道signed char和unsigned char的区别。</p> 
<ul><li> <p>signed char<br> <img src="https://images2.imgbox.com/23/74/dHlVUPZG_o.png" alt=""></p> </li><li> <p>unsigned char<br> <img src="https://images2.imgbox.com/df/75/kHniOlBX_o.png" alt=""><br> 我们现在再回到题目。</p> </li><li> <p>补码存储<br> <img src="https://images2.imgbox.com/a0/18/25jyFev3_o.png" alt=""><br> 因为内存中存储的是二进制的补码，所以我们先把-1的补码写出来。</p> </li><li> <p>截断<br> <img src="https://images2.imgbox.com/e2/e7/uUa3kxni_o.png" alt=""><br> 因为-1是整数，放在char类型变量需要发生截断，只保留后八位比特位。</p> </li><li> <p>整型提升<br> 注意char是有符号的char还是无符号的char是取决于编译器的！<br> 在vs中char等价于signed char。</p> </li></ul> 
<pre><code class="prism language-c">    <span class="token keyword">char</span> a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">signed</span> <span class="token keyword">char</span> b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a=%d,b=%d,c=%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>因为是%d打印，%d是打印有符号整数。所以这里需要发生整型提升。<br> 整型提升有符号数按照符号位填充，无符号数用0填充。<br> <img src="https://images2.imgbox.com/cf/a0/2b0370qV_o.png" alt=""><br> 所以结果就是-1 -1 255。</p> 
<ul><li>验证<br> <img src="https://images2.imgbox.com/f8/49/lqcMNPZS_o.png" alt=""><br> 所以数据在存储时不会关心是否是有符号数还是无符号数。<br> 输出时才会考虑是否是有符号数还是无符号数。</li></ul> 
<hr> 
<h4><a id="35_252"></a>3.5练习三</h4> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%u\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li> <p>补码存储<br> <img src="https://images2.imgbox.com/4d/9c/9XTjVlKK_o.png" alt=""><br> 这里我们写出-128的补码。</p> </li><li> <p>截断<br> <img src="https://images2.imgbox.com/7d/57/KoFTC1AA_o.png" alt=""></p> </li><li> <p>整型提升<br> %u认为内存存放的是无符号数。<br> a是char类型，需要发生整形提升。<br> <img src="https://images2.imgbox.com/75/c2/6OpADxAc_o.png" alt=""></p> </li><li> <p>验证：<br> <img src="https://images2.imgbox.com/fa/dc/MxJJopqR_o.png" alt=""></p> </li></ul> 
<hr> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 <span class="token keyword">char</span> a <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>
 <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%u\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/17/1e/NIPSaMwI_o.png" alt=""><br> 所以这两个代码的输出一样。</p> 
<ul><li>验证：<br> <img src="https://images2.imgbox.com/97/cc/vyX2Oshv_o.png" alt=""></li></ul> 
<hr> 
<h4><a id="36_297"></a>3.6练习四</h4> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 <span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> i<span class="token punctuation">;</span>
 <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
 a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们再来看这道题。<br> 首先我们需要知道strlen求得是字符串的长度，<br> 统计\0之前字符的个数，\0的ASCLL码值是0。<br> 所以这道题的意思就是统计在0之前的字符数。<br> 那我们怎么找呢？<br> 我们前面说过signed char的取值范围是-128到217。<br> 那如果超出范围会怎样呢？<br> <img src="https://images2.imgbox.com/58/15/e4BRT9J4_o.png" alt=""><br> 大家来看图解。<br> 如果超出范围内存中存的数据就会继续绕圈循环。<br> 顺时针看是+1的循环，逆时针看是-1的循环。</p> 
<pre><code class="prism language-c"><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
   a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre> 
<p>题目的for循环是-1,那我们就逆时针看。<br> 数字变化过程就应该是这样的：<br> <img src="https://images2.imgbox.com/33/cb/uqtZq4d2_o.png" alt="在这里插入图片描述"><br> 所以答案应该是255。</p> 
<ul><li>验证：<img src="https://images2.imgbox.com/fd/4d/Fls5l4BL_o.png" alt="在这里插入图片描述"></li></ul> 
<hr> 
<h4><a id="37_339"></a>3.7练习五</h4> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">unsigned</span> <span class="token keyword">char</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">255</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
 <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们来看这个代码。<br> <img src="https://images2.imgbox.com/0d/f0/Cl7k7Eoc_o.png" alt=""><br> 这是无符号的char的循环图。<br> 所以unsigned char的取值范围为0到255。<br> 所以i&lt;=255的条件恒成立，代码死循环。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 <span class="token keyword">unsigned</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span>
 <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
 <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%u\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>同理unsigned int存在内存的数据永远&gt;=0.<br> 所以i &gt;= 0判断条件恒成立。代码也是死循环。</p> 
<hr> 
<h4><a id="38_375"></a>3.8练习六</h4> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token operator">*</span>ptr1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token operator">*</span>ptr2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x,%x"</span><span class="token punctuation">,</span> ptr1<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>ptr2<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>小端字节序，X86环境下代码输出的结果是啥？</p> 
<ul><li>ptr1[-1]<br> <img src="https://images2.imgbox.com/aa/89/FEYOxQHt_o.png" alt="在这里插入图片描述"><br> 这里大家注意指针的类型和强制类型转化即可。</li><li>*ptr2<br> <img src="https://images2.imgbox.com/32/43/0NucLTDi_o.png" alt=""><br> 大家看一下图解。</li><li>验证：<br> <img src="https://images2.imgbox.com/27/74/Ny2WTv99_o.png" alt=""><br> 这里再跟大家说一下为啥是x86的环境。<br> 因为x64的环境这段代码执行不了为啥呢？<br> 因为x64指针大小是8个字节，int是四个字节。<br> 强转的过程会发生截断，那就会有数据的丢失。<br> 后面再强转成指针时就会有野指针的风险，所以无法执行。</li><li>验证：<br> <img src="https://images2.imgbox.com/fd/d8/ZPILVOZG_o.png" alt=""></li></ul> 
<hr> 
<h3><a id="_411"></a>四.浮点数在内存中的存储</h3> 
<p>常见的浮点数：3.14159、1E10等，浮点数家族包括： float、double、long double 类型。<br> 浮点数表示的范围： float.h 中定义</p> 
<h4><a id="41_414"></a>4.1练习</h4> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
 <span class="token keyword">float</span> <span class="token operator">*</span>pFloat <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>n<span class="token punctuation">;</span>
 <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"n的值为：%d\n"</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*pFloat的值为：%f\n"</span><span class="token punctuation">,</span><span class="token operator">*</span>pFloat<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token operator">*</span>pFloat <span class="token operator">=</span> <span class="token number">9.0</span><span class="token punctuation">;</span>
 <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"num的值为：%d\n"</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*pFloat的值为：%f\n"</span><span class="token punctuation">,</span><span class="token operator">*</span>pFloat<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>大家来看看这段代码，大家觉得会输出啥？<br> 可能很多小伙伴都会觉得时9 9.0 9 9.0 。<br> 但其实不是。<br> <img src="https://images2.imgbox.com/be/14/Gzzzhh71_o.png" alt=""><br> 通过观察我们可以发现，只有当我们以整型存储并且以整形读取输出时，或者浮点数存储并且以浮点数读取输出时结果才和存储的数据一样。<br> 这就说明整型和都浮点型的存储和读取方式不一样。<br> 那浮点型的存储和读取方式是怎么样的呢？</p> 
<hr> 
<h4><a id="42_439"></a>4.2浮点数的存储</h4> 
<blockquote> 
 <p>我们先来思考一个问题： 浮点数如何用二进制表示？</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/5f/1b/YHfNxsgc_o.png" alt=""></p> 
<p>上面的代码中， num 和 *pFloat 在内存中明明是同⼀个数，为什么浮点数和整数的解读结果会差别这么大？<br> 要理解这个结果，⼀定要搞懂浮点数在计算机内部的表示方法。<br> 根据国际标准IEEE（电气和电子工程协会）754，任意⼀个二进制浮点数V可以表示成下面的形式：<br> <img src="https://images2.imgbox.com/57/a6/pjXhLN0H_o.png" alt="在这里插入图片描述"><br> 举例来说：<br> 十进制的5.0，写成二进制是 101.0 ，相当于 1.01×2^2 。<br> 那么，按照上面的格式，可以得出S=0，M=1.01，E=2。<br> 十进制的-5.0，写成⼆进制是 -101.0 ，相当于 -1.01×2^2 。那么，S=1，M=1.01，E=2。<br> IEEE754规定：</p> 
<ul><li> <p>对于32位的浮点数(float)，最高的1位存储符号位S，接着的8位存储指数E，剩下的23位存储有效数字M<br> <img src="https://images2.imgbox.com/9b/34/kWk1GFJo_o.png" alt=""></p> </li><li> <p>对于64位的浮点数（double），最高的1位存储符号位S，接着的11位存储指数E，剩下的52位存储有效数字M。<br> <img src="https://images2.imgbox.com/a8/c0/LHfQooRe_o.png" alt=""><br> 所以浮点数的存储过程其实就是存储S E M三个数据的过程。</p> </li></ul> 
<hr> 
<h4><a id="43_464"></a>4.3浮点数存的过程</h4> 
<blockquote> 
 <p>EEE754对有效数字M和指数E，还有⼀些特别规定。</p> 
</blockquote> 
<ul><li>前面说过， 1≤M&lt;2 ，也就是说，M可以写成 1.xxxxxx 的形式，其中 xxxxxx 表示小数部分。<br> IEEE754规定，在计算机内部保存M时，默认这个数的第⼀位总是1，因此可以被舍去，只保存后面的<br> xxxxxx部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第⼀位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第⼀位的1舍去以后，等于可以保存24位有效数字。</li></ul> 
<p>至于指数E，情况就比较复杂<br> 首先，E为⼀个无符号整数（unsigned int）。</p> 
<ul><li>这意味着，如果E为8位，它的取值范围为0到255；如果E为11位，它的取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE754规定，存入内存时E的真实值必须再加上一个中间数，<br> 对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。</li></ul> 
<p>这里我们来验证一下吧。</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">float</span> f <span class="token operator">=</span> <span class="token number">5.5f</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/75/df/Gka8oMy1_o.png" alt=""><br> 因为是小端存放，所以内存是倒着存放。<br> <img src="https://images2.imgbox.com/f4/54/dXDCP3ow_o.png" alt=""></p> 
<ul><li> <p>特殊浮点数无法精确保存<br> 大家注意，并不是所有浮点数都能精确表示的。<br> 可能会出现这种情况：<br> <img src="https://images2.imgbox.com/02/1c/OoflZ9Gs_o.png" alt=""></p> </li><li> <p>验证：<br> <img src="https://images2.imgbox.com/bc/44/bytKuE1x_o.png" alt=""></p> </li></ul> 
<hr> 
<h4><a id="44_504"></a>4.4浮点数取的过程</h4> 
<blockquote> 
 <p>指数E从内存中取出还可以再分成三种情况：</p> 
</blockquote> 
<ul><li>E不全为0或不全为1<br> 这时，浮点数就采用下面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第⼀位的1。<br> 比如：0.5的⼆进制形式为0.1，由于规定正数部分必须为1，即将小数点右移1位，则为1.0*2^(-1)，其阶码为-1+127(中间值)=126，表示为01111110，二尾数1.0去掉整数部分为0，补齐0到23位<br> 00000000000000000000000，则其二进制表示形式为:</li></ul> 
<pre><code class="prism language-c"><span class="token number">1</span> <span class="token number">0</span> <span class="token number">01111110</span> <span class="token number">00000000000000000000000</span>
</code></pre> 
<ul><li>E全为0<br> 这时，浮点数的指数E等于1-127（或者1-1023）即为真实值，有效数字M不再加上第⼀位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。</li></ul> 
<pre><code class="prism language-c"><span class="token number">1</span> <span class="token number">0</span> <span class="token number">00000000</span> <span class="token number">00100000000000000000000</span>
</code></pre> 
<ul><li>E全为1<br> 这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；</li></ul> 
<pre><code class="prism language-c"><span class="token number">1</span> <span class="token number">0</span> <span class="token number">11111111</span> <span class="token number">00010000000000000000000</span>
</code></pre> 
<p>这是我们再来看回开始的代码<br> <img src="https://images2.imgbox.com/61/74/hAIbGeWM_o.png" alt=""><br> 所以代码输出就是：<br> <img src="https://images2.imgbox.com/ed/44/dBVQMLBs_o.png" alt=""></p> 
<hr> 
<h3><a id="_538"></a>后言</h3> 
<blockquote> 
 <p>这就是数据再内存中的存储啦！这些知识看似不起眼，其实都是在修炼我们编程学习的内功。大家下去一定要认真学习。感谢大家的垂阅。今天就分享到这里，咱们下期见！拜拜~<br> <img src="https://images2.imgbox.com/af/dc/yOFCLQOJ_o.jpg" alt=""></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0d663fe9f7508600c2e3deae1f95b573/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JSP简介——[JSP]2</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/380bfdf9d4a44b07ccf1fd8dc3b7f9e4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JSP语法——[JSP]5</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>