<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构-----二叉排序树 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/de05c0d4c988c31fe1ca877d7db7f15b/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="数据结构-----二叉排序树">
  <meta property="og:description" content="目录
前言
1.什么是二叉排序树
2.如何构建二叉排序树
3.二叉排序树的操作
3.1定义节点储存方式
3.2插入节点操作
3.2创建二叉排序树
3.4遍历输出（中序遍历）
3.5数据查找操作
3.6获取最大值和最小值
3.7删除节点操作
3.8销毁二叉排序树
4.完整代码
前言 今天我们继续学习新的知识点----排序二叉树，在此之前我们学习了相关的排序算法，给你一个数组，然后对这个数组进行排序。那么同样的我们也可以去构建一个二叉排序树，在创建树的过程中进行排序，也能实现排序的效果，下面就一起来看看吧！
1.什么是二叉排序树 二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。是数据结构中的一类。在一般情况下，查询效率比链表结构要高。 给定一个二叉树，如果满足以下条件，那就是二叉排序树
若它的左子树不空，则左子树上所有结点的值均小于它根结点的值。若它的右子树不空，则右子树上所有结点的值均大于它根结点的值。它的左、右子树都满足为⼆叉排序树 二叉排序树最大的好处就是查找效率高，相较于链表一个一个去查找，二叉排序树可以去根据数据的排序规律来进行查找
二叉排序树图示：
2.如何构建二叉排序树 比如给定一个数组 [62,88,58,47,35,73,51,99,37,93] ，首先拿到第一个数字，以这个数字为根结点（标准），进行构建，如果比这个数字要大的就放到右子树，比这个要小的就放到左子树去，如下图所示：
这里我们可以看出，这些节点是一个一个去进行插入的，那我们就可以去通过递归插入的方式来创建，依次往下遍历，找到合适的位置再进行插入操作。
3.二叉排序树的操作 3.1定义节点储存方式 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; //二叉排序树节点存储方式 typedef int DataType; typedef struct binarytreenode { DataType data;	//数据域 struct binarytreenode* left;	//左指针 struct binarytreenode* right;	//右指针 }BTnode; 3.2插入节点操作 插入一个节点首先就要找到这个节点应该插入的位置，从跟节点开始，如果比跟节点小就往左，大就往右，直到叶子节点的位置进行插入操作。
代码实现： //插入数据 void Insert_node(BTnode** root, DataType data) { if (*root == NULL) { *root = (BTnode*)malloc(sizeof(BTnode)); if (!">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-16T12:57:12+08:00">
    <meta property="article:modified_time" content="2024-04-16T12:57:12+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构-----二叉排序树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:40px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="1.%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91-toc" style="margin-left:40px;"><a href="#1.%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91" rel="nofollow">1.什么是二叉排序树</a></p> 
<p id="2.%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91-toc" style="margin-left:40px;"><a href="#2.%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91" rel="nofollow">2.如何构建二叉排序树</a></p> 
<p id="3.%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#3.%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C" rel="nofollow">3.二叉排序树的操作</a></p> 
<p id="3.1%E5%AE%9A%E4%B9%89%E8%8A%82%E7%82%B9%E5%82%A8%E5%AD%98%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#3.1%E5%AE%9A%E4%B9%89%E8%8A%82%E7%82%B9%E5%82%A8%E5%AD%98%E6%96%B9%E5%BC%8F" rel="nofollow">3.1定义节点储存方式</a></p> 
<p id="3.2%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#3.2%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C" rel="nofollow">3.2插入节点操作</a></p> 
<p id="3.2%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91-toc" style="margin-left:80px;"><a href="#3.2%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91" rel="nofollow">3.2创建二叉排序树</a></p> 
<p id="3.4%E9%81%8D%E5%8E%86%E8%BE%93%E5%87%BA%EF%BC%88%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%89-toc" style="margin-left:80px;"><a href="#3.4%E9%81%8D%E5%8E%86%E8%BE%93%E5%87%BA%EF%BC%88%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%89" rel="nofollow">3.4遍历输出（中序遍历）</a></p> 
<p id="3.5%E6%95%B0%E6%8D%AE%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#3.5%E6%95%B0%E6%8D%AE%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C" rel="nofollow">3.5数据查找操作</a></p> 
<p id="3.6%E8%8E%B7%E5%8F%96%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC-toc" style="margin-left:80px;"><a href="#3.6%E8%8E%B7%E5%8F%96%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC" rel="nofollow">3.6获取最大值和最小值</a></p> 
<p id="3.7%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#3.7%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C" rel="nofollow">3.7删除节点操作</a></p> 
<p id="3.8%E9%94%80%E6%AF%81%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91-toc" style="margin-left:80px;"><a href="#3.8%E9%94%80%E6%AF%81%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91" rel="nofollow">3.8销毁二叉排序树</a></p> 
<p id="4.%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#4.%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">4.完整代码</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E5%89%8D%E8%A8%80">前言</h3> 
<p>        今天我们继续学习新的知识点----排序二叉树，在此之前我们学习了相关的排序算法，给你一个数组，然后对这个数组进行排序。那么同样的我们也可以去构建一个二叉排序树，在创建树的过程中进行排序，也能实现排序的效果，下面就一起来看看吧！</p> 
<h3 id="1.%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91">1.什么是二叉排序树</h3> 
<blockquote> 
 <p>        二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/7077855?fromModule=lemma_inlink" rel="nofollow" title="二叉搜索树">二叉搜索树</a>。是<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450?fromModule=lemma_inlink" rel="nofollow" title="数据结构">数据结构</a>中的一类。在一般情况下，查询效率比<a href="https://baike.baidu.com/item/%E9%93%BE%E8%A1%A8/9794473?fromModule=lemma_inlink" rel="nofollow" title="链表">链表</a>结构要高。 </p> 
</blockquote> 
<blockquote> 
 <p>给定一个二叉树，如果满足以下条件，那就是二叉排序树</p> 
 <ul><li><span style="color:#fe2c24;">若它的左子树不空，则左子树上所有结点的值均小于它根结点的值。</span></li><li><span style="color:#fe2c24;">若它的右子树不空，则右子树上所有结点的值均大于它根结点的值。</span></li><li><span style="color:#fe2c24;">它的左、右子树都满足为⼆叉排序树</span></li></ul> 
 <p>二叉排序树最大的好处就是查找效率高，相较于链表一个一个去查找，二叉排序树可以去根据数据的排序规律来进行查找</p> 
</blockquote> 
<p>二叉排序树图示：<img alt="" height="1119" src="https://images2.imgbox.com/ed/d1/FUGM5kMC_o.png" width="1200"></p> 
<h3 id="2.%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91">2.如何构建二叉排序树</h3> 
<blockquote> 
 <p>比如给定一个数组<strong> [62,88,58,47,35,73,51,99,37,93] </strong>，首先拿到第一个数字，以这个数字为根结点（标准），进行构建，如果比这个数字要大的就放到右子树，比这个要小的就放到左子树去，如下图所示：</p> 
</blockquote> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/75/19/JDFH3cw4_o.png" width="1200"></p> 
<blockquote> 
 <p> 这里我们可以看出，这些节点是一个一个去进行插入的，那我们就可以去通过递归插入的方式来创建，依次往下遍历，找到合适的位置再进行插入操作。</p> 
</blockquote> 
<h3 id="3.%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C">3.二叉排序树的操作</h3> 
<h4 id="3.1%E5%AE%9A%E4%B9%89%E8%8A%82%E7%82%B9%E5%82%A8%E5%AD%98%E6%96%B9%E5%BC%8F">3.1定义节点储存方式</h4> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

//二叉排序树节点存储方式
typedef int DataType;
typedef struct binarytreenode {
	DataType data;	//数据域
	struct binarytreenode* left;	//左指针 
	struct binarytreenode* right;	//右指针
}BTnode;</code></pre> 
<h4 id="3.2%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C">3.2插入节点操作</h4> 
<blockquote> 
 <p>插入一个节点首先就要找到这个节点应该插入的位置，从跟节点开始，如果比跟节点小就往左，大就往右，直到叶子节点的位置进行插入操作。</p> 
</blockquote> 
<p><img alt="" height="532" src="https://images2.imgbox.com/0c/52/WPaC1G2d_o.png" width="1111"></p> 
<p>代码实现： </p> 
<pre><code class="language-cpp">//插入数据
void Insert_node(BTnode** root, DataType data) {
	if (*root == NULL) {
		*root = (BTnode*)malloc(sizeof(BTnode));
		if (!*root) {
			printf("ERROR\n");
			exit(-1);
		}
		(*root)-&gt;data = data;
		(*root)-&gt;left = NULL;
		(*root)-&gt;right = NULL;
	}

	else if ((*root)-&gt;data &lt;= data)
		Insert_node(&amp;(*root)-&gt;right, data);
	else if ((*root)-&gt;data &gt; data)
		Insert_node(&amp;(*root)-&gt;left, data);
}</code></pre> 
<h4 id="3.2%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91">3.2创建二叉排序树</h4> 
<blockquote> 
 <p>创建二叉排序树，只需要一一插入节点，最后返回根节点即可。代码如下：</p> 
</blockquote> 
<pre><code class="language-cpp">//创建排序二叉树
BTnode* Create_sortBtree(DataType* arr, int size) {
	if (!arr)
		return NULL;
	else {
		BTnode* T = NULL;
		for (int i = 0; i &lt; size; i++) {
			Insert_node(&amp;T, arr[i]);
		}
		return T;
	}
}</code></pre> 
<h4 id="3.4%E9%81%8D%E5%8E%86%E8%BE%93%E5%87%BA%EF%BC%88%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%89">3.4遍历输出（中序遍历）</h4> 
<pre><code class="language-cpp">//中序遍历排序二叉树
void mid_travel(BTnode* T)
{
	if (!T)
		return;
	mid_travel(T-&gt;left);
	printf("%d ", T-&gt;data);
	mid_travel(T-&gt;right);
}</code></pre> 
<h4 id="3.5%E6%95%B0%E6%8D%AE%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C">3.5数据查找操作</h4> 
<blockquote> 
 <p>在二叉排序树上查找某一个值节点，然后返回这个节点的操作。这里可以通过递归和非递归两种方法去实现，代码如下：</p> 
</blockquote> 
<p><strong>递归实现： </strong></p> 
<pre><code class="language-cpp">BTnode* Btree_search(BTnode* root, DataType target) {
	if (!root)
		return NULL;
	if (target == root-&gt;data) {
		return root;
	}
	return target &gt; root-&gt;data ? Btree_search(root-&gt;right, target) : Btree_search(root-&gt;left, target);
}</code></pre> 
<p><strong> 非递归实现（迭代实现）：</strong></p> 
<pre><code class="language-cpp">//非递归查找
BTnode* Btree_search_fa(BTnode* T, DataType target) {
	BTnode* p = T;
	while (p) {
		if (p-&gt;data == target)
		{
			return p;
		}
		p = target &gt; p-&gt;data ? p-&gt;right : p-&gt;left;
	}
	return NULL;
}</code></pre> 
<h4 id="3.6%E8%8E%B7%E5%8F%96%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC">3.6获取最大值和最小值</h4> 
<blockquote> 
 <p>在一个排序二叉树里面获取最大值或者是最小值，说白了也就是找到最右边和最左边节点就行了，二叉排序树的两个最值就在最两边。代码如下：</p> 
</blockquote> 
<p><strong>获取最大值</strong></p> 
<pre><code class="language-cpp">//获取最大值
int Btree_max(BTnode* T) {
	BTnode* cur = T;
	while (cur-&gt;right) {
		cur = cur-&gt;right;
	}
	return cur-&gt;data;
}</code></pre> 
<p> <strong>获取最小值</strong></p> 
<pre><code class="language-cpp">//获取最小值
int Btree_min(BTnode* T) {
	BTnode* cur = T;
	while (cur-&gt;left) {
		cur = cur-&gt;left;
	}
	return cur-&gt;data;
}
</code></pre> 
<h4 id="3.7%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C" style="background-color:transparent;">3.7删除节点操作</h4> 
<blockquote> 
 <p>删除节点操作，这就有可能会破坏到排序二叉树的结构，所以要分几种情况去处理。<span style="color:#1c7331;">一、如果删除的是叶子节点的话，那么就可以直接去删除，因为叶子节点左右节点都为空，不会影响到二叉排序树的结构；二、如果要删除的节点只有一个左子树或者是有一个右子树的话，我们只需要找到这个节点的左节点或者是右节点，然后顶替掉这个要删除的节点即可；三、如果要删除的节点都有左右子树的话，这里我们就需要去遍历找到比这个节点大一位或者是小一位的节点来顶替这个节点。如下图所示：</span></p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>1.删除叶子节点</strong> </span></p> 
<p><img alt="" height="568" src="https://images2.imgbox.com/1d/ff/6kipEXV1_o.png" width="1200"></p> 
<p><span style="color:#fe2c24;"><strong> 2</strong>.<strong>删除只有一个左（右）子树的节点</strong></span><img alt="" height="439" src="https://images2.imgbox.com/66/c7/I2psm2NG_o.png" width="900"></p> 
<p><strong><span style="color:#fe2c24;">3.删除有左右子树的节点</span></strong> </p> 
<p><img alt="" height="1064" src="https://images2.imgbox.com/ff/ed/zQ4VUhE8_o.png" width="1200"></p> 
<p><img alt="" height="1161" src="https://images2.imgbox.com/a6/1f/MreDJGLa_o.png" width="1200"></p> 
<p>代码实现：</p> 
<pre><code class="language-cpp">//删除节点
void Btree_del(BTnode* T, DataType l) {
	if (!T) {
		printf("fuck no\n");
		return;
	}
	//找到这个要删除节点的父节点
	BTnode* p = T, * f = NULL;
	while (p) {
		if (p-&gt;data == l)
		{
			break;
		}
		f = p;
		p = l &gt; p-&gt;data ? p-&gt;right : p-&gt;left;
	}
	if (!p)
	{
		printf("没有这个节点\n");
		return;
	}
	BTnode* target = p;//此时的要删除目标节点
	BTnode* par = f; //此时要删除节点的父节点

	//第一种情况 此节点只有一个子树的时候
	if (!target-&gt;left &amp;&amp; target-&gt;right != NULL)
	{
		if (target-&gt;data &gt; par-&gt;data) {
			par-&gt;right = target-&gt;right;
		}
		else {
			par-&gt;left = target-&gt;right;
		}
		free(target);//释放空间
		target = NULL;
	}
	else if (target-&gt;left != NULL &amp;&amp; !target-&gt;right) {
		if (target-&gt;data &gt; par-&gt;data) {
			par-&gt;right = target-&gt;left;
		}
		else {
			par-&gt;left = target-&gt;left;
		}
		free(target);
		target = NULL;
	}
	//第二种情况，如果删除的是叶节点，直接删除即可
	else if (!target-&gt;left &amp;&amp; !target-&gt;right) {
		if (target-&gt;data &gt; par-&gt;data) {
			par-&gt;right = NULL;
		}
		else {
			par-&gt;left = NULL;
		}
		free(target);
		target = NULL;
	}
	//第三种情况,如果左右子树都存在的话
	//可以用右子树的最小元素
	//或者左子树的最大元素来替代被删除的节点
	//我这里就直接去用左树的最大代替这个节点
	else
	{
		BTnode* Lchild = target-&gt;left;
		BTnode* Lchild_par = NULL;//要找的替换节点的父节点
		while (Lchild-&gt;right != NULL) {
			Lchild_par = Lchild;
			Lchild = Lchild-&gt;right;
			
		}
	
		if (Lchild-&gt;left!=NULL) {
			Lchild_par-&gt;right = Lchild-&gt;left;
		}
		else
			Lchild_par-&gt;right = NULL;
		target-&gt;data = Lchild-&gt;data;
		free(Lchild);
		Lchild = NULL;
	}
	printf("Deleting successfully\n");
}</code></pre> 
<h4 id="3.8%E9%94%80%E6%AF%81%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91">3.8销毁二叉排序树</h4> 
<pre><code class="language-cpp">//销毁
void Destory_btree(BTnode* T) {
	if (!T)
		return;
	BTnode* cur = T;
	if (cur-&gt;left)
		Destory_btree(cur-&gt;left);
	if (cur-&gt;right)
		Destory_btree(cur-&gt;right);
	free(T);
}</code></pre> 
<h3 id="4.%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" style="background-color:transparent;">4.完整代码</h3> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

//二叉排序树节点存储方式
typedef int DataType;
typedef struct binarytreenode {
	DataType data;	//数据域
	struct binarytreenode* left;	//左指针 
	struct binarytreenode* right;	//右指针
}BTnode;


//插入数据
void Insert_node(BTnode** root, DataType data) {
	if (*root == NULL) {
		*root = (BTnode*)malloc(sizeof(BTnode));
		if (!*root) {
			printf("ERROR\n");
			exit(-1);
		}
		(*root)-&gt;data = data;
		(*root)-&gt;left = NULL;
		(*root)-&gt;right = NULL;
	}

	else if ((*root)-&gt;data &lt;= data)
		Insert_node(&amp;(*root)-&gt;right, data);
	else if ((*root)-&gt;data &gt; data)
		Insert_node(&amp;(*root)-&gt;left, data);
}


//创建排序二叉树
BTnode* Create_sortBtree(DataType* arr, int size) {
	if (!arr)
		return NULL;
	else {
		BTnode* T = NULL;
		for (int i = 0; i &lt; size; i++) {
			Insert_node(&amp;T, arr[i]);
		}
		return T;
	}
}

//中序遍历排序二叉树
void mid_travel(BTnode* T)
{
	if (!T)
		return;
	mid_travel(T-&gt;left);
	printf("%d ", T-&gt;data);
	mid_travel(T-&gt;right);
}

//递归查找数据
BTnode* Btree_search(BTnode* root, DataType target) {
	if (!root)
		return NULL;
	if (target == root-&gt;data) {
		return root;
	}
	return target &gt; root-&gt;data ? Btree_search(root-&gt;right, target) : Btree_search(root-&gt;left, target);
}
//非递归查找
BTnode* Btree_search_fa(BTnode* T, DataType target) {
	BTnode* p = T, * f = NULL;
	while (p) {
		if (p-&gt;data == target)
		{
			return f;
		}
		f = p;
		p = target &gt; p-&gt;data ? p-&gt;right : p-&gt;left;
	}
	return NULL;
}

//获取最大值
int Btree_max(BTnode* T) {
	BTnode* cur = T;
	while (cur-&gt;right) {
		cur = cur-&gt;right;
	}
	return cur-&gt;data;
}
//获取最小值
int Btree_min(BTnode* T) {
	BTnode* cur = T;
	while (cur-&gt;left) {
		cur = cur-&gt;left;
	}
	return cur-&gt;data;
}


//删除节点
void Btree_del(BTnode* T, DataType l) {
	if (!T) {
		printf("fuck no\n");
		return;
	}
	//找到这个要删除节点的父节点
	BTnode* p = T, * f = NULL;
	while (p) {
		if (p-&gt;data == l)
		{
			break;
		}
		f = p;
		p = l &gt; p-&gt;data ? p-&gt;right : p-&gt;left;
	}
	if (!p)
	{
		printf("没有这个节点\n");
		return;
	}
	BTnode* target = p;//此时的要删除目标节点
	BTnode* par = f; //此时要删除节点的父节点

	//第一种情况 此节点只有一个子树的时候
	if (!target-&gt;left &amp;&amp; target-&gt;right != NULL)
	{
		if (target-&gt;data &gt; par-&gt;data) {
			par-&gt;right = target-&gt;right;
		}
		else {
			par-&gt;left = target-&gt;right;
		}
		free(target);//释放空间
		target = NULL;
	}
	else if (target-&gt;left != NULL &amp;&amp; !target-&gt;right) {
		if (target-&gt;data &gt; par-&gt;data) {
			par-&gt;right = target-&gt;left;
		}
		else {
			par-&gt;left = target-&gt;left;
		}
		free(target);
		target = NULL;
	}
	//第二种情况，如果删除的是叶节点，直接删除即可
	else if (!target-&gt;left &amp;&amp; !target-&gt;right) {
		if (target-&gt;data &gt; par-&gt;data) {
			par-&gt;right = NULL;
		}
		else {
			par-&gt;left = NULL;
		}
		free(target);
		target = NULL;
	}
	//第三种情况,如果左右子树都存在的话
	//可以用右子树的最小元素
	//或者左子树的最大元素来替代被删除的节点
	//我这里就直接去用左树的最大代替这个节点
	else
	{
		BTnode* Lchild = target-&gt;left;
		BTnode* Lchild_par = NULL;//要找的替换节点的父节点
		while (Lchild-&gt;right != NULL) {
			Lchild_par = Lchild;
			Lchild = Lchild-&gt;right;
			
		}
	
		if (Lchild-&gt;left!=NULL) {
			Lchild_par-&gt;right = Lchild-&gt;left;
		}
		else
			Lchild_par-&gt;right = NULL;
		target-&gt;data = Lchild-&gt;data;
		free(Lchild);
		Lchild = NULL;
	}
	printf("Deleting successfully\n");
}

//销毁
void Destory_btree(BTnode* T) {
	if (!T)
		return;
	BTnode* cur = T;
	if (cur-&gt;left)
		Destory_btree(cur-&gt;left);
	if (cur-&gt;right)
		Destory_btree(cur-&gt;right);
	free(T);
}

int main()
{
	int a[] = { 53,17,78,9,45,65,87,23 };
	//创建二叉排序树
	BTnode* T = Create_sortBtree(a, sizeof(a) / sizeof(int));
	mid_travel(T);//遍历输出
	puts("");
	//删除最大最小值
	printf("max:%d  min:%d\n", Btree_max(T), Btree_min(T));
	//查找
	BTnode* find = Btree_search(T, 23);
	printf("查找结果%d\n", find-&gt;data);

	//删除节点
	Btree_del(T, 45);
	mid_travel(T);
	puts("");
	//销毁操作
	Destory_btree(T);
}
//输出结果：
//9 17 23 45 53 65 78 87
//max:87  min : 9
//查找结果23
//Deleting successfully
//9 17 23 53 65 78 87


</code></pre> 
<p><strong><span style="color:#956fe7;"><em>以上就是二叉排序树的全部内容了，我们下次见咯！祝各位国庆节快乐！</em></span></strong></p> 
<p> 分享一张壁纸：<img alt="" height="1080" src="https://images2.imgbox.com/54/6a/n4MyvyEh_o.png" width="1200"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bb6a3c8704a899d160f020834a553e06/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">华为ensp中nat server 公网访问内网服务器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4971a174ec12a8b609a5b7325f4a57cd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Stable Diffusion本地部署教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>