<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【动态规划】斐波那契数列模型（C&#43;&#43;） - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/2dca1e162e29b6a792beb4ee86c1dc9f/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【动态规划】斐波那契数列模型（C&#43;&#43;）">
  <meta property="og:description" content="目录 1137.第N个泰波那契数
解法（动态规划） 算法流程
1. 状态表⽰：
2. 状态转移⽅程：
3. 初始化：
4. 填表顺序：
5. 返回值：
C&#43;&#43;算法代码 优化： 滚动数组
测试：
08.01.三步问题
解法（动态规划） 算法思路
1. 状态表⽰
2. 状态转移⽅程
3. 初始化
4. 填表顺序
5. 返回值
代码：
测试
746.使⽤最⼩花费爬楼梯
2. 状态转移⽅程：
3. 初始化：
测试：
91.解码⽅法
算法思路：
1. 状态表⽰：
2. 状态转移⽅程：
3. 初始化：
代码： 优化
测试
1137.第N个泰波那契数 解法（动态规划） 算法流程 1. 状态表⽰： 这道题可以「根据题⽬的要求」直接定义出状态表⽰：
dp[i] 表⽰：第i 个泰波那契数的值。
2. 状态转移⽅程： 题⽬已经⾮常贴⼼的告诉我们了： dp[i] = dp[i - 1] &#43; dp[i - 2] &#43; dp[i - 3]">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-23T14:46:49+08:00">
    <meta property="article:modified_time" content="2024-05-23T14:46:49+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【动态规划】斐波那契数列模型（C&#43;&#43;）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%C2%A0"><strong>目录</strong></h2> 
<p id="1137.%E7%AC%ACN%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0-toc" style="margin-left:0px;"><a href="#1137.%E7%AC%ACN%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0" rel="nofollow">1137.第N个泰波那契数</a></p> 
<p id="%E8%A7%A3%E6%B3%95%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89%20%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%E8%A7%A3%E6%B3%95%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89%20%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B" rel="nofollow">解法（动态规划） 算法流程</a></p> 
<p id="1.%20%E7%8A%B6%E6%80%81%E8%A1%A8%E2%BD%B0%EF%BC%9A-toc" style="margin-left:80px;"><a href="#1.%20%E7%8A%B6%E6%80%81%E8%A1%A8%E2%BD%B0%EF%BC%9A" rel="nofollow">1. 状态表⽰：</a></p> 
<p id="2.%20%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E2%BD%85%E7%A8%8B%EF%BC%9A-toc" style="margin-left:80px;"><a href="#2.%20%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E2%BD%85%E7%A8%8B%EF%BC%9A" rel="nofollow">2. 状态转移⽅程：</a></p> 
<p id="3.%20%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A-toc" style="margin-left:80px;"><a href="#3.%20%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A" rel="nofollow">3. 初始化：</a></p> 
<p id="4.%20%E5%A1%AB%E8%A1%A8%E9%A1%BA%E5%BA%8F%EF%BC%9A-toc" style="margin-left:80px;"><a href="#4.%20%E5%A1%AB%E8%A1%A8%E9%A1%BA%E5%BA%8F%EF%BC%9A" rel="nofollow">4. 填表顺序：</a></p> 
<p id="5.%20%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A-toc" style="margin-left:80px;"><a href="#5.%20%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A" rel="nofollow">5. 返回值：</a></p> 
<p id="%C2%A0C%2B%2B%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%C2%A0-toc" style="margin-left:40px;"><a href="#%C2%A0C%2B%2B%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%C2%A0" rel="nofollow"> C++算法代码 </a></p> 
<p id="%E4%BC%98%E5%8C%96%EF%BC%9A%C2%A0%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84-toc" style="margin-left:80px;"><a href="#%E4%BC%98%E5%8C%96%EF%BC%9A%C2%A0%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84" rel="nofollow">优化： 滚动数组</a></p> 
<p id="%E6%B5%8B%E8%AF%95%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E6%B5%8B%E8%AF%95%EF%BC%9A" rel="nofollow">测试：</a></p> 
<p id="08.01.%E4%B8%89%E6%AD%A5%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><a href="#08.01.%E4%B8%89%E6%AD%A5%E9%97%AE%E9%A2%98" rel="nofollow">08.01.三步问题</a></p> 
<p id="%E8%A7%A3%E6%B3%95%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89%20%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px;"><a href="#%E8%A7%A3%E6%B3%95%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89%20%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF" rel="nofollow">解法（动态规划） 算法思路</a></p> 
<p id="1.%20%E7%8A%B6%E6%80%81%E8%A1%A8%E2%BD%B0-toc" style="margin-left:80px;"><a href="#1.%20%E7%8A%B6%E6%80%81%E8%A1%A8%E2%BD%B0" rel="nofollow">1. 状态表⽰</a></p> 
<p id="2.%20%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E2%BD%85%E7%A8%8B-toc" style="margin-left:80px;"><a href="#2.%20%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E2%BD%85%E7%A8%8B" rel="nofollow">2. 状态转移⽅程</a></p> 
<p id="3.%20%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px;"><a href="#3.%20%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">3. 初始化</a></p> 
<p id="4.%20%E5%A1%AB%E8%A1%A8%E9%A1%BA%E5%BA%8F-toc" style="margin-left:80px;"><a href="#4.%20%E5%A1%AB%E8%A1%A8%E9%A1%BA%E5%BA%8F" rel="nofollow">4. 填表顺序</a></p> 
<p id="5.%20%E8%BF%94%E5%9B%9E%E5%80%BC-toc" style="margin-left:80px;"><a href="#5.%20%E8%BF%94%E5%9B%9E%E5%80%BC" rel="nofollow">5. 返回值</a></p> 
<p id="%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">代码：</a></p> 
<p id="%E6%B5%8B%E8%AF%95-toc" style="margin-left:40px;"><a href="#%E6%B5%8B%E8%AF%95" rel="nofollow">测试</a></p> 
<p id="746.%E4%BD%BF%E2%BD%A4%E6%9C%80%E2%BC%A9%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF-toc" style="margin-left:0px;"><a href="#746.%E4%BD%BF%E2%BD%A4%E6%9C%80%E2%BC%A9%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF" rel="nofollow">746.使⽤最⼩花费爬楼梯</a></p> 
<p id="2.%20%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E2%BD%85%E7%A8%8B%EF%BC%9A-toc" style="margin-left:80px;"><a href="#2.%20%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E2%BD%85%E7%A8%8B%EF%BC%9A" rel="nofollow">2. 状态转移⽅程：</a></p> 
<p id="3.%20%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A-toc" style="margin-left:80px;"><a href="#3.%20%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A" rel="nofollow">3. 初始化：</a></p> 
<p id="%E6%B5%8B%E8%AF%95%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%B5%8B%E8%AF%95%EF%BC%9A" rel="nofollow">测试：</a></p> 
<p id="%C2%A091.%E8%A7%A3%E7%A0%81%E2%BD%85%E6%B3%95-toc" style="margin-left:0px;"><a href="#%C2%A091.%E8%A7%A3%E7%A0%81%E2%BD%85%E6%B3%95" rel="nofollow"> 91.解码⽅法</a></p> 
<p id="%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF%EF%BC%9A" rel="nofollow">算法思路：</a></p> 
<p id="1.%20%E7%8A%B6%E6%80%81%E8%A1%A8%E2%BD%B0%EF%BC%9A-toc" style="margin-left:80px;"><a href="#1.%20%E7%8A%B6%E6%80%81%E8%A1%A8%E2%BD%B0%EF%BC%9A" rel="nofollow">1. 状态表⽰：</a></p> 
<p id="2.%20%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E2%BD%85%E7%A8%8B%EF%BC%9A-toc" style="margin-left:80px;"><a href="#2.%20%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E2%BD%85%E7%A8%8B%EF%BC%9A" rel="nofollow">2. 状态转移⽅程：</a></p> 
<p id="3.%20%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A-toc" style="margin-left:80px;"><a href="#3.%20%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A" rel="nofollow">3. 初始化：</a></p> 
<p id="%E4%BB%A3%E7%A0%81%EF%BC%9A%C2%A0-toc" style="margin-left:40px;"><a href="#%E4%BB%A3%E7%A0%81%EF%BC%9A%C2%A0" rel="nofollow">代码： </a></p> 
<p id="%E4%BC%98%E5%8C%96-toc" style="margin-left:80px;"><a href="#%E4%BC%98%E5%8C%96" rel="nofollow">优化</a></p> 
<p id="%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#%E6%B5%8B%E8%AF%95" rel="nofollow">测试</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1137.%E7%AC%ACN%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span style="color:#1a439c;">1137.第N个泰波那契数</span></h2> 
<p><img alt="" height="478" src="https://images2.imgbox.com/2a/ae/iD1Ct8wu_o.png" width="650"></p> 
<h3 id="%E8%A7%A3%E6%B3%95%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89%20%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B">解法（动态规划） 算法流程</h3> 
<h4 id="1.%20%E7%8A%B6%E6%80%81%E8%A1%A8%E2%BD%B0%EF%BC%9A">1. 状态表⽰：</h4> 
<blockquote> 
 <p>这道题可以「根据题⽬的要求」直接定义出状态表⽰：</p> 
 <p></p> 
 <p>dp[i] 表⽰：第i 个泰波那契数的值。</p> 
</blockquote> 
<h4 id="2.%20%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E2%BD%85%E7%A8%8B%EF%BC%9A">2. 状态转移⽅程：</h4> 
<p>题⽬已经⾮常贴⼼的告诉我们了： </p> 
<p><span style="color:#1c7892;"><strong><span style="background-color:#cbe0f1;">dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]</span></strong></span></p> 
<h4 id="3.%20%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A">3. 初始化：</h4> 
<blockquote> 
 <p>从我们的递推公式可以看出， dp[i] 在 i = 0 以及i = 1 的时候是没有办法进⾏推导的，因 为dp[-2] 或dp[-1] 不是⼀个有效的数据。</p> 
 <p></p> 
 <p>因此我们需要在填表之前，将0, 1, 2 位置的值初始化。题⽬中已经告诉我们dp[0] = 0, dp[1] = dp[2] = 1 。</p> 
</blockquote> 
<h4 id="4.%20%E5%A1%AB%E8%A1%A8%E9%A1%BA%E5%BA%8F%EF%BC%9A">4. 填表顺序：</h4> 
<p>毫⽆疑问是「从左往右」。</p> 
<h4 id="5.%20%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A">5. 返回值：</h4> 
<p>应该返回dp[n] 的值。</p> 
<p></p> 
<h3 id="%C2%A0C%2B%2B%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%C2%A0"><strong> C++算法代码 </strong></h3> 
<p>使⽤⼀维数组：</p> 
<pre><code class="language-cpp">class Solution {
public:
    int tribonacci(int n) {
        //如何填，抄状态转移方程
        if(n==0||n==1)
        return n;
        vector&lt;int&gt; dp(n+1);
        dp[0]=0,dp[1]=1,dp[2]=1;//初始化前三个
        //left-&gt;right
        for(int i=3;i&lt;=n;i++)
        dp[i]=dp[i-1]+dp[i-2]+dp[i-3];
        //返回
        return dp[n];
        //核心：从左往右一个个+
    }
};</code></pre> 
<h4 id="%E4%BC%98%E5%8C%96%EF%BC%9A%C2%A0%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84">优化： 滚动数组</h4> 
<p> //之后的背包中，会更加常用：</p> 
<pre><code class="language-cpp">//滚动数组优化
int tribonacci(int n){
    if(n==0)return 0;
    if(n==1||n==2)return 1;
    int a=0,b=1,c=1,d=0;
    for(int i=3;i&lt;=n;i++)
    {
        d=a+b+c;
        a=b;b=c;c=d;
    }
    return d;

}</code></pre> 
<h4 id="%E6%B5%8B%E8%AF%95%EF%BC%9A">测试：</h4> 
<p><img alt="" height="281" src="https://images2.imgbox.com/e8/12/BFkyPA3U_o.png" width="650"></p> 
<h2 id="08.01.%E4%B8%89%E6%AD%A5%E9%97%AE%E9%A2%98"><span style="color:#1a439c;">08.01.三步问题</span></h2> 
<p><img alt="" height="399" src="https://images2.imgbox.com/ca/dd/4p828m2g_o.png" width="600"></p> 
<h3 id="%E8%A7%A3%E6%B3%95%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89%20%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF">解法（动态规划） 算法思路</h3> 
<h4 id="1.%20%E7%8A%B6%E6%80%81%E8%A1%A8%E2%BD%B0">1. 状态表⽰</h4> 
<p>这道题可以根据「经验+题⽬要求」直接定义出状态表⽰： dp[i] 表⽰：到达 i 位置时，⼀共有多少种⽅法。</p> 
<h4 id="2.%20%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E2%BD%85%E7%A8%8B">2. 状态转移⽅程</h4> 
<blockquote> 
 <p>以i位置状态的最近的⼀步，来分情况讨论：</p> 
 <p>如果 dp[i] 表⽰⼩孩上第i 阶楼梯的所有⽅式，那么它应该等于所有上⼀步的⽅式之和：</p> 
 <ul><li>i. 上⼀步上⼀级台阶， dp[i] += dp[i - 1] ；</li><li>ii. 上⼀步上两级台阶， dp[i] += dp[i - 2] ；</li><li>iii. 上⼀步上三级台阶， dp[i] += dp[i - 3] ；</li></ul> 
 <p>综上所述， dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] 。</p> 
 <p>需要注意的是，这道题⽬说，由于结果可能很⼤，需要对结果取模。</p> 
 <p></p> 
 <p>在计算的时候，三个值全部加起来再取模，即(dp[i - 1] + dp[i - 2] + dp[i - 3]) % MOD 是不可取的，同学们可以试验⼀下， n 取题⽬范围内最⼤值时，⽹站会报错signed integer overflow 。</p> 
 <p>对于这类需要取模的问题，<span style="color:#be191c;">我们每计算⼀次（两个数相加/乘等），都需要取⼀次模。否则，万⼀ 发⽣了溢出，我们的答案就错了</span>。</p> 
</blockquote> 
<h4 id="3.%20%E5%88%9D%E5%A7%8B%E5%8C%96">3. 初始化</h4> 
<p>从我们的递推公式可以看出， dp[i] 在i = 0, i = 1 以及i = 2 的时候是没有办法进⾏ 推导的，因为<span style="color:#be191c;"><span style="background-color:#fbd4d0;">dp[-3] dp[-2] 或dp[-1] 不是⼀个有效的数据。</span></span></p> 
<p> 因此我们需要在填表之前，将1, 2, 3 位置的值初始化。</p> 
<p>根据题意， dp[1] = 1, dp[2] = 2, dp[3] = 4 。</p> 
<h4 id="4.%20%E5%A1%AB%E8%A1%A8%E9%A1%BA%E5%BA%8F">4. 填表顺序</h4> 
<p>毫⽆疑问是「从左往右」。</p> 
<h4 id="5.%20%E8%BF%94%E5%9B%9E%E5%80%BC">5. 返回值</h4> 
<p>应该返回dp[n] 的值。</p> 
<h3 id="%E4%BB%A3%E7%A0%81%EF%BC%9A">代码：</h3> 
<pre><code class="language-cpp">#define MOD 1000000007
class Solution {
    //有一点起始累加，到最后一个的感觉
public:
    int waysToStep(int n) {
        //1.状态表示  i和dp[i]表示什么
        //2.方程      dp[i]和最近一步的关系
        //3.初始化    不可越界
        //4.填表顺序   是从左到右还是从右到左
        //5.返回       dp[i/i-1]
        int i=0;
        vector&lt;int&gt; dp(n+1);//n+1 因为数组有0
        dp[1]=1;dp[2]=2;dp[3]=4;
        if(n==1||n==2) return n;
        if(n==3) return 4;
        for(i=4;i&lt;=n;i++)
        dp[i]=((dp[i-1]+dp[i-2])%MOD+dp[i-3])%MOD;
        return dp[n];
    }
};</code></pre> 
<h3 id="%E6%B5%8B%E8%AF%95">测试</h3> 
<p><img alt="" height="126" src="https://images2.imgbox.com/ea/3d/B5Ko89c1_o.png" width="484"></p> 
<h2 id="746.%E4%BD%BF%E2%BD%A4%E6%9C%80%E2%BC%A9%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span style="color:#1a439c;">746.使⽤最⼩花费爬楼梯</span></h2> 
<p> <img alt="" height="354" src="https://images2.imgbox.com/1a/88/weZ890OS_o.png" width="600"></p> 
<p><strong><span style="color:#be191c;">注意注意：</span></strong></p> 
<p>在这道题中，数组内的每⼀个下标[0, n - 1] 表⽰的都是楼层，⽽<span style="color:#b95514;">顶楼的位置其实是在n 的 位置！！！  </span></p> 
<p><span style="color:#0d0016;">之后我们就着重研究：方程和初始化啦~</span></p> 
<h4>2. 状态转移⽅程：</h4> 
<blockquote> 
 <p>根据最近的⼀步，分情况讨论：</p> 
 <p></p> 
 <p>▪ 先到达i - 1 的位置，然后⽀付cost[i - 1] ，接下来⾛⼀步⾛到 i 位置：</p> 
 <p><span style="color:#b95514;">dp[i - 1] + csot[i - 1] </span>；</p> 
 <p>▪ 先到达i - 2 的位置，然后⽀付 cost[i - 2] ，接下来⾛⼀步⾛到i 位置：</p> 
 <p><span style="color:#b95514;">dp[i - 2] + csot[i - 2] </span>。</p> 
 <p></p> 
 <p><span style="color:#be191c;"><span style="background-color:#fbd4d0;"> dp[i]= min (cost[i-1]+dp[i-1],cost[i-2]+dp[i-2]);</span></span></p> 
</blockquote> 
<h4>3. 初始化：</h4> 
<p>从我们的递推公式可以看出，我们需要先初始化i = 0 ，以及i = 1 位置的值。容易得到<span style="color:#1a439c;"> <span style="background-color:#cbe0f1;">dp[0] = dp[1] = 0 </span></span>，因为不需要任何花费，就可以直接站在第0 层和第1 层上。</p> 
<pre><code class="language-cpp">class Solution {
public:
    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) {
        int n=cost.size();
        //初始化一个dp表
        vector&lt;int&gt; dp(n+1,0);
        //初始化
        dp[0]=dp[1]=0;
        //填表
        for(int i=2;i&lt;n+1;i++)
        //根据状态转移方程得
        dp[i]=min(cost[i-1]+dp[i-1],cost[i-2]+dp[i-2]);
        //一步两步当中，勇敢取小
        return dp[n];

    }
};</code></pre> 
<h3>测试：</h3> 
<p><img alt="" height="297" src="https://images2.imgbox.com/62/78/jv3ajttr_o.png" width="600"></p> 
<h2 id="%C2%A091.%E8%A7%A3%E7%A0%81%E2%BD%85%E6%B3%95"><span style="color:#1a439c;"> 91.解码⽅法</span></h2> 
<p><img alt="" height="435" src="https://images2.imgbox.com/f9/9c/UXkKvji3_o.png" width="600"></p> 
<h3 id="%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF%EF%BC%9A">算法思路：</h3> 
<p>类似于斐波那契数列~</p> 
<h4>1. 状态表⽰：</h4> 
<p>根据以往的经验，对于⼤多数线性dp ，<span style="color:#be191c;">我们经验上都是「以某个位置结束或者开始」做⽂章</span>，这 ⾥我们继续尝试<span style="color:#be191c;">「⽤i位置为结尾」</span>结合「题⽬要求」来定义状态表⽰。</p> 
<p> dp[i] 表⽰：字符串中 [0，i] 区间上，⼀共有多少种<span style="color:#1a439c;">编码⽅法</span>。//一般都是所求及dp</p> 
<h4>2. 状态转移⽅程：</h4> 
<p>定义好状态表⽰，我们就可以分析 i 位置的 dp 值，如何由「前⾯」或者「后⾯」的信息推导出 来。</p> 
<p>关于i 位置的编码状况，我们可以分为下⾯两种情况：</p> 
<blockquote> 
 <ul><li>i. 让i 位置上的数单独解码成⼀个字⺟；</li><li>ii. 让i 位置上的数与i - 1 位置上的数结合，解码成⼀个字⺟。</li></ul> 
</blockquote> 
<p> 下⾯我们就上⾯的两种解码情况，继续分析：</p> 
<p>◦ 让i位置上的数单独解码成⼀个字⺟，就存在「解码成功」和「解码失败」两种情况：</p> 
<blockquote> 
 <ul><li><strong><span style="background-color:#ffd7b9;">i. 解码成功</span>：</strong>当 i 位置上的数在 [1, 9] 之间的时候，说明i 位置上的数是可以单独解 码的，那么此时[0, i] 区间上的解码⽅法应该等于 [0, i - 1] 区间上的解码⽅ 法。因为 [0, i - 1] 区间上的所有解码结果，后⾯填上⼀个 i 位置解码后的字⺟就 可以了。此时 <strong><span style="color:#b95514;">dp[i] = dp[i - 1] ；</span></strong></li><li><strong><span style="background-color:#ffd7b9;">ii. 解码失败：</span></strong>当 i 位置上的数是 0 的时候，说明 i 位置上的数是不能单独解码的，那么 此时 [0, i] 区间上不存在解码⽅法。因为 i 位置如果单独参与解码，但是解码失败 了，那么前⾯做的努⼒就全部⽩费了。此时<span style="color:#b95514;"><strong> dp[i] = 0 。</strong></span></li></ul> 
</blockquote> 
<p>◦ 让 i 位置上的数与 i - 1 位置上的数结合在⼀起，解码成⼀个字⺟，也存在「解码成功」 和「解码失败」两种情况：</p> 
<blockquote> 
 <ul><li><strong><span style="background-color:#ffd7b9;">i. 解码成功：</span></strong>当结合的数在[10, 26] 之间的时候，说明[i - 1, i] 两个位置是可以 解码成功的，那么此时[0, i] 区间上的解码⽅法应该等于[0, i - 2 ]区间上的解码 ⽅法，原因同上。此时<strong><span style="color:#b95514;">dp[i] = dp[i - 2] </span></strong>；</li><li><strong><span style="background-color:#ffd7b9;"> ii. 解码失败</span></strong>：当结合的数在[0, 9] 和[27 , 99] 之间的时候，说明两个位置结合后解 码失败（这⾥⼀定要注意00 01 02 03 04 ......这⼏种情况），那么此时[0, i] 区 间上的解码⽅法就不存在了，原因依旧同上。此时<strong><span style="color:#b95514;">dp[i] = 0</span></strong> 。</li></ul> 
</blockquote> 
<p>综上所述： dp[i] 最终的结果应该是上⾯四种情况下，解码成功的两种的累加和（因为我们关⼼ 的是解码⽅法，既然解码失败，就不⽤加⼊到最终结果中去），因此可以得到状态转移⽅程 （ dp[i] 默认初始化为 0 ）：</p> 
<blockquote> 
 <ul><li> i. 当 s[i] 上的数在 [1, 9] 区间上时： dp[i] += dp[i - 1] ；</li><li> ii. 当 s[i - 1] 与 s[i] 上的数结合后，在[10, 26] 之间的时候： dp[i] += dp[i - 2] ；</li></ul> 
</blockquote> 
<p>如果上述两个判断都不成⽴，<span style="color:#b95514;">说明没有解码⽅法， dp[i] 就是默认值 0 。</span></p> 
<h4>3. 初始化：</h4> 
<p>⽅法⼀（直接初始化）：</p> 
<blockquote> 
 <p>由于可能要⽤到i - 1 以及i - 2 位置上的dp 值，因此要先初始化「前两个位置」。初始化dp[0] ：</p> 
 <p> i. 当s[0] == '0' 时，没有编码⽅法，结果dp[0] = 0 ；</p> 
 <p> ii. 当s[0] != '0' 时，能编码成功， dp[0] = 1</p> 
 <p> 初始化dp[1] ：</p> 
 <p>i. 当s[1] 在[1，9] 之间时，能单独编码，此时dp[1] += dp[0] （原因同上， dp[1] 默认为0 ）</p> 
 <p>ii. 当s[0] 与s[1] 结合后的数在[10, 26] 之间时，说明在前两个字符中，⼜有⼀种 编码⽅式，此时dp[1] += 1</p> 
</blockquote> 
<p> ⽅法⼆（添加辅助位置初始化）：</p> 
<p>可以在最前⾯加上⼀个辅助结点，帮助我们初始化。使⽤这种技巧要注意两个点：</p> 
<blockquote> 
 <p>i. 辅助结点⾥⾯的值要保证后续填表是正确的；</p> 
 <p><span style="color:#b95514;">ii. 下标的映射关系</span></p> 
</blockquote> 
<h3 id="%E4%BB%A3%E7%A0%81%EF%BC%9A%C2%A0">代码： </h3> 
<pre><code class="language-cpp">class Solution {
    // dp 是一种从起始到末的次数累加
public:
    int numDecodings(string s) {
        // size
        int n = s.size();
        vector&lt;int&gt; dp(n); // 创建一个dp表

        // 初始化前两个位置
        dp[0] = s[0] != '0';
        if (n == 1)
            return dp[0]; // 处理边界情况
        if (s[1] &lt;= '9' &amp;&amp; s[1] &gt;= '1')
            dp[1] += dp[0];
        int t = (s[0] - '0') * 10 + s[1] - '0';
//如果和前一个数 联合编码
        if (t &gt;= 10 &amp;&amp; t &lt;= 26)
            dp[1] += 1;
        for (int i = 2; i &lt; n; i++) {
            // 如果单独编码
            if (s[i] &lt;= '9' &amp;&amp; s[i] &gt;= '1')
                dp[i] += dp[i - 1];
            int t = (s[i - 1] - '0') * 10 + s[i] - '0';
            if (t &gt;= 10 &amp;&amp; t &lt;= 26)
                dp[i] += dp[i - 2];
        }
        return dp[n - 1];
    }
};</code></pre> 
<h4 id="%E4%BC%98%E5%8C%96">优化</h4> 
<p>使用添加辅助结点的方式 初始化：</p> 
<pre><code class="language-cpp">class Solution {
public:
    int numDecodings(string s) {
        // 优化
        int n = s.size();
        vector&lt;int&gt; dp(n + 1);
        dp[0] = 1; // 保证后续填表是正确的
        dp[1] = s[0] != '0';
        // 填表
        for (int i = 2; i &lt;= n; i++) {
            // 处理单独编码
            if (s[i - 1] != '0')
                dp[i] += dp[i - 1];
            // 如果和前⾯的⼀个数联合起来编码
            int t = (s[i - 2] - '0') * 10 + s[i - 1] - '0';
            if (t &gt;= 10 &amp;&amp; t &lt;= 26)
                dp[i] += dp[i - 2];
        }
        return dp[n];
    }
};</code></pre> 
<h4 style="background-color:transparent;">测试</h4> 
<p><img alt="" height="264" src="https://images2.imgbox.com/91/3f/cTd2RCc1_o.png" width="600"></p> 
<p> 本文就到这里结束啦，大家也可以多多去力扣刷一些 动态规划的题  巩固一下~</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5be9e2e8da19e148dcc4d24cda7564b0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在jetson nano中安装jetson.inference模块</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/77d867b6ea6abd920dba54cb6fabc2f2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在 MFC 中 UNICODE 加 _T 与 L 长字符串，有什么区别？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>