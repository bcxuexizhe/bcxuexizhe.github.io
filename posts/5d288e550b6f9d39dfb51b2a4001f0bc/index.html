<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Spring】Spring中AOP的简介和基本使用，SpringBoot使用AOP - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/5d288e550b6f9d39dfb51b2a4001f0bc/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【Spring】Spring中AOP的简介和基本使用，SpringBoot使用AOP">
  <meta property="og:description" content="📝个人主页：哈__
期待您的关注 目录
一、AOP简介
二、AOP个人浅谈
三、AOP中几个核心的方法注解
四、AOP中几个核心的属性
1.切入点（PointCut）
五、代码演示
1.SpringBoot引入依赖
2.定义一个AOP，也就是切面类 3.使用自定义注解进行增强
六、AOP实现的原理
一、AOP简介 AOP的全称是Aspect-Oriented Programming，即面向切面编程（也称面向方面编程）。它是面向对象编程（OOP）的一种补充，目前已成为一种比较成熟的编程方式。
在传统的业务处理代码中，通常都会进行事务处理、日志记录等操作。虽然使用OOP可以通过组合或者继承的方式来达到代码的重用，但如果要实现某个功能（如日志记录），同样的代码仍然会分散到各个方法中。这样，如果想要关闭某个功能，或者对其进行修改，就必须要修改所有的相关方法。这不但增加了开发人员的工作量，而且提高了代码的出错率。
为了解决这一问题，AOP思想随之产生。AOP采取横向抽取机制，将分散在各个方法中的重复代码提取出来，然后在程序编译或运行时，再将这些提取出来的代码应用到需要执行的地方。这种采用横向抽取机制的方式，采用传统的OOP思想显然是无法办到的，因为OOP只能实现父子关系的纵向的重用。虽然AOP是一种新的编程思想，但却不是OOP的替代品，它只是OOP的延伸和补充。
可以看看类和切面的关系，图片来自黑马程序员。
行了，到了这一步了也不就在废话了，我在尽量不使用太多专业术语的情况下尽可能给大家讲明白AOP。
二、AOP个人浅谈 在我们传统的OOP（面向对象编程）时，在我们原有的方法上我们希望做一些修改，我们希望啊，在执行这个方法之前通知我们的老板，告诉他我已经开始执行任务啦，不要再催促我了。在方法执行结束后，我还要把执行结果告诉老板。那么你会怎么做，是如下边的代码一样吗？
这样子做的确没问题，但是你有没有想过，如果我们的老板比较认真，每一项任务都要向老板汇报，那么你这样写代码还方便吗？如果你只有几项任务的话还好说，就是累一些，但如果你有五十项，一百项呢？
这时AOP就凸显出它的优点了。如果看了简介不明白什么是AOP，那么现在来看看我的理解。
你有很多的任务，你无法把每一项任务都向老板汇报。这时有着这样的一个组织，这个组织可以帮你和老板进行沟通，如果你想对你任务进行这样的能力增强，你就要告诉这个组织，你需要他们的帮助。什么意思呢？我用一张图来解释。
你需要AOP给你提供的帮助，你就需要向AOP提供你要进行业务能力增强的方法的路径，AOP找到这个方法就会对方法进行增强，在你调用方法的时候就会进行增强。
这下你总能理解什么是AOP了吧。
三、AOP中几个核心的方法注解 下边的代码我只使用的Around，其他的注解大家可以看看其他文章，或者自己试一下。
四、AOP中几个核心的属性 1.切入点（PointCut） 切入点就是用来描述我们到底要对哪个方法进行增强的，我们需要提供一串切入点需要的表达式。
切入点表达式的规则如下。
execution(modifier? ret-type declaring-type?name-pattern(param-pattern) throws-pattern?) modifier：匹配修饰符，public, private 等，省略时匹配任意修饰符ret-type：匹配返回类型，使用 * 匹配任意类型declaring-type：匹配目标类，省略时匹配任意类型 .. 匹配任意的包及其子包name-pattern：匹配方法名称，使用 * 表示通配符 * 表示所有的方法set* 匹配名称以 set 开头的方法param-pattern：匹配参数类型和数量 () 匹配没有参数的方法(..) 匹配有任意数量参数的方法(*) 匹配有一个任意类型参数的方法(*,int) 匹配有两个参数的方法，并且第一个为任意类型，第二个为 int 类型throws-pattern：匹配抛出异常类型，省略时匹配任意类型 下边的PointCut注解就传入了一个切入点表达式。
@Pointcut(value = &#34;execution(* com.example.shardingsphere.controller.*.*(..))&#34;) 五、代码演示 1.SpringBoot引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-07T17:23:37+08:00">
    <meta property="article:modified_time" content="2024-05-07T17:23:37+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Spring】Spring中AOP的简介和基本使用，SpringBoot使用AOP</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><img alt="" height="150" src="https://images2.imgbox.com/ec/ac/xiOSRhV9_o.png" width="150"></p> 
<p style="text-align:center;"> <strong> 📝个人主页：<a class="link-info" href="https://blog.csdn.net/qq_61024956?type=blog" title="哈__">哈__</a></strong></p> 
<p style="text-align:center;"><span style="color:#fe2c24;">期待您的关注 </span></p> 
<p style="text-align:center;"><img alt="" height="100" src="https://images2.imgbox.com/17/c4/7XAPsC9N_o.gif" width="1000"></p> 
<p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81AOP%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81AOP%E7%AE%80%E4%BB%8B" rel="nofollow">一、AOP简介</a></p> 
<p id="%E4%BA%8C%E3%80%81AOP%E4%B8%AA%E4%BA%BA%E6%B5%85%E8%B0%88-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81AOP%E4%B8%AA%E4%BA%BA%E6%B5%85%E8%B0%88" rel="nofollow">二、AOP个人浅谈</a></p> 
<p id="%E4%B8%89%E3%80%81AOP%E4%B8%AD%E5%87%A0%E4%B8%AA%E6%A0%B8%E5%BF%83%E7%9A%84%E6%96%B9%E6%B3%95%E6%B3%A8%E8%A7%A3-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81AOP%E4%B8%AD%E5%87%A0%E4%B8%AA%E6%A0%B8%E5%BF%83%E7%9A%84%E6%96%B9%E6%B3%95%E6%B3%A8%E8%A7%A3" rel="nofollow">三、AOP中几个核心的方法注解</a></p> 
<p id="%E5%9B%9B%E3%80%81AOP%E4%B8%AD%E5%87%A0%E4%B8%AA%E6%A0%B8%E5%BF%83%E7%9A%84%E5%B1%9E%E6%80%A7-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81AOP%E4%B8%AD%E5%87%A0%E4%B8%AA%E6%A0%B8%E5%BF%83%E7%9A%84%E5%B1%9E%E6%80%A7" rel="nofollow">四、AOP中几个核心的属性</a></p> 
<p id="1.%E5%88%87%E5%85%A5%E7%82%B9%EF%BC%88PointCut%EF%BC%89-toc" style="margin-left:40px;"><a href="#1.%E5%88%87%E5%85%A5%E7%82%B9%EF%BC%88PointCut%EF%BC%89" rel="nofollow">1.切入点（PointCut）</a></p> 
<p id="%E4%BA%94%E3%80%81%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA" rel="nofollow">五、代码演示</a></p> 
<p id="1.SpringBoot%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96-toc" style="margin-left:40px;"><a href="#1.SpringBoot%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96" rel="nofollow">1.SpringBoot引入依赖</a></p> 
<p id="2.%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AAAOP%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%88%87%E9%9D%A2%E7%B1%BB%C2%A0-toc" style="margin-left:40px;"><a href="#2.%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AAAOP%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%88%87%E9%9D%A2%E7%B1%BB%C2%A0" rel="nofollow">2.定义一个AOP，也就是切面类 </a></p> 
<p id="3.%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E8%BF%9B%E8%A1%8C%E5%A2%9E%E5%BC%BA-toc" style="margin-left:40px;"><a href="#3.%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E8%BF%9B%E8%A1%8C%E5%A2%9E%E5%BC%BA" rel="nofollow">3.使用自定义注解进行增强</a></p> 
<p id="%E5%85%AD%E3%80%81AOP%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81AOP%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86" rel="nofollow">六、AOP实现的原理</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81AOP%E7%AE%80%E4%BB%8B">一、AOP简介</h2> 
<blockquote> 
 <p> AOP的全称是Aspect-Oriented Programming，即面向切面编程（也称面向方面编程）。它是面向对象编程（OOP）的一种补充，目前已成为一种比较成熟的编程方式。</p> 
 <p></p> 
 <p>在传统的业务处理代码中，通常都会进行事务处理、日志记录等操作。虽然使用OOP可以通过组合或者继承的方式来达到代码的重用，但如果要实现某个功能（如日志记录），同样的代码仍然会分散到各个方法中。这样，如果想要关闭某个功能，或者对其进行修改，就必须要修改所有的相关方法。这不但增加了开发人员的工作量，而且提高了代码的出错率。</p> 
 <p></p> 
 <p>为了解决这一问题，AOP思想随之产生。AOP采取横向抽取机制，将分散在各个方法中的重复代码提取出来，然后在程序编译或运行时，再将这些提取出来的代码应用到需要执行的地方。这种采用横向抽取机制的方式，采用传统的OOP思想显然是无法办到的，因为OOP只能实现父子关系的纵向的重用。虽然AOP是一种新的编程思想，但却不是OOP的替代品，它只是OOP的延伸和补充。</p> 
</blockquote> 
<p> 可以看看类和切面的关系，图片来自黑马程序员。</p> 
<p><img alt="" height="273" src="https://images2.imgbox.com/7e/1d/rX5qXvun_o.png" width="709"> 行了，到了这一步了也不就在废话了，我在尽量不使用太多专业术语的情况下尽可能给大家讲明白AOP。</p> 
<h2 id="%E4%BA%8C%E3%80%81AOP%E4%B8%AA%E4%BA%BA%E6%B5%85%E8%B0%88">二、AOP个人浅谈</h2> 
<p>在我们传统的OOP（面向对象编程）时，在我们原有的方法上我们希望做一些修改，我们希望啊，在执行这个方法之前通知我们的老板，告诉他我已经开始执行任务啦，不要再催促我了。在方法执行结束后，我还要把执行结果告诉老板。那么你会怎么做，是如下边的代码一样吗？</p> 
<p><img alt="" height="248" src="https://images2.imgbox.com/cc/85/tpddu1Lu_o.png" width="1105"></p> 
<p>这样子做的确没问题，但是你有没有想过，如果我们的老板比较认真，每一项任务都要向老板汇报，那么你这样写代码还方便吗？如果你只有几项任务的话还好说，就是累一些，但如果你有五十项，一百项呢？</p> 
<p>这时AOP就凸显出它的优点了。如果看了简介不明白什么是AOP，那么现在来看看我的理解。</p> 
<p>你有很多的任务，你无法把每一项任务都向老板汇报。这时有着这样的一个组织，这个组织可以帮你和老板进行沟通，如果你想对你任务进行这样的能力增强，你就要告诉这个组织，你需要他们的帮助。什么意思呢？我用一张图来解释。</p> 
<p><img alt="" height="501" src="https://images2.imgbox.com/d0/72/s7swDkUu_o.png" width="1033"></p> 
<p> 你需要AOP给你提供的帮助，你就需要向AOP提供你要进行业务能力增强的方法的路径，AOP找到这个方法就会对方法进行增强，在你调用方法的时候就会进行增强。</p> 
<p>这下你总能理解什么是AOP了吧。</p> 
<h2 id="%E4%B8%89%E3%80%81AOP%E4%B8%AD%E5%87%A0%E4%B8%AA%E6%A0%B8%E5%BF%83%E7%9A%84%E6%96%B9%E6%B3%95%E6%B3%A8%E8%A7%A3">三、AOP中几个核心的方法注解</h2> 
<p><img alt="" height="531" src="https://images2.imgbox.com/64/eb/JxoFsOF5_o.png" width="689"></p> 
<p>下边的代码我只使用的Around，其他的注解大家可以看看其他文章，或者自己试一下。</p> 
<h2 id="%E5%9B%9B%E3%80%81AOP%E4%B8%AD%E5%87%A0%E4%B8%AA%E6%A0%B8%E5%BF%83%E7%9A%84%E5%B1%9E%E6%80%A7">四、AOP中几个核心的属性</h2> 
<h3 id="1.%E5%88%87%E5%85%A5%E7%82%B9%EF%BC%88PointCut%EF%BC%89">1.切入点（PointCut）</h3> 
<p>切入点就是用来描述我们到底要对哪个方法进行增强的，我们需要提供一串切入点需要的表达式。</p> 
<p>切入点表达式的规则如下。</p> 
<pre><code class="language-java">execution(modifier? ret-type declaring-type?name-pattern(param-pattern) throws-pattern?)
</code></pre> 
<ul><li>modifier：匹配修饰符，public, private 等，省略时匹配任意修饰符</li><li>ret-type：匹配返回类型，使用 * 匹配任意类型</li><li>declaring-type：匹配目标类，省略时匹配任意类型 
  <ul><li><span style="background-color:#a2e043;">.. </span>匹配任意的包及其子包</li></ul></li><li>name-pattern：匹配方法名称，使用 * 表示通配符 
  <ul><li><strong><span style="background-color:#a2e043;">* </span></strong>表示所有的方法</li><li><span style="background-color:#a2e043;">set*</span> 匹配名称以 set 开头的方法</li></ul></li><li>param-pattern：匹配参数类型和数量 
  <ul><li><span style="background-color:#a2e043;">()</span> 匹配没有参数的方法</li><li><span style="background-color:#a2e043;">(..)</span> 匹配有任意数量参数的方法</li><li><span style="background-color:#a2e043;">(*) </span>匹配有一个任意类型参数的方法</li><li><span style="background-color:#a2e043;">(*,int)</span> 匹配有两个参数的方法，并且第一个为任意类型，第二个为 int 类型</li></ul></li><li>throws-pattern：匹配抛出异常类型，省略时匹配任意类型</li></ul> 
<p> 下边的PointCut注解就传入了一个切入点表达式。</p> 
<pre><code class="language-java">@Pointcut(value = "execution(* com.example.shardingsphere.controller.*.*(..))")</code></pre> 
<p><img alt="" height="261" src="https://images2.imgbox.com/8b/bc/iyLQhw1T_o.png" width="1200"></p> 
<h2 id="%E4%BA%94%E3%80%81%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA">五、代码演示</h2> 
<h3 id="1.SpringBoot%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96">1.SpringBoot引入依赖</h3> 
<pre><code class="language-java">         &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
        &lt;/dependency&gt;</code></pre> 
<h3 id="2.%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AAAOP%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%88%87%E9%9D%A2%E7%B1%BB%C2%A0">2.定义一个AOP，也就是切面类 </h3> 
<pre><code class="language-java">@Component
@Aspect
public class GlobalAspect {
    @Pointcut(value = "execution(* com.example.shardingsphere.controller.*.*(..))")
    public void pointCut(){}

    @Around(value =  "pointCut()")
    public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        Object proceed = null;
        System.out.println("通知老板开始统计了");
        proceed = proceedingJoinPoint.proceed();
        System.out.println("告诉老板统计结果");
        return proceed;
    }
}
</code></pre> 
<p> ProceedingJointPoint类还有许多的方法可以使用，比如获取原来方法的参数等功能。<strong>以下内容来自转载。</strong></p> 
<pre><code class="language-java">public interface JoinPoint {  
   String toString();         //连接点所在位置的相关信息  
   String toShortString();    //连接点所在位置的简短相关信息  
   String toLongString();     //连接点所在位置的全部相关信息  
   Object getThis();          //返回AOP代理对象，也就是com.sun.proxy.$Proxy18
   Object getTarget();        //返回目标对象，一般我们都需要它或者（也就是定义方法的接口或类，为什么会是接口呢？
                              //这主要是在目标对象本身是动态代理的情况下，例如Mapper。所以返回的是定义方法的对象如
                              //aoptest.daoimpl.GoodDaoImpl或com.b.base.BaseMapper&lt;T, E, PK&gt;）
   Object[] getArgs();        //返回被通知方法参数列表  
   Signature getSignature();  //返回当前连接点签名。其getName()方法返回方法的FQN，如void aoptest.dao.GoodDao.delete()
                              //或com.b.base.BaseMapper.insert(T)(需要注意的是，很多时候我们定义了子类继承父类的时候，
                              //我们希望拿到基于子类的FQN，无法直接拿到，要依赖于
                              //AopUtils.getTargetClass(point.getTarget())获取原始代理对象，下面会详细讲解)
   SourceLocation getSourceLocation();//返回连接点方法所在类文件中的位置  
   String getKind();           //连接点类型  
   StaticPart getStaticPart(); //返回连接点静态部分  
  }  

————————————————

                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，
                        
原文链接：https://blog.csdn.net/feiying0canglang/article/details/120711774</code></pre> 
<p>同时在启动程序上加上注解。</p> 
<pre><code class="language-java">@EnableAspectJAutoProxy</code></pre> 
<p>进行测试，我写了这样的一个方法。</p> 
<pre><code class="language-java">@GetMapping("/test2")
    public String test(){
        System.out.println("开始统计公司工资情况");
        return "执行完毕";
    }</code></pre> 
<p>结果如下图所示。 </p> 
<p><img alt="" height="116" src="https://images2.imgbox.com/19/09/CeXdYFU3_o.png" width="344"></p> 
<p>你能够看到，AOP已经成功的增强了我们原来的业务逻辑，这说明我们之后再也不用在我们的业务逻辑中进行这样的统计了，我们可以直接在切面类中进行功能的增强，并且切面类的代码可以复用，提高我们的开发效率。</p> 
<h3 id="3.%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E8%BF%9B%E8%A1%8C%E5%A2%9E%E5%BC%BA">3.使用自定义注解进行增强</h3> 
<p>每次想要增强一个方法我们就得写一个表达式，如果是有通配符的话还好说，但如果我们使用了通配符，那就说明可能对所有的方法进行增强，但有一些方法我不想进行增强，这可怎么办？没关系，我们可以使用自定义的注解来实现。</p> 
<p>我们的表达式不在指向方法了，我们指向注解，哪个方法加了这个注解，哪个方法就需要增强。</p> 
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface MyAspect {
}</code></pre> 
<p>修改表达式。也就是我们在哪里定义的这个注解。</p> 
<pre><code class="language-java">@Pointcut(value = "@annotation(com.example.shardingsphere.aop.MyAspect))")</code></pre> 
<p>之后在我们的controller中的test方法上加上@MyAspect注解。进行测试。结果是一样的。</p> 
<p><img alt="" height="97" src="https://images2.imgbox.com/ae/06/cDdok0G0_o.png" width="265"></p> 
<h2 id="%E5%85%AD%E3%80%81AOP%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86">六、AOP实现的原理</h2> 
<p>这里就简单的说一下，AOP是通过Jdk动态代理或者Cglib动态代理实现的，我们调用我们需要增强的方法，实际上是调用了代理类的方法，由代理类真正的执行我们的业务逻辑。想了解jdk动态代理可以看看我的这篇博客<a href="https://blog.csdn.net/qq_61024956/article/details/137396393?spm=1001.2014.3001.5502" title="【Java】jdk1.8 Java代理模式，Jdk动态代理讲解（非常详细，附带class文件）-CSDN博客">【Java】jdk1.8 Java代理模式，Jdk动态代理讲解（非常详细，附带class文件）-CSDN博客</a></p> 
<p><img alt="" height="741" src="https://images2.imgbox.com/b0/2c/WtAmo5WB_o.png" width="996"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/59867f673a74599079b79f994d039b55/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前端数据可视化基础(折线图)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/40b4fbfca06bce00a429c53d562fa150/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">20240508 每日AI必读资讯</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>