<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>初始Java篇（JavaSE基础语法）（6）（继承和多态）（上） - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/1531b9a14db8a815960c8e9a87e69228/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="初始Java篇（JavaSE基础语法）（6）（继承和多态）（上）">
  <meta property="og:description" content="Java学习篇 个人主页（找往期文章包括但不限于本期文章中不懂的知识点）：我要学编程(ಥ_ಥ)-CSDN博客
目录
继承篇 为什么需要继承？
继承概念
继承的语法
父类成员访问
super关键字
子类构造方法
super和this的比较
再谈初始化
protected 关键字
继承方式 final 关键字
继承与组合
继承篇 为什么需要继承？ Java中使用类对现实世界中实体来进行描述，类经过实例化之后的产物对象，则可以用来表示现实中的实体，但是现实世界错综复杂，事物之间可能会存在一些关联，那在设计程序时就需要考虑。比如：狗和猫，它们都是一个动物。我们现在就可以创建一个猫类和狗类。
class Dog{ public String name; public int age; //构造方法来初始化成员变量 public Dog(String name, int age){ this.name = name; this.age = age; } //来打印成员变量 public void show(){ System.out.println(&#34;name:&#34;&#43;this.name&#43;&#34;age:&#34;&#43;this.age); } } class Cat{ public String name; public int age; //构造方法来初始化成员变量 public Cat(String name, int age){ this.name = name; this.age = age; } //来打印成员变量 public void show(){ System.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-06T14:55:26+08:00">
    <meta property="article:modified_time" content="2024-04-06T14:55:26+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">初始Java篇（JavaSE基础语法）（6）（继承和多态）（上）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" src="https://images2.imgbox.com/31/47/IspupExC_o.jpg">                                                        Java学习篇 </p> 
<blockquote> 
 <p>个人主页（找往期文章包括但不限于本期文章中不懂的知识点）：<a href="https://blog.csdn.net/2301_80854132?type=blog" title="我要学编程(ಥ_ಥ)-CSDN博客">我要学编程(ಥ_ಥ)-CSDN博客</a></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E7%BB%A7%E6%89%BF%E7%AF%87%C2%A0-toc" style="margin-left:0px;"><a href="#%E7%BB%A7%E6%89%BF%E7%AF%87%C2%A0" rel="nofollow">继承篇 </a></p> 
<p id="%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BB%A7%E6%89%BF%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BB%A7%E6%89%BF%EF%BC%9F" rel="nofollow">为什么需要继承？</a></p> 
<p id="%E7%BB%A7%E6%89%BF%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%E7%BB%A7%E6%89%BF%E6%A6%82%E5%BF%B5" rel="nofollow">继承概念</a></p> 
<p id="%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%AD%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%AD%E6%B3%95" rel="nofollow">继承的语法</a></p> 
<p id="%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE-toc" style="margin-left:40px;"><a href="#%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE" rel="nofollow">父类成员访问</a></p> 
<p id="super%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:40px;"><a href="#super%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">super关键字</a></p> 
<p id="%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95" rel="nofollow">子类构造方法</a></p> 
<p id="super%E5%92%8Cthis%E7%9A%84%E6%AF%94%E8%BE%83-toc" style="margin-left:40px;"><a href="#super%E5%92%8Cthis%E7%9A%84%E6%AF%94%E8%BE%83" rel="nofollow">super和this的比较</a></p> 
<p id="%E5%86%8D%E8%B0%88%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#%E5%86%8D%E8%B0%88%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">再谈初始化</a></p> 
<p id="protected%20%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:40px;"><a href="#protected%20%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">protected 关键字</a></p> 
<p id="%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%C2%A0-toc" style="margin-left:40px;"><a href="#%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%C2%A0" rel="nofollow">继承方式 </a></p> 
<p id="final%20%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:40px;"><a href="#final%20%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">final 关键字</a></p> 
<p id="%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88-toc" style="margin-left:40px;"><a href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88" rel="nofollow">继承与组合</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E7%BB%A7%E6%89%BF%E7%AF%87%C2%A0"><span style="color:#fe2c24;">继承篇</span> </h2> 
<h3 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BB%A7%E6%89%BF%EF%BC%9F" style="background-color:transparent;"><span style="color:#38d8f0;">为什么需要继承？</span></h3> 
<p>Java中使用类对现实世界中实体来进行描述，类经过实例化之后的产物对象，则可以用来表示现实中的实体，但是现实世界错综复杂，事物之间可能会存在一些关联，那在设计程序时就需要考虑。比如：狗和猫，它们都是一个动物。我们现在就可以创建一个猫类和狗类。</p> 
<pre><code class="language-java">class Dog{
    public String name;
    public int age;
    //构造方法来初始化成员变量
    public Dog(String name, int age){
        this.name = name;
        this.age = age;
    }
    //来打印成员变量
    public void show(){
        System.out.println("name:"+this.name+"age:"+this.age);
    }
}

class Cat{
    public String name;
    public int age;
    //构造方法来初始化成员变量
    public Cat(String name, int age){
        this.name = name;
        this.age = age;
    }
    //来打印成员变量
    public void show(){
        System.out.println("name:"+this.name+"age:"+age);
    }
}</code></pre> 
<p>有细心的小伙伴会发现，这两个类有很多共同之处：成员变量，show方法。因此Java就提出了继承的概念，把共同的代码放到一起组成一个新的类。 继承是专门用来进行共性抽取，实现代码复用。</p> 
<h3 id="%E7%BB%A7%E6%89%BF%E6%A6%82%E5%BF%B5" style="background-color:transparent;"><span style="color:#38d8f0;">继承概念</span></h3> 
<p>继承(inheritance)机制：是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加新功能，这样产生新的类，称派生类。继承呈现了面向对象程序设计的层次结构， 体现了由简单到复杂的认知过程。继承主要解决的问题是：共性的抽取，实现代码复用。</p> 
<p>我们还是拿上面的例子，狗和猫都是动物，那么我们就可以将共性的内容进行抽取，然后采用继承的思想来达到共用。</p> 
<h3 id="%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%AD%E6%B3%95"><span style="color:#38d8f0;">继承的语法</span></h3> 
<p>在Java中如果要表示类之间的继承关系，需要借助extends关键字，具体如下：</p> 
<pre><code class="language-java">class 子类 extends 父类 {
    // ... 
}</code></pre> 
<p>那么上面的代码就可以改成下面这样：</p> 
<pre><code class="language-java">class Animol{
    //这些成员变量和成员方法都是Dog和Cat共有的，因此放到父类
    public String name;
    public int age;
    public void show(){
        System.out.println("name:"+this.name+"age:"+age);
    }
}
//    子类 extends 父类
class Dog extends Animol{

    //构造方法来初始化成员变量
    public Dog(String name, int age){
        this.name = name;
        this.age = age;
    }
}

//    子类 extends 父类
class Cat extends Animol{

    //构造方法来初始化成员变量
    public Cat(String name, int age){
        this.name = name;
        this.age = age;
    }
}
</code></pre> 
<p>注意：1. 子类会将父类中的成员变量或者成员方法继承到子类中 2. 子类继承父类之后，必须要新添加自己特有的成员，体现出与父类的不同，否则就没有必要继承了（这是在实际应用当中，而我们上面的代码只是演示，因此就不需要满足。如果是在写一个项目就需要满足上面的条件）。</p> 
<h3 id="%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE"><span style="color:#38d8f0;">父类成员访问</span></h3> 
<p>在继承体系中，子类将父类中的方法和字段（成员变量）继承下来了，那在子类中能否直接访问父类中继承下来的成员呢？下面我们就来学习在子类中访问父类成员和方法。</p> 
<pre><code class="language-java">class Animol{
    public String name;
    public int age;
}

class Dog extends Animol{
    public String character;
    public void method() {
        name = "dabai"; // 访问从父类中继承下来的name
        age = 5; // 访问从父类中继承下来的age
        character = "忠诚"; // 访问子类自己的character
    }
}</code></pre> 
<p>但是还有一种情况：当子类的变量名和父类的变量名冲突时，优先访问子类的变量。</p> 
<pre><code class="language-java">class Animol{
    public String name;
    public int age;
}

class Dog extends Animol{
    public String name;
    public void method() {
        name = "dabai"; // 访问子类自己的name
        age = 5; // 访问从父类中继承下来的age
    }
}</code></pre> 
<p>在子类方法中或者通过子类对象访问成员时： 如果访问的成员变量子类中有，优先访问自己的成员变量。 如果访问的成员变量子类中无，则访问父类继承下来的，如果父类也没有定义，则编译报错。 如果访问的成员变量与父类中成员变量同名，则优先访问自己的。 成员变量访问遵循就近原则，自己有优先自己的，如果没有则向父类中找。</p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args){
        Dog dog = new Dog();
        dog.show();
    }
}

class Animol{
    public String name = "dabai";
    public int age = 5;
}

class Dog extends Animol{
    public String name = "huahua";
    public void show(){
        //由于编译器会默认加上this，因此我们写了也没问题，不是因为这个引起的，
        //但是如果我们把这个show方法放到Animol，那么就会打印dabai，
        //因为this是指向当前对象的引用
        System.out.println("name:"+this.name+" age:"+this.age);
    }
}
</code></pre> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/95/c9/FfiRMEuo_o.png" width="1107"></p> 
<p>如果把show方法放到Animol中会不会发生我们所预料的情况呢？ </p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/de/df/sLesfw9G_o.png" width="1200"></p> 
<p>从上面的结果来看我们的猜测是对滴。这样的结果就是this造成的。</p> 
<p>同样成员方法的访问也是如此：成员方法没有同名时，在子类方法中或者通过子类对象访问方法时，则优先访问自己的，自己没有时再到父类中找，如果父类中也没有则报错；反之，通过子类对象访问父类与子类中不同名方法时，优先在子类中找，找到则访问，否则在父类中找，找到则访问，否则编译报错。 通过子类对象访问父类与子类同名方法时，如果父类和子类同名方法的参数列表不同(重载)，根据调用方法适传递的参数选择合适的方法访问，如果没有则报错。<img alt="" height="1200" src="https://images2.imgbox.com/1e/02/5BmZKiAd_o.png" width="1200"></p> 
<p>总结：父类成员的访问就是一句话，先在子类找，子类没找到，就找父类，都没找到就报错。（当父类方法与子类方法形成重载时，通过传递的参数来进行区分，但如果在子类中要访问重写的基类方法，则需要借助super关键字，重写后面在学习） </p> 
<p>但如果子类中存在与父类中相同的成员时，那如何在子类中访问父类相同名称的成员呢？Java就提供了super这个关键字来访问父类成员。</p> 
<h3 id="super%E5%85%B3%E9%94%AE%E5%AD%97"><span style="color:#38d8f0;">super关键字</span></h3> 
<p>由于设计不好，或者因场景需要，子类和父类中可能会存在相同名称的成员，如果要在子类方法中访问父类同名成员时，该如何操作？直接访问是无法做到的，Java提供了super关键字，该关键字主要作用：在子类方法中访问父类的成员。</p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args){
        Dog dog = new Dog();
        dog.show();
    }
}

class Animol{
    public String name = "dabai";
    public int age = 5;
}

class Dog extends Animol{
    public String name = "huahua";
    public void show(){
        System.out.println("name:"+super.name+" age:"+super.age);
    }
}
</code></pre> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/7c/91/LBohIqZz_o.png" width="1093"></p> 
<p>注意：super只能在非静态方法中使用。因为super也是要依赖与对象。  </p> 
<h3 id="%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span style="color:#38d8f0;">子类构造方法</span></h3> 
<p>父子父子，先有父再有子，即：子类对象在构造时，需要先调用父类构造方法，然后执行子类的构造方法。</p> 
<pre><code class="language-java">class Animol{
    public String name = "dabai";
    public int age = 5;
    //因为我们没有写构造方法，编译器默认提供一个不带参数的构造方法
}

class Dog extends Animol{
    public String name = "huahua";
    public Dog(String name, int age){
        //因为我们没有写super（）这个构造方法，
        //编译器会自动把这个方法写到子类构造方法的第一行，就像下面这样
        //super();    //父类的构造方法一定要放到子类构造方法的第一行
        //我们也可以选择把super（）这个方法手动加到第一行
        this.name = name;
        this.age = age;
    }
}</code></pre> 
<p>下面是部分错误的示例： </p> 
<p><img alt="" height="1057" src="https://images2.imgbox.com/2c/0d/0le8p61H_o.png" width="1114"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/ce/1a/8Djd9Gin_o.png" width="1178"></p> 
<p><img alt="" height="1198" src="https://images2.imgbox.com/e8/83/VBR4Ui3i_o.png" width="1200"></p> 
<p>在子类构造方法中，并没有写任何关于父类构造的代码，但是在构造子类对象时，先执行父类的构造方法，然后执行子类的构造方法，是因为：子类对象中成员是有两部分组成的，父类继承下来的以及子类新增加的部分 。父子父子 肯定是先有父再有子，所以在构造子类对象时候 ，先要调用父类的构造方法，将从父类继承下来的成员构造完整 ，然后再调用子类自己的构造方法，将子类自己新增加的成员初始化完整。</p> 
<p>注意： 1. 若父类显式定义无参或者使用默认的构造方法（即没写构造方法），在子类构造方法第一行默认有隐含的super()调用，即调父类构造方法 2. 如果父类构造方法是带有参数的，此时需要用户为子类显式定义构造方法，并在子类构造方法中选择合适的父类构造方法调用，否则编译失败。 3. 在子类构造方法中，super(...)调用父类构造时，必须是子类构造函数中第一条语句。<strong> 4. super(...)只能在子类构造方法中出现一次，并且不能和this同时出现 。</strong></p> 
<h3 id="super%E5%92%8Cthis%E7%9A%84%E6%AF%94%E8%BE%83"><span style="color:#38d8f0;">super和this的比较</span></h3> 
<p>super和this都可以在成员方法中用来访问：成员变量和调用其他的成员函数，都可以作为构造方法的第一条语句，那他们之间有什么区别呢？</p> 
<blockquote> 
 <p>【相同点】</p> 
 <p>1. 都是Java中的关键字。</p> 
 <p>2. 只能在类的非静态方法中使用，用来访问非静态成员方法和字段，因为它们都是需要依赖对象。</p> 
 <p>3. 在构造方法中调用时，必须是构造方法中的第一条语句，并且不能同时存在。</p> 
</blockquote> 
<blockquote> 
 <p>【不同点】</p> 
 <p>1. this是当前对象的引用，当前对象即调用实例方法的对象，super相当于是子类对象中从父类继承下来部分成员的引用。</p> 
 <p>2. 在非静态成员方法中，this用来访问本类的方法和属性，super用来访问父类继承下来的方法和属性。</p> 
 <p>3. 在构造方法中：this(...)用于调用本类构造方法，super(...)用于调用父类构造方法，两种调用不能同时在构造方法中出现。</p> 
 <p>4. 构造方法中一定会存在super(...)的调用，用户没有写编译器也会增加（有子类存在的情况下），但是this(...)用户不写则没有。</p> 
</blockquote> 
<p>对this（）与super（）不能同时出现在构造方法中的<strong>最简单</strong>解释：假设我们现在有一个父类和一个子类，我们想要在子类的构造方法中调用this（），首先就得调用super（），把super（）放在第一行，而this（）也需要放在第一行，因此就会冲突！换种情况，先调用super（）的话，就不满足，this（）在第一行了，因此又冲突了！由上可知：super（）和this（）不能同时出现在构造方法中。</p> 
<h3 id="%E5%86%8D%E8%B0%88%E5%88%9D%E5%A7%8B%E5%8C%96"><span style="color:#38d8f0;">再谈初始化</span></h3> 
<p>还记得我们之前学过的代码块吗？我们简单回顾一下重要的代码块：实例代码块和静态代码块。在没有继承关系时的执行顺序是：静态代码块执行 ——&gt;实例代码块执行——&gt;构造方法执行 。</p> 
<p>静态代码块先执行，并且只执行一次，在类加载阶段执行；当有对象创建时，才会执行实例代码块，实例代码块执行完成后，最后构造方法才执行。</p> 
<p>当父类和子类同时存在时，该怎么执行呢？</p> 
<p>1、父类静态代码块优先于子类静态代码块执行，且是最早执行 2、父类实例代码块和父类构造方法紧接着执行 3、子类的实例代码块和子类构造方法紧接着再执行 4、第二次实例化子类对象时，父类和子类的静态代码块都将不会再执行。</p> 
<p>下面我们就用代码来验证一下：</p> 
<pre><code class="language-java">public class Test{
       public static void main(String[] args){
           Dog dog = new Dog();
       }
}

class Animol{
    public String name;
    public int age;
    public Animol(String name, int age){
        this.name = name;
        this.age = age;
        System.out.println("父类构造方法");
    }
    {
        System.out.println("父类实例代码块");
    }
    static{
        System.out.println("父类静态代码块");
    }

}

class Dog  extends Animol{
    public String character;
    public Dog(){
        super("huahua",5);
        System.out.println("子类的构造方法");
    }
    {
        System.out.println("子类的实例代码块");
    }
    static{
        System.out.println("子类的静态代码块");
    }
}</code></pre> 
<p>输出结果：<img alt="" height="281" src="https://images2.imgbox.com/6a/65/wh40O2mP_o.png" width="1058"></p> 
<p>和我们的结论是一样的。 </p> 
<h3 id="protected%20%E5%85%B3%E9%94%AE%E5%AD%97" style="background-color:transparent;"><span style="color:#38d8f0;">protected 关键字</span></h3> 
<p>在学习类和对象时，为了实现封装特性，Java中引入了访问限定符，主要限定：类或者类中成员能否在类外或者其他包中被访问。现在我们就来学习protected这个关键字，其实也就是学习<strong>不同包中的子类</strong>，这个理解就是有两个类，一个是子类，一个是父类，而这两个类在不同的包中。这就是不同包中的子类。</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/8a/af/a8TAeUbn_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/2a/91/59D8V9sO_o.png" width="1200"></p> 
<p>注意：在父类中被private修饰的成员变量或者方法只是不能被子类访问，但是继承还是没问题的。</p> 
<h3 id="%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%C2%A0"><span style="color:#38d8f0;">继承方式</span> </h3> 
<p>在现实生活中，事物之间的关系是非常复杂，灵活多样。比如下面这样：</p> 
<p><img alt="" height="594" src="https://images2.imgbox.com/63/a8/kYGQ9bEl_o.png" width="1200"></p> 
<p> 但在Java中只支持以下几种继承方式：<img alt="" height="1128" src="https://images2.imgbox.com/28/eb/JGexm89K_o.png" width="1200"></p> 
<p>一般我们不希望出现超过三层的继承关系. 如果继承层次太多, 就需要考虑对代码进行重构了. 如果想从语法上进行限制继承, 就可以使用 final 关键 。</p> 
<h3 id="final%20%E5%85%B3%E9%94%AE%E5%AD%97"><span style="color:#38d8f0;">final 关键字</span></h3> 
<p>final关键可以用来修饰变量、成员方法以及类。类似我们在C语言中学习的const。</p> 
<p>1. 修饰变量或字段，表示常量(即不能修改）。</p> 
<p>2. 修饰类：表示此类不能被继承。</p> 
<p><img alt="" height="1131" src="https://images2.imgbox.com/85/09/AkU4pKOx_o.png" width="1200"></p> 
<p>我们平时是用的 String 字符串类, 就是用 final 修饰的, 不能被继承。</p> 
<p>3. 修饰方法：表示该方法不能被重写(后序介绍) 。</p> 
<h3 id="%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88"><span style="color:#38d8f0;">继承与组合</span></h3> 
<p>和继承类似, 组合也是一种表达类之间关系的方式, 也是能够达到代码重用的效果。组合并没有涉及到特殊的语法 (诸如 extends 这样的关键字), 仅仅是将一个类的实例作为另外一个类的字段。 继承表示对象之间是is-a的关系，比如：狗是动物，猫是动物。组合表示对象之间是has-a的关系，比如：汽车和其轮胎、发动机、方向盘、车载系统等的关系就应该是组合，因为汽车是由这些部件组成的。汽车中有这些东西。</p> 
<pre><code class="language-java">// 轮胎类
class Tire{
    // ...
}
// 发动机类
class Engine{
    // ...
}
// 车载系统类
class VehicleSystem{
    // ...
}
//汽车有轮胎，发动机，车载系统（组成）
class Car{
    private Tire tire; // 可以复用轮胎中的属性和方法
    private Engine engine; // 可以复用发动机中的属性和方法
    private VehicleSystem vs; // 可以复用车载系统中的属性和方法
    // ...
}
// 奔驰是汽车(继承)
class Benz extends Car{
    // 将汽车中包含的：轮胎、发送机、车载系统全部继承下来
}</code></pre> 
<p>组合和继承都可以实现代码复用，应该使用继承还是组合，需要根据应用场景来选择，一般建议：能用组合尽量用组合。</p> 
<p>好啦！本期Java继承篇的内容就已经学习完了。下一期我们再一起学习吧！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f140989a10519fba5ae5ccbdc61102e5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构之顺序表的相关知识点及应用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a65403658174467bbe24f1e44649774e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端AES加密，后端解密，有效防止数据外泄_前端加密后端解密</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>