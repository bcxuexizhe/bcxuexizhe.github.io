<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>动态规划----股票买卖问题（详解） - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/d1b4049547a0ebdc9e4745c35010fa0d/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="动态规划----股票买卖问题（详解）">
  <meta property="og:description" content="目录
一.买卖股票的最佳时机：
二.买卖股票的最佳时机含冷冻期：
三.买卖股票的最佳时期含⼿续费：
四.买卖股票的最佳时机III: 五.买卖股票的最佳时机IV:
买卖股票的最佳时机问题介绍：动态规划买卖股票的最佳时机是一个经典的算法问题。该问题的目标是在给定的股票价格数组中，找到最大的利润，即最佳的买入和卖出时间，使得买入时间早于卖出时间。
下面我们通过一些例题，来解决这一类动态规划的问题：
一.买卖股票的最佳时机： 题目链接：121. 买卖股票的最佳时机 - 力扣（LeetCode）题目描述： 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
①.动态规划解法：
一.状态表示dp[ i ][ j ]：下标为 i 这一天结束的时候，手上持股状态为 j 时，我们持有的最大利润。这里我们定义状态 j （两种情况）分别为：0 买入状态1 可交易状态二.状态转移方程：dp[ i ][ 0 ] = Math.max( dp[ i - 1 ][ 0 ], -prices[ i ]) ; ①.在前面一天已经是买入状态，今天选择什么也不干，今天结束后，是买入状态。②.前面是可交易状态，今天选择买入，则今天结束后是买入状态，这里注意不是dp[ i - 1][ 1 ] - prices[ i ];因为只能交易一次，如果今天选择买入，那后面一定要卖出（这算一次交易),此时才可能有最大利润。则前面不能有交易，利润为0.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-12T23:53:12+08:00">
    <meta property="article:modified_time" content="2024-05-12T23:53:12+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">动态规划----股票买卖问题（详解）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%EF%BC%9A" rel="nofollow">一.买卖股票的最佳时机：</a></p> 
<p id="%E4%BA%8C.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F%EF%BC%9A" rel="nofollow">二.买卖股票的最佳时机含冷冻期：</a></p> 
<p id="%E4%B8%89.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%9F%E5%90%AB%E2%BC%BF%E7%BB%AD%E8%B4%B9%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%9F%E5%90%AB%E2%BC%BF%E7%BB%AD%E8%B4%B9%EF%BC%9A" rel="nofollow">三.买卖股票的最佳时期含⼿续费：</a></p> 
<p id="%E5%9B%9B.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII%3A%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%9B%9B.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII%3A%C2%A0" rel="nofollow">四.买卖股票的最佳时机III: </a></p> 
<p id="%E4%BA%94.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV%3A-toc" style="margin-left:0px;"><a href="#%E4%BA%94.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV%3A" rel="nofollow">五.买卖股票的最佳时机IV:</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p><strong>买卖股票的最佳时机问题介绍</strong>：动态规划买卖股票的最佳时机是一个经典的算法问题。该问题的目标是在给定的股票价格数组中，找到最大的利润，即最佳的买入和卖出时间，使得买入时间早于卖出时间。</p> 
<p>下面我们通过一些例题，来解决这一类动态规划的问题：</p> 
<h2 id="%E4%B8%80.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%EF%BC%9A">一.买卖股票的最佳时机：</h2> 
<ul><li>题目链接：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/" rel="nofollow" title="121. 买卖股票的最佳时机 - 力扣（LeetCode）">121. 买卖股票的最佳时机 - 力扣（LeetCode）</a></li><li>题目描述： <p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p> <p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p> <p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p> </li></ul> 
<p><img alt="" height="181" src="https://images2.imgbox.com/51/a4/ZzouI6OW_o.png" width="570"></p> 
<p><strong>①.动态规划解法：</strong></p> 
<blockquote> 
 <ul><li><strong><span style="background-color:#ff9900;">一.状态表示dp[ i ][ j ]：</span></strong>下标为 <code>i</code> 这一天结束的时候，手上持股状态为 <code>j</code> 时，我们持有的最大利润。这里我们定义状态 j （两种情况）分别为：</li><li>0 <strong><span style="background-color:#ffd900;">买入状态</span></strong></li><li>1 <strong><span style="background-color:#ffd900;">可交易状态</span></strong></li><li><strong><span style="background-color:#ff9900;">二.状态转移方程：</span></strong></li><li><strong><span style="background-color:#ffd900;">dp[ i ][ 0 ] = Math.max( dp[ i - 1 ][ 0 ], -prices[ i ]) ; </span></strong>①.在前面一天已经是买入状态，今天选择什么也不干，今天结束后，是买入状态。②.前面是可交易状态，今天选择买入，则今天结束后是买入状态，这里注意不是dp[ i - 1][ 1 ] - prices[ i ];因为只能交易一次，如果今天选择买入，那后面一定要卖出（这算一次交易),此时才可能有最大利润。则前面不能有交易，利润为0.</li><li><strong><span style="background-color:#ffd900;">dp[ i ][ 1 ] = Math.max( dp[ i - 1][ 1 ],dp[ i - 1][ 0 ] + prices[ i ]);</span></strong>①.前面一天是可交易状态，今天选择什么也不干，今天结束后是可交易状态。②.前面一天是买入状态，今天选择卖出，今天结束后是可交易状态。</li><li><strong><span style="background-color:#ff9900;">三.初始化</span></strong>：根据状态表示：</li><li><strong><span style="background-color:#ffd900;">dp[ 0 ][ 0 ] = - prices[ 0 ];</span></strong>第一天选择买入，此时利润为 - prices[ 0 ]</li><li><strong><span style="background-color:#ffd900;">dp[ 0 ][ 1 ] = 0;</span></strong>第一天选择什么也不干或则交易一次，此时的利润为0;</li><li><strong><span style="background-color:#ff9900;">四.填表顺序</span></strong>：根据状态转移方程，从左往右，从上往下填写.</li><li><strong><span style="background-color:#ff9900;">五.返回值</span></strong>：dp[ n - 1 ][ 1 ];n为prices数组的长度,最后一天结束后，是可交易状态，此时为最大利润.</li></ul> 
 <p><strong>各个状态关系图：</strong></p> 
 <p><img alt="" height="294" src="https://images2.imgbox.com/35/72/EIYKjidr_o.png" width="619"></p> 
 <p><strong>代码详解：</strong></p> 
 <pre><code class="language-java">class Solution {
         // 1. 创建 dp 表
        // 2. 初始化
       // 3. 填表
       // 4. 返回值
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[][] dp = new int[n][2];
        //初始化
        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        for(int i = 1;i &lt; n;i++){
            //注意这里不是dp[i - 1][1] - prices[i];
            dp[i][0] = Math.max(dp[i - 1][0], - prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1],dp[i - 1][0] + prices[i]);
        }
        //返回值
        return dp[n - 1][1];
    }
}</code></pre> 
</blockquote> 
<p style="text-align:center;"><strong>②.暴力解法（相对简单这里给出解题过程）：</strong> <img alt="" height="346" src="https://images2.imgbox.com/c8/ac/N4ZIQRo3_o.gif" width="451"></p> 
<p><strong>代码详解：</strong></p> 
<pre><code class="language-java">class Solution {
    public int maxProfit(int[] prices) {
        int cost = Integer.MAX_VALUE;
        int profit = 0;
        for(int price : prices){
            cost = Math.min(cost,price);
            profit = Math.max(profit,price - cost);
        }
        return profit;
    }
}</code></pre> 
<p><strong>运行结果：</strong></p> 
<p><img alt="" height="471" src="https://images2.imgbox.com/e7/20/EJhFXsZE_o.png" width="1200"></p> 
<h2 id="%E4%BA%8C.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F%EF%BC%9A">二.买卖股票的最佳时机含冷冻期：</h2> 
<ul><li>题目链接：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/" rel="nofollow" title="309. 买卖股票的最佳时机含冷冻期 - 力扣（LeetCode）">309. 买卖股票的最佳时机含冷冻期 - 力扣（LeetCode）</a></li><li>问题描述： <p>给定一个整数数组<code>prices</code>，其中第 <em> </em><code>prices[i]</code> 表示第 <code><em>i</em></code> 天的股票价格 。​</p> <p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p> </li><li> <p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p> </li><li> <p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p> </li></ul> 
<p><img alt="" height="191" src="https://images2.imgbox.com/a7/a6/4BbMt8vM_o.png" width="518"></p> 
<blockquote> 
 <p><strong>动态规划解法：</strong></p> 
 <p><strong><span style="background-color:#ff9900;">一.状态表示</span></strong>：<strong>dp[ i ][ j ]</strong>:由于有「买⼊」「可交易」「冷冻期」三个状态，因此我们可以选择⽤三个数组，其中：</p> 
 <ul><li><strong><span style="background-color:#ffd900;">dp[i][0] 表⽰：第 i 天结束后，处于「买⼊」状态，此时的最⼤利润；</span></strong></li><li><strong><span style="background-color:#ffd900;">dp[i][1] 表⽰：第 i 天结束后，处于「可交易」状态，此时的最⼤利润；</span></strong></li><li><strong><span style="background-color:#ffd900;">dp[i][2] 表⽰：第 i 天结束后，处于「冷冻期」状态，此时的最⼤利润</span></strong></li></ul> 
 <p><strong><span style="background-color:#ff9900;">二.状态转移方程：</span></strong></p> 
 <ul><li><strong><span style="background-color:#ffd900;">dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);</span></strong> ①.前一天是买入状态，今天啥也不做，今天结束后是买入状态②.前面一天是可交易状态，今天选择买入，今天结束后是买入状态。</li><li><strong><span style="background-color:#ffd900;">dp[i][1] = max(dp[i - 1][1], dp[i - 1][2]);</span></strong> ①.前面一天是可交易状态，今天啥也不干，今天结束后是可交易状态②.前面一天是冷冻期，今天啥也不干，今天过后是可交易状态</li><li><strong><span style="background-color:#ffd900;">dp[i][2] = dp[i - 1][0] + prices[i]；</span></strong>前面一天是买入状态，今天选择卖出，今天过后是冷冻期</li></ul> 
 <p><strong><span style="background-color:#ff9900;">三.初始化：</span></strong></p> 
 <p><strong>dp[0][0] = - prices[0] ；   dp[0][1] = 0 ；    dp[0][2] = 0;</strong></p> 
 <p><strong><span style="background-color:#ff9900;">四.填表顺序</span>：从左往右，从上往下，依次填写三个表</strong></p> 
 <p><strong><span style="background-color:#ff9900;">五.返回值</span>：状态转移方程三者的最大值：</strong></p> 
 <p><strong><span style="background-color:#ffd900;"> </span></strong><strong><span style="background-color:#ffd900;">max(dp[n - 1][1], dp[n - 1] [2])</span>;dp[n - 1][0]不可能是最大值，这里不用考虑进去（如果考虑进去了也没关系）</strong></p> 
 <p></p> 
 <p><strong>各个状态关系图：</strong></p> 
 <p><img alt="" height="379" src="https://images2.imgbox.com/50/d9/0KqhvEqK_o.png" width="572"></p> 
 <p><strong><span style="background-color:#ffd900;">代码详解</span>：</strong></p> 
 <pre><code class="language-java">class Solution {
      // 1. 创建 dp 表
        // 2. 初始化
       // 3. 填表
       // 4. 返回值
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[][] dp = new int[n][3];
        dp[0][0] = -prices[0];
        for(int i = 1;i &lt; n;i++){
            dp[i][0] = Math.max(dp[i - 1][0],dp[i - 1][1] - prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1],dp[i - 1][2]);
            dp[i][2] = dp[i - 1][0] + prices[i];
        }
        return Math.max(dp[n - 1][1],dp[n - 1][2]);
    }
}</code></pre> 
</blockquote> 
<p><strong>运行结果： </strong></p> 
<p><img alt="" height="382" src="https://images2.imgbox.com/05/3d/Jxivndfw_o.png" width="1200"></p> 
<h2 id="%E4%B8%89.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%9F%E5%90%AB%E2%BC%BF%E7%BB%AD%E8%B4%B9%EF%BC%9A">三.买卖股票的最佳时期含⼿续费：</h2> 
<p>题目链接：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/" rel="nofollow" title="714. 买卖股票的最佳时机含手续费 - 力扣（LeetCode）">714. 买卖股票的最佳时机含手续费 - 力扣（LeetCode）</a></p> 
<p>题目描述：</p> 
<p>给定一个整数数组 <code>prices</code>，其中 <code>prices[i]</code>表示第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。</p> 
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p> 
<p>返回获得利润的最大值。</p> 
<p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p> 
<p><img alt="" height="359" src="https://images2.imgbox.com/78/57/t4tPCQJy_o.png" width="521"></p> 
<blockquote> 
 <p><strong> 动态规划解法：</strong></p> 
 <p><strong><span style="background-color:#ff9900;">一.状态表示：</span></strong>由于有「买⼊」「可交易」两个状态，因此我们可以选择⽤两个数组来定义我们的状态（或则一个二维数组也行），其中：</p> 
 <ul><li><strong><span style="background-color:#ffd900;">f[i] 表⽰：第 i 天结束后，处于「买⼊」状态，此时的最⼤利润；</span></strong></li><li><strong><span style="background-color:#ffd900;">g[i] 表⽰：第 i 天结束后，处于「卖出」状态，此时的最⼤利润.</span></strong></li></ul> 
 <p><strong><span style="background-color:#ff9900;">二.状态转移方程 ：</span></strong>我们选择在「卖出」的时候，⽀付这个⼿续费，那么在「买⼊」的时候，就不⽤再考虑⼿续费的问题（完成一次交易支付手续费）：</p> 
 <ul><li><strong><span style="background-color:#ffd900;">f[i] = max(f[i - 1], g[i - 1] - prices[i]) </span></strong>；①.在 i - 1 天「持有」股票，第 i 天啥也不⼲。此时最⼤收益为 f[i - 1] ；②.在 i - 1 天的时候「没有」股票，在第 i 天买⼊股票。此时最⼤收益为 g[i - 1] - prices[i]) ；</li><li><strong><span style="background-color:#ffd900;">g[i] = max(g[i - 1], f[i - 1] + prices[i] - fee);</span></strong>①.在 i - 1 天「持有」股票，但是在第 i 天将股票卖出。此时最⼤收益为： f[i - 1] + prices[i] - fee) ，<strong><span style="background-color:#ffd900;">记得⼿续费</span></strong>；②.在 i - 1 天「没有」股票，然后第 i 天啥也不⼲。此时最⼤收益为： g[i - 1]</li></ul> 
 <p><strong><span style="background-color:#ff9900;">三.初始化：</span></strong>由于需要⽤到前⾯的状态，因此需要初始化第⼀个位置:</p> 
 <ul><li><strong><span style="background-color:#ffd900;">对于 f[0] ，此时处于「买⼊」状态，因此 f[0] = -prices[0]</span></strong></li><li><strong>对于 g[0] ，此时处于「没有股票」状态，啥也不⼲即可获得最⼤收益，因此 g[0] = 0 </strong></li></ul> 
 <p><strong><span style="background-color:#ff9900;">四.填表顺序：</span></strong><strong>从左到右两个表一起填</strong></p> 
 <p><strong><span style="background-color:#ff9900;">五.返回值：</span>应该返回「卖出」状态下，最后⼀天的最⼤值收益： g[n - 1]</strong> </p> 
 <p><img alt="" height="281" src="https://images2.imgbox.com/50/95/Z6QDGo2r_o.png" width="821"></p> 
 <p><strong>代码详解</strong>：</p> 
 <pre><code class="language-java">class Solution {
    public int maxProfit(int[] prices, int fee) {
        int n = prices.length;
        int[] f = new int[n];
        int[] g = new int[n];
        f[0] = -prices[0];
        for(int i = 1;i &lt; n;i++){
            f[i] = Math.max(f[i - 1],g[i - 1] - prices[i]);
            g[i] = Math.max(g[i - 1],f[i - 1] + prices[i] - fee);
        }
        return Math.max(f[n - 1],g[n - 1]);
    }
}</code></pre> 
</blockquote> 
<p><strong>运行结果：</strong></p> 
<p><img alt="" height="374" src="https://images2.imgbox.com/b0/34/YJ0JRr7f_o.png" width="1200"></p> 
<h2 id="%E5%9B%9B.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII%3A%C2%A0">四.买卖股票的最佳时机III: </h2> 
<p>题目链接：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/" rel="nofollow" title="123. 买卖股票的最佳时机 III - 力扣（LeetCode）">123. 买卖股票的最佳时机 III - 力扣（LeetCode）</a></p> 
<p>题目描述：</p> 
<p>给定一个数组，它的第<em> </em><code>i</code> 个元素是一支给定的股票在第 <code>i</code><em> </em>天的价格。</p> 
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔 </strong>交易。</p> 
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p> 
<p><img alt="" height="406" src="https://images2.imgbox.com/a8/b5/7sDtXLCS_o.png" width="550"></p> 
<blockquote> 
 <p><strong>动态规划解法：</strong></p> 
 <p><strong><span style="background-color:#ff9900;">一.状态表示：</span></strong>由于有「买⼊」「可交易」两个状态，因此我们可以选择⽤两个数组。但是这道题⾥⾯还有交易次 数的限制，因此我们还需要再加上⼀维，⽤来表⽰交易次数。其中：</p> 
 <ul><li><strong><span style="background-color:#ffd900;">f[i][j] 表⽰：第 i 天结束后，完成了 j 次交易，处于「买⼊」状态，此时的最⼤利 润；</span></strong></li><li><strong><span style="background-color:#ffd900;">g[i][j] 表⽰：第 i 天结束后，完成了 j 次交易，处于「卖出」状态，此时的最⼤利 润。</span></strong></li></ul> 
 <p><strong><span style="background-color:#ff9900;">二.状态转移方程：</span></strong></p> 
 <ul><li><strong><span style="background-color:#ffd900;">f[i][j] = max(f[i - 1][j], g[i - 1][j] - prices[i])</span></strong>;①.在 i - 1 天的时候，交易了 j 次，处于「买⼊」状态，第 i 天啥也不⼲即可。此时最 ⼤利润为： f[i - 1][j] ；②.在 i - 1 天的时候，交易了 j 次，处于「卖出」状态，第 i 天的时候把股票买了。此 时的最⼤利润为： g[i - 1][j] - prices[i] 。</li><li><strong><span style="background-color:#ffd900;">g[i][j] = g[i - 1][j];</span></strong></li></ul> 
 <p><strong>      <span style="background-color:#ffd900;">if(j &gt; 0) g[i][j] = max(g[i][j], f[i - 1][j - 1] + prices[i]);  </span></strong></p> 
 <p>     ①.在 i - 1 天的时候，交易了 j 次，处于「卖出」状态，第 i 天啥也不⼲即可。此时的 最             ⼤利润为： g[i - 1][j] ；</p> 
 <p>    ②.在 i - 1 天的时候，交易了 j - 1 次，处于「买⼊」状态，第 i 天把股票卖了，然 后就完          成了 j ⽐交易。此时的最⼤利润为： f[i - 1][j - 1] + prices[i] 。但 是这个状态不⼀定存              在，要先判断⼀下。</p> 
 <p><strong><span style="background-color:#ff9900;">三.初始化：</span></strong></p> 
 <ul><li><strong><span style="background-color:#ffd900;">当处于第 0 天的时候，只能处于「买⼊过⼀次」的状态，此时的收益为 -prices[0] ，因 此 f[0][0] = - prices[0] 。</span></strong></li><li><strong><span style="background-color:#ffd900;">为了取 max 的时候，⼀些不存在的状态「起不到⼲扰」的作⽤，我们统统将它们初始化为 - INF （⽤ INT_MIN 在计算过程中会有「溢出」的⻛险，这⾥ INF 折半取 0x3f3f3f3f ，⾜够⼩即可）</span></strong></li></ul> 
 <p><strong><span style="background-color:#ff9900;">四.填表顺序：</span>从「上往下填」每⼀⾏，每⼀⾏「从左往右」，两个表「⼀起填」。</strong></p> 
 <p><strong><span style="background-color:#ff9900;">五.返回值：</span>返回处于「卖出状态」的最⼤值，但是我们也「不知道是交易了⼏次」，因此返回 g 表最后⼀⾏ 的最⼤值。</strong></p> 
 <p><img alt="" height="361" src="https://images2.imgbox.com/1e/16/LZGQejKz_o.png" width="872"></p> 
 <p><strong>代码详解：</strong></p> 
 <pre><code class="language-java">class Solution {
    static int INF = -0x3f3f3f3f;
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[][] f = new int[n][3];
        int[][] g = new int[n][3];
        //1.
        f[0][0] = -prices[0];
        for(int i = 1;i &lt; f[0].length;i++){
            f[0][i] = INF;
        }
        for(int j = 1;j &lt; g[0].length;j++){
            g[0][j] = INF;//Integer.MIN_VALUE/2
        }
        
        //2.
        for(int i = 1;i &lt; n;i++){
            for(int j = 0;j &lt; 3;j++){
                f[i][j] = Math.max(f[i - 1][j],g[i - 1][j] - prices[i]);
                g[i][j] = g[i - 1][j];
                if(j &gt; 0){
                    g[i][j] = Math.max(g[i][j],f[i - 1][j - 1] + prices[i]);
                }
            }
        }
        int res = Integer.MIN_VALUE;
        for(int j = 0;j &lt; 3;j++){ 
           res = Math.max(res,g[n - 1][j]);
        }
        return res;
    }
}</code></pre> 
</blockquote> 
<p><strong>运行结果：</strong></p> 
<p><img alt="" height="375" src="https://images2.imgbox.com/bf/19/z5spTm92_o.png" width="1200"></p> 
<h2 id="%E4%BA%94.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV%3A"><strong>五.买卖股票的最佳时机IV:</strong></h2> 
<p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/" rel="nofollow" title="188. 买卖股票的最佳时机 IV - 力扣（LeetCode）">188. 买卖股票的最佳时机 IV - 力扣（LeetCode）</a></p> 
<p><strong>题目描述：</strong></p> 
<p>给你一个整数数组 <code>prices</code> 和一个整数 <code>k</code> ，其中 <code>prices[i]</code> 是某支给定的股票在第 <code>i</code><em> </em>天的价格。</p> 
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code> 笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code> 次。</p> 
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p> 
<p><img alt="" height="324" src="https://images2.imgbox.com/d8/fe/j5DayNq9_o.png" width="517"></p> 
<blockquote> 
 <p><strong>动态规划解法：</strong></p> 
 <p><strong><span style="background-color:#ff9900;">一.状态表示：</span></strong>为了更加清晰的区分「买⼊」和「卖出」，我们换成「有股票」和「⽆股票」两个状态：</p> 
 <ul><li><strong><span style="background-color:#ffd900;">f[i][j] 表⽰：第 i 天结束后，完成了 j 笔交易，此时处于「有股票」状态的最⼤收益；</span></strong></li><li>g[i][j] 表⽰：第 i 天结束后，完成了 j 笔交易，此时处于「⽆股票」状态的最⼤收益</li></ul> 
 <p><strong><span style="background-color:#ff9900;">二.状态转移方程：</span></strong></p> 
 <ul><li><span style="background-color:#ffd900;">f</span><strong><span style="background-color:#ffd900;">[i][j] = max(f[i - 1][j], g[i - 1][j] - prices[i]);</span></strong>①.在 i - 1 天的时候，⼿⾥「有股票」，并且交易了 j 次。在第 i 天的时候，啥也不⼲。 此时的收益为 f[i - 1][j] ；②.在 i - 1 天的时候，⼿⾥「没有股票」，并且交易了 j 次。在第 i 天的时候，买了股 票。那么 i 天结束之后，我们就有股票了。此时的收益为 g[i - 1][j] - prices[i];</li><li><strong><span style="background-color:#ffd900;">g[i][j] = max(g[i - 1][j], f[i - 1][j - 1] + prices[i]);</span></strong>①.在 i - 1 天的时候，⼿⾥「没有股票」，并且交易了 j 次。在第 i 天的时候，啥也不 ⼲。此时的收益为 g[i - 1][j] ；②.在 i - 1 天的时候，⼿⾥「有股票」，并且交易了 j - 1 次。在第 i 天的时候，把 股票卖了。那么 i 天结束之后，我们就交易了 j 次。此时的收益为 f[i - 1][j - 1] + prices[i] ；</li></ul> 
 <p><strong><span style="background-color:#ff9900;">三.初始化：</span></strong></p> 
 <ul><li><strong><span style="background-color:#ffd900;">当处于第 0 天的时候，只能处于「买⼊过⼀次」的状态，此时的收益为 -prices[0] ，因 此 f[0][0] = - prices[0]</span></strong></li><li><strong><span style="background-color:#ffd900;">为了取 max 的时候，⼀些不存在的状态「起不到⼲扰」的作⽤，我们统统将它们初始化为 - INF （⽤ INT_MIN 在计算过程中会有「溢出」的⻛险，这⾥ INF 折半取 0x3f3f3f3f ，⾜够⼩即可）</span></strong></li></ul> 
 <p><strong><span style="background-color:#ff9900;">四.填表顺序：</span></strong>从上往下填每⼀⾏，每⼀⾏从左往右，两个表⼀起填。</p> 
 <p><strong><span style="background-color:#ff9900;">五.返回值：</span></strong>返回处于卖出状态的最⼤值，但是我们也不知道是交易了⼏次，因此返回 g 表最后⼀⾏的最⼤ 值</p> 
 <p><strong>代码详解：</strong></p> 
 <pre><code class="language-java">class Solution {
    static int INF = -0x3f3f3f3f;
    public int maxProfit(int k, int[] prices) {
        int n = prices.length;
        int[][] f = new int[n][k + 1];
        int[][] g = new int[n][k + 1];
        //1.
        f[0][0] = -prices[0];
        for(int i = 1;i &lt; f[0].length;i++){
            f[0][i] = INF;//-&gt;防止越界g[i - 1][j] - prices[i];
        }
        for(int j = 1;j &lt; g[0].length;j++){
            g[0][j] = INF;//Integer.MIN_VALUE/2
        }
        
        //2.
        for(int i = 1;i &lt; n;i++){
            for(int j = 0;j &lt; k + 1;j++){
                f[i][j] = Math.max(f[i - 1][j],g[i - 1][j] - prices[i]);
                g[i][j] = g[i - 1][j];
                if(j &gt; 0){
                    g[i][j] = Math.max(g[i][j],f[i - 1][j - 1] + prices[i]);
                }
            }
        }
        int res = Integer.MIN_VALUE;
        for(int j = 0;j &lt; k + 1;j++){ 
           res = Math.max(res,g[n - 1][j]);
        }
        return res;
    }
}</code></pre> 
</blockquote> 
<p><strong>运行结果：</strong></p> 
<p><img alt="" height="374" src="https://images2.imgbox.com/85/ab/wqZJZpvN_o.png" width="1200"></p> 
<p> <strong>结语：</strong> <strong>写博客不仅仅是为了分享学习经历，同时这也有利于我巩固知识点，总结该知识点，由于作者水平有限，对文章有任何问题的还请指出，接受大家的批评，让我改进。同时也希望读者们不吝啬你们的点赞+收藏+关注，你们的鼓励是我创作的最大动力！</strong></p> 
<p style="text-align:center;"><strong><img alt="" height="295" src="https://images2.imgbox.com/cc/af/1qk1jfuF_o.jpg" width="295"></strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dad8984eac2d6201502435e9e1024726/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【一步一步了解Java系列】：了解Java与C语言的运算符的“大同小异”</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2e96e22a1585929ee6682d55a42d3220/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">高校普法|基于SSM＋vue的高校普法系统的设计与实现(源码&#43;数据库&#43;文档)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>