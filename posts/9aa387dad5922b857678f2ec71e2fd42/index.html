<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringBootWeb 篇-深入了解请求响应（服务端接收不同类型的请求参数的方式） - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/9aa387dad5922b857678f2ec71e2fd42/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="SpringBootWeb 篇-深入了解请求响应（服务端接收不同类型的请求参数的方式）">
  <meta property="og:description" content="🔥博客主页： 【小扳_-CSDN博客】
❤感谢大家点赞👍收藏⭐评论✍
文章目录
1.0 请求响应概述
1.1 简单参数
1.2 实体参数
2.3 数组集合参数
2.4 日期参数
2.5 json 参数
2.6 路径参数
3.0 完整代码
1.0 请求响应概述 当客户端发送不同的请求参数到服务端，服务端就需要进行不同的方法方式来接收请求参数。一般的请求参数的类型包括：简单参数、实体参数、数组集合参数、日期参数、json 参数、路径参数。
1.1 简单参数 客户端无论通过 get 或者是 post 方式来发送请求，对应发送简单请求参数来说，是通过键值对的方式来发送到服务端。
1）方法一：服务端可以用到 HttpServletRequest 类对象来接收简单参数请求，再通过对象名.getParam(&#34;请求参数名&#34;) 方法来获取值。
代码演示：
//接收简单参数方法一:使用 HttpServletRequest 类来获取客户端发送过来的请求参数 //通过对象名.get //这里注解为:请求路径 @RequestMapping(&#34;/simpleParam&#34;) public String simpleParam(HttpServletRequest request){ String name = request.getParameter(&#34;name&#34;); String age = request.getParameter(&#34;age&#34;); 发送的请求参数：
通过 GET 方式来发送请求，请求参数有两个 name 和 age，send 发送给服务端后，服务端给客户端返回 &#34;OK&#34; 。
服务器输出的结果：
服务端成功接收请求参数且返回数据到客户端。
2）方法二：可以直接用一一对应的方式来接收请求参数，必须要注意保持请求的参数名与服务端需要接收的变量名保持一致。
代码演示：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-11T16:30:51+08:00">
    <meta property="article:modified_time" content="2024-05-11T16:30:51+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringBootWeb 篇-深入了解请求响应（服务端接收不同类型的请求参数的方式）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>🔥博客主页： 【<strong><a href="https://blog.csdn.net/Tingfeng__?spm=1000.2115.3001.5343" title="小扳_-CSDN博客】">小扳_-CSDN博客】</a></strong><br> ❤感谢大家点赞👍收藏⭐评论✍</strong></p> 
</blockquote> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/1b/eb/PoZj8fNI_o.jpg" width="400"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3b/33/tXJr2QZp_o.gif"></p> 
<p></p> 
<p id="main-toc"><strong>文章目录</strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E6%A6%82%E8%BF%B0" rel="nofollow">        1.0 请求响应概述</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.1%20%E7%AE%80%E5%8D%95%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.1%20%E7%AE%80%E5%8D%95%E5%8F%82%E6%95%B0" rel="nofollow">        1.1 简单参数</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.2%20%E5%AE%9E%E4%BD%93%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.2%20%E5%AE%9E%E4%BD%93%E5%8F%82%E6%95%B0" rel="nofollow">        1.2 实体参数</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%20%E6%95%B0%E7%BB%84%E9%9B%86%E5%90%88%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%20%E6%95%B0%E7%BB%84%E9%9B%86%E5%90%88%E5%8F%82%E6%95%B0" rel="nofollow">        2.3 数组集合参数</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.4%20%E6%97%A5%E6%9C%9F%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.4%20%E6%97%A5%E6%9C%9F%E5%8F%82%E6%95%B0" rel="nofollow">        2.4 日期参数</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.5%20json%20%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.5%20json%20%E5%8F%82%E6%95%B0" rel="nofollow">        2.5 json 参数</a></strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.6%20%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.6%20%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0" rel="nofollow">        2.6 路径参数</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">        3.0 完整代码</a></strong></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E6%A6%82%E8%BF%B0">        1.0 请求响应概述</h2> 
<p><strong>        当客户端发送不同的请求参数到服务端，服务端就需要进行不同的方法方式来接收请求参数。一般的请求参数的类型包括：<span style="color:#fe2c24;">简单参数、实体参数、数组集合参数、日期参数、json 参数、路径参数。</span></strong></p> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.1%20%E7%AE%80%E5%8D%95%E5%8F%82%E6%95%B0">        1.1 简单参数</h3> 
<p><strong>        客户端无论通过 <span style="color:#fe2c24;">get </span>或者是 <span style="color:#fe2c24;">post</span> 方式来发送请求，对应发送简单请求参数来说，是通过键值对的方式来发送到服务端。</strong></p> 
<p><span style="color:#fe2c24;"><strong>        1）方法一：服务端可以用到 HttpServletRequest 类对象来接收简单参数请求，再通过对象名.getParam("请求参数名") 方法来获取值。</strong></span></p> 
<p><strong>代码演示：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //接收简单参数方法一:使用 HttpServletRequest 类来获取客户端发送过来的请求参数
    //通过对象名.get
    //这里注解为:请求路径
    @RequestMapping("/simpleParam")
    public String simpleParam(HttpServletRequest request){
        String name = request.getParameter("name");
        String age = request.getParameter("age");</code></pre> 
 <p><strong>发送的请求参数：</strong></p> 
 <p class="img-center"><img alt="" height="319" src="https://images2.imgbox.com/42/99/tliQoOtd_o.png" width="600"></p> 
 <p><strong>        通过 GET 方式来发送请求，请求参数有两个 name 和 age，send 发送给服务端后，服务端给客户端返回 "OK" 。</strong></p> 
 <p></p> 
 <p><strong>服务器输出的结果：</strong></p> 
 <p class="img-center"><img alt="" height="97" src="https://images2.imgbox.com/88/34/VVsjkkxN_o.png" width="349"></p> 
 <p><strong>        服务端成功接收请求参数且返回数据到客户端。</strong></p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>        2）方法二：可以直接用一一对应的方式来接收请求参数，必须要注意保持请求的参数名与服务端需要接收的变量名保持一致。</strong></span></p> 
<p><strong>代码演示：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //接受简单参数方法二:直接用对应请求参数的变量名称来接收，一一对应的方式
    @RequestMapping("/simpleParam1")
    //需要注意的是，参数名称与客户端发送过来的名称要一一对应，且接收后的数据会自动识别转换类型
    public String simpleParam1(String name,Integer age){
        System.out.println(name + " : " + age);
        return "OK";
    }</code></pre> 
 <p><strong>发送的请求：</strong></p> 
 <p class="img-center"><img alt="" height="360" src="https://images2.imgbox.com/2d/05/E5Mf7tDq_o.png" width="600"></p> 
 <p><strong>        这次发送的请求方式为 post 方式，请求参数在请求体中。</strong></p> 
 <p></p> 
 <p><strong>服务器输出的结果：</strong></p> 
 <p class="img-center"><img alt="" height="100" src="https://images2.imgbox.com/6e/c2/SzfV3H7x_o.png" width="262"></p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>        3）对方法 2 的升级，万一有需求：接收请求参数的变量名与请求参数不一致，那么可以通过变量名与请求参数进行绑定的形式。</strong></span></p> 
<p><strong>代码演示：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //如果方法中的参数名与请求参数名不一致，就需要进行绑定参数
    @RequestMapping("/simpleParam2")
    public String simpleParam2(@RequestParam(name = "name" ,required = false) String userName,Integer age){
        System.out.println(userName + " : " + age);
        return "OK";
    }</code></pre> 
 <p><strong>发送的请求：</strong></p> 
 <p class="img-center"><img alt="" height="330" src="https://images2.imgbox.com/28/f4/6Y3I9ab5_o.png" width="600"></p> 
 <p><strong>        通过用注解 RequestParam 来绑定 name 与 userName ，也可以理解为将 name 映射到 userName 。注解中还有一个参数，该参数的作用，将 required 设置 false 时，不要求请求参数 name 一定有，但是 requider 默认为 true ，必须要求请求参数 name 必须存在。</strong></p> 
 <p><strong>服务端输出的结果：</strong></p> 
 <p class="img-center"><img alt="" height="92" src="https://images2.imgbox.com/c3/3b/nPlfJX8T_o.png" width="241"></p> 
</blockquote> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.2%20%E5%AE%9E%E4%BD%93%E5%8F%82%E6%95%B0">        1.2 实体参数</h3> 
<p><strong>        可以用类对象（实体）的方式来接收请求参数，类中的成员变量必须保持跟请求参数名一致。</strong></p> 
<p><strong>代码演示：</strong></p> 
<blockquote> 
 <pre><code class="language-java">public class User {
    private String name;
    private String age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAge() {
        return age;
    }

    public void setAge(String age) {
        this.age = age;
    }

    public User() {
    }

    public User(String name, String age) {
        this.name = name;
        this.age = age;
    }


    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age='" + age + '\'' +
                '}';
    }
}</code></pre> 
 <pre><code class="language-java">    //接受实体参数方法三:当客户端发送过来的数据，服务端可以用对象来接受，对象中的变量要跟传输过来的参数名要保持一致
    @RequestMapping("/complexParam")
    //用一个类对象来接收
    public String complexParam(User user){
        //这样 user 就可以接收到请求参数了
        System.out.println(user);
        return "OK";
    }</code></pre> 
 <p><strong>发送的请求：</strong></p> 
 <p class="img-center"><img alt="" height="330" src="https://images2.imgbox.com/c9/9a/OS5AIGJK_o.png" width="600"></p> 
 <p></p> 
 <p><strong>服务端输出的结果：</strong></p> 
 <p class="img-center"><img alt="" height="86" src="https://images2.imgbox.com/d9/9e/v7No3clY_o.png" width="312"></p> 
</blockquote> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%20%E6%95%B0%E7%BB%84%E9%9B%86%E5%90%88%E5%8F%82%E6%95%B0">        2.3 数组集合参数</h3> 
<p><strong>        当客户端发送的请求参数中有多个参数名是一致的且值不相同时，服务端就可以用到数组来接收这些相同参数的值了，接收参数值的数组名一定要跟该多个参数名保持一致。</strong></p> 
<p><strong>代码演示：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //接收数组参数方法:当客户端发送的参数名都是一样且值不一样的时候，就可以用到数组来接收了
    //需要注意的是，请求参数名需要跟接收的数组名保持一致
    @RequestMapping("/arrayParam")
    public String arrayParam(String[] hobby){
        System.out.println(Arrays.toString(hobby));
        return "OK";
    }</code></pre> 
 <p><strong>发送的请求：</strong></p> 
 <p class="img-center"><img alt="" height="350" src="https://images2.imgbox.com/bc/a6/tcrBhLiv_o.png" width="600"></p> 
 <p></p> 
 <p><strong>服务端输出的结果：</strong></p> 
 <p class="img-center"><img alt="" height="87" src="https://images2.imgbox.com/1b/34/RXdxyctw_o.png" width="281"></p> 
 <p><strong>        服务端成功用数组接收请求参数所应对的值。</strong></p> 
</blockquote> 
<p><strong>        除了数组这个容器之外，还可以用集合容器来接收请求参数，通过注解 @RequestParam 来绑定该集合来接收请求参数。</strong></p> 
<p><strong>代码演示：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //用集合来接收请求参数
    @RequestMapping("/listParam")
    //这里的注解:映射，默认用数组接收，若改变用集合来接收请求参数，就需要进行关系上的绑定
    //一定要注意，请求参数的名称 hobby 一定要与以下方法集合名称保持一致
    public String listParam(@RequestParam List&lt;String&gt; hobby){
        System.out.println(hobby);
        return "OK";
    }</code></pre> 
 <p><strong>发送的请求：</strong></p> 
 <p class="img-center"><img alt="" height="334" src="https://images2.imgbox.com/ee/19/VWorAxYk_o.png" width="600"></p> 
 <p></p> 
 <p><strong>服务端输出的结果：</strong></p> 
 <p class="img-center"><img alt="" height="92" src="https://images2.imgbox.com/98/3f/ufmRqyXR_o.png" width="319"></p> 
</blockquote> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.4%20%E6%97%A5%E6%9C%9F%E5%8F%82%E6%95%B0">        2.4 日期参数</h3> 
<p><strong>        若客户端发送给服务端的请求参数是日期格式，服务端可以用<span style="color:#fe2c24;"> LocalDateTime </span>类型的对象来接收该日期格式的请求参数，由于日期格式是不确定的，所以需要自定义日期格式，通过 <span style="color:#fe2c24;">@DateTimeFormat </span>注解中的 <span style="color:#fe2c24;">pattern </span>参数来定义日期格式。</strong></p> 
<p><strong>代码演示：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //当客户端的请求参数是日期的格式，那么就需要用到LocalDateTime类型来接收
    @RequestMapping("/dateTimeParam")
    //这里的注释:规定日期格式
    //需要注意，方法中的参数名必须要跟请求参数的名保持一致
    public String dateTimeParam(@DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss") LocalDateTime localDateTime){
        System.out.println(localDateTime);
        return "OK";
    }</code></pre> 
 <p><strong>发送的请求：</strong></p> 
 <p class="img-center"><img alt="" height="328" src="https://images2.imgbox.com/bd/f3/c4LA4qE2_o.png" width="600"></p> 
 <p><strong>        需要注意的是：05 不能只写 5 ，会因为格式不对，导致报错，报错码为：400，客户端格式错误，语法错误。</strong></p> 
 <p></p> 
 <p><strong>服务端输出的结果：</strong></p> 
 <p class="img-center"><img alt="" height="105" src="https://images2.imgbox.com/32/88/9Zi8FOJS_o.png" width="261"></p> 
</blockquote> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.5%20json%20%E5%8F%82%E6%95%B0">        2.5 json 参数</h3> 
<p><strong>        客户端用 post 方式来发送请求，请求的参数是 json 格式的参数，在请求体中。简单理解为，由于 json 格式与类的格式很像，所以用类对象来接收 json 参数，通过注解 @RequestBody 将类对象与请求 json 格式的参数进行绑定。</strong></p> 
<p><strong>代码演示：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //当客户端的请求参数是一个 json 格式,需要进行参数绑定
    //json 格式的数据可以简单理解认为就是用类对象来接收的，因为格式很相识
    @RequestMapping("/jsonParam")
    public String jsonParam(@RequestBody User user){
        System.out.println(user);
        return "OK";
    }</code></pre> 
 <p><strong>发送的请求：</strong></p> 
 <p class="img-center"><img alt="" height="348" src="https://images2.imgbox.com/17/ac/UPY7CKX5_o.png" width="600"></p> 
 <p></p> 
 <p><strong>服务端输出的结果：</strong></p> 
 <p class="img-center"><img alt="" height="99" src="https://images2.imgbox.com/92/78/EA7WK7vc_o.png" width="750"></p> 
 <p><strong>        这样服务端就完成了对客户端发送过来的 json 格式的请求参数接收完毕，且成功给客户端响应 "OK" 。</strong></p> 
</blockquote> 
<p></p> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.6%20%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0">        2.6 路径参数</h3> 
<p><strong>        当客户端发送的路径中就含有参数时，服务端该如何接收呢？</strong></p> 
<p><strong>        使用 Spring 框架的 Java 应用程序，可以使用<span style="color:#fe2c24;"> @PathVariable </span>注解来接收客户端发送的带有参数的路径。</strong></p> 
<p><strong>        在请求路径上的参数需要用<span style="color:#fe2c24;"> {} 进行封装</span>。</strong></p> 
<p><strong>代码演示：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //当客户端的请求参数就是路径参数
    @RequestMapping("/Path/{id}/{name}")
    public String pathParam(@PathVariable String id,@PathVariable String name){
        System.out.println(id + " : " + name);
        return "OK";
    }</code></pre> 
 <p><strong>发送的请求：</strong></p> 
 <p class="img-center"><img alt="" height="156" src="https://images2.imgbox.com/6d/7f/usR4nDTV_o.png" width="600"></p> 
 <p></p> 
 <p><strong>服务端输出的结果：</strong></p> 
 <p class="img-center"><img alt="" height="100" src="https://images2.imgbox.com/ef/b7/0J7EyrUF_o.png" width="275"></p> 
</blockquote> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">        3.0 完整代码</h2> 
<p><strong>demo1 类：</strong></p> 
<blockquote> 
 <pre><code class="language-java">import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;

@RestController
public class demo1 {

    //接收简单参数方法一:使用 HttpServletRequest 类来获取客户端发送过来的请求参数
    //通过对象名.get
    //这里注解为:请求路径
    @RequestMapping("/simpleParam")
    public String simpleParam(HttpServletRequest request){
        String name = request.getParameter("name");
        String age = request.getParameter("age");

        //类型转化:
        int age1 = Integer.parseInt(age);
        System.out.println(name + " : " + age1);

        //给客户端返回
        return "OK";
    }


    //接受简单参数方法二:直接用对应请求参数的变量名称来接收，一一对应的方式
    @RequestMapping("/simpleParam1")
    //需要注意的是，参数名称与客户端发送过来的名称要一一对应，且接收后的数据会自动识别转换类型
    public String simpleParam1(String name,Integer age){
        System.out.println(name + " : " + age);
        return "OK";
    }

    //如果方法中的参数名与请求参数名不一致，就需要进行绑定参数
    @RequestMapping("/simpleParam2")
    public String simpleParam2(@RequestParam(name = "name" ,required = false) String userName,Integer age){
        System.out.println(userName + " : " + age);
        return "OK";
    }



    //接受实体参数方法三:当客户端发送过来的数据，服务端可以用对象来接受，对象中的变量要跟传输过来的参数名要保持一致
    @RequestMapping("/complexParam")
    //用一个类对象来接收
    public String complexParam(User user){
        //这样 user 就可以接收到请求参数了
        System.out.println(user);
        return "OK";
    }


    //接收数组参数方法:当客户端发送的参数名都是一样且值不一样的时候，就可以用到数组来接收了
    //需要注意的是，请求参数名需要跟接收的数组名保持一致
    @RequestMapping("/arrayParam")
    public String arrayParam(String[] hobby){
        System.out.println(Arrays.toString(hobby));
        return "OK";
    }

    //用集合来接收请求参数
    @RequestMapping("/listParam")
    //这里的注解:映射，默认用数组接收，若改变用集合来接收请求参数，就需要进行关系上的绑定
    //一定要注意，请求参数的名称 hobby 一定要与以下方法集合名称保持一致
    public String listParam(@RequestParam List&lt;String&gt; hobby){
        System.out.println(hobby);
        return "OK";
    }

    //当客户端的请求参数是日期的格式，那么就需要用到LocalDateTime类型来接收
    @RequestMapping("/dateTimeParam")
    //这里的注释:规定日期格式
    //需要注意，方法中的参数名必须要跟请求参数的名保持一致
    public String dateTimeParam(@DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss") LocalDateTime localDateTime){
        System.out.println(localDateTime);
        return "OK";
    }


    //当客户端的请求参数是一个 json 格式,需要进行参数绑定
    //json 格式的数据可以简单理解认为就是用类对象来接收的，因为格式很相识
    @RequestMapping("/jsonParam")
    public String jsonParam(@RequestBody User user){
        System.out.println(user);
        return "OK";
    }


    //当客户端的请求参数就是路径参数
    @RequestMapping("/Path/{id}/{name}")
    public String pathParam(@PathVariable String id,@PathVariable String name){
        System.out.println(id + " : " + name);
        return "OK";
    }



}</code></pre> 
 <p></p> 
</blockquote> 
<p><strong>User 类：</strong></p> 
<blockquote> 
 <pre><code class="language-java">public class User {
    private String name;
    private String age;
    private Hobby hobby;


    public User() {
    }

    public User(String name, String age, Hobby hobby) {
        this.name = name;
        this.age = age;
        this.hobby = hobby;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAge() {
        return age;
    }

    public void setAge(String age) {
        this.age = age;
    }

    public Hobby getHobby() {
        return hobby;
    }

    public void setHobby(Hobby hobby) {
        this.hobby = hobby;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age='" + age + '\'' +
                ", hobby=" + hobby +
                '}';
    }
}</code></pre> 
 <p></p> 
</blockquote> 
<p><strong>Hobby 类：</strong></p> 
<blockquote> 
 <pre><code class="language-java">public class Hobby {
    private String name1;
    private String name2;

    public Hobby() {
    }

    public Hobby(String name1, String name2) {
        this.name1 = name1;
        this.name2 = name2;
    }

    public String getName1() {
        return name1;
    }

    public void setName1(String name1) {
        this.name1 = name1;
    }

    public String getName2() {
        return name2;
    }

    public void setName2(String name2) {
        this.name2 = name2;
    }

    @Override
    public String toString() {
        return "Hobby{" +
                "name1='" + name1 + '\'' +
                ", name2='" + name2 + '\'' +
                '}';
    }
}</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/4e/9b/FbLXrSyJ_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/260547e14cfbd548e82f28744a07120a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【梳理】k8s使用Operator搭建Flink集群（高可用可选）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d5521c370939220f2282595898d212a7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【c&#43;&#43;】全面理解C&#43;&#43;多态：虚函数表深度剖析与实践应用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>