<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构与算法】之五道链表进阶面试题详解！ - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/2efe50d08b0ba71b910197d5b0b1a40d/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【数据结构与算法】之五道链表进阶面试题详解！">
  <meta property="og:description" content="目录
1、链表的回文结构
2、相交链表
3、随机链表的复制
4、环形链表
5、环形链表（||）
6、完结散花
个人主页：秋风起，再归来~
数据结构与算法 个人格言：悟已往之不谏，知来者犹可追
克心守己，律己则安！
1、链表的回文结构 题目描述：
对于一个链表，请设计一个时间复杂度为O(n),额外空间复杂度为O(1)的算法，判断其是否为回文结构。
给定一个链表的头指针A，请返回一个bool值，代表其是否为回文结构。保证链表长度小于等于900。
测试样例：
1-&gt;2-&gt;2-&gt;1 返回：true 题目链接：OJ链接
解题代码：
ListNode* findMid(ListNode* head) { struct ListNode* fast=head,*slow=head; while(fast) { fast=fast-&gt;next-&gt;next; slow=slow-&gt;next; } return slow; } ListNode* reverse(ListNode* mid) { ListNode* n1=NULL; ListNode* n2=mid; ListNode* n3=mid-&gt;next; while(n2) { n2-&gt;next=n1; n1=n2; n2=n3; if(n3) { n3=n3-&gt;next; } } return n1; } class PalindromeList { public: bool chkPalindrome(ListNode* A) { // write code her //找中间节点 ListNode* mid=findMid(A); //把中间节点后的节点逆置 ListNode* rmid=reverse(A); while(A) { if(A-&gt;val!">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-06T21:28:55+08:00">
    <meta property="article:modified_time" content="2024-05-06T21:28:55+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构与算法】之五道链表进阶面试题详解！</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><a id="_0"></a></h3> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="1%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84" rel="nofollow">1、链表的回文结构</a></p> 
<p id="2%E3%80%81%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8" rel="nofollow">2、相交链表</a></p> 
<p id="3%E3%80%81%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6-toc" style="margin-left:0px;"><a href="#3%E3%80%81%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6" rel="nofollow">3、随机链表的复制</a></p> 
<p id="4%E3%80%81%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#4%E3%80%81%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8" rel="nofollow">4、环形链表</a></p> 
<p id="5%E3%80%81%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%EF%BC%88%7C%7C%EF%BC%89-toc" style="margin-left:0px;"><a href="#5%E3%80%81%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%EF%BC%88%7C%7C%EF%BC%89" rel="nofollow">5、环形链表（||）</a></p> 
<p id="3.%20%E5%AE%8C%E7%BB%93%E6%95%A3%E8%8A%B1-toc" style="margin-left:0px;"><a href="#3.%20%E5%AE%8C%E7%BB%93%E6%95%A3%E8%8A%B1" rel="nofollow">6、完结散花</a></p> 
<hr id="hr-toc"> 
<p></p> 
<blockquote> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/48/db/MBT21sQt_o.jpg"></p> 
 <p>                                                                                <a href="https://blog.csdn.net/2301_80221228?spm=1010.2135.3001.5343" title="个人主页：秋风起，再归来~">个人主页：秋风起，再归来~</a></p> 
 <p>                                                             <a href="http://t.csdnimg.cn/iayyH" rel="nofollow" title="  ">  </a>                 <a href="http://t.csdnimg.cn/WB4w7" rel="nofollow" title="            数据结构与算法">            数据结构与算法</a>                             </p> 
 <p>                                                                       <strong>个人格言：悟已往之不谏，知来者犹可追</strong></p> 
 <p><strong>                                                                                        克心守己，律己则安！</strong></p> 
</blockquote> 
<h2 id="1%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84" style="background-color:transparent;">1、链表的回文结构</h2> 
<blockquote> 
 <p><strong><span style="background-color:#ffd900;">题目描述：</span></strong></p> 
 <p>对于一个链表，请设计一个时间复杂度为O(n),额外空间复杂度为O(1)的算法，判断其是否为回文结构。</p> 
 <p>给定一个链表的头指针<strong>A</strong>，请返回一个bool值，代表其是否为回文结构。保证链表长度小于等于900。</p> 
 <p>测试样例：</p> 
 <pre>1-&gt;2-&gt;2-&gt;1</pre> 
 <pre>返回：true</pre> 
 <p><strong><span style="background-color:#ffd900;">题目链接：</span></strong><a class="link-info" href="https://www.nowcoder.com/practice/d281619e4b3e4a60a2cc66ea32855bfa?tpId=49&amp;&amp;tqId=29370&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/2016test/question-ranking" rel="nofollow" title="OJ链接">OJ链接</a></p> 
</blockquote> 
<p><strong><span style="background-color:#ffd900;">解题代码：</span></strong></p> 
<pre><code class="hljs">ListNode* findMid(ListNode* head)
{
    struct ListNode* fast=head,*slow=head;
    while(fast)
    {
        fast=fast-&gt;next-&gt;next;
        slow=slow-&gt;next;
    }
    return slow;
}

ListNode* reverse(ListNode* mid)
{
    ListNode* n1=NULL;
    ListNode* n2=mid;
    ListNode* n3=mid-&gt;next;
    while(n2)
    {
        n2-&gt;next=n1;
        n1=n2;
        n2=n3;
        if(n3)
        {
            n3=n3-&gt;next;
        }
    }
    return n1;
}

class PalindromeList {
public:
    bool chkPalindrome(ListNode* A) {
        // write code her
    //找中间节点
    ListNode* mid=findMid(A);
    //把中间节点后的节点逆置
    ListNode* rmid=reverse(A);
    while(A)
    {
        if(A-&gt;val!=rmid-&gt;val)
        {
            return false;
        }
        A=A-&gt;next;
        rmid=rmid-&gt;next;
    }
    return true;
    }
};</code></pre> 
<h2 id="2%E3%80%81%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8">2、相交链表</h2> 
<blockquote> 
 <p><strong><span style="background-color:#ffd900;">题目描述：</span></strong></p> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;">给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</span></span></p> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;">图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></span></span></p> 
 <p style="margin-left:0;"></p> 
 <p class="img-center"><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" rel="nofollow"><img alt="" height="241" src="https://images2.imgbox.com/0d/32/7WD5BMN4_o.png" width="742"></a></p> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;">题目数据 <strong>保证</strong> 整个链式结构中不存在环。</span></span></p> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;"><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</span></span></p> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;"><strong>自定义评测：</strong></span></span></p> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;"><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</span></span></p> 
 <ul><li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li><li><code>listA</code> - 第一个链表</li><li><code>listB</code> - 第二个链表</li><li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li></ul> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;">评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</span></span></p> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;"> </span></span></p> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;"><strong>示例 1：</strong></span></span></p> 
 <p style="margin-left:0;"></p> 
 <p class="img-center"><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" rel="nofollow"><img alt="" height="241" src="https://images2.imgbox.com/3e/66/z4yync0O_o.png" width="742"></a></p> 
 <pre style="margin-left:0;"><span style="background-color:#f0f0f0;"><strong>输入：</strong>intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
<strong>输出：</strong>Intersected at '8'
<strong>解释：</strong>相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。
</span></pre> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;"> </span></span></p> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;"><strong>示例 2：</strong></span></span></p> 
 <p style="margin-left:0;"></p> 
 <p class="img-center"><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png" rel="nofollow"><img alt="" height="241" src="https://images2.imgbox.com/98/5f/YBaNVYwB_o.png" width="622"></a></p> 
 <pre style="margin-left:0;"><span style="background-color:#f0f0f0;"><strong>输入：</strong>intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
<strong>输出：</strong>Intersected at '2'
<strong>解释：</strong>相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
</span></pre> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;"><strong>示例 3：</strong></span></span></p> 
 <p style="margin-left:0;"></p> 
 <p class="img-center"><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png" rel="nofollow"><img alt="" height="241" src="https://images2.imgbox.com/86/f8/r8YfDW79_o.png" width="382"></a></p> 
 <pre style="margin-left:0;"><span style="background-color:#f0f0f0;"><strong>输入：</strong>intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
<strong>输出：</strong>null
<strong>解释：</strong>从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
</span></pre> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;"> </span></span></p> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;"><strong>提示：</strong></span></span></p> 
 <ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>1 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li></ul> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;"> </span></span></p> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;"><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</span></span></p> 
 <p style="margin-left:0;"><span style="color:#262626;"><strong><span style="background-color:#ffd900;">题目链接：</span></strong><span style="background-color:#f0f0f0;"><a class="link-info" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/" rel="nofollow" title="OJ链接">OJ链接</a></span></span></p> 
</blockquote> 
<p><strong><span style="background-color:#ffd900;">解题代码：</span></strong></p> 
<pre><code class="hljs">struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) 
{
    struct ListNode *tailA=headA,*tailB=headB;
    int lenA=0,lenB=0;
    while(tailA-&gt;next)
    {
        lenA++;
        tailA=tailA-&gt;next;
    }
    while(tailB-&gt;next)
    {
        lenB++;
        tailB=tailB-&gt;next;
    }
    if(tailA!=tailB)
    return NULL;
    int gap=abs(lenA-lenB);//差距步
    //假设A为长链表
    struct ListNode *longList=headA,*shortList=headB;
    if(lenA&lt;lenB)
    {
        longList=headB;
        shortList=headA;
    }
    while(gap--)
    {
        longList=longList-&gt;next;
    }
    while(longList)
    {
        if(longList==shortList)
        return shortList;
        longList=longList-&gt;next;
        shortList=shortList-&gt;next;
    }
    return NULL;
}</code></pre> 
<h2 id="3%E3%80%81%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6">3、随机链表的复制</h2> 
<blockquote> 
 <p><strong><span style="background-color:#ffd900;">题目描述：</span></strong></p> 
 <p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p> 
 <p>构造这个链表的 <strong><a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin" rel="nofollow" title="深拷贝">深拷贝</a></strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点 </strong>。</p> 
 <p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p> 
 <p>返回复制链表的头节点。</p> 
 <p>用一个由 <code>n</code> 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p> 
 <ul><li><code>val</code>：一个表示 <code>Node.val</code> 的整数。</li><li><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为  <code>null</code> 。</li></ul> 
 <p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数。</p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="386" src="https://images2.imgbox.com/2e/2c/Szx3bBvJ_o.png" width="1200"></p> 
 <pre><strong>输入：</strong>head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
<strong>输出：</strong>[[7,null],[13,0],[11,4],[10,2],[1,0]]
</pre> 
 <p><strong>示例 2：</strong></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="272" src="https://images2.imgbox.com/43/4f/2oM1hv5B_o.png" width="1200"></p> 
 <pre><strong>输入：</strong>head = [[1,1],[2,1]]
<strong>输出：</strong>[[1,1],[2,1]]
</pre> 
 <p><strong>示例 3：</strong></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="330" src="https://images2.imgbox.com/be/97/Kgc6fluw_o.png" width="1200"></p> 
 <pre><strong>输入：</strong>head = [[3,null],[3,0],[3,null]]
<strong>输出：</strong>[[3,null],[3,0],[3,null]]
</pre> 
 <p></p> 
 <p><strong>提示：</strong></p> 
 <ul><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>-104 &lt;= Node.val &lt;= 104</code></li><li><code>Node.random</code> 为 <code>null</code> 或指向链表中的节点。</li></ul> 
 <p><strong><span style="background-color:#ffd900;">题目链接：<a class="link-info" href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/description/" rel="nofollow" title="OJ链接">OJ链接</a></span></strong></p> 
</blockquote> 
<p><strong><span style="background-color:#ffd900;">解题代码：</span></strong></p> 
<pre><code class="hljs">struct Node* copyRandomList(struct Node* head) {
	struct Node* cur=head;
    //将复制的链表先尾插到原链表的后面
    while(cur)
    {
        struct Node* copy=(struct Node*)malloc(sizeof(struct Node));
        copy-&gt;val=cur-&gt;val;
        copy-&gt;next=cur-&gt;next;
        cur-&gt;next=copy;
        cur=copy-&gt;next;
    }
    //复制链表的random的指向
    cur=head;
    while(cur)
    {
        struct Node* copy=cur-&gt;next;
        if(cur-&gt;random==NULL)
        {
            copy-&gt;random=NULL;
        }else{
            copy-&gt;random=cur-&gt;random-&gt;next;
        }
        cur=copy-&gt;next;
    }
    //将复制链表穿起来，并恢复原链表
	struct Node* copyhead=NULL,*copytail=NULL;
    cur=head;
    while(cur)
    {
        struct Node* copy=cur-&gt;next;
	    struct Node* next=copy-&gt;next;
        if(copyhead==NULL)
        {
            copyhead=copytail=copy;
        }else{
            copytail-&gt;next=copy;
            copytail=copytail-&gt;next;
        }
        cur-&gt;next=next;//恢复原链表
        cur=next;
    }
    return copyhead;
}</code></pre> 
<h2 id="4%E3%80%81%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8" style="background-color:transparent;">4、环形链表</h2> 
<blockquote> 
 <p><strong><span style="background-color:#ffd900;">题目描述：</span></strong></p> 
 <p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p> 
 <p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递 </strong>。仅仅是为了标识链表的实际情况。</p> 
 <p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="171" src="https://images2.imgbox.com/b5/38/de8x9qvq_o.png" width="531"></p> 
 <pre><strong>输入：</strong>head = [3,2,0,-4], pos = 1
<strong>输出：</strong>true
<strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。
</pre> 
 <p><strong>示例 2：</strong></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="105" src="https://images2.imgbox.com/6f/75/Jau7QGaT_o.png" width="201"></p> 
 <pre><strong>输入：</strong>head = [1,2], pos = 0
<strong>输出：</strong>true
<strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。
</pre> 
 <p><strong>示例 3：</strong></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="65" src="https://images2.imgbox.com/9d/40/Ea7OOKbT_o.png" width="65"></p> 
 <pre><strong>输入：</strong>head = [1], pos = -1
<strong>输出：</strong>false
<strong>解释：</strong>链表中没有环。
</pre> 
 <p></p> 
 <p><strong>提示：</strong></p> 
 <ul><li>链表中节点的数目范围是 <code>[0, 104]</code></li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li></ul> 
 <p></p> 
 <p><strong>进阶：</strong>你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p> 
 <p><strong><span style="background-color:#ffd900;">题目链接：</span></strong><a class="link-info" href="https://leetcode-cn.com/problems/linked-list-cycle/description/" rel="nofollow" title="OJ链接">OJ链接</a></p> 
</blockquote> 
<p><strong><span style="background-color:#ffd900;">解题代码：</span></strong></p> 
<pre><code class="hljs">bool hasCycle(struct ListNode *head) {
    struct ListNode* fast=head,*slow=head;
    while(fast&amp;&amp;fast-&gt;next)
    {
        fast=fast-&gt;next-&gt;next;
        slow=slow-&gt;next;
        if(fast==slow)
        {
            return true;
        }
    }
    return false;
}</code></pre> 
<h2 id="5%E3%80%81%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%EF%BC%88%7C%7C%EF%BC%89">5、环形链表（||）</h2> 
<blockquote> 
 <p><strong><span style="background-color:#ffd900;">题目描述：</span></strong></p> 
 <p></p> 
 <p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p> 
 <p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p> 
 <p><strong>不允许修改 </strong>链表。</p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="171" src="https://images2.imgbox.com/18/0a/qWQd123f_o.png" width="531"></p> 
 <pre><strong>输入：</strong>head = [3,2,0,-4], pos = 1
<strong>输出：</strong>返回索引为 1 的链表节点
<strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。
</pre> 
 <p><strong>示例 2：</strong></p> 
 <p class="img-center"><img alt="" height="105" src="https://images2.imgbox.com/f9/da/HStWROPk_o.png" width="201"></p> 
 <pre><strong>输入：</strong>head = [1,2], pos = 0
<strong>输出：</strong>返回索引为 0 的链表节点
<strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。
</pre> 
 <p><strong>示例 3：</strong></p> 
 <p class="img-center"><img alt="" height="65" src="https://images2.imgbox.com/9c/77/r7cMIRJc_o.png" width="65"></p> 
 <pre><strong>输入：</strong>head = [1], pos = -1
<strong>输出：</strong>返回 null
<strong>解释：</strong>链表中没有环。
</pre> 
 <p></p> 
 <p><strong>提示：</strong></p> 
 <ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul> 
 <p></p> 
 <p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p> 
 <p><strong><span style="background-color:#ffd900;">题目链接：</span></strong><a class="link-info" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/description/" rel="nofollow" title="OJ链接">OJ链接</a></p> 
</blockquote> 
<p><strong><span style="background-color:#ffd900;">解题代码：</span></strong></p> 
<pre><code class="hljs"> struct ListNode * hasCycle(struct ListNode *head) {
    struct ListNode* fast=head,*slow=head;
    while(fast&amp;&amp;fast-&gt;next)
    {
        fast=fast-&gt;next-&gt;next;
        slow=slow-&gt;next;
        if(fast==slow)
        {
            return fast;
        }
    }
    return NULL;
}
struct ListNode *detectCycle(struct ListNode *head) {
    if(hasCycle(head)==NULL)
    {
        return NULL;
    }
    else
    {
        struct ListNode* meet=hasCycle(head);
        struct ListNode* cur=head;
        while(cur)
        {
            if(cur==meet)
            {
                return cur;
            }
            cur=cur-&gt;next;
            meet=meet-&gt;next;
        }
    }
    return NULL;
}</code></pre> 
<h2 id="3.%20%E5%AE%8C%E7%BB%93%E6%95%A3%E8%8A%B1" style="background-color:transparent;">6、完结散花</h2> 
<p><span style="color:#956fe7;"><strong><em>好了，这期的分享到</em><em>这里就结束了~</em></strong></span></p> 
<p><span style="color:#956fe7;"><strong><em>如果这篇博客对你有帮助的话，可以用你们的小手指点一个免费的赞并收藏起来哟~</em></strong></span></p> 
<p><span style="color:#956fe7;"><strong><em>如果期待博主下期内容的话，可以点点关注，避免找不到我了呢~</em></strong></span></p> 
<p><span style="color:#956fe7;"><strong><em>我们下期不见不散~~</em></strong></span></p> 
<p><img alt="" height="240" src="https://images2.imgbox.com/35/7c/HcY6uXKm_o.gif" width="240">​​<img alt="" height="142" src="https://images2.imgbox.com/77/66/SaozZvWF_o.gif" width="200">​​</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ca3524b561081090c4c4495b696bf7d6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;：哈希表和unordered系列容器的封装</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c564e2a3218f8be092299b3c7da244cd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">初识指针（2）＜C语言＞</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>