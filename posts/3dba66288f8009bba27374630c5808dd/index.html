<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】栈和队列专题 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/3dba66288f8009bba27374630c5808dd/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【数据结构】栈和队列专题">
  <meta property="og:description" content="前言
上篇博客我们讨论了栈和队列的有关结构，本篇博客我们继续来讨论有关栈和队列习题
这些题算是经典了
💓 个人主页：小张同学zkf
⏩ 文章专栏：数据结构
若有问题 评论区见📝 🎉欢迎大家点赞👍收藏⭐文章 ​
目录
1. 括号匹配问题 2.用队列实现栈
3.用栈实现队列
4.设计循环队列
1. 括号匹配问题 由题可知我们需要判断一对括号是否成立，成立的话，就返回true，失败的话就返回false，这道题乍一看不好判断，其实我们可以用栈来解决，栈是后进先出的原则，我们可以判断如果是左括号的话让这个括号进栈，如果是右括号的话，让栈里的括号出栈与右括号匹对，若匹对成功，则继续判断下一个括号，这里我们需要考虑极端情况，假如括号都遍历完了，栈内还有左括号，代表此时左括号多，不匹配，所以还需要判断栈是否为空，还有如果第一个入栈的括号若是右括号，必定不匹配，直接false。
思路已给出，代码如下
对于c语言来说，注意先把栈写好，写好后再调用栈的函数，后续c&#43;&#43;就不用这么麻烦了
2.用队列实现栈 这道题就是给你两个队列，通过队列实现一个栈，我们都知道栈是后进先出的原则，而队列是先进先出的原则，那如何用两个队列实现栈那？
首先我们思考，假如现在有两个队列q1和q2，我们画图分析
根据图上操作要想实现栈的后进先出的原则，我们在入栈时先用一个队列q1来做入栈操作，若出栈，由于后进先出的原则，我们可以先把除最后一个元素，剩下的元素全部导入q2，然后再将还在q1的元素通过出队的方式实现出栈，若继续入栈，此刻元素都在q2那么就用q2实现入栈操作，然后出栈时，按照上面的操作来回导入就可以了。 所以出栈比较难，其他操作都是常规的，我们说一下出栈，我们可以用假设法，分为空的队列和非空的队列，非空的队列前size-1的元素，pop出来再push进空的队列，再pop最后一个元素
对了，判空条件是两个队里都没元素时，此刻栈为空
代码如下
3.用栈实现队列 两个队列可以实现栈，那两个栈如何实现队列那
队列是先进先出原则，那对于栈来说，后进先出，若两个栈，将第一个栈的所有元素全部导入第二个栈，此刻我们想想比如第一个栈原本1,2,3,4，现在导入第二个栈此刻是不是就是4,3,2,1，此刻第二个栈若出栈的话正好符合了队列的先进先出
我们可以在画图看一下
其实对于两个栈，将第一个栈导入另一个栈，原本第一个栈的元素是后进先出的原则，导入第二个栈就变成现进先出了
代码如下
4.设计循环队列 重头戏来了
循环队列，就是在一个有限空间里重复利用，如图
如图，我们用两个指针指向数组头，一个是队头指针head，一个是队尾指针tail，push数据时，tail&#43;&#43;，相当于Tail指向的是最后一个元素的下一个位置·，这一点跟栈栈顶元素有点类似，当初始化为0时， 指针指向最后一个元素的下一个位置，pop的话移动头元素head就行了，不过上面的图不现实，因为队列空和满时对应的条件都一样，都是head=Tail，所以我们得找一个办法让这个条件不一样，才能判空
一种是用一个size变量加加，记录数据，这是一种方法。
其实还有另一种方法，我们可以多一个空间,开k&#43;1个空间，但只能放k个元素
如图，此刻若放满正好是第四个图，相当于tail的下一个位置就是head，那么我们是不是可以根据取模得到关系（tail&#43;1）%(k&#43;1)==head达到这个条件就是满，空的条件就很简单，head==Tail
如果是返回尾元素，就是tail指针指向的上一个位置，tail-1，但是我们得考虑如上图这种情况，Tail回到前面，但是此刻tail－1越界了，所以这时我们可以根据取模，(Tail-1&#43;k&#43;1)%(k&#43;1) 就得到了尾元素的位置
头元素就是head指向的元素
OK，剩下的操作就是常规操作，代码如下
结束语
栈与队列经典习题就结束了，有什么问题可私聊我，里面的满足条件多想一想就能想明白，特别是最后一道题
OK,本篇博客结束！！！">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-14T21:28:54+08:00">
    <meta property="article:modified_time" content="2024-05-14T21:28:54+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】栈和队列专题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><span style="color:#4da8ee;">前言</span></p> 
 <p><span style="color:#0d0016;">上篇博客我们讨论了栈和队列的有关结构，本篇博客我们继续来讨论有关栈和队列习题</span></p> 
 <p><span style="color:#0d0016;">这些题算是经典了</span></p> 
 <p><span style="color:#0d0016;">💓 个人主页：<a class="link-info" href="https://blog.csdn.net/m0_74091744?spm=1010.2135.3001.5421" title="小张同学zkf">小张同学zkf</a></span></p> 
 <p><span style="color:#0d0016;">⏩ 文章专栏：<a class="link-info" href="https://blog.csdn.net/m0_74091744/category_12630139.html?spm=1001.2014.3001.5482" title="数据结构">数据结构</a></span></p> 
 <p><span style="color:#0d0016;">      若有问题 评论区见📝 </span></p> 
 <p><span style="color:#0d0016;">🎉欢迎大家点赞👍收藏⭐文章 ​</span></p> 
 <p style="text-align:center;"><span style="color:#0d0016;"><img alt="" class="left" src="https://images2.imgbox.com/23/b6/rC6L7owA_o.gif"></span></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3e/19/fBRDQUdA_o.gif"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/73/57/E0oFSwZk_o.gif"> </p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%20%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%C2%A0-toc" style="margin-left:0px;"><a href="#1.%20%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%C2%A0" rel="nofollow">1. 括号匹配问题 </a></p> 
<p id="2.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88-toc" style="margin-left:0px;"><a href="#2.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88" rel="nofollow">2.用队列实现栈</a></p> 
<p id="3.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97-toc" style="margin-left:0px;"><a href="#3.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97" rel="nofollow">3.用栈实现队列</a></p> 
<p id="4.%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97-toc" style="margin-left:0px;"><a href="#4.%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97" rel="nofollow">4.设计循环队列</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p> </p> 
<h2 id="1.%20%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%C2%A0"><span style="color:#777777;">1. </span><span style="color:#777777;">括号匹配问题</span> </h2> 
<p><img alt="" height="1124" src="https://images2.imgbox.com/60/c9/MQMKgqt9_o.png" width="1193"></p> 
<p>由题可知我们需要判断一对括号是否成立，成立的话，就返回true，失败的话就返回false，这道题乍一看不好判断，其实我们可以用栈来解决，栈是后进先出的原则，我们可以判断如果是左括号的话让这个括号进栈，如果是右括号的话，让栈里的括号出栈与右括号匹对，若匹对成功，则继续判断下一个括号，这里我们需要考虑极端情况，假如括号都遍历完了，栈内还有左括号，代表此时左括号多，不匹配，所以还需要判断栈是否为空，还有如果第一个入栈的括号若是右括号，必定不匹配，直接false。</p> 
<p><img alt="" height="409" src="https://images2.imgbox.com/53/e0/AyrcCGRF_o.png" width="969"></p> 
<p>思路已给出，代码如下</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/7a/72/Kww5HZO8_o.png" width="698"></p> 
<p>对于c语言来说，注意先把栈写好，写好后再调用栈的函数，后续c++就不用这么麻烦了</p> 
<hr> 
<h2 id="2.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88">2.用队列实现栈</h2> 
<p><img alt="" height="868" src="https://images2.imgbox.com/7e/dd/w6O0NVHY_o.png" width="1196"> </p> 
<p>这道题就是给你两个队列，通过队列实现一个栈，我们都知道栈是后进先出的原则，而队列是先进先出的原则，那如何用两个队列实现栈那？</p> 
<p style="text-align:center;"><img alt="" class="left" height="100" src="https://images2.imgbox.com/8e/21/wqitU6lE_o.gif" width="100"> </p> 
<p>首先我们思考，假如现在有两个队列q1和q2，我们画图分析</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/a2/fb/dPfwEYZl_o.png" width="1200"></p> 
<p></p> 
<p>根据图上操作要想实现栈的后进先出的原则，我们在入栈时先用一个队列q1来做入栈操作，若出栈，由于后进先出的原则，我们可以先把除最后一个元素，剩下的元素全部导入q2，然后再将还在q1的元素通过出队的方式实现出栈，若继续入栈，此刻元素都在q2那么就用q2实现入栈操作，然后出栈时，按照上面的操作来回导入就可以了。 </p> 
<p>所以出栈比较难，其他操作都是常规的，我们说一下出栈，我们可以用假设法，分为空的队列和非空的队列，非空的队列前size-1的元素，pop出来再push进空的队列，再pop最后一个元素</p> 
<p>对了，判空条件是两个队里都没元素时，此刻栈为空</p> 
<p>代码如下</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/a4/75/aEwuTN5G_o.png" width="1091"></p> 
<hr> 
<h2 id="3.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">3.用栈实现队列</h2> 
<p><img alt="" height="773" src="https://images2.imgbox.com/b2/b6/QQE81Vcm_o.png" width="1185"> </p> 
<p> 两个队列可以实现栈，那两个栈如何实现队列那</p> 
<p>队列是先进先出原则，那对于栈来说，后进先出，若两个栈，将第一个栈的所有元素全部导入第二个栈，此刻我们想想比如第一个栈原本1,2,3,4，现在导入第二个栈此刻是不是就是4,3,2,1，此刻第二个栈若出栈的话正好符合了队列的先进先出</p> 
<p>我们可以在画图看一下</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/a5/b6/4RJRLIW3_o.png" width="905"></p> 
<p>其实对于两个栈，将第一个栈导入另一个栈，原本第一个栈的元素是后进先出的原则，导入第二个栈就变成现进先出了</p> 
<p>代码如下</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/9b/01/O936cF6o_o.png" width="960"> </p> 
<hr> 
<h2 id="4.%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97">4.设计循环队列</h2> 
<p>重头戏来了</p> 
<p><img alt="" height="221" src="https://images2.imgbox.com/ee/c5/Igc6DevG_o.png" width="1200"></p> 
<p>循环队列，就是在一个有限空间里重复利用，如图</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/28/58/Sp1xMJt4_o.png" width="1200"> </p> 
<p>如图，我们用两个指针指向数组头，一个是队头指针head，一个是队尾指针tail，push数据时，tail++，相当于Tail指向的是最后一个元素的下一个位置·，这一点跟栈栈顶元素有点类似，当初始化为0时， 指针指向最后一个元素的下一个位置，pop的话移动头元素head就行了，<span style="background-color:#a2e043;">不过上面的图不现实，因为队列空和满时对应的条件都一样，都是head=Tail</span>，所以我们得找一个办法让这个条件不一样，才能判空</p> 
<p>一种是用一个size变量加加，记录数据，这是一种方法。</p> 
<p>其实还有另一种方法，我们可以多一个空间,开k+1个空间，但只能放k个元素</p> 
<p><img alt="" height="1072" src="https://images2.imgbox.com/89/14/teqJ67SS_o.png" width="1200"></p> 
<p>如图，此刻若放满正好是第四个图，相当于tail的下一个位置就是head，那么我们是不是可以根据取模得到关系（tail+1）%(k+1)==head达到这个条件就是满，空的条件就很简单，head==Tail</p> 
<p><img alt="" height="748" src="https://images2.imgbox.com/6c/fc/jVjV3Xjp_o.png" width="1200"></p> 
<p> </p> 
<p>如果是返回尾元素，就是tail指针指向的上一个位置，tail-1，但是我们得考虑如上图这种情况，Tail回到前面，但是此刻tail－1越界了，所以这时我们可以根据取模，(Tail-1+k+1)%(k+1) 就得到了尾元素的位置</p> 
<p>头元素就是head指向的元素</p> 
<p>OK，剩下的操作就是常规操作，代码如下</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/3e/d3/iQKXemSZ_o.png" width="1200"></p> 
<hr> 
<blockquote> 
 <p><span style="color:#4da8ee;"> 结束语</span></p> 
 <p><span style="color:#0d0016;">栈与队列经典习题就结束了，有什么问题可私聊我，里面的满足条件多想一想就能想明白，特别是最后一道题</span></p> 
 <p><span style="color:#0d0016;">OK,本篇博客结束！！！</span></p> 
 <p style="text-align:center;"><span style="color:#0d0016;"><img alt="" class="left" height="100" src="https://images2.imgbox.com/f4/96/OvGo1uuA_o.gif" width="100"></span><img alt="" src="https://images2.imgbox.com/59/98/QEvjb53E_o.gif"><img alt="" class="right" src="https://images2.imgbox.com/72/04/PEin8lPU_o.gif"></p> 
</blockquote> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5a9a56c78881395d3ca3650554de3f0c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AI绘画Stable Diffusion基础教程！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0e8d7fb50631fd6639f08b7169924783/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">搜索引擎的设计与实现（四）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>