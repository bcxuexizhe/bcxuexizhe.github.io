<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[Redis]基本全局命令 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/eef3a43c882fd0dd43d9c85af924a196/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="[Redis]基本全局命令">
  <meta property="og:description" content="Redis存储方式介绍 在 Redis 中数据是以键值对的凡事存储的，键（Key）和值（Value）是基本的数据存储单元。以下是对 Redis 键值对的详细讲解：
键（Key）： 类型：键是字符串类型，可以包含任何二进制数据。
长度限制：键的最大长度为 512 MB。
命名规范：虽然 Redis 对键的命名没有严格的要求，但为了提高可读性和管理性，通常使用有意义的命名规范。例如： session:abc123
值（Value）： 值可以是多种数据类型之一，Redis 提供了丰富的数据结构来存储不同类型的数据：
比如字符串（String）、哈希（Hash）、列表（List）、集合（Set）、有序集合（Sorted Set，ZSet）、位图（Bitmap）、HyperLogLog、地理空间索引（Geospatial）、流（Stream）
这里以字符串类型举例，其他数据类型后面会介绍
基础全局命令介绍 设置和获取键值对（string） 这里操作就是这是一个key1 value1的键值对，key1为键，value1为值
设置好后，再用get命令获取到key1对应的值
获取到value1
检查键是否存在 exists key
因为有key1，所以使用key1可以查询到，返回了1
（这里也可以一次性查询多个key，返回就是有几个查到了，就返回几）
没有key2，查询不到，返回0
查找键 keys [pattern]
返回所有满足样式（pattern）的 key。支持如下统配样式。
h?llo 匹配 hello , hallo 和 hxllo
h*llo 匹配 hllo 和 heeeello
h[ae]llo 匹配 hello 和 hallo 但不匹配 hillo
h[^e]llo 匹配 hallo , hbllo , ... 但不匹配 hello
h[a-b]llo 匹配 hallo 和 hbllo">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-23T16:12:44+08:00">
    <meta property="article:modified_time" content="2024-05-23T16:12:44+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[Redis]基本全局命令</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>Redis存储方式介绍</h3> 
<p>在 Redis 中数据是以键值对的凡事存储的，键（Key）和值（Value）是基本的数据存储单元。以下是对 Redis 键值对的详细讲解：</p> 
<h4>键（Key）：</h4> 
<p><strong>类型</strong>：键是字符串类型，可以包含任何二进制数据。</p> 
<p><strong>长度限制</strong>：键的最大长度为 512 MB。</p> 
<p><strong>命名规范</strong>：虽然 Redis 对键的命名没有严格的要求，但为了提高可读性和管理性，通常使用有意义的命名规范。例如： session:abc123</p> 
<h4>值（Value）：</h4> 
<p>值可以是多种数据类型之一，Redis 提供了丰富的数据结构来存储不同类型的数据：</p> 
<p>比如<strong>字符串（String）、哈希（Hash）、列表（List）、集合（Set）、有序集合（Sorted Set，ZSet）、位图（Bitmap）、HyperLogLog、地理空间索引（Geospatial）、流（Stream）</strong></p> 
<p>这里以字符串类型举例，其他数据类型后面会介绍</p> 
<h3>基础全局命令介绍</h3> 
<h4>设置和获取键值对（string）</h4> 
<p><img alt="" height="102" src="https://images2.imgbox.com/10/4a/7gwlmIDi_o.png" width="377"></p> 
<p>这里操作就是这是一个key1 value1的键值对，key1为键，value1为值</p> 
<p>设置好后，再用get命令获取到key1对应的值</p> 
<p>获取到value1</p> 
<h4><strong>检查键是否存在</strong></h4> 
<p>exists key</p> 
<p><img alt="" height="162" src="https://images2.imgbox.com/b7/10/fI7UFGRH_o.png" width="347"><br><br> 因为有key1，所以使用key1可以查询到，返回了1</p> 
<p>（这里也可以一次性查询多个key，返回就是有几个查到了，就返回几）</p> 
<p>没有key2，查询不到，返回0</p> 
<h4>查找键</h4> 
<p>keys [pattern]</p> 
<p>返回所有满足样式（pattern）的 key。支持如下统配样式。</p> 
<blockquote> 
 <p>h?llo 匹配 hello , hallo 和 hxllo</p> 
 <p>h*llo 匹配 hllo 和 heeeello</p> 
 <p>h[ae]llo 匹配 hello 和 hallo 但不匹配 hillo</p> 
 <p>h[^e]llo 匹配 hallo , hbllo , ... 但不匹配 hello</p> 
 <p>h[a-b]llo 匹配 hallo 和 hbllo</p> 
</blockquote> 
<p> keys * 返回数据库中所有key</p> 
<p><img alt="" height="161" src="https://images2.imgbox.com/88/2f/XxyMfbqE_o.png" width="206"></p> 
<p>使用 keys 命令在 Redis 中有很大的风险，特别是在生产环境中。这是因为 keys 命令会扫描整个数据库并返回匹配指定模式的所有键。这种操作可能会对 Redis 服务器的性能产生严重影响，特别是在键数量较多的情况下。</p> 
<h5><font face="monospace">keys</font>命令的风险</h5> 
<ol><li> <p><strong>性能问题</strong>：</p> 
  <ul><li><code>KEYS</code> 命令是阻塞操作，会遍历整个数据库来查找匹配的键。</li><li>在键数量较多时，执行 <code>KEYS</code> 命令可能会导致 Redis 服务卡顿，影响其他操作的响应时间。</li><li>这种操作的时间复杂度为 O(N)，其中 N 是数据库中的键数量。</li></ul></li><li> <p><strong>阻塞客户端</strong>：</p> 
  <ul><li>如果一个客户端执行 <code>KEYS</code> 命令，其他客户端的请求可能会被阻塞，直到 <code>KEYS</code> 命令执行完毕。</li><li>在高并发场景下，这种阻塞可能导致大量请求堆积，造成 Redis 服务不可用。</li></ul></li><li> <p><strong>内存消耗</strong>：</p> 
  <ul><li><code>KEYS</code> 命令返回的结果集可能非常大，导致返回的数据量超出客户端的处理能力。</li><li>结果集需要在内存中存储，可能导致 Redis 服务器的内存压力增大。</li></ul></li></ol> 
<p>当然，也有其他命令可以代替keys，比如scan命令，后面会讲到。</p> 
<p>在数据量很小的情况下，使用keys命令问题不大。</p> 
<h4> 删除键</h4> 
<p>del key</p> 
<p><img alt="" height="170" src="https://images2.imgbox.com/a1/5b/onIfBEyh_o.png" width="278"></p> 
<p>这里因为存在key1，所以使用del删除返回1，表示删除成功1个</p> 
<p>但是key2不存在，没有删除任何key，返回0</p> 
<h4>设置过期时间</h4> 
<p>expire key seconds        （单位是秒）</p> 
<p>pexpire key millisecond        （单位是毫秒）</p> 
<p><img alt="" height="163" src="https://images2.imgbox.com/04/70/9i7Sa896_o.png" width="290"></p> 
<p>设置key1，然后设置key1的过期时间为10秒</p> 
<p>10秒后用exists查询，返回0，说明key1已经过期被删除了</p> 
<h4>查询键的剩余生存时间</h4> 
<p>TTL：获取键的剩余生存时间（单位是秒）</p> 
<p>PTTL：获取键的剩余生存时间（单位是毫秒）</p> 
<p><img alt="" height="204" src="https://images2.imgbox.com/83/eb/VNC2Mnqz_o.png" width="257"></p> 
<p>设置键值对并设置过期时间</p> 
<p>用ttl和pttl查询剩余过期时间</p> 
<p>过期后，key1被删除，返回-2</p> 
<p><img alt="" height="98" src="https://images2.imgbox.com/4f/a7/h12JSkgQ_o.png" width="392"></p> 
<p>如果返回-1，说明key是永久存在的，没有设置过期时间</p> 
<h3 style="background-color:transparent;">redis过期策略</h3> 
<p>Redis 通过多种策略来管理键的过期和内存回收</p> 
<p>可以在redis系统文件的配置，也就是redis.conf里修改过期策略</p> 
<h4>1. 惰性删除（Lazy Deletion）</h4> 
<p>惰性删除策略意味着当客户端访问某个键时，Redis 会检查该键是否已经过期。如果该键已经过期，Redis 将立即删除它，并返回一个不存在的结果。</p> 
<ul><li><strong>实现方式</strong>： 
  <ul><li>每次读取或写入一个键时，Redis 都会检查该键的过期时间。</li><li>如果过期时间已到，Redis 会删除该键，然后返回不存在的结果或进行相应的写操作。</li></ul></li><li><strong>优点</strong>： 
  <ul><li>不会额外占用 CPU 资源，因为只在访问键时进行检查。</li></ul></li><li><strong>缺点</strong>： 
  <ul><li>过期键在没有被访问时仍会占用内存。</li></ul></li></ul> 
<h4>2. 定期删除（Periodic Deletion）</h4> 
<p>定期删除策略是指 Redis 以固定的时间间隔对带有过期时间的键进行扫描和删除。</p> 
<ul><li><strong>实现方式</strong>： 
  <ul><li>Redis 内部会运行一个后台任务，以每秒 10 次的频率随机抽取一部分带有过期时间的键进行检查。</li><li>如果发现这些键已经过期，Redis 会删除它们。</li></ul></li><li><strong>优点</strong>： 
  <ul><li>相对平衡了性能和内存回收的需求。</li><li>可以在一定程度上避免大量过期键长时间占用内存。</li></ul></li><li><strong>缺点</strong>： 
  <ul><li>由于是定期抽样检查，仍有可能存在一些过期键在被检查到之前长时间占用内存。</li></ul></li></ul> 
<p></p> 
<p><strong>Redis 过期键处理策略（惰性删除和定期删除）是内置的，不需要特别配置。</strong></p> 
<p>但是可以通过以下配置调整定期删除的频率：（在redis.conf配置文件里）</p> 
<p>hz 10<br> 这表示 Redis 的事件循环频率，每秒执行 10 次事件循环。这个值会影响定期删除过期键的频率。</p> 
<p></p> 
<h4>3. 主动删除（Active Deletion）</h4> 
<p>主动删除策略主要是通过内存淘汰策略（Eviction Policy）来实现，当 Redis 内存达到配置的最大使用量时，会主动删除一些键来释放内存。</p> 
<ul><li> <p><strong>配置方式</strong>：</p> 
  <ul><li>可以通过 <code>maxmemory</code> 配置项设置 Redis 的最大内存使用量。</li><li>可以通过 <code>maxmemory-policy</code> 配置项设置内存淘汰策略，包括以下几种： 
    <ul><li><code>volatile-lru</code>：从设置了过期时间的键中移除最近最少使用的键。</li><li><code>allkeys-lru</code>：从所有键中移除最近最少使用的键。</li><li><code>volatile-lfu</code>：从设置了过期时间的键中移除最不常使用的键。</li><li><code>allkeys-lfu</code>：从所有键中移除最不常使用的键。</li><li><code>volatile-ttl</code>：从设置了过期时间的键中移除将要过期的键。</li><li><code>noeviction</code>：当内存达到限制时，不再进行删除操作，直接返回错误。</li><li><code>volatile-random</code>：从设置了过期时间的键中随机移除键。</li><li><code>allkeys-random</code>：从所有键中随机移除键。</li></ul></li></ul></li><li> <p><strong>优点</strong>：</p> 
  <ul><li>可以确保 Redis 在达到内存上限时继续运行。</li><li>根据不同的策略，可以优化特定场景下的性能和内存使用。</li></ul></li><li> <p><strong>缺点</strong>：</p> 
  <ul><li>可能导致一些热键（高频访问的键）被移除，从而影响性能。</li></ul></li></ul> 
<h4>4. 内存淘汰策略</h4> 
<p>当 Redis 内存使用达到限制时，会根据配置的内存淘汰策略删除一些键，以释放内存。以下是一些常用的内存淘汰策略：</p> 
<ul><li><strong>LRU（Least Recently Used）</strong>：删除最近最少使用的键。</li><li><strong>LFU（Least Frequently Used）</strong>：删除使用频率最少的键。</li><li><strong>TTL（Time to Live）</strong>：删除最早过期的键。</li><li><strong>随机删除</strong>：随机删除一些键。</li></ul> 
<p>可以通过 <code>maxmemory-policy</code> 配置项来设置具体的淘汰策略。</p> 
<p>比如：</p> 
<p>maxmemory-policy allkeys-lru</p> 
<p>这表示当达到最大内存限制时，Redis 将采用 LRU策略在所有键中移除最近最少使用的键。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/71d14c4bf1828304aa830b127b5c8786/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">什么是边缘计算？它为何如此重要？天拓四方</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9f3cce58d63ae78e640245c022327b3d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【算法】网络图中的dfs</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>