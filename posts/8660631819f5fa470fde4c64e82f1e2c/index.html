<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构算法——链表带环问题——数学深度解析 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/8660631819f5fa470fde4c64e82f1e2c/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="数据结构算法——链表带环问题——数学深度解析">
  <meta property="og:description" content="前言:本节内容主要是讲解链表的两个问题 ：1、判断链表是否带环； 2、一个链表有环， 找到环的入口点。 本节内容适合正在学习链表或者链表基础薄弱的友友们哦。
我们先将问题抛出来，友友们可以自己去力扣或者牛客网去找相应题目， 这里直接贴链接：（没有做过这两个题的友友 千万！ 千万！ 千万！ 要先自己做一下这两个题。)
判断链表是否带环：141. 环形链表 - 力扣（LeetCode）
带环链表的入环节点：LCR 022. 环形链表 II - 力扣（LeetCode）
目录
判断链表是否带环
题目解析
算法原理
算法演示
算法原理
原理扩展
环形链表的入口节点
题目解析
算法原理
算法演示
算法原理
我们先来讲解第一道题
判断链表是否带环 题目解析 题目：
代码框：
题目非常的简单， 就是要求我们设计一个算法， 判断这个链表中是否右带环结构就可以了。 如果有带环结构， 那么就返回true， 如果没有带环结构， 那么就返回false。 算法原理 算法演示 解决这个问题需要用到快慢双指针算法， 我们利用题中所给示例进行演示:
先定义两个指针slow， fast。并且slow和fast要指向同时指向头节点， 否则在第二道题的时候处理起来会变的复杂。(具体为什么会变得复杂请友友们现在不要深究， 第二题的时候会讲到的， 到时再思考就行啦)
然后， 我们向后进行遍历， 遍历的过程是这样的： slow指针一次向后移动一个节点。 fast一次向后移动两个节点。当两个节点相遇的时候就说明我们的链表是带环的。
而如果我们的fast指向了空节点， 那么就说明我们的链表是不带环的。
我们演示一遍是这样的：
代码贴图如下：
bool hasCycle(struct ListNode *head) { //先判断下链表为空的情况 if (head == NULL) return false; //1、创建两个指针， slow, fast同时指向链表头节点。 struct ListNode* slow = head; struct ListNode* fast = head; //2、遍历整个链表， 判断是否有环 while (fast !">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-05T21:31:04+08:00">
    <meta property="article:modified_time" content="2024-05-05T21:31:04+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构算法——链表带环问题——数学深度解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>        <span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">前言</span></strong></span>:本节内容主要是讲解链表的两个问题 ：1、判断链表是否带环； 2、一个链表有环， 找到环的入口点。 本节内容适合正在学习链表或者链表基础薄弱的友友们哦。</p> 
</blockquote> 
<p>        我们先将问题抛出来，友友们可以自己去力扣或者牛客网去找相应题目， 这里直接贴链接：（没有做过这两个题的友友 <strong><span style="color:#fe2c24;">千万！ 千万！ 千万！ </span></strong>要先自己做一下这两个题。)</p> 
<p>        判断链表是否带环：<a href="https://leetcode.cn/problems/linked-list-cycle/description/" rel="nofollow" title="141. 环形链表 - 力扣（LeetCode）">141. 环形链表 - 力扣（LeetCode）</a></p> 
<p>        带环链表的入环节点：<a href="https://leetcode.cn/problems/c32eOV/description/" rel="nofollow" title="LCR 022. 环形链表 II - 力扣（LeetCode）">LCR 022. 环形链表 II - 力扣（LeetCode）</a></p> 
<p>        </p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%B8%A6%E7%8E%AF-toc" style="margin-left:0px;"><a href="#%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%B8%A6%E7%8E%AF" rel="nofollow">判断链表是否带环</a></p> 
<p id="%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90" rel="nofollow">题目解析</a></p> 
<p id="%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86" rel="nofollow">算法原理</a></p> 
<p id="%E7%AE%97%E6%B3%95%E6%BC%94%E7%A4%BA-toc" style="margin-left:80px;"><a href="#%E7%AE%97%E6%B3%95%E6%BC%94%E7%A4%BA" rel="nofollow">算法演示</a></p> 
<p id="%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86" rel="nofollow">算法原理</a></p> 
<p id="%E5%8E%9F%E7%90%86%E6%89%A9%E5%B1%95-toc" style="margin-left:80px;"><a href="#%E5%8E%9F%E7%90%86%E6%89%A9%E5%B1%95" rel="nofollow">原理扩展</a></p> 
<p id="%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9-toc" style="margin-left:0px;"><a href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9" rel="nofollow">环形链表的入口节点</a></p> 
<p id="%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90" rel="nofollow">题目解析</a></p> 
<p id="%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86" rel="nofollow">算法原理</a></p> 
<p id="%E7%AE%97%E6%B3%95%E6%BC%94%E7%A4%BA-toc" style="margin-left:80px;"><a href="#%E7%AE%97%E6%B3%95%E6%BC%94%E7%A4%BA" rel="nofollow">算法演示</a></p> 
<p id="%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86" rel="nofollow">算法原理</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p>        我们先来讲解第一道题</p> 
<h2 id="%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%B8%A6%E7%8E%AF">判断链表是否带环</h2> 
<h3 id="%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90">题目解析</h3> 
<p>题目：</p> 
<p>        <img alt="" height="656" src="https://images2.imgbox.com/d8/98/CwhTtpAX_o.png" width="491"></p> 
<p>代码框：</p> 
<p><img alt="" height="569" src="https://images2.imgbox.com/f3/a9/US1ps5xf_o.png" width="1200"></p> 
<p>        题目非常的简单， 就是要求我们设计一个算法， 判断这个链表中是否右带环结构就可以了。 如果有带环结构， 那么就返回true， 如果没有带环结构， 那么就返回false。 </p> 
<h3 id="%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86">算法原理</h3> 
<h4 id="%E7%AE%97%E6%B3%95%E6%BC%94%E7%A4%BA">算法演示</h4> 
<p><img alt="" height="296" src="https://images2.imgbox.com/01/08/luBoGTkX_o.png" width="837"></p> 
<p>        解决这个问题需要用到快慢双指针算法， 我们利用题中所给示例进行演示:</p> 
<p><img alt="" height="344" src="https://images2.imgbox.com/f2/f1/DG6lmjYz_o.png" width="611"></p> 
<p>        先定义两个指针slow， fast。并且<span style="color:#fe2c24;"><strong>slow和fast要指向同时指向头节点， 否则在第二道题的时候处理起来会变的复杂</strong></span>。(<strong><span style="color:#38d8f0;"><span style="background-color:#f9eda6;">具体为什么会变得复杂请友友们现在不要深究， 第二题的时候会讲到的， 到时再思考就行啦</span></span></strong>)</p> 
<p>        然后， 我们向后进行遍历， 遍历的过程是这样的：<span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;"> slow指针一次向后移动一个节点。 fast一次向后移动两个节点。当两个节点相遇的时候就说明我们的链表是带环的。</span></strong></span></p> 
<p>        <span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">而如果我们的fast指向了空节点， 那么就说明我们的链表是不带环的。</span></strong></span></p> 
<p>        我们演示一遍是这样的：</p> 
<p><img alt="" height="844" src="https://images2.imgbox.com/de/07/nGmZ0YmY_o.png" width="1200"></p> 
<p>代码贴图如下：</p> 
<pre><code class="language-cpp">bool hasCycle(struct ListNode *head) 
{
    //先判断下链表为空的情况
    if (head == NULL) return false;

    //1、创建两个指针， slow, fast同时指向链表头节点。
    struct ListNode* slow = head;
    struct ListNode* fast = head;

    //2、遍历整个链表， 判断是否有环
    while (fast != NULL &amp;&amp; fast-&gt;next != NULL)
    {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
        if (slow == fast) return true;  //如果两个指针指向同一个位置， 说明有环。
    }
    return false;             //退出循环说明无环。
}</code></pre> 
<p>        这就是算法的基本思路， 我们接下来进行剖析这个算法：</p> 
<h4>算法原理</h4> 
<p>        <img alt="" height="563" src="https://images2.imgbox.com/e4/a6/rMp3SyoF_o.png" width="1200"></p> 
<p>        为了证明我们的结论的普遍性， 我们利用上面的抽象图来进行演示。</p> 
<p>         这里的<span style="color:#a2e043;"><strong>环周长就相当于C个节点</strong></span>， 前面的<span style="color:#a2e043;"><strong>直线L就相当于没有进入环之前的L个节点</strong></span>。 然后<span style="color:#a2e043;"><strong>slow每次走一个节点， fast一次走两个节点</strong></span>。 </p> 
<p>        fast走的比slow要快， 所以， fast一定是在slow前面的。如果没有环的话， fast是肯定会先一步指向空的。 fast和slow也就无法相遇了。 所以如果fast指向空， 那么就一定没有环。</p> 
<p>         但是如果有环， 这个时候<span style="color:#fe2c24;"><strong>fast一定会先进入环</strong></span>。如图所示：</p> 
<p><img alt="" height="548" src="https://images2.imgbox.com/0b/40/U30zwD7I_o.png" width="1200"></p> 
<p>        然后继续遍历， slow再进入环。如图所示：</p> 
<p><img alt="" height="519" src="https://images2.imgbox.com/1b/e9/wnoR4VfW_o.png" width="1200"></p> 
<p>        那么， 重点就来了。 slow进入环之后， 如果fast和slow再继续遍历， 那么是不是fast和slow之间的距离在不断的缩小， 是不是就<strong><span style="color:#38d8f0;">相当于fast在追击slow</span></strong>。 我们<strong><span style="color:#fe2c24;"><span style="background-color:#ffd900;">假设fast到slow的距离为N， 此时我们就将问题转化为了一个追击相遇问题</span></span></strong>。  </p> 
<p>        fast每次走两步， slow每次走一步。 那么每回合fast和slow之间的距离就减少1。 循环下来就是N - 1  - 1 - 1 - 1 - 1， 直到N为零位置。 此时fast和slow相遇。并且当这两个指针相遇的时候， 只有两种情况， 一个是在环的入口点相遇， 一个是在环的其他位置相遇。 但这两种情况可以归到一类里面——<strong><span style="color:#fe2c24;"><span style="background-color:#ffd900;">slow和fast会在环内相遇</span></span></strong>。</p> 
<p>        <img alt="" height="198" src="https://images2.imgbox.com/7b/8d/3gnkZbdr_o.png" width="601"></p> 
<p> 综上， slow和fast只要相遇了， 他们就会在环内， 说明链表有环。</p> 
<p>        然后到这里这个题的算法原理基本结束了， 但是， 这里还有一个经常考的探究性问题， 很重要的扩展知识。 接下来进行分析：</p> 
<h4 id="%E5%8E%9F%E7%90%86%E6%89%A9%E5%B1%95">原理扩展</h4> 
<p>        从上文我们知道， 当slow指针和fast指针相遇的时候一定再环内。 但是有没有可能slow和fast不会相遇， 每次fast指针都越过slow指针， 导致两个指针永远无法相遇？</p> 
<blockquote> 
 <p>        答案是我们前面分析的fast走两步， slow的情况不会。</p> 
 <p>        但是如果fast一次走三步， slow一次走一步以及一些其他情况就可能fast直接越过slow， 永远不会相遇。这里需要具体情况具体分析。</p> 
</blockquote> 
<p>        分析过程如下：</p> 
<p>        如果我们slow每回合走一步， fast每回合走三步。 那么fast和slow的步数就相差2。 假设slow进环的时候slow和fast之间的距离相差<strong><span style="color:#38d8f0;">N</span></strong>。那么循环下来就是N - 2 - 2 - 2. 这里如果N是偶数， N就恰好减少到零了， 这个时候slow和fast指针就相遇了。</p> 
<p>        但是如果N是奇数呢？ N - 2 - 2 - 2就有可能得到-1，我们假设圆环的长度为<span style="color:#38d8f0;"><strong>C，</strong></span>这个时候就是如图这种情况：</p> 
<p><img alt="" height="944" src="https://images2.imgbox.com/08/2b/T41KTG6j_o.png" width="1200"></p> 
<p>        那么， <span style="color:#38d8f0;"><strong>fast和slow之间的距离此时变成了C - 1</strong></span>。</p> 
<p>        接下来再进行分类讨论， 如果C为奇数， 那么C - 1就为偶数， 这样 C - 1 - 2 - 2 - 2……就有可能减少到零； 如果C为偶数， 那么C - 1就是奇数， 这样 C - 1 - 2 - 2 ……就会重新减少到-1， 然后fast和slow之间的距离又变成C - 1， 这个时候就陷入了死循环。</p> 
<p>         所以，综上我们可以得出小结论：<strong><span style="color:#38d8f0;"> 当fast一次走三步， slow一次走一步。如果N为偶数， 那么fast和slow一定相遇。 如果N为奇数， C为奇数。 那么fast和slow也会相遇。 如果N为奇数， C为偶数， 那么fast和slow永远不会相遇。</span></strong></p> 
<blockquote> 
 <p>        将上面的推导过程总结为一个算数表达式就是 ： <strong><span style="color:#fe2c24;"><span style="background-color:#ffd900;">（N + x * C）% 2  ？ 0</span></span></strong>；<strong><span style="color:#a2e043;">//距离N + x圈后模上fast和slow步数差是不是等于0.</span></strong></p> 
</blockquote> 
<blockquote> 
 <p>        所以， 我们得出的大结论就是：<span style="color:#38d8f0;">假设slow和fast每回合的步数相差<strong><span style="background-color:#f9eda6;">sub</span></strong>.进入环的时候fast指针与slow指针之间的距离为<strong><span style="background-color:#f9eda6;">N</span></strong>。圆环的长度为<strong><span style="background-color:#f9eda6;">C</span></strong>。如果有 ：  <strong><span style="background-color:#ffd900;">（N + x * C）% sub  ==  0</span></strong>。就说明fast和slow会相遇， 否则不会相遇。</span></p> 
</blockquote> 
<p>        以上就是本道题的所有知识点。</p> 
<blockquote> 
 <p><strong><span style="color:#a2e043;">        ps:代码中的细节问题，属于代码编写的范畴， 不属于算法原理。 本篇内容只讲算法原理。 代码友友们自行编写调试。</span></strong></p> 
</blockquote> 
<h2 id="%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9"><br><br><strong>环形链表的入口节点</strong></h2> 
<h3>题目解析</h3> 
<p>题目：</p> 
<p><img alt="" height="704" src="https://images2.imgbox.com/29/e4/jRNs0cYl_o.png" width="484"></p> 
<p>代码框： </p> 
<p>        <img alt="" height="362" src="https://images2.imgbox.com/2c/45/eENpLsC7_o.png" width="583"></p> 
<p> 这道题就是上面那道题的提高版本。 需要先对链表判断是否有环， 然后再判断入环节点。</p> 
<h4>算法原理</h4> 
<p>要找到环的入口点同样是有结论的， 这里我们先用结论进行代码的展示。 再进行分析</p> 
<h4>算法演示</h4> 
<blockquote> 
 <p>        寻找环的入口点的算法就是先利用上面一题的方法<span style="color:#fe2c24;">先判断是否存在环</span>。 这个时候如果存在环的话fast指针和slow指针会在环内的某一个点相遇。</p> 
 <p>        然后，我们<strong><span style="color:#fe2c24;">定义一个meet指针指向这个相遇节点</span></strong>。 然后再重新<span style="color:#fe2c24;"><strong>定义一个指针指向链表的头节点</strong></span>。 让meet指针和指向头节点的指针<span style="color:#fe2c24;"><strong>同时向后遍历</strong></span>。 最后相遇的节点就是我们环的入口节点。 （原理是数学证明， 后面会进行证明。）</p> 
</blockquote> 
<p>        如图为代码贴图：</p> 
<pre><code class="language-cpp">struct ListNode *detectCycle(struct ListNode *head) 
{
    //1、定义快慢指针
    struct ListNode* slow = head;
    struct ListNode* fast = head;

    //2、循环判断是否有环
    while (fast != NULL &amp;&amp; fast-&gt;next != NULL)
    {
        //fast走两步， slow走一步。
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;

        //如果相遇， 说明有环。 然后寻找入环节点
        if (slow == fast)
        {
            //meet节点指向fast和slow相遇节点。
            struct ListNode* meet = slow;
            //让slow重新指向头节点
            slow = head;
            //如果两个指针不相等， 就让他们向后遍历。
            while (slow != meet)
            {
                slow = slow-&gt;next;
                meet = meet-&gt;next;
            }
            //最后返回相遇节点
            return meet;
        }
    }
    return NULL;  //从循环中出来说明fast走向了空， 说明没有环。
}</code></pre> 
<h4>算法原理</h4> 
<p>        <span style="color:#fe2c24;"><strong>要证明为什么从相遇位置和头节点的两个指针同时向后遍历， 相遇节点就是入环节点。</strong></span>我先给一张抽象图， 方便观察与理解：</p> 
<p><img alt="" height="566" src="https://images2.imgbox.com/53/bc/Ad698GNM_o.png" width="1198"></p> 
<blockquote> 
 <p>假设我们从图中时刻开始向后遍历。 首先， fast先进环。如下图：</p> 
 <p><img alt="" height="459" src="https://images2.imgbox.com/9f/8c/KTTPMOEV_o.png" width="807"></p> 
</blockquote> 
<p></p> 
<blockquote> 
 <p>        然后， fast继续向后走。 一直到slow进环：</p> 
 <p><img alt="" height="334" src="https://images2.imgbox.com/f4/cd/Y2x8LezM_o.png" width="608"></p> 
 <p>        <span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">好， 在这里停住， 这里有很重要的问题。 就是这个fast此时在环中已经走了几圈？ </span></strong></span></p> 
 <p>        这个圈数确定吗？答案是不确定。 因为我们并不知道这个圈的大小， 如果这个圈很小很小。 然后前面的直链很长， 那么从fast进环到slow进环这一段时间中fast就可能在环中转了很多很多圈。</p> 
</blockquote> 
<blockquote> 
 <p>        我在这画出一个例子就好懂了：</p> 
 <p><img alt="" height="917" src="https://images2.imgbox.com/4d/46/0iAqqXzy_o.png" width="1200"></p> 
 <p>        从这个例子我们可以看出， 在fast到slow这段时间内， fast在环中走的圈数是不确定的。</p> 
</blockquote> 
<p>        知道了这点后， 我们继续向下遍历， 一直到slow和fast相遇。</p> 
<p><img alt="" height="628" src="https://images2.imgbox.com/6c/aa/p9cqAKhU_o.png" width="1200"></p> 
<p>        <span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">现在， 另外一个重要的问题就是：从slow进环到被fast追上， slow转了几圈？</span></strong></span></p> 
<p>        我们看这样一个例子：</p> 
<p>        如果当slow进环的时候， fast恰好在slow前面一个位置。 如图：</p> 
<p><img alt="" height="464" src="https://images2.imgbox.com/70/fa/Q5s4Ptwd_o.png" width="904"></p> 
<p>        那么到fast追上slow的时候， slow转的了一圈吗？</p> 
<p>        我们利用方程算一下：假设<span style="color:#38d8f0;"><strong>slow行走的路程是s</strong></span>， 那么<span style="color:#38d8f0;"><strong>fast就是2s</strong></span>。 此时就有：<span style="color:#38d8f0;"><strong><span style="background-color:#f9eda6;">2s - s = C - 1;</span></strong></span></p> 
<p>得到的就是<span style="color:#38d8f0;"><strong><span style="background-color:#f9eda6;">s == C - 1</span></strong></span>； 很显然就算在这种极端情况下slow都没有走一圈， 那么其他情况下更不可能走一圈。 那么上面的问题的答案就是： <span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">从slow进环到被fast追上， slow一圈也没有转。</span></strong></span></p> 
<p>        有了这些的铺垫后。 我们再从整体出发看 ： 从两个指针开始遍历到两个指针相遇。 <strong><span style="color:#38d8f0;">设slow行走的距离是X。 那么fast指针行走的距离就是2 * X</span></strong>;  我们设从入环到节点到slow和fast相遇的位置的距离为N。如图：</p> 
<p><img alt="" height="690" src="https://images2.imgbox.com/67/97/RA7Y1L4y_o.png" width="1200"></p> 
<p>        那么就有<span style="color:#38d8f0;"><strong>N + L = X</strong></span>；所以slow行走的距离就是<span style="color:#38d8f0;"><strong>N + L</strong></span>；fast行走的距离就是<strong><span style="color:#fe2c24;"><span style="background-color:#ffd900;">2 *（N + L）</span></span></strong>；</p> 
<p>        但是， 对于fast来说， 还有另外一个式子： fast在从入环到slow入环期间，我们分析过了。 fast可能行走了几圈。 我们设为k圈。  然后从入环节点到相遇位置为N。 那么就有了fast的行走距离又可以有 ：<span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;"> L + k * C + N</span></strong></span>;</p> 
<p>        那么就有  <span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">2 *（N + L）== L + k * C + N</span></strong></span>。</p> 
<p>        计算后就是k* C - N == L;  也可以写成 ： （k - 1) * C + <span style="color:#fe2c24;"><strong>(C - N)</strong></span> ==<span style="color:#fe2c24;"><strong> L</strong></span>; </p> 
<p>        <strong><span style="color:#fe2c24;"><span style="background-color:#ffd900;">而我们的相遇节点到入环节点的距离恰好是 C - N</span></span></strong>; 所以，根据这个式子。 我们就可以证明如果从相遇节点和头节点同时向后遍历， 那么最后再次相遇时的节点就是入环节点。 </p> 
<p></p> 
<blockquote> 
 <p>        现在我们来思考这么一个问题。 如果fast指针和slow指针<span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">一开始没有从一点出发</span></strong></span>。 那么他们的相遇节点， 这个位置出发的<strong>meet指针和从头节点出发的指针还能在环的入口点相遇吗</strong>？</p> 
 <p>假设fast在slow的下一个节点出发如图：</p> 
 <p><img alt="" height="594" src="https://images2.imgbox.com/5e/37/5rNK9nih_o.png" width="1200"></p> 
</blockquote> 
<blockquote> 
 <p><img alt="" height="703" src="https://images2.imgbox.com/1d/3b/gTZaCmsZ_o.png" width="1200"></p> 
 <p>        那么我们可以重新使用方程推导一下： 从开始到两指针相遇，slow的行走距离还是<strong><span style="color:#a2e043;">L + N</span></strong>,  那么fast就有<strong><span style="color:#a2e043;"> 2 * (L + N)</span></strong>。</p> 
 <p>        而fast从开始到进环， 行走的距离变成了<span style="color:#a2e043;"><strong>L - 1</strong></span>； 从环到相遇的这段距离也是不变的， 同样是N； 而且在环中转的圈数不确定， 设<span style="color:#a2e043;"><strong>K * C</strong></span>; 那么fast的行走距离就有 :<span style="color:#a2e043;"><strong> L  - 1 + K * C + N;</strong></span></p> 
 <p>        就可以得到 : <span style="color:#a2e043;"><strong>  2 * (L + N)  == L - 1 + K * C + N</strong></span>;</p> 
 <p>        化简后就是 ：<strong><span style="color:#fe2c24;"><span style="background-color:#ffd900;">( K - 1) * C  + C - N == L + 1</span></span></strong>；</p> 
 <p>由此可以推断出结论 ：<strong><span style="color:#fe2c24;"><span style="background-color:#ffd900;"> 从meet节点出发的指针和从链表头节点出发的指针并不能相遇。</span></span></strong></p> 
</blockquote> 
<p>---------------------------------------------------------------------------------------------------------------------------------</p> 
<p>        以上， 就是本节的全部内容。</p> 
<p>       </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/583a6d0743e76dbb18e03f8eadd68d1b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【链表】：链表的带环问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f6cc793d51c9cf90b684a14afbfd1f11/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">太原理工大学大数据期末简答题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>