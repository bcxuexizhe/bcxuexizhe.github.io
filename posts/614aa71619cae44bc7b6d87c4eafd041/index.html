<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>A*（A-star）算法 定义&#43;特性&#43;原理&#43;公式&#43;Python示例代码（带详细注释） - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/614aa71619cae44bc7b6d87c4eafd041/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="A*（A-star）算法 定义&#43;特性&#43;原理&#43;公式&#43;Python示例代码（带详细注释）">
  <meta property="og:description" content="文章目录 引言定义特性基本原理及公式推导基本原理公式推导 实现步骤与代码实现实现步骤Python代码代码说明代码运行结果 应用案例优化和挑战挑战优化 结论 引言 A*算法由Peter Hart, Nils Nilsson和Bertram Raphael在1968年提出，是解决路径搜索问题的一种启发式算法。它用于在图中找到从起始节点到目标节点的最短路径，并广泛应用于游戏设计、机器人导航等领域。
定义 A*（A-star）算法是一种在图中寻找从初始节点到目标节点最短路径的启发式搜索算法。它结合了Dijkstra算法的确保性（保证找到一条最短路径）和贪心算法的高效性（快速找到目标）。A* 算法通过评估函数 f ( n ) = g ( n ) &#43; h ( n ) f(n) = g(n) &#43; h(n) f(n)=g(n)&#43;h(n) 来工作，其中 g ( n ) g(n) g(n) 是从起始点到任何顶点 n n n 的实际成本，而 h ( n ) h(n) h(n) 是从顶点 n n n 到目标的估计最低成本，通常用启发式函数来计算，这个函数需要事先设计来反映实际的地形或环境特征。理想情况下， h ( n ) h(n) h(n) 应该不会高估实际的成本，这种情况下，A* 算法保证找到一条最低成本路径。算法的性能和准确性高度依赖于启发式函数的选择。在实际应用中，A* 算法广泛应用于各类路径规划问题，如机器人导航、地图定位服务和游戏中的AI路径寻找等场景。通过适当选择和调整启发式函数，A* 算法能够在复杂的环境中有效地寻找最短路径，同时保持计算上的可行性和效率。
特性 A* 算法具有以下显著特性：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-14T23:25:54+08:00">
    <meta property="article:modified_time" content="2024-04-14T23:25:54+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">A*（A-star）算法 定义&#43;特性&#43;原理&#43;公式&#43;Python示例代码（带详细注释）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_5" rel="nofollow">引言</a></li><li><a href="#_7" rel="nofollow">定义</a></li><li><a href="#_9" rel="nofollow">特性</a></li><li><a href="#_18" rel="nofollow">基本原理及公式推导</a></li><li><ul><li><a href="#_19" rel="nofollow">基本原理</a></li><li><a href="#_28" rel="nofollow">公式推导</a></li></ul> 
   </li><li><a href="#_55" rel="nofollow">实现步骤与代码实现</a></li><li><ul><li><a href="#_56" rel="nofollow">实现步骤</a></li><li><a href="#Python_79" rel="nofollow">Python代码</a></li><li><a href="#_227" rel="nofollow">代码说明</a></li><li><a href="#_234" rel="nofollow">代码运行结果</a></li></ul> 
   </li><li><a href="#_242" rel="nofollow">应用案例</a></li><li><a href="#_250" rel="nofollow">优化和挑战</a></li><li><ul><li><a href="#_251" rel="nofollow">挑战</a></li><li><a href="#_258" rel="nofollow">优化</a></li></ul> 
   </li><li><a href="#_266" rel="nofollow">结论</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h3><a id="_5"></a>引言</h3> 
<p>A*算法由Peter Hart, Nils Nilsson和Bertram Raphael在1968年提出，是解决路径搜索问题的一种启发式算法。它用于在图中找到从起始节点到目标节点的最短路径，并广泛应用于游戏设计、机器人导航等领域。</p> 
<h3><a id="_7"></a>定义</h3> 
<p>A*（A-star）算法是一种在图中寻找从初始节点到目标节点最短路径的启发式搜索算法。它结合了Dijkstra算法的确保性（保证找到一条最短路径）和贪心算法的高效性（快速找到目标）。A* 算法通过评估函数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
         = 
        
       
         g 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
         + 
        
       
         h 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        f(n) = g(n) + h(n) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> 来工作，其中 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         g 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        g(n) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> 是从起始点到任何顶点 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> 的实际成本，而 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         h 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        h(n) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> 是从顶点 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> 到目标的估计最低成本，通常用启发式函数来计算，这个函数需要事先设计来反映实际的地形或环境特征。理想情况下，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         h 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        h(n) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> 应该不会高估实际的成本，这种情况下，A* 算法保证找到一条最低成本路径。算法的性能和准确性高度依赖于启发式函数的选择。在实际应用中，A* 算法广泛应用于各类路径规划问题，如机器人导航、地图定位服务和游戏中的AI路径寻找等场景。通过适当选择和调整启发式函数，A* 算法能够在复杂的环境中有效地寻找最短路径，同时保持计算上的可行性和效率。</p> 
<h3><a id="_9"></a>特性</h3> 
<p>A* 算法具有以下显著特性：</p> 
<ol><li><strong>最优性</strong>：当启发式函数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          h 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
       
         h(n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> 是可采纳的（即不会高估从任一节点到目标的成本时），A* 算法保证找到最短路径。</li><li><strong>完备性</strong>：只要有解存在，A* 算法总能找到解，前提是节点扩展没有限制且启发式函数不返回无穷大值。</li><li><strong>高效率</strong>：通过启发式函数有效指导搜索方向，A* 算法通常比其他简单的搜索算法如广度优先或深度优先搜索更快地找到最短路径。</li><li><strong>灵活性</strong>：启发式函数的选择可以根据具体的应用场景灵活调整，影响算法的效率和行为。</li><li><strong>普适性</strong>：适用于任何能够用图表示的路径搜索问题，从机器人路径规划到游戏设计中的AI挑战。</li><li><strong>适应性</strong>：能够根据实时反馈调整启发式评估，适应于动态变化的环境中。</li></ol> 
<h3><a id="_18"></a>基本原理及公式推导</h3> 
<h4><a id="_19"></a>基本原理</h4> 
<p>A*算法是一种在图中寻找从起始点到目标点最短路径的启发式搜索算法。该算法使用三个主要函数：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         g 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        g(n) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         h 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        h(n) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>，和 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        f(n) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> 来评估路径的优劣。</p> 
<ul><li><strong><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           g 
          
         
           ( 
          
         
           n 
          
         
           ) 
          
         
        
          g(n) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></strong>：从起始点到任何节点 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          n 
         
        
       
         n 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> 的实际路径成本。</li><li><strong><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           h 
          
         
           ( 
          
         
           n 
          
         
           ) 
          
         
        
          h(n) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></strong>：从节点 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          n 
         
        
       
         n 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> 到目标的预估成本，这是一个启发式估计，通常是从 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          n 
         
        
       
         n 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> 到目标的直线距离。</li><li><strong><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           f 
          
         
           ( 
          
         
           n 
          
         
           ) 
          
         
        
          f(n) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></strong>：节点 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          n 
         
        
       
         n 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> 的总成本估算，计算为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          f 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          = 
         
        
          g 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          + 
         
        
          h 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
       
         f(n) = g(n) + h(n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>。</li></ul> 
<p>这些评价指标共同帮助算法决定在图中的哪个方向上继续搜索，以期达到最有效的路径搜索。</p> 
<h4><a id="_28"></a>公式推导</h4> 
<ol><li> <p><strong>启发式函数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            h 
           
          
            ( 
           
          
            n 
           
          
            ) 
           
          
         
           h(n) 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> 的定义</strong></p> <p>对于网格中的点 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           ( 
          
         
           x 
          
         
           , 
          
         
           y 
          
         
           ) 
          
         
        
          (x, y) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mclose">)</span></span></span></span></span>，若目标点是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           ( 
          
          
          
            x 
           
           
           
             g 
            
           
             o 
            
           
             a 
            
           
             l 
            
           
          
         
           , 
          
          
          
            y 
           
           
           
             g 
            
           
             o 
            
           
             a 
            
           
             l 
            
           
          
         
           ) 
          
         
        
          (x_{goal}, y_{goal}) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0361em; vertical-align: -0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>，一个常用的启发式是欧几里得距离：</p> <p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            h 
           
          
            ( 
           
          
            n 
           
          
            ) 
           
          
            = 
           
           
            
            
              ( 
             
            
              x 
             
            
              − 
             
             
             
               x 
              
              
              
                g 
               
              
                o 
               
              
                a 
               
              
                l 
               
              
             
             
             
               ) 
              
             
               2 
              
             
            
              + 
             
            
              ( 
             
            
              y 
             
            
              − 
             
             
             
               y 
              
              
              
                g 
               
              
                o 
               
              
                a 
               
              
                l 
               
              
             
             
             
               ) 
              
             
               2 
              
             
            
           
          
         
           h(n) = \sqrt{(x - x_{goal})^2 + (y - y_{goal})^2} 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.84em; vertical-align: -0.5742em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.2658em;"><span class="svg-align" style="top: -3.8em;"><span class="pstrut" style="height: 3.8em;"></span><span class="mord" style="padding-left: 1em;"><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.7401em;"><span class="" style="top: -2.989em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right: 0.0197em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.7401em;"><span class="" style="top: -2.989em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.2258em;"><span class="pstrut" style="height: 3.8em;"></span><span class="hide-tail" style="min-width: 1.02em; height: 1.88em;"> 
              <svg width="400em" height="1.88em" viewbox="0 0 400000 1944" preserveaspectratio="xMinYMin slice"> 
               <path d="M983 90
l0 -0
c4,-6.7,10,-10,18,-10 H400000v40
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M1001 80h400000v40h-400000z"></path> 
              </svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.5742em;"><span class=""></span></span></span></span></span></span></span></span></span></span></p> </li><li> <p><strong>成本函数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            g 
           
          
            ( 
           
          
            n 
           
          
            ) 
           
          
         
           g(n) 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> 的计算</strong></p> <p>每当我们从起始点通过路径移动到一个新节点，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           g 
          
         
           ( 
          
         
           n 
          
         
           ) 
          
         
        
          g(n) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> 将累加上到达该节点的移动成本。例如，如果每步移动成本为 1，则：</p> <p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            g 
           
          
            ( 
           
           
           
             n 
            
            
            
              n 
             
            
              e 
             
            
              w 
             
            
           
          
            ) 
           
          
            = 
           
          
            g 
           
          
            ( 
           
           
           
             n 
            
            
            
              c 
             
            
              u 
             
            
              r 
             
            
              r 
             
            
              e 
             
            
              n 
             
            
              t 
             
            
           
          
            ) 
           
          
            + 
           
          
            1 
           
          
         
           g(n_{new}) = g(n_{current}) + 1 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right: 0.0269em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.2806em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">rre</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span></span></p> </li><li> <p><strong>总评价函数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            f 
           
          
            ( 
           
          
            n 
           
          
            ) 
           
          
         
           f(n) 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> 的计算</strong></p> <p>结合上述两个值，我们得到 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           f 
          
         
           ( 
          
         
           n 
          
         
           ) 
          
         
        
          f(n) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> 来评价节点的总成本，以决定哪些节点应该被优先考虑：</p> <p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            f 
           
          
            ( 
           
          
            n 
           
          
            ) 
           
          
            = 
           
          
            g 
           
          
            ( 
           
          
            n 
           
          
            ) 
           
          
            + 
           
          
            h 
           
          
            ( 
           
          
            n 
           
          
            ) 
           
          
         
           f(n) = g(n) + h(n) 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></span></p> </li></ol> 
<h3><a id="_55"></a>实现步骤与代码实现</h3> 
<h4><a id="_56"></a>实现步骤</h4> 
<ol><li> <p><strong>初始化</strong>：</p> 
  <ul><li>创建起始节点和目标节点，初始化 g、h 和 f 值。</li><li>创建开放列表（使用优先队列）和封闭列表，将起始节点加入开放列表。</li></ul> </li><li> <p><strong>节点处理</strong>：</p> 
  <ul><li>从开放列表中取出 f 值最小的节点作为当前节点。</li><li>检查当前节点是否为目标节点。如果是，回溯路径并返回。</li></ul> </li><li> <p><strong>邻接节点探索</strong>：</p> 
  <ul><li>计算当前节点的四个方向的邻接节点（上、下、左、右）。</li><li>对于每个邻接节点，检查是否为有效节点（即在网格范围内且不是障碍物）。</li></ul> </li><li> <p><strong>更新邻接节点</strong>：</p> 
  <ul><li>对于每个有效的邻接节点，如果它不在封闭列表中，则计算它的 g、h 和 f 值。</li><li>使用 <code>add_to_open</code> 函数判断是否将邻接节点添加到开放列表。</li></ul> </li><li> <p><strong>移动到封闭列表</strong>：</p> 
  <ul><li>将当前节点移入封闭列表。</li><li>如果开放列表为空，说明没有找到路径，返回失败。</li></ul> </li><li> <p><strong>重复过程</strong>：</p> 
  <ul><li>重复步骤 2-5，直到找到目标节点或开放列表为空</li></ul> </li></ol> 
<h4><a id="Python_79"></a>Python代码</h4> 
<pre><code class="prism language-python"><span class="token keyword">import</span> heapq
<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np

<span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""节点类表示搜索树中的每一个点。"""</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> parent<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> position<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>parent <span class="token operator">=</span> parent        <span class="token comment"># 该节点的父节点</span>
        self<span class="token punctuation">.</span>position <span class="token operator">=</span> position    <span class="token comment"># 节点在迷宫中的坐标位置</span>
        self<span class="token punctuation">.</span>g <span class="token operator">=</span> <span class="token number">0</span>                  <span class="token comment"># G值：从起点到当前节点的成本</span>
        self<span class="token punctuation">.</span>h <span class="token operator">=</span> <span class="token number">0</span>                  <span class="token comment"># H值：当前节点到目标点的估计成本</span>
        self<span class="token punctuation">.</span>f <span class="token operator">=</span> <span class="token number">0</span>                  <span class="token comment"># F值：G值与H值的和，即节点的总评估成本</span>

    <span class="token comment"># 比较两个节点位置是否相同</span>
    <span class="token keyword">def</span> <span class="token function">__eq__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>position <span class="token operator">==</span> other<span class="token punctuation">.</span>position

    <span class="token comment"># 定义小于操作，以便在优先队列中进行比较</span>
    <span class="token keyword">def</span> <span class="token function">__lt__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>f <span class="token operator">&lt;</span> other<span class="token punctuation">.</span>f
    

<span class="token keyword">def</span> <span class="token function">astar</span><span class="token punctuation">(</span>maze<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""A*算法实现，用于在迷宫中找到从起点到终点的最短路径。"""</span>
    start_node <span class="token operator">=</span> Node<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">,</span> start<span class="token punctuation">)</span>  <span class="token comment"># 创建起始节点</span>
    end_node <span class="token operator">=</span> Node<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span>      <span class="token comment"># 创建终点节点</span>

    open_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>                  <span class="token comment"># 开放列表用于存储待访问的节点</span>
    closed_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>                <span class="token comment"># 封闭列表用于存储已访问的节点</span>

    heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>open_list<span class="token punctuation">,</span> <span class="token punctuation">(</span>start_node<span class="token punctuation">.</span>f<span class="token punctuation">,</span> start_node<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 将起始节点添加到开放列表</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"添加起始节点到开放列表。"</span><span class="token punctuation">)</span>

    <span class="token comment"># 当开放列表非空时，循环执行</span>
    <span class="token keyword">while</span> open_list<span class="token punctuation">:</span>
        current_node <span class="token operator">=</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>open_list<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment"># 弹出并返回开放列表中 f 值最小的节点</span>
        closed_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>current_node<span class="token punctuation">)</span>            <span class="token comment"># 将当前节点添加到封闭列表</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"当前节点: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>current_node<span class="token punctuation">.</span>position<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>

        <span class="token comment"># 如果当前节点是目标节点，则回溯路径</span>
        <span class="token keyword">if</span> current_node <span class="token operator">==</span> end_node<span class="token punctuation">:</span>
            path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
            <span class="token keyword">while</span> current_node<span class="token punctuation">:</span>
                path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>current_node<span class="token punctuation">.</span>position<span class="token punctuation">)</span>
                current_node <span class="token operator">=</span> current_node<span class="token punctuation">.</span>parent
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"找到目标节点，返回路径。"</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> path<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment"># 返回反向路径，即从起点到终点的路径</span>

        <span class="token comment"># 获取当前节点周围的相邻节点</span>
        <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=</span> current_node<span class="token punctuation">.</span>position
        neighbors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

        <span class="token comment"># 遍历相邻节点</span>
        <span class="token keyword">for</span> <span class="token builtin">next</span> <span class="token keyword">in</span> neighbors<span class="token punctuation">:</span>
            <span class="token comment"># 确保相邻节点在迷宫范围内，且不是障碍物</span>
            <span class="token keyword">if</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> <span class="token builtin">next</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> maze<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">and</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> <span class="token builtin">next</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> maze<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> maze<span class="token punctuation">[</span><span class="token builtin">next</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">next</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
                    <span class="token keyword">continue</span>
                neighbor <span class="token operator">=</span> Node<span class="token punctuation">(</span>current_node<span class="token punctuation">,</span> <span class="token builtin">next</span><span class="token punctuation">)</span>  <span class="token comment"># 创建相邻节点</span>
                <span class="token comment"># 如果相邻节点已在封闭列表中，跳过不处理</span>
                <span class="token keyword">if</span> neighbor <span class="token keyword">in</span> closed_list<span class="token punctuation">:</span>
                    <span class="token keyword">continue</span>
                neighbor<span class="token punctuation">.</span>g <span class="token operator">=</span> current_node<span class="token punctuation">.</span>g <span class="token operator">+</span> <span class="token number">1</span>  <span class="token comment"># 计算相邻节点的 G 值</span>
                neighbor<span class="token punctuation">.</span>h <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end_node<span class="token punctuation">.</span>position<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token builtin">next</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end_node<span class="token punctuation">.</span>position<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token builtin">next</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment"># 计算 H 值</span>
                neighbor<span class="token punctuation">.</span>f <span class="token operator">=</span> neighbor<span class="token punctuation">.</span>g <span class="token operator">+</span> neighbor<span class="token punctuation">.</span>h  <span class="token comment"># 计算 F 值</span>

                <span class="token comment"># 如果相邻节点的新 F 值较小，则将其添加到开放列表</span>
                <span class="token keyword">if</span> add_to_open<span class="token punctuation">(</span>open_list<span class="token punctuation">,</span> neighbor<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>open_list<span class="token punctuation">,</span> <span class="token punctuation">(</span>neighbor<span class="token punctuation">.</span>f<span class="token punctuation">,</span> neighbor<span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"添加节点 </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>neighbor<span class="token punctuation">.</span>position<span class="token punctuation">}</span></span><span class="token string"> 到开放列表。"</span></span><span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"节点 </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span><span class="token builtin">next</span><span class="token punctuation">}</span></span><span class="token string"> 越界或为障碍。"</span></span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> <span class="token boolean">None</span>  <span class="token comment"># 如果没有找到路径，返回 None</span>

<span class="token keyword">def</span> <span class="token function">add_to_open</span><span class="token punctuation">(</span>open_list<span class="token punctuation">,</span> neighbor<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""检查并添加节点到开放列表。"""</span>
    <span class="token keyword">for</span> node <span class="token keyword">in</span> open_list<span class="token punctuation">:</span>
        <span class="token comment"># 如果开放列表中已存在相同位置的节点且 G 值更低，不添加该节点</span>
        <span class="token keyword">if</span> neighbor <span class="token operator">==</span> node<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">and</span> neighbor<span class="token punctuation">.</span>g <span class="token operator">&gt;</span> node<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>g<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
    <span class="token keyword">return</span> <span class="token boolean">True</span>  <span class="token comment"># 如果不存在，则返回 True 以便添加该节点到开放列表</span>

<span class="token keyword">def</span> <span class="token function">visualize_path</span><span class="token punctuation">(</span>maze<span class="token punctuation">,</span> path<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""将找到的路径可视化在迷宫上。"""</span>
    maze_copy <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>maze<span class="token punctuation">)</span>
    <span class="token keyword">for</span> step <span class="token keyword">in</span> path<span class="token punctuation">:</span>
        maze_copy<span class="token punctuation">[</span>step<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0.5</span>  <span class="token comment"># 标记路径上的点</span>
    plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment"># 将迷宫中的通道显示为黑色，障碍物为白色</span>
    plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>maze_copy<span class="token punctuation">,</span> cmap<span class="token operator">=</span><span class="token string">'hot'</span><span class="token punctuation">,</span> interpolation<span class="token operator">=</span><span class="token string">'nearest'</span><span class="token punctuation">)</span>
    <span class="token comment"># 提取路径上的x和y坐标</span>
    path_x <span class="token operator">=</span> <span class="token punctuation">[</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> p <span class="token keyword">in</span> path<span class="token punctuation">]</span>  <span class="token comment"># 列坐标</span>
    path_y <span class="token operator">=</span> <span class="token punctuation">[</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> p <span class="token keyword">in</span> path<span class="token punctuation">]</span>  <span class="token comment"># 行坐标</span>
    <span class="token comment"># 绘制路径</span>
    plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>path_x<span class="token punctuation">,</span> path_y<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'orange'</span><span class="token punctuation">,</span> linewidth<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token comment"># 绘制起点和终点</span>
    start_x<span class="token punctuation">,</span> start_y <span class="token operator">=</span> start<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> start<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    end_x<span class="token punctuation">,</span> end_y <span class="token operator">=</span> end<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> end<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span><span class="token punctuation">[</span>start_x<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>start_y<span class="token punctuation">]</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'green'</span><span class="token punctuation">,</span> s<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'Start'</span><span class="token punctuation">,</span> zorder<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>  <span class="token comment"># 起点为绿色圆点</span>
    plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span><span class="token punctuation">[</span>end_x<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>end_y<span class="token punctuation">]</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'red'</span><span class="token punctuation">,</span> s<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'End'</span><span class="token punctuation">,</span> zorder<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>  <span class="token comment"># 终点为红色圆点</span>
    <span class="token comment"># 添加图例</span>
    plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># # 隐藏坐标轴</span>
    <span class="token comment"># plt.axis('off')</span>
    <span class="token comment"># 显示图像</span>
    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 设定迷宫的尺寸</span>
maze_size <span class="token operator">=</span> <span class="token number">100</span>

<span class="token comment"># 创建一个空的迷宫，全部设置为0（表示可通过）</span>
maze <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>maze_size<span class="token punctuation">,</span> maze_size<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># 定义几个障碍物区块，每个障碍物区块是一个矩形</span>
obstacle_blocks <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment"># (y起始, x起始, 高度, 宽度)</span>
    <span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span>

<span class="token comment"># 在迷宫中设置障碍物</span>
<span class="token keyword">for</span> y_start<span class="token punctuation">,</span> x_start<span class="token punctuation">,</span> height<span class="token punctuation">,</span> width <span class="token keyword">in</span> obstacle_blocks<span class="token punctuation">:</span>
    maze<span class="token punctuation">[</span>y_start<span class="token punctuation">:</span>y_start<span class="token operator">+</span>height<span class="token punctuation">,</span> x_start<span class="token punctuation">:</span>x_start<span class="token operator">+</span>width<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>

<span class="token comment"># 设定起始点和终点</span>
start <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
end <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">92</span><span class="token punctuation">,</span> <span class="token number">93</span><span class="token punctuation">)</span>

<span class="token comment"># 确保起始点和终点不是障碍物</span>
maze<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
maze<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>

<span class="token comment"># 输出迷宫的一部分，以确认障碍物的设置</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"迷宫左上角10x10区域的视图:"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>maze<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

path <span class="token operator">=</span> astar<span class="token punctuation">(</span>maze<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span>
<span class="token keyword">if</span> path<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"路径已找到："</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span>
    visualize_path<span class="token punctuation">(</span>maze<span class="token punctuation">,</span> path<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"没有找到路径。"</span><span class="token punctuation">)</span>

</code></pre> 
<h4><a id="_227"></a>代码说明</h4> 
<p>本代码实现了 A* 算法，它是一种在网格中找到最短路径的启发式搜索算法。我们定义了一个 <code>Node</code> 类来表示搜索中的每个节点，其中包括节点的位置、从起点到该节点的成本（g）、从该节点到终点的估算成本（h）和两者的总和（f）。以下是代码的主要部分解释：</p> 
<ul><li><strong>Node 类</strong>：包含父节点、位置、g、h 和 f 值。重载了 <code>__eq__</code> 以比较节点位置，<code>__lt__</code> 以在优先队列中比较节点。</li><li><strong>astar 函数</strong>：实现 A* 搜索算法，维护开放列表和封闭列表，从起始点开始搜索直到达到终点或开放列表为空。</li><li><strong>add_to_open 函数</strong>：辅助函数，用于决定是否将一个节点添加到开放列表。</li><li><strong>visualize_path 函数</strong>：用于在网格上可视化找到的路径。</li></ul> 
<h4><a id="_234"></a>代码运行结果</h4> 
<p><img src="https://images2.imgbox.com/8d/a1/wTwTsTim_o.png" alt="在这里插入图片描述"><br> 该图展示了使用 A* 算法在一个二维网格迷宫中的路径规划结果。迷宫中白色的矩形区域代表障碍物，黑色背景代表可以通行的空间。路径以橙色线条表示，它从左上角的绿点（起点）开始，穿越迷宫，绕过障碍物，最终到达右下角的红点（终点）。该可视化图像清楚地展示了算法从起始位置到目标位置寻找最短路径的过程，并且成功避开了所有障碍。</p> 
<h3><a id="_242"></a>应用案例</h3> 
<p>A* 算法在多种领域中的应用包括：</p> 
<ol><li><strong>地图导航系统</strong>：A* 算法广泛应用于 GPS 和在线地图服务中，用于计算从一个地点到另一个地点的最短路径。</li><li><strong>视频游戏</strong>：在游戏开发中，A* 算法用于控制人工智能（AI）角色的路径寻找，使其能够高效地移动到目标位置。</li><li><strong>机器人路径规划</strong>：机器人利用 A* 算法规划避开障碍物的最优移动路径，确保机器人从起点安全、有效地移动到终点。</li><li><strong>网络路由</strong>：网络技术中使用 A* 算法来优化数据包的传输路径，从而减少延迟和提高传输效率。</li><li><strong>图形用户界面设计</strong>：在图形软件中，A* 可用于自动排线或连接元件，如电路设计和流程图软件中的最佳布线。</li><li><strong>数据分析</strong>：在数据科学中，A* 算法可帮助分析和找到数据点之间的最短路径或最佳连接方式，用于复杂网络分析。</li></ol> 
<h3><a id="_250"></a>优化和挑战</h3> 
<h4><a id="_251"></a>挑战</h4> 
<ol><li><strong>启发式函数的选择</strong>：A* 算法的效率和效果高度依赖于启发式函数<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          h 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
       
         h(n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> 的准确性。选择一个不合适的启发式函数可能导致路径搜索效率低下，或者在最坏的情况下，找不到解。</li><li><strong>内存消耗</strong>：A* 算法需要维护开放列表和封闭列表，存储大量的节点信息，这在处理大规模图或复杂环境时可能会消耗大量内存。</li><li><strong>动态环境适应性</strong>：在动态变化的环境中，如移动障碍物或实时更新的地图数据，A* 算法需要不断重新计算，这可能会影响其实时性能。</li><li><strong>计算复杂度</strong>：在图特别大或特别密集的情况下，即使是 A* 算法也可能因为需要评估的节点过多而导致计算量大和速度慢。</li></ol> 
<h4><a id="_258"></a>优化</h4> 
<ol><li><strong>改进启发式函数</strong>：研究和开发更加准确的启发式评估方法，以更好地预测实际成本，提高算法的搜索效率和减少搜索空间。</li><li><strong>内存管理优化</strong>：实施更高效的数据结构来管理开放和封闭列表，如使用斐波那契堆等优化过的优先队列，以减少内存使用和提高操作效率。</li><li><strong>增量式搜索</strong>：对于动态环境的应用，开发基于 A* 的增量式搜索算法，如 D* Lite，能够在环境变化时快速更新已有路径而不是重新计算整条路径。</li><li><strong>并行处理</strong>：利用现代多核处理器的能力，通过并行化处理来提高 A* 算法的计算效率，尤其是在处理大规模数据集时。</li></ol> 
<h3><a id="_266"></a>结论</h3> 
<p>A* 算法是一种强大且灵活的路径搜索算法，适用于各种从点A到点B的最短路径搜索问题。通过合理选择启发式函数，A* 算法不仅能保证找到最短路径，还能在执行过程中保持高效。面对复杂的实际应用场景，适当的优化和算法调整可以进一步提升其性能，满足更广泛的应用需求。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7ee032041ccaeca4a077a4a2c10b83ac/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HBuilder X运行项目到微信开发者工具调试和发布Uniapp小程序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9bff4bd310a892a11c188eb64f7f46b1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">从UUID到替代方案：探索Java中唯一ID生成的多种方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>