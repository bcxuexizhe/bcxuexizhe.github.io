<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】详解队列 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/46ebb4bda2cbdfa76a6f790f9f0f8b6d/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【数据结构】详解队列">
  <meta property="og:description" content="现在我们来掌握一下队列！如果有对往期知识有不足地方，可翻阅之前文章哦！
个人主页：小八哥向前冲~-CSDN博客
所属专栏：数据结构【c语言版】_小八哥向前冲~的博客-CSDN博客
栈和队列的实现其实都是对你顺序表和链表的检验，只有一些新的概念罢了！
哈哈！不信就往下看吧！！！
目录
什么是队列？
扩展--循环队列
队列的实现
初始化
队列的插入
队列的判空
队列的删除
队列的尾数据
队列的头数据
队列的销毁
总代码
Queue.h文件
Queue.c文件
什么是队列？ 队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先进先出 FIFO(First In First Out) 。入队列：进行插入操作的一端称为队尾。出队列：进行删除操作的一端称为队头。 上图理解：
注意：遵循先进先出的原则！这个原则就是区分栈（后进先出）和队列（先进先出）方法！
我们来看看一个队列需要有的最基本要求：详情见--queue - C&#43;&#43; Reference
了解了队列的基本概念，我们来扩展一下！
扩展--循环队列 生活中队列很常用，而在实际的生活中，有时我们会用到循环队列。
循环队列它也有一些应用场景。如：在操作系统中的生产者消费者模型（这个我们后续提到！）
在这种问题中，环形队列可以使用数组实现，也可以使用循环链表实现。
我们图上了解：
空的环形队列：
满的环形队列：
注意：为了能区别Q.front=Q.rear为队满还是队空，我们通常认为Q.rear&#43;1=Q.front为满！
ok!了解了队列的基本，我们来巩固一下：
3.循环队列的存储空间为 Q(1:100) ，初始状态为 front=rear=100 。经过一系列正常的入队与退队操作 后， front=rear=99 ，则循环队列中的元素个数为（ ）
A .1
B.2
C.99
D.0或者100
4.以下( )不是队列的基本运算？
A.从队尾插入一个新元素
B.从队列中删除第i个元素
C.判断一个队列是否为空
D.读取队头元素的值
5.现有一循环队列，其队头指针为front，队尾指针为rear；循环队列长度为N。其队内有效长度为( )？(假设 队头不存放数据)
A.(rear - front &#43; N) % N &#43; 1">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-13T22:55:23+08:00">
    <meta property="article:modified_time" content="2024-05-13T22:55:23+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】详解队列</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>现在我们来掌握一下队列！如果有对往期知识有不足地方，可翻阅之前文章哦！</p> 
<blockquote> 
 <p>个人主页：<a href="https://blog.csdn.net/Qiwaw?spm=1000.2115.3001.5343" title="小八哥向前冲~-CSDN博客">小八哥向前冲~-CSDN博客</a></p> 
 <p>所属专栏：<a href="https://blog.csdn.net/qiwaw/category_12656458.html" title="数据结构【c语言版】_小八哥向前冲~的博客-CSDN博客">数据结构【c语言版】_小八哥向前冲~的博客-CSDN博客</a></p> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/98/cc/UAxlWNOz_o.jpg"></p> 
</blockquote> 
<p>栈和队列的实现其实都是对你顺序表和链表的检验，只有一些新的概念罢了！</p> 
<p>哈哈！不信就往下看吧！！！</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%9F%E5%88%97%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%9F%E5%88%97%EF%BC%9F" rel="nofollow">什么是队列？</a></p> 
<p id="%E6%89%A9%E5%B1%95--%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97-toc" style="margin-left:0px;"><a href="#%E6%89%A9%E5%B1%95--%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97" rel="nofollow">扩展--循环队列</a></p> 
<p id="%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">队列的实现</a></p> 
<p id="%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">初始化</a></p> 
<p id="%E9%98%9F%E5%88%97%E7%9A%84%E6%8F%92%E5%85%A5-toc" style="margin-left:40px;"><a href="#%E9%98%9F%E5%88%97%E7%9A%84%E6%8F%92%E5%85%A5" rel="nofollow">队列的插入</a></p> 
<p id="%E9%98%9F%E5%88%97%E7%9A%84%E5%88%A4%E7%A9%BA-toc" style="margin-left:40px;"><a href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%88%A4%E7%A9%BA" rel="nofollow">队列的判空</a></p> 
<p id="%E9%98%9F%E5%88%97%E7%9A%84%E5%88%A0%E9%99%A4-toc" style="margin-left:40px;"><a href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%88%A0%E9%99%A4" rel="nofollow">队列的删除</a></p> 
<p id="%E9%98%9F%E5%88%97%E7%9A%84%E5%B0%BE%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%B0%BE%E6%95%B0%E6%8D%AE" rel="nofollow">队列的尾数据</a></p> 
<p id="%E9%98%9F%E5%88%97%E7%9A%84%E5%A4%B4%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%A4%B4%E6%95%B0%E6%8D%AE" rel="nofollow">队列的头数据</a></p> 
<p id="%E9%98%9F%E5%88%97%E7%9A%84%E9%94%80%E6%AF%81-toc" style="margin-left:40px;"><a href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%94%80%E6%AF%81" rel="nofollow">队列的销毁</a></p> 
<p id="%E6%80%BB%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E4%BB%A3%E7%A0%81" rel="nofollow">总代码</a></p> 
<p id="Queue.h%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#Queue.h%E6%96%87%E4%BB%B6" rel="nofollow">Queue.h文件</a></p> 
<p id="Queue.c%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#Queue.c%E6%96%87%E4%BB%B6" rel="nofollow">Queue.c文件</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%9F%E5%88%97%EF%BC%9F">什么是队列？</h2> 
<blockquote> 
 <ul><li>队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的<span style="color:#fe2c24;">特殊线性表</span>，队列具有<span style="color:#fe2c24;">先进先出 FIFO(First In First Out) </span>。</li><li>入队列：进行插入操作的一端称为队尾。</li><li>出队列：进行删除操作的一端称为队头。</li></ul> 
</blockquote> 
<p>上图理解：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/45/24/r1qIrhtH_o.png"></p> 
<p><span style="color:#fe2c24;"><strong>注意：遵循先进先出的原则！这个原则就是区分栈（后进先出）和队列（先进先出）方法！</strong></span></p> 
<p>我们来看看一个队列需要有的最基本要求：详情见--<a href="https://legacy.cplusplus.com/reference/queue/queue/?kw=queue" rel="nofollow" title="queue - C++ Reference">queue - C++ Reference</a></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/fd/8d/nsMf2uxJ_o.png"></p> 
<p>了解了队列的基本概念，我们来扩展一下！</p> 
<h2 id="%E6%89%A9%E5%B1%95--%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97">扩展--循环队列</h2> 
<p>生活中队列很常用，而在实际的生活中，有时我们会用到循环队列。</p> 
<p>循环队列它也有一些应用场景。如：<span style="background-color:#c7e6ea;">在操作系统中的生产者消费者模型（这个我们后续提到！）</span></p> 
<p>在这种问题中，<span style="color:#fe2c24;">环形队列可以使用数组实现，也可以使用循环链表实现</span>。</p> 
<p>我们图上了解：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0f/26/pOydAvQD_o.png"></p> 
<p><span style="color:#fe2c24;"><strong>空的环形队列</strong></span>：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c8/a0/yjwjBVfj_o.png"></p> 
<p><strong><span style="color:#fe2c24;">满的环形队列：</span></strong></p> 
<p><img alt="" src="https://images2.imgbox.com/7e/51/AD4ohcSn_o.png"></p> 
<p><span style="background-color:#38d8f0;">注意：为了能区别Q.front=Q.rear为队满还是队空，我们通常认为Q.rear+1=Q.front为满！</span></p> 
<p>ok!了解了队列的基本，我们来巩固一下：</p> 
<blockquote> 
 <p>3.循环队列的存储空间为 Q(1:100) ，初始状态为 front=rear=100 。经过一系列正常的入队与退队操作 后， front=rear=99 ，则循环队列中的元素个数为（ ）</p> 
 <p>A .1</p> 
 <p>B.2</p> 
 <p>C.99</p> 
 <p>D.0或者100</p> 
 <p>4.以下( )不是队列的基本运算？</p> 
 <p>A.从队尾插入一个新元素</p> 
 <p>B.从队列中删除第i个元素</p> 
 <p>C.判断一个队列是否为空</p> 
 <p>D.读取队头元素的值</p> 
 <p>5.现有一循环队列，其队头指针为front，队尾指针为rear；循环队列长度为N。其队内有效长度为( )？(假设 队头不存放数据)</p> 
 <p>A.(rear - front + N) % N + 1</p> 
 <p>B.(rear - front + N) % N</p> 
 <p>C.ear - front) % (N + 1)</p> 
 <p>D.(rear - front + N) % (N - 1)</p> 
</blockquote> 
<p><span style="background-color:#fbd4d0;">答案：3.D  4.B   5.B</span></p> 
<p><span style="background-color:#cbe0f1;">参考：</span></p> 
<p><span style="background-color:#cbe0f1;">3.我们肯定知道元素个数为空时，front=rear，可当front=rear时，也有元素为满的情况！</span></p> 
<p><span style="background-color:#c7e6ea;">5.因为是循环队列，单纯尾指针和头指针相减并不能求出总长。</span></p> 
<p>现在我们来实现一下队列（<span style="color:#fe2c24;"><strong>按照一个队列的基本要求</strong></span>）。</p> 
<p><span style="background-color:#eaf4fc;">当然，队列像栈一样，都可以写成链表和顺序表的底层！这里主要了解链表！</span></p> 
<h2 id="%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0">队列的实现</h2> 
<p>还是老样子：我们创建Queue.h文件声明各种变量和函数，创建Queue.c文件来将函数实现。</p> 
<p><span style="color:#fe2c24;"><strong>思路：</strong></span></p> 
<p> 我们在实现一个函数时，要先弄清楚参数。</p> 
<p>既然底层是链表，那么就得<span style="color:#fe2c24;"><strong>定义节点</strong></span>！</p> 
<pre><code class="language-cpp">typedef int QDataType;
//队列节点
typedef struct QueueNode
{
	struct QueueNode* next;
	QDataType val;
}QNode;</code></pre> 
<p>我们来看看我们的底层逻辑：<strong><span style="color:#fe2c24;">需要头指针记录头，尾指针记录尾，一个计数变量</span></strong>。</p> 
<p><span style="background-color:#edf6e8;">既然需要这几个变量时刻记录，不如我们直接定义一个结构体来管理这些参数。</span></p> 
<p><strong>作用：</strong></p> 
<p><span style="color:#fe2c24;">这里将参数管理起来可以避免插入和删除函数参数二级指针的使用！（下面会有体现）</span>。</p> 
<pre><code class="language-cpp">typedef struct Queue
{
	QNode* phead;
	QNode* ptail;
	int size;
}Queue;
</code></pre> 
<p>ok! 我们来将这些函数一一实现。</p> 
<h3 id="%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</h3> 
<p><span style="background-color:#fbd4d0;">我们得先将记录的参数初始化一下，以便后续参数的更新！</span></p> 
<pre><code class="language-cpp">//队列的初始化
void QInit(Queue* p)
{
	assert(p);
	p-&gt;phead = p-&gt;ptail = NULL;
	p-&gt;size = 0;
}</code></pre> 
<h3 id="%E9%98%9F%E5%88%97%E7%9A%84%E6%8F%92%E5%85%A5">队列的插入</h3> 
<p><span style="background-color:#cbe0f1;">这里谨记：队列是先进先出，栈是后进先出，不要搞混了！</span></p> 
<p><span style="color:#fe2c24;">这里由于记录好了尾指针，我们直接在尾后面插入就行！这样看是不是觉得很方便？避免了二级指针的使用。</span></p> 
<p><strong>在插入之前，需要开辟一个节点，然后开始插入！</strong></p> 
<pre><code class="language-cpp">//队列的插入
void Qpush(Queue* p, QDataType x)
{
	assert(p);
	QNode* node = (QNode*)malloc(sizeof(QNode));
	if (node == NULL)
	{
		perror("malloc failed!");
		return;
	}
	//初始化节点
	node-&gt;next = NULL;
	node-&gt;val = x;
	//开始插入
	if (p-&gt;phead == NULL)
	{
		p-&gt;phead = p-&gt;ptail = node;
	}
	else
	{
		p-&gt;ptail-&gt;next = node;
		p-&gt;ptail = node;
	}
}</code></pre> 
<h3 id="%E9%98%9F%E5%88%97%E7%9A%84%E5%88%A4%E7%A9%BA">队列的判空</h3> 
<p><span style="color:#fe2c24;">我们只需要在管理的数据变量中判断计数器的值是否为空就行！这也侧面体现了我们用一个结构体管理变量的好处！</span></p> 
<pre><code class="language-cpp">//队列的判空
bool QEmpty(Queue* p)
{
	assert(p);
	return p-&gt;size==0;
}</code></pre> 
<h3 id="%E9%98%9F%E5%88%97%E7%9A%84%E5%88%A0%E9%99%A4">队列的删除</h3> 
<ul><li>在删除之前，我们要先判断队列是否为空，如果为空的话，不能删除。</li><li>因为队列是先进先出原则，既然尾部进数据，那么头部出数据。所以我们删除数据要在头部删除！</li></ul> 
<p><strong><span style="color:#0d0016;">而在删除时要讨论队列中一个节点还是多个节点问题。本来不讨论我们也能删除数据，那么是为什么要讨论呢？</span></strong></p> 
<p><span style="color:#fe2c24;">当队列中只有一个节点时，头指针等于尾指针一起指向这一个节点，当删除时，头指针移向空，然后将这个节点释放掉，但尾指针仍然指向那个节点，当我们访问尾指针指向的那个值时，程序出现错误！</span></p> 
<p>我们上图理解：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/72/d5/X85NKPjq_o.png"></p> 
<p>于是我们能这样写代码：</p> 
<pre><code class="language-cpp">//队列的删除
void Qpop(Queue* p)
{
	assert(p);
	//删除之前不能为空
	assert(!QEmpty(p));
	//讨论队列只有一个节点的情况！
	if (p-&gt;phead-&gt;next == NULL)
	{
		free(p-&gt;phead);
		p-&gt;phead = p-&gt;ptail = NULL;
	}
	else
	{
		QNode* next = p-&gt;phead-&gt;next;
		free(p-&gt;phead);
		p-&gt;phead = next;
	}
	p-&gt;size--;
}</code></pre> 
<h3 id="%E9%98%9F%E5%88%97%E7%9A%84%E5%B0%BE%E6%95%B0%E6%8D%AE">队列的尾数据</h3> 
<p><span style="color:#fe2c24;">有了前面的基础，我们访问队列尾数据十分简单，但需要注意的是，判断队列是否为空。</span></p> 
<pre><code class="language-cpp">//队列的尾数据
QDataType QBack(Queue* p)
{
	assert(p);
	assert(!QEmpty(p));
	return p-&gt;ptail-&gt;val;
}</code></pre> 
<h3 id="%E9%98%9F%E5%88%97%E7%9A%84%E5%A4%B4%E6%95%B0%E6%8D%AE">队列的头数据</h3> 
<p><span style="color:#fe2c24;">能十分访问尾数据，访问头数据也是如此，但是别忘了要判断队列是否为空。</span></p> 
<pre><code class="language-cpp">//队列的头数据
QDataType QFront(Queue* p)
{
	assert(p);
	assert(!QEmpty(p));
	return p-&gt;phead-&gt;val;
}</code></pre> 
<h3 id="%E9%98%9F%E5%88%97%E7%9A%84%E9%94%80%E6%AF%81">队列的销毁</h3> 
<p><span style="color:#fe2c24;">我们动态开辟了内存节点，那么当我们不用了这个队列时，不要忘了销毁它！</span></p> 
<pre><code class="language-cpp">//队列的销毁
void QDestroy(Queue* p)
{
	assert(p);
	QNode* cur = p-&gt;phead;
	while (cur)
	{
		QNode* next = cur-&gt;next;
		free(cur);
		cur = next;
	}
}</code></pre> 
<h2 id="%E6%80%BB%E4%BB%A3%E7%A0%81">总代码</h2> 
<h3 id="Queue.h%E6%96%87%E4%BB%B6">Queue.h文件</h3> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdbool.h&gt;

typedef int QDataType;
//队列节点
typedef struct QueueNode
{
	struct QueueNode* next;
	QDataType val;
}QNode;

//队列相关变量
//先进先出
typedef struct Queue
{
	QNode* phead;
	QNode* ptail;
	int size;
}Queue;


//队列的初始化
void QInit(Queue* p);
//队列的插入
void Qpush(Queue* p, QDataType x);
//队列的判空
bool QEmpty(Queue* p);
//队列的删除
void Qpop(Queue* p);
//队列的尾数据
QDataType QBack(Queue* p);
//队列的头数据
QDataType QFront(Queue* p);
//队列的销毁
void QDestroy(Queue* p);</code></pre> 
<h3 id="Queue.c%E6%96%87%E4%BB%B6">Queue.c文件</h3> 
<pre><code class="language-cpp">#include"Queue.h"
//队列的初始化
void QInit(Queue* p)
{
	assert(p);
	p-&gt;phead = p-&gt;ptail = NULL;
	p-&gt;size = 0;
}
//队列的插入
void Qpush(Queue* p, QDataType x)
{
	assert(p);
	QNode* node = (QNode*)malloc(sizeof(QNode));
	if (node == NULL)
	{
		perror("malloc failed!");
		return;
	}
	//初始化节点
	node-&gt;next = NULL;
	node-&gt;val = x;
	//开始插入
	if (p-&gt;phead == NULL)
	{
		p-&gt;phead = p-&gt;ptail = node;
	}
	else
	{
		p-&gt;ptail-&gt;next = node;
		p-&gt;ptail = node;
	}
}
//队列的判空
bool QEmpty(Queue* p)
{
	assert(p);
	return p-&gt;phead == NULL;
}
//队列的删除
void Qpop(Queue* p)
{
	assert(p);
	//删除之前不能为空
	assert(!QEmpty(p));
	//讨论队列只有一个节点的情况！
	if (p-&gt;phead-&gt;next == NULL)
	{
		free(p-&gt;phead);
		p-&gt;phead = p-&gt;ptail = NULL;
	}
	else
	{
		QNode* next = p-&gt;phead-&gt;next;
		free(p-&gt;phead);
		p-&gt;phead = next;
	}
	p-&gt;size--;
}
//队列的尾数据
QDataType QBack(Queue* p)
{
	assert(p);
	assert(!QEmpty(p));
	return p-&gt;ptail-&gt;val;
}
//队列的头数据
QDataType QFront(Queue* p)
{
	assert(p);
	assert(!QEmpty(p));
	return p-&gt;phead-&gt;val;
}
//队列的销毁
void QDestroy(Queue* p)
{
	assert(p);
	QNode* cur = p-&gt;phead;
	while (cur)
	{
		QNode* next = cur-&gt;next;
		free(cur);
		cur = next;
	}
}</code></pre> 
<p>好了，现在你已经掌握了队列，快去题海感受一下吧！</p> 
<p>我们下期见！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7575b50c4241b995281c7a759d597341/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java抽象类：为何它是你代码架构的基石？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8f61e1aee36c9ad537bbffa5127165d4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构】数组循环队列的实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>