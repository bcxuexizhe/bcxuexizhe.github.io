<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构|C语言版】树、二叉树和堆 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/6da9031b7f65b239b9122f43966e4700/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【数据结构|C语言版】树、二叉树和堆">
  <meta property="og:description" content="前言1. 树1.1 树的概念1.2 树的表示1.3 树在实际中的运用1.4 树的实现 2. 二叉树2.1 二叉树的概念和结构2.2 二叉树的性质2.3 二叉树的存储结构2.4 二叉树的代码实现 3. 堆4. 二叉树顺序结构的实现5. 二叉树链式结构的实现结语 #include&lt;GUIQU.h&gt;
int main {
上期回顾: 【数据结构|C语言版】栈和队列
个人主页：C_GUIQU
归属专栏：【数据结构（C语言版）学习】
return 一键三连;
}
前言 各位小伙伴大家好！上次小编给大家讲解了数据结构中的栈和队列，接下来我们讲解一下树、二叉树和堆！
1. 树 1.1 树的概念 树（Tree）是一种抽象数据类型（ADT），用于模拟具有层次关系的数据集合。在树形结构中，数据以节点（Node）的形式存储，并且每个节点都可以有零个或多个子节点。以下是树相关的基本概念：
节点（Node）：树的基本单元，包含数据元素和指向其子节点的链接。根节点（Root）：树的最顶端节点，没有父节点。子节点（Child）：从某个节点延伸出的节点称为该节点的子节点。父节点（Parent）：如果一个节点拥有子节点，那么这个节点称为其子节点的父节点。叶节点（Leaf）：没有子节点的节点称为叶节点或终端节点。兄弟节点（Sibling）：共享同一父节点的节点互称为兄弟节点。节点的层（Level）：节点的层级从根节点开始定义，根节点为第一层，其子节点为第二层，以此类推。树的深度（Depth）或高度（Height）：树中节点的最大层级数称为树的深度或高度。树的深度通常从1开始计数，而树的高度通常从0开始计数。子树（Subtree）：树的任意节点及其后代节点构成的树称为该节点的子树。路径（Path）：从一个节点到另一个节点的序列，其中包含了经过的节点和边的序列。边（Edge）：连接两个节点的线段，表示节点之间的关系。度（Degree）：一个节点拥有的子节点数称为该节点的度。树的遍历（Traversal）：按照一定的顺序访问树中的所有节点。常见的遍历方法有：前序遍历（Preorder）、中序遍历（Inorder）和后序遍历（Postorder）。查找（Search）：在树中查找一个特定的节点。插入（Insertion）：向树中添加一个新的节点。删除（Deletion）：从树中移除一个节点。
树的应用非常广泛，例如在数据库、文件系统、组织结构、决策树、游戏AI等领域。树的不同类型包括二叉树、二叉搜索树（BST）、平衡树（如AVL树、红黑树）、堆（Heap）、B树、Trie（前缀树）等，每种类型都有其特定的用途和特性。 1.2 树的表示 树的数据结构可以用多种方式表示。以下是一些常见的树表示方法：
链接表示法： 节点和指针：每个节点通常由一个数据元素和多个指向其子节点的指针组成。对于二叉树，通常有两个指针，一个指向左子节点，另一个指向右子节点。结构体定义：在C语言中，可以使用结构体来定义树的节点。例如，一个二叉树的节点可以定义为：struct TreeNode { int data; struct TreeNode *left; struct TreeNode *right; }; 数组表示法： 顺序存储：对于完全二叉树或满二叉树，可以使用数组来表示。在这种表示法中，数组的第一个元素（通常索引为1）用于根节点，而节点的左子节点位于2*i的位置，右子节点位于2*i &#43; 1的位置，其中i是节点在数组中的索引。紧凑表示：这种表示方法节省空间，但不适用于非完全二叉树，因为可能会浪费数组中的空间。 嵌套集合表示法： 左孩子右兄弟表示法：在这种表示法中，每个节点除了指向其第一个子节点的指针外，还包含一个指向其下一个兄弟节点的指针。这种表示法适用于多叉树。结构体定义：在C语言中，可以使用以下结构体来定义节点：struct TreeNode { int data; struct TreeNode *firstChild; struct TreeNode *nextSibling; }; 字符串表示法： 括号表示法：在这种表示法中，树被表示为一个括号嵌套的字符串，其中每个节点的子树被一对括号括起来。例如，二叉树的括号表示法可以是(A(B,C))，其中A是根节点，B和C是子节点。 图形表示法： 可视化工具：使用图形界面工具来绘制树的形状，使得树的结构更加直观。这在教学和文档中非常常见。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-20T00:08:28+08:00">
    <meta property="article:modified_time" content="2024-05-20T00:08:28+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构|C语言版】树、二叉树和堆</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4> </h4> 
 <ul><li><a href="#_15" rel="nofollow">前言</a></li><li><a href="#1__17" rel="nofollow">1. 树</a></li><li><ul><li><a href="#11__18" rel="nofollow">1.1 树的概念</a></li><li><a href="#12__41" rel="nofollow">1.2 树的表示</a></li><li><a href="#13__72" rel="nofollow">1.3 树在实际中的运用</a></li><li><a href="#14__88" rel="nofollow">1.4 树的实现</a></li></ul> 
  </li><li><a href="#2__250" rel="nofollow">2. 二叉树</a></li><li><ul><li><a href="#21__251" rel="nofollow">2.1 二叉树的概念和结构</a></li><li><a href="#22__287" rel="nofollow">2.2 二叉树的性质</a></li><li><a href="#23___310" rel="nofollow">2.3 二叉树的存储结构</a></li><li><a href="#24__323" rel="nofollow">2.4 二叉树的代码实现</a></li></ul> 
  </li><li><a href="#3__457" rel="nofollow">3. 堆</a></li><li><a href="#4__532" rel="nofollow">4. 二叉树顺序结构的实现</a></li><li><a href="#5__610" rel="nofollow">5. 二叉树链式结构的实现</a></li><li><a href="#_685" rel="nofollow">结语</a></li></ul> 
</div> 
<p></p> 
<p><img src="https://images2.imgbox.com/9e/5a/gKsAOWrT_o.gif" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/31/9b/NllVJc9h_o.gif" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>#include&lt;GUIQU.h&gt;<br> int main {<!-- --><br> 上期回顾: <a href="http://t.csdnimg.cn/cLdZr" rel="nofollow">【数据结构|C语言版】栈和队列</a><br> 个人主页：<a href="https://blog.csdn.net/2302_80269373?type=blog">C_GUIQU</a><br> 归属专栏：<a href="https://blog.csdn.net/2302_80269373/category_12642757.html">【数据结构（C语言版）学习】</a><br> return 一键三连;<br> }</strong><br> <img src="https://images2.imgbox.com/e3/dd/ZBpmJ6bN_o.gif" alt="在这里插入图片描述"></p> 
</blockquote> 
<h2><a id="_15"></a>前言</h2> 
<p>各位小伙伴大家好！上次小编给大家讲解了数据结构中的栈和队列，接下来我们讲解一下树、二叉树和堆！</p> 
<h2><a id="1__17"></a>1. 树</h2> 
<h3><a id="11__18"></a>1.1 树的概念</h3> 
<p>树（Tree）是一种抽象数据类型（ADT），用于模拟具有层次关系的数据集合。在树形结构中，数据以节点（Node）的形式存储，并且每个节点都可以有零个或多个子节点。以下是树相关的基本概念：</p> 
<ol><li>节点（Node）：树的基本单元，包含数据元素和指向其子节点的链接。</li><li>根节点（Root）：树的最顶端节点，没有父节点。</li><li>子节点（Child）：从某个节点延伸出的节点称为该节点的子节点。</li><li>父节点（Parent）：如果一个节点拥有子节点，那么这个节点称为其子节点的父节点。</li><li>叶节点（Leaf）：没有子节点的节点称为叶节点或终端节点。</li><li>兄弟节点（Sibling）：共享同一父节点的节点互称为兄弟节点。</li><li>节点的层（Level）：节点的层级从根节点开始定义，根节点为第一层，其子节点为第二层，以此类推。</li><li>树的深度（Depth）或高度（Height）：树中节点的最大层级数称为树的深度或高度。树的深度通常从1开始计数，而树的高度通常从0开始计数。</li><li>子树（Subtree）：树的任意节点及其后代节点构成的树称为该节点的子树。</li><li>路径（Path）：从一个节点到另一个节点的序列，其中包含了经过的节点和边的序列。</li><li>边（Edge）：连接两个节点的线段，表示节点之间的关系。</li><li>度（Degree）：一个节点拥有的子节点数称为该节点的度。</li><li>树的遍历（Traversal）：按照一定的顺序访问树中的所有节点。常见的遍历方法有：前序遍历（Preorder）、中序遍历（Inorder）和后序遍历（Postorder）。</li><li>查找（Search）：在树中查找一个特定的节点。</li><li>插入（Insertion）：向树中添加一个新的节点。</li><li>删除（Deletion）：从树中移除一个节点。<br> 树的应用非常广泛，例如在数据库、文件系统、组织结构、决策树、游戏AI等领域。树的不同类型包括二叉树、二叉搜索树（BST）、平衡树（如AVL树、红黑树）、堆（Heap）、B树、Trie（前缀树）等，每种类型都有其特定的用途和特性。</li></ol> 
<p><img src="https://images2.imgbox.com/f3/b7/QLSo5mqQ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/25/8f/AV02touV_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="12__41"></a>1.2 树的表示</h3> 
<p>树的数据结构可以用多种方式表示。以下是一些常见的树表示方法：</p> 
<ol><li><strong>链接表示法</strong>： 
  <ul><li><strong>节点和指针</strong>：每个节点通常由一个数据元素和多个指向其子节点的指针组成。对于二叉树，通常有两个指针，一个指向左子节点，另一个指向右子节点。</li><li><strong>结构体定义</strong>：在C语言中，可以使用结构体来定义树的节点。例如，一个二叉树的节点可以定义为：<pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token operator">*</span>left<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token operator">*</span>right<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> </li></ul> </li><li><strong>数组表示法</strong>： 
  <ul><li><strong>顺序存储</strong>：对于完全二叉树或满二叉树，可以使用数组来表示。在这种表示法中，数组的第一个元素（通常索引为1）用于根节点，而节点的左子节点位于<code>2*i</code>的位置，右子节点位于<code>2*i + 1</code>的位置，其中<code>i</code>是节点在数组中的索引。</li><li><strong>紧凑表示</strong>：这种表示方法节省空间，但不适用于非完全二叉树，因为可能会浪费数组中的空间。</li></ul> </li><li><strong>嵌套集合表示法</strong>： 
  <ul><li><strong>左孩子右兄弟表示法</strong>：在这种表示法中，每个节点除了指向其第一个子节点的指针外，还包含一个指向其下一个兄弟节点的指针。这种表示法适用于多叉树。</li><li><strong>结构体定义</strong>：在C语言中，可以使用以下结构体来定义节点：<pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token operator">*</span>firstChild<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token operator">*</span>nextSibling<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> </li></ul> </li><li><strong>字符串表示法</strong>： 
  <ul><li><strong>括号表示法</strong>：在这种表示法中，树被表示为一个括号嵌套的字符串，其中每个节点的子树被一对括号括起来。例如，二叉树的括号表示法可以是<code>(A(B,C))</code>，其中<code>A</code>是根节点，<code>B</code>和<code>C</code>是子节点。</li></ul> </li><li><strong>图形表示法</strong>： 
  <ul><li><strong>可视化工具</strong>：使用图形界面工具来绘制树的形状，使得树的结构更加直观。这在教学和文档中非常常见。<br> 不同的表示方法有各自的优缺点，适用于不同的应用场景。在实际应用中，选择哪种表示方法取决于树的类型、操作的类型以及效率要求。例如，链接表示法在插入和删除操作上更加灵活，而数组表示法在访问特定索引的节点时更加高效。</li></ul> </li></ol> 
<h3><a id="13__72"></a>1.3 树在实际中的运用</h3> 
<p>树在实际应用中非常广泛，它们以各种形式出现在计算机科学和日常生活的许多领域。以下是一些树的实际应用示例：</p> 
<ol><li><strong>文件系统</strong>：在计算机的文件系统中，文件和目录被组织成树状结构。每个目录可以包含文件和其他目录（子目录），形成层级结构。</li><li><strong>组织结构</strong>：公司、政府机构和其他组织的结构通常以树的形式表示，其中顶层是首席执行官或总统，下面是各个部门或机构的负责人。</li><li><strong>决策树</strong>：在机器学习中，决策树是一种用于分类和回归的模型，它通过一系列判断来决策。</li><li><strong>数据库索引</strong>：数据库管理系统使用B树、B+树、红黑树等数据结构来优化搜索操作，这些数据结构都是树的变体。</li><li><strong>优先队列</strong>：堆（Heap）是一种特殊的树（通常是二叉树），用于实现优先队列，它可以快速地插入元素和删除最小（或最大）元素。</li><li><strong>路由算法</strong>：在网络中，路由算法使用树来决定数据包从源点到目的地的最佳路径。</li><li><strong>语法分析</strong>：在编译器的构建过程中，抽象语法树（AST）用于表示源代码的语法结构。</li><li><strong>搜索算法</strong>：二叉搜索树（BST）用于优化搜索操作，它可以快速地插入、删除和查找数据。</li><li><strong>游戏AI</strong>：在视频游戏中，行为树和决策树用于控制非玩家角色（NPC）的行为和决策过程。</li><li><strong>XML/HTML解析</strong>：XML和HTML文档可以被视为树状结构，其中每个标签都是一个节点，文档对象模型（DOM）树用于在浏览器中解析和渲染网页。</li><li><strong>家族树</strong>：在遗传学和社会研究中，家族树用于表示家族成员之间的关系和遗传信息。</li><li><strong>自动完成</strong>：在搜索引擎和文本编辑器中，Trie（前缀树）用于实现自动完成功能，快速地提供与用户输入匹配的单词或短语。</li><li><strong>数据压缩</strong>：Huffman树用于数据压缩算法中，它通过为常见字符分配较短的编码，为不常见字符分配较长的编码，来减少数据的存储空间。<br> 这些只是树在实际情况中应用的一小部分例子。由于树提供了一种自然的层次结构，它们在需要组织和搜索复杂数据的应用中非常有用。</li></ol> 
<h3><a id="14__88"></a>1.4 树的实现</h3> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token comment">// 定义树节点的结构体</span>
<span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token operator">*</span>left<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token operator">*</span>right<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 创建新节点的函数</span>
<span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> <span class="token function">createNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> newNode <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newNode <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"内存分配失败\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    newNode<span class="token operator">-&gt;</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
    newNode<span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    newNode<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> newNode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 插入节点的函数</span>
<span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> <span class="token function">insertNode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token function">createNode</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&lt;</span> root<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        root<span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&gt;</span> root<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        root<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 查找节点的函数</span>
<span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> <span class="token function">findNode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> root<span class="token operator">-&gt;</span>data <span class="token operator">==</span> data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> root<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&lt;</span> root<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token function">findNode</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token function">findNode</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 删除节点的辅助函数，找到最小值节点</span>
<span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> <span class="token function">findMinNode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> node<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> current <span class="token operator">=</span> node<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">&amp;&amp;</span> current<span class="token operator">-&gt;</span>left <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        current <span class="token operator">=</span> current<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> current<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 删除节点的函数</span>
<span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> root<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&lt;</span> root<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        root<span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&gt;</span> root<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        root<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 节点找到，进行删除</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> temp <span class="token operator">=</span> root<span class="token operator">-&gt;</span>right<span class="token punctuation">;</span>
            <span class="token function">free</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> temp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> temp <span class="token operator">=</span> root<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>
            <span class="token function">free</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> temp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 节点有两个子节点</span>
        <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> temp <span class="token operator">=</span> <span class="token function">findMinNode</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        root<span class="token operator">-&gt;</span>data <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
        root<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> temp<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 前序遍历的函数</span>
<span class="token keyword">void</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> node<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> node<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 中序遍历的函数</span>
<span class="token keyword">void</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> node<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> node<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 后序遍历的函数</span>
<span class="token keyword">void</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> node<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> node<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 清理树的函数</span>
<span class="token keyword">void</span> <span class="token function">deleteTree</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">deleteTree</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">deleteTree</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> root <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    root <span class="token operator">=</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"前序遍历: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"中序遍历: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"后序遍历: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> node <span class="token operator">=</span> <span class="token function">findNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"找到节点: %d\n"</span><span class="token punctuation">,</span> node<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"节点未找到\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    root <span class="token operator">=</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"删除节点 20 后的中序遍历: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    inorder
</code></pre> 
<h2><a id="2__250"></a>2. 二叉树</h2> 
<h3><a id="21__251"></a>2.1 二叉树的概念和结构</h3> 
<p><mark>二叉树是一种特殊的树形数据结构，每个节点最多有两个子节点，通常称为左子节点和右子节点。</mark></p> 
<p>以下是二叉树的一些基本概念和结构：</p> 
<ol><li><strong>节点（Node）</strong>：树的基本单元，每个节点包含数据元素和指向其子节点的指针。</li><li><strong>根节点（Root）</strong>：二叉树的最顶端节点，没有父节点。</li><li><strong>子节点（Child）</strong>：从某个节点延伸出的节点称为该节点的子节点，在二叉树中，分为左子节点和右子节点。</li><li><strong>父节点（Parent）</strong>：如果一个节点拥有子节点，那么这个节点称为其子节点的父节点。</li><li><strong>叶节点（Leaf）</strong>：没有子节点的节点称为叶节点或终端节点。</li><li><strong>兄弟节点（Sibling）</strong>：共享同一父节点的节点互称为兄弟节点。</li><li><strong>节点的层（Level）</strong>：节点的层级从根节点开始定义，根节点为第一层，其子节点为第二层，以此类推。</li><li><strong>深度（Depth）</strong>：节点的深度是指从根节点到该节点的唯一路径上的边的数量。</li><li><strong>高度（Height）</strong>：节点的高度是指从该节点到最远叶节点的路径上的边的数量。整个二叉树的高度是指根节点的高度。</li><li><strong>路径（Path）</strong>：从一个节点到另一个节点的序列，其中包含了经过的节点和边的序列。</li><li><strong>子树（Subtree）</strong>：每个节点的左子节点和右子节点及其后代节点构成了该节点的左子树和右子树。</li><li><strong>满二叉树（Full Binary Tree）</strong>：每个节点都有0个或2个子节点的二叉树。</li><li><strong>完美二叉树（Perfect Binary Tree）</strong>：除了叶节点外，每个节点都有两个子节点，并且所有叶节点都在同一层的二叉树。</li><li><strong>完全二叉树（Complete Binary Tree）</strong>：除了最后一层外，每一层都是满的，并且最后一层的节点都靠左排列。</li><li><strong>平衡二叉树（Balanced Binary Tree）</strong>：任一节点的左右子树的高度差不超过1的二叉树。</li><li><strong>二叉搜索树（Binary Search Tree, BST）</strong>：左子树的所有节点都小于根节点，右子树的所有节点都大于根节点的二叉树。</li><li><strong>AVL树</strong>：任何节点的两个子树的高度最大差别为1的平衡二叉搜索树。</li><li><strong>红黑树</strong>：一种自平衡的二叉搜索树，其中每个节点包含一个颜色作为附加信息。<br> 二叉树的结构可以通过链接方式表示，每个节点包含数据元素和两个指向其子节点的指针。例如，在C语言中，可以使用以下结构体来定义二叉树的节点：</li></ol> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>              <span class="token comment">// 节点存储的数据</span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token operator">*</span>left<span class="token punctuation">;</span>  <span class="token comment">// 指向左子节点的指针</span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token operator">*</span>right<span class="token punctuation">;</span> <span class="token comment">// 指向右子节点的指针</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>通过这种方式，可以构建和操作各种类型的二叉树，如二叉搜索树、平衡树等。二叉树在计算机科学中非常重要，因为它们提供了一种高效的方式来组织和访问数据。例如，二叉搜索树可以快速地插入、删除和查找数据，而平衡二叉树如AVL树和红黑树则保证了这些操作的最坏情况时间复杂度为O(log n)。<br> <img src="https://images2.imgbox.com/06/7a/UeknCe9z_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/b0/ec/YbuE86XS_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="22__287"></a>2.2 二叉树的性质</h3> 
<ol><li><strong>非空性质</strong>：每个二叉树至少有一个节点。</li><li><strong>节点性质</strong>：二叉树的每个节点包含以下三个部分： 
  <ul><li>数据域（Data）：存储节点数据的域。</li><li>左指针（Left）：指向左子树的指针，如果节点没有左子树，则该指针为NULL。</li><li>右指针（Right）：指向右子树的指针，如果节点没有右子树，则该指针为NULL。</li></ul> </li><li><strong>根节点性质</strong>：二叉树的根节点没有父节点，它的左指针和右指针都为NULL。</li><li><strong>子节点性质</strong>：对于二叉树中的任意一个节点，其左子树和右子树也是二叉树，且左子树的根节点是该节点的左子节点，右子树的根节点是该节点的右子节点。</li><li><strong>层次性质</strong>：二叉树中的节点可以按照层次进行编号，根节点为第1层，其子节点为第2层，依此类推。</li><li><strong>节点度数</strong>：二叉树中每个节点的度数最多为2，即每个节点最多有两个子节点。</li><li><strong>路径性质</strong>：从根节点到树中任意节点的路径都是唯一的。</li><li><strong>树的高度</strong>：二叉树的高度是从根节点到最远叶节点的最长路径上的边的数量。</li><li><strong>节点的最大深度</strong>：在二叉树中，每个节点的最大深度是该节点到其最远叶节点的路径上的边的数量。</li><li><strong>叶节点的性质</strong>：叶节点是没有子节点的节点，也称为终端节点。</li><li><strong>非叶节点的性质</strong>：非叶节点至少有一个子节点。</li><li><strong>完全二叉树性质</strong>：除了最后一层外，其他所有层都是满的，最后一层的节点都靠左排列。</li><li><strong>满二叉树性质</strong>：每个节点都有两个子节点的二叉树。</li><li><strong>完美二叉树性质</strong>：除了叶节点外，每个节点都有两个子节点，并且所有叶节点都在同一层的二叉树。</li><li><strong>平衡二叉树性质</strong>：二叉树中任意节点的两个子树的高度差不超过1的二叉树。</li><li><strong>二叉搜索树性质</strong>：二叉搜索树（BST）是一种特殊的二叉树，满足左子树的所有节点值小于根节点的值，右子树的所有节点值大于根节点的值。</li></ol> 
<p>这些性质使得二叉树在数据结构中非常有用，因为它们提供了一种高效的方式来组织和访问数据。</p> 
<h3><a id="23___310"></a>2.3 二叉树的存储结构</h3> 
<p>二叉树的存储结构通常指的是如何将二叉树的数据以某种形式存储在计算机的内存中。<br> 常见的二叉树存储结构有顺序存储结构和链式存储结构。</p> 
<ol><li><strong>顺序存储结构</strong>： 
  <ul><li><strong>数组</strong>：使用一维数组来存储二叉树的所有节点。在这种表示中，通常假设树是完全二叉树或接近完全二叉树，这样可以有效利用数组的连续空间。</li><li><strong>紧凑表示</strong>：对于非完全二叉树，可以使用紧凑表示法，其中非叶子节点的指针指向数组中的下一个节点，而叶子节点的指针指向NULL。</li></ul> </li><li><strong>链式存储结构</strong>： 
  <ul><li><strong>链表</strong>：使用链表来存储二叉树的节点。每个节点包含数据域和两个指针域，分别指向其左子节点和右子节点。</li><li><strong>堆栈</strong>：可以使用堆栈来模拟二叉树的后序遍历。</li><li><strong>队列</strong>：可以使用队列来模拟二叉树的前序遍历和中序遍历。</li></ul> </li></ol> 
<p>顺序存储结构的优势在于随机访问节点的效率较高，但是插入和删除操作可能需要移动大量节点，导致效率较低。链式存储结构则相反，插入和删除操作的效率较高，但是随机访问节点的效率较低。<br> 在实际应用中，选择哪种存储结构取决于具体的应用场景和对性能的要求。例如，对于需要频繁插入和删除操作的应用，链式存储结构可能更加合适；而对于需要频繁随机访问节点的应用，顺序存储结构可能更加合适。</p> 
<h3><a id="24__323"></a>2.4 二叉树的代码实现</h3> 
<p>以下是一个简单的C语言程序，实现了二叉树的创建、插入、查找、删除和遍历操作：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token comment">// 定义二叉树节点的结构体</span>
<span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token operator">*</span>left<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token operator">*</span>right<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 创建新节点的函数</span>
<span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> <span class="token function">createNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> newNode <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newNode <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"内存分配失败\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    newNode<span class="token operator">-&gt;</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
    newNode<span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    newNode<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> newNode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 插入节点的函数</span>
<span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> <span class="token function">insertNode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token function">createNode</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&lt;</span> root<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        root<span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&gt;</span> root<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        root<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 查找节点的函数</span>
<span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> <span class="token function">findNode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> root<span class="token operator">-&gt;</span>data <span class="token operator">==</span> data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> root<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&lt;</span> root<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token function">findNode</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token function">findNode</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 删除节点的函数</span>
<span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> root<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&lt;</span> root<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        root<span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&gt;</span> root<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        root<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 节点找到，进行删除</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> temp <span class="token operator">=</span> root<span class="token operator">-&gt;</span>right<span class="token punctuation">;</span>
            <span class="token function">free</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> temp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> temp <span class="token operator">=</span> root<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>
            <span class="token function">free</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> temp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 节点有两个子节点</span>
        <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> temp <span class="token operator">=</span> <span class="token function">findMinNode</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        root<span class="token operator">-&gt;</span>data <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
        root<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> temp<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 找到最小值节点的辅助函数</span>
<span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> <span class="token function">findMinNode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> node<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> current <span class="token operator">=</span> node<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">&amp;&amp;</span> current<span class="token operator">-&gt;</span>left <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        current <span class="token operator">=</span> current<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> current<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 前序遍历的函数</span>
<span class="token keyword">void</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> node<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> node<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 中序遍历的函数</span>
<span class="token keyword">void</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> node<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> node<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 后序遍历的函数</span>
<span class="token keyword">void</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> node<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> node<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 清理树的函数</span>
<span class="token keyword">void</span> <span class="token function">deleteTree</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">deleteTree</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">deleteTree</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> root <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="3__457"></a>3. 堆</h2> 
<p>堆（Heap）是一种特别的完全二叉树，它满足两个特性：</p> 
<ol><li>堆是一个完全二叉树，即树中的所有层都是满的，除了最后一层，最后一层的节点从左到右排列。</li><li>对于最大堆（Max Heap）来说，每个父节点的值都大于或等于其子节点的值；对于最小堆（Min Heap）来说，每个父节点的值都小于或等于其子节点的值。</li></ol> 
<p>堆通常用于实现优先队列（Priority Queue），因为可以在对数时间复杂度内找到最大或最小元素，并且可以在对数时间复杂度内删除或插入元素。</p> 
<p>堆通常使用数组来实现。对于数组中的任意位置 i 的元素，其：</p> 
<ul><li>左子节点的位置是 2i（如果存在）</li><li>右子节点的位置是 2i + 1（如果存在）</li><li>父节点的位置是 i / 2（向下取整）</li></ul> 
<p>堆的主要操作包括：</p> 
<ol><li><strong>初始化（Init）</strong>：创建一个空堆。</li><li><strong>插入（Insert）</strong>：向堆中插入一个新元素。插入时，新元素首先被放到堆的末尾，然后与其父节点比较，如果违反了堆的性质，则进行交换，直到满足堆的性质为止。</li><li><strong>删除（Delete）</strong>：删除堆顶元素（最大或最小元素）。删除时，将堆的最后一个元素移动到堆顶，然后与子节点比较，如果违反了堆的性质，则进行交换，直到满足堆的性质为止。</li><li><strong>提取最大值或最小值（Extract Max/Min）</strong>：返回并删除堆顶元素。这是优先队列中常用的操作。</li><li><strong>堆排序（Heapify）</strong>：将一个无序的数组转换为堆。这是一个建立堆的过程。</li></ol> 
<p>下面是一个使用 C 语言实现的最大堆的简单示例：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>
    <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>
    <span class="token operator">*</span>b <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> largest <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// Initialize largest as root</span>
    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// left = 2*i + 1</span>
    <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// right = 2*i + 2</span>
    <span class="token comment">// If left child is larger than root</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span>
        largest <span class="token operator">=</span> left<span class="token punctuation">;</span>
    <span class="token comment">// If right child is larger than largest so far</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span>
        largest <span class="token operator">=</span> right<span class="token punctuation">;</span>
    <span class="token comment">// If largest is not root</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>largest <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// Recursively heapify the affected sub-tree</span>
        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> largest<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// Main function to do heap sort</span>
<span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// Build heap (rearrange array)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// One by one extract an element from heap</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// Move current root to end</span>
        <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// call max heapify on the reduced heap</span>
        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// A utility function to print array of size n</span>
<span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// Driver program</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">heapSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Sorted array is \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个示例中，<code>heapify</code> 函数用于维护堆的性质，<code>heapSort</code> 函数用于对数组进行堆排序。堆排序是一种不稳定的比较排序算法，其时间复杂度为 O(n log n)。</p> 
<h2><a id="4__532"></a>4. 二叉树顺序结构的实现</h2> 
<p>在 C 语言中实现二叉树的顺序结构，我们通常使用数组来表示树。下面是一个简单的 C 语言实现，它创建了一个二叉树，并提供了插入、查找和显示节点的功能。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_SIZE</span> <span class="token expression"><span class="token number">100</span>  </span><span class="token comment">// 定义数组的最大容量</span></span>
<span class="token comment">// 定义二叉树结构</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> data<span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 存储节点的数组</span>
    <span class="token keyword">int</span> size<span class="token punctuation">;</span>            <span class="token comment">// 树的大小</span>
<span class="token punctuation">}</span> BinaryTree<span class="token punctuation">;</span>
<span class="token comment">// 初始化二叉树</span>
<span class="token keyword">void</span> <span class="token function">initBinaryTree</span><span class="token punctuation">(</span>BinaryTree <span class="token operator">*</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    tree<span class="token operator">-&gt;</span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 初始时树的大小为0</span>
<span class="token punctuation">}</span>
<span class="token comment">// 判断二叉树是否为空</span>
<span class="token keyword">int</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>BinaryTree <span class="token operator">*</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> tree<span class="token operator">-&gt;</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 在二叉树中插入节点</span>
<span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>BinaryTree <span class="token operator">*</span>tree<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> position<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> position <span class="token operator">&gt;</span> MAX_SIZE<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"位置无效\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token operator">-&gt;</span>size <span class="token operator">&gt;=</span> MAX_SIZE<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"树已满\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    tree<span class="token operator">-&gt;</span>size<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment">// 增加树的大小</span>
    tree<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>position<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>  <span class="token comment">// 在指定位置插入值</span>
<span class="token punctuation">}</span>
<span class="token comment">// 获取左子节点</span>
<span class="token keyword">int</span> <span class="token function">leftChild</span><span class="token punctuation">(</span>BinaryTree <span class="token operator">*</span>tree<span class="token punctuation">,</span> <span class="token keyword">int</span> position<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> leftPosition <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> position<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>leftPosition <span class="token operator">&lt;=</span> tree<span class="token operator">-&gt;</span>size<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> tree<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>leftPosition<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 表示没有左子节点</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 获取右子节点</span>
<span class="token keyword">int</span> <span class="token function">rightChild</span><span class="token punctuation">(</span>BinaryTree <span class="token operator">*</span>tree<span class="token punctuation">,</span> <span class="token keyword">int</span> position<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> rightPosition <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> position <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>rightPosition <span class="token operator">&lt;=</span> tree<span class="token operator">-&gt;</span>size<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> tree<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>rightPosition<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 表示没有右子节点</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 获取父节点</span>
<span class="token keyword">int</span> <span class="token function">parent</span><span class="token punctuation">(</span>BinaryTree <span class="token operator">*</span>tree<span class="token punctuation">,</span> <span class="token keyword">int</span> position<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> tree<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>position <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 表示没有父节点</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 显示二叉树</span>
<span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span>BinaryTree <span class="token operator">*</span>tree<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> tree<span class="token operator">-&gt;</span>size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"节点位置 %d: 值 %d, 左子节点 %d, 右子节点 %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> tree<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">leftChild</span><span class="token punctuation">(</span>tree<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rightChild</span><span class="token punctuation">(</span>tree<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    BinaryTree tree<span class="token punctuation">;</span>
    <span class="token function">initBinaryTree</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">insert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tree<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">insert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tree<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">insert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tree<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">insert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tree<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">insert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tree<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">display</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个实现中，我们定义了一个 <code>BinaryTree</code> 结构，其中包含一个整数数组 <code>data</code> 来存储树的节点，以及一个整数 <code>size</code> 来表示树的大小。我们提供了初始化、插入、查找和显示树的方法。这个实现假设树是一个完全二叉树，因此它适用于完全二叉树或近似完全二叉树的情况。如果树不是完全二叉树，那么数组表示法可能会导致空间浪费。</p> 
<h2><a id="5__610"></a>5. 二叉树链式结构的实现</h2> 
<p>二叉树的链式结构实现通常使用节点（Node）和指针（在 C 语言中是指针，在其他语言中可能是引用或其他形式的间接访问）。每个节点包含一个数据字段和两个指针字段，分别指向其左子节点和右子节点。如果某个节点没有子节点，则相应的指针字段为 NULL。</p> 
<p>以下是一个使用 C 语言实现的二叉树链式结构的基本操作：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token comment">// 定义二叉树节点的结构</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>               <span class="token comment">// 节点存储的数据</span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token operator">*</span>left<span class="token punctuation">;</span>  <span class="token comment">// 指向左子节点的指针</span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token operator">*</span>right<span class="token punctuation">;</span> <span class="token comment">// 指向右子节点的指针</span>
<span class="token punctuation">}</span> TreeNode<span class="token punctuation">;</span>
<span class="token comment">// 创建新节点</span>
TreeNode<span class="token operator">*</span> <span class="token function">createNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    TreeNode <span class="token operator">*</span>newNode <span class="token operator">=</span> <span class="token punctuation">(</span>TreeNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>TreeNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>newNode<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    newNode<span class="token operator">-&gt;</span>data <span class="token operator">=</span> value<span class="token punctuation">;</span>
    newNode<span class="token operator">-&gt;</span>left <span class="token operator">=</span> newNode<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> newNode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 向二叉树中插入节点</span>
<span class="token keyword">void</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span><span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token operator">*</span>root <span class="token operator">=</span> <span class="token function">createNode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        TreeNode <span class="token operator">*</span>current <span class="token operator">=</span> <span class="token operator">*</span>root<span class="token punctuation">;</span>
        TreeNode <span class="token operator">*</span>parent <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            parent <span class="token operator">=</span> current<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;</span> current<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                current <span class="token operator">=</span> current<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                current <span class="token operator">=</span> current<span class="token operator">-&gt;</span>right<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;</span> parent<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            parent<span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token function">createNode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            parent<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token function">createNode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 中序遍历二叉树</span>
<span class="token keyword">void</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span>root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> root<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 主函数</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    TreeNode <span class="token operator">*</span>root <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 插入节点</span>
    <span class="token function">insertNode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">insertNode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">insertNode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">insertNode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">insertNode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">insertNode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">insertNode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 中序遍历二叉树</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"中序遍历二叉树: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个实现中，我们定义了一个 <code>TreeNode</code> 结构，它包含一个整数值 <code>data</code> 和两个指向 <code>TreeNode</code> 的指针 <code>left</code> 和 <code>right</code>。<code>createNode</code> 函数用于创建一个新的节点，<code>insertNode</code> 函数用于向树中插入一个新的节点，<code>inorderTraversal</code> 函数用于中序遍历树并打印节点的值。<br> 这个基本的实现没有包含删除节点的功能，也没有进行任何形式的平衡或优化。在实际应用中，我们可能需要根据具体需求添加更多的功能，比如平衡二叉树（如 AVL 树或红黑树）、查找节点、删除节点等。</p> 
<h2><a id="_685"></a>结语</h2> 
<p>以上就是小编对树、二叉树和堆的讲解。<br> 如果觉得小编讲的还可以，还请一键三连。互三必回！<br> 持续更新中~！</p> 
<p><img src="https://images2.imgbox.com/55/fc/ox5ve4CF_o.gif" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/e3/e8/4iy5E0g9_o.gif" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5690b4bc8ca405452e32874d8690bb76/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">精通C&#43;&#43; STL（一）：解开string类的面纱与高效应用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8e18001a0c6fe08053181240e2332faf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端报错npm ERR! cb() never called!问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>