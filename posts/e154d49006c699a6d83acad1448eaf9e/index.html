<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LeetCode_栈和队列相关OJ - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/e154d49006c699a6d83acad1448eaf9e/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="LeetCode_栈和队列相关OJ">
  <meta property="og:description" content="✨✨所属专栏：LeetCode刷题专栏✨✨
✨✨作者主页：嶔某✨✨
上一篇：数据结构_栈和队列(Stack &amp; Queue)-CSDN博客 有效的括号 解析: 这里我们用数组实现的栈来解决这个问题，在有了栈的几个基础接口之后，我们运用这几个接口解决问题。
首先新建一个栈并初始化，进入循环如果当前指针指向的字符元素为左括号 {([ 就入栈，反之就出栈，之后判断指针指向的字符是否和出栈的字符左右括号相匹配。
( (top == &#39;{&#39;&amp;&amp; *s != &#39;}&#39;) || (top == &#39;[&#39;&amp;&amp; *s != &#39;]&#39;) || (top == &#39;(&#39;&amp;&amp; *s !=&#39;)&#39;) )
每次循环后s&#43;&#43;，如果 *s != &#39;\0&#39; 就进行下一次循环。
写完后提交会发现当只有一个元素的时候这种写法是不能过的
这里我们在else里面做一个判空，因为如果进了else里面，就说明这是个右括号，那么栈里面一定有其所对应的左括号，如果这时后栈为空，那么显然括号之间是不匹配的。这样就很好的解决了诸如此类的问题。
if(STEmpty(&amp;S))
{
STDestroy(&amp;S);
return false;
}
最后s遇到了 &#39;\0&#39; 循环结束，我们判断栈是否为空，如果为空返回true，否则栈中还有元素括号之间也是不匹配的。
return STEmpty(&amp;S);
可以这么理解这两段代码：一个判断了左括号是否多了，一个判断了右括号是否多了。
示例代码： function/数据结构_栈 · 钦某/c-language-learning - 码云 - 开源中国 (gitee.com)https://gitee.com/wang-qin928/c-language-learning/tree/master/function/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%A0%88
bool isValid(char* s) { ST S; STInit(&amp;S); while(*s) { if(*s == &#39;{&#39; || *s == &#39;[&#39; || *s == &#39;(&#39;) { STPush(&amp;S,*s); } else { if(STEmpty(&amp;S)) { STDestroy(&amp;S); return false; } char top = STTop(&amp;S); STPop(&amp;S); if((top == &#39;{&#39;&amp;&amp; *s !">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-15T10:32:40+08:00">
    <meta property="article:modified_time" content="2024-05-15T10:32:40+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LeetCode_栈和队列相关OJ</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/b3/78/bazohA8Q_o.png" alt="0c76f4c1e358481fbc51e89cd6e2e854.png"></p> 
 <p style="text-align:center;">✨✨所属专栏：<a href="https://blog.csdn.net/2301_80194476/category_12596977.html?spm=1001.2014.3001.5482" title="LeetCode刷题专栏">LeetCode刷题专栏</a>✨✨</p> 
 <p style="text-align:center;">✨✨作者主页：<a href="https://blog.csdn.net/2301_80194476?spm=1000.2115.3001.5343" title="嶔某">嶔某</a>✨✨</p> 
</blockquote> 
<p style="text-align:center;">上一篇：<a href="https://blog.csdn.net/2301_80194476/article/details/138316164?spm=1001.2014.3001.5502" title="数据结构_栈和队列(Stack &amp; Queue)-CSDN博客">数据结构_栈和队列(Stack &amp; Queue)-CSDN博客</a> </p> 
<h2> 有效的括号</h2> 
<p><img src="https://images2.imgbox.com/26/7b/wp2nSaPP_o.png" alt="fa8665e0221848ac8d681622763fdf99.png"></p> 
<h3>解析:</h3> 
<p>这里我们用<strong>数组实现的栈</strong>来解决这个问题，在有了栈的几个基础接口之后，我们运用这几个接口解决问题。</p> 
<p>首先新建一个栈并初始化，进入循环如果当前指针指向的字符元素为左括号 {([ 就入栈，反之就出栈，之后判断指针指向的字符是否和出栈的字符左右括号相匹配。</p> 
<blockquote> 
 <p>(  (top == '{'&amp;&amp; *s != '}')  ||  (top == '['&amp;&amp; *s != ']')  ||  (top == '('&amp;&amp; *s !=')')  )</p> 
</blockquote> 
<p> 每次循环后s++，如果 *s != '\0' 就进行下一次循环。</p> 
<p>写完后提交会发现当只有一个元素的时候这种写法是不能过的</p> 
<p><img src="https://images2.imgbox.com/c2/53/PbM4FoUk_o.png" alt="e66b9b3067d24488a17ef5e12181c92a.png"></p> 
<p> 这里我们在else里面做一个判空，因为如果进了else里面，就说明这是个右括号，那么栈里面一定有其所对应的左括号，如果这时后栈为空，那么显然括号之间是不匹配的。这样就很好的解决了诸如此类的问题。</p> 
<blockquote> 
 <p>if(STEmpty(&amp;S))<br> {<!-- --><br>         STDestroy(&amp;S);<br>         return false;</p> 
 <p>}</p> 
</blockquote> 
<p>最后s遇到了 '\0' 循环结束，我们判断栈是否为空，如果为空返回true，否则栈中还有元素括号之间也是不匹配的。</p> 
<blockquote> 
 <p>return STEmpty(&amp;S);</p> 
</blockquote> 
<p> 可以这么理解这两段代码：一个判断了左括号是否多了，一个判断了右括号是否多了。</p> 
<h3> 示例代码：</h3> 
<p> <a class="has-card" href="https://gitee.com/wang-qin928/c-language-learning/tree/master/function/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%A0%88" rel="nofollow" title="function/数据结构_栈 · 钦某/c-language-learning - 码云 - 开源中国 (gitee.com)"><span class="link-card-box"><span class="link-title">function/数据结构_栈 · 钦某/c-language-learning - 码云 - 开源中国 (gitee.com)</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/ae/5f/bI4BxQ73_o.png">https://gitee.com/wang-qin928/c-language-learning/tree/master/function/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%A0%88</span></span></a></p> 
<pre><code class="language-cpp">bool isValid(char* s)
{
    ST S;
    STInit(&amp;S);
    while(*s)
    {
        if(*s == '{' || *s == '[' || *s == '(')
        {
            STPush(&amp;S,*s);
        }
        else
        {
            if(STEmpty(&amp;S))
            {
                STDestroy(&amp;S);
                return false;
            }
            char top = STTop(&amp;S);
            STPop(&amp;S);

            if((top == '{'&amp;&amp; *s != '}')||
            (top == '['&amp;&amp; *s != ']') ||
            (top == '('&amp;&amp; *s !=')'))
            {
                STDestroy(&amp;S);
                return false;               
            }
        }
        s++;
    }
    return STEmpty(&amp;S);
}</code></pre> 
<h2> 用队列实现栈</h2> 
<p><img src="https://images2.imgbox.com/59/12/yRNw3bQB_o.png" alt="3aeb55e96b4742ab99063dab48a0291b.png"></p> 
<h3>解析：</h3> 
<p>这里我们使用数组实现的队列，只需要创建两个队列，把数据在两个队列之间互相导就行了。</p> 
<h4>定义结构体MyStack：</h4> 
<p>将mystack结构体里面创建两个队列q1、q2。</p> 
<h4>myStackCreate函数：</h4> 
<p>malloc出结构体pst的内存空间 ，并将q1、q2交给 QueueInit函数，返回这个结构体。</p> 
<h4>myStackPush函数：</h4> 
<p>将数据方放进 QueuePush，入队列q1就行。</p> 
<h4>myStackPop函数：</h4> 
<p>将q1队列的数据转到q2里面，最后剩一个数据不转，直接删除，之后再将数据从q2转到q1里面。返回删除的那个数据。</p> 
<h4>myStackTop函数：</h4> 
<p>和上一个函数一样，只不过myStackTop不删除数据，直接返回就好了。</p> 
<h4>myStackEmpty函数：</h4> 
<blockquote> 
 <p>return !QueueSize(&amp;(obj-&gt;q1));</p> 
</blockquote> 
<h4> myStackFree函数：</h4> 
<p>这里一定要先释放q1、q2的空间之后再释放pst。</p> 
<h3>示例代码：</h3> 
<p><a class="has-card" href="https://gitee.com/wang-qin928/c-language-learning/tree/master/function/%E9%98%9F%E5%88%97" rel="nofollow" title="function/队列 · 钦某/c-language-learning - 码云 - 开源中国 (gitee.com)"><span class="link-card-box"><span class="link-title">function/队列 · 钦某/c-language-learning - 码云 - 开源中国 (gitee.com)</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/d8/e2/oZryKNAh_o.png">https://gitee.com/wang-qin928/c-language-learning/tree/master/function/%E9%98%9F%E5%88%97</span></span></a></p> 
<pre><code class="language-cpp">
typedef struct {
    Queue q1;
    Queue q2;
} MyStack;

MyStack* myStackCreate() {
    MyStack* pst = (MyStack*)malloc(sizeof(MyStack));
    QueueInit(&amp;(pst-&gt;q1));
    QueueInit(&amp;(pst-&gt;q2));

    return pst;
}

void myStackPush(MyStack* obj, int x) {
    QueuePush(&amp;(obj-&gt;q1),x);
}

int myStackPop(MyStack* obj) {
    while(QueueSize(&amp;(obj-&gt;q1)) != 1)
    {
        QueuePush(&amp;(obj-&gt;q2),QueueFront(&amp;(obj-&gt;q1)));
        QueuePop(&amp;(obj-&gt;q1));
    }
    int tmp = QueueFront(&amp;(obj-&gt;q1));
    QueuePop(&amp;(obj-&gt;q1));
    while(QueueSize(&amp;(obj-&gt;q2)))
    {
        QueuePush(&amp;(obj-&gt;q1),QueueFront(&amp;(obj-&gt;q2)));
        QueuePop(&amp;(obj-&gt;q2));
    }
    return tmp;
}

int myStackTop(MyStack* obj) {
    return QueueBack(&amp;(obj-&gt;q1));
}

bool myStackEmpty(MyStack* obj) {
    return !QueueSize(&amp;(obj-&gt;q1));
}

void myStackFree(MyStack* obj) {
    Destory(&amp;(obj-&gt;q1));
    Destory(&amp;(obj-&gt;q2));
    free(obj);
}</code></pre> 
<h2> 用栈实现队列</h2> 
<p><img src="https://images2.imgbox.com/aa/5c/pLDWUkiF_o.png" alt="55a9b73110954d878af70071ad863d35.png"></p> 
<h3>解析：</h3> 
<p>此题与上题思路差不多，有一些细节上的改变，我们在代码里面细说。</p> 
<h4>定义结构体MyQueue：</h4> 
<p>创建两个栈st1、st2</p> 
<h4>myQueueCreate函数：</h4> 
<p>为MyQueue结构体malloc一块空间，将里面的st1、st2交给 STInit函数。</p> 
<h4>myQueuePush函数：</h4> 
<p>直接利用STPush函数插入就行。</p> 
<h4>myQueuePeek函数：</h4> 
<p>这里判断一下，如果st2为空的话，就将st1的数据转到st2来，取栈顶元素返回（转过来的时候数据会反过来）如果st2不为空，就直接返回st2栈顶元素。</p> 
<h4>myQueuePop函数：</h4> 
<p>这里本来也是要进行判断、转数据的，但是我们可以简化一下代码，直接调用myQueuePeek返回值存起来，这样st2必然就有数据，我们就可以直接pop掉st2里面的数据。</p> 
<h4>myQueueEmpty函数：</h4> 
<p>只有st1、st2同时为空，这个队列才为空。</p> 
<h4>myQueueFree函数：</h4> 
<p>先用 STDestroy释放掉st1、st2的空间，之后再free掉obj。</p> 
<blockquote> 
 <p><strong>总结：此题目不用将st2的数据再转回到st1里，相当于st2是专门用来出数据的，st1专门用来入数据的。</strong></p> 
</blockquote> 
<h3>示例代码：</h3> 
<p><a class="has-card" href="https://gitee.com/wang-qin928/c-language-learning/tree/master/function/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%A0%88" rel="nofollow" title="function/数据结构_栈 · 钦某/c-language-learning - 码云 - 开源中国 (gitee.com)"><span class="link-card-box"><span class="link-title">function/数据结构_栈 · 钦某/c-language-learning - 码云 - 开源中国 (gitee.com)</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/76/17/P1rgcRlm_o.png">https://gitee.com/wang-qin928/c-language-learning/tree/master/function/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%A0%88</span></span></a></p> 
<pre><code class="language-cpp">typedef struct {
    ST st1;
    ST st2;
} MyQueue;

MyQueue* myQueueCreate() {
    MyQueue* Q = (MyQueue*)malloc(sizeof(MyQueue));
    STInit(&amp;(Q-&gt;st1));
    STInit(&amp;(Q-&gt;st2));
    return Q;
}

void myQueuePush(MyQueue* obj, int x) {
    STPush(&amp;(obj-&gt;st1),x);
}

int myQueuePop(MyQueue* obj) {
    int tmp = myQueuePeek(obj);
    STPop(&amp;(obj-&gt;st2));
    return tmp;
}

int myQueuePeek(MyQueue* obj) {
    if(STEmpty(&amp;(obj-&gt;st2)))
    {
        while(!STEmpty(&amp;(obj-&gt;st1)))
        {
            STPush(&amp;(obj-&gt;st2),STTop(&amp;(obj-&gt;st1)));
            STPop(&amp;(obj-&gt;st1));
        }
        return STTop(&amp;(obj-&gt;st2));
    }
    else
    {
        return STTop(&amp;(obj-&gt;st2));
    }
}

bool myQueueEmpty(MyQueue* obj) {
    return (STEmpty(&amp;(obj-&gt;st1)) &amp;&amp; STEmpty(&amp;(obj-&gt;st2)));
}

void myQueueFree(MyQueue* obj) {
    STDestroy(&amp;(obj-&gt;st1));
    STDestroy(&amp;(obj-&gt;st2));
    free(obj);
}</code></pre> 
<h2>设计循环队列 </h2> 
<p><img src="https://images2.imgbox.com/5b/b2/PLyyrwHR_o.png" alt="7695610debf84b95b303e6eb554eeb23.png"></p> 
<h3>解析：</h3> 
<p>用数组实现，多开辟一块空间，防止假溢出。或多定义一个size元素记录数组元素个数。主要都是为了解决判空和判满的问题。</p> 
<h4>定义MyCircularQueue结构体：</h4> 
<p>一个int*指针、一个head、一个tail、一个k表示队列容量。</p> 
<h4>myCircularQueueCreate函数：</h4> 
<p>为MyCircularQueue建立空间，并为data建立空间，其他值：obj-&gt;head = obj-&gt;tail = 0，obj-&gt;k = k。</p> 
<h4>myCircularQueueIsEmpty函数：</h4> 
<p>如果obj-&gt;head == obj-&gt;tail就为空，返回true，反之返回false。</p> 
<p><img src="https://images2.imgbox.com/9b/ec/b0bBTy3v_o.png" alt="09c5a4dc0d664cceb48796cde149f93b.png"></p> 
<h4>myCircularQueueIsFull函数：</h4> 
<p>如果obj-&gt;head == (obj-&gt;tail+1)%(obj-&gt;k+1)就为满，返回true，反之返回false。</p> 
<p><img src="https://images2.imgbox.com/62/af/ZNEZdgOQ_o.png" alt="2504324f2bc347de88ad48254f13d16a.png"></p> 
<h4>myCircularQueueEnQueue函数：</h4> 
<p>先判断是否为满，之后再往里面插入数据。注意这里tail的变化:</p> 
<blockquote> 
 <p style="text-align:center;">(obj-&gt;tail) %= (obj-&gt;k+1);</p> 
</blockquote> 
<h4>myCircularQueueDeQueue函数：</h4> 
<p>先判断是否为空，之后再删除数据。注意head的变化：</p> 
<blockquote> 
 <p style="text-align:center;"> (obj-&gt;head) %= (obj-&gt;k+1);</p> 
</blockquote> 
<h4>myCircularQueueFront函数：</h4> 
<blockquote> 
 <p style="text-align:center;">return myCircularQueueIsEmpty(obj)?-1:obj-&gt;data[obj-&gt;head];</p> 
</blockquote> 
<h4>myCircularQueueRear函数：</h4> 
<blockquote> 
 <p style="text-align:center;">return myCircularQueueIsEmpty(obj)?-1:obj-&gt;data[(obj-&gt;tail+obj-&gt;k)%(obj-&gt;k+1)];</p> 
</blockquote> 
<p>注意这里tail+1后可能回超出范围，所以我们要在这里模上(k+1)。</p> 
<h4>myCircularQueueFree函数：</h4> 
<p>先free掉obj-&gt;data,之后free掉obj。</p> 
<blockquote> 
 <p>总结：</p> 
 <p>我们要时刻注意，tail和head的范围，不能超过k，否则就应该模上(k+1)。其次这道题用单链表写会麻烦很多，因为不好处理循环的问题。如果你用双向循环链表，当我没说……（我们要用最少的消耗，干最多的事儿！）</p> 
</blockquote> 
<h3>示例代码：</h3> 
<pre><code class="language-cpp">typedef struct {
    int *data;
    int head;
    int tail;
    int k;
} MyCircularQueue;

MyCircularQueue* myCircularQueueCreate(int k) {
    MyCircularQueue* CQ = (MyCircularQueue*)malloc(sizeof(MyCircularQueue));
    CQ-&gt;data = (int*)malloc(sizeof(int)*(k+1));//data需另外开辟空间
    CQ-&gt;head = 0;
    CQ-&gt;tail = 0;
    CQ-&gt;k = k;
    return CQ;
}

bool myCircularQueueIsEmpty(MyCircularQueue* obj) {
    return obj-&gt;head == obj-&gt;tail;
}

bool myCircularQueueIsFull(MyCircularQueue* obj) {
    return (obj-&gt;tail+1) % (obj-&gt;k + 1) == obj-&gt;head;
}

bool myCircularQueueEnQueue(MyCircularQueue* obj, int value) {
    if(myCircularQueueIsFull(obj))
        return false;

    obj-&gt;data[obj-&gt;tail] = value;
    obj-&gt;tail++;
    (obj-&gt;tail) %= (obj-&gt;k+1);
    return true;
}

bool myCircularQueueDeQueue(MyCircularQueue* obj) {
    if(myCircularQueueIsEmpty(obj))
        return false;

    obj-&gt;head++;
    (obj-&gt;head) %= (obj-&gt;k+1);
    return true;
}

int myCircularQueueFront(MyCircularQueue* obj) {
    return myCircularQueueIsEmpty(obj)?-1:obj-&gt;data[obj-&gt;head];
}

int myCircularQueueRear(MyCircularQueue* obj) {
    return myCircularQueueIsEmpty(obj)?-1:obj-&gt;data[(obj-&gt;tail+obj-&gt;k)%(obj-&gt;k+1)];
}

void myCircularQueueFree(MyCircularQueue* obj) {
    free(obj-&gt;data);
    free(obj);
}</code></pre> 
<p style="text-align:center;"><strong>本期博客到这里就结束了，如果有什么错误，欢迎指出，如果对你有帮助，请点个赞，谢谢！</strong></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/30fc86647ae6260cf8beaf65779b5012/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Springboot3 链接Redis遇到的报错(本文仅记录保存，优质文章移步springboot专栏)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bfad77a1cd7de4b76b3e9166e2b9d4c4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【千帆AppBuidler】零代码构建AI人工智能应用，全网都在喊话歌手谁能应战，一键AI制作歌手信息查询应用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>