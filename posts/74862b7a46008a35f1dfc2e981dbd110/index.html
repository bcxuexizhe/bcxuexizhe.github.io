<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构的队列（c语言版） - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/74862b7a46008a35f1dfc2e981dbd110/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="数据结构的队列（c语言版）">
  <meta property="og:description" content="一.队列的概念 1.队列的定义 队列是一种常见的数据结构，它遵循先进先出的原则。类似于现实生活中排队的场景，最先进入队列的元素首先被处理，而最后进入队列的元素则要等到前面的元素都被处理完后才能被处理。
在队列中，元素只能从一端插入，称为队尾，而只能从另一端删除，称为队头。新的元素被插入到队尾，而最早插入的元素位于队头。这样，当一个元素被处理或删除时，它前面的元素就会成为新的队头。
2.队列的应用 队列的应用：
1.任务调度：多个任务按照顺序排队等待执行。
2.广度优先搜索（BFS）：在图或树的遍历中，按层次遍历节点。
3.缓存管理：缓存中的数据按照访问顺序排列，最先进入的数据最先被替换。
4.算法设计：某些算法的设计与队列密切相关，如哈夫曼编码、循环队列等。
3.队列的优缺点 优点：
先进先出（FIFO）：队列保持元素的插入顺序，最先插入的元素最先被处理，符合很多实际问题的需求。简单高效：队列的基本操作入队和出队的时间复杂度为O(1)，无论队列的大小如何，操作的时间复杂度都是固定的。应用广泛：队列在很多算法和应用中有广泛的应用，如任务调度、广度优先搜索、缓存管理等。 缺点：
随机访问困难：队列只允许在队头删除元素，而在队尾插入元素，不支持随机访问。如果需要在其他位置插入或删除元素，操作效率较低。队列大小限制：使用数组实现的队列在创建时需要指定最大容量，因此队列的大小有限。如果队列已满，则无法再插入新的元素。存储空间浪费：如果队列的实际元素数量远小于最大容量，那么可能会造成存储空间的浪费，因为队列的容量是固定的。 二.队列的功能 队列常见的功能：
入队：将一个元素插入到队列的尾部，成为新的队尾。出队：从队列的头部删除并返回一个元素，将队列的头部指针向后移动一位。获取队头元素：返回队列的头部元素，但不删除它。检查队列是否为空：检查队列中是否没有元素，即队列是否为空。检查队列是否已满：检查队列是否已达到其最大容量，无法再插入新的元素。清空队列：将队列中的所有元素删除，使其变为空队列。获取队列中元素的数量：返回队列中元素的当前数量。遍历队列：从队列的头部开始遍历到尾部，依次访问每个元素。 三.队列的实现 1.定义队列结构 Queue 是一个结构体类型，包含以下成员：
elements：类型为 int* 的指针，用于存储队列中的元素。通常情况下，可以通过动态内存分配来为该指针分配足够的内存空间，以存储队列的元素。front：整型变量，表示队列头部的索引。它指向队列中的第一个元素。rear：整型变量，表示队列尾部的索引。它指向队列中最后一个元素。maxSize：整型变量，表示队列的最大容量。它用于限制队列中元素的数量，防止队列溢出。 typedef struct { int* elements; // 存储元素的数组 int front; // 队列头部索引 int rear; // 队列尾部索引 int maxSize; // 队列的最大容量 } Queue; 2.初始化队列 initQueue(Queue* queue, int maxSize)：初始化队列。该函数接受一个指向 Queue 结构的指针以及队列的最大容量 maxSize。在函数内部，它为队列的元素数组分配内存空间，并将队列的头部索引 front 设置为 0，尾部索引 rear 设置为 -1，表示队列为空。
// 初始化队列 void initQueue(Queue* queue, int maxSize) { queue-&gt;elements = (int*)malloc(sizeof(int) * maxSize); queue-&gt;front = 0; queue-&gt;rear = -1; queue-&gt;maxSize = maxSize; } 3.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-02T15:29:34+08:00">
    <meta property="article:modified_time" content="2024-05-02T15:29:34+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构的队列（c语言版）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一.队列的概念</h2> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ae/26/VhYGTGD4_o.png"></p> 
<h3>1.队列的定义</h3> 
<p><span style="color:#fe2c24;">队列是一种常见的数据结构，它遵循先进先出的原则。</span>类似于现实生活中排队的场景，最先进入队列的元素首先被处理，而最后进入队列的元素则要等到前面的元素都被处理完后才能被处理。</p> 
<p>在队列中，元素只能从一端插入，称为队尾，而只能从另一端删除，称为队头。新的元素被插入到队尾，而最早插入的元素位于队头。这样，当一个元素被处理或删除时，它前面的元素就会成为新的队头。</p> 
<h3>2.队列的应用</h3> 
<p>队列的应用：</p> 
<p>1.任务调度：多个任务按照顺序排队等待执行。</p> 
<p>2.广度优先搜索（BFS）：在图或树的遍历中，按层次遍历节点。</p> 
<p>3.缓存管理：缓存中的数据按照访问顺序排列，最先进入的数据最先被替换。</p> 
<p>4.算法设计：某些算法的设计与队列密切相关，如哈夫曼编码、循环队列等。</p> 
<h3>3.队列的优缺点</h3> 
<p>优点：</p> 
<ol><li>先进先出（FIFO）：队列保持元素的插入顺序，最先插入的元素最先被处理，符合很多实际问题的需求。</li><li>简单高效：队列的基本操作入队和出队的时间复杂度为O(1)，无论队列的大小如何，操作的时间复杂度都是固定的。</li><li>应用广泛：队列在很多算法和应用中有广泛的应用，如任务调度、广度优先搜索、缓存管理等。</li></ol> 
<p>缺点：</p> 
<ol><li>随机访问困难：队列只允许在队头删除元素，而在队尾插入元素，不支持随机访问。如果需要在其他位置插入或删除元素，操作效率较低。</li><li>队列大小限制：使用数组实现的队列在创建时需要指定最大容量，因此队列的大小有限。如果队列已满，则无法再插入新的元素。</li><li>存储空间浪费：如果队列的实际元素数量远小于最大容量，那么可能会造成存储空间的浪费，因为队列的容量是固定的。</li></ol> 
<h2 style="background-color:transparent;">二.队列的功能</h2> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/de/8c/QaHBp0U5_o.png"></p> 
<p>队列常见的功能：</p> 
<ol><li>入队：将一个元素插入到队列的尾部，成为新的队尾。</li><li>出队：从队列的头部删除并返回一个元素，将队列的头部指针向后移动一位。</li><li>获取队头元素：返回队列的头部元素，但不删除它。</li><li>检查队列是否为空：检查队列中是否没有元素，即队列是否为空。</li><li>检查队列是否已满：检查队列是否已达到其最大容量，无法再插入新的元素。</li><li>清空队列：将队列中的所有元素删除，使其变为空队列。</li><li>获取队列中元素的数量：返回队列中元素的当前数量。</li><li>遍历队列：从队列的头部开始遍历到尾部，依次访问每个元素。</li></ol> 
<h2>三.队列的实现</h2> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3e/1e/UjKvxn29_o.jpg"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/27/51/hdX4Xhbr_o.png"> </p> 
<h3>1.定义队列结构</h3> 
<p><code>Queue</code> 是一个结构体类型，包含以下成员：</p> 
<ul><li><code>elements</code>：类型为 <code>int*</code> 的指针，用于存储队列中的元素。通常情况下，可以通过动态内存分配来为该指针分配足够的内存空间，以存储队列的元素。</li><li><code>front</code>：整型变量，表示队列头部的索引。它指向队列中的第一个元素。</li><li><code>rear</code>：整型变量，表示队列尾部的索引。它指向队列中最后一个元素。</li><li><code>maxSize</code>：整型变量，表示队列的最大容量。它用于限制队列中元素的数量，防止队列溢出。</li></ul> 
<pre><code class="language-cpp">typedef struct {
    int* elements;  // 存储元素的数组
    int front;      // 队列头部索引
    int rear;       // 队列尾部索引
    int maxSize;    // 队列的最大容量
} Queue;</code></pre> 
<h3> 2.初始化队列</h3> 
<p><code>initQueue(Queue* queue, int maxSize)</code>：初始化队列。该函数接受一个指向 <code>Queue</code> 结构的指针以及队列的最大容量 <code>maxSize</code>。在函数内部，它为队列的元素数组分配内存空间，并将队列的头部索引 <code>front</code> 设置为 0，尾部索引 <code>rear</code> 设置为 -1，表示队列为空。</p> 
<p> </p> 
<pre><code class="language-cpp">// 初始化队列
void initQueue(Queue* queue, int maxSize) {
    queue-&gt;elements = (int*)malloc(sizeof(int) * maxSize);
    queue-&gt;front = 0;
    queue-&gt;rear = -1;
    queue-&gt;maxSize = maxSize;
}
</code></pre> 
<h3>3.判断队列是否为空</h3> 
<p><code>isEmpty(Queue* queue)</code>：检查队列是否为空。该函数接受一个指向 <code>Queue</code> 结构的指针，并根据队列的头部索引和尾部索引的关系来判断队列是否为空。如果队列为空，返回 1；否则，返回 0。</p> 
<pre><code class="language-cpp">/ 检查队列是否为空
int isEmpty(Queue* queue) {
    return (queue-&gt;rear &lt; queue-&gt;front);
}</code></pre> 
<p> </p> 
<h3>4.判断队列是否已满</h3> 
<p><code>isFull(Queue* queue)</code>：检查队列是否已满。该函数接受一个指向 <code>Queue</code> 结构的指针，并根据队列的头部索引和尾部索引的关系来判断队列是否已满。如果队列已满，返回 1；否则，返回 0。</p> 
<pre><code class="language-cpp">// 检查队列是否已满
int isFull(Queue* queue) {
    return (queue-&gt;rear == queue-&gt;maxSize - 1);
}</code></pre> 
<p> </p> 
<h3>5.入队</h3> 
<p><code>enqueue(Queue* queue, int element)</code>：入队。该函数接受一个指向 <code>Queue</code> 结构的指针和要插入的元素 <code>element</code>。在函数内部，它首先检查队列是否已满，如果已满，则打印出队列已满的提示信息并返回；否则，将尾部索引 <code>rear</code> 增加 1，并将元素 <code>element</code> 存储在队列的尾部。</p> 
<pre><code class="language-cpp">// 入队
void enqueue(Queue* queue, int element) {
    if (isFull(queue)) {
        printf("队列已满，无法入队。\n");
        return;
    }
    queue-&gt;rear++;
    queue-&gt;elements[queue-&gt;rear] = element;
}</code></pre> 
<p> </p> 
<h3>6.出队</h3> 
<p><code>dequeue(Queue* queue)</code>：出队。该函数接受一个指向 <code>Queue</code> 结构的指针，并返回队列头部的元素。在函数内部，它首先检查队列是否为空，如果为空，则打印出队列为空的提示信息并返回 -1；否则，将头部索引 <code>front</code> 增加 1，并返回队列头部的元素。</p> 
<pre><code class="language-cpp">// 出队
int dequeue(Queue* queue) {
    if (isEmpty(queue)) {
        printf("队列为空，无法出队。\n");
        return -1;
    }
    int element = queue-&gt;elements[queue-&gt;front];
    queue-&gt;front++;
    return element;
}
</code></pre> 
<p> </p> 
<h3>7.获取队列头部信息</h3> 
<p><code>getFront(Queue* queue)</code>：获取队列头部元素。该函数接受一个指向 <code>Queue</code> 结构的指针，并返回队列头部的元素，但不删除它。在函数内部，它首先检查队列是否为空，如果为空，则打印出队列为空的提示信息并返回 -1；否则，返回队列头部的元素。</p> 
<pre><code class="language-cpp">// 获取队列头部元素
int getFront(Queue* queue) {
    if (isEmpty(queue)) {
        printf("队列为空，无法获取头部元素。\n");
        return -1;
    }
    return queue-&gt;elements[queue-&gt;front];
}
</code></pre> 
<p> </p> 
<h3>8.释放内存</h3> 
<p><code>freeQueue(Queue* queue)</code>：释放队列内存空间。该函数接受一个指向 <code>Queue</code> 结构的指针，并释放队列的元素数组所占用的内存空间。</p> 
<pre><code class="language-cpp">// 释放队列内存空间
void freeQueue(Queue* queue) {
    free(queue-&gt;elements);
}
</code></pre> 
<p> </p> 
<h2>四.队列的源码呈现</h2> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// 定义队列结构
typedef struct {
    int* elements;  // 存储元素的数组
    int front;      // 队列头部索引
    int rear;       // 队列尾部索引
    int maxSize;    // 队列的最大容量
} Queue;

// 初始化队列
void initQueue(Queue* queue, int maxSize) {
    queue-&gt;elements = (int*)malloc(sizeof(int) * maxSize);
    queue-&gt;front = 0;
    queue-&gt;rear = -1;
    queue-&gt;maxSize = maxSize;
}

// 检查队列是否为空
int isEmpty(Queue* queue) {
    return (queue-&gt;rear &lt; queue-&gt;front);
}

// 检查队列是否已满
int isFull(Queue* queue) {
    return (queue-&gt;rear == queue-&gt;maxSize - 1);
}

// 入队
void enqueue(Queue* queue, int element) {
    if (isFull(queue)) {
        printf("队列已满，无法入队。\n");
        return;
    }
    queue-&gt;rear++;
    queue-&gt;elements[queue-&gt;rear] = element;
}

// 出队
int dequeue(Queue* queue) {
    if (isEmpty(queue)) {
        printf("队列为空，无法出队。\n");
        return -1;
    }
    int element = queue-&gt;elements[queue-&gt;front];
    queue-&gt;front++;
    return element;
}

// 获取队列头部元素
int getFront(Queue* queue) {
    if (isEmpty(queue)) {
        printf("队列为空，无法获取头部元素。\n");
        return -1;
    }
    return queue-&gt;elements[queue-&gt;front];
}

// 释放队列内存空间
void freeQueue(Queue* queue) {
    free(queue-&gt;elements);
}

int main() {
    Queue queue;
    int maxSize = 5;
    
    // 初始化队列
    initQueue(&amp;queue, maxSize);
    
    // 入队
    enqueue(&amp;queue, 10);
    enqueue(&amp;queue, 20);
    enqueue(&amp;queue, 30);
    
    // 出队
    int element = dequeue(&amp;queue);
    printf("出队元素：%d\n", element);
    
    // 获取队列头部元素
    int frontElement = getFront(&amp;queue);
    printf("队列头部元素：%d\n", frontElement);
    
    // 释放队列内存空间
    freeQueue(&amp;queue);
    
    return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/54b017e4750c95914078a18fb229129b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">视频生成Sora的全面解析：从AI绘画、ViT到ViViT、TECO、DiT、VDT、NaViT等</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e986146f04d0d39110e031ccf804303c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构】链表专题3</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>