<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C语言】明析部分C语言内存函数 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/4c6d4ea80e0b2e0192e9c04aaed0a91a/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【C语言】明析部分C语言内存函数">
  <meta property="og:description" content="目录
1.memcpy
2.memmove
3.memset
4.memcmp
以下都是内存函数，作用单位均是字节
1.memcpy memcpy是C/C&#43;&#43;语言中的一个内存拷贝函数，其原型为：
void* memcpy(void* dest, const void* src, size_t n); 目标空间（字节） 源空间（字节） 拷贝个数 该函数的功能是将源地址src开始的n个字节内容复制到目标地址dest开始的内存空间。 使用memcpy函数需要注意以下几点：
要确保目标地址dest有足够的空间来存放从源地址src复制过来的数据，否则可能会发生内存溢出。要确保源地址src和目标地址dest指向的内存内容是可读写的。在使用该函数时需要注意边界情况，即源地址src和目标地址dest的有效数据范围。 接下来，我们观察memcpy函数：
#include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { const char* src = &#34;Hello, memcpy!&#34;; char dest[20]; // 复制字符串到dest中 memcpy(dest, src, strlen(src) &#43; 1); // 输出复制后的字符串 printf(&#34;Copied string: %s\n&#34;, dest); return 0; } 程序运行结果：
Copied string: Hello, memcpy! 很显然，源字符串“Hello, memcpy!”已成功被复制到了目标字符数组dest中。
现在，我们来观察memcpy函数的实现方式：
//Memcpy #include&lt;stdio.h&gt; #include&lt;assert.h&gt; void* Memcpy(void* dest, const void* src, size_t byte_num) { assert(dest &amp;&amp; src); char* ptr_1 = (char*)dest; const char* ptr_2 = (const char*)src; while (byte_num) { *ptr_1 = *ptr_2; ptr_1&#43;&#43;; ptr_2&#43;&#43;; byte_num--; } return dest;//返回指向目标内存块的指针。 } int main() { int arr[] = { 1,2,3,4,5,6,7,8,9,0 }; int src[] = { 8,8,8,8,8,8,8,8,8,8 }; Memcpy(arr, src, 15); for (int i = 0; i &lt; sizeof(arr) / sizeof(arr[0]); i&#43;&#43;) { printf(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-24T08:30:00+08:00">
    <meta property="article:modified_time" content="2024-05-24T08:30:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C语言】明析部分C语言内存函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><span style="color:#38d8f0;"><strong>目录</strong></span></p> 
<p id="1.memcpy-toc" style="margin-left:0px;"><a href="#1.memcpy" rel="nofollow"><span style="color:#38d8f0;">1.memcpy</span></a></p> 
<p id="2.memmove-toc" style="margin-left:0px;"><a href="#2.memmove" rel="nofollow"><span style="color:#38d8f0;">2.memmove</span></a></p> 
<p id="3.memset-toc" style="margin-left:0px;"><a href="#3.memset" rel="nofollow"><span style="color:#38d8f0;">3.memset</span></a></p> 
<p id="4.memcmp-toc" style="margin-left:0px;"><a href="#4.memcmp" rel="nofollow"><span style="color:#38d8f0;">4.memcmp</span></a></p> 
<hr id="hr-toc"> 
<p style="text-align:center;"><img alt="" height="218" src="https://images2.imgbox.com/b9/36/Fge8BM6g_o.jpg" width="468"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d1/eb/wISu3b9F_o.gif"></p> 
<p><strong><span style="background-color:#fefcd8;">以下都是内存函数，作用单位均是字节</span></strong></p> 
<h2 id="1.memcpy"><span style="color:#fe2c24;"><strong><span style="background-color:#d7d8d9;">1.memcpy</span></strong></span></h2> 
<blockquote> 
 <h2></h2> 
 <p><strong>memcpy</strong>是C/C++语言中的一个内存拷贝函数，其原型为：</p> 
</blockquote> 
<pre><code class="language-cpp">void* memcpy(void* dest, const void* src, size_t n);
            目标空间（字节）  源空间（字节）  拷贝个数</code></pre> 
<blockquote> 
 <p>该函数的功能是将源地址src开始的n个字节内容复制到目标地址dest开始的内存空间。 </p> 
</blockquote> 
<p><span style="background-color:#fbd4d0;">使用memcpy函数需要注意以下几点：</span></p> 
<ul><li><span style="background-color:#edf6e8;">要确保目标地址dest有足够的空间来存放从源地址src复制过来的数据，否则可能会发生内存溢出。</span></li><li><span style="background-color:#edf6e8;">要确保源地址src和目标地址dest指向的内存内容是可读写的。</span></li><li><span style="background-color:#edf6e8;">在使用该函数时需要注意边界情况，即源地址src和目标地址dest的有效数据范围。</span></li></ul> 
<p><span style="background-color:#fbd4d0;">接下来，我们观察memcpy函数：</span></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    const char* src = "Hello, memcpy!";
    char dest[20];

    // 复制字符串到dest中
    memcpy(dest, src, strlen(src) + 1);

    // 输出复制后的字符串
    printf("Copied string: %s\n", dest);

    return 0;
}</code></pre> 
<p><span style="background-color:#fbd4d0;">程序运行结果：</span></p> 
<pre><code class="language-cpp">Copied string: Hello, memcpy!</code></pre> 
<p><span style="background-color:#fbd4d0;">很显然，源字符串“Hello, memcpy!”已成功被复制到了目标字符数组</span><code><span style="background-color:#fbd4d0;">dest</span></code><span style="background-color:#fbd4d0;">中。</span></p> 
<p><span style="background-color:#fbd4d0;">现在，我们来观察memcpy函数的实现方式：</span></p> 
<pre><code class="language-cpp">//Memcpy
#include&lt;stdio.h&gt;
#include&lt;assert.h&gt;

void* Memcpy(void* dest, const void* src, size_t byte_num) {
	assert(dest &amp;&amp; src);
	char* ptr_1 = (char*)dest;
	const char* ptr_2 = (const char*)src;
	while (byte_num) {
		*ptr_1 = *ptr_2;
		ptr_1++;
		ptr_2++;
		byte_num--;
	}
	return dest;//返回指向目标内存块的指针。
}

int main() {
	int arr[] = { 1,2,3,4,5,6,7,8,9,0 };
	int src[] = { 8,8,8,8,8,8,8,8,8,8 };
	Memcpy(arr, src, 15);
	for (int i = 0; i &lt; sizeof(arr) / sizeof(arr[0]); i++) {
		printf("%d ", arr[i]);
	}
	return 0;
}</code></pre> 
<p></p> 
<hr> 
<h2 id="2.memmove"><span style="color:#fe2c24;"><strong><span style="background-color:#d7d8d9;">2.memmove</span></strong></span></h2> 
<blockquote> 
 <p><strong>memmove</strong>函数与memcpy函数功能相似，但是memmove函数会考虑<strong>源地址和目标地址重叠</strong>的情况，它会根据具体情况采取不同的拷贝方式，避免<strong>数据错误或内存访问冲突</strong>。</p> 
</blockquote> 
<p> <span style="background-color:#fbd4d0;">接下来，我们观察memmove函数：</span></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char str[50] = "Hello, memmove!";
    char buffer[20];
    
    // 复制数据到buffer，源和目标地址重叠
    memmove(str + 7, str, strlen(str) + 1); 

    // 输出复制后的字符串
    printf("Copied string: %s\n", str);

    return 0;
}</code></pre> 
<p> <span style="background-color:#fbd4d0;">很容易发现，memmove函数可以作用于同一个函数</span></p> 
<p> <span style="background-color:#fbd4d0;">我们再看看该函数的模拟实现：</span></p> 
<pre><code class="language-cpp">void* my_memmove(void* dest, const void* src, size_t n) {
    char* d = (char*)dest;
    const char* s = (const char*)src;
    
    // 判断源地址和目标地址是否有重叠
    if (d &lt; s) {
        for (size_t i = 0; i &lt; n; i++) {
            d[i] = s[i];
        }
    } else if (d &gt; s) {
        for (size_t i = n; i &gt; 0; i--) {
            d[i - 1] = s[i - 1];
        }
    }
    
    return dest;
}</code></pre> 
<blockquote> 
 <p><code>my_memmove</code>函数和标准的<code>memmove</code>函数功能类似，可以处理源地址和目标地址重叠的情况。如果源地址在目标地址之前，就从源地址前往后复制数据；如果源地址在目标地址之后，就从源地址后往前复制数据。</p> 
</blockquote> 
<h2 id="3.memset"><span style="color:#fe2c24;"><strong><span style="background-color:#d7d8d9;">3.memset</span></strong></span></h2> 
<blockquote> 
 <p><strong> memset</strong>函数是C标准库中的一个函数，用于将一块内存空间的内容全部设置为指定的值。</p> 
</blockquote> 
<p><span style="background-color:#fbd4d0;">接下来，我们观察memset函数：</span> </p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char str[50];
    
    // 初始化str数组为0
    memset(str, 0, sizeof(str));

    // 打印初始化后的字符串
    printf("Initialized string: %s\n", str);

    return 0;
}</code></pre> 
<pre><code class="language-cpp">Initialized string:</code></pre> 
<blockquote> 
 <p> 在这个例子中，我们先定义了一个字符数组<code>str</code>，然后使用<code>memset</code>函数将<code>str</code>数组内的内存空间全部设置为0。最后打印出初始化后的字符串内容，因为全部设置为0，所以输出结果为"Initialized string: "。</p> 
</blockquote> 
<p><code><span style="background-color:#e7fafa;">   memset</span></code><span style="background-color:#e7fafa;">函数通常用于在初始化数据结构或清空内存块时设置初始值，例如<strong><span style="color:#fe2c24;">清空一个数组、结构体或其他内存区域</span></strong>的内容。</span></p> 
<p><span style="background-color:#fbd4d0;">我们再看看该函数的模拟实现：</span></p> 
<pre><code class="language-cpp">void* my_memset(void* ptr, int value, size_t num) {
    unsigned char* p = (unsigned char*)ptr;
    for (size_t i = 0; i &lt; num; i++) {
        p[i] = (unsigned char)value;
    }
    return ptr;
}</code></pre> 
<blockquote> 
 <p> 这个模拟实现的<code>my_memset</code>函数功能类似于标准的<code>memset</code>函数，通过将内存空间中的每个字节设置为指定的值来实现初始化。传入的参数包括要初始化的内存位置的指针 <code>ptr</code>，要设置的值 <code>value</code>，以及要初始化的字节数 <code>num</code>。循环遍历内存空间，将每个字节设置为指定的值。最后返回指向初始化后的内存空间的指针。</p> 
</blockquote> 
<h2 id="4.memcmp"><span style="color:#fe2c24;"><strong><span style="background-color:#d7d8d9;">4.memcmp</span></strong></span></h2> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong><code>memcmp</code></strong></span>是C标准库中的一个函数，用于比较两块内存区域的内容。</p> 
</blockquote> 
<p><span style="background-color:#fbd4d0;">接下来，我们观察memset函数：</span> </p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char str1[] = "Hello";
    char str2[] = "World";

    int result = memcmp(str1, str2, 5);

    if (result == 0) {
        printf("str1 and str2 are equal.\n");
    } else if (result &lt; 0) {
        printf("str1 is less than str2.\n");
    } else {
        printf("str1 is greater than str2.\n");
    }

    return 0;
}</code></pre> 
<pre><code class="language-cpp">str1 is less than str2.</code></pre> 
<blockquote> 
 <p>这是因为在ASCII编码中，字符'H'的ASCII码小于字符'W'的ASCII码。因此，<code>str1</code>在内存中的前5个字符的比较结果是<code>str1</code>小于<code>str2</code>。 </p> 
</blockquote> 
<p style="text-align:center;"><strong><span style="color:#38d8f0;">Over……希望对你有帮助，fight together！</span></strong><img alt="" src="https://images2.imgbox.com/f8/6b/g60BacYO_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fdd3725760f5c70ccb8b7b514fda2144/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">React是什么？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9c821b638990ed870bd3b815c5ffe33e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">音视频--音频实时传输</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>