<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【JAVA】javadoc，如何生成标准的JAVA API文档 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/dfa2cdd6c9f713259db411ddd4dc0c3e/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【JAVA】javadoc，如何生成标准的JAVA API文档">
  <meta property="og:description" content="目录
1.什么是JAVA DOC
2.标签
3.命令
1.什么是JAVA DOC 当我们写完JAVA代码，别人要调用我们的代码的时候要是没有API文档是很痛苦的，只能跟进源码去一个个的看，一个个方法的猜，并且JAVA本来就不是一个重复造轮子的游戏，一般一些常用的轮子早就已经早好了，直接拿来用就是。但是拿来用的时候往往由于API文档的缺失或者不规范，造成使用上的很多痛苦，大家在很多实际工作中经常也会遇到类似的场景：
公司多年累积下来的工具类或者提供底层能力的公共模块里面积累了很多能力，公司为了代码规范也要求我们尽量去调用这些工具类或者公共模块。但是：
没有API文档或者文档写的很烂
参数列表动不动就很长，数十个甚至几十个参数
参数列表没有注释，出现一些莫名其妙的参数，都不知道怎么传
方法名也不能见名知意
造成往往要用这些公共能力的时候甚至还要去读源码
有读源码这个时间，可能自己都重新写了一个了，而且自己写的，可能比祖传下来的那些工具类还更“清爽”一些。于是系统内越来越多工具类堆积，重复造的轮子越来越多，“屎山”越堆越高。
即使有时候我们有API文档，但是各类API文档，格式，内容都不相同，没有统一的规范，读起来其实也很慢。所以有没有一个统一的规范喃？JAVA官方其实早就想到了这个问题，在JDK1.1发布的时候就附带了JAVA DOC，支持用标签注释的方式给各个方法做好规范的说明，然后用JAVA命令一键生成可视化的HTML页面作为API。
2.标签 标签是JAVA DOC的核心，用什么标签，JAVA DOC最后就会对应生成哪些API文档内容：
@author:
/** * @author John Doe */ public class MyClass { } @version:
/** * @version 1.0.1 */ public class MyClass { } @param:
/** * Concatenates two strings. * @param string1 The first string to concatenate. * @param string2 The second string to concatenate. * @return The concatenated string.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-30T20:34:13+08:00">
    <meta property="article:modified_time" content="2024-04-30T20:34:13+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【JAVA】javadoc，如何生成标准的JAVA API文档</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<p><img src="https://images2.imgbox.com/5e/85/3KYbgosl_o.png" alt="4cdbd0f2fe404d5fb6849eb73a7ce9a0.png"></p> 
<p><strong>目录</strong></p> 
<p style="margin-left:0px;"><a href="#1.%E4%BB%80%E4%B9%88%E6%98%AFJAVA%20DOC" rel="nofollow">1.什么是JAVA DOC</a></p> 
<p style="margin-left:0px;"><a href="#2.%E6%A0%87%E7%AD%BE" rel="nofollow">2.标签</a></p> 
<p style="margin-left:0px;"><a href="#3.%E5%91%BD%E4%BB%A4" rel="nofollow">3.命令</a></p> 
<hr> 
<p> </p> 
<h2>1.什么是JAVA DOC</h2> 
<p>当我们写完JAVA代码，别人要调用我们的代码的时候要是没有API文档是很痛苦的，只能跟进源码去一个个的看，一个个方法的猜，并且JAVA本来就不是一个重复造轮子的游戏，一般一些常用的轮子早就已经早好了，直接拿来用就是。但是拿来用的时候往往由于API文档的缺失或者不规范，造成使用上的很多痛苦，大家在很多实际工作中经常也会遇到类似的场景：</p> 
<p>公司多年累积下来的工具类或者提供底层能力的公共模块里面积累了很多能力，公司为了代码规范也要求我们尽量去调用这些工具类或者公共模块。但是：</p> 
<ul><li> <p>没有API文档或者文档写的很烂</p> </li><li> <p>参数列表动不动就很长，数十个甚至几十个参数</p> </li><li> <p>参数列表没有注释，出现一些莫名其妙的参数，都不知道怎么传</p> </li><li> <p>方法名也不能见名知意</p> </li><li> <p>造成往往要用这些公共能力的时候甚至还要去读源码</p> </li></ul> 
<p>有读源码这个时间，可能自己都重新写了一个了，而且自己写的，可能比祖传下来的那些工具类还更“清爽”一些。于是系统内越来越多工具类堆积，重复造的轮子越来越多，“屎山”越堆越高。</p> 
<p>即使有时候我们有API文档，但是各类API文档，格式，内容都不相同，没有统一的规范，读起来其实也很慢。所以有没有一个统一的规范喃？JAVA官方其实早就想到了这个问题，在JDK1.1发布的时候就附带了JAVA DOC，支持用标签注释的方式给各个方法做好规范的说明，然后用JAVA命令一键生成可视化的HTML页面作为API。</p> 
<h2>2.标签</h2> 
<p>标签是JAVA DOC的核心，用什么标签，JAVA DOC最后就会对应生成哪些API文档内容：</p> 
<p>@author:</p> 
<pre><code class="language-java">   /**
    * @author John Doe
    */
   public class MyClass {
   }</code></pre> 
<p>@version:</p> 
<pre>   /**
    * @version 1.0.1
    */
   public class MyClass {
   }</pre> 
<p>@param:</p> 
<pre>   /**
    * Concatenates two strings.
    * @param string1 The first string to concatenate.
    * @param string2 The second string to concatenate.
    * @return The concatenated string.
    */
   public String concatenateStrings(String string1, String string2) {
       return string1 + string2;
   }</pre> 
<p>@return:</p> 
<pre>   /**
    * Returns the sum of two integers.
    * @param num1 The first integer.
    * @param num2 The second integer.
    * @return The sum of num1 and num2.
    */
   public int add(int num1, int num2) {
       return num1 + num2;
   }</pre> 
<p>@throws 或 @exception: 描述方法可能抛出的异常。</p> 
<pre>   /**
    * Divides two numbers and throws an exception if the divisor is zero.
    * @param dividend The number to be divided.
    * @param divisor The divisor.
    * @return The result of the division.
    * @throws ArithmeticException If the divisor is zero.
    */
   public double safeDivide(double dividend, double divisor) {
       if (divisor == 0) {
           throw new ArithmeticException("Divisor cannot be zero.");
       }
       return dividend / divisor;
   }</pre> 
<p>@see:</p> 
<pre>   /**
    * See {@link java.util.ArrayList} for more information on dynamic arrays.
    */
   public class MyDynamicArray {
   }</pre> 
<p>@link: 创建一个链接到其他类、方法或字段的链接。</p> 
<pre>   /**
    * This method uses the {@link java.util.Collections#shuffle(List)} method to randomize the list.
    */
   public void shuffleList(List&lt;?&gt; list) {
       Collections.shuffle(list);
   }</pre> 
<p>@since: 指定该元素是从哪个版本开始引入的。</p> 
<pre>   /**
    * A utility class for working with dates.
    * @since 1.5
    */
   public class DateUtils {
   }</pre> 
<p>@deprecated: 标记不再推荐使用的元素。</p> 
<pre>   /**
    * Old method that should not be used anymore.
    * @deprecated Use the {@link #newMethod()} instead.
    */
   @Deprecated
   public void oldMethod() {
   }</pre> 
<p>@inheritDoc: 继承父类或接口的 JavaDoc。</p> 
<pre>    /**
     * {@inheritDoc}
     */
    @Override
    public void someMethod() {
        // Implementation
    }</pre> 
<p>@parametricType: 用于描述泛型类型参数。</p> 
<pre>    /**
     * Represents a generic collection.
     * @param &lt;E&gt; The type of elements in this collection.
     */
    public class MyCollection&lt;E&gt; {
    }</pre> 
<p>@serialField 和 @serialData: 用于序列化类的字段和数据。</p> 
<pre>/**
 * A serializable class.
 * @serialField name The name of the object.
 * @serialData The length of the name.
 */
@Serial
private static final long serialVersionUID = 1L;
​
private String name;
// serialization logic</pre> 
<h2>3.命令</h2> 
<p>javadoc命令用于生成API文档，其支持多种参数：</p> 
<blockquote> 
 <p>javadoc [options] [source files]</p> 
</blockquote> 
<p>常用参数：</p> 
<ul><li>-d &lt;directory&gt;: 指定输出目录，存放生成的 HTML 文件。</li><li>-sourcepath &lt;pathlist&gt;: 指定源文件路径，可以是多个路径，用分隔符（如冒号或分号）分隔。</li><li>-subpackages &lt;packagename&gt;: 递归处理指定包及其子包下的所有类。</li><li>-classpath &lt;classpath&gt;: 设置类路径，用于解析类型引用。</li><li>-encoding &lt;encoding&gt;: 指定源文件的字符编码。</li><li>-charset &lt;charset&gt;: 指定生成文档时使用的字符集。</li><li>-windowtitle &lt;text&gt;: 设置文档窗口标题。</li><li>-doctitle &lt;text&gt;: 设置文档页面的标题。</li><li>-overview &lt;filename&gt;: 指定概述文件，用于文档的首页内容。</li><li>-exclude &lt;patternlist&gt;: 指定要排除的包或类的模式列表。</li><li>-private: 包含私有成员的文档。</li><li>-protected: 默认行为，包含受保护和公开成员的文档。</li><li>-public: 只包含公共成员的文档。</li></ul> 
<p>示例：</p> 
<p>假设你有一个名为 com.example 的包，位于 /src/main/java 目录下，你想生成包含所有公共和受保护成员的 API 文档，并将输出文件保存在 /docs/api 目录下，同时指定字符编码为 UTF-8，可以使用以下命令：</p> 
<p>javadoc -encoding UTF-8 -charset UTF-8 -d /docs/api -sourcepath /src/main/java -subpackages com.example</p> 
<p>搞一个类来把注解都用上，然后生成API文档看看：</p> 
<pre><code class="language-java">package com.eryi.config;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

/**
 * @author John Doe
 * @version 1.0.0
 * @since 2022-04-01
 * @deprecated Since version 1.1.0, use the {@link BetterFileManager} instead.
 * This class provides basic file management operations.
 */
@Deprecated
public class FileManager {

    /**
     * @param filePath The path of the file to check.
     * @return True if the file exists, false otherwise.
     * @see File#exists()
     * @throws NullPointerException If the filePath is null.
     */
    public boolean fileExists(String filePath) {
        if (filePath == null) {
            throw new NullPointerException("FilePath cannot be null.");
        }

        File file = new File(filePath);
        return file.exists();
    }

    /**
     * @param fileName The name of the file to create.
     * @param content The content to write into the file.
     * @return The newly created file.
     * @throws IOException If there's any issue creating or writing to the file.
     * @see File#createNewFile()
     * @see FileWriter
     */
    public File createFileWithContent(String fileName, String content) throws IOException {
        File file = new File(fileName);
        if (!file.createNewFile()) {
            throw new IOException("Failed to create file: " + fileName);
        }

        try (FileWriter writer = new FileWriter(file)) {
            writer.write(content);
        }
        return file;
    }

    /**
     * A sample file path constant.
     * @since 1.0.0
     */
    @Deprecated
    public static final String SAMPLE_FILE_PATH = "resources/sample.txt";

    /**
     * @param args Command-line arguments (not used in this example).
     */
    public static void main(String[] args) {
        FileManager fileManager = new FileManager();
        System.out.println("Does sample file exist? " + fileManager.fileExists(SAMPLE_FILE_PATH));
    }
}
</code></pre> 
<p>直接JAVADOC：</p> 
<p><img src="https://images2.imgbox.com/8a/c4/PaLphXpF_o.png" alt="82f2e61264ab41cc86c3ba0659c1b986.png"></p> 
<p>会在路径下生成一堆东西，需要用的只有index.html，其它的都是为了支持这个index.html的资源文件而已：</p> 
<p><img src="https://images2.imgbox.com/ff/88/K6iwfQHB_o.png" alt="650a6514057f443aa5ac4b82f70712e2.png"></p> 
<p>看看效果：</p> 
<p>可以看到关于这个类的什么都有：</p> 
<p><img src="https://images2.imgbox.com/1d/9c/92a4ryoi_o.png" alt="9243bbcd81ba43059d3c39bc5d0b9da7.png"></p> 
<p><img src="https://images2.imgbox.com/d1/60/CqVjoZmm_o.png" alt="732db52ce1dd4011b79a275f141938a0.png"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d960ec7509814bf4e491c00c274af679/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">搭建和配置Stable Diffusion环境，超详细的本地部署教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/de0abe7099fecfb77aabcd64f32ea2dd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构】顺序表专题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>