<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring Web MVC入门（2）——请求 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/39f88dd1c60ab575bfcdaadb4bbb9b69/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Spring Web MVC入门（2）——请求">
  <meta property="og:description" content="目录
一、传递单个参数
基础类型和包装类型的区别
1、基础类型
（1）不传参
（2）传字符串
2、包装类型
（1）不传参
（2）传字符串
3、小结
二、传递多个参数
三、传递对象
四、后端参数重命名（后端参数映射）
五、传递数组
六、传递集合
不加注解@RequestParam
加注解@RequestParam
七、传递JSON数据
1、JSON概念
JSON于JavaScript的关系：
2、JSON语法
（1）JSON的语法：
（2）JSON的两种结构：
3、JSON字符串和Java对象互转
4、JSON优点
5、传递JSON对象
八、获取URL中参数@PathVariable
九、上传文件@RequestPart
十、获取Cookie / Session
1、回顾Cookie
2、理解Session
3、Cookie 和 Session 的区别（面试常考）
4、获取Cookie
（1）传统获取Cookie
（2）简洁获取Cookie
5、获取Session
（1）Session 存储
（2）传统获取Session
（3）简洁获取 Session(1)
（4）简洁获取 Session(2)
下面讨论一下Spring从传统获取Session到简洁获取Session：
十一、获取Header
1、传统获取Header
2、简洁获取Header
访问不同的路径，就是发送不同的请求。在发送请求时，可能会带一些参数，所以学习Spring的请求，主要是学习如何传递参数到后端，以及后端如何接收。
传递参数，这里主要使用Postman来模拟，浏览器也可以，但是Postman会更方便。
后端开发人员无需过度关注如何传递参数，了解即可，实际开发中以Postman测试为主。比如餐厅里的厨师，不需要关注用户是在店里下单还是外卖平台下单，只需要知道如何接收订单，根据订单做出对应的菜肴即可。
一、传递单个参数 接收单个参数，在Spring MVC中直接使用方法中的参数就可以了，比如以下代码：
import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(&#34;/Demo1&#34;) public class Demo1 { @RequestMapping(&#34;/test&#34;) public String test(String name) { return &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-27T15:33:10+08:00">
    <meta property="article:modified_time" content="2024-04-27T15:33:10+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring Web MVC入门（2）——请求</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E4%BC%A0%E9%80%92%E5%8D%95%E4%B8%AA%E5%8F%82%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E4%BC%A0%E9%80%92%E5%8D%95%E4%B8%AA%E5%8F%82%E6%95%B0" rel="nofollow">一、传递单个参数</a></p> 
<p id="%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">基础类型和包装类型的区别</a></p> 
<p id="1%E3%80%81%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B" rel="nofollow">1、基础类型</a></p> 
<p id="%EF%BC%881%EF%BC%89%E4%B8%8D%E4%BC%A0%E5%8F%82-toc" style="margin-left:120px;"><a href="#%EF%BC%881%EF%BC%89%E4%B8%8D%E4%BC%A0%E5%8F%82" rel="nofollow">（1）不传参</a></p> 
<p id="%EF%BC%882%EF%BC%89%E4%BC%A0%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:120px;"><a href="#%EF%BC%882%EF%BC%89%E4%BC%A0%E5%AD%97%E7%AC%A6%E4%B8%B2" rel="nofollow">（2）传字符串</a></p> 
<p id="2%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B" rel="nofollow">2、包装类型</a></p> 
<p id="%EF%BC%881%EF%BC%89%E4%B8%8D%E4%BC%A0%E5%8F%82-toc" style="margin-left:120px;"><a href="#%EF%BC%881%EF%BC%89%E4%B8%8D%E4%BC%A0%E5%8F%82" rel="nofollow">（1）不传参</a></p> 
<p id="%EF%BC%882%EF%BC%89%E4%BC%A0%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:120px;"><a href="#%EF%BC%882%EF%BC%89%E4%BC%A0%E5%AD%97%E7%AC%A6%E4%B8%B2" rel="nofollow">（2）传字符串</a></p> 
<p id="3%E3%80%81%E5%B0%8F%E7%BB%93-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E5%B0%8F%E7%BB%93" rel="nofollow">3、小结</a></p> 
<p id="%E4%BA%8C%E3%80%81%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0" rel="nofollow">二、传递多个参数</a></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%89%E3%80%81%E4%BC%A0%E9%80%92%E5%AF%B9%E8%B1%A1-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E4%BC%A0%E9%80%92%E5%AF%B9%E8%B1%A1" rel="nofollow">三、传递对象</a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%90%8E%E7%AB%AF%E5%8F%82%E6%95%B0%E9%87%8D%E5%91%BD%E5%90%8D%EF%BC%88%E5%90%8E%E7%AB%AF%E5%8F%82%E6%95%B0%E6%98%A0%E5%B0%84%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E5%90%8E%E7%AB%AF%E5%8F%82%E6%95%B0%E9%87%8D%E5%91%BD%E5%90%8D%EF%BC%88%E5%90%8E%E7%AB%AF%E5%8F%82%E6%95%B0%E6%98%A0%E5%B0%84%EF%BC%89" rel="nofollow">四、后端参数重命名（后端参数映射）</a></p> 
<p id="%E4%BA%94%E3%80%81%E4%BC%A0%E9%80%92%E6%95%B0%E7%BB%84-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E4%BC%A0%E9%80%92%E6%95%B0%E7%BB%84" rel="nofollow">五、传递数组</a></p> 
<p id="%E5%85%AD%E3%80%81%E4%BC%A0%E9%80%92%E9%9B%86%E5%90%88-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E4%BC%A0%E9%80%92%E9%9B%86%E5%90%88" rel="nofollow">六、传递集合</a></p> 
<p id="%E4%B8%8D%E5%8A%A0%E6%B3%A8%E8%A7%A3%40RequestParam-toc" style="margin-left:40px;"><a href="#%E4%B8%8D%E5%8A%A0%E6%B3%A8%E8%A7%A3%40RequestParam" rel="nofollow">不加注解@RequestParam</a></p> 
<p id="%E5%8A%A0%E6%B3%A8%E8%A7%A3%40RequestParam-toc" style="margin-left:40px;"><a href="#%E5%8A%A0%E6%B3%A8%E8%A7%A3%40RequestParam" rel="nofollow">加注解@RequestParam</a></p> 
<p id="%E4%B8%83%E3%80%81%E4%BC%A0%E9%80%92JSON%E6%95%B0%E6%8D%AE-toc" style="margin-left:0px;"><a href="#%E4%B8%83%E3%80%81%E4%BC%A0%E9%80%92JSON%E6%95%B0%E6%8D%AE" rel="nofollow">七、传递JSON数据</a></p> 
<p id="1%E3%80%81JSON%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#1%E3%80%81JSON%E6%A6%82%E5%BF%B5" rel="nofollow">1、JSON概念</a></p> 
<p id="JSON%E4%BA%8EJavaScript%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9A-toc" style="margin-left:80px;"><a href="#JSON%E4%BA%8EJavaScript%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9A" rel="nofollow">JSON于JavaScript的关系：</a></p> 
<p id="2%E3%80%81JSON%E8%AF%AD%E6%B3%95-toc" style="margin-left:40px;"><a href="#2%E3%80%81JSON%E8%AF%AD%E6%B3%95" rel="nofollow">2、JSON语法</a></p> 
<p id="%EF%BC%881%EF%BC%89JSON%E7%9A%84%E8%AF%AD%E6%B3%95%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89JSON%E7%9A%84%E8%AF%AD%E6%B3%95%EF%BC%9A" rel="nofollow">（1）JSON的语法：</a></p> 
<p id="%EF%BC%882%EF%BC%89JSON%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%BB%93%E6%9E%84%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89JSON%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%BB%93%E6%9E%84%EF%BC%9A" rel="nofollow">（2）JSON的两种结构：</a></p> 
<p id="3%E3%80%81JSON%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8CJava%E5%AF%B9%E8%B1%A1%E4%BA%92%E8%BD%AC-toc" style="margin-left:40px;"><a href="#3%E3%80%81JSON%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8CJava%E5%AF%B9%E8%B1%A1%E4%BA%92%E8%BD%AC" rel="nofollow">3、JSON字符串和Java对象互转</a></p> 
<p id="4%E3%80%81JSON%E4%BC%98%E7%82%B9-toc" style="margin-left:40px;"><a href="#4%E3%80%81JSON%E4%BC%98%E7%82%B9" rel="nofollow">4、JSON优点</a></p> 
<p id="5%E3%80%81%E4%BC%A0%E9%80%92JSON%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E4%BC%A0%E9%80%92JSON%E5%AF%B9%E8%B1%A1" rel="nofollow">5、传递JSON对象</a></p> 
<p id="%E5%85%AB%E3%80%81%E8%8E%B7%E5%8F%96URL%E4%B8%AD%E5%8F%82%E6%95%B0%40PathVariable-toc" style="margin-left:0px;"><a href="#%E5%85%AB%E3%80%81%E8%8E%B7%E5%8F%96URL%E4%B8%AD%E5%8F%82%E6%95%B0%40PathVariable" rel="nofollow">八、获取URL中参数@PathVariable</a></p> 
<p id="%E4%B9%9D%E3%80%81%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%40RequestPart-toc" style="margin-left:0px;"><a href="#%E4%B9%9D%E3%80%81%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%40RequestPart" rel="nofollow">九、上传文件@RequestPart</a></p> 
<p id="%E5%8D%81%E3%80%81%E8%8E%B7%E5%8F%96Cookie%20%2F%20Session-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E3%80%81%E8%8E%B7%E5%8F%96Cookie%20%2F%20Session" rel="nofollow">十、获取Cookie / Session</a></p> 
<p id="1%E3%80%81%E5%9B%9E%E9%A1%BECookie-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%9B%9E%E9%A1%BECookie" rel="nofollow">1、回顾Cookie</a></p> 
<p id="2%E3%80%81%E7%90%86%E8%A7%A3Session-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E7%90%86%E8%A7%A3Session" rel="nofollow">2、理解Session</a></p> 
<p id="3%E3%80%81Cookie%20%E5%92%8C%20Session%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%EF%BC%89-toc" style="margin-left:40px;"><a href="#3%E3%80%81Cookie%20%E5%92%8C%20Session%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%EF%BC%89" rel="nofollow">3、Cookie 和 Session 的区别（面试常考）</a></p> 
<p id="4%E3%80%81%E8%8E%B7%E5%8F%96Cookie-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E8%8E%B7%E5%8F%96Cookie" rel="nofollow">4、获取Cookie</a></p> 
<p id="%EF%BC%881%EF%BC%89%E4%BC%A0%E7%BB%9F%E8%8E%B7%E5%8F%96Cookie-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E4%BC%A0%E7%BB%9F%E8%8E%B7%E5%8F%96Cookie" rel="nofollow">（1）传统获取Cookie</a></p> 
<p id="%EF%BC%882%EF%BC%89%E7%AE%80%E6%B4%81%E8%8E%B7%E5%8F%96Cookie-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E7%AE%80%E6%B4%81%E8%8E%B7%E5%8F%96Cookie" rel="nofollow">（2）简洁获取Cookie</a></p> 
<p id="5%E3%80%81%E8%8E%B7%E5%8F%96Session-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E8%8E%B7%E5%8F%96Session" rel="nofollow">5、获取Session</a></p> 
<p id="%EF%BC%881%EF%BC%89Session%20%E5%AD%98%E5%82%A8-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89Session%20%E5%AD%98%E5%82%A8" rel="nofollow">（1）Session 存储</a></p> 
<p id="%EF%BC%882%EF%BC%89%E4%BC%A0%E7%BB%9F%E8%8E%B7%E5%8F%96Session-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E4%BC%A0%E7%BB%9F%E8%8E%B7%E5%8F%96Session" rel="nofollow">（2）传统获取Session</a></p> 
<p id="%EF%BC%883%EF%BC%89%E7%AE%80%E6%B4%81%E8%8E%B7%E5%8F%96%20Session(1)-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89%E7%AE%80%E6%B4%81%E8%8E%B7%E5%8F%96%20Session%281%29" rel="nofollow">（3）简洁获取 Session(1)</a></p> 
<p id="%EF%BC%884%EF%BC%89%E7%AE%80%E6%B4%81%E8%8E%B7%E5%8F%96%20Session(2)-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89%E7%AE%80%E6%B4%81%E8%8E%B7%E5%8F%96%20Session%282%29" rel="nofollow">（4）简洁获取 Session(2)</a></p> 
<p id="%E4%B8%8B%E9%9D%A2%E8%AE%A8%E8%AE%BA%E4%B8%80%E4%B8%8BSpring%E4%BB%8E%E4%BC%A0%E7%BB%9F%E8%8E%B7%E5%8F%96Session%E5%88%B0%E7%AE%80%E6%B4%81%E8%8E%B7%E5%8F%96Session%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E4%B8%8B%E9%9D%A2%E8%AE%A8%E8%AE%BA%E4%B8%80%E4%B8%8BSpring%E4%BB%8E%E4%BC%A0%E7%BB%9F%E8%8E%B7%E5%8F%96Session%E5%88%B0%E7%AE%80%E6%B4%81%E8%8E%B7%E5%8F%96Session%EF%BC%9A" rel="nofollow">下面讨论一下Spring从传统获取Session到简洁获取Session：</a></p> 
<p id="%E5%8D%81%E4%B8%80%E3%80%81%E8%8E%B7%E5%8F%96Header-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E4%B8%80%E3%80%81%E8%8E%B7%E5%8F%96Header" rel="nofollow">十一、获取Header</a></p> 
<p id="1%E3%80%81%E4%BC%A0%E7%BB%9F%E8%8E%B7%E5%8F%96Header-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E4%BC%A0%E7%BB%9F%E8%8E%B7%E5%8F%96Header" rel="nofollow">1、传统获取Header</a></p> 
<p id="2%E3%80%81%E7%AE%80%E6%B4%81%E8%8E%B7%E5%8F%96Header-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E7%AE%80%E6%B4%81%E8%8E%B7%E5%8F%96Header" rel="nofollow">2、简洁获取Header</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p>        <span style="background-color:#a2e043;">访问不同的路径，就是发送不同的请求</span>。<span style="background-color:#38d8f0;">在发送请求时，可能会带一些参数，所以学习Spring的请求，主要是学习如何传递参数到后端，以及后端如何接收</span>。</p> 
<p>        传递参数，这里主要使用Postman来模拟，浏览器也可以，但是Postman会更方便。</p> 
<blockquote> 
 <p>后端开发人员无需过度关注如何传递参数，了解即可，实际开发中以Postman测试为主。比如餐厅里的厨师，不需要关注用户是在店里下单还是外卖平台下单，只需要知道如何接收订单，根据订单做出对应的菜肴即可。</p> 
</blockquote> 
<h2 id="%E4%B8%80%E3%80%81%E4%BC%A0%E9%80%92%E5%8D%95%E4%B8%AA%E5%8F%82%E6%95%B0" style="background-color:transparent;">一、传递单个参数</h2> 
<p>        接收单个参数，在Spring MVC中直接使用方法中的参数就可以了，比如以下代码：</p> 
<pre><code class="language-java">import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/Demo1")
public class Demo1 {
    @RequestMapping("/test")
    public String test(String name) {
        return "接收到的参数name：" + name;
    }
}</code></pre> 
<p>        Postman观察返回的请求：</p> 
<p><img alt="" height="598" src="https://images2.imgbox.com/e9/37/FpQ8Sdp6_o.png" width="1069"></p> 
<p>        查询字符串名称必须和方法里的参数名称一样，如图：</p> 
<p><img alt="" height="610" src="https://images2.imgbox.com/4e/31/pt5B0ndf_o.png" width="1200"></p> 
<p>        现在把name改成name1，结果如下：</p> 
<p><img alt="" height="389" src="https://images2.imgbox.com/23/6a/wWJEz0Ql_o.png" width="538"></p> 
<p>        因为URL已经指定要访问test方法了，但是方法没有name1这个参数，就只能返回一个null了。</p> 
<h3 id="%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB">基础类型和包装类型的区别</h3> 
<h4 id="1%E3%80%81%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B">1、基础类型</h4> 
<p>        基础类型现在正常传参，代码如下：</p> 
<pre><code class="language-java">import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/Demo1")
public class Demo1 {
    @RequestMapping("/test")
    public String test(int age) {
        return "接收到的参数age：" + age;
    }
}</code></pre> 
<p>        Postman：</p> 
<p>        <img alt="" height="346" src="https://images2.imgbox.com/93/97/5p3nxEs0_o.png" width="417"></p> 
<p>        是没有任何问题的。下面看看如果不传参，会怎么样</p> 
<h5 id="%EF%BC%881%EF%BC%89%E4%B8%8D%E4%BC%A0%E5%8F%82">（1）不传参</h5> 
<p>        Postman：<img alt="" height="644" src="https://images2.imgbox.com/e0/6d/DAccxNB8_o.png" width="1057"></p> 
<p>        错误码是500，说明是服务器这边出问题了，观察程序日志：</p> 
<p><img alt="" height="155" src="https://images2.imgbox.com/e2/35/X2VABQGC_o.png" width="1200"></p> 
<p>        <span style="background-color:#a2e043;">上面说int类型的参数age，虽然为可选的，但由于被声明为基本类型，而不能转换为空值，考虑将其声明为对应基本类型的包装类型。按照错误信息解决错误即可</span>。<strong>初学者也应该养成看错误日志的习惯</strong>。</p> 
<h5 id="%EF%BC%882%EF%BC%89%E4%BC%A0%E5%AD%97%E7%AC%A6%E4%B8%B2">（2）传字符串</h5> 
<p>        传字符串，Postman：</p> 
<p><img alt="" height="466" src="https://images2.imgbox.com/9d/11/bfppU6SH_o.png" width="517"></p> 
<p>        错误码是400，说明是客户端这边出问题了，error提示：Bad Request，说明请求有问题，再看服务器这边，也出现了警告日志：</p> 
<p><img alt="" height="76" src="https://images2.imgbox.com/e3/4c/n6MaNaWX_o.png" width="1200"></p> 
<p>        如果实在看不懂，可以去有道云进行翻译，如图：</p> 
<p><img alt="" height="143" src="https://images2.imgbox.com/e9/1e/I7W7V6NB_o.png" width="1200"></p> 
<p>        说明<span style="background-color:#a2e043;">基本类型int不能转换为字符串</span>。</p> 
<h4 id="2%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B">2、包装类型</h4> 
<p>        代码如下：</p> 
<pre><code class="language-java">import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/Demo1")
public class Demo1 {
    @RequestMapping("/test")
    public String test(Integer age) {
        return "接收到的参数age：" + age;
    }
}</code></pre> 
<p>        正常传参，观察结果：</p> 
<p><img alt="" height="347" src="https://images2.imgbox.com/16/c1/0hUBXJE7_o.png" width="400"></p> 
<p>        没有问题。</p> 
<h5>（1）不传参</h5> 
<p>        当不传参时，Postman结果如下：</p> 
<p><img alt="" height="399" src="https://images2.imgbox.com/50/18/FFWXjgKg_o.png" width="463"></p> 
<p>        和基本类型不同，并没有报错，而是显示出null。</p> 
<p>        <span style="background-color:#a2e043;">对于包装类型，如果不传对应参数，Spring接收到的数据则为null</span>，所以企业开发中，<strong><span style="color:#956fe7;">对于参数可能为空的数据，建议使用包装类型</span></strong>。</p> 
<h5>（2）传字符串</h5> 
<p>        传字符串，Postman结果：</p> 
<p><img alt="" height="379" src="https://images2.imgbox.com/9f/56/1xnG7kwQ_o.png" width="379"></p> 
<p>        报错和基本类型一样，日志如下：</p> 
<p><img alt="" height="68" src="https://images2.imgbox.com/45/26/o5NmoLxv_o.png" width="1200"></p> 
<h4 id="3%E3%80%81%E5%B0%8F%E7%BB%93">3、小结</h4> 
<p>        <span style="background-color:#a2e043;">对于方法里参数可能为null的数据，建议使用包装类型</span>；<span style="background-color:#ffd900;">而对于传递对象时（后面会讲到），对象（类）里面可以不使用包装类型</span>，<strong>如果无法进行区分，那就都使用包装类型好了</strong>。</p> 
<hr> 
<h2 id="%E4%BA%8C%E3%80%81%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0">二、传递多个参数</h2> 
<p>        和接收单个参数一样，无非就是多加几个参数而已，代码如下：</p> 
<pre><code class="language-java">    @RequestMapping("/test2")
    public String test2(String name, Integer age) {
        return "接收到的参数name：" + name + "  接收到的参数age：" + age;
    }
}</code></pre> 
<p>        Postman观察结果如下：</p> 
<p><img alt="" height="397" src="https://images2.imgbox.com/19/16/h9Lmtq9S_o.png" width="504"></p> 
<p>        这里传参的时候，<span style="color:#956fe7;"><strong>填入query string 的参数位置顺序可以任意的，结果不受这个顺序影响</strong></span>。</p> 
<p>        但是如果要传很多个，3个，4个，5个.....，这样进行传参代码就会显得很丑，所以，就可以引入对象，下面的内容介绍传对象。</p> 
<h2></h2> 
<hr> 
<h2 id="%E4%B8%89%E3%80%81%E4%BC%A0%E9%80%92%E5%AF%B9%E8%B1%A1">三、传递对象</h2> 
<p>        现在有Student类，代码如下：</p> 
<pre><code class="language-java">public class Student {
    private String name;
    private int age;
    private int id;

    public String getName() {return name;}
    public int getAge() {return age;}
    public int getId() {return id;}
    public void setName(String name) {this.name = name;}
    public void setAge(int age) {this.age = age;}
    public void setId(int id) {this.id = id;}

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", id=" + id +
                '}';
    }
}</code></pre> 
<p>        传递对象的代码：</p> 
<pre><code class="language-java">    @RequestMapping("test3")
    public Object test3(Student student) {
        return student.toString();
    }</code></pre> 
<p>        Postman发送请求，结果如下：<br><img alt="" height="350" src="https://images2.imgbox.com/d1/71/JE74G39G_o.png" width="492"></p> 
<p>        如果<strong>不传参数呢？</strong>这里不会吧报错？试一下就知道了，如图：</p> 
<p>        <img alt="" height="385" src="https://images2.imgbox.com/b0/88/BS9Y4LLR_o.png" width="400"></p> 
<p>        可以看到，并<strong>不会报错</strong>，<span style="color:#fe2c24;"><strong>原因就是在对象（类）中，成员属性会自动初始化</strong></span>，<span style="background-color:#a2e043;">使用基础类型，也会进行初始化，如果没有传递这个参数，不会报错</span>；<span style="background-color:#a2e043;">但如果直接在接口方法中声明，使用int类型，没传参就会报错，就像上面介绍基础类型报错的例</span>子。</p> 
<hr> 
<h2 id="%E5%9B%9B%E3%80%81%E5%90%8E%E7%AB%AF%E5%8F%82%E6%95%B0%E9%87%8D%E5%91%BD%E5%90%8D%EF%BC%88%E5%90%8E%E7%AB%AF%E5%8F%82%E6%95%B0%E6%98%A0%E5%B0%84%EF%BC%89">四、后端参数重命名（后端参数映射）</h2> 
<p>        某些特殊的情况下，前端传递的参数key和我们后端接收的key可以不一致，比如前端传递了一个time给后端，但后端是使用createtime字段来接收的，这样就会出现参数接收不到的情况，如果我们想前端传过来的参数，后端接收的参数是重命名后的，就可以使用@RequestParam来重命名后端等待参数值。</p> 
<p>        代码如下：</p> 
<pre><code class="language-java">@RequestMapping("d1")
@RestController
public class Demo1 {
    @RequestMapping("r1")
    public String method_1(@RequestParam(value = "time") String newTime) {
        return "接收到的参数newTime：" + newTime;
    }
}</code></pre> 
<p>        postman页面如下：</p> 
<p>        <img alt="" height="374" src="https://images2.imgbox.com/78/6a/Llme8VLy_o.png" width="446"></p> 
<p>        可以看到，Spring可以正确的把浏览器传递的参数time绑定到后端参数newTime上。</p> 
<p>        我们试试传参的参数改成newTime，看看有没有问题，postman页面如下：</p> 
<p>        <img alt="" height="355" src="https://images2.imgbox.com/76/a7/qakhP1VH_o.png" width="392"></p> 
<p>        错误码400，说明客户端这边的请求有问题，看看报错日志：<br><img alt="" height="63" src="https://images2.imgbox.com/9a/68/FRlSOddp_o.png" width="1200"></p> 
<p>        请求参数“time”不存在，说明访问这个方法，必须要有参数，而我们传的newtTime参数，在这里没有，所以就报错了，我们也可以设置参数不是必须的，代码如下：</p> 
<pre><code class="language-java">@RequestMapping("d1")
@RestController
public class Demo1 {
    @RequestMapping("r1")
    public String method_1(@RequestParam(value = "time",required = false) String newTime) {
        return "接收到的参数newTime：" + newTime;
    }
}</code></pre> 
<p>        这样如果我们没有传参，也不会报错了，如图：</p> 
<p>        <img alt="" height="361" src="https://images2.imgbox.com/24/65/rbUosQzt_o.png" width="410"></p> 
<p>        或者传其他参数名，也不会报错</p> 
<p>        <img alt="" height="333" src="https://images2.imgbox.com/88/f5/dBy8RJb6_o.png" width="404"></p> 
<p> 在这里可以得出结论：</p> 
<blockquote> 
 <p>1、注解：@RequestParam 进行参数重命名时，请求参数只有和@RequestParam声明的名称一致，才能进行参数绑定和赋值。</p> 
 <p>2、注解：@RequestParam 默认访问此方法是必须要带参数的，也可以设置不再参数。</p> 
</blockquote> 
<hr> 
<h2 id="%E4%BA%94%E3%80%81%E4%BC%A0%E9%80%92%E6%95%B0%E7%BB%84">五、传递数组</h2> 
<p>        传递数组时，Spring MVC可以自动绑定数组参数的赋值，代码如下：</p> 
<pre><code class="language-java">    @RequestMapping("r2")
    public String method2(String[] str) {
        return Arrays.toString(str);
    }</code></pre> 
<p>        postman页面如下：</p> 
<p>        <img alt="" height="391" src="https://images2.imgbox.com/d8/51/x4DmWa16_o.png" width="441">、</p> 
<p>        浏览器可以使用以下URL：</p> 
<blockquote> 
 <p>http://127.0.0.1:8080/d1/r2?str=zhangsan&amp;str=lisi&amp;str=wangwu<br> http://127.0.0.1:8080/d1/r2?str=zhangsan%2clisi%2cwangwu<br> http://127.0.0.1:8080/d1/r2?str=zhangsan,lisi,wangwu</p> 
</blockquote> 
<hr> 
<h2 id="%E5%85%AD%E3%80%81%E4%BC%A0%E9%80%92%E9%9B%86%E5%90%88">六、传递集合</h2> 
<p>        集合参数，和数组类似，同一个请求参数名有多个，且需要使用@RequestParam注解绑定参数关系。</p> 
<p>        默认情况下，请求中参数名相同的多个值，是封装到数组。如果要封装到集合，要使用@RequestParam绑定参数关系。</p> 
<h3 id="%E4%B8%8D%E5%8A%A0%E6%B3%A8%E8%A7%A3%40RequestParam">不加注解@RequestParam</h3> 
<p>        不加注解@RequestParam的代码：</p> 
<pre><code class="language-java">    @RequestMapping("r3")
    public String method3(List&lt;String&gt; list) {
        return "size:" + list.size() + ",list:" + list;
    }</code></pre> 
<p>        postman页面：</p> 
<p>        <img alt="" height="422" src="https://images2.imgbox.com/cc/81/7hixwXhQ_o.png" width="372"></p> 
<p>        可以看到，服务器这边报错了，看看日志：</p> 
<p><img alt="" height="89" src="https://images2.imgbox.com/d6/f7/khbWJ8vb_o.png" width="1200"></p> 
<p><img alt="" height="68" src="https://images2.imgbox.com/f6/73/JNcUyMzS_o.png" width="1200"></p> 
<p>        说明传参的时候，出问题了，因为没有加注解@RequestParam，所以默认传的参数是数组，但接收的确实集合List，所以服务器这边代码就会报错。</p> 
<h3 id="%E5%8A%A0%E6%B3%A8%E8%A7%A3%40RequestParam">加注解@RequestParam</h3> 
<p>        加注解@RequestParam的代码：</p> 
<pre><code class="language-java">    @RequestMapping("r3")
    public String method3(@RequestParam List&lt;String&gt; list) {
        return "size:" + list.size() + ",list:" + list;
    }</code></pre> 
<p>        postman页面：</p> 
<p>        <img alt="" height="361" src="https://images2.imgbox.com/61/45/352j8XOE_o.png" width="403"></p> 
<p>        可以看到，这时候就没出错了，因为加了注解@RequestParam后，客户端这边传的参数就不是数组了，而是List。</p> 
<hr> 
<h2 id="%E4%B8%83%E3%80%81%E4%BC%A0%E9%80%92JSON%E6%95%B0%E6%8D%AE">七、传递JSON数据</h2> 
<h3 id="1%E3%80%81JSON%E6%A6%82%E5%BF%B5" style="background-color:transparent;">1、JSON概念</h3> 
<p>        JSON：JavaScript Object Notation【JavaScript 对象表示法】。</p> 
<p>        JSON是一种轻量级的数据交互格式。它基于ECMAScript（欧洲计算机协会制定的js规范）的一个子集，采用完全独立于编程语言的文本格式，来存储和表示数据。——百度百科</p> 
<p>        简单来说：JSON就是一种数据格式，有自己的格式和语法，使用文本表示一个对象或数组的信息，因此JSON本质是字符串。主要负责在不同的语言中进行数据传递和交换。</p> 
<p>        类似于：国际通用语言：英语。或者是中国56个民族不同地区的通用语言：普通话。有自己的语法，但其他语言也认识。</p> 
<h4 id="JSON%E4%BA%8EJavaScript%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9A">JSON于JavaScript的关系：</h4> 
<p>        没有关系，只是语法相似，js开发者能更快的上手而已，但是他的语法本身比较简单，所以也很好学。</p> 
<h3 id="2%E3%80%81JSON%E8%AF%AD%E6%B3%95">2、JSON语法</h3> 
<p>        JSON是一个字符串，它的格式非常类似JavaScript对象字棉量的格式，如下是一段JSON数据：</p> 
<blockquote> 
 <p>{<!-- --><br>     "squadName": "Super hero squad",<br>     "homeTown": "Metro City",<br>     "formed": 2016,<br>     "secretBase": "Super tower",<br>     "active": true,<br>     "members": [<br>         {<!-- --><br>             "name": "Molecule Man",<br>             "age": 29,<br>             "secretIdentity": "Dan Jukes",<br>             "powers": [<br>                 "Radiation resistance",<br>                 "Turning tiny",<br>                 "Radiationblast"<br>             ]<br>         },<br>         {<!-- --><br>             "name": "Madame Uppercut",<br>             "age": 39,<br>             "secretIdentity": "Jane Wilson",<br>             "powers": [<br>                 "Million tonne punch",<br>                 "Damage resistance",<br>                 "Superhumanreflexes"<br>             ]<br>         },<br>         {<!-- --><br>             "name": "Eternal Flame",<br>             "age": 1000000,<br>             "secretIdentity": "Unknown",<br>             "powers": [<br>                 "Immortality",<br>                 "Heat Immunity",<br>                 "Inferno",<br>                 "Teleportation",<br>                 "Interdimensional travel"<br>             ]<br>         }<br>     ]<br> }</p> 
</blockquote> 
<p>        也可以进行压缩：</p> 
<blockquote> 
 <p>{"squadName":"Super hero squad","homeTown":"Metro City","formed":2016,"secretBase":"Super tower","active":true,"members":[{"name":"Molecule Man","age":29,"secretIdentity":"Dan Jukes","powers":["Radiation resistance","Turning tiny","Radiationblast"]},{"name":"Madame Uppercut","age":39,"secretIdentity":"Jane Wilson","powers":["Million tonne punch","Damage resistance","Superhumanreflexes"]},{"name":"Eternal Flame","age":1000000,"secretIdentity":"Unknown","powers":["Immortality","Heat Immunity","Inferno","Teleportation","Interdimensional travel"]}]}</p> 
</blockquote> 
<p>        压缩后和没压缩之前的数据是一样的，只不过没压缩的进行了格式化，更易读。</p> 
<h4 id="%EF%BC%881%EF%BC%89JSON%E7%9A%84%E8%AF%AD%E6%B3%95%EF%BC%9A">（1）JSON的语法：</h4> 
<blockquote> 
 <p>1、数据在 键值对（Key / Value）中。</p> 
 <p>2、数据由逗号 "<strong> , </strong>" 分割。</p> 
 <p>3、对象用 " { } " 表示。</p> 
 <p>4、数组用 " [ ] " 表示。</p> 
 <p>5、值可以为对象，也可以为数组，数组中可以包含多个对象。</p> 
</blockquote> 
<h4 id="%EF%BC%882%EF%BC%89JSON%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%BB%93%E6%9E%84%EF%BC%9A">（2）JSON的两种结构：</h4> 
<blockquote> 
 <p>1、对象：大括号 " { } " 保存的对象是一个无序的 键值对 集合。一个对象以左括号 " { " 开始，右括号 " } " 结束。每个 "键" 后跟一个冒号 " : "，键值对使用逗号 " , " 分隔。</p> 
 <p>2、数组：中括号 " [ ] " 保存的数组是值（Value）的有序集合。一个数组以左中括号 " [ " 开始，右中括号 " ] "，值之间使用逗号 " , " 分隔。</p> 
</blockquote> 
<p><img alt="" height="636" src="https://images2.imgbox.com/a1/76/zczEBlwK_o.png" width="999"></p> 
<p>所以，以下都是合法的JSON数据：</p> 
<blockquote> 
 <p>{"name":"admin","age":18}<br> ["hello", 3.1415, "json"]<br> [{"name":"admin","age":18},{"name":"root","age":16},{"name":"张三","age":20}]</p> 
</blockquote> 
<p>        可以使用在线JSON格式化工具来进行校验和书写：<a href="http://www.bejson.com/" rel="nofollow" title="在线JSON校验格式化工具（Be JSON）">在线JSON校验格式化工具（Be JSON）</a></p> 
<h3 id="3%E3%80%81JSON%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8CJava%E5%AF%B9%E8%B1%A1%E4%BA%92%E8%BD%AC">3、JSON字符串和Java对象互转</h3> 
<p>        JSON本质上是一个字符串，通过文本来存储和描述数据。</p> 
<p>        Spring MVC框架也集成了JSON的转换工具，我们可以直接使用，来完成JSON字符串和Java对象的互转。</p> 
<p>        本质上是 Jackson-databind 提供的功能，Spring MVC框架中已经把该工具包引入了进来，咱们直接使用即可，如果脱离SPring MVC使用，需要引入相关依赖：</p> 
<pre><code class="language-XML">&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.13.5&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p>        Person类如下：</p> 
<pre><code class="language-java">public class Person {
    private int id;
    private String name;
    private String password;
    public Person(){ };
    public Person(int id, String name, String password) {
        this.id = id;
        this.name = name;
        this.password = password;
    };
    @Override
    public String toString() {
        return "Person{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", password='" + password + '\'' +
                '}';
    }
    public int getId() {return id;}
    public String getName() {return name;}
    public String getPassword() {return password;}
    public void setId(int id) {this.id = id;}
    public void setName(String name) {this.name = name;}
    public void setPassword(String password) {this.password = password;}
}</code></pre> 
<p>        互转的代码如下：</p> 
<pre><code class="language-java">public class JSONUtils {
    private static ObjectMapper objectMapper = new ObjectMapper();

    public static void main(String[] args) throws JsonProcessingException {
        Person person = new Person(10, "zhangsan", "123456");
        //对象转为JSON字符串
        String jsonStr = objectMapper.writeValueAsString(person);
        System.out.println("JSON字符串为：" + jsonStr);
        //JSON字符串转为对象
        Person p = objectMapper.readValue(jsonStr, Person.class);
        System.out.println("转换的对象为：" + person.toString());
    }
}
</code></pre> 
<p>        运行结果如下：<br><img alt="" height="178" src="https://images2.imgbox.com/94/cd/GbRvM0FO_o.png" width="645"></p> 
<h3 id="4%E3%80%81JSON%E4%BC%98%E7%82%B9">4、JSON优点</h3> 
<blockquote> 
 <p><strong>1、简单易用</strong>：语法简单，易于理解和编写，可以快速地进行数据转换。</p> 
 <p><strong>2、跨平台支持</strong>：JSON可以被多种编程语言解析和生成，可以在不同的平台和语言之间进行数据交换和传输。</p> 
 <p><strong>3、轻量级</strong>：相较于XML格式，JSON数据格式更加轻量级，传输数据时占用的带宽较小，可以提高传输速度。</p> 
 <p><strong>4、易于扩展</strong>：JSON的数据结构灵活，支持嵌套对象和数组等复杂的数据结构，便于扩展和使用。</p> 
 <p><strong>5、安全性</strong>：JSON数据格式是一种纯文本格式，不包含可执行代码，不会执行恶意代码，因此具有较高的安全性。</p> 
</blockquote> 
<p>        基于以上特点，JSON在Web应用程序中被广泛使用，如前后端数据交互、API接口数据传输等。</p> 
<h3 id="5%E3%80%81%E4%BC%A0%E9%80%92JSON%E5%AF%B9%E8%B1%A1" style="background-color:transparent;">5、传递JSON对象</h3> 
<p>        接收JSON对象，需要使用@RequestBody注解。</p> 
<blockquote> 
 <p>RequestBody：请求正文，意思是这个注解作用在请求正文的数据绑定，请求参数必须写在请求正文中。</p> 
</blockquote> 
<p>        后端代码如下：</p> 
<pre><code class="language-java">@RestController
@RequestMapping("/d1")
public class Demo {
    @RequestMapping("/m1")
    public Object method1(@RequestBody Person person) {
        return person.toString();
    }
}</code></pre> 
<p>        使用postman发送json请求参数：</p> 
<p><img alt="" height="526" src="https://images2.imgbox.com/12/f1/KghN5l0y_o.png" width="1027"></p> 
<p>        可以看到，后端正确接收到了，下面通过fiddler观察一下请求参数：</p> 
<p>        <img alt="" height="455" src="https://images2.imgbox.com/f5/04/vOiQYSY5_o.png" width="491"></p> 
<p>        可以看到，请求类型是json。那如果后端代码去掉注解@RequestBody呢？代码如下：</p> 
<pre><code class="language-java">@RestController
@RequestMapping("/d1")
public class Demo {
    @RequestMapping("/m1")
    public Object method1( Person person) {
        return person.toString();
    }
}</code></pre> 
<p>        继续使用Postman传递json，看看响应结果：</p> 
<p><img alt="" height="378" src="https://images2.imgbox.com/54/1a/LL3DFWGg_o.png" width="569"></p> 
<p>        可以看到，并没有给person赋值成功。</p> 
<hr> 
<h2 id="%E5%85%AB%E3%80%81%E8%8E%B7%E5%8F%96URL%E4%B8%AD%E5%8F%82%E6%95%B0%40PathVariable">八、获取URL中参数@PathVariable</h2> 
<p>        <strong>path variable</strong>：<strong><span style="color:#956fe7;">路径变量</span></strong></p> 
<p>        和字面表达的意思一样，<strong>这个注解主要作用在请求URL路径上的数据绑定</strong><span style="background-color:#a2e043;">（默认传递参数写在URL上，Spring MVC就可以获取到）</span>。</p> 
<p>        后端代码：</p> 
<pre><code class="language-java">    @RequestMapping("/m2/{id}/{name}")
    public String method2(@PathVariable Integer id, @PathVariable("name") String userName) {
        return "解析参数id:" + id + ",name:" + userName;
    }</code></pre> 
<p>        使用浏览器，访问：http://127.0.0.1:8080/d1/m2/5/zhangsan  ，页面如下：</p> 
<p>        <img alt="" height="90" src="https://images2.imgbox.com/ec/17/D0HHpT4p_o.png" width="519"></p> 
<p>        使用Postman页面如下：</p> 
<p>        <img alt="" height="321" src="https://images2.imgbox.com/ef/49/H1W6i852_o.png" width="512"></p> 
<p>        可以看到，后端接收到了URL的参数，下图是参数对应关系：</p> 
<p><img alt="" height="299" src="https://images2.imgbox.com/0f/fe/YUnmdzHa_o.png" width="988"></p> 
<blockquote> 
 <p>如果方法参数名称和需要绑定的URL的变量名称一致时，可以简写，不用给@PathVariable的属性赋值，例如上述例子中的id变量。</p> 
 <p>如果方法参数名称和需要绑定的URL的变量名称不一致时，需要给@PathVariable的属性赋值，如上述例子中的userName变量。</p> 
</blockquote> 
<hr> 
<h2 id="%E4%B9%9D%E3%80%81%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%40RequestPart">九、上传文件@RequestPart</h2> 
<p>        使用注解RequestPart</p> 
<p>        后端代码实现：</p> 
<pre><code class="language-java">    @RequestMapping("m3")
    public String getFile(@RequestPart("file") MultipartFile file) throws IOException {
        //获取文件名称
        String fileName = file.getOriginalFilename();
        //文件上传到指定路径
        file.transferTo(new File("D:/desktop/file/javaEE/temp" + file.getOriginalFilename()));
        return "接收到的文件名称为: " + fileName;
    }</code></pre> 
<p>        Postman页面如下：</p> 
<p><img alt="" height="287" src="https://images2.imgbox.com/34/cf/sadcecGl_o.png" width="499"></p> 
<p>        查看电脑 D:/desktop/file/javaEE/temp/ 路径下是否有cat.jpg文件：</p> 
<p><img alt="" height="276" src="https://images2.imgbox.com/0b/56/OGm5vsg8_o.png" width="437"></p> 
<hr> 
<h2 id="%E5%8D%81%E3%80%81%E8%8E%B7%E5%8F%96Cookie%20%2F%20Session" style="background-color:transparent;">十、获取Cookie / Session</h2> 
<p>        <strong>HTTP协议自身是属于 “无状态” 协议</strong>。<span style="background-color:#a2e043;">“无状态” ：默认情况下，HTTP协议的客户端和服务器的这次通信，和下次通信之间没有直接的联系（也可以理解成 “无记忆”）</span></p> 
<p>        在计算机领域，<span style="background-color:#a2e043;">我们认为 “无状态” 是好的，相反，“有状态” 就不好</span>。</p> 
<p>        但是实际开发中，很多时候是需要知道请求之间有关联的关系，例如我登录第三方网站，第一次登录成功后，后续的访问就不用继续输入账户密码，可以直接登录成功，所以这时候服务器就需要知道我之前是登录过了的。</p> 
<h3 id="1%E3%80%81%E5%9B%9E%E9%A1%BECookie">1、回顾Cookie</h3> 
<p>        下面简单介绍一下Cookie，详细介绍可以看我之前写的博客：<a href="https://blog.csdn.net/cool_tao6/article/details/137209490?spm=1001.2014.3001.5501" title="网络原理 - HTTP / HTTPS(2)">网络原理 - HTTP / HTTPS(2)</a></p> 
<p>       <span style="color:#fe2c24;"><strong> Cookie本质是浏览器这边，本地化永久存储数据的机制，是一个身份标识，相当于令牌</strong></span>。</p> 
<p>        客户端和服务器之间的登录请求交互，大概流程图如下：</p> 
<p>        <img alt="" height="430" src="https://images2.imgbox.com/1d/97/EY1xoo7s_o.png" width="611"></p> 
<p>        <strong>Cookie就像就诊卡</strong>：<span style="background-color:#38d8f0;">去医院看病，第一次去陌生的医院看病，进行挂号，一般都是要买个就诊卡的，医生给你看病时，第一句也不是问你病情，而是像你要就诊卡，这个就诊卡就记录着你之前的病史、开过的药、生病的日期，都会记录着，如果是第一次去这个医院，当然也就没有之前的病史了，但你这次的就诊也会记录在这上面</span>。大概流程图如下：</p> 
<p>        <img alt="" height="343" src="https://images2.imgbox.com/78/2d/tda36gq4_o.png" width="587"></p> 
<p>        Cookie就简单介绍到这。</p> 
<p>        客户端这边有了Cookie这个 “令牌”，那<span style="color:#fe2c24;"><strong>服务器这边也就需要记录 这个 “令牌” 的信息</strong></span>；因为一个网站，会有很多客户，大型网站无时无刻都有很多请求访问过来，那么就会带有非常多的Cookie，这也就意味着，<span style="color:#fe2c24;"><strong>服务器这边也要对 这些 “令牌” 进行管理</strong></span>，这些工作也就是下面要介绍的 <span style="color:#956fe7;"><strong>Session 来负责</strong></span>了。</p> 
<h3 id="2%E3%80%81%E7%90%86%E8%A7%A3Session" style="background-color:transparent;">2、理解Session</h3> 
<p>        了解Session之前，我们先谈谈会话（会话：对话的意思），现实中的会话如下图：</p> 
<p>        <img alt="" height="348" src="https://images2.imgbox.com/0e/4d/XKyOJplK_o.png" width="551"></p> 
<p>        <span style="background-color:#a2e043;">在计算机领域中，<strong>会话是一个客户端与服务器的不中断的请求响应</strong>。对于服务器来说，客户端发来的请求，服务器能识别出请求来自同一个客户端</span>。<span style="background-color:#38d8f0;">当一个未知的客户端向Web应用程序发送第一个请求，此时就开始了一个会话。当客户明确结束会话或者服务器在一个时限（时间阈值，Session默认的超时时间是30min，但这也是可以进行设置）没有接收到客户端发来的任何请求，此时会话就结束了</span>。</p> 
<blockquote> 
 <p>有点像打电话咨询客服，每次打一个电话，就会有客服和我们进行沟通，此时会话就建立了，当我们挂断电话，此时会话就会结束，或者较长时间没有回客服，没有新的请求，此时会话也会结束。</p> 
</blockquote> 
<p>        <span style="background-color:#a2e043;">服务器同一时刻会收到很多请求，<strong>服务器也需要清楚的区分每个请求是从属于哪个用户</strong>，也就是会有不同的会话</span>，<span style="background-color:#38d8f0;">要进行区分这些会话，就需要在服务器这边记录每个会话以及与用户信息的对应关系，<strong>服务器为了保存用户信息创建了一个特殊的对象：Session</strong></span>。大概流程图如下：</p> 
<p><img alt="" height="276" src="https://images2.imgbox.com/c8/f1/y9qAPpxr_o.png" width="582"></p> 
<p>        <strong><span style="background-color:#a2e043;">Session的本质就是一个 “哈希表”，存储了一些键值对结构</span></strong><span style="background-color:#a2e043;">。Key就是SessionID，Value就是用户信息（用户信息可以根据需求灵活设计</span>）。结构大概如下图：</p> 
<p><img alt="" height="411" src="https://images2.imgbox.com/30/76/yWgJTYDX_o.png" width="915"></p> 
<blockquote> 
 <p>        SessionId 是由服务器生成的一个 “唯一性字符串”，从Session机制的角度来看，这个唯一性字符串称为 “SessionId”。但是站在整个登录流程中看待，也可以把这个唯一性字符串称为：“token”。</p> 
 <p>        上述例子中的令牌ID，就可以看做是SessionId，只不过令牌除了 ID 之外，还会带一些其他信息，比如时间、签名等。</p> 
</blockquote> 
<p>    举个账户余额的例子，如图：</p> 
<p><img alt="" height="563" src="https://images2.imgbox.com/a6/bb/UCo7EK6w_o.png" width="1083"></p> 
<p>        Cookie和Session搭配一起使用，大概流程如下：</p> 
<p><img alt="" height="449" src="https://images2.imgbox.com/c0/3b/nYfNQtGG_o.png" width="1021"></p> 
<blockquote> 
 <p><strong>1、</strong><span style="background-color:#ffd900;">当用户登录的时候，服务器在Session会新增一个新记录，并把SessionID，返回给客户端（通过HTTP响应中是Set-Cookie字段返回）</span>。</p> 
 <p><strong>2、</strong><span style="background-color:#ffd900;">客户端后续再给服务器发送请求的时候，需要在请求中带上SessionId（通过HTTP请求中的Cookie字段带上）</span>。</p> 
 <p><strong>3、</strong><span style="background-color:#ffd900;">服务器接收到请求后，根据请求中的SessionId，找到对应的Session中，获取到对应的用户信息，再进行后续的操作。如果找不到，就重新创建Session，再把SessionId返回给客户端</span>。</p> 
</blockquote> 
<p><strong>注意</strong>：<span style="background-color:#a2e043;">Session默认是保存在内存中的，如果重启服务器，Session数据就像消失</span>。</p> 
<h3 id="3%E3%80%81Cookie%20%E5%92%8C%20Session%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%EF%BC%89" style="background-color:transparent;">3、Cookie 和 Session 的区别（面试常考）</h3> 
<blockquote> 
 <p><strong>（1）</strong><span style="background-color:#38d8f0;">Cookie是客户端保存用户信息的一种机制，Session是服务器保存用户信息的一种机制</span>。</p> 
 <p><strong>（2）</strong><span style="background-color:#38d8f0;">Cookie和Session之间是通过SessionId关联起来的（并没有什么直接关系），SessionId是Cookie和Session之间的桥梁</span>。</p> 
 <p><strong>（3）</strong><span style="background-color:#38d8f0;">Cookie和Session经常会搭配在一起使用，但不是必须搭配的</span>。</p> 
 <p>     <strong>   a、</strong><span style="background-color:#a2e043;">完全可以用Cookie保存一些数据在客户端；这些数据并不一定是用户身份信息（SessionId）</span>。</p> 
 <p>    <strong>    b、</strong><span style="background-color:#a2e043;">Session的SessionId也不是非得通过Cookie / Set-Cookie传递，也有其他方式，比如通过URL传递</span>。</p> 
</blockquote> 
<h3 id="4%E3%80%81%E8%8E%B7%E5%8F%96Cookie">4、获取Cookie</h3> 
<h4 id="%EF%BC%881%EF%BC%89%E4%BC%A0%E7%BB%9F%E8%8E%B7%E5%8F%96Cookie" style="background-color:transparent;">（1）传统获取Cookie</h4> 
<p>        代码如下：</p> 
<pre><code class="language-java">@RestController
@RequestMapping("/d1")
public class Demo1 {
    @RequestMapping("/getC1")
    public String getCookie(HttpServletRequest request, HttpServletResponse response) {
        //获取参数
        //String name = request.getParameter("name");
        //获取所有参数
        Cookie[] cookies = request.getCookies();

        //1、不使用lambda表达式
        StringBuilder stringBuilder = new StringBuilder();
        if(cookies != null) {
            for(Cookie ck : cookies) {
                stringBuilder.append(ck.getName() + ":" + ck.getValue());
            }
        }
        //return "获取Cookie信息:" + stringBuilder;
        
        //2、使用lambda表达式
        if(cookies != null) {
            Arrays.stream(cookies).forEach(ck -&gt; System.out.println(ck.getName() + ":" + ck.getValue()));
        }
        return "获取Cookie";
    }
}</code></pre> 
<p>        使用浏览器访问：http:127.0.0.1:8080/d1/getC1，页面如下：</p> 
<p>        <img alt="" height="82" src="https://images2.imgbox.com/9a/88/E2EkoxhS_o.png" width="386"></p> 
<p>        因为没有设置Cookie，现在Cookie是null，控制台也不会打印Cookie，如图：</p> 
<p><img alt="" height="339" src="https://images2.imgbox.com/56/62/PwgrYQgF_o.png" width="1200"></p> 
<p>        现在在浏览器手动设置一些Cookie，如图：</p> 
<p>        <img alt="" height="26" src="https://images2.imgbox.com/8d/a4/SLeLhxAt_o.png" width="215"> 这个称为：host domain</p> 
<p><img alt="" height="223" src="https://images2.imgbox.com/ab/15/pePbrfFr_o.png" width="1200"></p> 
<p>        也可以使用Postman设置Cookie，如图：<br><img alt="" height="320" src="https://images2.imgbox.com/3e/d5/vciWFdCN_o.png" width="561"></p> 
<p>        刷新一下页面，再看看控制台，打印了hahaha:666，说明后端接收到了浏览器发来的Cookie，如图：</p> 
<p><img alt="" height="116" src="https://images2.imgbox.com/20/a7/yE9mudxR_o.png" width="1060"></p> 
<p>        从这个例子也能看出来，<span style="color:#fe2c24;"><strong>Cookie是可以伪造的</strong></span>，也就是不安全的，所以使用Cookie时，后端也需要进行Cookie的校验。</p> 
<blockquote> 
 <p><strong>1、</strong><span style="background-color:#38d8f0;">Spring MVC是基于Servlet API构建的原始Web框架，也是在Servlet的基础上实现的，HttpServletRequest、HttpServletResponse 是Servlet提供的两个类，是Spring MVC方法的内置对象。需要时直接在方法中添加声明即可（例如注解@CookieValue，下面会介绍）</span>。</p> 
 <p><strong>2、</strong><span style="background-color:#38d8f0;">HttpServletRequest 对象代表客户端的请求。当客户端通过HTTP协议访问服务器时，HTTP请求头的所有信息都封装在这个对象中，通过这个对象提供的方法，可以获取到客户端请求的所有信息</span>。</p> 
 <p><strong>3、</strong><span style="background-color:#38d8f0;">HttpServletResponse 对象代表服务器的响应。HTTP响应的信息都在这个对象中，比如向客户端发送的数据、响应头、状态码等等。通过这个对象提供的方法，可以获得服务器响应的所有内容</span>。</p> 
</blockquote> 
<p>        Spring MVC在这两个对象的基础上进行了封装，给我们提供了更简单的使用方法（使用注解）。下面介绍简洁获取Cookie的使用方法。</p> 
<h4 id="%EF%BC%882%EF%BC%89%E7%AE%80%E6%B4%81%E8%8E%B7%E5%8F%96Cookie">（2）简洁获取Cookie</h4> 
<p>        后端代码如下：</p> 
<pre><code class="language-java">    @RequestMapping("/getC2")
    public String getCookie2(@CookieValue("name") String newName) {
        return "从Cookie中获取值，name:" + newName;
    }</code></pre> 
<p>        Cookie如下：</p> 
<p><img alt="" height="180" src="https://images2.imgbox.com/d9/6f/LnA8dd8M_o.png" width="646"></p> 
<p>        浏览器访问：http:127.0.0.1:8080/d1/getC2 ，页面如下：</p> 
<p>        <img alt="" height="95" src="https://images2.imgbox.com/c4/9c/q6K1SPst_o.png" width="444"></p> 
<h3 id="5%E3%80%81%E8%8E%B7%E5%8F%96Session">5、获取Session</h3> 
<h4 id="%EF%BC%881%EF%BC%89Session%20%E5%AD%98%E5%82%A8" style="background-color:transparent;">（1）Session 存储</h4> 
<p>        因为Session是服务器这边存储的信息，所以要获取到到Session前要先有它。</p> 
<p>        Session也是基于HttpServletRequest来存储和获取的，下面是存储Session的后端代码：</p> 
<pre><code class="language-java">    @RequestMapping("/setSess")
    public String setSess(HttpServletRequest request) {
        //从Cookie中获取到SessionId，根据SessionId获取Session对象，如果没有，就会创建一个
        HttpSession session = request.getSession();
        session.setAttribute("name", "zhangsan");
        return "设置Session成功";
    }</code></pre> 
<p>        <span style="background-color:#ffd900;">这个代码中虽然看不到SessionId这样的概念，但是getSession操作内部会提取到请求中的Cookie的SessionId，然后根据SessionId获取到对应的Session对象，Session对象用HttpSession来描述</span>。如图：</p> 
<p><img alt="" height="168" src="https://images2.imgbox.com/cd/25/ea6EdaxG_o.png" width="738"></p> 
<p>        运行代码后浏览器页面如下：</p> 
<p><img alt="" height="93" src="https://images2.imgbox.com/c7/1d/kxx0Mvvp_o.png" width="430"></p> 
<p><img alt="" height="174" src="https://images2.imgbox.com/55/a2/gZBG2BbH_o.png" width="1176"></p> 
<p>        可以看到Cookie多了一个，就是我们刚才设置的，再看看Postman页面：</p> 
<p><img alt="" height="152" src="https://images2.imgbox.com/b5/b9/zUfJ9hKD_o.png" width="528"></p> 
<p>        也是多了一个，和浏览器一样的Cookie。</p> 
<p>        通过fiddler抓包观察，如图：</p> 
<p><img alt="" height="367" src="https://images2.imgbox.com/9e/6c/kvw3qLtj_o.png" width="530"></p> 
<h4 id="%EF%BC%882%EF%BC%89%E4%BC%A0%E7%BB%9F%E8%8E%B7%E5%8F%96Session" style="background-color:transparent;">（2）传统获取Session</h4> 
<p>        获取Session有两种方式，getSession的不同参数有两种情况，如下两种：</p> 
<pre><code class="language-java">HttpSession getSession(boolean create);
HttpSession getSession();</code></pre> 
<blockquote> 
 <p>HttpSession getSession(boolean create)，参数如果为true，则当不存在会话是，会新建会话；参数如果不为false，则当不存在会话时，返回null，不新建会话。</p> 
</blockquote> 
<p>        后端代码如下：</p> 
<pre><code class="language-java">    @RequestMapping("getSess1")
    public String getsSess(HttpServletRequest request) {
        //从cookie中获取到了sessionID, 根据sessionID获取Session对象取Session对象,如果session不存在，不会自动创建
        HttpSession session = request.getSession(false);
        String userName = (String) session.getAttribute("name");
        return "name: " + userName;
    }</code></pre> 
<p>        Object getAttribute(String name)：返回该session会话中具有指定名称的对象，如果没有指定名称的对象，则返回 null。</p> 
<p>        前面我们已经存储了Session：session.setAttribute("name", "zhangsan");   </p> 
<p>        现在获取一下session，浏览器访问：http:127.0.0.1:8080/d1/getSess1 ，页面如下：</p> 
<p>        <img alt="" height="114" src="https://images2.imgbox.com/f2/93/sOQGUTIX_o.png" width="497"></p> 
<p>        Postman页面如下：</p> 
<p>        <img alt="" height="319" src="https://images2.imgbox.com/ee/8a/kVQP7IY4_o.png" width="496"></p> 
<p>        通过fiddler抓包进行观察，如图：</p> 
<p>        <img alt="" height="399" src="https://images2.imgbox.com/fb/f7/c9SStLdh_o.png" width="548"></p> 
<p>        可以看到，客户端发送HTTP请求时，SessionId通过Cookie传递给了服务器。</p> 
<p>        这里如果我们修改一下Cookie的值，就会拿不到了，如图：</p> 
<p>        原来的：</p> 
<p><img alt="" height="107" src="https://images2.imgbox.com/52/60/b64Z7HUv_o.png" width="1057"></p> 
<p>        修改后的：</p> 
<p><img alt="" height="116" src="https://images2.imgbox.com/53/41/aBcod1qb_o.png" width="882"></p> 
<p>        因为修改了Cookie，也就是伪造的，Cookie里的SessionId也就会改变，但服务器这边没有这个对应的SessionId，就拿不到Session了。</p> 
<p>        <img alt="" height="103" src="https://images2.imgbox.com/0d/fb/P7zrkJtE_o.png" width="417"></p> 
<h4 id="%EF%BC%883%EF%BC%89%E7%AE%80%E6%B4%81%E8%8E%B7%E5%8F%96%20Session(1)" style="background-color:transparent;">（3）简洁获取 Session(1)</h4> 
<p>        后端代码如下：</p> 
<pre><code class="language-java">    @RequestMapping("getSess2")
    public String getSess2(HttpSession session) {
        String name = (String)session.getAttribute("name");
        return "从Session中获取name: " + name;
    }</code></pre> 
<p>        这里封装了 HttpSession session = Request.getSession(); 如果Session不存在，会自动创建。</p> 
<p>        Session是放在内存中的，因为重启了程序，就要重新存储Session，浏览器要再访问一下http:127.0.0.1:8080/d1/setSess ，如下：</p> 
<p><img alt="" height="101" src="https://images2.imgbox.com/6e/81/lvcN0EE1_o.png" width="474"></p> 
<p>        浏览器访问：http:127.0.0.1:8080/d1/getSess2，页面如下：</p> 
<p>        <img alt="" height="96" src="https://images2.imgbox.com/98/0a/F66TvWgk_o.png" width="482"></p> 
<h4 id="%EF%BC%884%EF%BC%89%E7%AE%80%E6%B4%81%E8%8E%B7%E5%8F%96%20Session(2)" style="background-color:transparent;">（4）简洁获取 Session(2)</h4> 
<p>        后端代码如下：</p> 
<pre><code class="language-java">    @RequestMapping("getSess3")
    public String getSess3(@SessionAttribute("name") String name) {
        return "从Session中获取name: " + name;
    }</code></pre> 
<p>        浏览器访问http:127.0.0.1:8080/d1/getSess3 ，页面如下：</p> 
<p>        <img alt="" height="86" src="https://images2.imgbox.com/fa/e3/Mba7WTpC_o.png" width="436"></p> 
<h4 id="%E4%B8%8B%E9%9D%A2%E8%AE%A8%E8%AE%BA%E4%B8%80%E4%B8%8BSpring%E4%BB%8E%E4%BC%A0%E7%BB%9F%E8%8E%B7%E5%8F%96Session%E5%88%B0%E7%AE%80%E6%B4%81%E8%8E%B7%E5%8F%96Session%EF%BC%9A">下面讨论一下Spring从传统获取Session到简洁获取Session：</h4> 
<p>        如图：</p> 
<p><img alt="" height="690" src="https://images2.imgbox.com/d8/24/9yDeAnOO_o.png" width="1016"></p> 
<p>        <span style="background-color:#a2e043;">可以看到，因为getSess1方法第一行代码是有可能会写的，为了简洁方便，就给他进行了一次封装，把HttpSession对象放进参数里，但开发者觉得还不够，又进一步进行封装，省去了会重复写的代码，就是使用了注解的getSess3方法了</span>。</p> 
<h2 id="%E5%8D%81%E4%B8%80%E3%80%81%E8%8E%B7%E5%8F%96Header" style="background-color:transparent;">十一、获取Header</h2> 
<h3 id="1%E3%80%81%E4%BC%A0%E7%BB%9F%E8%8E%B7%E5%8F%96Header">1、传统获取Header</h3> 
<p>        后端代码如下：</p> 
<pre><code class="language-java">    @RequestMapping("getHeader1")
    public String getHeader1(HttpServletRequest request) {
        String userAgent = request.getHeader("User-Agent");
        return "从Header获取信息，userAgent:" + userAgent;
    }</code></pre> 
<p>        浏览器页面如下：</p> 
<p><img alt="" height="111" src="https://images2.imgbox.com/d0/95/Rv2wL7Yx_o.png" width="1200"></p> 
<p>        我们使用fiddler抓包看看：</p> 
<p><img alt="" height="515" src="https://images2.imgbox.com/b7/d4/kWI7nh5N_o.png" width="1028"></p> 
<p>        可以看到，和请求的Header报头一样。</p> 
<h3 id="2%E3%80%81%E7%AE%80%E6%B4%81%E8%8E%B7%E5%8F%96Header" style="background-color:transparent;">2、简洁获取Header</h3> 
<p>        后端代码如下：</p> 
<pre><code class="language-java">    @RequestMapping("getHeader2")
    public String getHeader2(@RequestHeader("User-Agent") String userAgent) {
        return "从Header获取信息，userAgent:" + userAgent;
    }</code></pre> 
<p>        浏览器页面如下：<br><img alt="" height="106" src="https://images2.imgbox.com/27/ef/hQkb0yV1_o.png" width="1200"></p> 
<p>        可以看到，响应和上面的一样，简洁的写法就是Spring对传统的写法进行了封装，使代码更简单、易学。</p> 
<hr> 
<h2>都看到这了，点个赞再走吧，谢谢谢谢谢</h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/079052967201e7f71138f78012416960/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Hugging Face全攻略：轻松下载Llama 3模型，探索NLP的无限可能！【实操】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0791d8924a0df6d847fb3ef1afc76557/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring Boot3整合Redis</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>