<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构：栈 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/cb9d6fdedec2e10228f7c56cdb0e5e37/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="数据结构：栈">
  <meta property="og:description" content="目录
一 栈的基本概念
1.栈的定义：
二 栈的顺序存储结构
1.栈的存储结构：
2.栈的所有接口：
3.栈的初始化：
4.栈顶指针初值为-1或者0的区别：
5.栈的销毁：
6.入栈：
7.出栈：
8.获取栈顶元素：
9.获取有效数据个数:
10：判断栈是否为空:
11.打印栈:
三 栈的链式存储结构
1.栈的存储结构：
3.栈的所有接口：
4.栈的初始化：
5.栈的销毁：
6.入栈：
7.出栈：
8.获取栈顶元素：
9.获取有效数据个数：
10.判断栈是否为空：
四 顺序存储和链式存储实现栈的优缺点比较
1.顺序存储（基于数组的栈）：
2.链式存储（基于链表的栈）：
五 总结
一 栈的基本概念 1.栈的定义： 栈(Stack)是只允许在一端进行插入或删除操作的线性表。首先栈是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作。
栈顶(Top) 线性表允许进行插入删除的那一端
栈底(Bottom) 固定的，不允许进行插入和删除的另一端。
空栈 不含任何元素。
二 栈的顺序存储结构 1.栈的存储结构： typedef int STDataType; typedef struct Stack { STDataType* a; int top; int capacity; }ST; 2.栈的所有接口： //栈的初始化、销毁 void STInit(ST* ps); void STDestroy(ST* ps); //栈的入栈、出栈 void STPush(ST* ps, STDataType x); void STPop(ST* ps); //获取栈顶元素、有效数据个数 STDataType STTop(ST* ps); int STSize(ST* ps); //判断栈是否为空 bool STEmpty(ST* ps); 3.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-04T22:30:32+08:00">
    <meta property="article:modified_time" content="2024-05-04T22:30:32+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构：栈</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%20%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%E4%B8%80%20%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">一 栈的基本概念</a></p> 
<p id="1.%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A-toc" style="margin-left:80px;"><a href="#1.%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A" rel="nofollow">1.栈的定义：</a></p> 
<p id="%E4%BA%8C%20%E6%A0%88%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%20%E6%A0%88%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">二 栈的顺序存储结构</a></p> 
<p id="1.%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%9A-toc" style="margin-left:80px;"><a href="#1.%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%9A" rel="nofollow">1.栈的存储结构：</a></p> 
<p id="2.%E6%A0%88%E7%9A%84%E6%89%80%E6%9C%89%E6%8E%A5%E5%8F%A3%EF%BC%9A-toc" style="margin-left:80px;"><a href="#2.%E6%A0%88%E7%9A%84%E6%89%80%E6%9C%89%E6%8E%A5%E5%8F%A3%EF%BC%9A" rel="nofollow">2.栈的所有接口：</a></p> 
<p id="3.%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A-toc" style="margin-left:80px;"><a href="#3.%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A" rel="nofollow">3.栈的初始化：</a></p> 
<p id="4.%E6%A0%88%E9%A1%B6%E6%8C%87%E9%92%88%E5%88%9D%E5%80%BC%E4%B8%BA-1%E6%88%96%E8%80%850%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A-toc" style="margin-left:80px;"><a href="#4.%E6%A0%88%E9%A1%B6%E6%8C%87%E9%92%88%E5%88%9D%E5%80%BC%E4%B8%BA-1%E6%88%96%E8%80%850%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A" rel="nofollow">4.栈顶指针初值为-1或者0的区别：</a></p> 
<p id="5.%E6%A0%88%E7%9A%84%E9%94%80%E6%AF%81%EF%BC%9A-toc" style="margin-left:80px;"><a href="#5.%E6%A0%88%E7%9A%84%E9%94%80%E6%AF%81%EF%BC%9A" rel="nofollow">5.栈的销毁：</a></p> 
<p id="6.%E5%85%A5%E6%A0%88%EF%BC%9A-toc" style="margin-left:80px;"><a href="#6.%E5%85%A5%E6%A0%88%EF%BC%9A" rel="nofollow">6.入栈：</a></p> 
<p id="7.%E5%87%BA%E6%A0%88%EF%BC%9A-toc" style="margin-left:80px;"><a href="#7.%E5%87%BA%E6%A0%88%EF%BC%9A" rel="nofollow">7.出栈：</a></p> 
<p id="8.%E8%8E%B7%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0%EF%BC%9A-toc" style="margin-left:80px;"><a href="#8.%E8%8E%B7%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0%EF%BC%9A" rel="nofollow">8.获取栈顶元素：</a></p> 
<p id="9.%E8%8E%B7%E5%8F%96%E6%9C%89%E6%95%88%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0%3A-toc" style="margin-left:80px;"><a href="#9.%E8%8E%B7%E5%8F%96%E6%9C%89%E6%95%88%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0%3A" rel="nofollow">9.获取有效数据个数:</a></p> 
<p id="10%EF%BC%9A%E5%88%A4%E6%96%AD%E6%A0%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%3A-toc" style="margin-left:80px;"><a href="#10%EF%BC%9A%E5%88%A4%E6%96%AD%E6%A0%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%3A" rel="nofollow">10：判断栈是否为空:</a></p> 
<p id="11.%E6%89%93%E5%8D%B0%E6%A0%88%3A-toc" style="margin-left:80px;"><a href="#11.%E6%89%93%E5%8D%B0%E6%A0%88%3A" rel="nofollow">11.打印栈:</a></p> 
<p id="%E4%B8%89%20%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#%E4%B8%89%20%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84" rel="nofollow">三 栈的链式存储结构</a></p> 
<p id="1.%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%9A-toc" style="margin-left:80px;"><a href="#1.%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%9A" rel="nofollow">1.栈的存储结构：</a></p> 
<p id="3.%E6%A0%88%E7%9A%84%E6%89%80%E6%9C%89%E6%8E%A5%E5%8F%A3%EF%BC%9A-toc" style="margin-left:80px;"><a href="#3.%E6%A0%88%E7%9A%84%E6%89%80%E6%9C%89%E6%8E%A5%E5%8F%A3%EF%BC%9A" rel="nofollow">3.栈的所有接口：</a></p> 
<p id="4.%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A-toc" style="margin-left:80px;"><a href="#4.%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A" rel="nofollow">4.栈的初始化：</a></p> 
<p id="5.%E6%A0%88%E7%9A%84%E9%94%80%E6%AF%81%EF%BC%9A-toc" style="margin-left:80px;"><a href="#5.%E6%A0%88%E7%9A%84%E9%94%80%E6%AF%81%EF%BC%9A" rel="nofollow">5.栈的销毁：</a></p> 
<p id="6.%E5%85%A5%E6%A0%88%EF%BC%9A-toc" style="margin-left:80px;"><a href="#6.%E5%85%A5%E6%A0%88%EF%BC%9A" rel="nofollow">6.入栈：</a></p> 
<p id="7.%E5%87%BA%E6%A0%88%EF%BC%9A-toc" style="margin-left:80px;"><a href="#7.%E5%87%BA%E6%A0%88%EF%BC%9A" rel="nofollow">7.出栈：</a></p> 
<p id="8.%E8%8E%B7%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0%EF%BC%9A-toc" style="margin-left:80px;"><a href="#8.%E8%8E%B7%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0%EF%BC%9A" rel="nofollow">8.获取栈顶元素：</a></p> 
<p id="9.%E8%8E%B7%E5%8F%96%E6%9C%89%E6%95%88%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0%EF%BC%9A-toc" style="margin-left:80px;"><a href="#9.%E8%8E%B7%E5%8F%96%E6%9C%89%E6%95%88%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0%EF%BC%9A" rel="nofollow">9.获取有效数据个数：</a></p> 
<p id="10.%E5%88%A4%E6%96%AD%E6%A0%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%EF%BC%9A-toc" style="margin-left:80px;"><a href="#10.%E5%88%A4%E6%96%AD%E6%A0%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%EF%BC%9A" rel="nofollow">10.判断栈是否为空：</a></p> 
<p id="%E5%9B%9B%20%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%92%8C%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0%E6%A0%88%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%AF%94%E8%BE%83-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%20%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%92%8C%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0%E6%A0%88%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%AF%94%E8%BE%83" rel="nofollow">四 顺序存储和链式存储实现栈的优缺点比较</a></p> 
<p id="1.%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%EF%BC%88%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E7%9A%84%E6%A0%88%EF%BC%89%EF%BC%9A-toc" style="margin-left:80px;"><a href="#1.%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%EF%BC%88%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E7%9A%84%E6%A0%88%EF%BC%89%EF%BC%9A" rel="nofollow">1.顺序存储（基于数组的栈）：</a></p> 
<p id="2.%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%EF%BC%88%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A0%88%EF%BC%89%EF%BC%9A-toc" style="margin-left:80px;"><a href="#2.%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%EF%BC%88%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A0%88%EF%BC%89%EF%BC%9A" rel="nofollow">2.链式存储（基于链表的栈）：</a></p> 
<p id="%E6%80%BB%E7%BB%93%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93%EF%BC%9A" rel="nofollow">五 总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E4%B8%80%20%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">一 栈的基本概念</h3> 
<h4 id="1.%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A">1.栈的定义：</h4> 
<p>栈(Stack)是<span style="color:#fe2c24;">只允许在一端进行插入或删除</span>操作的线性表。首先栈是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作。<br><strong>栈顶(Top) </strong>线性表允许进行插入删除的那一端<br><strong>栈底(Bottom) </strong>固定的，不允许进行插入和删除的另一端。<br><strong>空栈 </strong>不含任何元素。</p> 
<h2 id="%E4%BA%8C%20%E6%A0%88%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">二 栈的顺序存储结构</h2> 
<p class="img-center"><img alt="" height="260" src="https://images2.imgbox.com/40/67/gv0iSLfC_o.png" width="231"></p> 
<h4 id="1.%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%9A">1.栈的存储结构：</h4> 
<pre><code>typedef int STDataType;
typedef struct Stack
{
	STDataType* a;
	int top;
	int capacity;
}ST;</code></pre> 
<h4 id="2.%E6%A0%88%E7%9A%84%E6%89%80%E6%9C%89%E6%8E%A5%E5%8F%A3%EF%BC%9A">2.栈的所有接口：</h4> 
<pre><code>//栈的初始化、销毁
void STInit(ST* ps);
void STDestroy(ST* ps);

//栈的入栈、出栈
void STPush(ST* ps, STDataType x);
void STPop(ST* ps);

//获取栈顶元素、有效数据个数
STDataType STTop(ST* ps);
int STSize(ST* ps);

//判断栈是否为空
bool STEmpty(ST* ps);</code></pre> 
<h4 id="3.%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A">3.栈的初始化：</h4> 
<pre><code>void STInit(ST* ps)
{
	ps-&gt;a = NULL;
	ps-&gt;capacity = 0;
    ps-&gt;top = -1;//ps-&gt;top = 0;
}</code></pre> 
<p> 输出：</p> 
<p><img alt="" height="100" src="https://images2.imgbox.com/9a/db/PqzAcCd0_o.png" width="1017"></p> 
<h4 id="4.%E6%A0%88%E9%A1%B6%E6%8C%87%E9%92%88%E5%88%9D%E5%80%BC%E4%B8%BA-1%E6%88%96%E8%80%850%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A">4.栈顶指针初值为-1或者0的区别：</h4> 
<p>当栈顶指针初始值为-1时：</p> 
<p class="img-center"><img alt="" height="377" src="https://images2.imgbox.com/28/1b/t8LTcb7g_o.png" width="497"></p> 
<p>进栈时：</p> 
<p>因为此时栈为空且栈顶指针指向-1所以我们先让栈顶指针先自增然后把值赋给栈顶元素。</p> 
<pre><code>ps-&gt;a[++ps-&gt;top] = x;
</code></pre> 
<p>出栈时：</p> 
<p>先取栈顶元素然后再自减。</p> 
<pre><code>x = ps-&gt;arr[ps-&gt;top--];
</code></pre> 
<p>当栈顶指针初始值为0时：</p> 
<p class="img-center"><img alt="" height="377" src="https://images2.imgbox.com/4c/c4/ZXDQlhi0_o.png" width="608"></p> 
<p>进栈时：</p> 
<p>因为此时栈为空且栈顶指针指向0所以我们先值赋给栈顶元素然后再让栈顶指针先自增。</p> 
<pre><code>ps-&gt;a[ps-&gt;top++] = x;</code></pre> 
<p>出栈时：</p> 
<p>先自减然后再取栈顶元素。</p> 
<pre><code>x = ps-&gt;arr[--ps-&gt;top];</code></pre> 
<p>其实谁便用哪个都行看自己喜好，它们无非就是先自增和后自增，自减也和自增一样。</p> 
<h4 id="5.%E6%A0%88%E7%9A%84%E9%94%80%E6%AF%81%EF%BC%9A">5.栈的销毁：</h4> 
<pre><code>void STDestroy(ST* ps)
{
	assert(ps);//判断ps指针是否为空
	free(ps-&gt;a);
	ps-&gt;a = NULL;
	ps-&gt;capacity = 0;
	ps-&gt;top = -1;
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="80" src="https://images2.imgbox.com/e3/ef/3YeN9wBm_o.png" width="1200"></p> 
<h4 id="6.%E5%85%A5%E6%A0%88%EF%BC%9A">6.入栈：</h4> 
<pre><code class="language-cs">void STPush(ST* ps, STDataType x)
{
	assert(ps);
	     //栈扩容
		if (ps-&gt;capacity == ps-&gt;top + 1)//因为ps-&gt;capacity为0而ps-&gt;top为-1，为了能让栈扩容 
                                        //那就必须要相等
		{
			STDataType NewCapacity = ps-&gt;capacity == 0 ? 4 : ps-&gt;capacity * 2;
			ST* tmp = (ST*)realloc(ps-&gt;a, NewCapacity * sizeof(STDataType));
			if (tmp == NULL)
			{
				perror("malloc error");
				exit(-1);
			}
			ps-&gt;a = tmp;
			ps-&gt;capacity = NewCapacity;
		}
		ps-&gt;a[++ps-&gt;top] = x;//ps-&gt;top == 0 : ps-&gt;a[ps-&gt;top++] = x;
}</code></pre> 
<p> 输出：</p> 
<p><img alt="" height="226" src="https://images2.imgbox.com/ad/95/VIu9XoRP_o.png" width="1155"></p> 
<h4 id="7.%E5%87%BA%E6%A0%88%EF%BC%9A">7.出栈：</h4> 
<pre><code class="language-cs">void STPop(ST* ps)
{
	assert(ps);
	if (ps-&gt;top == -1)//判断栈是否为空
	{
		exit(-1);
	}
	ps-&gt;top--;
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="154" src="https://images2.imgbox.com/68/94/5m4vAtQg_o.png" width="1149"></p> 
<h4 id="8.%E8%8E%B7%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0%EF%BC%9A">8.获取栈顶元素：</h4> 
<pre><code class="language-cs">STDataType STTop(ST* ps)
{
	assert(ps);
	if (ps-&gt;top == -1)
	{
		exit(-1);
	}
	return ps-&gt;a[ps-&gt;top];
}
</code></pre> 
<p>输出：</p> 
<p><img alt="" height="162" src="https://images2.imgbox.com/c8/ea/3ErIk7nF_o.png" width="1200"></p> 
<h4 id="9.%E8%8E%B7%E5%8F%96%E6%9C%89%E6%95%88%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0%3A">9.获取有效数据个数:</h4> 
<pre><code class="language-cs">int STSize(ST* ps)
{
	assert(ps);
	ps-&gt;top++;
	return ps-&gt;top;
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="139" src="https://images2.imgbox.com/4a/ab/S8CFyJcS_o.png" width="1200"></p> 
<h4 id="10%EF%BC%9A%E5%88%A4%E6%96%AD%E6%A0%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%3A">10：判断栈是否为空:</h4> 
<pre><code class="language-cs">bool STEmpty(ST* ps)
{
	assert(ps);
	return ps-&gt;top == -1;//当栈为空那么返回的就是真反之则为假
}</code></pre> 
<p>输出：</p> 
<p class="img-center"><img alt="" height="146" src="https://images2.imgbox.com/b4/5b/Nb3EtBS5_o.png" width="576"></p> 
<h4 id="11.%E6%89%93%E5%8D%B0%E6%A0%88%3A">11.打印栈:</h4> 
<p><img alt="" height="238" src="https://images2.imgbox.com/0c/ea/4FSaTvwZ_o.png" width="1200"></p> 
<h2 id="%E4%B8%89%20%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">三 栈的链式存储结构</h2> 
<p class="img-center"><img alt="" height="259" src="https://images2.imgbox.com/9e/01/2hz7X2Vt_o.png" width="710"></p> 
<h4>1.栈的存储结构：</h4> 
<pre><code class="language-cs">//链表存储结构
typedef int STTDataType;
typedef struct STist
{
	struct STist* next;//指针域
	STTDataType data;//数据域
}ST;
//栈存储结构
typedef struct LinkedStack 
{
	ST* top;//栈顶指针
	int size;//有效数据
} LS;
</code></pre> 
<h4 id="3.%E6%A0%88%E7%9A%84%E6%89%80%E6%9C%89%E6%8E%A5%E5%8F%A3%EF%BC%9A">3.栈的所有接口：</h4> 
<pre><code class="language-cs">//初始化、销毁
//初始化、销毁
void Init_Stack(LS* Stack);
void Destroy_Stack(ST* Stack);

//入栈、出栈
void push_Stack(ST* Stack, STTDataType x);
void pop_Stack(ST* Stack);

//检查栈是否为空
STTDataType STEmpty(ST* Stack);

//获取栈顶元素、有效数据个数
STTDataType STTop(ST* Stack);
STTDataType STSize(ST* Stack);
</code></pre> 
<h4 id="4.%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A">4.栈的初始化：</h4> 
<pre><code class="language-cs">void Init_Stack(LS* Stack)
{
	assert(Stack);
	Stack-&gt;top = NULL;
	Stack-&gt;size = 0;
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="132" src="https://images2.imgbox.com/90/76/JcPHWCf7_o.png" width="1200"></p> 
<h4>5.栈的销毁：</h4> 
<pre><code class="language-cs">void Destroy_Stack(LS* Stack)
{
	assert(Stack);
	Stack-&gt;size = 0;
	ST* tmp = Stack-&gt;top;
	while (tmp != NULL)
	{
		ST* next = tmp-&gt;next;
		free(tmp);
		tmp = next;
	}
}</code></pre> 
<h4>6.入栈：</h4> 
<pre><code class="language-cs">void push_Stack(LS* Stack, STTDataType x)
{
	assert(Stack);
	ST* Newnode = (ST*)malloc(sizeof(ST));
	if (Newnode == NULL)
	{
		perror("malloc error");
		exit(-1);
	}
	Newnode-&gt;data = x;
    //首先就是让第一个节点指向为空(把它当成尾)然后再让新节点指向之前的节点以此类推
	Newnode-&gt;next = Stack-&gt;top;
	Stack-&gt;top = Newnode;//让Stack-&gt;top永远为第一个节点
	Stack-&gt;size++;//有效数据自增
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="319" src="https://images2.imgbox.com/1f/85/InIhQbKX_o.png" width="1200"></p> 
<h4>7.出栈：</h4> 
<pre><code class="language-cs">void pop_Stack(LS* Stack)
{
	assert(Stack);
	if (Stack-&gt;top == NULL)//判断栈顶指针是否为空
	{
		exit(-1);
	}
	ST* Ptmp = (Stack-&gt;top)-&gt;next;
	free(Stack-&gt;top);
	Stack-&gt;top = Ptmp;
	Ptmp = Ptmp-&gt;next;
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="416" src="https://images2.imgbox.com/f5/a6/6RUjiqkN_o.png" width="1200"></p> 
<h4>8.获取栈顶元素：</h4> 
<pre><code class="language-cs">STTDataType STTop(LS* Stack)
{
	return Stack-&gt;top-&gt;data;
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="116" src="https://images2.imgbox.com/4f/74/cfbP97dP_o.png" width="1200"></p> 
<h4 id="9.%E8%8E%B7%E5%8F%96%E6%9C%89%E6%95%88%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0%EF%BC%9A">9.获取有效数据个数：</h4> 
<pre><code class="language-cs">STTDataType STSize(LS* Stack)
{
	return Stack-&gt;size;
}
</code></pre> 
<p>输出：</p> 
<p><img alt="" height="92" src="https://images2.imgbox.com/7d/05/hm6n2lu7_o.png" width="1200"></p> 
<h4 id="10.%E5%88%A4%E6%96%AD%E6%A0%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%EF%BC%9A">10.判断栈是否为空：</h4> 
<pre><code class="language-cs">STTDataType IsEmpty(LS* Stack)
{
	if (Stack-&gt;top == NULL)//判断栈顶指针是否为空
	{
		return 0;
	}
	return 1;
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="322" src="https://images2.imgbox.com/4f/95/7Y7kIp8c_o.png" width="1200"></p> 
<h2 id="%E5%9B%9B%20%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%92%8C%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0%E6%A0%88%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%AF%94%E8%BE%83">四 顺序存储和链式存储实现栈的优缺点比较</h2> 
<p>顺序存储和链式存储都可用于实现栈，各有优缺点。具体选择哪种方式取决于应用的特定需求和优先级。</p> 
<h4 id="1.%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%EF%BC%88%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E7%9A%84%E6%A0%88%EF%BC%89%EF%BC%9A"><strong>1.顺序存储（基于数组的栈）：</strong></h4> 
<p><strong>优点：</strong></p> 
<ol><li> <p><strong>2.高效的访问和随机检索：</strong> 顺序存储允许使用索引直接访问堆栈中的任何元素，从而实现高效的随机检索元素。</p> </li><li> <p><strong>可预测的内存使用：</strong> 基于数组的栈具有预定义的大小，使得估计和管理内存使用更加容易。</p> </li><li> <p><strong>缓存友好型访问：</strong> 数组中的连续内存位置往往可以更好地利用 CPU 缓存。</p> </li></ol> 
<p><strong>缺点：</strong></p> 
<ol><li> <p><strong>有限的动态调整大小：</strong> 基于数组的栈具有固定大小，在运行过程中调整大小可能效率低下，并且需要复制元素。</p> </li><li> <p><strong>潜在的内存浪费：</strong> 如果栈大小估计过高，则可能由于未使用的分配空间而浪费内存。如果估计过低，则栈可能溢出，导致错误。</p> </li><li> <p><strong>中间插入/删除代价高昂：</strong> 在基于数组的栈中插入或删除中间元素可能代价高昂，因为它需要移动元素以保持顺序。</p> </li></ol> 
<h4 id="2.%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%EF%BC%88%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A0%88%EF%BC%89%EF%BC%9A"><strong>2.链式存储（基于链表的栈）：</strong></h4> 
<p><strong>优点：</strong></p> 
<ol><li> <p><strong>动态调整大小：</strong> 链表可以根据需要动态增长或缩小，因此适用于堆栈大小不可预测的情况。</p> </li><li> <p><strong>中间插入/删除高效：</strong> 在链表栈中插入或删除中间元素相对便宜，因为它只需要修改指针引用。</p> </li><li> <p><strong>灵活的内存分配：</strong> 链表不需要连续的内存分配，因此适用于内存受限的环境。</p> </li></ol> 
<p><strong>缺点：</strong></p> 
<ol><li> <p><strong>较慢的访问和检索：</strong> 访问链表堆栈中的特定元素需要从头开始遍历链表，与顺序存储相比，随机检索速度较慢。</p> </li><li> <p><strong>指针开销：</strong> 链表会引入额外的内存开销来存储节点之间的指针，这在内存关键型应用程序中可能是一个因素。</p> </li><li> <p><strong>缓存效率低：</strong> 链表的非连续内存布局可能导致缓存利用率低于顺序存储。</p> </li></ol> 
<h2 id="%E6%80%BB%E7%BB%93%EF%BC%9A" style="background-color:transparent;"><strong>五 总结</strong></h2> 
<ul><li> <p><strong>建议使用顺序存储（基于数组的栈）</strong>：</p> 
  <ol><li>随机访问和检索速度至关重要。</li><li>可预测和可控的内存使用很重要。</li><li>堆栈大小相对稳定，可以事先估计。</li></ol></li><li> <p><strong>建议使用链式存储（基于链表的栈）</strong>：</p> 
  <ol><li>需要动态的堆栈大小来处理不可预测的数据量。</li><li>预计频繁地在堆栈中间插入/删除元素。</li><li>内存限制是一个问题，需要灵活的内存分配。</li></ol></li></ul> 
<p>对于实现栈的顺序存储和链式存储之间的选择，取决于应用的特定需求和优先级。仔细权衡访问速度、内存使用和动态功能之间的利弊，以做出最佳决策。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e13cd9cd03d9efc125296f4d206cea9d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言之数据结构之栈和队列的运用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5acdeb2950bb8bacf31dcb7f38726b9e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2024年大数据最全《大数据时代：生活、工作与思维的大变革》：看(2)，2024年最新讲的太清楚了</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>