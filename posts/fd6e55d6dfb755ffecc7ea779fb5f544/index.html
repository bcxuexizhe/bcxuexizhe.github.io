<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构：线性表(详解) - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/fd6e55d6dfb755ffecc7ea779fb5f544/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="数据结构：线性表(详解)">
  <meta property="og:description" content="线性表 线性表的知识框架：
线性表的定义：
线性表是具有相同数据类型的n(n &gt; 0)个数据元素的有限序列，当n = 0时线性表为一个空表。
若用L命名为线性表，则数据集合为L= {a1,a2,…,an}，其中a1称为表头元素，an称为表尾元素。除第一个元素外，每个元素有且仅有一个直接前驱。除最后一个元素外，每个元素有且仅有一个直接后继。
线性表的特点： 1.表中元素的个数有限
2.表中元素具有逻辑上的顺序表，表中元素有其先后次序
3.表中元素都是数据元素，每个元素都是单个元素
4.表中元素的数据类型相同，所以每个元素占有相同大小的存储空间
5.线性表是一种逻辑结构，表示元素之间一对一的相邻关系。顺序表和链表是指存储结构
线性表的顺序存储结构 顺序表的的定义： 线性表的顺序存储又称顺序表。它是用一组地址连续的存储单元依次存储线性表中的数据元素。
顺序表的特点： 1.顺序表的存储密度高，每个结点只存储数据结构。
2.顺序表逻辑上相邻的元素在物理上也相邻，所以插入和删除操作需要移动大量数据
3.顺序表是随机访问，即通过首地址和元素序号可在时间O(1)内找到指定的元素
顺序表代码实现：
顺序表储存结构： typedef int SLTDataType; typedef struct SeqList { SLDatatype capacity;//数组的容量 SLDatatype size;//有效数据 SLDatatype* arr; }SL; 顺序表所有接口： //初始化/销毁 void SLInit(SL* ps); void SLDestroy(SL* ps); void SLPrint(SL* ps); //顺序表的头部/尾部插入 void SLPushBack(SL* ps, SLDatatype x); void SLPushFront(SL* ps, SLDatatype x); //顺序表的头部/尾部删除 void SLPopBack(SL* ps); void SLPopFront(SL* ps); //指定位置之前插入数据/删除指定位置数据 void SLInsert(SL* ps, SLDatatype pos, SLDatatype x); void SLErase(SL* ps, SLDatatype pos); 顺序表初始化和销毁： void SLInit(SL* ps) { ps-&gt;arr = NULL; ps-&gt;capacity = ps-&gt;size = 0; } 顺序表输出：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-06T16:12:44+08:00">
    <meta property="article:modified_time" content="2024-05-06T16:12:44+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构：线性表(详解)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2></h2> 
<p id="main-toc"></p> 
<h2 id="%E7%BA%BF%E6%80%A7%E8%A1%A8">线性表</h2> 
<p><strong>线性表的知识框架：</strong></p> 
<p><img alt="" height="401" src="https://images2.imgbox.com/9d/a9/NT9j5VrW_o.png" width="727"></p> 
<p id="%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A"><strong>线性表的定义：</strong></p> 
<p>线性表是具有<span style="color:#fe2c24;">相同数据类型</span>的n(n &gt; 0)个数据元素的<span style="color:#fe2c24;">有限序列</span><span style="color:#0d0016;">，当n = 0时线性表为一个空表。<br> 若用L命名为线性表，则</span>数据集合为L= {a1,a2,…,an}，其中a1称为表头元素，an称为表尾元素。除第一个元素外，每个元素有且<span style="color:#fe2c24;">仅有一个直接前驱</span>。除最后一个元素外，每个元素有且<span style="color:#fe2c24;">仅有一个直接后继。</span></p> 
<h6 id="%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A"><strong>线性表的特点：</strong></h6> 
<p>1.表中元素的个数<span style="color:#fe2c24;">有限</span><br> 2.表中元素具有逻辑上的顺序表，表中元素有其<span style="color:#fe2c24;">先后次序</span><br> 3.表中元素都是数据元素，每个元素都是单个元素<br> 4.表中元素的<span style="color:#fe2c24;">数据类型相同</span>，所以每个元素占有相同大小的存储空间<br> 5.线性表是一种<span style="color:#fe2c24;">逻辑结构</span>，表示元素之间一对一的相邻关系。顺序表和链表是指<span style="color:#fe2c24;">存储结构</span></p> 
<h3 id="%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">线性表的顺序存储结构</h3> 
<h6 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A"><strong>顺序表的的定义：</strong></h6> 
<p>线性表的顺序存储又称顺序表。它是用一组地址连续的存储单元依次存储线性表中的数据元素。</p> 
<h6 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A"><strong>顺序表的特点：</strong></h6> 
<p>1.顺序表的存储密度高，每个结点只存储数据结构。<br> 2.顺序表逻辑上相邻的元素在物理上也相邻，所以插入和删除操作需要移动大量数据<br> 3.顺序表是随机访问，即通过首地址和元素序号可在时间O(1)内找到指定的元素</p> 
<p><strong>顺序表代码实现：</strong></p> 
<h6 id="%C2%A0%20%C2%A0%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%9A">    顺序表储存结构：</h6> 
<pre><code>
typedef int SLTDataType;
typedef struct SeqList
{
	SLDatatype capacity;//数组的容量
	SLDatatype size;//有效数据
	SLDatatype* arr;
}SL;</code></pre> 
<h6 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%89%80%E6%9C%89%E6%8E%A5%E5%8F%A3%EF%BC%9A">顺序表所有接口：</h6> 
<pre><code>//初始化/销毁
void SLInit(SL* ps);
void SLDestroy(SL* ps);
void SLPrint(SL* ps);

//顺序表的头部/尾部插入
void SLPushBack(SL* ps, SLDatatype x);
void SLPushFront(SL* ps, SLDatatype x);

//顺序表的头部/尾部删除
void SLPopBack(SL* ps);
void SLPopFront(SL* ps);

//指定位置之前插入数据/删除指定位置数据
void SLInsert(SL* ps, SLDatatype pos, SLDatatype x);
void SLErase(SL* ps, SLDatatype pos);</code></pre> 
<h6 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%EF%BC%9A">顺序表初始化和销毁：</h6> 
<pre><code>void SLInit(SL* ps)
{
	ps-&gt;arr = NULL;
	ps-&gt;capacity = ps-&gt;size = 0;
}</code></pre> 
<p><img alt="" height="207" src="https://images2.imgbox.com/a8/d0/ksuokm15_o.png" width="1133"></p> 
<p>顺序表输出：</p> 
<pre><code>void SLPrint(SL* ps)
{
	for (int i = 0; i &lt; ps-&gt;size; i++)
	{
		printf("%d ", ps-&gt;arr[i]);
	}
    printf("\n");
}</code></pre> 
<h6 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%89%A9%E5%AE%B9%EF%BC%9A">顺序表扩容：</h6> 
<pre><code>void SLIncreaseCapacity(SL* ps)
{
	if (ps-&gt;capacity == ps-&gt;size)//当有效数据与实际数据相等则需要扩容
	{
		SLDatatype NewCapacity = ps-&gt;capacity == 0 ? 4 : ps-&gt;capacity * 2;
		SLDatatype* tmp = (SLDatatype*)realloc(ps-&gt;arr, NewCapacity * sizeof(int));
		if (tmp == NULL)
		{
			perror("malloc error");
			exit(-1);
		}
		ps-&gt;arr = tmp; //仅当 SL 结构被销毁时，用于 ps-&gt;arr 的内存才会被释放。
		ps-&gt;capacity = NewCapacity;
	}
}</code></pre> 
<h6 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%B0%BE%E6%8F%92%EF%BC%9A">顺序表尾插：</h6> 
<pre><code>void SLPushBack(SL* ps, SLDatatype x)
{
	assert(ps);
SLIncreaseCapacity(ps);//判断是否需要扩容
ps-&gt;arr[ps-&gt;size++] = x;
}</code></pre> 
<p>顺序表尾插输出：</p> 
<p class="img-center"><img alt="" height="361" src="https://images2.imgbox.com/08/a0/7B4j2SbQ_o.png" width="368"></p> 
<h6 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%A4%B4%E6%8F%92%EF%BC%9A">顺序表头插：</h6> 
<pre><code>void SLPushFront(SL* ps, SLDatatype x)
{
	assert(ps);
SLIncreaseCapacity(ps);//判断是否需要扩容
for (int i = ps-&gt;size; i &gt; 0; i--)
{
	ps-&gt;arr[i] = ps-&gt;arr[i - 1];
}
ps-&gt;arr[0] = x;
ps-&gt;size++;
}</code></pre> 
<p>顺序表头插输出：</p> 
<p class="img-center"><img alt="" height="252" src="https://images2.imgbox.com/f2/8f/tB3NyJHk_o.png" width="416"></p> 
<h6 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%B0%BE%E5%88%A0%EF%BC%9A">顺序表尾删：</h6> 
<pre><code>void SLPopBack(SL* ps)
{
	assert(ps);
	assert(ps-&gt;size);//判断数组是否为空
	ps-&gt;size--;//size--只是在逻辑层面删除了而已，但物理层面还是实际存在的 
               //只是我们不将它看成 顺序表的一部分，所以就可以理解为删除了         
}</code></pre> 
<p>顺序表尾删输出：</p> 
<p class="img-center"><img alt="" height="221" src="https://images2.imgbox.com/47/34/MjENu1CS_o.png" width="533"></p> 
<h6 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%A4%B4%E5%88%A0%EF%BC%9A">顺序表头删：</h6> 
<pre><code>void SLPopFront(SL* ps)
{
	assert(ps);
	assert(ps-&gt;size);
	for (int i = 0; i &lt; ps-&gt;size - 1; i++)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i + 1];
	}
	ps-&gt;size--;
}</code></pre> 
<p>顺序表头删输出：</p> 
<p class="img-center"><img alt="" height="231" src="https://images2.imgbox.com/bf/da/IXS2NMms_o.png" width="513"></p> 
<h6 id="%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%EF%BC%9A">在指定位置插入：</h6> 
<pre><code>void SLInsert(SL* ps, SLDatatype pos, SLDatatype x)
{
	assert(ps);
	SLCheckCapacity(ps);
	assert(pos &gt;= 0 &amp;&amp; pos &lt; ps-&gt;size);//pos如果小于0那就没什么意义并且不能等于ps-&gt;size如果等于那就相当于尾插了
	for (int i = ps-&gt;size; i &gt; pos; i--)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i - 1];
	}
	ps-&gt;arr[pos] = x;
	ps-&gt;size++;
}</code></pre> 
<p>指定位置输出：</p> 
<p class="img-center"><img alt="" height="188" src="https://images2.imgbox.com/c6/d7/kGUIVDXx_o.png" width="578"></p> 
<h6 id="%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E5%88%A0%E9%99%A4%EF%BC%9A">在指定位置删除：</h6> 
<pre><code>void SLErase(SL* ps, SLDatatype pos)
{
	assert(ps);
	assert(pos &gt;= 0 &amp;&amp; pos &lt; ps-&gt;size);
	for (int i = pos; i &lt; ps-&gt;size - 1; i++)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i + 1];
	}
	ps-&gt;size--;
}</code></pre> 
<p>指定位置输出：</p> 
<p></p> 
<p class="img-center"><img alt="" height="204" src="https://images2.imgbox.com/08/da/MoT5oM2Q_o.png" width="488"></p> 
<p></p> 
<h3 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A">顺序表的优缺点：</h3> 
<p>  优点：1.空间利用率高</p> 
<p>             2.插入删除方便</p> 
<p>             3.结构简单</p> 
<p>  缺点：1.访问效率低</p> 
<p>            2.插入和删除操作可能导致元素移动</p> 
<p>            3.难以实现部分元素的随机访问</p> 
<h2 id="%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%9A">线性表的链式存储结构：</h2> 
<h3 id="%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A"><strong>单链表的定义：</strong></h3> 
<p>单链表（SLL）是一种由节点序列组成的链接数据结构，每个节点包含一个数据元素和一个指向下一个节点的指针。单链表以其简单性和效率而闻名，广泛应用于各种应用程序。<span style="color:#0d0016;">                                                                                  单链表结构如下：</span></p> 
<p class="img-center"><img alt="" height="71" src="https://images2.imgbox.com/ac/ac/5321yW3G_o.png" width="286"></p> 
<p><strong>单链表代码实现：</strong></p> 
<h6 id="%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%9A">单链表存储结构：</h6> 
<pre><code>typedef int SLTDataType;
typedef struct SList
{
	struct SList* next;//指针域
	SLTDataType data;//数据域
}SL;
</code></pre> 
<h6 id="%E5%8D%95%E9%93%BE%E8%A1%A8%E6%89%80%E6%9C%89%E6%8E%A5%E5%8F%A3%EF%BC%9A">单链表所有接口：</h6> 
<pre><code>
//链表的输出、销毁
void SLPrint(SL* phead);
void SListDesTroy(SL** pphead);

//链表的尾插、头插
void SLPushBack(SL** pphead, SLTDataType x);
void SLPushFront(SL** pphead, SLTDataType x);

//链表的尾删、头删
void SLPopBack(SL** pphead);
void SLPopFront(SL** pphead);

//查找
SL* SLTFind(SL* phead, SLTDataType x);

//在指定位置之前插入数据、之后插入数据
void SLTInsert(SL** pphead, SL* pos, SLTDataType x);
void SLTInsertAfter(SL* pos, SLTDataType x);

//删除pos节点、pos之后的节点
void SLTErase(SL** pphead, SL* pos);
void SLTEraseAfter(SL* pos);</code></pre> 
<h6 id="%E5%8D%95%E9%93%BE%E8%A1%A8%E8%BE%93%E5%87%BA%EF%BC%9A">单链表输出：</h6> 
<pre><code>
void SLPrint(SL* phead)
{
	SL* pur = phead;
	while (pur)
	{
		printf("%d-&gt;", pur-&gt;data);
		pur = pur-&gt;next;
	}
	printf("NULL");
	printf("\n");
}</code></pre> 
<h6 id="%E5%8D%95%E9%93%BE%E8%A1%A8%E9%94%80%E6%AF%81%EF%BC%9A">单链表销毁：</h6> 
<pre><code>
void SListDesTroy(SL** pphead)
{
	void SListDesTroy(SL** pphead)
{
	assert(pphead &amp;&amp; *pphead);
	SL* Pfast = (*pphead)-&gt;next;
	SL* Pslow = *pphead;
	while (Pslow &amp;&amp; Pfast != NULL)
	{
		free(Pslow);
		Pslow = NULL;

		Pslow = Pfast;
		Pfast = Pfast-&gt;next;
	}
    //销毁尾节点
	free(Pslow);
	Pslow = NULL;
    //free完之后再将头节点置为空
	*pphead = NULL;
}
}</code></pre> 
<p>销毁链表输出：</p> 
<p><img alt="" height="172" src="https://images2.imgbox.com/07/a0/SXkKcN52_o.png" width="1200"></p> 
<h6 id="%E6%89%A9%E5%AE%B9%E5%8D%95%E9%93%BE%E8%A1%A8%E7%A9%BA%E9%97%B4%EF%BC%9A">扩容单链表空间：</h6> 
<pre><code>
SL* SLTBuyNode(SLTDataType x)
{
	SL* Newnode = (SL*)malloc(sizeof(SL));
	SL*	ptmp = Newnode;
	if (ptmp == NULL)
	{
		perror("malloc error");
		exit(-1);
	}
	Newnode-&gt;data = x;
	Newnode-&gt;next = NULL;
	return Newnode;
}</code></pre> 
<h6 id="%E5%8D%95%E9%93%BE%E8%A1%A8%E5%B0%BE%E6%8F%92%EF%BC%9A">单链表尾插：</h6> 
<pre><code>
//为什么需要二级指针而不用一级指针呢，因为传一级的话改变不了它的指向而二级指针可以
//就相当于C语言里面传值和传地址一个道理
void SLPushBack(SL** pphead, SLTDataType x)
{
	//pphead:相当于指针指向节点的那个指针的地址
    //*pphead:相当于节点地址
    //**pphead:相当于节点里的数据
	assert(pphead);//判断pphead指针是否为空和节点是否为空
	//assert(*pphead);//判断pphead节点是否为空
	SL* newnode = SLTBuyNode(x);
	if (*pphead == NULL)//当链表为空时那么newnode就可以作为链表的新节点
	{
		*pphead = newnode;
		return;
	}
	//链表不为空
	SL* Ptmp = *pphead;
	while (Ptmp-&gt;next)
	{
		Ptmp = Ptmp-&gt;next;
	}
	Ptmp-&gt;next = newnode;
}</code></pre> 
<p>单链表尾插输出：</p> 
<p class="img-center"><img alt="" height="541" src="https://images2.imgbox.com/36/8a/ZAhoqaBG_o.png" width="857"></p> 
<p><img alt="" height="785" src="https://images2.imgbox.com/ad/47/jmfbV0CM_o.png" width="1167"></p> 
<p></p> 
<p>本质上，单指针用于“只读”操作，而双指针用于“读写”操作。</p> 
<p>以下是一个简化的类比来说明区别：</p> 
<p>想象一个链表就像一列火车车厢。每个车厢代表列表中的一个节点，车厢之间的连接代表指针。</p> 
<p><strong>单指针</strong>就像火车上的乘客。他们可以从一辆车厢移动到另一辆车厢，观察每辆车厢的内容（数据访问），但他们不能直接拆卸或连接车厢（修改列表结构）。</p> 
<p><strong>双指针</strong>就像火车乘务员。他们不仅有权在车厢之间移动，还可以解耦和耦合车厢，修改列车的组成（修改列表结构）。<br> 如果还是搞不懂可以点开这个链接，这个博主写的非常好<a href="http://t.csdnimg.cn/yNoDo" rel="nofollow" title="http://t.csdnimg.cn/yNoDo">http://t.csdnimg.cn/yNoDo</a></p> 
<h6 id="%E5%8D%95%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%8F%92%EF%BC%9A">单链表头插：</h6> 
<pre><code>
void SLPushFront(SL** pphead, SLTDataType x)
{
	assert(pphead);
	SL* newnode = SLTBuyNode(x);
	if (*pphead == NULL)
	{
		*pphead = newnode;
		return;
	}
	newnode-&gt;next = *pphead;
	*pphead = newnode;
}</code></pre> 
<p>单链表头插输出：</p> 
<p><img alt="" height="258" src="https://images2.imgbox.com/46/0f/iiPiPI0r_o.png" width="703"></p> 
<p>单链表尾插：</p> 
<pre><code>
void SLPopBack(SL** pphead)
{
	assert(pphead &amp;&amp; *pphead);//判断pphead指针是否为空和节点是否为空
	//只有一个节点
	//因为-&gt;符号的优先级比*符号的优先级高所以不加括号就是pphead-&gt;next
	if ((*pphead)-&gt;next == NULL)
	{
		free(*pphead);
		*pphead = NULL;
		return;
	}
	//多个节点
	SL* Pfast = *pphead;
	SL* Pslow = NULL;
	//如果是用Pfast去判断的话那等while结束的时候到它会指向NULL，Plast会指向最后一个节点
    //最后我们是把NULL赋给Pfast-&gt;next以此来达到尾删的效果，那这样都不是删除最后一个节点而是给NULL赋NULL。
	//所以是要用Pfast-&gt;next去进行判断
	while (Pfast-&gt;next)
	{
		Pslow = Pfast;
		Pfast = Pfast-&gt;next;
	}
	Pslow-&gt;next = NULL;
	//最后别忘记销毁尾节点
	free(Pfast);
	Pfast = NULL;
}
</code></pre> 
<p>单链表尾删输出：</p> 
<p><img alt="" height="426" src="https://images2.imgbox.com/07/17/QQRIFstN_o.png" width="730"></p> 
<h6 id="%E5%8D%95%E9%93%BE%E8%A1%A8%E5%A4%B4%E5%88%A0%EF%BC%9A">单链表头删：</h6> 
<pre><code>
void SLPopFront(SL** pphead)
{
	assert(pphead &amp;&amp; *pphead);
	//只有一个节点
	if ((*pphead)-&gt;next == NULL)
	{
		free(*pphead);
		*pphead = NULL;
		return;
	}
	//多个节点
	SL* next = (*pphead)-&gt;next;
	free(*pphead);
	*pphead = next;
}</code></pre> 
<p>单链表头删输出：</p> 
<p><img alt="" height="437" src="https://images2.imgbox.com/d9/0a/wELkhUO8_o.png" width="725"></p> 
<h6 id="%E5%8D%95%E9%93%BE%E8%A1%A8%E6%9F%A5%E6%89%BE%EF%BC%9A">单链表查找：</h6> 
<pre><code>
SL* SLTFind(SL* phead, SLTDataType x)
{
	assert(phead);
	SL* Pcur = phead;
	while (Pcur)
	{
		if (Pcur-&gt;data == x)
		{
			return Pcur;
		}
		Pcur = Pcur-&gt;next;
	}
	return NULL;
}</code></pre> 
<p>查找输出：</p> 
<p><img alt="" height="379" src="https://images2.imgbox.com/cc/33/aeWLRXdL_o.png" width="953"></p> 
<h6 id="%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%89%8D%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%EF%BC%9A">在指定位置之前插入数据：</h6> 
<pre><code>void SLTInsert(SL** pphead, SL* pos, SLTDataType x)
{
	assert(pphead &amp;&amp; *pphead);
	assert(pos);//判断pos指针是否为空
	SL* newnode = SLTBuyNode(x);//扩容一个新节点
	//假设pos为头节点
	if (pos == *pphead)
	{   //头插
		SLPushFront(pphead , x);
		return;//插入完新数据直接return
	}
	SL* Pur = *pphead;
	//不为头节点
	while (Pur)
	{
		if (Pur-&gt;next == pos)
		{
			Pur-&gt;next = newnode;
			newnode-&gt;next = pos;
		}
		Pur = Pur-&gt;next;
	}
	return;
}</code></pre> 
<p>指定位置之前输出：</p> 
<p><img alt="" height="130" src="https://images2.imgbox.com/14/a6/ArmKU4pe_o.png" width="998"></p> 
<h6 id="%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%EF%BC%9A">在指定位置之后插入数据：</h6> 
<pre><code>
//尾插不需要pos之前的指针，所以pphead在这里不起作用
void SLTInsertAfter(SL* pos, SLTDataType x)
{
	assert(pos);
	SL* newnode = SLTBuyNode(x);
	SL* Ptur = pos-&gt;next;//防止找不到它的下一个节点
	pos-&gt;next = newnode;
	newnode-&gt;next = Ptur;
}
</code></pre> 
<p>指定位置之后输出：</p> 
<p><img alt="" height="133" src="https://images2.imgbox.com/e9/7f/163BuKHJ_o.png" width="927"></p> 
<h6 id="%E5%88%A0%E9%99%A4pos%E6%8C%87%E9%92%88%EF%BC%9A">删除pos指针：</h6> 
<pre><code>void SLTErase(SL** pphead, SL* pos)
{
	assert(pphead &amp;&amp; *pphead);
	assert(pos);
	//pos刚好是头结点,执行头删
	if (*pphead == pos) 
	{
		//头删
		SLPopFront(pphead);
		return;
	}
	SL* Pur = *pphead;
	//不为头节点
	while (Pur-&gt;next != pos)
	{
		Pur = Pur-&gt;next;
	}
	Pur-&gt;next = pos-&gt;next;
	free(pos);
	pos = NULL;
	return;
	//为什么错误？上面为什么对？
	//因为上面就是他先把pos置为空但是那个循环不会结束等到Pur-&gt;NULL时
	//那这又与pos相等了,如果再去访问pos-&gt;next就会报错
	//访问空指针的next就会出问题但是访问有效指针的next且那个next为空这样并不会报错
	/*while (Pur)
	{
		if (Pur-&gt;next == pos)
		{
			Pur-&gt;next = pos-&gt;next;
			free(pos);
			pos = NULL;
		}
		Pur = Pur-&gt;next;
	}*/
}</code></pre> 
<p>删除pos指针输出：</p> 
<p><img alt="" height="154" src="https://images2.imgbox.com/5a/d2/v4LP7TtX_o.png" width="869"></p> 
<h6 id="%E5%88%A0%E9%99%A4pos%E4%B9%8B%E5%90%8E%E8%8A%82%E7%82%B9">删除pos之后节点</h6> 
<pre><code>void SLTEraseAfter(SL* pos)
{
	assert(pos);
	SL* Pur = pos-&gt;next;//保存Pur节点等下需要销毁这个节点
	pos-&gt;next = pos-&gt;next-&gt;next;
	free(Pur);
	Pur = NULL;
}</code></pre> 
<p>删除pos之后节点输出：</p> 
<p><img alt="" height="141" src="https://images2.imgbox.com/c0/f4/WAumcYod_o.png" width="812"></p> 
<p>                                     <span style="color:#fe2c24;">上述代码全部都是用不带头节点编写而成 </span></p> 
<h3 id="%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span style="color:#0d0016;">单链表的优缺点：</span></h3> 
<p><span style="color:#0d0016;"> 优点：</span><br>              1.简单易懂<br>              2.插入和删除操作高效<br>              3.动态内存管理</p> 
<p>缺点：<br>              1.无法随机访问<br>              2.插入操作会破坏原有顺序<br>              3.无法向后遍历</p> 
<h3 id="%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A"><strong>双链表的定义：</strong></h3> 
<p>在计算机科学中，双链表（DLL）是一种由元素序列组成的链接数据结构，每个元素称为节点，每个节点都有两个指针：一个指向序列中的下一个节点，另一个指向前面的节点。每个节点还包含一个数据元素。</p> 
<p>双链表代码实现：</p> 
<h6 id="%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%9A">双链表存储结构：</h6> 
<pre><code>typedef int LTDataType;
typedef struct DList
{
	struct DList* next;//后继节点
	struct DList* prev;//前驱节点
	LTDataType data;//节点数据
}DL;</code></pre> 
<h6 id="%E5%8F%8C%E9%93%BE%E8%A1%A8%E6%89%80%E6%9C%89%E6%8E%A5%E5%8F%A3%EF%BC%9A">双链表所有接口：</h6> 
<pre><code>//初始化、销毁、输出
void LTInit(DL** pphead);
void LTDesTroy(DL** pphead);
void LTPrint(DL* phead);

//尾插、头插
void LTPushBack(DL* phead, LTDataType x);
void LTPushFront(DL* phead, LTDataType x);

//头删、尾删
void LTPopBack(DL* phead);
void LTPopFront(DL* phead);

//查找
DL* LTFind(DL* phead, LTDataType x);

//在pos位置之后插入数据、删除pos位置的数据
void LTInsert(DL* pos, LTDataType x);
void LTErase(DL* pos);</code></pre> 
<h6 id="%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A">双链表初始化：</h6> 
<pre><code>void LTInit(DL** pphead)
{
	*pphead = (DL*)malloc(sizeof(DL));//为哨兵位开辟空间
	if (*pphead == NULL)
	{
		perror("malloc error");
		exit(-1);
	}
    //双链表节点的初始化是前驱和后继指针都是指向自身
	(*pphead)-&gt;next = (*pphead)-&gt;prev = *pphead;
	(*pphead)-&gt;data = 0;
}</code></pre> 
<p>双链表初始化输出：</p> 
<p><img alt="" height="204" src="https://images2.imgbox.com/b1/e8/862anSkT_o.png" width="1175"></p> 
<h6 id="%E5%8F%8C%E9%93%BE%E8%A1%A8%E9%94%80%E6%AF%81%EF%BC%9A">双链表销毁：</h6> 
<pre><code>void  LTDesTroy(DL** pphead)
{
	assert(pphead);
	assert(*pphead);
	DL* Pfast = (*pphead)-&gt;next-&gt;next;
	DL* Pslow = (*pphead)-&gt;next;
	while (Pslow != NULL)
	{
		free(Pslow);
		Pslow = NULL;
		Pslow = Pfast;
		Pfast = Pfast-&gt;next;
	}
	free(*pphead);
	*pphead = NULL;
}</code></pre> 
<p>双链表销毁输出：</p> 
<p><img alt="" height="190" src="https://images2.imgbox.com/16/36/Y0o5LEuI_o.png" width="712"></p> 
<h6 id="%E6%89%A9%E5%B1%95%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%A9%BA%E9%97%B4%EF%BC%9A">扩展双链表空间：</h6> 
<pre><code>DL* DLTBuyNode(LTDataType x)
{
	DL* NewNode = (DL*)malloc(sizeof(DL));//为新节点开辟空间
	DL* Ptmp = NewNode;
	if (Ptmp == NULL)
	{
		perror("malloc error");
		exit(-1);
	}
	Ptmp-&gt;data = x;
	Ptmp-&gt;next = Ptmp-&gt;prev = NewNode;
	return NewNode;
}</code></pre> 
<h6 id="%E5%8F%8C%E9%93%BE%E8%A1%A8%E8%BE%93%E5%87%BA%EF%BC%9A">双链表输出：</h6> 
<pre><code>void LTPrint(DL* phead)
{
	assert(phead);
	DL* Pur = phead-&gt;next;//因为哨兵位没有数据所以不需要遍历它
	while (Pur != phead)
	{
		printf("%d-&gt;", Pur-&gt;data);
		Pur = Pur-&gt;next;
	}
	printf("\n");
}</code></pre> 
<h6 id="%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%B0%BE%E6%8F%92%EF%BC%9A">双链表尾插：</h6> 
<pre><code>void LTPushBack(DL* phead, LTDataType x)
{
    assert(phead);//判断phead指针是否为空
	DL* Newnode = DLTBuyNode(x);
	//先改变新节点
	Newnode-&gt;next = phead;//让新节点的后继指针指向头节点(原先是尾节点指向哨兵位的前驱)
	Newnode-&gt;prev = phead-&gt;prev;//让新节点的前驱指针指向尾节点

	//再改变尾节点
	phead-&gt;prev-&gt;next = Newnode;//让尾节点的后继指针指向新节点
	phead-&gt;prev = Newnode;//哨兵位的前驱指针指向新节点
}</code></pre> 
<p>双链表尾插输出：</p> 
<p><img alt="" height="454" src="https://images2.imgbox.com/34/20/twQLWz6V_o.png" width="735"></p> 
<h6 id="%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%8F%92%EF%BC%9A">双链表头插：</h6> 
<pre><code>//双链表的头插并不是在哨兵位之前插入数据而是第一个有效节点之前插入
//在哨兵位之前插入数据就相当尾插,因为哨兵位前面就是最后一个有效节点
void LTPushFront(DL* phead, LTDataType x)
{
	assert(phead);
	DL* Newnode = DLTBuyNode(x);
	//先改变新节点的指向
	Newnode-&gt;next = phead-&gt;next;
	Newnode-&gt;prev = phead;

	phead-&gt;next-&gt;prev = Newnode;
	phead-&gt;next = Newnode;
}
</code></pre> 
<p>双链表头插输出：</p> 
<p><img alt="" height="521" src="https://images2.imgbox.com/01/8a/W76h1KRw_o.png" width="830"></p> 
<h6 id="%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%B0%BE%E5%88%A0%EF%BC%9A">双链表尾删：</h6> 
<pre><code>void LTPopBack(DL* phead)
{
	assert(phead);
	assert(phead-&gt;next != phead);//哨兵位指向自己就相当于双链表为空
	DL* pre = phead-&gt;prev;
	//先让尾节点的前一个节点的next指向哨兵位再让哨兵位的前驱指针指向尾节点的前一个节点那这样下 
    //来尾节点就相当于被销毁了
	phead-&gt;prev-&gt;prev-&gt;next = phead;//phead-&gt;prev就相当于尾节点然后phead-&gt;prev-&gt;prev就相当 
                                    //于尾节点的前一个节点
	phead-&gt;prev = phead-&gt;prev-&gt;prev;
	free(pre);
	pre = NULL;
	
}</code></pre> 
<p>双链表尾删输出：</p> 
<p><img alt="" height="214" src="https://images2.imgbox.com/3f/a7/5WtClzxo_o.png" width="667"></p> 
<h6 id="%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%A4%B4%E5%88%A0%EF%BC%9A">双链表头删：</h6> 
<pre><code>void LTPopFront(DL* phead)
{
	assert(phead);
	assert(phead-&gt;next != phead);
	DL* next = phead-&gt;next;//如果不先保存原哨兵位的next地址那删除完节点后再去 
                           //free(phead&gt;next)这样就是删除新头节点了并不是再删除旧的头节点
	phead-&gt;next-&gt;next-&gt;prev = phead;
	phead-&gt;next = phead-&gt;next-&gt;next;
	free(next);
	next = NULL;
}</code></pre> 
<p>双链表头删输出：</p> 
<p><img alt="" height="146" src="https://images2.imgbox.com/75/ba/hUf3n4lE_o.png" width="768"></p> 
<h6 id="%E5%8F%8C%E9%93%BE%E8%A1%A8%E6%9F%A5%E6%89%BE%EF%BC%9A">双链表查找：</h6> 
<pre><code>DL* LTFind(DL* phead, LTDataType x)
{
	assert(phead);
	DL* Pur = phead-&gt;next;//区别于与单链表的是这里传的并不是头节点而是头节点next
	while (Pur != phead)
	{
		if (Pur-&gt;data == x)
		{
			return Pur;
		}
		Pur = Pur-&gt;next;
	}
	return NULL;
}
</code></pre> 
<p>双链表查找输出：</p> 
<p><img alt="" height="374" src="https://images2.imgbox.com/1f/8c/AZHR4Qn1_o.png" width="965"></p> 
<h6>在指定位置之后插入数据：</h6> 
<pre><code>void LTInsert(DL* pos, LTDataType x)
{
	assert(pos);
	DL* Newnode = DLTBuyNode(x);
	//依然是先修改新节点的指向
	Newnode-&gt;next = pos-&gt;next;
	Newnode-&gt;prev = pos;

	//不能先改变pos-&gt;next的指向因为修改了就找不到pos后面的节点
	//所以指向先改变pos后面节点的指向然后再改变pos的指向
	pos-&gt;next-&gt;prev = Newnode;
	pos-&gt;next = Newnode;
	
}</code></pre> 
<p>在指定位置之后插入数据输出：</p> 
<p><img alt="" height="155" src="https://images2.imgbox.com/2e/f0/0ydXi43w_o.png" width="1000"></p> 
<h6 id="%E5%88%A0%E9%99%A4pos%E4%BD%8D%E7%BD%AE%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9A">删除pos位置的数据：</h6> 
<pre><code>void LTErase(DL* pos)
{
	assert(pos);
	//先改变pos前面的节点那就找不到pos后面的节点，所以只能先改变后面再改变前面
	pos-&gt;next-&gt;prev = pos-&gt;prev;
	pos-&gt;prev-&gt;next = pos-&gt;next;
}</code></pre> 
<p>删除pos位置的数据输出：</p> 
<p><img alt="" height="161" src="https://images2.imgbox.com/f7/ed/GUPrlsxv_o.png" width="796"></p> 
<h3 id="%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%9A"><strong>链表与顺序表的比较：</strong></h3> 
<p><strong>1.结构：</strong><br><br> 链表<strong>:</strong> 链表由一系列节点组成，每个节点包含数据元素和指向下一个节点的指针。节点之间的连接是通过指针实现的，因此链表是一种<span style="color:#fe2c24;">非连续的存储结构</span>。<br><br> 顺序表<strong>：</strong>顺序表将元素存储在连续的内存空间中，每个元素占用一个固定大小的单元。元素之间的访问通过索引实现，因此顺序表是一种<span style="color:#fe2c24;">连续的存储结构</span>。</p> 
<p><strong>2.逻辑结构与物理结构：</strong><br><br> 采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻。而采用链式存储时，逻辑上相邻的元素，物理存储位置不一定相邻，对应的逻辑关系时通过指针链接来表示的。</p> 
<p><strong>3.遍历、插入、删除操作：</strong></p> 
<p>插入：在链表中插入新元素，需要修改相邻节点的指针以保持链表的顺序。在顺序表中插入新元素，如果空间不足则需要重新分配内存或移动现有元素。<br><br> 删除：在链表中删除元素，需要修改相邻节点的指针以跳过被删除的元素。在顺序表中删除元素，需要将被删除元素后面的元素向前移动一个位置。<br><br> 遍历<strong>: </strong>在链表中遍历元素，需要逐个遍历节点并访问数据元素。在顺序表中遍历元素，可以使用循环访问每个元素</p> 
<p><strong>4.应用：</strong></p> 
<p>链表<strong>:</strong> 适用于需要频繁插入和删除操作的情景，因为链表的插入和删除操作效率较高，且不需要预先分配固定数量的内存空间。例如，缓存实现、栈和队列的底层实现等。</p> 
<p>顺序表<strong>:</strong> 适用于需要随机访问数据的情景，因为顺序表的随机访问效率较高，可以直接通过索引访问任意位置的元素。例如，数组的底层实现、符号表等。</p> 
<h3 id="%E6%80%BB%E7%BB%93%EF%BC%9A"><strong>总结：</strong></h3> 
<p>在选择数据结构时，需要根据具体应用场景权衡利弊。如果需要频繁插入和删除操作，并且对随机访问性能要求不高，则链表是一个不错的选择。如果需要随机访问数据，并且插入和删除操作不频繁，则顺序表是一个更好的选择。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bcbcc17429eb8ab2af78e6feba81b03b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">1. MySQL 5.7安装部署</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b1b55e5a982ca61cb7439515840cd9cb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【MySQL数据库】详解数据库审核工具SQLE的部署及接口调用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>