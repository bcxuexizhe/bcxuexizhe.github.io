<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>（2020|ICML PMLR，线性 Transformer，核函数，RNN）Transformer 是 RNN - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/07037ddd9a417204f93398e6434d5140/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="（2020|ICML PMLR，线性 Transformer，核函数，RNN）Transformer 是 RNN">
  <meta property="og:description" content="Transformers are RNNs: Fast Autoregressive Transformers with Linear Attention
公众号：EDPJ（进 Q 交流群：922230617 或加 VX：CV_EDPJ 进 V 交流群）
目录
0. 摘要
3. 线性 Transformers
3.1. Transformer
3.2. 线性注意力机制
3.2.1. 特征映射与计算成本
3.3. 因果掩码
3.3.1. 梯度计算
3.3.2. 训练和推理
3.4. transformer 是 RNN
4. 实验
0. 摘要 Transformer 在多项任务中表现出色，但由于其对输入长度的二次复杂度，对于非常长的序列来说，速度极慢。为了解决这一限制，我们将自注意力表示为核特征映射（kernel feature maps）的线性点积，并利用矩阵乘积的结合性将复杂度从 O(N^2) 降低到 O(N)，其中 N 是序列长度。我们证明了这种表达方式允许一种迭代实现，大大加速了自回归 Transformer，并揭示了它们与递归神经网络的关系。我们的线性 Transformer 在性能上与普通 Transformer 相似，并且在非常长序列的自回归预测中速度快达 4000 倍。 3. 线性 Transformers 在本节中，我们提出了线性 Transformer。我们展示了将传统的 softmax 注意力机制改为基于特征映射的点积注意力，可以改善时间和内存复杂度，并且可以实现类似于 RNN 的线性时间序列生成模型。
3.1. Transformer 3.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-28T23:02:02+08:00">
    <meta property="article:modified_time" content="2024-05-28T23:02:02+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">（2020|ICML PMLR，线性 Transformer，核函数，RNN）Transformer 是 RNN</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><strong>Transformers are RNNs: Fast Autoregressive Transformers with Linear Attention</strong></p> 
<p style="text-align:center;"><strong>公众号：EDPJ（进 Q 交流群：922230617 或加 VX：CV_EDPJ 进 V 交流群）</strong></p> 
<p class="img-center"><img alt="" height="32" src="https://images2.imgbox.com/db/48/ifwd5kJX_o.png" width="684"></p> 
<p class="img-center"><img alt="" height="79" src="https://images2.imgbox.com/ff/76/TsCYlKCE_o.png" width="449"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="0.%20%E6%91%98%E8%A6%81-toc" style="margin-left:0px;"><a href="#0.%20%E6%91%98%E8%A6%81" rel="nofollow">0. 摘要</a></p> 
<p id="3.%20%E7%BA%BF%E6%80%A7%C2%A0Transformers-toc" style="margin-left:0px;"><a href="#3.%20%E7%BA%BF%E6%80%A7%C2%A0Transformers" rel="nofollow">3. 线性 Transformers</a></p> 
<p id="3.1.%20Transformer-toc" style="margin-left:40px;"><a href="#3.1.%20Transformer" rel="nofollow">3.1. Transformer</a></p> 
<p id="3.2.%20%E7%BA%BF%E6%80%A7%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6-toc" style="margin-left:40px;"><a href="#3.2.%20%E7%BA%BF%E6%80%A7%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6" rel="nofollow">3.2. 线性注意力机制</a></p> 
<p id="3.2.1.%20%E7%89%B9%E5%BE%81%E6%98%A0%E5%B0%84%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%88%90%E6%9C%AC-toc" style="margin-left:80px;"><a href="#3.2.1.%20%E7%89%B9%E5%BE%81%E6%98%A0%E5%B0%84%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%88%90%E6%9C%AC" rel="nofollow">3.2.1. 特征映射与计算成本</a></p> 
<p id="3.3.%20%E5%9B%A0%E6%9E%9C%E6%8E%A9%E7%A0%81-toc" style="margin-left:40px;"><a href="#3.3.%20%E5%9B%A0%E6%9E%9C%E6%8E%A9%E7%A0%81" rel="nofollow">3.3. 因果掩码</a></p> 
<p id="3.3.1.%20%E6%A2%AF%E5%BA%A6%E8%AE%A1%E7%AE%97-toc" style="margin-left:80px;"><a href="#3.3.1.%20%E6%A2%AF%E5%BA%A6%E8%AE%A1%E7%AE%97" rel="nofollow">3.3.1. 梯度计算</a></p> 
<p id="3.3.2.%20%E8%AE%AD%E7%BB%83%E5%92%8C%E6%8E%A8%E7%90%86-toc" style="margin-left:80px;"><a href="#3.3.2.%20%E8%AE%AD%E7%BB%83%E5%92%8C%E6%8E%A8%E7%90%86" rel="nofollow">3.3.2. 训练和推理</a></p> 
<p id="3.4.%20transformer%20%E6%98%AF%20RNN-toc" style="margin-left:40px;"><a href="#3.4.%20transformer%20%E6%98%AF%20RNN" rel="nofollow">3.4. transformer 是 RNN</a></p> 
<p id="4.%20%E5%AE%9E%E9%AA%8C-toc" style="margin-left:0px;"><a href="#4.%20%E5%AE%9E%E9%AA%8C" rel="nofollow">4. 实验</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="0.%20%E6%91%98%E8%A6%81" style="background-color:transparent;">0. 摘要</h2> 
<p>Transformer 在多项任务中表现出色，但由于其对输入长度的二次复杂度，对于非常长的序列来说，速度极慢。为了解决这一限制，<strong>我们将自注意力表示为核特征映射（kernel feature maps）的线性点积，并利用矩阵乘积的结合性将复杂度从 O(N^2) 降低到 O(N)</strong>，其中 N 是序列长度。我们证明了这种表达方式允许一种迭代实现，大大加速了自回归 Transformer，并揭示了它们与递归神经网络的关系。我们的线性 Transformer 在性能上与普通 Transformer 相似，并且在非常长序列的自回归预测中速度快达 4000 倍。 </p> 
<h2 id="3.%20%E7%BA%BF%E6%80%A7%C2%A0Transformers">3. 线性 Transformers</h2> 
<p>在本节中，我们提出了线性 Transformer。我们展示了将传统的 softmax 注意力机制改为基于特征映射的点积注意力，可以改善时间和内存复杂度，并且可以实现类似于 RNN 的线性时间序列生成模型。</p> 
<h3 id="3.1.%20Transformer" style="background-color:transparent;">3.1. Transformer</h3> 
<p class="img-center"><img alt="" height="28" src="https://images2.imgbox.com/84/7b/JV6eOL2R_o.png" width="319"></p> 
<p class="img-center"><img alt="" height="140" src="https://images2.imgbox.com/11/cf/uanTxMtp_o.png" width="362"></p> 
<p class="img-center"><img alt="" height="64" src="https://images2.imgbox.com/c9/71/dBjDbadO_o.png" width="343"></p> 
<p class="img-center"><img alt="" height="36" src="https://images2.imgbox.com/12/52/0N4skvsj_o.png" width="183"></p> 
<h3 id="3.2.%20%E7%BA%BF%E6%80%A7%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6" style="background-color:transparent;">3.2. 线性注意力机制</h3> 
<p>公式 2 中的注意力定义是通用的，可以用于定义多种其他注意力实现，例如多项式注意力或 RBF 核注意力（Tsai等人，2019）。注意，为了使公式 3 定义的注意力函数有效，我们需要对 sim(·) 施加的唯一约束是非负性。这包括所有核函数 k(x, y): R^(2 × F) → R_+。</p> 
<p>给定具有特征表示 ϕ(x) 的核函数，我们可以将公式 2 重写为：</p> 
<p class="img-center"><img alt="" height="67" src="https://images2.imgbox.com/33/cb/kYKNmfDe_o.png" width="359"></p> 
<p>然后利用矩阵乘法的结合性进一步简化为：</p> 
<p class="img-center"><img alt="" height="62" src="https://images2.imgbox.com/14/f3/YJLWGPUT_o.png" width="361"></p> 
<p>当分子以向量形式书写时，上述公式更容易理解，如下所示：</p> 
<p class="img-center"><img alt="" height="37" src="https://images2.imgbox.com/2a/59/9LTpAybN_o.png" width="388"></p> 
<p>注意，特征映射 ϕ(·) 是逐行应用于矩阵 Q 和 K 的。</p> 
<p>从公式 2 可以看出，softmax 注意力的计算成本随 O(N^2) 缩放，其中 N 表示序列长度。内存需求也是如此，因为必须存储完整的注意力矩阵以计算查询、键和值的梯度。相比之下，我们在公式 5 中提出的<strong>线性 transformer </strong>具有 O(N) 的时间和内存复杂度，因为我们可以计算</p> 
<p class="img-center"><img alt="" height="30" src="https://images2.imgbox.com/72/65/dgTV1Agt_o.png" width="275"></p> 
<p>一次，并在每个查询中重复使用它们。</p> 
<h4 id="3.2.1.%20%E7%89%B9%E5%BE%81%E6%98%A0%E5%B0%84%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%88%90%E6%9C%AC">3.2.1. 特征映射与计算成本</h4> 
<p>对于 softmax 注意力，就乘法和加法的总成本而言，随着 O(N^2·max(D, M)) 缩放，其中 D 是查询和键的维度，M 是值的维度。相反，对于线性注意力，我们首先计算维度为 C 的特征映射。随后，计算新值需要 O(NCM) 次加法和乘法。</p> 
<p>上述分析未考虑核函数和特征函数的选择。需要注意的是，对应于指数核的特征函数是无限维的，这使得精确 softmax 注意力的线性化不可行。另一方面，例如多项式核具有精确的有限维特征映射，并且已证明与指数或 RBF 核（Tsai等人，2019）同样有效。线性化多项式 transformer 的计算成本为 O(N·D^2·M)。当 N &gt; D^2 时，这使得计算复杂度更具优势。实际上，由于我们希望能够处理成千上万元素的序列，这一情况是成立的。</p> 
<p>对于我们的实验，处理较小的序列，我们采用了一个结果为正相似函数的特征映射，如下定义：</p> 
<p class="img-center"><img alt="" height="25" src="https://images2.imgbox.com/5e/27/ZCB4faSQ_o.png" width="300"></p> 
<p>其中 elu(·) 表示指数线性单元（Clevert等人，2015）的激活函数。我们更喜欢 elu(·) 而不是relu(·)，以避免在 x 为负时将梯度设置为 0。这种特征映射导致的注意力函数需要 O(NDM) 次乘法和加法。在我们的实验部分，我们展示了公式 7 的特征映射在性能上与完整 transformer 相当，同时显著减少了计算和内存需求。</p> 
<h3 id="3.3.%20%E5%9B%A0%E6%9E%9C%E6%8E%A9%E7%A0%81">3.3. 因果掩码</h3> 
<p>transformer  架构可以通过掩蔽（masking）注意力计算来高效地训练自回归模型，使得第 i 个位置只能被第 j 个位置影响当且仅当 j ≤ i，即一个位置不能被后续位置影响。形式上，这种因果掩码将公式 3 修改如下：</p> 
<p class="img-center"><img alt="" height="62" src="https://images2.imgbox.com/ce/b6/BUiGVHfW_o.png" width="340"></p> 
<p>按照3.2节的推理，我们如下所述对掩码注意力进行线性化：</p> 
<p class="img-center"><img alt="" height="62" src="https://images2.imgbox.com/8d/15/4G4Sh6zm_o.png" width="353"></p> 
<p>通过引入 Si 和 Zi 如下所示：</p> 
<p class="img-center"><img alt="" height="133" src="https://images2.imgbox.com/14/c8/OtGvQtPm_o.png" width="305"></p> 
<p>我们可以将公式 9 简化为：</p> 
<p class="img-center"><img alt="" height="58" src="https://images2.imgbox.com/a3/a4/GIHd9Ncd_o.png" width="299"></p> 
<p>注意，Si 和 Zi 可以从 S_(i-1) 和 Z_(i-1) 在固定时间内计算得出，因此使得具有因果掩码的线性 transformer 的计算复杂度相对于序列长度为线性。</p> 
<h4 id="3.3.1.%20%E6%A2%AF%E5%BA%A6%E8%AE%A1%E7%AE%97">3.3.1. 梯度计算</h4> 
<p>在任何深度学习框架中，公式 12 的朴素实现需要存储所有中间值 Si，以计算梯度。这会增加max(D, M) 倍的内存消耗，从而阻碍因果线性注意力在更长序列或更深模型中的应用。为了解决这个问题，我们将公式 9 中的分子（numerator）的梯度导出为累积和。这使我们能够在线性时间和固定内存中计算因果线性注意力的前向和后向传播。详细推导见附录材料。</p> 
<p>给定分子 ¯V_i 和标量损失函数相对于分子的梯度</p> 
<p class="img-center"><img alt="" height="26" src="https://images2.imgbox.com/8e/c2/NFJrkZJJ_o.png" width="49"></p> 
<p>推导可得：</p> 
<p class="img-center"><img alt="" height="233" src="https://images2.imgbox.com/ab/ad/MR7DHItY_o.png" width="426"></p> 
<p>累计和项在公式 9 和 13-15 中以线性时间计算，并且相对于序列长度需要常量内存。这导致的算法在给定维度为 C 的特征映射下，其计算复杂度为 O(NCM)，内存复杂度为 O(N·max (C, M))。算法 1 是分子部分前向和后向传播的伪代码实现。</p> 
<p class="img-center"><img alt="" height="632" src="https://images2.imgbox.com/a1/98/6XsUHsTF_o.png" width="451"></p> 
<h4 id="3.3.2.%20%E8%AE%AD%E7%BB%83%E5%92%8C%E6%8E%A8%E7%90%86" style="background-color:transparent;">3.3.2. 训练和推理</h4> 
<p>在训练自回归 transformer 模型时，可以使用完整的真实序列。这使得公式 1 中的函数 φ(·) 和注意力计算都可以进行分层并行化。因此，transformer 比 RNN 更高效地进行训练。然而，在推理过程中，时间步 i 的输出是时间步 i + 1 的输入。这使得自回归模型无法并行化。此外，transformer 每个时间步的成本不是常量，而是随着当前序列长度的平方增长，因为必须为所有先前的时间步计算注意力。</p> 
<p>我们提出的线性 transformer 模型结合了这两者的优点。在训练时，计算可以并行化并充分利用 GPU 或其他加速器。在推理时，我们模型的每次预测在时间和内存上的成本是常量的。这意味着我们可以简单地将</p> 
<p class="img-center"><img alt="" height="26" src="https://images2.imgbox.com/51/df/wU6XzMXp_o.png" width="86"></p> 
<p>矩阵存储为内部状态，并在每个时间步像递归神经网络一样更新它。这使得推理速度比其他 transformer 模型快数千倍。</p> 
<h3 id="3.4.%20transformer%20%E6%98%AF%20RNN">3.4. transformer 是 RNN</h3> 
<p>在文献中，transformer 模型被认为是一种与递归神经网络（RNN）根本不同的方法。然而，从 3.3 节中的因果掩码公式和前一节的讨论可以看出，任何具有因果掩码的 transformer 层都可以被表示为一种模型，该模型在给定输入后修改内部状态，然后预测输出，即 RNN。注意，与通用变压器（Universal Transformers）（Dehghani等人，2018）不同，我们考虑的是时间上的递归，而不是深度上的递归。</p> 
<p>在以下公式中，我们将公式 1 的 Transformer 层形式化为 RNN。所得的 RNN 有两个隐藏状态，即注意力记忆 s 和归一化记忆 z。我们用下标表示递归中的时间步。</p> 
<p class="img-center"><img alt="" height="177" src="https://images2.imgbox.com/0b/1a/2lh7pPxv_o.png" width="360"></p> 
<p>在上述公式中，x_i 表示特定 Transformer 层的第 i 个输入，y_i 表示第 i 个输出。需要注意的是，我们的公式对特征函数没有任何约束，因此可以用于表示任何 Transformer 模型，理论上甚至包括使用 softmax 注意力的模型。这一公式是更好理解 Transformer 与流行的 RNN（Hochreiter &amp; Schmidhuber, 1997）及其存储和检索信息过程之间关系的第一步。 </p> 
<h2 id="4.%20%E5%AE%9E%E9%AA%8C" style="background-color:transparent;">4. 实验</h2> 
<p class="img-center"><img alt="" height="336" src="https://images2.imgbox.com/c2/e6/FyTeinsK_o.png" width="931"></p> 
<p class="img-center"><img alt="" height="358" src="https://images2.imgbox.com/b6/9f/gH3gJl8J_o.png" width="450"></p> 
<p class="img-center"><img alt="" height="268" src="https://images2.imgbox.com/b6/e9/wpE6DlTE_o.png" width="450"></p> 
<p class="img-center"><img alt="" height="289" src="https://images2.imgbox.com/3f/9d/uKvUH6fw_o.png" width="452"></p> 
<p class="img-center"><img alt="" height="842" src="https://images2.imgbox.com/91/6a/r9BYsNOK_o.png" width="453"></p> 
<p class="img-center"><img alt="" height="549" src="https://images2.imgbox.com/23/6f/ULV0EK2C_o.png" width="450"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0369de4e97085858045cb10208a09dd4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">《TCP/IP网络编程》（第十二章）I/O复用（1）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8c96b4735a1a3be6a9324675d7f88b32/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java特性之设计模式【备忘录模式】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>