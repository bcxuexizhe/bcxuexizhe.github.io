<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 【数据结构】 优先级队列（PriorityQueue）和堆（Heap）【神装】 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/7832b7e91dad8f709eecf8bf8bc54c5b/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Java 【数据结构】 优先级队列（PriorityQueue）和堆（Heap）【神装】">
  <meta property="og:description" content="登神长阶
第六神装 优先级队列 PriorityQueue
第七神装 堆 Heap 目录
📔一.认识优先级队列（PriorityQueue）
📕1.概念
📖2.特点
📗二.认识堆（Heap） 📘1.概念
📙2.特点 📚三.优先级队列的模拟实现
📓1.堆的创建
📒2.建堆的时间复杂度
📃3.堆的插入和删除
📜3.1插入
📄 3.2删除
📰四.PriorityQueue接口介绍
🗞️1.基本使用
📑2.注意事项
🔖五.总结与反思
📔一.认识优先级队列（PriorityQueue） 📕1.概念 前面介绍过队列，在 Java 中，队列（Queue）是一种先进先出（FIFO）的数据结构，用于存储元素。队列在 java.util 包中有多种实现，如 LinkedList、ArrayDeque 和 PriorityQueue。只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先进先出FIFO(First In First Out) 入队列：进行插入操作的一端称为队尾（Tail/Rear） 出队列：进行删除操作的一端称为队头（Head/Front）
Java中的优先级队列（PriorityQueue）是一种数据结构，它基于优先级的概念来确定元素的顺序。在优先级队列中，元素按照优先级被逐个访问和处理，具有较高优先级的元素会被优先处理。
📖2.特点 元素的排序： 优先级队列中的元素根据其优先级进行排序。具体来说，元素必须是可比较的，或者队列需要根据给定的比较器来确定优先级。
内部实现： Java中的优先级队列通常使用堆（heap）来实现。堆是一种特殊的树形数据结构，这也是本篇博客把二者放在一起的原因，下文会做详细介绍。
插入和删除操作： 优先级队列支持插入和删除操作。插入操作将元素插入到队列中，并根据其优先级进行调整；删除操作移除并返回队列中优先级最高的元素。
访问操作： 优先级队列通常支持访问具有最高优先级的元素，但不一定支持随机访问其他元素。在Java中，可以使用 peek() 方法来访问队首元素，该方法返回队列中优先级最高的元素但不移除它。
线程安全性： Java中的优先级队列实现通常不是线程安全的。如果需要在多线程环境中使用优先级队列，可以考虑使用 PriorityBlockingQueue 类，它是 BlockingQueue 接口的一个实现，提供了线程安全的优先级队列功能。
综上所述，Java中的优先级队列是一种重要的数据结构，适用于需要按照优先级处理元素的场景，例如任务调度、事件处理等。
📗二.认识堆（Heap） 📘1.概念 Java中的堆（Heap）是一种特殊的树形数据结构，如果有一个关键码的集合K = {k0，k1， k2，…，kn-1}，把它的所有元素按完全二叉树的顺序存储方式存储 在一个一维数组中，并满足：Ki &lt;= K2i&#43;1 且 Ki&lt;= K2i&#43;2 (Ki &gt;= K2i&#43;1 且 Ki &gt;= K2i&#43;2) i = 0，1，2…，则称为小堆(或大堆)。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。 📙2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-01T10:00:00+08:00">
    <meta property="article:modified_time" content="2024-05-01T10:00:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 【数据结构】 优先级队列（PriorityQueue）和堆（Heap）【神装】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" height="140" src="https://images2.imgbox.com/fb/71/L5QYhUWt_o.png" width="407"></p> 
<p class="img-center"><img alt="" height="80" src="https://images2.imgbox.com/00/e9/ANdJ038i_o.png" width="640"></p> 
<p> </p> 
<p style="text-align:center;"> <strong>登神长阶</strong></p> 
<p style="text-align:center;"><strong> 第六神装 优先级队列 PriorityQueue</strong></p> 
<p style="text-align:center;"><strong>第七神装  堆 Heap</strong> </p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%F0%9F%93%94%E4%B8%80.%E8%AE%A4%E8%AF%86%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%EF%BC%88PriorityQueue%EF%BC%89-toc" style="margin-left:0px;"><a href="#%F0%9F%93%94%E4%B8%80.%E8%AE%A4%E8%AF%86%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%EF%BC%88PriorityQueue%EF%BC%89" rel="nofollow">📔一.认识优先级队列（PriorityQueue）</a></p> 
<p id="%F0%9F%93%951.%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%F0%9F%93%951.%E6%A6%82%E5%BF%B5" rel="nofollow">📕1.概念</a></p> 
<p id="%F0%9F%93%962.%E7%89%B9%E7%82%B9-toc" style="margin-left:40px;"><a href="#%F0%9F%93%962.%E7%89%B9%E7%82%B9" rel="nofollow">📖2.特点</a></p> 
<p id="%F0%9F%93%97%E4%BA%8C.%E8%AE%A4%E8%AF%86%E5%A0%86%EF%BC%88Heap%EF%BC%89%C2%A0-toc" style="margin-left:0px;"><a href="#%F0%9F%93%97%E4%BA%8C.%E8%AE%A4%E8%AF%86%E5%A0%86%EF%BC%88Heap%EF%BC%89%C2%A0" rel="nofollow">📗二.认识堆（Heap） </a></p> 
<p id="%F0%9F%93%981.%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%F0%9F%93%981.%E6%A6%82%E5%BF%B5" rel="nofollow">📘1.概念</a></p> 
<p id="%F0%9F%93%992.%E7%89%B9%E7%82%B9%C2%A0-toc" style="margin-left:40px;"><a href="#%F0%9F%93%992.%E7%89%B9%E7%82%B9%C2%A0" rel="nofollow">📙2.特点 </a></p> 
<p id="%F0%9F%93%9A%E4%B8%89.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%F0%9F%93%9A%E4%B8%89.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow">📚三.优先级队列的模拟实现</a></p> 
<p id="%F0%9F%93%931.%E5%A0%86%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:40px;"><a href="#%F0%9F%93%931.%E5%A0%86%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">📓1.堆的创建</a></p> 
<p id="%F0%9F%93%922.%E5%BB%BA%E5%A0%86%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:40px;"><a href="#%F0%9F%93%922.%E5%BB%BA%E5%A0%86%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow">📒2.建堆的时间复杂度</a></p> 
<p id="%F0%9F%93%833.%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4-toc" style="margin-left:40px;"><a href="#%F0%9F%93%833.%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4" rel="nofollow">📃3.堆的插入和删除</a></p> 
<p id="%F0%9F%93%9C3.1%E6%8F%92%E5%85%A5-toc" style="margin-left:80px;"><a href="#%F0%9F%93%9C3.1%E6%8F%92%E5%85%A5" rel="nofollow">📜3.1插入</a></p> 
<p id="%F0%9F%93%84%C2%A03.2%E5%88%A0%E9%99%A4-toc" style="margin-left:80px;"><a href="#%F0%9F%93%84%C2%A03.2%E5%88%A0%E9%99%A4" rel="nofollow">📄 3.2删除</a></p> 
<p id="%F0%9F%93%B0%E5%9B%9B.PriorityQueue%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#%F0%9F%93%B0%E5%9B%9B.PriorityQueue%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D" rel="nofollow">📰四.PriorityQueue接口介绍</a></p> 
<p id="%F0%9F%97%9E%EF%B8%8F1.%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#%F0%9F%97%9E%EF%B8%8F1.%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8" rel="nofollow">🗞️1.基本使用</a></p> 
<p id="%F0%9F%93%912.%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-toc" style="margin-left:40px;"><a href="#%F0%9F%93%912.%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" rel="nofollow">📑2.注意事项</a></p> 
<p id="%F0%9F%94%96%E4%BA%94.%E6%80%BB%E7%BB%93%E4%B8%8E%E5%8F%8D%E6%80%9D-toc" style="margin-left:0px;"><a href="#%F0%9F%94%96%E4%BA%94.%E6%80%BB%E7%BB%93%E4%B8%8E%E5%8F%8D%E6%80%9D" rel="nofollow">🔖五.总结与反思</a></p> 
<hr> 
<h2 id="%F0%9F%93%94%E4%B8%80.%E8%AE%A4%E8%AF%86%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%EF%BC%88PriorityQueue%EF%BC%89" style="background-color:transparent;">📔一.认识优先级队列（PriorityQueue）</h2> 
<h3 id="%F0%9F%93%951.%E6%A6%82%E5%BF%B5">📕1.概念</h3> 
<div> 
 <p><span style="color:#333333;">        前面介绍过队列，</span>在 Java 中，队列（Queue）是一种先进先出（FIFO）的数据结构，用于存储元素。队列在 java.util 包中有多种实现，如 LinkedList、ArrayDeque 和 PriorityQueue。只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先进先出FIFO(First In First Out) 入队列：进行插入操作的一端称为队尾（Tail/Rear） 出队列：进行删除操作的一端称为队头（Head/Front）</p> 
 <p><strong>        Java中的优先级队列（PriorityQueue）是一种数据结构，它基于优先级的概念来确定元素的顺序。在优先级队列中，元素按照优先级被逐个访问和处理，具有较高优先级的元素会被优先处理。</strong></p> 
 <p class="img-center"><img alt="" height="292" src="https://images2.imgbox.com/64/cb/8ZVGO7zR_o.png" width="1149"></p> 
</div> 
<h3 id="%F0%9F%93%962.%E7%89%B9%E7%82%B9" style="background-color:transparent;">📖2.特点</h3> 
<ul><li> <p><strong>元素的排序：</strong> 优先级队列中的元素根据其优先级进行排序。具体来说，元素必须是可比较的，或者队列需要根据给定的<strong>比较器</strong>来确定优先级。</p> </li><li> <p><strong>内部实现： Java中的优先级队列通常使用堆（heap）</strong>来实现。堆是一种特殊的树形数据结构，这也是本篇博客把二者放在一起的原因，下文会做详细介绍。</p> </li><li> <p><strong>插入和删除操作：</strong> 优先级队列支持插入和删除操作。插入操作将元素插入到队列中，并根据其优先级进行调整；删除操作移除并返回队列中优先级最高的元素。</p> </li><li> <p><strong>访问操作：</strong> 优先级队列通常支持访问具有最高优先级的元素，但不一定支持随机访问其他元素。在Java中，可以使用 <code>peek()</code> 方法来访问队首元素，该方法返回队列中优先级最高的元素但不移除它。</p> </li><li> <p><strong>线程安全性：</strong> Java中的优先级队列实现通常<strong>不是</strong>线程安全的。如果需要在多线程环境中使用优先级队列，<strong>可以考虑使用 <code>PriorityBlockingQueue</code> 类，它是 <code>BlockingQueue</code> 接口的一个实现，提供了线程安全的优先级队列功能。</strong></p> </li></ul> 
<p>综上所述，Java中的优先级队列是一种重要的数据结构，适用于需要按照优先级处理元素的场景，例如任务调度、事件处理等。</p> 
<h2 id="%F0%9F%93%97%E4%BA%8C.%E8%AE%A4%E8%AF%86%E5%A0%86%EF%BC%88Heap%EF%BC%89%C2%A0" style="background-color:transparent;">📗二.认识堆（Heap） </h2> 
<h3 id="%F0%9F%93%981.%E6%A6%82%E5%BF%B5">📘1.概念</h3> 
<p>        Java中的堆（Heap）是一种特殊的树形数据结构，<span style="color:#333333;">如果有一个关键码的集合</span><span style="color:#333333;">K = {k0</span><span style="color:#333333;">，</span><span style="color:#333333;">k1</span><span style="color:#333333;">，</span><span style="color:#333333;"> k2</span><span style="color:#333333;">，</span><span style="color:#333333;">…</span><span style="color:#333333;">，</span><span style="color:#333333;">kn-1}</span><span style="color:#333333;">，把它的所有元素</span><span style="color:#333333;">按完全二叉树的顺序存储方式存储 在一个一维数组中，并满足：</span><span style="color:#333333;">Ki &lt;= K2i+1 </span><span style="color:#333333;">且</span><span style="color:#333333;"> Ki&lt;= K2i+2</span><span style="color:#333333;"> (Ki &gt;= K2i+1 </span><span style="color:#333333;">且</span><span style="color:#333333;"> Ki &gt;= K2i+2) i = 0</span><span style="color:#333333;">，</span><span style="color:#333333;">1</span><span style="color:#333333;">，</span><span style="color:#333333;">2…</span><span style="color:#333333;">，则</span><span style="color:#333333;">称为小堆</span><span style="color:#333333;">(</span><span style="color:#333333;">或大堆)</span><span style="color:#333333;">。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。 </span></p> 
<p class="img-center"><img alt="" height="368" src="https://images2.imgbox.com/cb/06/C6yPNbEI_o.png" width="418"></p> 
<h3 id="%F0%9F%93%992.%E7%89%B9%E7%82%B9%C2%A0" style="background-color:transparent;">📙2.特点 </h3> 
<ul><li> <p><strong>完全二叉树结构：</strong> 堆通常是一棵完全二叉树，即除了最底层，其他层都是满的，并且最底层从左向右填充。</p> </li><li> <p><strong>最大堆和最小堆：</strong> 堆可以分为最大堆（Max Heap）和最小堆（Min Heap）两种类型。</p> 
  <ul><li>在最大堆中，父节点的值大于等于其子节点的值，因此根节点是最大值。</li><li>在最小堆中，父节点的值小于等于其子节点的值，因此根节点是最小值。</li></ul></li><li> <p><strong>堆的性质：</strong> 堆的一个重要性质是堆中的每个节点都满足堆的性质，即父节点的值要么大于等于/小于等于其子节点的值，这取决于是最大堆还是最小堆。</p> </li><li> <p><strong>插入操作：</strong> 向堆中插入元素时，通常会将元素放置在堆的末尾，然后通过上移操作（向上调整）将元素移到合适的位置，以满足堆的性质。</p> </li><li> <p><strong>删除操作：</strong> 从堆中删除元素时，通常会删除根节点，并将堆的最后一个元素移动到根节点位置，然后通过下移操作（向下调整）将元素移到合适的位置，以满足堆的性质。</p> </li><li> <p><strong>堆的实现：</strong> 在Java中，堆通常通过数组来实现。数组的每个元素对应堆中的一个节点，通过索引可以方便地找到节点的父节点和子节点。</p> </li><li> <p><strong>应用：</strong> 堆在计算机科学中有许多重要的应用，例如优先级队列、堆排序、最小（大）k个元素问题等。其中，优先级队列是最常见的应用之一，可以使用堆来实现高效的优先级队列。</p> </li></ul> 
<p>总之，堆是一种重要的数据结构，具有高效的插入、删除和访问操作，适用于需要快速找到最大值或最小值的场景。</p> 
<h2 id="%F0%9F%93%9A%E4%B8%89.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" style="background-color:transparent;">📚三.优先级队列的模拟实现</h2> 
<h3 id="%F0%9F%93%931.%E5%A0%86%E7%9A%84%E5%88%9B%E5%BB%BA" style="background-color:transparent;">📓1.堆的创建</h3> 
<p>        根据初步认识，我们知道堆是一颗完全二叉树：</p> 
<p class="img-center"><img alt="" height="627" src="https://images2.imgbox.com/b8/32/7THRkRa8_o.png" width="1200"></p> 
<p>因此，会出现：</p> 
<p><span style="color:#333333;"><strong>根节点的左右子树已经完全满足堆的性质，</strong>此时只需要将根节点向下调整即可，以下为例：</span></p> 
<p class="img-center"><img alt="" height="362" src="https://images2.imgbox.com/aa/39/dysdn77f_o.png" width="549"></p> 
<p class="img-center"><img alt="" height="352" src="https://images2.imgbox.com/4c/b5/yFepLw7G_o.png" width="915"></p> 
<p><img alt="" height="343" src="https://images2.imgbox.com/21/85/A4o2IQVm_o.png" width="1200"> </p> 
<p> 基本思路为向下调整，代码如下：</p> 
<pre><code class="hljs"> public void shiftDown(int[] array, int parent) {
    // child先标记parent的左孩子，因为parent可能右左没有右
        int child = 2 * parent + 1;
        int size = array.length;
        while (child &lt; size) {
    // 如果右孩子存在，找到左右孩子中较小的孩子,用child进行标记
            if (child + 1 &lt; size &amp;&amp; array[child + 1] &lt; array[child]) {
                child += 1;
            }
    // 如果双亲比其最小的孩子还小，说明该结构已经满足堆的特性了
            if (array[parent] &lt;= array[child]) {
                break;
            } else {
    // 将双亲与较小的孩子交换
                int t = array[parent];
                array[parent] = array[child];
                array[child] = t;
    // parent中大的元素往下移动，可能会造成子树不满足堆的性质，因此需要继续向下调整
                parent = child;
                child = parent * 2 + 1;
            }
        }
    }</code></pre> 
<blockquote> 
 <div> 
  <span style="color:#333333;"><strong>注意：</strong>在调整以</span> 
  <span style="color:#333333;">parent</span> 
  <span style="color:#333333;">为根的二叉树时，必须要满足</span> 
  <span style="color:#333333;">parent</span> 
  <span style="color:#333333;">的左子树和右子树已经是堆了才可以向下调整。 </span> 
 </div> 
 <div> 
  <span style="color:#333333;"><strong>时间复杂度分析</strong>：</span> 
  <span style="color:#333333;">最坏的情况</span> 
  <span style="color:#333333;">即图示的情况，</span> 
  <span style="color:#333333;">从根一路比较到叶子，比较的次数为完全二叉树的高度，即时间复杂度为log2N</span> 
 </div> 
</blockquote> 
<p><span style="color:#333333;">在实际应用之中对于普通的序列，即根节点的左右子树不满足堆的特性，调整方法逻辑如下</span><img alt="" height="940" src="https://images2.imgbox.com/80/f5/6ZGMg53N_o.png" width="1200"><span style="color:#333333;"> </span> 代码要用到向下调整的代码：</p> 
<pre><code class="hljs">public static void createHeap(int[] array) {
    // 找倒数第一个非叶子节点，从该节点位置开始往前一直到根节点，遇到一个节点，应用向下调整
    int root = ((array.length-2)&gt;&gt;1);
    for (; root &gt;= 0; root--) {
        shiftDown(array, root);
    }
}</code></pre> 
<h3 id="%F0%9F%93%922.%E5%BB%BA%E5%A0%86%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" style="background-color:transparent;">📒2.建堆的时间复杂度</h3> 
<div> 
 <span style="color:#333333;">        因为堆是完全二叉树，而满二叉树也是完全二叉树，此处为了简化使用满二叉树来证明(时间复杂度本来看的就是近似值，多几个节点不影响最终结果)：此处要用到错位相减的思想：</span> 
 <img alt="" height="897" src="https://images2.imgbox.com/15/98/28W3GSw5_o.png" width="1200"> 
</div> 
<p> <span style="color:#333333;">因此：</span><span style="color:#333333;"><strong>建堆的时间复杂度为</strong></span><span style="color:#333333;"><strong>O(N)</strong></span><span style="color:#333333;">。</span></p> 
<h3 id="%F0%9F%93%833.%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span style="color:#333333;">📃3.堆的插入和删除</span></h3> 
<h4 id="%F0%9F%93%9C3.1%E6%8F%92%E5%85%A5"><span style="color:#333333;">📜3.1插入</span></h4> 
<div> 
 <span style="color:#333333;"><strong>堆的插入总共需要两个步骤</strong>： </span> 
</div> 
<ol><li><span style="color:#333333;">先将元素放入到底层空间中</span><span style="color:#333333;">(</span><span style="color:#333333;">注意：空间不够时需要扩容</span><span style="color:#333333;">) </span></li><li><span style="color:#333333;">将最后新插入的节点向上调整，直到满足堆的性质</span> <p class="img-center"><img alt="" height="466" src="https://images2.imgbox.com/17/a7/AwsyFRXv_o.png" width="1200"></p> </li></ol> 
<p>向上调整 </p> 
<pre><code class="hljs">public void shiftUp(int child) {
    // 找到child的双亲
        int parent = (child - 1) / 2;
        while (child &gt; 0) {
    // 如果双亲比孩子大，parent满足堆的性质，调整结束
            if (array[parent] &gt; array[child]) {
                break;
            }
            else{
    // 将双亲与孩子节点进行交换
                int t = array[parent];
                array[parent] = array[child];
                array[child] = t;
    // 小的元素向下移动，可能到值子树不满足对的性质，因此需要继续向上调增
                child = parent;
                parent = (child - 1) / 1;
            }
        }
    }</code></pre> 
<h4 id="%F0%9F%93%84%C2%A03.2%E5%88%A0%E9%99%A4" style="background-color:transparent;">📄 3.2删除</h4> 
<div> 
 <span style="color:#333333;"><strong>注意：堆的删除一定删除的是堆顶元素。</strong></span> 
</div> 
<ol><li><span style="color:#333333;">将堆顶元素对堆中最后一个元素交换 </span></li><li><span style="color:#333333;">将堆中有效数据个数减少一个 </span></li><li><span style="color:#333333;">对堆顶元素进行向下调整 </span></li></ol> 
<p class="img-center"><img alt="" height="631" src="https://images2.imgbox.com/5e/2f/kZbgocHo_o.png" width="1200"></p> 
<p> 要用到向上调整 </p> 
<pre><code class="hljs">public class MyPriorityQueue {
        // 演示作用，不再考虑扩容部分的代码
        private int[] array = new int[100];
        private int size = 0;
        public void offer(int e) {
            array[size++] = e;
            shiftUp(size - 1);
        }
        public int poll() {
            int oldValue = array[0];
            array[0] = array[--size];
            shiftDown(0);
            return oldValue;
        }
        public int peek() {
            return array[0];
        }
    }</code></pre> 
<h2 id="%F0%9F%93%B0%E5%9B%9B.PriorityQueue%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D" style="background-color:transparent;">📰四.<span style="color:#333333;"><strong>PriorityQueue接口介绍</strong></span></h2> 
<p></p> 
<div> 
 <span style="color:#333333;">Java</span> 
 <span style="color:#333333;">集合框架中提供了</span> 
 <span style="color:#333333;"><strong>PriorityQueue</strong></span> 
 <span style="color:#333333;">和</span> 
 <span style="color:#333333;"><strong>PriorityBlockingQueue</strong></span> 
 <span style="color:#333333;">两种类型的优先级队列，</span> 
 <span style="color:#333333;"><strong>PriorityQueue</strong></span> 
 <span style="color:#333333;"><strong>是线 </strong></span> 
</div> 
<div> 
 <span style="color:#333333;"><strong>程不安全的，</strong></span> 
 <span style="color:#333333;"><strong>PriorityBlockingQueue</strong></span> 
 <span style="color:#333333;"><strong>是线程安全的</strong></span> 
 <span style="color:#333333;">，本文主要介绍</span> 
 <span style="color:#333333;">PriorityQueue</span> 
 <span style="color:#333333;">。 </span> 
</div> 
<div> 
 <p class="img-center"><img alt="" height="585" src="https://images2.imgbox.com/27/e6/Q3g7brel_o.png" width="571"></p> 
 <h3 id="%F0%9F%97%9E%EF%B8%8F1.%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8" style="background-color:transparent;">🗞️1.基本使用</h3> 
 <table border="1" cellpadding="1" cellspacing="1" style="width:700px;"><tbody><tr><td style="width:314px;"> 
     <div style="text-align:center;"> 
      <span style="color:#333333;"><strong>构造方法</strong></span> 
     </div> </td><td style="text-align:center;width:384px;"><span style="color:#333333;"><strong>功能介绍</strong></span></td></tr><tr><td style="width:314px;"><span style="color:#333333;"><strong>PriorityQueue()</strong></span></td><td style="width:384px;"><span style="color:#333333;">创建一个空的优先级队列，默认容量是</span><span style="color:#333333;">11</span></td></tr><tr><td style="width:314px;"> 
     <div> 
      <span style="color:#333333;"><strong>PriorityQueue(int </strong></span> 
      <span style="color:#333333;"><strong>initialCapacity)</strong></span> 
     </div> </td><td style="width:384px;"> 
     <div> 
      <span style="color:#333333;">创建一个初始容量为</span> 
      <span style="color:#333333;">initialCapacity</span> 
      <span style="color:#333333;">的优先级队列，注意：initialCapacity不能小于</span> 
      <span style="color:#333333;">1</span> 
      <span style="color:#333333;">，否则会抛</span> 
      <span style="color:#333333;">IllegalArgumentException</span> 
      <span style="color:#333333;">异 </span> 
     </div> 
     <div> 
      <span style="color:#333333;">常</span> 
     </div> </td></tr><tr><td style="width:314px;"> 
     <div> 
      <span style="color:#333333;"><strong>PriorityQueue(Collection&lt;? </strong></span> 
      <span style="color:#333333;"><strong>extends E&gt; c)</strong></span> 
     </div> </td><td style="width:384px;"><span style="color:#333333;">用一个集合来创建优先级队列</span></td></tr></tbody></table> 
 <div> 
  <pre><code class="hljs"> static void TestPriorityQueue(){
    // 创建一个空的优先级队列，底层默认容量是11
        PriorityQueue&lt;Integer&gt; q1 = new PriorityQueue&lt;&gt;();
    // 创建一个空的优先级队列，底层的容量为initialCapacity
        PriorityQueue&lt;Integer&gt; q2 = new PriorityQueue&lt;&gt;(100);
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        list.add(4);
        list.add(3);
        list.add(2);
        list.add(1);
    // 用ArrayList对象来构造一个优先级队列的对象
    // q3中已经包含了三个元素
        PriorityQueue&lt;Integer&gt; q3 = new PriorityQueue&lt;&gt;(list);
        System.out.println(q3.size());
        System.out.println(q3.peek());
    }</code></pre> 
 </div> 
 <div> 
  <span style="color:#333333;">注意：默认情况下，</span> 
  <span style="color:#333333;">PriorityQueue</span> 
  <span style="color:#333333;">队列是小堆，如果需要大堆需要用户提供比较器 </span> 
 </div> 
 <div> 
  <pre><code class="hljs"> public class TestPriorityQueue {
        public static void main(String[] args) {
            PriorityQueue&lt;Integer&gt; p = new PriorityQueue&lt;&gt;(new IntCmp());
            p.offer(4);
            p.offer(3);
            p.offer(2);
            p.offer(1);
            p.offer(5);
            System.out.println(p.peek());
        }
    }</code></pre> 
 </div> 
 <div>
   常用的操作如下： 
 </div> 
 <div> 
  <table border="1" cellpadding="1" cellspacing="1" style="width:700px;"><tbody><tr><td style="width:222px;"> 
      <div style="text-align:center;"> 
       <span style="color:#333333;"><strong>函数名 </strong></span> 
      </div> </td><td style="width:476px;"> 
      <div style="text-align:center;"> 
       <span style="color:#333333;"><strong>功能介绍 </strong></span> 
      </div> </td></tr><tr><td style="width:222px;"> 
      <div> 
       <span style="color:#333333;">boolean offer(E e) </span> 
      </div> </td><td style="width:476px;"> 
      <div> 
       <span style="color:#333333;">插入元素</span> 
       <span style="color:#333333;">e</span> 
       <span style="color:#333333;">，插入成功返回</span> 
       <span style="color:#333333;">true</span> 
       <span style="color:#333333;">，如果</span> 
       <span style="color:#333333;">e</span> 
       <span style="color:#333333;">对象为空，抛出</span> 
       <span style="color:#333333;">NullPointerException</span> 
       <span style="color:#333333;">异常，时 </span> 
      </div> 
      <div> 
       <span style="color:#333333;">间复杂度 log2N，注意：空间不够时候会进行扩容</span> 
      </div> </td></tr><tr><td style="width:222px;"> 
      <div> 
       <span style="color:#333333;">E peek() </span> 
      </div> </td><td style="width:476px;"> 
      <div> 
       <span style="color:#333333;">获取优先级最高的元素，如果优先级队列为空，返回</span> 
       <span style="color:#333333;">null</span> 
      </div> </td></tr><tr><td style="width:222px;"> 
      <div> 
       <span style="color:#333333;">E poll() </span> 
      </div> </td><td style="width:476px;"> 
      <div> 
       <span style="color:#333333;">移除优先级最高的元素并返回，如果优先级队列为空，返回</span> 
       <span style="color:#333333;">null</span> 
      </div> </td></tr><tr><td style="width:222px;"> 
      <div> 
       <span style="color:#333333;">int size() </span> 
      </div> </td><td style="width:476px;"> 
      <div> 
       <span style="color:#333333;">获取有效元素的个数 </span> 
      </div> </td></tr><tr><td style="width:222px;"> 
      <div> 
       <span style="color:#333333;">void clear()</span> 
      </div> </td><td style="width:476px;"> 
      <div> 
       <span style="color:#333333;">清空</span> 
      </div> </td></tr><tr><td style="width:222px;"> 
      <div> 
       <span style="color:#333333;">boolean isEmpty()</span> 
      </div> </td><td style="width:476px;"> 
      <div> 
       <span style="color:#333333;">检测优先级队列是否为空，空返回</span> 
       <span style="color:#333333;">true</span> 
      </div> </td></tr></tbody></table> 
  <pre><code class="hljs">  static void TestPriorityQueue2(){
        int[] arr = {4,1,9,2,8,0,7,3,6,5};
    // 一般在创建优先级队列对象时，如果知道元素个数，建议就直接将底层容量给好
    // 否则在插入时需要不多的扩容
    // 扩容机制：开辟更大的空间，拷贝元素，这样效率会比较低
        PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;(arr.length);
        for (int e: arr) {
            q.offer(e);
        }
        System.out.println(q.size()); // 打印优先级队列中有效元素个数
        System.out.println(q.peek()); // 获取优先级最高的元素
    // 从优先级队列中删除两个元素之和，再次获取优先级最高的元素
        q.poll();
        q.poll();
        System.out.println(q.size()); // 打印优先级队列中有效元素个数
        System.out.println(q.peek()); // 获取优先级最高的元素
        q.offer(0);
        System.out.println(q.peek()); // 获取优先级最高的元素
    // 将优先级队列中的有效元素删除掉，检测其是否为空
        q.clear();
        if(q.isEmpty()){
            System.out.println("优先级队列已经为空!!!");
        }
        else{
            System.out.println("优先级队列不为空");
        }
    }</code></pre> 
  <h3 id="%F0%9F%93%912.%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" style="background-color:transparent;">📑2.注意事项</h3> 
 </div> 
 <ul><li><span style="color:#333333;">使用时必须导入</span><span style="color:#333333;">PriorityQueue</span><span style="color:#333333;">所在的包，即： </span></li><li><span style="color:#333333;">PriorityQueue</span><span style="color:#333333;">中放置的</span><span style="color:#333333;"><strong>元素必须要能够比较大小，不能插入无法比较大小的对象，否则会抛出</strong></span><span style="color:#333333;"><strong>ClassCastException</strong></span><span style="color:#333333;"><strong>异常 </strong></span></li><li><span style="color:#333333;">不能</span><span style="color:#333333;"><strong>插入</strong></span><span style="color:#333333;"><strong>null</strong></span><span style="color:#333333;"><strong>对象，否则会抛出</strong></span><span style="color:#333333;"><strong>NullPointerException </strong></span></li><li><span style="color:#333333;"><strong>没有容量限制，可以插入任意多个元素，其内部可以自动扩容 </strong></span></li><li><span style="color:#333333;"><strong>插入和删除元素的时间复杂度为 </strong></span></li><li><span style="color:#333333;"><strong>PriorityQueue</strong></span><span style="color:#333333;"><strong>底层使用了堆数据结构 </strong></span></li><li><span style="color:#333333;"><strong>PriorityQueue</strong></span><span style="color:#333333;"><strong>默认情况下是小堆</strong></span><span style="color:#333333;">---</span><span style="color:#333333;">即每次获取到的元素都是最小的元素</span></li></ul> 
 <h2 id="%F0%9F%94%96%E4%BA%94.%E6%80%BB%E7%BB%93%E4%B8%8E%E5%8F%8D%E6%80%9D"><span style="color:#333333;">🔖五.总结与反思</span></h2> 
 <blockquote> 
  <p>梦想只要能持久，就能成为现实。我们不就是生活在梦想中的吗？——丁尼生</p> 
 </blockquote> 
 <p>        在学习Java中的PriorityQueue和堆这一主题时，我掌握了如何使用PriorityQueue类来实现堆的基本操作，包括插入和删除。这些操作对于解决许多实际问题都非常有用，尤其是在需要高效管理元素优先级的情况下。</p> 
 <p>        插入操作是向堆中添加新元素的过程，它的基本思路是保持堆的性质不变。通过PriorityQueue的<code>add()</code>或<code>offer()</code>方法，我们可以很方便地实现插入操作。插入操作的关键在于保证插入元素后，堆仍然满足堆的性质，这需要进行必要的上浮操作。这种自动维护堆性质的特性使得插入操作非常高效且便捷。</p> 
 <p>        删除操作是从堆中移除元素的过程，它也是一个关键的操作。通过PriorityQueue的<code>remove()</code>或<code>poll()</code>方法，我们可以轻松地实现删除操作。删除操作的核心在于保持堆的性质不变，这需要进行必要的下沉操作。下沉操作确保移动的元素与其子节点之间的关系满足堆的性质，从而维护堆的结构。</p> 
 <p>        过学习Java中的PriorityQueue和堆，我意识到了数据结构在解决实际问题中的重要性。掌握这些基本的数据结构和操作，可以为我在日后的编程工作中提供强大的支持。在未来，我计划通过更深入的学习和实践，进一步提升自己在数据结构和算法方面的能力，以应对更复杂的编程挑战。</p> 
 <p>        总的来说，学习Java中的PriorityQueue和堆是一次愉快且收获丰富的经历。我期待着将这些知识应用到实际项目中，并不断提升自己的编程技能。</p> 
 <hr> 
 <p>🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀</p> 
 <p>以上，就是本期的全部内容啦，若有错误疏忽希望各位大佬及时指出💐</p> 
 <p>  制作不易，希望能对各位提供微小的帮助，可否留下你免费的赞呢🌸</p> 
 <p></p> 
 <div></div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f5d8d86037268a0903884e16f998e51b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【MySQL精炼宝库】深度解析索引 | 事务</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ee4ce0be4ce0b8e0e51ce29f5a239e81/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C语言】——数据在内存中的存储</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>