<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C语言】——数据在内存中的存储 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/ee4ce0be4ce0b8e0e51ce29f5a239e81/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【C语言】——数据在内存中的存储">
  <meta property="og:description" content="【C语言】——数据在内存中的存储 一、整数在内存中的存储1.1、整数的存储方式1.2、大小端字节序（1）大小端字节序的定义（2）判断大小端 1.3、整型练习 二、浮点数在内存中的存储2.1、引言2.2、浮点数的存储规则2.3、浮点数的存储过程2.4、题目解析 一、整数在内存中的存储 1.1、整数的存储方式 我们知道，整形分为有符号整形和无符号整形。对于无符号整型来说，他所有位均为数值位；而有符号整形，他的最高位代表符号位，其余位为数值位，符号位用0表示正，1表示负。
注： c h a r char char类型虽然是存储字符，但本质是存其ASCII值，因此也可以看作是整形。
注：有符号和无符号只针对整型，不包括浮点型等
在【C语言】——详原解操作符（上）中，我曾提到，整数在内存中的存储有三种方式：原码、反码、补码。下面，让我们简单回顾一下。
原码：直接将数值按他的正负数形式翻译成二进制得到的就是原码反码：源码的符号位不变，数值位按位取反即为反码补码：将反码加一，得到的就是补码 在内存中，整数的存储和运算都是以补码的形式，只有显示给用户时，才是原码的形式。
为什么呢？
在计算机系统中，数值一律用补码来表示和存储。
原因在于：使用补码，可以将数值位和符号位统一进行处理
同时，加法和减法也可以统一进行处理（CPU只有加法器），此外，源码和补码相互转换，其运算过程是相同的（两者转换都是取反，加一），不需要额外的硬件电路。
1.2、大小端字节序 （1）大小端字节序的定义 不知大家在平时调试代码时，大家有没有发现一个奇怪的现象：整型在内存中好像是倒着存的。
如图：
上图显示的是整型变量 a a a 在内存中的存储情况，按我们的习惯不应该是：00 00 00 01 吗？为什么是 01 00 00 00 呢？
上面这种存储方式叫小端字节序存储
首先，我们来看看什么是大小端。
在内存中，数据是以内存为单位进行存储的，那么，超过一个字节大小的数据的存储就不可避免的涉及到存储顺序问题，按照不同的存储顺序，我们分为大端字节序存储和小端字节序存储，下面是具体概念。
小端字节序存储：指数据的低位字节内容保存在内存中的低地址处，而数据的高字节内容保存在内存的高地址处。大端字节序存储：指数据的高位字节内容保存在内存的低地址处，而数据的低字节内容保存在内存的高地址处。 数据是大端还是小端存储并不由编译器决定，而是取决于硬件设备。
为什么会分大小端呢？
这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8 个 b i t bit bit 位，但是在 C语言 中除了 8 b i t bit bit 的 c h a r char char 之外，还有 16 b i t bit bit 的 s h o r t short short">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-01T11:48:22+08:00">
    <meta property="article:modified_time" content="2024-05-01T11:48:22+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C语言】——数据在内存中的存储</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>【C语言】——数据在内存中的存储</h4> 
 <ul><li><ul><li><a href="#_1" rel="nofollow">一、整数在内存中的存储</a></li><li><ul><li><a href="#11_2" rel="nofollow">1.1、整数的存储方式</a></li><li><a href="#12_31" rel="nofollow">1.2、大小端字节序</a></li><li><ul><li><a href="#1_32" rel="nofollow">（1）大小端字节序的定义</a></li><li><a href="#2_63" rel="nofollow">（2）判断大小端</a></li></ul> 
    </li><li><a href="#13_113" rel="nofollow">1.3、整型练习</a></li></ul> 
   </li><li><a href="#_268" rel="nofollow">二、浮点数在内存中的存储</a></li><li><ul><li><a href="#21_269" rel="nofollow">2.1、引言</a></li><li><a href="#22_316" rel="nofollow">2.2、浮点数的存储规则</a></li><li><a href="#23_343" rel="nofollow">2.3、浮点数的存储过程</a></li><li><a href="#24_373" rel="nofollow">2.4、题目解析</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_1"></a>一、整数在内存中的存储</h3> 
<h4><a id="11_2"></a>1.1、整数的存储方式</h4> 
<p>  <br>   我们知道，整形分为<mark>有符号整形</mark>和<mark>无符号整形</mark>。对于无符号整型来说，他<code>所有位均为数值位</code>；而有符号整形，他的<code>最高位代表符号位</code>，<code>其余位为数值位</code>，符号位用<code>0表示正，1表示负</code>。<br>   </p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/b1/a0/I3lsmF3H_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p><em>注：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          c 
         
        
          h 
         
        
          a 
         
        
          r 
         
        
       
         char 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">ha</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span></span></span>类型虽然是存储字符，但本质是存其<mark>ASCII值</mark>，因此也可以看作是整形。<br> 注：有符号和无符号<mark>只针对整型</mark>，不包括浮点型等</em><br>   </p> 
<p>在<a href="https://blog.csdn.net/yusjushd/article/details/136273748">【C语言】——详原解操作符（上）</a>中，我曾提到，整数在内存中的存储有三种方式：原码、反码、补码。下面，让我们简单回顾一下。</p> 
<blockquote> 
 <ul><li>原码：直接将数值按他的正负数形式翻译成二进制得到的就是原码</li><li>反码：源码的符号位不变，数值位按位取反即为反码</li><li>补码：将反码加一，得到的就是补码</li></ul> 
</blockquote> 
<p>  在内存中，整数的存储和运算都是以<mark>补码</mark>的形式，只有显示给用户时，才是<strong>原码</strong>的形式。<br>   <br> 为什么呢？</p> 
<blockquote> 
 <p>  在计算机系统中，数值一律用补码来表示和存储。<br>   <br>   原因在于：使用补码，可以将数值位和符号位统一进行处理<br>   <br>   同时，加法和减法也可以统一进行处理（CPU只有加法器），此外，源码和补码相互转换，其运算过程是相同的（两者转换都是取反，加一），不需要额外的硬件电路。</p> 
</blockquote> 
<p>  <br>   </p> 
<h4><a id="12_31"></a>1.2、大小端字节序</h4> 
<h5><a id="1_32"></a>（1）大小端字节序的定义</h5> 
<p>  不知大家在平时调试代码时，大家有没有发现一个奇怪的现象：<code>整型在内存中好像是倒着存的</code>。<br>   <br> <strong>如图：</strong></p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/39/ab/dc96Khde_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  <br>   上图显示的是整型变量 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
      
        a 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span></span> 在内存中的存储情况，按我们的习惯不应该是：<mark>00 00 00 01</mark> 吗？为什么是 <mark>01 00 00 00</mark> 呢？<br>   <br>   上面这种存储方式叫<mark>小端字节序存储</mark><br>   <br>   首先，我们来看看什么是大小端。<br>   <br>   在内存中，数据是<code>以内存为单位进行存储</code>的，那么，<code>超过一个字节大小的数据的存储就不可避免的涉及到存储顺序问题</code>，按照不同的存储顺序，我们分为<code>大端字节序存储</code>和<code>小端字节序存储</code>，下面是具体概念。</p> 
<ul><li><code>小端字节序存储</code>：指数据的<mark>低位字节内容</mark>保存在内存中的<mark>低地址</mark>处，而数据的<mark>高字节内容</mark>保存在内存的<mark>高地址</mark>处。</li><li><code>大端字节序存储</code>：指数据的<mark>高位字节内容</mark>保存在内存的<mark>低地址</mark>处，而数据的<mark>低字节内容</mark>保存在内存的<mark>高地址</mark>处。</li></ul> 
<p>  数据是大端还是小端存储并不由编译器决定，而是<code>取决于硬件设备</code>。<br>   <br>   <br> <strong>为什么会分大小端呢？</strong></p> 
<blockquote> 
 <p>  这是因为在计算机系统中，我们是<code>以字节为单位</code>的，每个地址单元都对应着一个字节，一个字节为 <mark>8 个<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           b 
          
         
           i 
          
         
           t 
          
         
        
          bit 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span></span></span></span></span></mark> 位，但是在 C语言 中除了 8<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          b 
         
        
          i 
         
        
          t 
         
        
       
         bit 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span></span></span></span></span> 的 <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           c 
          
         
           h 
          
         
           a 
          
         
           r 
          
         
        
          char 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">ha</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span></span></span></mark> 之外，还有 16<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          b 
         
        
          i 
         
        
          t 
         
        
       
         bit 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span></span></span></span></span> 的 <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           s 
          
         
           h 
          
         
           o 
          
         
           r 
          
         
           t 
          
         
        
          short 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right: 0.0278em;">or</span><span class="mord mathnormal">t</span></span></span></span></span></mark><br> 类型，32<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          b 
         
        
          i 
         
        
          t 
         
        
       
         bit 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span></span></span></span></span> 的 <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           l 
          
         
           o 
          
         
           n 
          
         
           g 
          
         
        
          long 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span></span></span></span></span></mark> 类型（要看具体的编译器），另外，对于位数大于 8 位的处理器，例如 16 位或者 32 位的处理器，由于寄存器宽度大于一个字节，那么就<code>必然存在着如何将多个字节安排的问题</code>。因此就导致了大端存储模式和小端存储模式。<br>   <br>    例如：一个 <mark>16<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           b 
          
         
           i 
          
         
           t 
          
         
        
          bit 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span></span></span></span></span></mark> 的 <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           s 
          
         
           h 
          
         
           o 
          
         
           r 
          
         
           t 
          
         
        
          short 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right: 0.0278em;">or</span><span class="mord mathnormal">t</span></span></span></span></span></mark> 类型 <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           x 
          
         
        
          x 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span></mark> ，在内存中的地址为 <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           0 
          
         
           x 
          
         
           0010 
          
         
        
          0x0010 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">0010</span></span></span></span></span></mark>，<mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           x 
          
         
        
          x 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span></mark> 的值为 <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           0 
          
         
           x 
          
         
           1122 
          
         
        
          0x1122 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">1122</span></span></span></span></span></mark> ，那么 <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           0 
          
         
           x 
          
         
           11 
          
         
        
          0x11 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">11</span></span></span></span></span></mark> 为高字节，<mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           0 
          
         
           x 
          
         
           22 
          
         
        
          0x22 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">22</span></span></span></span></span></mark> 为低字节。对于大端模式，就将 <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           0 
          
         
           x 
          
         
           11 
          
         
        
          0x11 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">11</span></span></span></span></span></mark> 放在低地址中，即 <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           0 
          
         
           x 
          
         
           0010 
          
         
        
          0x0010 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">0010</span></span></span></span></span></mark> 中，<mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           022 
          
         
        
          022 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">022</span></span></span></span></span></mark> 放在高地址中，即放在 <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           0 
          
         
           x 
          
         
           0011 
          
         
        
          0x0011 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">0011</span></span></span></span></span></mark> 中。而小端模式，刚好相反。   <br>   <br>   我们常用的 <mark>x86</mark> 结构是小端模式，而 <mark>KEIL C51</mark> 则为大端模式。很多的ARM，DSP都为小端模式。有些 ARM 处理器还可以由硬件来选择时大端模式还是小端模式</p> 
</blockquote> 
<p>  <br>   </p> 
<h5><a id="2_63"></a>（2）判断大小端</h5> 
<p>  <br>   既然知道了计算机分为大端和小端存储，那有没有办法通过代码来判断自己的设备是大端还是小端呢？<br>   <br>   我们不妨这样想，往一个整形中存放数据，再想办法<code>只读取他第一个字节内容</code>，根据该字节存储的内容来判断是大端还是小端。</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">check_sys</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">check_sys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"小端\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"大端\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  <br>   我们来分析<code>return (*(char*)&amp;i);</code>这句代码：</p> 
<ul><li>我们取出变量 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          i 
         
        
       
         i 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span> 的地址，因为 <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           c 
          
         
           h 
          
         
           a 
          
         
           r 
          
         
        
          char 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">ha</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span></span></span>* 型指针只会访问一个字节的内容</mark>，所以将其强制类型转换成 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          c 
         
        
          h 
         
        
          a 
         
        
          r 
         
        
       
         char 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">ha</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span></span></span>* 类型，再对其进行解引用。</li><li>同时我们还知道：<code>一个变量的地址，是其所有字节的地址中，地址最小的字节的地址</code>。因此解引用得到的是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          i 
         
        
       
         i 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span> 中最小字节地址所存储的内容，如果存储值为 1，则为小端存储，如果为 0，则为大端存储</li></ul> 
<p>  <br>   当然，，我们还可以用联合体来判断</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">check_sys</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">union</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> i<span class="token punctuation">;</span>
		<span class="token keyword">char</span> c<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>un<span class="token punctuation">;</span>
	un<span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> un<span class="token punctuation">.</span>c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  关于联合体的知识，我们放到后面去讲<br>   <br>   </p> 
<h4><a id="13_113"></a>1.3、整型练习</h4> 
<p>  <br> <strong>练习一：</strong></p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">signed</span> <span class="token keyword">char</span> b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a=%d, b=%d, c=%d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  </p> 
<blockquote> 
 <ul><li>首先我们来看<code>char a = -1;</code>：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           c 
          
         
           h 
          
         
           a 
          
         
           r 
          
         
        
          char 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">ha</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span></span></span> 类型是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           （ 
          
         
           s 
          
         
           i 
          
         
           g 
          
         
           n 
          
         
           e 
          
         
           d 
          
         
           ） 
          
         
           c 
          
         
           h 
          
         
           a 
          
         
           r 
          
         
        
          （signed）char 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord cjk_fallback">（</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord cjk_fallback">）</span><span class="mord mathnormal">c</span><span class="mord mathnormal">ha</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span></span></span> 还是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           （ 
          
         
           u 
          
         
           n 
          
         
           s 
          
         
           i 
          
         
           g 
          
         
           n 
          
         
           e 
          
         
           d 
          
         
           c 
          
         
           h 
          
         
           a 
          
         
           r 
          
         
           ） 
          
         
        
          （unsigned char） 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord cjk_fallback">（</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal">c</span><span class="mord mathnormal">ha</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord cjk_fallback">）</span></span></span></span></span> 取决于<mark>具体编译器的实现</mark>，但大部分是（signed）char。</li><li>-1 的补码是 <font color="red">11111111 11111111 11111111 11111111</font>（整数默认4个字节），因为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           c 
          
         
           h 
          
         
           a 
          
         
           r 
          
         
        
          char 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">ha</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span></span></span> 只有一个字节大小，发生截断，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           a 
          
         
        
          a 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span></span> 中放的是 <font color="red"> 11111111</font>。同理<code>char b=-1</code>中 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           b 
          
         
        
          b 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></span> 中放的也是<font color="red">11111111</font>。</li><li>接下来，我们来看<code>unsigned char c = -1;</code>：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           c 
          
         
        
          c 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span></span> 中存放的也是 <font color="red">11111111</font>，<mark>虽然 -1 是负数，但是存还是照样存的（先把数据存进去再说）</mark></li><li>虽然 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           a 
          
         
           b 
          
         
           c 
          
         
        
          abc 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">ab</span><span class="mord mathnormal">c</span></span></span></span></span> 里存的都是 8 个 1 ，但以什么方式看待这 8 个 1 是不同的，对 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           a 
          
         
           b 
          
         
        
          ab 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">ab</span></span></span></span></span> 来说，他们认为 8 个 1 是 <font color="red">-1</font>，而对 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           c 
          
         
        
          c 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span></span> 来说，他认为 8 个 1 是 <font color="red">255</font>。</li><li>再来看最后一句，首先，我们要知道<code>％d</code>是<mark>以有符号整型来打印</mark>，打印 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           a 
          
         
           b 
          
         
           c 
          
         
        
          abc 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">ab</span><span class="mord mathnormal">c</span></span></span></span></span> 时，他们要先发生<mark>整形提升</mark>（详情请看<a href="https://blog.csdn.net/yusjushd/article/details/136517921">【C语言】——详解操作符（下）</a>）。</li><li> 
   <ul><li>对 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             a 
            
           
             b 
            
           
          
            ab 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">ab</span></span></span></span></span> 来说他们是<mark>有符号类型</mark>，整形提升<mark>按他们的符号位进行提升</mark>，即 <font color="red">11111111 11111111 11111111 11111111</font>，补码转为源码，打印的结果是 <font color="red">-1</font>。</li></ul> </li><li> 
   <ul><li>而对于 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             c 
            
           
          
            c 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span></span> 来说他是<mark>无符号类型</mark>，整形提升<mark>高位补 0</mark>，即 <font color="red">00000000 00000000 00000000 11111111</font>，因为首位是 0，被认为是正数，正数的原反补码相同，结果为 <font color="red">255</font>。</li></ul> </li></ul> 
</blockquote> 
<p><strong>答案：-1、-1、255</strong></p> 
<p>  <br>   </p> 
<p><strong>练习二：</strong></p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span> b <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a=%u, b=%u\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  </p> 
<blockquote> 
 <p>我们先来看 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          a 
         
        
       
         a 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span></span></p> 
 <ul><li>首先，我们来看 -128 的原码 反码 补码<br> 原码：10000000 00000000 00000000 10000000<br> 反码：11111111 11111111 11111111 0111111<br> 补码：11111111 11111111 11111111 10000000<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           a 
          
         
        
          a 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span></span> 存储时，发生截断，存后面 8 个 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           b 
          
         
           i 
          
         
           t 
          
         
        
          bit 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span></span></span></span></span> 位，即 <font color="red">10000000</font></li><li><code>％u</code>是<mark>以无符号整型来打印数据</mark>，打印前，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           a 
          
         
        
          a 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span></span> 先发生<mark>整形提升</mark>，因为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           c 
          
         
           h 
          
         
           a 
          
         
           r 
          
         
        
          char 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">ha</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span></span></span> 为有符号类型，整型提升<mark>按符号位提升</mark>，即 <font color="red">11111111 11111111 11111111 1000000</font>，而<code>％u</code>认为他是无符号数，因此打印的是一个很大的数。</li><li>同理，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           b 
          
         
        
          b 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></span> 也是类似的分析方法</li></ul> 
</blockquote> 
<p><strong>答案：a=4294967168, b=4294967168</strong><br>   <br>   <br>  <br> <strong>练习三：</strong></p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  </p> 
<blockquote> 
 <p>让我们一起来分析这道题</p> 
 <ul><li>数组 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           a 
          
         
        
          a 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span></span> 中存放的是 <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            c 
           
          
            h 
           
          
            a 
           
          
            r 
           
          
         
           char 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">ha</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span></span></span>类型</mark> 的数据，通过 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           f 
          
         
           o 
          
         
           r 
          
         
        
          for 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mord mathnormal" style="margin-right: 0.0278em;">or</span></span></span></span></span> 循环，依次放入 <strong>-1，-2，-3</strong> <strong>······</strong> 等数据，循环 1000 次。而因为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           a 
          
         
        
          a 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span></span> 中元素是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           c 
          
         
           h 
          
         
           a 
          
         
           r 
          
         
        
          char 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">ha</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span></span></span>类型，范围是 <mark>-128至127</mark>，因此放入的数据会<mark>周期循环</mark>。</li><li>而题目要求打印的是<code>strlen(a)</code>的值，我们知 <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            s 
           
          
            t 
           
          
            r 
           
          
            l 
           
          
            e 
           
          
            n 
           
          
         
           strlen 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span></span></span></span></span>函数</mark> 是计算字符串的长度，遇到 <strong><font color="red">‘\0’</font></strong> 停止计算，而 <code>‘\0’ 的本质是 0</code>，因此这题的核心思路就是：<code>计算第一次放入0，是第几个数放入，再减去一，即可知道前面翻入几个数，即字符串长度</code>。</li></ul> 
</blockquote> 
<p>  </p> 
<blockquote> 
 <p> <img src="https://images2.imgbox.com/da/d1/2TtkRb3T_o.png" alt="在这里插入图片描述"><br>  </p> 
</blockquote> 
<p><strong>答案：255</strong><br>   <br>   <br> <strong>练习四：</strong></p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">255</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  </p> 
<blockquote> 
 <p>  该代码会打印多少个 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          " 
         
        
          h 
         
        
          e 
         
        
          l 
         
        
          l 
         
        
          o 
         
        
          w 
         
        
          o 
         
        
          r 
         
        
          l 
         
        
          d 
         
        
          " 
         
        
       
         "hello world" 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord">"</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right: 0.0197em;">ll</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span><span class="mord mathnormal" style="margin-right: 0.0278em;">or</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">d</span><span class="mord">"</span></span></span></span></span> 呢？是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          256 
         
        
       
         256 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">256</span></span></span></span></span> 个吗？<br>   答案是：<font color="red">死循环</font><br>   因为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          i 
         
        
       
         i 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span> 是 <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           u 
          
         
           n 
          
         
           s 
          
         
           i 
          
         
           g 
          
         
           n 
          
         
           e 
          
         
           d 
          
         
           c 
          
         
           h 
          
         
           a 
          
         
           r 
          
         
        
          unsigned char 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal">c</span><span class="mord mathnormal">ha</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span></span></span> 类型</mark>，他的数据范围是 <mark>0-255</mark>，当值为 255 即 11111111 时，加 1 为 100000000，因为只能存 8 比特位，<mark>发生截断</mark>，即 <font color="red">00000000</font>，再不断加一，如此往复，永远跳不出循环。</p> 
</blockquote> 
<p>  </p> 
<blockquote> 
 <p> <img src="https://images2.imgbox.com/19/c7/VCOb76ZK_o.png" alt="在这里插入图片描述"><br>  </p> 
</blockquote> 
<p>  </p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%u\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>同理，这段代码也是如此，一样是死循环</p> 
</blockquote> 
<p>  <br>   <br> <strong>练习五：</strong></p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> ptr1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> ptr2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x, %x"</span><span class="token punctuation">,</span> ptr1<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>ptr2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  </p> 
<blockquote> 
 <ul><li>首先我们来看 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           p 
          
         
           t 
          
         
           r 
          
         
           1 
          
         
        
          ptr1 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8389em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">pt</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord">1</span></span></span></span></span>：&amp;<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           a 
          
         
        
          a 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span></span> 取出的是<mark>整个数组的地址</mark>，+1 则是跳过了整个数组，之后将该地址强制类型转换成 <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            i 
           
          
            n 
           
          
            t 
           
          
         
           int 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span></span></span></span></span> * 类型</mark>。<mark>％x 是以十六进制</mark>的方式打印数据，<mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            p 
           
          
            t 
           
          
            r 
           
          
            1 
           
          
            [ 
           
          
            − 
           
          
            1 
           
          
            ] 
           
          
         
           ptr1[-1] 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">pt</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord">1</span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span></mark> 等价于 <mark>*<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            （ 
           
          
            p 
           
          
            t 
           
          
            r 
           
          
            − 
           
          
            1 
           
          
            ） 
           
          
         
           （ptr -1） 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord cjk_fallback">（</span><span class="mord mathnormal">pt</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord">1</span><span class="mord cjk_fallback">）</span></span></span></span></span></mark>，由于 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           p 
          
         
           t 
          
         
           r 
          
         
           1 
          
         
        
          ptr1 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8389em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">pt</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord">1</span></span></span></span></span> 是整型指针，-1 后退 4 个字节指向元素 <mark>4</mark><br>  <br> <strong>图示：</strong><br>  <br> <img src="https://images2.imgbox.com/23/62/ZTWaueix_o.png" alt="在这里插入图片描述"><br>  </li></ul> 
</blockquote> 
<p>  </p> 
<blockquote> 
 <ul><li>接着我们来看 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           p 
          
         
           t 
          
         
           r 
          
         
           2 
          
         
        
          ptr2 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8389em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">pt</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord">2</span></span></span></span></span>，首先 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           a 
          
         
        
          a 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span></span> 是数组首元素的地址，取出后将其强制类型转换成<mark>整型变量</mark>，后面 +1，即<mark>数学上的+1</mark>，指针向后移动一位。</li><li>再将该整数强制类型转换成<mark>整型指针</mark>，最后，以<mark>十六进制</mark>打印 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           p 
          
         
           t 
          
         
           r 
          
         
           2 
          
         
        
          ptr2 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8389em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">pt</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord">2</span></span></span></span></span> 解引用的值，因为强转成 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           i 
          
         
           n 
          
         
           t 
          
         
        
          int 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span></span></span></span></span>* 指针，所以访问权限为 <font color="red">4</font> 个字节。<br>  <br> <img src="https://images2.imgbox.com/4c/38/4FI6LV42_o.png" alt="在这里插入图片描述"><br>  </li><li>因为为<mark>小端存储</mark>，所以取出的数实际为 <font color="red">02 00 00 00</font></li></ul> 
</blockquote> 
<p><strong>答案：4  2000000</strong></p> 
<p>  <br>   </p> 
<h3><a id="_268"></a>二、浮点数在内存中的存储</h3> 
<h4><a id="21_269"></a>2.1、引言</h4> 
<p>  像 3.14159、1E10 等数被称为浮点数。</p> 
<p>  首先我来问问大家，浮点数为什么叫浮点数呢？</p> 
<p>  我们来看个例子：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         123.45 
        
       
      
        123.45 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">123.45</span></span></span></span></span> = <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         12.345 
        
       
         ∗ 
        
       
         1 
        
        
        
          0 
         
        
          1 
         
        
       
      
        12.345*10^1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">12.345</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> = <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1.2345 
        
       
         ∗ 
        
       
         1 
        
        
        
          0 
         
        
          2 
         
        
       
      
        1.2345 * 10^2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1.2345</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p> 
<p>  可以看到，该数的<strong>小数点</strong>是可以<strong>左右浮动</strong>的，因此被称为<mark>浮点数</mark>。<br>  <br>   浮点数家族包括 <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          f 
         
        
          l 
         
        
          o 
         
        
          a 
         
        
          t 
         
        
       
         float 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span></span></span></span></span></mark>、<mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          d 
         
        
          o 
         
        
          u 
         
        
          b 
         
        
          l 
         
        
          e 
         
        
       
         double 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span></span></span></span></span></mark>、<mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          l 
         
        
          o 
         
        
          n 
         
        
          g 
         
        
          d 
         
        
          o 
         
        
          u 
         
        
          b 
         
        
          l 
         
        
          e 
         
        
       
         long double 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span></span></span></span></span></mark> 等类型，浮点数的表示范围，在 <code>&lt;float.h&gt;</code>中定义<br>   <br>   <br> 接下来，让我们看一道习题，开启接下来的浮点数学习之旅。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
	<span class="token keyword">float</span><span class="token operator">*</span> pFloat <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>n<span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"n的值为：%d\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*pFloat的值为：%f\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>pFloat<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token operator">*</span>pFloat <span class="token operator">=</span> <span class="token number">9.0</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"n的值为：%d\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*pFloat的值为：%f\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>pFloat<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  <br> <strong>输出结果：</strong></p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/58/eb/HfxEYEok_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  为什么会这样呢？按我们之前的知识，四个答案应该是：<mark>9</mark>、<mark>9.0</mark>、<mark>9</mark>、<mark>9.0</mark> 。但现在，只有两个正确，为什么呢？<br>   </p> 
<blockquote> 
 <p>我们先粗略分析一下原因</p> 
 <ul><li>我们以整型形式放，以浮点型形式取出，有问题</li><li>我们以浮点型的形式放，以整型的形式取出，也有问题</li></ul> 
</blockquote> 
<p>  我们不妨做一个大胆的猜测：<code>整型和浮点型在内存中的存储有很大差异</code>。<br>   <br>   那到底是不是这样呢？我们一起来学习浮点型在内存中的存储。<br>   </p> 
<h4><a id="22_316"></a>2.2、浮点数的存储规则</h4> 
<blockquote> 
 <p>  根据国际标准 <mark>IEEE(电气和电子工程协会)754</mark>，任意一个浮点数 V 可以表示成下面的形式<br>  <img src="https://images2.imgbox.com/d2/36/VxbtYWpQ_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p> <br> 举例来说：</p> 
<blockquote> 
 <p>十进制的 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          5.0 
         
        
       
         5.0 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">5.0</span></span></span></span></span>，用二进制表示是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          101.0 
         
        
       
         101.0 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">101.0</span></span></span></span></span>，可写成 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          1.01 
         
        
          ∗ 
         
         
         
           2 
          
         
           2 
          
         
        
       
         1.01*2^2 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1.01</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>。 那么，按上面 V 的形式，他的 <mark>S=0</mark>、 <mark>M=1.01</mark>、 <mark>E=2</mark><br>  <br> 十进制的 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          − 
         
        
          5.0 
         
        
       
         -5.0 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7278em; vertical-align: -0.0833em;"></span><span class="mord">−</span><span class="mord">5.0</span></span></span></span></span>，用二进制表示是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          − 
         
        
          101.0 
         
        
       
         -101.0 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7278em; vertical-align: -0.0833em;"></span><span class="mord">−</span><span class="mord">101.0</span></span></span></span></span>，可写成 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          − 
         
        
          1.01 
         
        
          ∗ 
         
         
         
           2 
          
         
           2 
          
         
        
       
         -1.01*2^2 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7278em; vertical-align: -0.0833em;"></span><span class="mord">−</span><span class="mord">1.01</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> 那么，按上面 V 的形式，它的 <mark>S=1</mark>、 <mark>M=1.01</mark>、 <mark>E=2</mark></p> 
</blockquote> 
<p>  <br> <strong><mark>IEEE 754</mark> 规定：</strong><br>   <br>   对于 <mark>32 位（<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          f 
         
        
          l 
         
        
          o 
         
        
          a 
         
        
          t 
         
        
       
         float 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span></span></span></span></span>）</mark> 的浮点数，<code>最高的一位</code>存储的是符号位 <code>S</code>，接着 <code>8 位</code>存储指数位 <code>E</code>，剩下的 <code>23 位</code>存储有效数字 <code>M</code></p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/78/42/isJMEFLj_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  <br>   而对于 <mark>64 位（<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          d 
         
        
          o 
         
        
          u 
         
        
          b 
         
        
          l 
         
        
          e 
         
        
       
         double 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span></span></span></span></span>）</mark> 的浮点数，<code>最高的一位</code>存储的是符号位<code>S</code>，接着<code>11位</code>存储指数位<code>E</code>，剩下的<code>52位</code>存储有效数字<code>M</code></p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/79/79/7zajdwl4_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  </p> 
<h4><a id="23_343"></a>2.3、浮点数的存储过程</h4> 
<p>  <br>   <strong>IEEE 754</strong> 对有效 <mark>数字 M</mark> 和 <mark>指数 E</mark> 还有一些特别规定</p> 
<p>  我们前面说过，M 的取值 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1 
        
       
         &lt; 
        
       
         = 
        
       
         M 
        
       
         &lt; 
        
       
         2 
        
       
      
        1&lt;=M&lt;2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6835em; vertical-align: -0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7224em; vertical-align: -0.0391em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">2</span></span></span></span></span> ，也就是写成 <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          1. 
         
        
          x 
         
        
          x 
         
        
          x 
         
        
          x 
         
        
          x 
         
        
       
         1.xxxxx 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1.</span><span class="mord mathnormal">xxxxx</span></span></span></span></span></mark> 的形式，其中 <mark>xxxxx</mark> 是小数部分。<strong>IEEE 754</strong> 中规定，计算机那边存储 <strong>M</strong> 时，默认这个数的第一位总是 <strong>1</strong> ，因此<code>1可以被舍去，只保留后面的小数部分</code>，比如保存 1.01 时，只存储 01。等<code>到读取的时候，再把第一位的 1 加上去</code>。这样做的目的是可以<strong>节省</strong>一位有效数字的<strong>空间</strong></p> 
<p> <br>   至于指数E，则更为复杂一些：</p> 
<p>  首先，规定 E 是一个<mark>无符号整数</mark>。这样，如果 E 为 8 位，他的存储范围是 <mark>0～255</mark> ，如果 E 为 11 位，他的存储范围则是 <mark>0～2047</mark>。但是，我们知道，指数位是可以有<strong>负数</strong>的，所以 <strong>IEEE 754</strong> 规定，存入内存时 <strong>E</strong> 的真实值<code>必须再加上一个中间值</code>，对于 <mark>8位</mark> 的 E，这个中间值是 <mark>127</mark> ，对 <mark>11位</mark> 的E这个中间值是 <mark>1023</mark>。比如：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          2 
         
        
          10 
         
        
       
      
        2^{10} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span></span> ，他的 E 为 10，所以存储为 32 位浮点数时，必须保存成 <strong>10+127=137</strong>，即 <strong>10001001</strong>。<br>   <br>   指数E从内存中取出还可以再分成三种情况</p> 
<ol><li>E不全为 0 或不全为 1<br>   这时， 浮点数就采用下面的规则表示，即<code>指数E的计算值减去127（或1023）</code>，得到真实值，<code>再将有效数字M前加上第一位的1</code>.<br>   比如：0.5 的二进制形式为 0.1，由于规定整数部分必须为 1，即小数点右移1位，为 <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           1.0 
          
         
           ∗ 
          
          
          
            2 
           
           
           
             − 
            
           
             1 
            
           
          
         
        
          1.0*2^{-1} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1.0</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></mark> ，其阶码(E) 为 <mark>-1+127(中间值) = 126</mark>，表示为 01111110，而尾数 1.0去掉整数部分为 0，补齐 0 到 23 位<br> <mark>0 01111110 00000000000000000000000</mark><br>   </li><li>E全为0<br>   这时，浮点数的<code>指数E等于1-127（或者1-1023）即为真实值</code>，有效数字M<code>不再加上第一位的1</code>，而是还原为0.xxxxx的小数。这样做是为了表示 ±0，以及接近于 0 的很小的数字<br> <mark>0 00000000 00100000000000000000000</mark><br>   </li><li>E全为1<br>   这时，如果有效数字 <strong>M</strong> 全为 0，表示 ± 无穷大（正负取决于符号位<strong>S</strong>）<br> <mark>0 11111111 00010000000000000000000</mark></li></ol> 
<p>  <br>   </p> 
<h4><a id="24_373"></a>2.4、题目解析</h4> 
<p>  <br>   现在，让我们回到一开始的题目<br>   <br> 先来看第一个环节：</p> 
<ul><li><code>int n = 9;</code>：我们以整型的形式存储 9，此时9在内存中表示为：<br> <font color="red">00000000 00000000 00000000 00001001</font></li><li><code>printf("n的值为：%d\n", n);</code>：这句代码以<strong>整型的形式</strong>打印，打印出 9，没有问题</li><li><code>printf("*pFloat的值为：%f\n", *pFloat);</code>：这句代码以<strong>浮点型的形式</strong>打印</li><li>在 *<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          p 
         
        
          F 
         
        
          l 
         
        
          o 
         
        
          a 
         
        
          t 
         
        
       
         pFloat 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">pFl</span><span class="mord mathnormal">o</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span></span></span></span></span> 眼里，它指向的数据是这样的：<br> <font color="red">0 00000000 00000000000000000001001</font><br> 即<mark>S = 0</mark>， <mark>E = 0</mark>， <mark>M = 1001</mark><br> 由于指数为 0 符合 E 为全 0 的情况。因此浮点数 V 写成：<br> V = <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          ( 
         
        
          − 
         
        
          1 
         
         
         
           ) 
          
         
           0 
          
         
        
       
         (-1)^0 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          ∗ 
         
        
       
         * 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4653em;"></span><span class="mord">∗</span></span></span></span></span> 0.00000000000000000001001 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          ∗ 
         
        
       
         * 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4653em;"></span><span class="mord">∗</span></span></span></span></span> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           2 
          
          
          
            − 
           
          
            126 
           
          
         
        
       
         2^{-126} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">126</span></span></span></span></span></span></span></span></span></span></span></span></span> = <mark>1.001 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           ∗ 
          
         
        
          * 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4653em;"></span><span class="mord">∗</span></span></span></span></span> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            2 
           
           
           
             − 
            
           
             146 
            
           
          
         
        
          2^{-146} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">146</span></span></span></span></span></span></span></span></span></span></span></span></span></mark></li><li>显然，V是一个很小且非常接近 0 的数，用十进制小数表示就是 <font color="red">0.000000</font></li></ul> 
<p>  <br> 再看第二个环节：<br>   <br> 放进浮点数 9.0</p> 
<ul><li>首先 9.0 用二进制表示 1001.0，换算成科学技术法是：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          1.001 
         
        
          ∗ 
         
         
         
           2 
          
          
          
            − 
           
          
            3 
           
          
         
        
       
         1.001 * 2^{-3} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1.001</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span></span>。所以 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          9.0 
         
        
       
         9.0 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">9.0</span></span></span></span></span> = <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           ( 
          
         
           − 
          
         
           1 
          
          
          
            ) 
           
          
            0 
           
          
         
           ∗ 
          
         
           ( 
          
         
           1.001 
          
         
           ) 
          
         
           ∗ 
          
          
          
            2 
           
          
            3 
           
          
         
        
          (-1)^0 * (1.001)*2^3 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1.001</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span></mark></li><li>即<mark>S = 0</mark>，<mark>E = 3 + 127 = 130</mark>，<mark>M = 001</mark> 后面补 20 个 0</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          9.0 
         
        
       
         9.0 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">9.0</span></span></span></span></span> 在内存中的存储为：<br> <font color="red">0 10000010 001</font>00000000000000000000</li><li>这个 32 位数。以整数的形式取出，就是整数在内存中的补码，因为为正数，原反补三码相同，十进制表示，正是1091567616</li></ul> 
<p>  <br>   <br>   <br>   </p> 
<hr> 
<p>  <em><font color="orange">好啦，本期关于数据在内存中的存储就介绍到这里啦，希望本期博客能对你有所帮助。同时，如果有错误的地方请多多指正，让我们在C语言的学习路上一起进步！</font></em></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7832b7e91dad8f709eecf8bf8bc54c5b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java 【数据结构】 优先级队列（PriorityQueue）和堆（Heap）【神装】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c7ef4dd1b72177a8e10896d2bb47a30c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43;】一篇文章带你深入了解stack、queue 和 priority_queue</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>