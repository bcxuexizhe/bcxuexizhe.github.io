<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>你真的知道 NPM、Yarn 与 PNPM 这三个前端包管理器之间的区别吗？ - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/e69c884894037d6e61f69d192e55a115/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="你真的知道 NPM、Yarn 与 PNPM 这三个前端包管理器之间的区别吗？">
  <meta property="og:description" content="在当代的Web开发过程中，JavaScript项目的构建离不开各种外部依赖，无论是实用的库、辅助工具还是其他类型的资源。这些依赖项的管理，已经成为了开发者日常不可或缺的一部分。NPM、Yarn和PNPM这三个包管理器，就像是开发者的得力助手，它们在项目开发中扮演着至关重要的角色。本文将带你一探究竟，了解这些工具的魅力所在，并帮助你选择适合自己项目的包管理器。
1、什么是包管理 在现代Web开发中，一个Node.js应用的构建往往离不开各种依赖，比如库、辅助工具或其他工具包。以一个典型的React项目为例，当你想为项目添加路由功能时，你需要安装如react-router-dom这样的包。类似这样的需求在开发过程中屡见不鲜，而这就是为什么我们需要一个包管理器来帮助我们管理这些依赖。
默认情况下，Node.js安装时会自带NPM（Node Package Manager），作为最初的包管理工具，它为我们的开发提供了极大的便利。然而，随着项目的不断演进和需求的日益增长，仅仅依赖NPM可能无法完全满足我们的所有需求。
因此，了解不同的包管理器，以及它们各自的优势和局限，对于选择最适合自己项目的工具至关重要。下面，我们将探讨包管理器的几个关键作用，帮助你更好地理解它们的价值。
依赖管理
包管理器的核心功能之一是依赖管理。它负责安装、更新和管理项目所需的所有外部依赖，确保依赖版本的正确性和在项目中的可用性。这不仅节省了开发者大量的时间，还避免了因手动管理依赖而可能导致的错误。
安装便捷
从下载命令的提供到本地机器上的依赖、漏洞与安全性评估，这一系列复杂的管理工作都由包管理器自动完成。这大大简化了项目的初始化和后续的依赖更新过程。
脚本与命令
通过在package.json文件中定义额外的脚本命令，包管理器使得常见的开发流程（如启动服务器、运行测试、构建资源等）变得简单快捷。这些命令可以通过包管理器的命令行工具（CLI）直接执行，极大地提高了开发效率。
安全保障
包管理器还提供了工具来扫描已知的安全漏洞，例如NPM的npm audit命令。它们还关注依赖锁定、包签名和验证等安全性和安全措施，从而保护你的项目免受潜在的安全威胁。
通过了解不同包管理器的这些核心功能，你将更加有信心地选择适合自己项目需求的工具。不管是NPM、Yarn还是PNPM，它们都旨在使你的开发工作流程更加顺畅，帮助你更高效、更安全地管理项目依赖。
2、NPM：JavaScript开发者的首选包管理器 NPM（Node Package Manager），作为默认的JavaScript应用包管理器，与Node.js一同安装，它是目前使用最广泛的包管理器，得益于其对大量包的强大支持。
NPM的成长之路
在早期版本中，NPM缺乏对锁文件的支持，这意味着它无法维护应用所使用的依赖版本的确切记录。因此，版本控制的缺失常常导致兼容性问题，不同的环境可能会结束使用不同版本的依赖。此外，在更新之前，NPM允许在不同的机器上使用不同版本的包，这种灵活性不经意间可能导致重大变化，因为开发者可能会不经意间依赖于某个版本中存在而在另一个版本中缺失的特性或行为。后来，Yarn解决了这些问题，随后NPM也通过更新解决了这些问题。
NPM的工作原理
NPM拥有一个集中式的注册中心，其中托管了数以千计的包。这些包可以是库、框架、助手、工具或实用工具。当你运行npm install时，NPM会从NPM注册中心下载package.json文件中列出的包。下载这些依赖项时，NPM还会生成一个锁文件（package-lock.json），该文件指定了为项目下载的所有依赖项（直接和间接）的确切版本。它充当了一个确定性记录，确保未来的安装，即使是在不同的机器上，也会尝试下载相同的版本。当没有锁文件或锁文件被删除时，NPM将尝试下载满足package.json文件中指定的版本范围的最新兼容版本。这些范围使用语义化版本控制（semver）约定，如^（兼容的小版本）、~（兼容的补丁版本）或确切的版本号（1.2.3）。NPM使用嵌套依赖树，确保每个包获得其依赖的确切版本。
NPM的优势与劣势
优势：
广泛的支持 — NPM托管着世界上最大的JavaScript包注册中心。
简化的依赖管理 — NPM以最简化的方式自动化查找、安装和管理依赖的过程。
易于使用 — NPM设置和使用简单，对所有技能级别的开发者都易于接入。
劣势：
磁盘空间 — 由于NPM使用嵌套依赖树方法保存包，如果不同的依赖需要它们，它需要更多的磁盘空间来保存同一包的多个副本。
依赖膨胀 — 如果依赖/包在长期内没有得到适当管理，可能会导致不必要地积累大量包，这可能会增加项目的大小并潜在引入兼容性问题。
性能 — 与其他包管理器相比，特别是对于有许多依赖的较大项目，NPM的安装可能会更慢，因为它顺序下载包。
尽管存在一些劣势，但NPM通过不断的更新和改进，成功解决了许多早期的问题，并继续为广大JavaScript开发者提供强大的依赖管理和包安装服务。对于大多数项目和开发者而言，NPM依然是包管理的。
3、Yarn：超越NPM的现代JavaScript包管理器 Yarn（Yet Another Resource Negotiator），虽然这个名称听起来有些神秘，实际上它是由Facebook开发的一个Node包管理器，旨在解决当时NPM面临的一些问题。最初，NPM缺乏对依赖版本精确控制和锁文件概念的支持，这正是Yarn诞生的原因。与NPM在功能上有很多相似之处，但Yarn在某些方面提供了更多的优势。
Yarn的工作方式
使用yarn init命令初始化一个项目，这会在项目中生成一个package.json文件。
通过命令yarn add &lt;package_name&gt;添加任何包。
如果你有一个预配置的项目，并且想要安装依赖，可以运行yarn install命令，这将从NPM注册中心下载所有依赖并生成一个锁文件。
Yarn的优点
更快的安装速度：与NPM相比，Yarn在安装包时可以并行执行，从而加快了安装速度。
离线支持：Yarn利用本地缓存加速安装过程。它在全局位置存储包的缓存，可以在不同项目之间共享，这样不仅提高了速度，还实现了NPM所没有的离线支持功能。使用yarn cache dir命令可以查看Yarn保存其包缓存的目录。
更少的磁盘使用：Yarn采用平级依赖结构，避免了包的重复和嵌套，从而最小化了磁盘使用。
Monorepo支持：Yarn还旨在通过称为WORKSPACE的特性支持monorepo。Monorepo是一个单一的仓库，其中存在多个包，每个包都有自己的package.json。Yarn Workspaces通过从中心位置安装所有包的依赖来简化依赖管理。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-10T17:40:33+08:00">
    <meta property="article:modified_time" content="2024-04-10T17:40:33+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">你真的知道 NPM、Yarn 与 PNPM 这三个前端包管理器之间的区别吗？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p><img src="https://images2.imgbox.com/7a/f7/sG3fuUx8_o.png" alt="234460f2fd04686b5df7d2fa08ee35d3.png"></p> 
 <p>在当代的Web开发过程中，JavaScript项目的构建离不开各种外部依赖，无论是实用的库、辅助工具还是其他类型的资源。这些依赖项的管理，已经成为了开发者日常不可或缺的一部分。NPM、Yarn和PNPM这三个包管理器，就像是开发者的得力助手，它们在项目开发中扮演着至关重要的角色。本文将带你一探究竟，了解这些工具的魅力所在，并帮助你选择适合自己项目的包管理器。<br></p> 
 <h2>1、什么是包管理</h2> 
 <p><img src="https://images2.imgbox.com/43/ad/pOn9PQ1F_o.jpg" alt="f82eabaa4c82f666931fd7a1d287a880.jpeg"></p> 
 <p>在现代Web开发中，一个Node.js应用的构建往往离不开各种依赖，比如库、辅助工具或其他工具包。以一个典型的React项目为例，当你想为项目添加路由功能时，你需要安装如react-router-dom这样的包。类似这样的需求在开发过程中屡见不鲜，而这就是为什么我们需要一个包管理器来帮助我们管理这些依赖。<br></p> 
 <p>默认情况下，Node.js安装时会自带NPM（Node Package Manager），作为最初的包管理工具，它为我们的开发提供了极大的便利。然而，随着项目的不断演进和需求的日益增长，仅仅依赖NPM可能无法完全满足我们的所有需求。</p> 
 <p>因此，了解不同的包管理器，以及它们各自的优势和局限，对于选择最适合自己项目的工具至关重要。下面，我们将探讨包管理器的几个关键作用，帮助你更好地理解它们的价值。</p> 
 <p>依赖管理</p> 
 <p>包管理器的核心功能之一是依赖管理。它负责安装、更新和管理项目所需的所有外部依赖，确保依赖版本的正确性和在项目中的可用性。这不仅节省了开发者大量的时间，还避免了因手动管理依赖而可能导致的错误。</p> 
 <p>安装便捷</p> 
 <p>从下载命令的提供到本地机器上的依赖、漏洞与安全性评估，这一系列复杂的管理工作都由包管理器自动完成。这大大简化了项目的初始化和后续的依赖更新过程。</p> 
 <p>脚本与命令</p> 
 <p>通过在package.json文件中定义额外的脚本命令，包管理器使得常见的开发流程（如启动服务器、运行测试、构建资源等）变得简单快捷。这些命令可以通过包管理器的命令行工具（CLI）直接执行，极大地提高了开发效率。</p> 
 <p>安全保障</p> 
 <p>包管理器还提供了工具来扫描已知的安全漏洞，例如NPM的npm audit命令。它们还关注依赖锁定、包签名和验证等安全性和安全措施，从而保护你的项目免受潜在的安全威胁。</p> 
 <p>通过了解不同包管理器的这些核心功能，你将更加有信心地选择适合自己项目需求的工具。不管是NPM、Yarn还是PNPM，它们都旨在使你的开发工作流程更加顺畅，帮助你更高效、更安全地管理项目依赖。</p> 
 <h2>2、NPM：JavaScript开发者的首选包管理器</h2> 
 <p><img src="https://images2.imgbox.com/12/9a/J0JS61V2_o.jpg" alt="a6b430a1712a1f5ca2012f1f9e56748c.jpeg"></p> 
 <p>NPM（Node Package Manager），作为默认的JavaScript应用包管理器，与Node.js一同安装，它是目前使用最广泛的包管理器，得益于其对大量包的强大支持。<br></p> 
 <p>NPM的成长之路</p> 
 <p>在早期版本中，NPM缺乏对锁文件的支持，这意味着它无法维护应用所使用的依赖版本的确切记录。因此，版本控制的缺失常常导致兼容性问题，不同的环境可能会结束使用不同版本的依赖。此外，在更新之前，NPM允许在不同的机器上使用不同版本的包，这种灵活性不经意间可能导致重大变化，因为开发者可能会不经意间依赖于某个版本中存在而在另一个版本中缺失的特性或行为。后来，Yarn解决了这些问题，随后NPM也通过更新解决了这些问题。</p> 
 <p>NPM的工作原理</p> 
 <p>NPM拥有一个集中式的注册中心，其中托管了数以千计的包。这些包可以是库、框架、助手、工具或实用工具。当你运行npm install时，NPM会从NPM注册中心下载package.json文件中列出的包。下载这些依赖项时，NPM还会生成一个锁文件（package-lock.json），该文件指定了为项目下载的所有依赖项（直接和间接）的确切版本。它充当了一个确定性记录，确保未来的安装，即使是在不同的机器上，也会尝试下载相同的版本。当没有锁文件或锁文件被删除时，NPM将尝试下载满足package.json文件中指定的版本范围的最新兼容版本。这些范围使用语义化版本控制（semver）约定，如^（兼容的小版本）、~（兼容的补丁版本）或确切的版本号（1.2.3）。NPM使用嵌套依赖树，确保每个包获得其依赖的确切版本。</p> 
 <p><img src="https://images2.imgbox.com/30/69/k2oV0klr_o.png" alt="6221618a3261359f49fff1c50982e2ff.png"></p> 
 <p>NPM的优势与劣势</p> 
 <p>优势：</p> 
 <ul><li><p>广泛的支持 — NPM托管着世界上最大的JavaScript包注册中心。</p></li><li><p>简化的依赖管理 — NPM以最简化的方式自动化查找、安装和管理依赖的过程。</p></li><li><p>易于使用 — NPM设置和使用简单，对所有技能级别的开发者都易于接入。</p></li></ul> 
 <p>劣势：</p> 
 <ul><li><p>磁盘空间 — 由于NPM使用嵌套依赖树方法保存包，如果不同的依赖需要它们，它需要更多的磁盘空间来保存同一包的多个副本。</p></li><li><p>依赖膨胀 — 如果依赖/包在长期内没有得到适当管理，可能会导致不必要地积累大量包，这可能会增加项目的大小并潜在引入兼容性问题。</p></li><li><p>性能 — 与其他包管理器相比，特别是对于有许多依赖的较大项目，NPM的安装可能会更慢，因为它顺序下载包。</p></li></ul> 
 <p>尽管存在一些劣势，但NPM通过不断的更新和改进，成功解决了许多早期的问题，并继续为广大JavaScript开发者提供强大的依赖管理和包安装服务。对于大多数项目和开发者而言，NPM依然是包管理的。</p> 
 <h2>3、Yarn：超越NPM的现代JavaScript包管理器</h2> 
 <p><img src="https://images2.imgbox.com/54/61/lN3ou9TX_o.jpg" alt="4761da41aed1438e036a05fa7850cf35.jpeg"></p> 
 <p>Yarn（Yet Another Resource Negotiator），虽然这个名称听起来有些神秘，实际上它是由Facebook开发的一个Node包管理器，旨在解决当时NPM面临的一些问题。最初，NPM缺乏对依赖版本精确控制和锁文件概念的支持，这正是Yarn诞生的原因。与NPM在功能上有很多相似之处，但Yarn在某些方面提供了更多的优势。<br></p> 
 <p>Yarn的工作方式</p> 
 <ul><li><p>使用yarn init命令初始化一个项目，这会在项目中生成一个package.json文件。</p></li><li><p>通过命令yarn add &lt;package_name&gt;添加任何包。</p></li><li><p>如果你有一个预配置的项目，并且想要安装依赖，可以运行yarn install命令，这将从NPM注册中心下载所有依赖并生成一个锁文件。</p></li></ul> 
 <p>Yarn的优点</p> 
 <ul><li><p>更快的安装速度：与NPM相比，Yarn在安装包时可以并行执行，从而加快了安装速度。</p></li><li><p>离线支持：Yarn利用本地缓存加速安装过程。它在全局位置存储包的缓存，可以在不同项目之间共享，这样不仅提高了速度，还实现了NPM所没有的离线支持功能。使用yarn cache dir命令可以查看Yarn保存其包缓存的目录。</p></li><li><p>更少的磁盘使用：Yarn采用平级依赖结构，避免了包的重复和嵌套，从而最小化了磁盘使用。</p></li><li><p>Monorepo支持：Yarn还旨在通过称为WORKSPACE的特性支持monorepo。Monorepo是一个单一的仓库，其中存在多个包，每个包都有自己的package.json。Yarn Workspaces通过从中心位置安装所有包的依赖来简化依赖管理。</p></li></ul> 
 <p>Yarn的劣势</p> 
 <ul><li><p>较少成熟的生态系统：虽然Yarn正在获得越来越多的关注，但NPM有着更长的历史和更广泛的社区支持。</p></li><li><p>有限的原生模块支持：可能不兼容一些依赖于NPM特定功能的特性或包。</p></li><li><p>依赖NPM注册中心：尽管Yarn在依赖管理上效率很高，但它依然依赖于NPM注册中心下载包。如果NPM面临任何问题，Yarn也会间接受到影响。</p></li></ul> 
 <p>Yarn的出现标志着JavaScript包管理向前迈出的一大步。它不仅提高了包安装的速度和效率，还通过支持更先进的特性（如monorepo），为开发者社区带来了新的可能。尽管在某些方面它仍然依赖于NPM，但Yarn无疑为JavaScript开发者提供了一个强大而现代化的包管理选择。</p> 
 <h2>4、PNPM：高效节省磁盘空间的包管理器</h2> 
 <p><img src="https://images2.imgbox.com/34/e2/Y7qS2YAr_o.png" alt="0ba68f35e7585c2faff2524c20ac8e12.png"></p> 
 <p>PNPM，意为高性能的NPM，它旨在解决YARN和NPM出现的问题。PNPM通过引入一些与NPM和YARN相似却又具有明显改进的命令，为JavaScript项目的依赖管理带来了新的解决方案。</p> 
 <p>PNPM的工作方式</p> 
 <ul><li><p>pnpm init：初始化一个新项目，类似于npm init或yarn init。</p></li><li><p>pnpm install &lt;package_name&gt;：安装包及其依赖。</p></li><li><p>pnpm list：列出项目中安装的包。</p></li><li><p>pnpm remove &lt;package_name&gt;：移除一个包。</p></li><li><p>pnpm run &lt;script_name&gt;：运行package.json文件中定义的脚本。</p></li></ul> 
 <p>PNPM的优点</p> 
 <ul><li><p>磁盘效率：PNPM使用全局存储方法，所有包在一个地方全局存储，不像NPM或Yarn那样。安装包时，PNPM会从全局存储中链接文件到项目的node_modules，因此我们不需要在每个应用中重复存储包，这使得它在磁盘使用上非常高效。</p></li><li><p>锁文件：尽管PNPM使用非平面的内部结构，但它通过一个称为锁文件（通常命名为pnpm-lock.yaml）的文件提供了依赖项的“扁平化视图”。</p></li><li><p>更快更轻：与NPM或YARN相比，PNPM更快、更轻，因为它利用缓存，并不是每次都安装包。如果包在全局中找到，它将在该项目/应用的node_module中附加符号链接/硬链接。</p></li></ul> 
 <p>PNPM的劣势</p> 
 <ul><li><p>较新的选手：虽然PNPM更快，但它在市场上相对较新，没有太多人了解它，而NPM和YARN已经存在了很长时间。</p></li><li><p>有限的原生模块支持：可能存在一些与依赖于NPM特定功能的某些原生模块的兼容性问题。</p></li><li><p>对全局存储的依赖：PNPM的全局包存储提供了效率优势，但也可能引入潜在的管理开销。例如，你可能需要考虑如何处理清除全局存储或如果多个项目需要同一个包的不同版本时的冲突管理。</p></li></ul> 
 <p>PNPM通过其创新的全局存储和链接机制，提供了一个节省磁盘空间且性能出色的包管理方案。虽然它作为一个较新的选手可能在生态系统支持和原生模块兼容性方面存在一些挑战，但对于那些寻求更高效、更快速的依赖管理工具的开发者而言，PNPM无疑是一个值得尝试的选择。随着时间的推移和社区的支持，PNPM有潜力成为JavaScript开发者的又一重要工具。</p> 
 <h2>5、选择正确的工具：包管理器比较指南</h2> 
 <p><img src="https://images2.imgbox.com/c7/b8/cRdHVVpp_o.jpg" alt="a8a6ccde4bb6894025eb23acecee5ed1.jpeg"></p> 
 <p>在决定使用哪种包管理器时，考虑你的项目需求和个人偏好至关重要。下面是一个快速比较，帮助你做出选择：<br></p> 
 <ul><li><p>速度与效率优先：如果你的首要任务是安装速度和最小化磁盘使用，那么PNPM是一个极佳的选择，特别是对于大型项目。PNPM的全局存储和链接机制可以显著减少重复依赖的存储，使其在速度和磁盘效率上胜过其他选项。</p></li><li><p>成熟的生态系统：如果你需要接入更广泛的社区和丰富的资源库，NPM可能是更好的选择。NPM凭借其悠久的历史和庞大的用户基础，提供了丰富的包和广泛的支持。</p></li><li><p>复杂原生模块的兼容性：如果你的项目在很大程度上依赖于原生模块，NPM或Yarn可能会提供更好的兼容性。它们在这一领域的长期记录意味着更好的支持和稳定性。</p></li></ul> 
 <p>最终，最适合你的包管理器取决于你的具体需求和偏好。在做出任何决定之前，仔细权衡每个选项的优势和劣势。</p> 
 <h2>结束</h2> 
 <p>每个包管理器都有其独特的优点，比如PNPM在磁盘使用和速度上的优势，NPM在资源和社区支持上的丰富性，Yarn在性能和安全特性上的改进。选择正确的工具不仅可以提高开发效率，还可以确保项目在长期运行中的稳定性和兼容性。</p> 
 <p>当然，这并不意味着你必须严格限制自己只使用一种工具。在某些情况下，根据项目的不同阶段或特定需求，灵活切换或同时使用多种包管理器也是可行的策略。关键是理解每个工具的优缺点，以及它们如何最好地满足你的项目需求。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6839ea1421f14a9a4cc135b37bb3639f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Stable Diffusion安装（非秋叶包一键部署）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e83fb05dc426cb09b40d516779304810/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python Format()函数的用法___实例详解（一）(全，例多）___各种格式化替换，format对齐打印</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>