<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2024 前端高频面试题之 Vue 篇 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/d784f6d2dec1698850fe78ce9e71c0d3/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="2024 前端高频面试题之 Vue 篇">
  <meta property="og:description" content="Vue 篇（持续更新中） 1、v-for 和 v-if 可以混合使用吗？为什么？2、v-for 中为什么加 key？3、事件默认有个 event 参数，它是什么？怎么使用？事件被绑定到哪里？4、vue 父子组件如何通讯？5、父子组件声明周期调用顺序？6、vue 双向绑定原理（响应式原理）？7、$nextTick 是什么？为什么优先解决微任务？8、vuex 是什么？为什么使用？9、keep-alive 是什么？怎么实现的？生命周期？首次加载是先执行 activated 还是 deactivated，为什么？10、vue2 和 vue3 的区别？11、history 和 hash 路由实现原理？区别是什么？12、请说出常用的设计模式？（5 种以上）并举例实际项目中的使用场景。13、$emit 和 $on 的本质？14、虚拟 dom 是什么？原理？优缺点？15、mixin 是什么？优缺点？原理？vue3 用什么取代了？16、自定义指令？原理？17、事件绑定原理？18、$set 的原理？19、Vue3 比 Vue2 有什么优势？20、Vue3 声明周期21、Composition API 和 Options API22、如何理解 ref、toRef 和 toRefs23、为何 ref 需要 value 属性？24、Vue3 升级了哪些重要的功能？ 1、v-for 和 v-if 可以混合使用吗？为什么？ 可以，但是尽量不要同时使用，v-for计算优先级比v-if高，首先会把虚拟节点渲染出来，然后再进行v-if判断。降低渲染性能
2、v-for 中为什么加 key？ 如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 算法可以更准确、更快速
更准确：因为带 key 就不是就地复用了，在 sameNode 函数 a.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-17T23:35:36+08:00">
    <meta property="article:modified_time" content="2024-04-17T23:35:36+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2024 前端高频面试题之 Vue 篇</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Vue 篇（持续更新中）</h4> 
 <ul><li><ul><li><a href="#1vfor__vif__4" rel="nofollow">1、v-for 和 v-if 可以混合使用吗？为什么？</a></li><li><a href="#2vfor__key_8" rel="nofollow">2、v-for 中为什么加 key？</a></li><li><a href="#3_event__15" rel="nofollow">3、事件默认有个 event 参数，它是什么？怎么使用？事件被绑定到哪里？</a></li><li><a href="#4vue__22" rel="nofollow">4、vue 父子组件如何通讯？</a></li><li><a href="#5_42" rel="nofollow">5、父子组件声明周期调用顺序？</a></li><li><a href="#6vue__53" rel="nofollow">6、vue 双向绑定原理（响应式原理）？</a></li><li><a href="#7nextTick__63" rel="nofollow">7、$nextTick 是什么？为什么优先解决微任务？</a></li><li><a href="#8vuex__67" rel="nofollow">8、vuex 是什么？为什么使用？</a></li><li><a href="#9keepalive__activated__deactivated_78" rel="nofollow">9、keep-alive 是什么？怎么实现的？生命周期？首次加载是先执行 activated 还是 deactivated，为什么？</a></li><li><a href="#10vue2__vue3__124" rel="nofollow">10、vue2 和 vue3 的区别？</a></li><li><a href="#11history__hash__132" rel="nofollow">11、history 和 hash 路由实现原理？区别是什么？</a></li><li><a href="#125__156" rel="nofollow">12、请说出常用的设计模式？（5 种以上）并举例实际项目中的使用场景。</a></li><li><a href="#13emit__on__171" rel="nofollow">13、$emit 和 $on 的本质？</a></li><li><a href="#14_dom__178" rel="nofollow">14、虚拟 dom 是什么？原理？优缺点？</a></li><li><a href="#15mixin_vue3__194" rel="nofollow">15、mixin 是什么？优缺点？原理？vue3 用什么取代了？</a></li><li><a href="#16_214" rel="nofollow">16、自定义指令？原理？</a></li><li><a href="#17_234" rel="nofollow">17、事件绑定原理？</a></li><li><a href="#18set__238" rel="nofollow">18、$set 的原理？</a></li><li><a href="#19Vue3__Vue2__242" rel="nofollow">19、Vue3 比 Vue2 有什么优势？</a></li><li><a href="#20Vue3__251" rel="nofollow">20、Vue3 声明周期</a></li><li><a href="#21Composition_API__Options_API_267" rel="nofollow">21、Composition API 和 Options API</a></li><li><a href="#22_reftoRef__toRefs_279" rel="nofollow">22、如何理解 ref、toRef 和 toRefs</a></li><li><a href="#23_ref__value__299" rel="nofollow">23、为何 ref 需要 value 属性？</a></li><li><a href="#24Vue3__305" rel="nofollow">24、Vue3 升级了哪些重要的功能？</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h3><a id="1vfor__vif__4"></a>1、v-for 和 v-if 可以混合使用吗？为什么？</h3> 
<p><strong>可以，但是尽量不要同时使用</strong>，<code>v-for</code>计算优先级比<code>v-if</code>高，首先会把虚拟节点渲染出来，然后再进行<code>v-if</code>判断。降低渲染性能</p> 
<h3><a id="2vfor__key_8"></a>2、v-for 中为什么加 key？</h3> 
<p>如果不使用 <code>key</code>，<code>Vue</code> 会使用一种最大限度减少动态元素并且尽可能的尝试<code>就地修改/复用</code>相同类型元素的算法。<strong>key</strong> 是为 <code>Vue</code> 中 <code>vnode</code> 的唯一标记，通过这个 <code>key</code>，<code>diff</code> 算法可以<strong>更准确、更快速</strong><br></p> 
<ul><li><strong>更准确</strong>：因为带 <code>key</code> 就不是就地复用了，在 <code>sameNode</code> 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。</li><li><strong>更快速</strong>：利用 <code>key</code> 的唯一性生成 <code>map</code> 对象来获取对应节点，比遍历方式更快</li></ul> 
<h3><a id="3_event__15"></a>3、事件默认有个 event 参数，它是什么？怎么使用？事件被绑定到哪里？</h3> 
<p>当事件没有参数，则默认有个 <code>event</code> 参数；如果有自定义参数，则需要使用<code>$event</code> 传过去。</p> 
<ul><li><code>event</code> 的构造函数是 <code>MouseEvent</code>，即是原生的 <code>event</code> 对象</li><li><code>event</code> 被挂载到当前元素下，即 <code>event.target</code></li></ul> 
<h3><a id="4vue__22"></a>4、vue 父子组件如何通讯？</h3> 
<ul><li><strong>props、$emit：</strong> <br><br> 父组件使用动态数据传递，子组件使用<code>props</code>接收，可以使用数组/对象数据结构，对象结构可以定义类型和默认值。<br><br> 子组件使用<code>$emit</code> 事件回传<br></li><li><strong>自定义事件进行组件通讯</strong>：<br><br> 自定义事件就是使用一个额外的 <code>js</code> 文件，其中声明一个 <code>Vue</code> 实例即可<br><br> <code>$on</code>，<code>$emit</code>，<code>$off</code>，参数分别是：注册函数名，真实函数<br><br> <strong>$on</strong>：绑定自定义事件<br><br> <strong>$emit</strong>：调用自定义事件<br><br> <strong>$off</strong>：在组件销毁时，要及时销毁自定义事件，否则可能会造成内存泄漏。在 <code>beforeDestroy</code> 中调用<code>$off</code><br></li><li><strong>$refs</strong>：<br><br> 获取当前组件实例</li><li><strong>$parent&amp;$children</strong>：<br><br> 获取当前组件的父组件和子组件</li><li><strong>vuex</strong>：<br><br> Vue 中全局状态管理系统，用于多个组件中数据共享。</li><li><strong>provide&amp;inject</strong>：<br><br> 上层组件提供，下层组件注入使用。（适用于组件库编写）</li></ul> 
<h3><a id="5_42"></a>5、父子组件声明周期调用顺序？</h3> 
<ul><li><strong>加载渲染过程</strong>：<br><br> 父<code>beforeCreate</code> -&gt; 父<code>created</code> -&gt; 父<code>beforeMount</code> -&gt; 子<code>beforeCreate</code> -&gt; 子<code>created</code> -&gt; 子<code>beforeMount</code> -&gt; 子<code>mounted</code> -&gt; 父<code>mounted</code></li><li><strong>更新过程</strong>：<br><br> 父<code>beforeUpdate</code> -&gt; 子<code>beforeUpdate</code> -&gt; 子<code>updated</code> -&gt; 父<code>updated</code></li><li><strong>销毁过程</strong>：<br><br> 父<code>beforeDestroy</code> -&gt; 子<code>beforeDestroy</code> -&gt; 子<code>destroyed</code> -&gt; 父<code>destroyed</code></li><li><strong>全流程</strong>：<br><br> <code>beforeCreate</code> -&gt; <code>created</code> -&gt; <code>beforeMount</code> -&gt; <code>mounted</code> -&gt; <code>beforeUpdate</code> -&gt; <code>updated</code> -&gt; <code>beforeDestroy</code> -&gt; <code>destroyed</code></li></ul> 
<h3><a id="6vue__53"></a>6、vue 双向绑定原理（响应式原理）？</h3> 
<p><strong>采用数据劫持结合观察者模式的方式</strong><br><br> 通过 Object.defineProperty()来劫持各个属性（只会劫持已经存在的属性）的 <code>setter</code>，<code>getter</code>，<code>dep</code> 和 <code>Watcher</code> 实现依赖收集和派发更新的过程：</p> 
<ul><li><code>vue</code> 将 <code>data</code> 初始化为一个 <code>Observer</code> 并对对象中的每个值，重写了其中的 <code>get</code>、<code>set</code>，<code>data</code> 中的每个 <code>key</code>，都有一个独立的 <code>dep</code>（依赖收集器）。</li><li>在 <code>get</code> 中，向 <code>dep</code>（依赖收集器）添加了监听</li><li>在 <code>mount</code> 时，实例了一个 <code>Watcher</code>，将收集器的目标指向了当前 <code>Watcher</code></li><li>在 <code>data</code> 值发生变更时，触发 <code>set</code>，触发了 <code>dep</code>（依赖收集器）中的所有监听的更新，来触发 <strong>Watcher.update</strong></li></ul> 
<h3><a id="7nextTick__63"></a>7、$nextTick 是什么？为什么优先解决微任务？</h3> 
<p><code>nextTick</code> 中的回调是在下次 <code>DOM</code> 更新循环结束之后执行的延迟回调。在修改数据之后立即使用这个方法，获取更新后的 <code>DOM</code>。主要思路就是采用微任务优先的方式调用异步方法去执行 <code>nextTick</code> 包装的方法</p> 
<h3><a id="8vuex__67"></a>8、vuex 是什么？为什么使用？</h3> 
<p><code>vuex</code> 是专门为 <code>vue</code> 提供的全局状态管理系统，用于多个组件中数据共享、数据缓存等。（无法持久化、内部核心原理是通过创造一个全局实例 new Vue）<br> 主要包括以下几个模块：</p> 
<ul><li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li><li>Getter：允许组件从 <code>Store</code> 中获取数据，<code>mapGetters</code> 辅助函数仅仅是将 <code>store</code> 中的 <code>getter</code> 映射到局部计算属性。</li><li>Mutation：是唯一更改 <code>store</code> 中状态的方法，且必须是同步函数。</li><li>Action：用于提交 <code>mutation</code>，而不是直接变更状态，可以包含任意异步操作。</li><li>Module：允许将单一的 <code>Store</code> 拆分为多个 <code>store</code> 且同时保存在单一的状态树中。</li></ul> 
<h3><a id="9keepalive__activated__deactivated_78"></a>9、keep-alive 是什么？怎么实现的？生命周期？首次加载是先执行 activated 还是 deactivated，为什么？</h3> 
<p><strong>作用与用法：</strong><br></p> 
<p>开发中缓存组件使用 <code>keep-alive</code> 组件，<code>keep-alive</code> 是 vue 内置组件，<code>keep-alive</code> 包裹动态组件 <code>component</code> 时，会缓存不活动的组件实例，而不是销毁它们，这样在组件切换过程中将状态保留在内存中，防止重复渲染 <code>DOM</code>。<br></p> 
<p><strong>使用细节：</strong><br></p> 
<p>结合属性 <code>include</code> 和 <code>exclude</code> 可以明确指定缓存哪些组件或排除缓存指定组件。<code>vue3</code> 中结合 <code>vue-router</code> 时变化较大，之前是 <code>keep-alive</code> 包裹 <code>router-view</code>，现在需要反过来用 <code>router-view</code> 包裹 <code>keep-alive</code>。<br></p> 
<p><code>keep-alive</code> 的中缓存的时候还运用了 <strong>LRU(Least Recently Used)</strong> 算法。<br></p> 
<p><strong>LRU(最近最少使用) 缓存机制：</strong><br></p> 
<p>如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code>。如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组<code>「关键字-值」</code>。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间<br></p> 
<p><strong>组件缓存后更新，解决方案可以有以下两种：</strong></p> 
<ul><li>beforeRouteEnter：在有 <code>vue-router</code> 的项目，每次进入路由的时候，都会执行 <code>beforeRouteEnter</code>。</li><li>activated：在 <code>keep-alive</code> 缓存的组件被激活的时候，都会执行 <code>activated</code> 钩子。</li></ul> 
<p><strong>原理：</strong><br></p> 
<p><code>keep-alive</code> 是一个通用组件，它内部定义了一个 <code>map</code>，缓存创建过的组件实例，它返回的渲染函数内部会查找内嵌的 <code>component</code> 组件对应组件的 <code>vnode</code>，如果该组件在 <code>map</code> 中存在就直接返回它。由于 <code>component</code> 的 <code>is</code> 属性是个响应式数据，因此只要它变化，<code>keep-alive</code> 的 <code>render</code> 函数就会重新执行。<br></p> 
<p><strong>参数：</strong><br></p> 
<p>keep-alive 接收三个参数：</p> 
<ul><li>include：可传字符串、正则表达式、数组，名称匹配成功的组件会被缓存</li><li>exclude：可传字符串、正则表达式、数组，名称匹配成功的组件不会被缓存</li><li>max：可传数字，限制缓存组件的最大数量，超过 max 则按照 LRU 算法进行置换</li></ul> 
<p><strong>include 和 exclude，传数组情况居多。</strong><br></p> 
<p><strong>生命周期：</strong><br></p> 
<p>生命周期有：activated 激活、deactivated 离开</p> 
<ul><li>activated： 页面第一次进入的时候，钩子触发的顺序是 created -&gt; mounted -&gt; activated</li><li>deactivated: 页面退出的时候会触发 deactivated</li></ul> 
<p><strong>当再次前进或者后退的时候只触发 <code>activated</code>。</strong><br></p> 
<p>使用 <code>keep-alive</code> 会将数据保留在<strong>内存中</strong>，如果要在每次进入页面的时候获取最新的数据，需要在 <code>activated</code> 阶段获取数据，承担原来 <code>created</code> 钩子中获取数据的任务。那么，我们一般会在动态组件、路由组件去用到 <code>keep-alive </code>组件。</p> 
<h3><a id="10vue2__vue3__124"></a>10、vue2 和 vue3 的区别？</h3> 
<ul><li>响应式系统：vue2 是 Object.defineProperty()；vue3 使用的是 proxy</li><li>vue3 全部由 ts 重构，对 ts 支持更友好</li><li>自定义渲染器</li><li>composition API</li><li>vue3 可以存在多个根节点，vue2 只能有一个</li></ul> 
<h3><a id="11history__hash__132"></a>11、history 和 hash 路由实现原理？区别是什么？</h3> 
<p><strong>hash 模式</strong><br></p> 
<ul><li>1.<strong>location.hash</strong> 的值实际就是 <code>URL</code> 中 <strong>#</strong> 后面的东西 它的特点在于：<code>hash</code> 虽然出现 <code>URL</code> 中，但不会被包含在 <code>HTTP</code> 请求中，对后端完全没有影响，因此改变 <code>hash</code> 不会重新加载页面。</li><li>2.可以为 <code>hash</code> 的改变添加监听事件</li></ul> 
<pre><code class="prism language-javascript">window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"hashchange"</span><span class="token punctuation">,</span> funcRef<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>每一次改变 hash（window.location.hash），都会在浏览器的访问历史中增加一个记录。<br><br> 利用 hash 的以上特点，就可以来实现前端路由 <strong>“更新视图但不重新请求页面”</strong> 的功能了<br></p> 
<blockquote> 
 <p>特点：兼容性好但是不美观</p> 
</blockquote> 
<p><strong>history 模式</strong><br></p> 
<p>利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。<br></p> 
<p>这两个方法应用于浏览器的历史记录站，在当前已有的 <code>back</code>、<code>forward</code>、<code>go</code> 的基础之上，它们提供了对历史记录进行修改的功能。这两个方法有个共同的特点：当调用他们修改浏览器历史记录栈后，虽然当前 <code>URL</code> 改变了，但浏览器不会刷新页面，这就为单页应用前端路由 <strong>“更新视图但不重新请求页面”</strong> 提供了基础。</p> 
<blockquote> 
 <p>特点：虽然美观，但是刷新会出现 404 需要后端进行配置</p> 
</blockquote> 
<h3><a id="125__156"></a>12、请说出常用的设计模式？（5 种以上）并举例实际项目中的使用场景。</h3> 
<ul><li> <p>1.工厂模式 - 传入参数即可创建实例</p> <p>虚拟 DOM 根据参数的不同返回基础标签的 Vnode 和组件 Vnode</p> </li><li> <p>2.单例模式 - 整个程序有且仅有一个实例</p> <p><code>vuex</code> 和 <code>vue-router</code> 的插件注册方法 <code>install</code> 判断如果系统存在实例就直接返回掉</p> </li><li> <p>3.观察者模式 (响应式数据原理)</p> </li><li> <p>4.策略模式 策略模式指对象有某个行为,但是在不同的场景中,该行为有不同的实现方案-比如选项的合并策略</p> </li><li> <p>5.策略模式：优化 if else 冗余代码</p> </li><li> <p>6.代理模式：mini-vue proxy</p> </li></ul> 
<h3><a id="13emit__on__171"></a>13、$emit 和 $on 的本质？</h3> 
<ul><li>1.<code>$on</code>、<code>$emit</code> 基于发布订阅模式</li><li>2.<code>$on</code> 用来收集所有的事件依赖，他会将传入的参数 <code>event</code> 和 <code>fn</code> 作为 <code>key</code> 和 <code>value</code> 的形式存到 <code>vm._events</code> 这个事件集合里，就像这样 <code>vm._events[event]=[fn]</code>;</li><li>3.而 <code>$emit</code> 是用来触发事件的，他会根据传入的 <code>event</code> 在 <code>vm_events</code> 中找到对应的事件并执行 <code>invokeWithErrorHandling(cbs[i], vm, args, vm, info)</code></li><li>4.最后我们看 <code>invokeWithErrorHandling</code> 方法可以发现，他是通过 <code>handler.apply(context, args)</code> 和 <code>handler.call(context)</code> 的形式执行对应的方法</li></ul> 
<h3><a id="14_dom__178"></a>14、虚拟 dom 是什么？原理？优缺点？</h3> 
<p>用 js 模拟一颗 dom 树,放在浏览器内存中.当你要变更时,虚拟 dom 使用 diff 算法进行新旧虚拟 dom 的比较,将变更放到变更队列中,反应到实际的 dom 树,减少了 dom 操作。<br><br> 虚拟 DOM 将 DOM 树转换成一个 JS 对象树,diff 算法逐层比较,删除,添加操作,但是,如果有多个相同的元素,可能会浪费性能,所以,react 和 vue-for 引入 key 值进行区分。<br></p> 
<p><strong>优点：</strong><br></p> 
<ul><li><strong>保证性能下限：</strong> 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li><li><strong>无需手动操作 DOM：</strong> 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li><li><strong>跨平台：</strong> 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等。</li></ul> 
<p><strong>缺点:</strong><br></p> 
<p><strong>无法进行极致优化：</strong> 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。<br> 首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。</p> 
<h3><a id="15mixin_vue3__194"></a>15、mixin 是什么？优缺点？原理？vue3 用什么取代了？</h3> 
<p>组件和组件之间有时候会存在相同的代码逻辑，分为<strong>局部混入</strong>和<strong>全局混入</strong>，我们希望对<strong>相同的代码逻辑进行抽取</strong></p> 
<ul><li>Mixin 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能</li><li>一个 Mixin 对象可以包含任何组件选项 — 其本质就是一个对象</li><li>当组件使用 Mixin 对象时，所有 Mixin 对象的选项将被 混入该组件本身的选项中</li></ul> 
<p><strong>缺点：</strong><br></p> 
<ul><li>变量来源不明确，不利于阅读</li><li>多 mixin 可能会造成命名冲突</li><li>mixin 和组件可能出现多对多的关系，复杂度较高</li></ul> 
<p>Vue3 使用 Composition API 替代了，优点：</p> 
<ul><li>代码提取</li><li>代码重用</li><li>命名冲突解决</li></ul> 
<h3><a id="16_214"></a>16、自定义指令？原理？</h3> 
<p>Vue 自定义指令有<strong>全局注册</strong>和<strong>局部注册</strong>两种方式。先来看看注册全局指令的方式，通过 <code>Vue.directive(id, [definition])</code> 方式<strong>注册全局指令</strong>。然后在入口文件中进行 Vue.use() 调用。<br><br> 它的作用价值在于当开发人员在某些场景下需要对普通 DOM 元素进行操作。提高代码复用。<br><br> 指令本质上是装饰器，是 vue 对 HTML 元素的扩展，给 HTML 元素增加自定义功能。vue 编译 DOM 时，会找到指令对象，执行指令的相关方法。<br><br> 自定义指令有五个生命周期（也叫钩子函数），分别是 <code>bind</code>、<code>inserted</code>、<code>update</code>、<code>componentUpdated</code>、<code>unbind</code></p> 
<ul><li>1.bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li><li>2.inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li><li>3.update：被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。</li><li>4.componentUpdated：被绑定元素所在模板完成一次更新周期时调用。</li><li>5.unbind：只调用一次，指令与元素解绑时调用。</li></ul> 
<p><strong>原理</strong><br></p> 
<ul><li>1.在生成 ast 语法树时，遇到指令会给当前元素添加 directives 属性</li><li>2.通过 genDirectives 生成指令代码</li><li>3.在 patch 前将指令的钩子提取到 cbs 中,在 patch 过程中调用对应的钩子</li><li>4.当执行指令对应钩子函数时，调用对应指令定义的方法</li></ul> 
<h3><a id="17_234"></a>17、事件绑定原理？</h3> 
<p>$on、$emit 是基于发布订阅模式的，维护一个事件中心，on 的时候将事件按名称存在事件中心里，称之为订阅者，然后 emit 将对应的事件进行发布，去执行事件中心里的对应的监听器</p> 
<h3><a id="18set__238"></a>18、$set 的原理？</h3> 
<p>因为响应式数据 我们给对象和数组本身都增加了 <code>__ob__</code> 属性，代表的是 Observer 实例。当给对象新增不存在的属性 首先会把新的属性进行响应式跟踪 然后会触发对象 <code>__ob__</code> 的 <code>dep</code> 收集到的 <code>watcher</code> 去更新，当修改数组索引时我们调用数组本身的 <code>splice</code> 方法去更新数组</p> 
<h3><a id="19Vue3__Vue2__242"></a>19、Vue3 比 Vue2 有什么优势？</h3> 
<ul><li>1.性能更好</li><li>2.体积更小</li><li>3.更好的 TS 支持</li><li>4.更好的代码组织</li><li>5.更好的逻辑抽离</li><li>6.更多新功能</li></ul> 
<h3><a id="20Vue3__251"></a>20、Vue3 声明周期</h3> 
<ul><li>Options API 
  <ul><li>1.beforeDestroy 改为 beforeUnmount</li><li>2.destroyed 改为 unmounted</li><li>3.其他沿用 Vue2 的生命周期</li></ul> </li><li>Composition API<br><br> <code>setup</code> 相当于整合了 <code>beforeCreate</code> 和 <code>created</code><br><br> 其余生命周期分别是写在 <code>setup</code> 中的函数：<br> 
  <ul><li>1.onBeforeMount()</li><li>2.onMounted()</li><li>3.onBeforeUpdate()</li><li>4.onUpdated()</li><li>5.onBeforeUnmount()</li><li>6.onUnmounted()</li></ul> </li></ul> 
<h3><a id="21Composition_API__Options_API_267"></a>21、Composition API 和 Options API</h3> 
<ul><li>1.更好的代码组织</li><li>2.更好的逻辑复用</li><li>3.更好的类型推导</li></ul> 
<p><strong>如何选择？</strong><br></p> 
<ul><li>1.不建议共用，会引起混乱</li><li>2.小型项目、业务逻辑简单，用 options API</li><li>3.中大型项目、逻辑复杂，用 composition API</li></ul> 
<h3><a id="22_reftoRef__toRefs_279"></a>22、如何理解 ref、toRef 和 toRefs</h3> 
<p><strong>ref：</strong><br></p> 
<ul><li>1.生成值类型的响应式数据</li><li>2.可用于模版和 reactive</li><li>3.通过<code>.value</code> 修改值</li></ul> 
<p><strong>toRef：</strong><br></p> 
<ul><li>1.针对一个响应式对象（reactive 封装）的 prop</li><li>2.创建一个 ref，具有响应式</li><li>3.两者保持引用关系</li></ul> 
<p><strong>toRefs：</strong><br></p> 
<ul><li>1.将响应式对象（reactive 封装）转换为普通对象</li><li>2.对象的每个 prop 都是对应的 ref（不然 reactive 响应式直接解构会失去响应式）</li><li>3.两者保持引用关系</li></ul> 
<h3><a id="23_ref__value__299"></a>23、为何 ref 需要 value 属性？</h3> 
<ul><li>1.ref 是一个对象（不丢失响应式，值类型不能用 proxy 代理），value 储存值</li><li>2.通过 <code>.value</code> 属性的 <code>get</code> 和 <code>set</code> 实现响应式</li><li>3.用于模版、reactive 时，不需要 <code>.value</code>，其他情况都需要</li></ul> 
<h3><a id="24Vue3__305"></a>24、Vue3 升级了哪些重要的功能？</h3> 
<ul><li>1.createApp</li><li>2.emits 属性：在子组件中声明 <code>emits</code> <code>options</code> 父组件的绑定事件</li><li>3.生命周期：使用 <code>setup</code> 整合 <code>beforeCreate</code> 和 <code>created``，beforeDestroy</code> 改为 <code>beforeUnmount</code>，<code>destroyed</code> 改为 <code>unmounted</code>，其他与 vue2 一致</li><li>4.多事件处理：在点击事件中写入多个处理函数，用逗号分割</li><li>5.Fragment：可以存放多个根节点</li><li>6.移除 <code>.sync</code></li><li>7.异步组件的写法：需要从 Vue 引入 <code>defineAsyncComponent</code>，使用这个函数包裹 import() 引入异步组件</li><li>8.移除 filter：双括号中用 | 分割转换含义</li><li>9.Teleport：主要场景就是把组件的嵌套层级提高</li><li>10.Suspense：用来加载异步组件未成功时的一些 <code>loading</code>，主要实现原理就是具名插槽</li><li>11.Composition API</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3e923e9638927971effba37d1a4e1951/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数据结构与算法】：关于时间复杂度与空间复杂度的计算（C/C&#43;&#43;篇）——含Leetcode刷题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6cb7079fef5320bdbc4dd0b7df892baf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端实现Excel文件导出功能的完整指南（vue实现excel文件导出功能）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>