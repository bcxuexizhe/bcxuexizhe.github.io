<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【链表OJ】链表中倒数第k个结点 合并两个链表(含哨兵位) 分割链表 链表的回文结构 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/b04f93d6d15fb976adffa9b0b5698494/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【链表OJ】链表中倒数第k个结点 合并两个链表(含哨兵位) 分割链表 链表的回文结构">
  <meta property="og:description" content="前言:
💥🎈个人主页:​​​​​​Dream_Chaser～ 🎈💥
✨✨刷题专栏:http://t.csdn.cn/UlvTc
⛳⛳本篇内容:力扣和牛客上链表OJ题目
目录
一、链表中倒数第k个结点
题目描述:
解题思路:
二.合并两个链表(含哨兵位) 题目描述:
解题思路: 不含哨兵位
三.分割链表 题目描述:
解题思路:
四.链表的回文结构
题目描述:
解题思路:
一、链表中倒数第k个结点 来源:链表中倒数第k个结点_牛客题霸_牛客网 (nowcoder.com)
题目描述: 输入一个链表，输出该链表中倒数第k个结点。
示例:
输入:1,{1,2,3,4,5}
返回值:{5}
解题思路: 创建两个指针，一个名为fast(快指针),另一个则是slow(慢指针),同时把头结点的地址赋值给二者，也就意味着两个指针同时指向头结点。通过传参传过来的参数k的含义是该链表中倒数的第k个结点进入第一个while循环中，k--多少次也就意味着fast指针先走k步接着进入第二个while循环，以fast!=NULL为循环的条件接着两指针一起走相同的步数,待fast指向NULL结束，此时正好是slow指向的链表中倒数第k个结点返回slow指针 struct ListNode* FindKthToTail(struct ListNode* pListHead, int k ) { struct ListNode* fast = pListHead, * slow = pListHead; while (k--) { if (fast == NULL)// 快慢指针同时移动，直到快指针到达链表末尾 { return NULL; } fast = fast-&gt;next; } while (fast) { slow = slow-&gt;next; fast = fast-&gt;next; } return slow;// 返回慢指针所指向的节点 } 动图解析: 执行:">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-08-15T09:24:31+08:00">
    <meta property="article:modified_time" content="2023-08-15T09:24:31+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【链表OJ】链表中倒数第k个结点 合并两个链表(含哨兵位) 分割链表 链表的回文结构</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>前言:</p> 
<blockquote> 
 <p>💥🎈个人主页:<a href="https://blog.csdn.net/weixin_65186652?type=blog" title="​​​​​​Dream_Chaser～">​​​​​​Dream_Chaser～</a> 🎈💥</p> 
 <p>✨✨刷题专栏:<a href="http://t.csdn.cn/UlvTc" rel="nofollow" title="http://t.csdn.cn/UlvTc">http://t.csdn.cn/UlvTc</a></p> 
 <p>⛳⛳本篇内容:力扣和牛客上链表OJ题目</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%C2%A0%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9" rel="nofollow"> 一、链表中倒数第k个结点</a></p> 
<p id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%3A-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%3A" rel="nofollow">题目描述:</a></p> 
<p id="%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%3A-toc" style="margin-left:40px;"><a href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%3A" rel="nofollow">解题思路:</a></p> 
<p id="%E4%BA%8C.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8(%E5%90%AB%E5%93%A8%E5%85%B5%E4%BD%8D)%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%28%E5%90%AB%E5%93%A8%E5%85%B5%E4%BD%8D%29%C2%A0" rel="nofollow">二.合并两个链表(含哨兵位) </a></p> 
<p id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%3A-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%3A" rel="nofollow">题目描述:</a></p> 
<p id="%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%3A%C2%A0-toc" style="margin-left:40px;"><a href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%3A%C2%A0" rel="nofollow">解题思路: </a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%E4%B8%8D%E5%90%AB%E5%93%A8%E5%85%B5%E4%BD%8D-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%E4%B8%8D%E5%90%AB%E5%93%A8%E5%85%B5%E4%BD%8D" rel="nofollow">                                           不含哨兵位</a></p> 
<p id="%E4%B8%89.%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8%C2%A0" rel="nofollow">三.分割链表 </a></p> 
<p id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%3A-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%3A" rel="nofollow">题目描述:</a></p> 
<p id="%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%3A-toc" style="margin-left:40px;"><a href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%3A" rel="nofollow">解题思路:</a></p> 
<p id="%E5%9B%9B.%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#%E5%9B%9B.%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84" rel="nofollow">四.链表的回文结构</a></p> 
<p id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%3A-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%3A" rel="nofollow">题目描述:</a></p> 
<p id="%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%3A-toc" style="margin-left:40px;"><a href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%3A" rel="nofollow">解题思路:</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%C2%A0%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9"> 一、链表中倒数第k个结点</h2> 
<p>来源:<a href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;&amp;tqId=11167&amp;rp=2&amp;ru=/activity/oj&amp;qru=/ta/coding-interviews/question-ranking" rel="nofollow" title="链表中倒数第k个结点_牛客题霸_牛客网 (nowcoder.com)">链表中倒数第k个结点_牛客题霸_牛客网 (nowcoder.com)</a></p> 
<h3 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%3A"><strong>题目描述:</strong></h3> 
<blockquote> 
 <p>输入一个链表，输出该链表中倒数第k个结点。</p> 
</blockquote> 
<p>示例:</p> 
<blockquote> 
 <p><strong>输入</strong>:1,{1,2,3,4,5}</p> 
 <p><strong>返回值</strong>:{5}</p> 
</blockquote> 
<h3 id="%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%3A">解题思路:</h3> 
<ol><li>创建两个指针，一个名为<strong>fast(快指针)</strong>,另一个则是<strong>slow(慢指针)</strong>,同时把头结点的地址赋值给二者，也就意味着两个指针同时指向头结点。</li><li>通过传参传过来的参数k的含义是该链表中<strong>倒数的第k个结点</strong></li><li>进入第一个while循环中，k--多少次也就意味着fast指针先走k步</li><li>接着进入第二个while循环，以fast!=NULL为循环的条件</li><li>接着两指针一起走相同的步数,待fast指向NULL结束，此时正好是slow指向的链表中倒数第k个结点</li><li>返回slow指针</li></ol> 
<pre><code class="language-cpp">struct ListNode* FindKthToTail(struct ListNode* pListHead, int k ) {
    struct ListNode* fast = pListHead, * slow = pListHead;
    while (k--)
    {
        if (fast == NULL)// 快慢指针同时移动，直到快指针到达链表末尾
        {
            return NULL;
        }
        fast = fast-&gt;next;
    }
     while (fast)
    {
        slow = slow-&gt;next;
        fast = fast-&gt;next;
    }
    return slow;// 返回慢指针所指向的节点
}</code></pre> 
<blockquote> 
 <p> 动图解析: <img alt="" src="https://images2.imgbox.com/cd/09/UlcX406x_o.gif"></p> 
</blockquote> 
<p>执行:</p> 
<p><img alt="" height="243" src="https://images2.imgbox.com/9b/89/jRg8nsor_o.png" width="843"></p> 
<h2 id="%E4%BA%8C.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8(%E5%90%AB%E5%93%A8%E5%85%B5%E4%BD%8D)%C2%A0">二.合并两个链表(含哨兵位) </h2> 
<p>此题来源:<strong><a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/" rel="nofollow" title="21. 合并两个有序链表 - 力扣（LeetCode）">21. 合并两个有序链表 - 力扣（LeetCode）</a></strong></p> 
<h3><strong>题目描述:</strong></h3> 
<blockquote> 
 <p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p> 
</blockquote> 
<p>示例1:</p> 
<p><strong>输入</strong>:</p> 
<blockquote> 
 <p>l1 = [1,2,4], l2 = [1,3,4]</p> 
</blockquote> 
<p> <strong>输出</strong>:</p> 
<blockquote> 
 <p>[1,1,2,3,4,4]</p> 
</blockquote> 
<p><img alt="" height="421" src="https://images2.imgbox.com/9e/f5/SPftYPeD_o.png" width="886"></p> 
<h3 id="%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%3A%C2%A0">解题思路: </h3> 
<p>主要思路跟这篇的思路相差不大</p> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%E4%B8%8D%E5%90%AB%E5%93%A8%E5%85%B5%E4%BD%8D"><strong><span style="background-color:#ffd900;">不含哨兵位</span></strong></h4> 
<p>二级指针解法请看-&gt;<a href="https://blog.csdn.net/weixin_65186652/article/details/132161992?spm=1001.2014.3001.5501" title="【链表OJ 5】合并两个有序链表_Dream_Chaser～的博客-CSDN博客">【链表OJ 5】合并两个有序链表_Dream_Chaser～的博客-CSDN博客</a></p> 
<p><strong>唯一区别如下:</strong></p> 
<p>首先,malloc一个哨兵位的头节点,</p> 
<p>接着创建两个指针:head和tail，并让它们指向哨兵位的头节点。</p> 
<p><strong>注意:</strong></p> 
<p>        此头结点不存储任何数据，使用时不用判断tail指针指向的结点是否为NULL，因为tail指向的哨兵位绝对不为NULL，添加时只需要在哨兵位的头节点后面链接上新结点即可。</p> 
<p>        最后记得销毁掉这个头节点。</p> 
<pre><code class="language-cpp">struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2)
{
   if(list1==NULL)
      return list2;
   if(list2 ==NULL)
      return list1;
   struct ListNode*head=NULL,*tail=NULL;
   head=tail=(struct ListNode*)malloc(sizeof(struct ListNode));
   while(list1 &amp;&amp; list2)
   {
     if(list1-&gt;val &lt; list2-&gt;val)
     {   //不用判断tail是否指向NULL，需要的时候直接在tail后面链接即可
         tail-&gt;next=list1;
         tail=tail-&gt;next;
         list1=list1-&gt;next;
     }
      else
      {
         tail-&gt;next=list2;
         tail=tail-&gt;next;
         list2=list2-&gt;next;
      }
   }
     if(list1)
     {
        tail-&gt;next=list1;
     }
     if(list2)
     {
       tail-&gt;next=list2;
     }
  
    //记得销毁哨兵位的头节点
     struct ListNode* del=head;
     head=head-&gt;next;
     free(del);
    return head;//链表的第一个有效的结点
 }</code></pre> 
<p>执行:</p> 
<p><img alt="" height="242" src="https://images2.imgbox.com/7c/48/LYECxeah_o.png" width="847"></p> 
<p></p> 
<h2 id="%E4%B8%89.%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8%C2%A0">三.分割链表 </h2> 
<p>来源:<a href="https://www.nowcoder.com/practice/0e27e0b064de4eacac178676ef9c9d70?tpId=8&amp;&amp;tqId=11004&amp;rp=2&amp;ru=/activity/oj&amp;qru=/ta/cracking-the-coding-interview/question-ranking" rel="nofollow" title="链表分割_牛客题霸_牛客网 (nowcoder.com)">链表分割_牛客题霸_牛客网 (nowcoder.com)</a></p> 
<h3>题目描述:</h3> 
<p>        现有一链表的头指针 ListNode* <strong>pHead</strong>，给一定值x，编写一段代码将所有小于x的结点排在其余结点之前，且不能改变原来的数据顺序，返回重新排列后的链表的头指针。</p> 
<p>示例:假定<span style="color:#fe2c24;"><strong>x为5</strong></span></p> 
<p><strong>输入</strong>:原链表顺序</p> 
<p><img alt="" height="108" src="https://images2.imgbox.com/a2/33/E3pT3fIy_o.png" width="1200"></p> 
<p><strong> 输出</strong>:返回链表<br><img alt="" height="244" src="https://images2.imgbox.com/dd/07/wceBB5zt_o.png" width="1200"></p> 
<h3 style="background-color:transparent;">解题思路:</h3> 
<p>1.创建两个带头结点(<span style="color:#fe2c24;"><strong>这题一定要含哨兵位，不然很麻烦</strong></span>)的单链表</p> 
<p>        1️⃣lesshead:指向比x值小的链表的哨兵位(第一个链表)</p> 
<p>        2️⃣lesstail：用于遍历第一个链表(比x小的)，以及链接比x值小的结点，最后待cur指向NULL时，链接到greaterhead，将两个链表链接起来</p> 
<p>        3️⃣greaterhead:指向比x值大的链表的哨兵位(第二个链表),与lesstail链接起来</p> 
<p>        4️⃣greatertail:用于遍历第二个链表(比x大的),以及链接比x值大的结点，最后一定要把greatertail置空，因为在原链表中，greatertail指向的这个值还存着下一个结点的地址，它的next有可能是NULL，也有可能不是NULL</p> 
<p>        如果greatertail指向的这个值不为NULL，若此时不置空，则会出现<span style="color:#fe2c24;">环状链表</span>的情况。</p> 
<p></p> 
<p>2.cur用于遍历原始链表是否结束的条件，若cur不指向NULL，则遍历原始链表，若指向NULL，则表示lesshead与greaterhead指向的两个链表尾插完毕。</p> 
<p></p> 
<p>3.判断</p> 
<p>        比x小的，用lesstail访问哨兵位的next与cur指向的当前结点链接起来，之后</p> 
<p>lesstail=lesstail-&gt;next, 准备尾插第二个结点。</p> 
<p>        比x大的，用greatertail访问哨兵位的next与cur指向的当前结点链接起来，之后greatertail=greatertail-&gt;next, 准备尾插第二个结点。</p> 
<p></p> 
<p>4.接着待两个链表尾插结束，要记得lesstail的next与greaterhead-&gt;head链接起来，接着greatertail置空。</p> 
<p>5.然后<span style="color:#fe2c24;"><strong>原始链表头结点pHead</strong></span>要用lesshead-&gt;next赋值向后更新一位，此时才是改变后的链表的头结点。</p> 
<p>6.将两个哨兵位free掉，接着返回pHead，打印链表。</p> 
<p></p> 
<blockquote> 
 <p>初始情况：</p> 
 <p><img alt="" height="705" src="https://images2.imgbox.com/60/2d/6X9KiD34_o.png" width="1200"></p> 
 <p></p> 
 <p>  动图解析:</p> 
 <p><img alt="" src="https://images2.imgbox.com/b7/c6/xktOJ3ko_o.gif"></p> 
 <p></p> 
 <p></p> 
 <p> 最终的情况：</p> 
 <p><img alt="" height="713" src="https://images2.imgbox.com/b6/af/5vwcXAwa_o.png" width="1200"></p> 
</blockquote> 
<pre><code class="language-cpp">class Partition {
public:
    ListNode* partition(ListNode* pHead, int x)
    {
    struct ListNode* lesshead,*lesstail,*greaterhead,*greatertail;
    lesshead=lesstail=(struct ListNode*)malloc(sizeof(struct ListNode));
    greaterhead=greatertail=(struct ListNode*)malloc(sizeof(struct ListNode));
       
    struct ListNode* cur=pHead;
    while(cur)
{
    if(cur-&gt;val &lt; x)
    {
       lesstail-&gt;next=cur;
       lesstail =lesstail-&gt;next;
    }
    else
    {
        greatertail-&gt;next =cur;
        greatertail=greatertail-&gt;next;
    }
        cur=cur-&gt;next;
        }
        lesstail-&gt;next=greaterhead-&gt;next;
        greatertail-&gt;next=NULL;

        pHead=lesshead-&gt;next;
        free(lesshead);
        free(greaterhead);
    return pHead;
}
};</code></pre> 
<p>执行:</p> 
<p><img alt="" height="194" src="https://images2.imgbox.com/66/71/OP413r26_o.png" width="914"></p> 
<p></p> 
<h2 id="%E5%9B%9B.%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84">四.链表的回文结构</h2> 
<p>来源:<a href="https://leetcode.cn/problems/aMhZSa/description/" rel="nofollow" title="LCR 027. 回文链表 - 力扣（LeetCode）">LCR 027. 回文链表 - 力扣（LeetCode）</a></p> 
<h3>题目描述:</h3> 
<p>给你一个单链表的头节点 head，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p> 
<p><strong>示例 1：</strong></p> 
<p><img alt="" height="141" src="https://images2.imgbox.com/17/b3/ErfN2jPC_o.png" width="633"></p> 
<blockquote> 
 <p><strong>输入</strong>:head = [1,2,2,1]</p> 
 <p><strong>输出</strong>: true</p> 
</blockquote> 
<p> <strong>示例 2：</strong></p> 
<p><img alt="" height="127" src="https://images2.imgbox.com/3e/cf/l8lvz7LL_o.png" width="306"></p> 
<blockquote> 
 <p><strong>输入</strong>: head = [1,2]</p> 
 <p><strong>输出</strong>: false</p> 
</blockquote> 
<p></p> 
<h3>解题思路:</h3> 
<p>        先找到中间结点，然后将中间结点mid指向的链表反方向输出,接着用原链表头结点head指向的前半段与反向后的链表头结点rmid指向的后半段进行比较。</p> 
<p>顺序:</p> 
<p>        1.用快慢指针方法找到链表的中间结点,这是前半段:<a href="http://t.csdn.cn/YH93S" rel="nofollow" title="http://t.csdn.cn/YH93S">http://t.csdn.cn/YH93S</a></p> 
<p>        2.用中间结点mid指向的链表反转,这是后半段，反转链表:<a href="http://t.csdn.cn/rf9Jl" rel="nofollow" title="http://t.csdn.cn/rf9Jl">http://t.csdn.cn/rf9Jl</a></p> 
<p>        3. 比较链表的前半段和后半段</p> 
<p>                若相等，则是回文结构(返回true)</p> 
<p>                否则，不为回文结构(返回false)</p> 
<p>动图解析:</p> 
<p> 这里省略了反转链表的细节过程，若有需要可以看看上面的那篇文章。</p> 
<blockquote> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c0/ed/zZ9O3XYH_o.gif"></p> 
</blockquote> 
<pre><code class="language-cpp">//c++环境下c适用
class Solution {
public:
   struct ListNode* middleNode(struct ListNode* head) {
        struct ListNode* slow = head, *fast = head;
        while (fast &amp;&amp; fast-&gt;next) {
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
        }
        return slow;
    }
    struct ListNode* reverseList(struct ListNode* head) {
        struct ListNode* cur = head, *rhead = NULL;
        while (cur) {
            struct ListNode* next = cur-&gt;next;

            //头插
            cur-&gt;next = rhead;
            rhead = cur;
            //迭代
            cur = next;
        }
        return rhead;
    }
    bool isPalindrome(struct ListNode* head) {
        struct ListNode* mid = middleNode(head);
        struct ListNode* rmid = reverseList(mid);
        while (rmid) {
            if (rmid-&gt;val != head-&gt;val) {
                return false;
            } else {
                rmid = rmid-&gt;next;
                head = head-&gt;next;
            }
           
        } 
        return true;
    }
};
    </code></pre> 
<p>执行: </p> 
<p><img alt="" height="230" src="https://images2.imgbox.com/25/01/uqySBi7y_o.png" width="851"></p> 
<p>         本篇结束，感谢你的来访。✨</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/425650bce974e5bb1f2851b7330e8116/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a4aa5815b9eaa3c2ba5068121082c43f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【mysql】事务的四种特性的理解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>