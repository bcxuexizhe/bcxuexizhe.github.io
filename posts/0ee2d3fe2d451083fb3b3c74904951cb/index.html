<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】第三节：单链表 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/0ee2d3fe2d451083fb3b3c74904951cb/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【数据结构】第三节：单链表">
  <meta property="og:description" content="前言 本篇要求掌握的C语言基础知识：指针、结构体
目录
前言 单链表
概念
对比链表和顺序表
创建链表
实现单链表
准备工作
打印链表
创建节点并初始化
尾插
二级指针的调用
尾插代码 头插
尾删
头删
查找（返回节点） 在指定位置(pos)之前插入数据
在指定位置(pos)之后插入数据
删除pos节点
删除pos之后的节点 销毁链表
单链表 概念 链表是⼀种物理存储结构上⾮连续、⾮顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的 。
对比链表和顺序表 顺序表：
1) 占用一大片连续内存空间
2) 不需要额外空间存储逻辑关系，总空间需求最少
4) 可顺序访问，支持随机访问
5) 在C语言中，通过数组实现
6) 数据元素的插入和删除操作通过移动元素完成
链表：
1) 不要求占用连续内存空间
2) 不仅要存储数据，还要存储数据之间的关系，故总空间需求较大
3) 通过指针反映逻辑关系
4) 逻辑连续，物理可不连续
5) 只可顺序访问，不支持随机访问
6) 存在标记：头指针
7) 数据元素的插入和删除操作通过修改指针完成：定位插入点/删除点的直接前驱/后
从上文可以得知与顺序表不同的是，链表⾥的每节&#34;⻋厢&#34;都是独⽴申请下来的空间，我们称之为“结点/节点” ，节点的组成主要有两个部分：当前节点要保存的数据和保存下⼀个节点的地址（指针变量）。 创建链表 //创建节点 typedef int SLTDataType; typedef struct SLNode { SLTDataType data;//数据域 struct SLNode* next;//指针域 }SLTNode; //创建节点 SLTNode* node1 = (SLTNode*)malloc(sizeof(SLTNode)); node1-&gt;data = 1; SLTNode* node2 = (SLTNode*)malloc(sizeof(SLTNode)); node2-&gt;data = 2; SLTNode* node3 = (SLTNode*)malloc(sizeof(SLTNode)); node3-&gt;data = 3; SLTNode* node4 = (SLTNode*)malloc(sizeof(SLTNode)); node4-&gt;data = 4; //链接节点 node1-&gt;next = node2; node2-&gt;next = node3; node3-&gt;next = node4; node4-&gt;next = NULL;//尾指针置空 其中数据域用于存放数据，指针域用于存放下一个结点的地址。上面的链表是手动创建节点，只是为了展示链表的形成，后续创建和链接单链表可以通过函数实现。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-15T14:47:55+08:00">
    <meta property="article:modified_time" content="2024-04-15T14:47:55+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】第三节：单链表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%E5%89%8D%E8%A8%80%C2%A0">前言 </h2> 
<blockquote> 
 <p style="text-align:center;">本篇要求掌握的C语言基础知识：指针、结构体</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80%C2%A0" rel="nofollow">前言 </a></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E5%8D%95%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#%E5%8D%95%E9%93%BE%E8%A1%A8" rel="nofollow">单链表</a></p> 
<p id="%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%E6%A6%82%E5%BF%B5" rel="nofollow">概念</a></p> 
<p id="%E5%AF%B9%E6%AF%94%E9%93%BE%E8%A1%A8%E5%92%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8-toc" style="margin-left:40px;"><a href="#%E5%AF%B9%E6%AF%94%E9%93%BE%E8%A1%A8%E5%92%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8" rel="nofollow">对比链表和顺序表</a></p> 
<p id="%E5%88%9B%E5%BB%BA%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#%E5%88%9B%E5%BB%BA%E9%93%BE%E8%A1%A8" rel="nofollow">创建链表</a></p> 
<p id="%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8" rel="nofollow">实现单链表</a></p> 
<p id="%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-toc" style="margin-left:40px;"><a href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C" rel="nofollow">准备工作</a></p> 
<p id="%C2%A0%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#%C2%A0%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8" rel="nofollow"> 打印链表</a></p> 
<p id="%C2%A0%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9%E5%B9%B6%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9%E5%B9%B6%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow"> 创建节点并初始化</a></p> 
<p id="%E5%B0%BE%E6%8F%92-toc" style="margin-left:40px;"><a href="#%E5%B0%BE%E6%8F%92" rel="nofollow">尾插</a></p> 
<p id="%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E8%B0%83%E7%94%A8-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E8%B0%83%E7%94%A8" rel="nofollow">二级指针的调用</a></p> 
<p id="%E5%B0%BE%E6%8F%92%E4%BB%A3%E7%A0%81%C2%A0-toc" style="margin-left:80px;"><a href="#%E5%B0%BE%E6%8F%92%E4%BB%A3%E7%A0%81%C2%A0" rel="nofollow">尾插代码 </a></p> 
<p id="%E5%A4%B4%E6%8F%92-toc" style="margin-left:40px;"><a href="#%E5%A4%B4%E6%8F%92" rel="nofollow">头插</a></p> 
<p id="%E5%B0%BE%E5%88%A0-toc" style="margin-left:40px;"><a href="#%E5%B0%BE%E5%88%A0" rel="nofollow">尾删</a></p> 
<p id="%E5%A4%B4%E5%88%A0-toc" style="margin-left:40px;"><a href="#%E5%A4%B4%E5%88%A0" rel="nofollow">头删</a></p> 
<p id="%E6%9F%A5%E6%89%BE%EF%BC%88%E8%BF%94%E5%9B%9E%E8%8A%82%E7%82%B9%EF%BC%89%C2%A0-toc" style="margin-left:40px;"><a href="#%E6%9F%A5%E6%89%BE%EF%BC%88%E8%BF%94%E5%9B%9E%E8%8A%82%E7%82%B9%EF%BC%89%C2%A0" rel="nofollow">查找（返回节点） </a></p> 
<p id="%C2%A0%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE(pos)%E4%B9%8B%E5%89%8D%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%28pos%29%E4%B9%8B%E5%89%8D%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE" rel="nofollow"> 在指定位置(pos)之前插入数据</a></p> 
<p id="%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE(pos)%E4%B9%8B%E5%90%8E%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%28pos%29%E4%B9%8B%E5%90%8E%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE" rel="nofollow">在指定位置(pos)之后插入数据</a></p> 
<p id="%E5%88%A0%E9%99%A4pos%E8%8A%82%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E5%88%A0%E9%99%A4pos%E8%8A%82%E7%82%B9" rel="nofollow">删除pos节点</a></p> 
<p id="%E5%88%A0%E9%99%A4pos%E4%B9%8B%E5%90%8E%E7%9A%84%E8%8A%82%E7%82%B9%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%88%A0%E9%99%A4pos%E4%B9%8B%E5%90%8E%E7%9A%84%E8%8A%82%E7%82%B9%C2%A0" rel="nofollow">删除pos之后的节点 </a></p> 
<p id="%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8" rel="nofollow">销毁链表</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%8D%95%E9%93%BE%E8%A1%A8">单链表</h2> 
<h3 id="%E6%A6%82%E5%BF%B5"><span style="color:#646a73;">概念</span></h3> 
<p><span style="color:#646a73;">        链表是⼀种物理存储结构上<strong><span style="background-color:#ffd900;">⾮连续</span></strong>、<strong><span style="background-color:#ffd900;">⾮顺序</span></strong>的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的 。</span></p> 
<h3 id="%E5%AF%B9%E6%AF%94%E9%93%BE%E8%A1%A8%E5%92%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8">对比链表和顺序表</h3> 
<blockquote> 
 <p><strong>顺序表</strong>：</p> 
 <p>        1) 占用一大片连续内存空间</p> 
 <p>        2) 不需要额外空间存储逻辑关系，总空间需求最少</p> 
 <p>        4) 可顺序访问，支持随机访问</p> 
 <p>        5) 在C语言中，通过数组实现</p> 
 <p>        6) 数据元素的插入和删除操作通过<strong>移动元素</strong>完成</p> 
 <p></p> 
 <p><strong>链表</strong>：</p> 
 <p>        1) 不要求占用连续内存空间</p> 
 <p>        2) 不仅要存储数据，还要存储数据之间的关系，故总空间需求较大</p> 
 <p>        3) 通过指针反映逻辑关系</p> 
 <p>        4) 逻辑连续，物理可不连续</p> 
 <p>        5) 只可顺序访问，不支持随机访问</p> 
 <p>        6) 存在标记：头指针</p> 
 <p>        7) 数据元素的插入和删除操作通过修改指针完成：定位插入点/删除点的直接前驱/后</p> 
</blockquote> 
<p>        从上文可以得知<span style="color:#646a73;">与顺序表不同的是，链表⾥的每节"⻋厢"都是独⽴申请下来的空间，我们称之为“<strong><span style="background-color:#ffd900;">结点/节点</span></strong>” ，节点的组成主要有两个部分：当前节点要保存的数据和保存下⼀个节点的地址（指针变量）。 </span></p> 
<p><img alt="" height="123" src="https://images2.imgbox.com/91/2c/5FSTewqn_o.png" width="700"></p> 
<h3 id="%E5%88%9B%E5%BB%BA%E9%93%BE%E8%A1%A8">创建链表</h3> 
<pre><code class="language-cpp">//创建节点
typedef int SLTDataType;

typedef struct SLNode
{
	SLTDataType data;//数据域
	struct SLNode* next;//指针域
}SLTNode;

//创建节点
SLTNode* node1 = (SLTNode*)malloc(sizeof(SLTNode));
node1-&gt;data = 1;

SLTNode* node2 = (SLTNode*)malloc(sizeof(SLTNode));
node2-&gt;data = 2;

SLTNode* node3 = (SLTNode*)malloc(sizeof(SLTNode));
node3-&gt;data = 3;

SLTNode* node4 = (SLTNode*)malloc(sizeof(SLTNode));
node4-&gt;data = 4;

//链接节点
node1-&gt;next = node2;
node2-&gt;next = node3;
node3-&gt;next = node4;
node4-&gt;next = NULL;//尾指针置空</code></pre> 
<p>        其中数据域用于存放数据，指针域用于存放下一个结点的地址。上面的链表是手动创建节点，只是为了展示链表的形成，后续创建和链接单链表可以通过函数实现。</p> 
<h2 id="%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8">实现单链表</h2> 
<h3 id="%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">准备工作</h3> 
<blockquote> 
 <p>在工程中一共包含三个文件</p> 
 <ul><li>定义文件SLNode.h：定义函数和结构体，头文件：stdio.h、stdlib.h、assert.h</li><li>实现文件SLNode.c：实现函数具体功能，头文件：SLNode.h</li><li>测试文件test.c：测试每一部分代码的正确性，头文件：SLNode.h</li></ul> 
</blockquote> 
<p>        在开始之前我们需要定义一个指向为空的结构体类型的节点（SLNode*）plist，作为链表的头节点。</p> 
<pre><code class="language-cpp">SLNode* plist = NULL;</code></pre> 
<h3 id="%C2%A0%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8"> 打印链表</h3> 
<blockquote> 
 <pre><code class="language-cpp">//打印
void SLTprint(SLTNode* phead)
{
	SLNode* pcur = phead;
	while (pcur != NULL)
	{
		printf("%d ", pcur-&gt;data);
		pcur = pcur-&gt;next;
	}
	printf("\n");
}</code></pre> 
</blockquote> 
<h3 id="%C2%A0%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9%E5%B9%B6%E5%88%9D%E5%A7%8B%E5%8C%96"> 创建节点并初始化</h3> 
<blockquote> 
 <pre><code class="language-cpp">//创建节点并初始化
SLNode* SLTbuyNode(SLTDataType x)
{
	SLNode* newnode = (SLNode*)malloc(sizeof(SLNode));//创建新节点
	if (newnode == NULL)
	{
		perror("malloc fail!");
		exit(1);//表示非正常退出
	}
	newnode-&gt;data = x;
	newnode-&gt;next = NULL;
	return newnode;
}</code></pre> 
</blockquote> 
<h3 id="%E5%B0%BE%E6%8F%92">尾插</h3> 
<h4 id="%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E8%B0%83%E7%94%A8">二级指针的调用</h4> 
<p>        从这一部分开始就涉及到了二级指针传参的问题，在对单链表进行尾插时，如果此时头节点plist指向为空（即该单链表为空），就需要在函数内部改变头指针的指向，指向新插入的节点。</p> 
<p>        这里举一个简单的例子，假如我要实现一个交换两个整形数据的函数，应该如何实现？</p> 
<blockquote> 
 <pre><code class="language-cpp">void Exchange(int a,int b)
{
    int tmp=a;
    a=b;
    tmp=b;
}</code></pre> 
 <p>        如果仅仅将两个整形作为参数是无法成功的，因为在主函数中调用Exchange时在栈帧中又开辟了一块地址不同于主函数的函数栈帧，以上"传值调用"仅仅将形参里的内容进行交换，在函数执行结束时所占据的空间会被释放，同时形参也会因为被销毁而无法对实参产生影响。</p> 
 <p>        如果想要"形参影响实参"，就要把"传值调用"改为"传址调用"，即将变量的地址作为参数传给函数，对应的函数参数应为指针类型。</p> 
 <pre><code class="language-cpp">void Exchange(int* a,int* b)
{
    int* tmp=*a;
    *a=*b;
    *tmp=*b;
}</code></pre> 
 <p>        这样就实现了交换两个数据的操作。</p> 
</blockquote> 
<p>        同理，想要在函数内部改变一级头指针plist的指向，应该把plist的地址传入，用二级指针接收，也就是"传址调用"，<strong>如果只传递一级指针（即链表的头指针），无法直接修改它所指向的地址，因为在函数内部对指针的修改不会影响到函数外部，最终只是将形参指针的指向改变而无法对实参造成影响。为了实现对链表头指针的修改，需要传递指向指针的指针，这样在函数内部就可以修改指针所指向的地址，从而改变链表的头指针。</strong></p> 
<p> 来一张图解释二级指针</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/80/c2/AiEB9mwF_o.jpg"></p> 
<blockquote> 
 <p><strong>总结：只要头指针发生改变就需要用到二级指针</strong></p> 
</blockquote> 
<h4 id="%E5%B0%BE%E6%8F%92%E4%BB%A3%E7%A0%81%C2%A0">尾插代码 </h4> 
<blockquote> 
 <pre><code class="language-cpp">void SLTpushBack(SLTNode** pphead, SLTDataType x)
{
	assert(pphead);
	SLTNode* newnode = SLTbuyNode(x);
	if (*pphead == NULL)//链表为空
	{
		*pphead = newnode;
	}
	else
	{
		SLNode* ptail = *pphead;
		while (ptail-&gt;next != NULL)//遍历链表找到尾节点
		{
			ptail = ptail-&gt;next;
		}
		ptail-&gt;next = newnode;
	}
}
</code></pre> 
</blockquote> 
<h3 id="%E5%A4%B4%E6%8F%92">头插</h3> 
<blockquote> 
 <p>       与尾插同理，头指针的指向发生改变，需要借助二级指针</p> 
 <pre><code class="language-cpp">void SLTpushFront(SLTNode** pphead, SLTDataType x)
{
	assert(pphead);
	SLTNode* newnode = SLTbuyNode(x);
	newnode-&gt;next = *pphead;//*pphead是指向第一个节点的指针
	*pphead = newnode;
}</code></pre> 
</blockquote> 
<h3 id="%E5%B0%BE%E5%88%A0">尾删</h3> 
<blockquote> 
 <pre><code class="language-cpp">void SLTpopBack(SLTNode** pphead)
{
	assert(pphead &amp;&amp; *pphead);//*pphead为空说明整个链表为空
	if ((*pphead)-&gt;next == NULL)//链表中只有一个节点
	{
		free(*pphead);
		*pphead = NULL;
	}
	else
	{
		SLTNode* ptail = *pphead;
		SLTNode* prev = *pphead;
		while (ptail-&gt;next != NULL)
		{
			prev = ptail;//prev指向的是尾节点的前一个节点
			ptail = ptail-&gt;next;
		}
		free(ptail);
		prev-&gt;next = NULL;//prev成为新的尾节点
		ptail = NULL;
	}
}</code></pre> 
</blockquote> 
<h3 id="%E5%A4%B4%E5%88%A0">头删</h3> 
<blockquote> 
 <pre><code class="language-cpp">void SLTpopFront(SLTNode** pphead)
{
	assert(pphead &amp;&amp; *pphead);
	if ((*pphead) == NULL)
	{
		free(*pphead);
		*pphead = NULL;
	}
	else
	{
		SLTNode* p = *pphead;//此时p指向的是头节点
		*pphead = (*pphead)-&gt;next;
		free(p);
		p = NULL;
	}
}</code></pre> 
</blockquote> 
<h3 id="%E6%9F%A5%E6%89%BE%EF%BC%88%E8%BF%94%E5%9B%9E%E8%8A%82%E7%82%B9%EF%BC%89%C2%A0">查找（返回节点） </h3> 
<blockquote> 
 <pre><code class="language-cpp">SLNode* SLTfind(SLTNode* phead, SLTDataType x)
{
	assert(phead);
	SLNode* pcur = phead;
	while (pcur != NULL)
	{
		if (pcur-&gt;data == x)
		{
			return pcur;
		}
		pcur = pcur-&gt;next;
	}
	return NULL;//没有找到返回NULL
}</code></pre> 
</blockquote> 
<h3 id="%C2%A0%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE(pos)%E4%B9%8B%E5%89%8D%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"> 在指定位置(pos)之前插入数据</h3> 
<blockquote> 
 <pre><code class="language-cpp">void SLTinsert(SLTNode** pphead, SLTNode* pos, SLTDataType x)
{
	assert(pphead &amp;&amp; *pphead &amp;&amp; pos);
	SLTNode* pcur = *pphead;
	SLNode* newnode = SLTbuyNode(x);
	if (pos == *pphead)
	{
		SLTpushFront(pphead, x);
	}
	else
	{
		while (pcur-&gt;next != pos)//遍历到pos节点的前驱节点
		{
			pcur = pcur-&gt;next;
		}
		newnode-&gt;next = pos;
		pcur-&gt;next = newnode;
	}
}
</code></pre> 
</blockquote> 
<h3 id="%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE(pos)%E4%B9%8B%E5%90%8E%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE">在指定位置(pos)之后插入数据</h3> 
<blockquote> 
 <pre><code class="language-cpp">void SLTinsertAfter(SLTNode* pos, SLTDataType x)
{
	assert(pos);
	SLNode* newnode = SLTbuyNode(x);
	if (pos-&gt;next == NULL)//如果pos是尾节点
	{
		pos-&gt;next = newnode;
		newnode-&gt;next = NULL;
	}
	else
	{
		SLNode* pafter = pos-&gt;next;//pcur是pos的后继节点
		newnode-&gt;next = pafter;
		pos-&gt;next = newnode;
	}
}</code></pre> 
 <p>         在这里不调用二级指针的原因是头指针无需改变，需要改变的时pos节点内部next指针的指向，而对于next指针来说，pos指向的时next所在的节点，所以pos可以直接访问这个黑点，从而改变next的指向，<strong>换句话pos相对于next来说就是二级指针</strong>。</p> 
</blockquote> 
<h3 id="%E5%88%A0%E9%99%A4pos%E8%8A%82%E7%82%B9">删除pos节点</h3> 
<blockquote> 
 <pre><code class="language-cpp">void SLTerase(SLTNode** pphead, SLTNode* pos)
{
	assert(*pphead &amp;&amp; pos &amp;&amp; pphead);
	if (pos-&gt;next == NULL)//如果pos是尾节点
	{
		SLTNode* prev = *pphead;
		while (prev-&gt;next != pos)
		{
			prev = prev-&gt;next;
		}
		prev-&gt;next = NULL;
		free(pos);
		pos = NULL;
	}
	else if (*pphead == pos)//如果pos是头节点
	{
		SLTNode* next = (*pphead)-&gt;next;
		free(*pphead);
		(*pphead) = next;
	}
	else
	{
		SLTNode* prev = *pphead;
		while (prev-&gt;next != pos)
		{
			prev = prev-&gt;next;
		}
		prev-&gt;next = pos-&gt;next;
		free(pos);
		pos = NULL;
	}
}
</code></pre> 
</blockquote> 
<h3 id="%E5%88%A0%E9%99%A4pos%E4%B9%8B%E5%90%8E%E7%9A%84%E8%8A%82%E7%82%B9%C2%A0">删除pos之后的节点 </h3> 
<blockquote> 
 <pre><code class="language-cpp">void SLTeraseAfter(SLTNode* pos)
{
	assert(pos-&gt;next &amp;&amp; pos);
	SLTNode* next = pos-&gt;next;
	pos-&gt;next = pos-&gt;next-&gt;next;
	free(next);
	next = NULL;
}</code></pre> 
</blockquote> 
<h3 id="%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8">销毁链表</h3> 
<blockquote> 
 <pre><code class="language-cpp">void SLTdestroy(SLTNode** pphead)
{
	assert(*pphead &amp;&amp; pphead);
	SLTNode* pcur = *pphead;
	while (pcur != NULL)
	{
		SLTNode* next = pcur-&gt;next;
		free(pcur);
		pcur = next;
	}
	*pphead = NULL;
}</code></pre> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a5b70fd50186c714eb798baa46099ff4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python matplotlib绘制 3D图像专题 （三维柱状图、曲面图、散点图、曲线图合集）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fa4ce8c55ef926012a84ce9873c70237/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">自定义数据集使用llama_factory微调模型并导入ollama</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>