<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>限流算法(令牌桶&amp;漏桶&amp;计数器) - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/5089fd683ac3fe1866cf760627f75b31/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="限流算法(令牌桶&amp;漏桶&amp;计数器)">
  <meta property="og:description" content="📝个人主页：五敷有你 🔥系列专栏：Spring
⛺️稳中求进，晒太阳
业务重的三种情况：突发流量、恶意流量、业务本身需要
限流: 是为了保护自身系统和下游系统不被高并发流量冲垮，导致系统雪崩。
保证系统在可用的情况下尽可能增加进入的请求，其余的请求在排队等待，或者返回友好提示。保证进入系统的用户可以友好使用。
令牌桶算法 令牌桶算法是一个设定的速率产生令牌(token) 并放入令牌通，每次用户请求都得申请令牌。如果令牌不足，则拒绝请求。
令牌桶算法中新请求到来时会从桶中拿走一个令牌，如果桶内没有i令牌可拿，就拒绝服务。
当然令牌的数量也是有上限的。令牌的数量与时间和发放速率强相关。时间流逝的时间越长，会不断往桶里加入越多的令牌，如果令牌发送的速度比申请速度快，令牌会放满令牌桶，直到令牌占满令牌桶
令牌桶的算法特点： 好处：可以方便地应对突发出口流量。
比如：可以改变令牌发放速度(需要后端系统能力的提升)，算法能按照新的发送速率调大令牌的发放数量，使得出口突发流量能被处理。
令牌生成的速度固定，消费速度不固定。
代码简单实现： package ratelimit; import java.util.concurrent.*; import java.util.concurrent.atomic.AtomicInteger; import java.util.logging.Logger; public class TokenBucketLimiter { //桶的容量 private static int capacity=100; //令牌生成速度 rate/s private static final int rate=50; //令牌数量 private volatile static AtomicInteger tokens=new AtomicInteger(0); /** * 开启一个线程，按固定频率放入令牌桶固定个数 */ public static void productTokens(){ ScheduledExecutorService scheduledExecutorService= Executors.newScheduledThreadPool(1); scheduledExecutorService.scheduleAtFixedRate(()-&gt;{ int allTokens = tokens.get()&#43;rate; //设置当前的tokens数量 tokens.set(allTokens); },1000,1000,TimeUnit.MILLISECONDS); } /** * true是被限流了 * * @param needCount * @return */ public static synchronized boolean limited(int needCount){ if(tokens.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-13T11:00:00+08:00">
    <meta property="article:modified_time" content="2024-05-13T11:00:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">限流算法(令牌桶&amp;漏桶&amp;计数器)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="132" src="https://images2.imgbox.com/67/79/pQ63KSFk_o.png" width="124"></p> 
<p style="text-align:center;"><span style="color:#4da8ee;">     </span><strong><span style="color:#4da8ee;">  📝<a href="https://so.csdn.net/so/search?q=%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5&amp;spm=1001.2101.3001.7020" title="个人主页">个人主页</a>：<a href="https://blog.csdn.net/m0_62645012?" title="五敷有你">五敷有你</a>      </span><br><span style="color:#956fe7;"> 🔥系列专栏：<a href="https://blog.csdn.net/m0_62645012/category_12520949.html" title="Spring">Spring</a></span><br><span style="color:#ff9900;">⛺️稳中求进，晒太阳</span></strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/64/e1/PwhaaiwQ_o.gif"></p> 
<p></p> 
<p>业务重的三种情况：突发流量、恶意流量、业务本身需要</p> 
<p></p> 
<p><strong>限流:  </strong> 是为了保护自身系统和下游系统不被高并发流量冲垮，导致系统雪崩。</p> 
<p>保证系统在可用的情况下尽可能增加进入的请求，其余的请求在排队等待，或者返回友好提示。保证进入系统的用户可以友好使用。</p> 
<p></p> 
<h3>令牌桶算法</h3> 
<p>令牌桶算法是一个设定的速率产生令牌(token) 并放入令牌通，每次用户请求都得申请令牌。如果令牌不足，则拒绝请求。</p> 
<p><img alt="" height="394" src="https://images2.imgbox.com/ab/aa/F2DMqici_o.png" width="639"></p> 
<blockquote> 
 <p>        令牌桶算法中新请求到来时会从桶中拿走一个令牌，如果桶内没有i令牌可拿，就拒绝服务。</p> 
 <p>        当然令牌的数量也是有上限的。令牌的数量与时间和发放速率强相关。时间流逝的时间越长，会不断往桶里加入越多的令牌，如果令牌发送的速度比申请速度快，令牌会放满令牌桶，直到令牌占满令牌桶</p> 
</blockquote> 
<p></p> 
<h4>令牌桶的算法特点：</h4> 
<p>好处：可以方便地<strong>应对突发出口流量。</strong></p> 
<p>比如：可以<strong>改变令牌发放速度</strong>(需要后端系统能力的提升)，算法能按照新的发送速率调大令牌的发放数量，使得出口突发流量能被处理。</p> 
<p>令牌生成的速度固定，消费速度不固定。</p> 
<h4>代码简单实现：</h4> 
<pre><code class="language-java">package ratelimit;


import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.logging.Logger;


public class TokenBucketLimiter {


    //桶的容量
    private static int capacity=100;
    //令牌生成速度 rate/s
    private static final int rate=50;
    //令牌数量
    private volatile static AtomicInteger tokens=new AtomicInteger(0);

    /**
     * 开启一个线程，按固定频率放入令牌桶固定个数
     */
    public static void productTokens(){
        ScheduledExecutorService scheduledExecutorService= Executors.newScheduledThreadPool(1);
        scheduledExecutorService.scheduleAtFixedRate(()-&gt;{
            int allTokens = tokens.get()+rate;
            //设置当前的tokens数量
            tokens.set(allTokens);
        },1000,1000,TimeUnit.MILLISECONDS);

    }


    /**
     * true是被限流了
     *
     * @param needCount
     * @return
     */
    public static synchronized boolean limited(int needCount){
        if(tokens.get()&lt;needCount){

            return true;
        }

        System.out.println("此时令牌桶中数量有: "+tokens.getAndDecrement());
        return false;
    }
    public static void main(String[] args) {
        //开启生产者任务
        productTokens();
        //定义一个原子类，
        AtomicInteger atomicInteger=new AtomicInteger(0);
        ExecutorService executorService=Executors.newFixedThreadPool(5);
        for(int i=0;i&lt;10000;i++){
            executorService.submit(()-&gt;{
                try {
                    Thread.sleep(200);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                //当前线程的名称
                String taskName=Thread.currentThread().getName();
                boolean isLimit=limited(1);
                //true被限流了
                if(isLimit){
                    System.out.println(taskName+"被限流了，累计限流次数: "+atomicInteger.incrementAndGet());
                }else {
                    System.out.println(taskName+"请求被正常处理了");
                }
            });

        }



    }




}
</code></pre> 
<p></p> 
<p> <img alt="" height="487" src="https://images2.imgbox.com/be/76/d1f8WIUD_o.png" width="808"></p> 
<p></p> 
<h3>漏桶算法</h3> 
<p>漏桶(Leak Bucket) 算法限流的基本原理：</p> 
<p>水(对应请求) 从进水口到漏桶里，<strong>漏桶以一定的速度出水</strong>(请求放行)，当<span style="color:#ff9900;"><strong>水流速度过大，桶内的总水量大于桶容量会直接溢出，请求拒绝。</strong></span></p> 
<h4><strong>大致的规则如下：</strong></h4> 
<p>1）进水口(对应客户端请求) 以任意速率流入漏桶。</p> 
<p>2）漏桶的容量是固定的，出水(放行)速率也是固定的。</p> 
<p>3）漏桶容量是不变的，如果处理速度太慢，桶内水的容量就会超出桶的容量，则后面的水滴会标识请求拒绝。</p> 
<p><img alt="" height="309" src="https://images2.imgbox.com/0a/15/lnlGb0R8_o.png" width="575"></p> 
<h4>流程：</h4> 
<p>水(请求)先进入桶中，漏桶按照一定的速率进行漏水，如果漏桶满了，那么水就会溢出(请求拒绝)，可以看出来漏桶算法能强行限制数据的传输速率。</p> 
<h4>代码实现</h4> 
<pre><code class="language-java">package ratelimit;

import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

public class LeakBucketLimiter {
    //漏桶的容量
    private static int capacity=10;
    //漏水的速度 rate/s
    private static final int leakRate=5;
    //桶中水量
    private volatile static AtomicInteger waterLeaf=new AtomicInteger(0);

    /**
     * 开启一个线程，按固定频率放入令牌桶固定个数
     */
    public static void leakWater(){
        ScheduledExecutorService scheduledExecutorService= Executors.newScheduledThreadPool(1);
        scheduledExecutorService.scheduleAtFixedRate(()-&gt;{
            //现在桶中的水
            int water = waterLeaf.get()-leakRate;
            //设置当前的水量
            waterLeaf.set(Math.max(0,water));
        },1,1, TimeUnit.SECONDS);

    }
    public static synchronized boolean limited(int waterCount){
        if(waterLeaf.get()+waterCount&gt;capacity){
            //水满了拒绝
            return true;
        }
        waterLeaf.addAndGet(waterCount);
        System.out.println("此时漏桶水量有: "+waterLeaf);
        return false;
    }
    public static void main(String[] args) {

        //开始漏水
        leakWater();

        //开启请求
        ScheduledExecutorService executorService=Executors.newScheduledThreadPool(5);
        AtomicInteger atomicInteger=new AtomicInteger(0);
        for(int i=0;i&lt;10000;i++){
            executorService.submit(()-&gt;{
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                String taskName=Thread.currentThread().getName();
                boolean limited = limited(1);
                if(limited){
                    System.out.println(taskName+"请求被拦截，累计拦截次数"+atomicInteger.incrementAndGet());
                }else{
                    System.out.println(taskName+"请求访问成功！！！");
                }
            });

        }



    }


}
</code></pre> 
<h3>计数器算法</h3> 
<p>        计数器算法在一段时间间隔内(时间窗/时间区间)，处理请求的最大数量固定，超过部分不做处理。计数器算法是限流算法中最简单的，也是最容易实现的一种算法。</p> 
<h4>举个例子：</h4> 
<p>比如：我们规定对于A接口，我们一分钟访问次数不能超过100个。</p> 
<p>可以这么做：</p> 
<p>1. 在一开始的时候，我们可以设置一个计数器counter,每当一个请求过来的时候，counter就+1，如果counter的值大于100，并且该请求与第一个请求的间隔在一分钟之内，那么说明请求数过多，拒绝访问；</p> 
<p>2. 如果该请求与第一个请求的间隔时间大于1分钟，且counter的值还在限流范围内，那么重置counter,就是这么简单粗暴</p> 
<p><img alt="" height="221" src="https://images2.imgbox.com/ae/28/JzP5aNoX_o.png" width="477"></p> 
<h4>问题：临界问题</h4> 
<p>计数器限流的严重问题：这个算法虽然简单，但是有一个十分致命的问题，就是临界问题</p> 
<p><img alt="" height="250" src="https://images2.imgbox.com/2e/a9/iKWDk3JI_o.png" width="492"></p> 
<p>两分钟之间的临界突发200请求，很危险！！！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/715ef15cea32c8beeeb38e749d64e5c0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【高阶数据结构(三)】图的遍历&amp;最小生成树问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2be8d795a10d291b056dd2e20c72eae0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AI大模型探索之路-训练篇22： ChatGLM3微调实战-从原理到应用的LoRA技术全解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>