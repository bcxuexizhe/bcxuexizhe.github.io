<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Java】快速排序 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/9359c01556ec5cc9f01ff67749964a07/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【Java】快速排序">
  <meta property="og:description" content="文章目录 一、什么是快速排序二、基准元素的选择1、选择第一个元素2、随机选择 三、元素的交换1、双边循环法2、单边循环法 一、什么是快速排序 快速排序是由冒泡排序演变而来，比冒泡排序更快的排序算法。之所以快，是因为快速排序用了分治法。
相同的是，与冒泡排序一样，快速排序也属于交换排序，通过元素之间的比较和交换来排序。
不同的是，冒泡排序每一轮只把一个元素冒泡到数列的一端，而快速排序每轮挑选一个基准元素，让比它小的元素移动到一端，让比它大的元素移动到另一端，从而把数列拆解成两个部分。
这种每次将数列分为两个部分的方法就叫做分治法。
分治法的好处体现在相比于冒泡排序它会有更小的时间复杂度，对于n的元素的冒泡排序时间复杂度为O(n2),而快速排序总体的平均时间复杂度为O(nlogn)。
二、基准元素的选择 在使用分治法的过程中以基准元素为中心把其他元素移到它的两边，那么如何选择基准元素呢？
1、选择第一个元素 最简单的方法是直接选择数列第一个元素为基准元素，但是这种方法在有些特殊情况下会出现问题：
对于这种原本是逆序的数列，每轮都只能确定基准元素的位置，这种情况下快速排序需要进行n轮，时间复杂度退化到了O(n2)。
2、随机选择 为了解决时间复杂度过大的情况，我们可以随机选择一个元素，并与首位元素互换位置，虽然这种情况下也有几率选到数列的最大或最小值，但大多情况下都是可以的。
所以，虽然快速排序的平均时间复杂度为O(nlogn)，但最坏情况下也可以达到O(n2)。
三、元素的交换 选好了基准元素，就要将其他元素移到基准元素两边，具体实现有两种方法：
双边循环法单边循环法 1、双边循环法 对以下数列按从小到大进行排序：
首先，选定基准元素p，并设置左右两个指针 l 和 r
开始循环后，从r指针开始，让r指针元素与基准元素做比较，如果大于等于p，则r指针向左移动；如果小于p，则停止移动，换到l指针。
对于当前数列，r指针元素为1，1&lt;4，所以r指针停止移动，换到l指针。
换到l指针后，让l指针元素与基准元素做比较，如果小于等于p，则l指针向右移动；如果大于p，则停止移动。
按照此思路，后续步骤如下：
实现代码如下：
import java.util.Arrays; public class quickSort { public static void quickSort(int arr[],int startIndex,int endIndex){ //递归结束条件为startIndex大于或等于endIndex if(startIndex&gt;=endIndex){ return; } //得到基准元素位置 int pIndex=partition(arr,startIndex,endIndex); //根据基准元素分两部分进行递归排序 quickSort(arr,startIndex,pIndex-1); quickSort(arr,pIndex&#43;1,endIndex); } /* * 分治法（双边循环法） * arr 待排序数组 * startIndex 起始下标 * endIndex 结束下标 * */ public static int partition(int arr[],int startIndex,int endIndex) { int p=arr[startIndex];//基准元素(可取随机位置) int l=startIndex;//左指针 int r=endIndex;//右指针 while(l!">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-09-20T17:45:00+08:00">
    <meta property="article:modified_time" content="2023-09-20T17:45:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java】快速排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_2" rel="nofollow">一、什么是快速排序</a></li><li><a href="#_15" rel="nofollow">二、基准元素的选择</a></li><li><ul><li><a href="#1_19" rel="nofollow">1、选择第一个元素</a></li><li><a href="#2_25" rel="nofollow">2、随机选择</a></li></ul> 
  </li><li><a href="#_30" rel="nofollow">三、元素的交换</a></li><li><ul><li><a href="#1_37" rel="nofollow">1、双边循环法</a></li><li><a href="#2_116" rel="nofollow">2、单边循环法</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_2"></a>一、什么是快速排序</h2> 
<p><strong>快速排序</strong>是由<strong>冒泡排序</strong>演变而来，比冒泡排序更快的排序算法。之所以快，是因为快速排序用了<strong>分治法</strong>。</p> 
<p>相同的是，与冒泡排序一样，快速排序也属于<strong>交换排序</strong>，通过元素之间的比较和交换来排序。</p> 
<p>不同的是，冒泡排序每一轮只把一个元素冒泡到数列的一端，<mark>而快速排序每轮挑选一个<strong>基准元素</strong>，让比它小的元素移动到一端，让比它大的元素移动到另一端，从而把数列拆解成两个部分</mark>。</p> 
<p><img src="https://images2.imgbox.com/e4/0b/AVLmQlS6_o.png" alt="在这里插入图片描述"><br> 这种每次将数列分为两个部分的方法就叫做<strong>分治法</strong>。</p> 
<p>分治法的好处体现在相比于冒泡排序它会有更小的时间复杂度，对于n的元素的<strong>冒泡排序时间复杂度为O(n<sup>2</sup>)</strong>,而<strong>快速排序总体的平均时间复杂度为O(nlogn)</strong>。</p> 
<h2><a id="_15"></a>二、基准元素的选择</h2> 
<p>在使用分治法的过程中以基准元素为中心把其他元素移到它的两边，那么如何选择基准元素呢？</p> 
<h3><a id="1_19"></a>1、选择第一个元素</h3> 
<p>最简单的方法是直接<strong>选择数列第一个元素为基准元素</strong>，但是这种方法在有些特殊情况下会出现问题：</p> 
<p><img src="https://images2.imgbox.com/1a/c0/NFBgIG8E_o.png" alt="在这里插入图片描述"><br> 对于这种原本是<strong>逆序的数列</strong>，每轮都只能确定基准元素的位置，这种情况下快速排序需要进行n轮，<strong>时间复杂度退化到了O(n<sup>2</sup>)</strong>。</p> 
<h3><a id="2_25"></a>2、随机选择</h3> 
<p>为了解决时间复杂度过大的情况，我们可以<strong>随机选择一个元素</strong>，并与首位元素互换位置，虽然这种情况下也有几率选到数列的最大或最小值，但大多情况下都是可以的。</p> 
<p><mark><strong>所以，虽然快速排序的平均时间复杂度为O(nlogn)，但最坏情况下也可以达到O(n<sup>2</sup>)。</strong></mark></p> 
<h2><a id="_30"></a>三、元素的交换</h2> 
<p>选好了基准元素，就要将其他元素移到基准元素两边，具体实现有两种方法：</p> 
<ul><li>双边循环法</li><li>单边循环法</li></ul> 
<h3><a id="1_37"></a>1、双边循环法</h3> 
<p>对以下数列按从小到大进行排序：<br> <img src="https://images2.imgbox.com/27/e6/Bo93sE8s_o.png" alt="在这里插入图片描述"><br> 首先，选定<strong>基准元素p</strong>，并设置左右两个指针 <strong>l</strong> 和 <strong>r</strong></p> 
<p><img src="https://images2.imgbox.com/0a/80/MmLyhko7_o.png" alt="在这里插入图片描述"><br> 开始循环后，从r指针开始，让<mark>r指针元素与基准元素做比较</mark>，如果<mark>大于等于p，则r指针向左移动</mark>；如果<mark>小于p，则停止移动</mark>，换到l指针。</p> 
<p>对于当前数列，r指针元素为1，1&lt;4，所以r指针停止移动，换到l指针。</p> 
<p>换到l指针后，让<mark>l指针元素与基准元素做比较</mark>，如果<mark>小于等于p，则l指针向右移动</mark>；如果<mark>大于p，则停止移动</mark>。</p> 
<p>按照此思路，后续步骤如下：</p> 
<p><img src="https://images2.imgbox.com/c6/e8/F7jf8rtA_o.png" alt="在这里插入图片描述"><br> 实现代码如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> quickSort <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> startIndex<span class="token punctuation">,</span><span class="token keyword">int</span> endIndex<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">//递归结束条件为startIndex大于或等于endIndex</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>startIndex<span class="token operator">&gt;=</span>endIndex<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">//得到基准元素位置</span>
        <span class="token keyword">int</span> pIndex<span class="token operator">=</span><span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>startIndex<span class="token punctuation">,</span>endIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//根据基准元素分两部分进行递归排序</span>
        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>startIndex<span class="token punctuation">,</span>pIndex<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>pIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>endIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*
    * 分治法（双边循环法）
    * arr  待排序数组
    * startIndex  起始下标
    * endIndex  结束下标
    * */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> startIndex<span class="token punctuation">,</span><span class="token keyword">int</span> endIndex<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> p<span class="token operator">=</span>arr<span class="token punctuation">[</span>startIndex<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//基准元素(可取随机位置)</span>
        <span class="token keyword">int</span> l<span class="token operator">=</span>startIndex<span class="token punctuation">;</span><span class="token comment">//左指针</span>
        <span class="token keyword">int</span> r<span class="token operator">=</span>endIndex<span class="token punctuation">;</span><span class="token comment">//右指针</span>

        <span class="token keyword">while</span><span class="token punctuation">(</span>l<span class="token operator">!=</span>r<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">//控制右指针向左移动，找到小于基准元素的那个数</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>l<span class="token operator">&lt;</span>r<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">&gt;</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                r<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">//控制左指针向右移动，找到大于基准元素的那个数</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>l<span class="token operator">&lt;</span>r<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">&lt;=</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                l<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">//交换l指针和r指针所指的元素</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">&lt;</span>r<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">int</span> tmp<span class="token operator">=</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">=</span>tmp<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment">//交换基准元素和重合点的元素</span>
        arr<span class="token punctuation">[</span>startIndex<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>
        arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">=</span>p<span class="token punctuation">;</span>
        <span class="token keyword">return</span> l<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/2c/1f/7Zbibgyc_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2_116"></a>2、单边循环法</h3> 
<p>双边循环更加直观，但代码比较麻烦，而单边循环法从数列的一边对元素进行遍历交换。</p> 
<p>开始循环选定基准元素p，再设置一个mark指针指向数列起始位置，mark代表着小于基准元素区域的右边界。</p> 
<p><mark>从基准元素的下一位开始遍历，若元素大于基准元素，则继续往后遍历。如果小于基准元素，先将mark指针右移一位，然后将最新遍历的元素与基准元素交换</mark>。</p> 
<p><img src="https://images2.imgbox.com/a0/4a/garyreav_o.png" alt="在这里插入图片描述"></p> 
<p><mark><strong>单边循环法与双边循环法主要是partition函数的实现不一样</strong></mark></p> 
<pre><code class="prism language-java"><span class="token comment">/*
     * 分治法（单边循环法）
     * arr  待排序数组
     * startIndex  起始下标
     * endIndex  结束下标
     * */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> startIndex<span class="token punctuation">,</span><span class="token keyword">int</span> endIndex<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> p<span class="token operator">=</span>arr<span class="token punctuation">[</span>startIndex<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//基准元素(可取随机位置)</span>
        <span class="token keyword">int</span> mark<span class="token operator">=</span>startIndex<span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>startIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>endIndex<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>mark<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                mark<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token keyword">int</span> tmp<span class="token operator">=</span>arr<span class="token punctuation">[</span>mark<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>mark<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>tmp<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment">//交换基准元素和mark指针的元素</span>
        arr<span class="token punctuation">[</span>startIndex<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>mark<span class="token punctuation">]</span><span class="token punctuation">;</span>
        arr<span class="token punctuation">[</span>mark<span class="token punctuation">]</span><span class="token operator">=</span>p<span class="token punctuation">;</span>
        <span class="token keyword">return</span> mark<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>可以看出，单边循环法只需要一个循环即可，比双边循环法要简单很多。</p> 
<p><img src="https://images2.imgbox.com/37/56/dwOFpXJY_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/668b6e6469737d8b1062a82c104af515/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">脸鉴AI开放平台：轻松上手的人工智能算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5fb70e5a633145da15f2f642b86d08d5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在SQL中，可以使用不同的函数来转换字符串日期格式。以下是一些常用的函数：</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>