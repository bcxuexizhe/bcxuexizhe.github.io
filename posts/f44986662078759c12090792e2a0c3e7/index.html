<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【百度云盘项目实践(1)】：探索JSON与Bundle库的结合应用 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/f44986662078759c12090792e2a0c3e7/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【百度云盘项目实践(1)】：探索JSON与Bundle库的结合应用">
  <meta property="og:description" content="hello ！大家好呀！ 欢迎大家来到我的Linux项目实战系列之《【百度云盘项目实践】：探索JSON与Bundle库的结合应用》，在这篇文章中，你将会学习到json数据格式，bundle库内对文件进行压缩与解压缩的过程，以及手绘UML图来帮助大家来理解，希望能让大家更能了解网络编程技术！！！
希望这篇文章能对你有所帮助，大家要是觉得我写的不错的话，那就点点免费的小爱心吧！（注：这章对于高性能服务器的实现非常重要哟！！！）
目录
一.Json
1.1 json数据
JSON对象
JSON数组
JSON语法规则
JSON与C&#43;&#43;的结合使用
1.2 Value实例
主要特性
常用操作
使用场景
1.3 json数据的序列化与反序列化
newStreamWriter()
newCharReader()
1.4 代码实例
二. bundle库 文件压缩：
文件解压：
一.Json 1.1 json数据 JSON（JavaScript Object Notation）是一种轻量级的数据交换格式。它基于JavaScript编程语言的一个子集，但因其文本格式清晰、易于解析和生成，被广泛用于数据交换和存储。JSON格式支持的数据结构包括对象（Object）和数组（Array）。
JSON对象 JSON对象是一个无序的键:值对集合。每个键值对中的键是一个字符串，后跟一个冒号，然后是值。值可以是字符串、数值、布尔值、数组、对象或null。例如：
{ &#34;name&#34;: &#34;张三&#34;, &#34;age&#34;: 30, &#34;isStudent&#34;: false, &#34;courses&#34;: [&#34;数学&#34;, &#34;物理&#34;, &#34;化学&#34;], &#34;address&#34;: { &#34;city&#34;: &#34;北京&#34;, &#34;street&#34;: &#34;长安街&#34; } } 在这个例子中，name、age、isStudent、courses和address是键，它们对应的值分别是字符串、数值、布尔值、数组和另一个对象。
JSON数组 JSON数组是一个有序的值列表，可以通过索引访问。数组中的值可以是字符串、数值、布尔值、数组、对象或null。例如：
[ { &#34;name&#34;: &#34;张三&#34;, &#34;age&#34;: 30 }, { &#34;name&#34;: &#34;李四&#34;, &#34;age&#34;: 25 } ] 这个例子中，数组包含两个对象，每个对象都有name和age属性。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-19T21:58:44+08:00">
    <meta property="article:modified_time" content="2024-05-19T21:58:44+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【百度云盘项目实践(1)】：探索JSON与Bundle库的结合应用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> <img alt="" height="938" src="https://images2.imgbox.com/e8/2f/fL0BCITa_o.jpg" width="1024"></p> 
<blockquote> 
 <p>hello ！大家好呀！ 欢迎大家来到我的Linux项目实战系列之《【百度云盘项目实践】：探索JSON与Bundle库的结合应用》，在这篇文章中，<strong>你将会学习到json数据格式，bundle库内对文件进行压缩与解压缩的过程</strong><strong>，以及手绘UML图来帮助大家来理解，希望能让大家更能了解网络编程技术！！！</strong></p> 
 <p>希望这篇文章能对你有所帮助，大家要是觉得我写的不错的话，那就点点免费的小爱心吧！（注：这章对于高性能服务器的实现非常重要哟！！！）</p> 
 <p><img alt="03d6d5d7168e4ccb946ff0532d6eb8b9.gif" height="93" src="https://images2.imgbox.com/46/38/LckIwGYg_o.gif" width="93">           </p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%C2%A0%E4%B8%80.Json-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%80.Json" rel="nofollow"> 一.Json</a></p> 
<p id="%C2%A01.1%20json%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#%C2%A01.1%20json%E6%95%B0%E6%8D%AE" rel="nofollow"> 1.1 json数据</a></p> 
<p id="JSON%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><a href="#JSON%E5%AF%B9%E8%B1%A1" rel="nofollow">JSON对象</a></p> 
<p id="JSON%E6%95%B0%E7%BB%84-toc" style="margin-left:80px;"><a href="#JSON%E6%95%B0%E7%BB%84" rel="nofollow">JSON数组</a></p> 
<p id="JSON%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99-toc" style="margin-left:80px;"><a href="#JSON%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99" rel="nofollow">JSON语法规则</a></p> 
<p id="JSON%E4%B8%8EC%2B%2B%E7%9A%84%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#JSON%E4%B8%8EC%2B%2B%E7%9A%84%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8" rel="nofollow">JSON与C++的结合使用</a></p> 
<p id="1.2%20Value%E5%AE%9E%E4%BE%8B-toc" style="margin-left:40px;"><a href="#1.2%20Value%E5%AE%9E%E4%BE%8B" rel="nofollow">1.2 Value实例</a></p> 
<p id="%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7-toc" style="margin-left:80px;"><a href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7" rel="nofollow">主要特性</a></p> 
<p id="%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C" rel="nofollow">常用操作</a></p> 
<p id="%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:80px;"><a href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">使用场景</a></p> 
<p id="1.3%20json%E6%95%B0%E6%8D%AE%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-toc" style="margin-left:40px;"><a href="#1.3%20json%E6%95%B0%E6%8D%AE%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96" rel="nofollow">1.3 json数据的序列化与反序列化</a></p> 
<p id="newStreamWriter()-toc" style="margin-left:80px;"><a href="#newStreamWriter%28%29" rel="nofollow">newStreamWriter()</a></p> 
<p id="newCharReader()-toc" style="margin-left:80px;"><a href="#newCharReader%28%29" rel="nofollow">newCharReader()</a></p> 
<p id="1.4%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B-toc" style="margin-left:40px;"><a href="#1.4%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B" rel="nofollow">1.4 代码实例</a></p> 
<p id="%E4%BA%8C.%20bundle%E5%BA%93%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%20bundle%E5%BA%93%C2%A0" rel="nofollow">二. bundle库 </a></p> 
<p id="%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%EF%BC%9A" rel="nofollow">文件压缩：</a></p> 
<p id="%C2%A0%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8E%8B%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A0%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8E%8B%EF%BC%9A" rel="nofollow"> 文件解压：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p> </p> 
<h2 id="%C2%A0%E4%B8%80.Json" style="background-color:transparent;"> 一.Json</h2> 
<h3 id="%C2%A01.1%20json%E6%95%B0%E6%8D%AE"> 1.1 json数据</h3> 
<p>        </p> 
<p>    JSON（JavaScript Object Notation）是一种轻量级的数据交换格式。它基于JavaScript编程语言的一个子集，但因其文本格式清晰、易于解析和生成，被广泛用于数据交换和存储。JSON格式支持的数据结构包括对象（Object）和数组（Array）。</p> 
<h4 id="JSON%E5%AF%B9%E8%B1%A1">JSON对象</h4> 
<p>JSON对象是一个无序的键:值对集合。每个键值对中的键是一个字符串，后跟一个冒号，然后是值。值可以是字符串、数值、布尔值、数组、对象或null。例如：</p> 
<pre><code class="language-cpp">{
  "name": "张三",
  "age": 30,
  "isStudent": false,
  "courses": ["数学", "物理", "化学"],
  "address": {
    "city": "北京",
    "street": "长安街"
  }
}
</code></pre> 
<p>在这个例子中，<code>name</code>、<code>age</code>、<code>isStudent</code>、<code>courses</code>和<code>address</code>是键，它们对应的值分别是字符串、数值、布尔值、数组和另一个对象。</p> 
<h4 id="JSON%E6%95%B0%E7%BB%84">JSON数组</h4> 
<p>JSON数组是一个有序的值列表，可以通过索引访问。数组中的值可以是字符串、数值、布尔值、数组、对象或null。例如：</p> 
<pre><code class="language-cpp">[
  {
    "name": "张三",
    "age": 30
  },
  {
    "name": "李四",
    "age": 25
  }
]
</code></pre> 
<p>这个例子中，数组包含两个对象，每个对象都有<code>name</code>和<code>age</code>属性。</p> 
<h4 id="JSON%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99">JSON语法规则</h4> 
<ul><li>数据在键值对中</li><li>数据由逗号分隔</li><li>花括号保存对象</li><li>方括号保存数组</li></ul> 
<h4 id="JSON%E4%B8%8EC%2B%2B%E7%9A%84%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8">JSON与C++的结合使用</h4> 
<p>在C++中，可以使用如<code>nlohmann/json</code>等库来解析和生成JSON数据。例如，使用这个库解析上述JSON对象：</p> 
<pre><code class="language-cpp">#include &lt;nlohmann/json.hpp&gt;
#include &lt;iostream&gt;

using json = nlohmann::json;

int main() {
    std::string jsonString = "{\"name\": \"张三\", \"age\": 30}";
    json j = json::parse(jsonString);

    std::cout &lt;&lt; "姓名: " &lt;&lt; j["name"].get&lt;std::string&gt;() &lt;&lt; std::endl;
    std::cout &lt;&lt; "年龄: " &lt;&lt; j["age"].get&lt;int&gt;() &lt;&lt; std::endl;

    return 0;
}
</code></pre> 
<p>这段代码解析了一个包含姓名和年龄的JSON对象，并打印出这些信息。</p> 
<p>JSON因其简洁和易用性，在Web应用、移动应用和许多其他场景中被广泛使用，特别是在数据交换和配置文件中。</p> 
<p></p> 
<h3 id="1.2%20Value%E5%AE%9E%E4%BE%8B">1.2 Value实例</h3> 
<blockquote> 
 <p>在JSONCpp库中，<code>Json::Value</code>实例是表示JSON数据结构的基本对象。它可以表示JSON中的各种数据类型，如对象（Object）、数组（Array）、字符串（String）、数值（Number）、布尔值（Boolean）和null。<span style="color:#4da8ee;"><code>Json::Value</code>实例是JSONCpp库的核心，用于创建、修改和访问JSON数据。</span></p> 
</blockquote> 
<h4 id="%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7">主要特性</h4> 
<ul><li><strong>多态性</strong>：一个<code>Json::Value</code>实例可以表示不同的数据类型。</li><li><strong>动态性</strong>：可以在运行时改变<code>Json::Value</code>实例所表示的数据类型。</li><li><strong>易于使用</strong>：通过简单的API，可以方便地操作JSON数据。</li></ul> 
<h4 id="%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C">常用操作</h4> 
<ul><li><strong>创建和赋值</strong>： <pre><code class="language-cpp">Json::Value value;
value["key"] = "value";  // 创建一个键值对
value["array"].append(1);  // 向数组中添加元素
</code></pre> </li><li><strong>访问数据</strong>： <pre><code class="language-cpp">std::string str = value["key"].asString();
int num = value["array"][0].asInt();
</code></pre> </li><li><strong>检查数据类型</strong>： <pre><code class="language-cpp">if (value.isObject()) {
    // 处理对象
}
if (value.isArray()) {
    // 处理数组
}
</code></pre> </li><li><strong>遍历对象和数组</strong>： <pre><code class="language-cpp">// 遍历对象
for (Json::Value::const_iterator it = value.begin(); it != value.end(); ++it) {
    std::string key = it.key().asString();
    Json::Value keyValue = *it;
    // 处理键值对
}

// 遍历数组
for (unsigned int i = 0; i &lt; value.size(); ++i) {
    Json::Value arrayElement = value[i];
    // 处理数组元素
}
</code></pre> </li></ul> 
<blockquote> 
 <h4 id="%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">使用场景</h4> 
 <ul><li><strong>序列化</strong>：将C++数据结构转换为JSON字符串。</li><li><strong>反序列化</strong>：将JSON字符串解析回C++数据结构。</li><li><strong>数据交换</strong>：在不同系统或服务间交换数据。</li><li><strong>配置文件</strong>：读取和写入配置数据。</li></ul> 
 <p><code>Json::Value</code>实例是JSONCpp库的基础，通过它可以轻松地处理复杂的JSON数据结构。</p> 
</blockquote> 
<p> </p> 
<h3 id="1.3%20json%E6%95%B0%E6%8D%AE%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96">1.3 json数据的序列化与反序列化</h3> 
<blockquote> 
 <p>在C++中，序列化是指将数据结构（如对象、数组等）转换为JSON字符串的过程，而反序列化则是将JSON字符串解析回相应的数据结构。使用如<code>nlohmann/json</code>库可以方便地进行这些操作。</p> 
 <p> </p> 
</blockquote> 
<p>在JSONCpp库中，<code>newStreamWriter()</code>和<code>newCharReader()</code>是用于JSON数据序列化和反序列化的重要函数。</p> 
<h4 id="newStreamWriter()" style="background-color:transparent;">newStreamWriter()</h4> 
<p><code>newStreamWriter()</code>函数是<code>Json::StreamWriterBuilder</code>类的一个方法，用于创建一个<code>Json::StreamWriter</code>对象，该对象负责将<code>Json::Value</code>对象转换为JSON格式的字符串。</p> 
<p>作用</p> 
<ul><li><strong>序列化</strong>：将C++中的<code>Json::Value</code>对象转换为JSON字符串。</li><li><strong>格式化</strong>：可以设置缩进、空格等格式化选项，使生成的JSON字符串更易于阅读。</li></ul> 
<p>使用方法</p> 
<ol><li>创建<code>StreamWriterBuilder</code>实例。</li><li>通过<code>newStreamWriter()</code>创建<code>StreamWriter</code>对象。</li><li>使用<code>StreamWriter</code>的<code>write()</code>方法将<code>Json::Value</code>对象转换为字符串。</li></ol> 
<p style="background-color:transparent;">示例</p> 
<pre><code class="language-cpp">Json::StreamWriterBuilder swb;
std::unique_ptr&lt;Json::StreamWriter&gt; sw(swb.newStreamWriter());
stringstream ss;
sw-&gt;write(root, &amp;ss);  // 将root序列化为JSON字符串，存储在ss中
</code></pre> 
<h4 id="newCharReader()" style="background-color:transparent;">newCharReader()</h4> 
<p><code>newCharReader()</code>函数是<code>Json::CharReaderBuilder</code>类的一个方法，用于创建一个<code>Json::CharReader</code>对象，该对象负责将JSON字符串解析为<code>Json::Value</code>对象。</p> 
<p>作用</p> 
<ul><li><strong>反序列化</strong>：将JSON字符串解析回C++中的<code>Json::Value</code>对象。</li><li><strong>错误处理</strong>：在解析过程中，如果遇到错误，可以提供错误信息。</li></ul> 
<p>使用方法</p> 
<ol><li>创建<code>CharReaderBuilder</code>实例。</li><li>通过<code>newCharReader()</code>创建<code>CharReader</code>对象。</li><li>使用<code>CharReader</code>的<code>parse()</code>方法将JSON字符串解析为<code>Json::Value</code>对象。</li></ol> 
<p>示例</p> 
<pre><code class="language-cpp">Json::CharReaderBuilder cwb;
unique_ptr&lt;Json::CharReader&gt; cw(cwb.newCharReader());
string err;
bool ret = cw-&gt;parse(json_str.c_str(), json_str.c_str() + json_str.size(), &amp;root2, &amp;err);
// 解析json_str到root2，如果失败，错误信息存储在err中
</code></pre> 
<blockquote> 
 <p>总结</p> 
 <p><code>newStreamWriter()</code>和<code>newCharReader()</code>是JSONCpp库中用于JSON数据序列化和反序列化的重要工具。<code>newStreamWriter()</code>用于创建一个可以将<code>Json::Value</code>对象转换为JSON字符串的<code>StreamWriter</code>对象，而<code>newCharReader()</code>用于创建一个可以将JSON字符串解析回<code>Json::Value</code>对象的<code>CharReader</code>对象。这些功能在处理JSON数据时非常关键，尤其是在需要与JSON格式数据进行交互的应用程序中。</p> 
</blockquote> 
<h3 id="1.4%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B">1.4 代码实例</h3> 
<p>        这是一个典型的json数据序列号与反序列化的程序：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;sstream&gt;
#include&lt;string&gt;
#include&lt;memory&gt;
#include&lt;jsoncpp/json/json.h&gt;
using namespace std;

int main(){
    const char * name = "小明";
    int age = 18 ;
    float score[]= {77.5 , 88 ,93.6};
    //创建一个Value实例
    Json::Value root;

    //向Value实例中添加数据
    root["姓名"] = name;
    root["年龄"] = age;
    root["成绩"].append(score[0]);
    root["成绩"].append(score[1]);
    root["成绩"].append(score[2]);

    //创建一个StreamWriterBuilder实例
    Json::StreamWriterBuilder swb ;

    std::unique_ptr&lt;Json::StreamWriter&gt; sw(swb.newStreamWriter());

    stringstream ss;
    //开始序列化,json序列化的字符串保存在ss中
    sw-&gt;write(root , &amp;ss);
    cout&lt;&lt;ss.str()&lt;&lt;endl;

    //反序列化过程
    string json_str = ss.str();//获取json字符串

    Json::Value root2;

    Json::CharReaderBuilder cwb;

    unique_ptr&lt;Json::CharReader&gt; cw(cwb.newCharReader());

    string err;
    //反序列化过程
    bool ret = cw-&gt;parse(json_str.c_str() ,json_str.c_str() + json_str.size() , &amp;root2 , &amp;err);
    if(ret == false){
        cout&lt;&lt;"反序列化失败"&lt;&lt; err &lt;&lt;endl;
    }

    // 输出反序列化后的数据
    cout &lt;&lt; "姓名: " &lt;&lt; root2["姓名"].asCString() &lt;&lt; endl;
    cout &lt;&lt; "年龄: " &lt;&lt; root2["年龄"].asInt() &lt;&lt; endl;
    cout &lt;&lt; "成绩: ";
    for (int i = 0; i &lt; root2["成绩"].size(); ++i) {
        cout &lt;&lt; root2["成绩"][i].asFloat() &lt;&lt; " ";
    }
    cout &lt;&lt; endl;


    return 0;
}</code></pre> 
<p> </p> 
<h2 id="%E4%BA%8C.%20bundle%E5%BA%93%C2%A0" style="background-color:transparent;">二. bundle库 </h2> 
<blockquote> 
 <p>    <span style="color:#4da8ee;">    bundle库中是有关于文件压缩与解压缩的23中方法的一个库，我们在云盘项目中，当用户进行文件的上传与下载时，我们需要对文件进行压缩与解压缩的过程，此时我们可以直接调用bundle库中的对应API来对我们文件进行处理</span>，由于这个库内容比较简单，我就展示一个简单的示例使用程序：</p> 
</blockquote> 
<h3 id="%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%EF%BC%9A">文件压缩：</h3> 
<p>这是压缩程序：当我们选择一个文件，可以按照我们指定的方式进行压缩为指定的文件。</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;fstream&gt;
#include"bundle.h"
using namespace std;
int main(int argc , char * argv[]){
    std::cout&lt;&lt;"argv[1]是原始文件名字\n" ;
    std ::cout&lt;&lt;"argv[2]是压缩包名字\n";
    if(argc &lt; 3) return -1;

    std::string ifilename = argv[1]; 
    std::string ofilename = argv[2];

    std::ifstream ifs;//创建文件输入输出流
    ifs.open(ifilename , std::ios::binary);//二进制打开文件
    ifs.seekg(0,std::ios::end);//跳转到文件末尾
    size_t fsize = ifs.tellg();//获取文件大小
    ifs.seekg(0,std::ios::beg);//跳转到文件起始

    std::string body;
    body.resize(fsize);//调整body大小为文件大小
    ifs.read(&amp;body[0],fsize);//读取文件所有数据到body

    std::string packed = bundle::pack(bundle::LZIP,body);//以Lzip格式压缩文件


    std::ofstream ofs;
    ofs.open(ofilename, std::ios::binary);//打开压缩包
    ofs.write(&amp;packed[0],packed.size());//将压缩后的文件写入压缩包文件
    ifs.close();
    ofs.close();
    
    return 0;
}
</code></pre> 
<p>这是我们压缩前httplib.h文件的大小，为321K。</p> 
<p> <img alt="" height="62" src="https://images2.imgbox.com/3a/a6/3uXZHsxz_o.png" width="443"></p> 
<p>我们进行压缩为.lz压缩包后： 明显我们的压缩包大小变成了49k，压缩比例还是很客观的。</p> 
<p> <img alt="" height="63" src="https://images2.imgbox.com/bf/9e/1IiIlzM7_o.png" width="440"></p> 
<p> </p> 
<h3 id="%C2%A0%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8E%8B%EF%BC%9A"> 文件解压：</h3> 
<p>这里给一个文件解压到另外一个文件的程序：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;fstream&gt;
#include"bundle.h"
using namespace std;
int main(int argc , char *argv[]){
    if(argc &lt;3){
        cout &lt;&lt;"argv[1]是压缩包名称"&lt;&lt;endl;
        cout&lt;&lt;"argv[2]是解压后的文件名称"&lt;&lt;endl;
        return -1;
    }
    string ifilename = argv[1] ;//获取压缩包名称
    string ofilename = argv[2];//获取解压后的文件名

    ifstream ifs;
    ifs.open(ifilename ,std::ios::binary);//打开压缩包
    ifs.seekg(0 , ios::end);//跳转到文件末尾
    size_t fsize = ifs.tellg();//获取文件大小
    ifs.seekg(0 ,ios::beg);//跳转到起始位置

    std::string body;
    body.resize(fsize);
    ifs.read(&amp;body[0],fsize);//将压缩包数据传入body
    ifs.close();

    string unpacked = bundle::unpack(body);//进行解压缩,数据存入unpacked

    ofstream ofs ;
    ofs.open(ofilename, std::ios::binary);
    ofs.write(&amp;unpacked[0] , unpacked.size());//数据写入解压文件
    ofs.close();



    return 0;
}</code></pre> 
<p>这个程序的实机演示和上面差不多，大家可以自己试试，这里不过多演示了。</p> 
<blockquote> 
 <p>       好啦！到这里这篇文章就结束啦，关于实例代码中我写了很多注释，如果大家还有不懂得，可以评论区或者私信我都可以哦<img alt="4d7d9707063b4d9c90ac2bca034b5705.png" src="https://images2.imgbox.com/8a/23/P815ySz8_o.png">！！ 感谢大家的阅读，我还会持续创造网络编程相</p> 
 <p>关内容的，记得点点小爱心和关注哟！</p> 
 <p><img alt="2cd0d6ee4ef84605933ed7c04d71cfef.jpeg" height="126" src="https://images2.imgbox.com/e9/5d/0jsl278Q_o.jpg" width="130">   </p> 
</blockquote> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ea3e02e3c6640c0de81beb6e7d753e0f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【开源】2024最新python豆瓣电影数据爬虫&#43;可视化分析项目</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/64ab23115e979161338109f01b57d0ec/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于SSM实现的新生报到系统源码&#43;数据库&#43;论文</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>