<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 【数据结构】 TreeSet&amp;TreeMap（二叉搜索树详解）【神装】 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/91370afe8f664adaba7de336e0c1bea3/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Java 【数据结构】 TreeSet&amp;TreeMap（二叉搜索树详解）【神装】">
  <meta property="og:description" content="登神长阶
第八神装 TreeSet
第九神装 TreeMap
目录
💉 一.二叉搜索树
🩸1. 定义
💊2. 基本操作
🩹3. 插入操作
🩼4. 查找操作
🩺5. 删除操作*
🩻6. 遍历操作
🪒7.性能分析
🪥二.TreeSet
🧽1. 定义
🧻 2.操作
🪣3. Set主要特性
🫧4. TreeSet的内部实现
🛒5. 应用场景
🧯三.TreeMap
🧹1.定义
🪤2.操作
🧷3.Map的主要特性
🧿4. TreeMap的内部实现
🪬5.应用场景 🗿四.总结与反思
💉 一.二叉搜索树 首先我们要知道TreeSet/TreeMap底层都采用的都是一种二叉搜索树（也叫自平衡二叉树），因此我们先来了解一下二叉搜索树。
对于他的学习若之前没有了解的可以参考：Java 【数据结构】 二叉树（Binary_Tree）【神装】
🩸1. 定义 二叉搜索树（Binary Search Tree，简称BST），是一种特殊的二叉树，它具有以下性质：
每个节点都有一个键（Key）和两个指向其他节点的指针（左子指针和右子指针）。任意节点的左子树中的所有键都小于该节点的键。任意节点的右子树中的所有键都大于该节点的键。左右子树也都是二叉搜索树。不存在键值相等的节点。 在Java中，我们可以这样定义一个二叉搜索树：
public class BinarySearchTree { private class Node { int val; Node left; Node right; Node(int val) { this.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-14T12:07:22+08:00">
    <meta property="article:modified_time" content="2024-05-14T12:07:22+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 【数据结构】 TreeSet&amp;TreeMap（二叉搜索树详解）【神装】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" height="140" src="https://images2.imgbox.com/1a/cc/gSe6kJdp_o.png" width="407"></p> 
<p class="img-center"><img alt="" height="80" src="https://images2.imgbox.com/55/89/1Qny6TYe_o.png" width="640"></p> 
<p style="text-align:center;"><strong>登神长阶</strong></p> 
<p style="text-align:center;"><strong> 第八神装 TreeSet</strong></p> 
<p style="text-align:center;"><strong>   第九神装  TreeMap</strong></p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%F0%9F%92%89%C2%A0%E4%B8%80.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-toc" style="margin-left:0px;"><a href="#%F0%9F%92%89%C2%A0%E4%B8%80.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91" rel="nofollow">💉 一.二叉搜索树</a></p> 
<p id="%F0%9F%A9%B81.%20%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#%F0%9F%A9%B81.%20%E5%AE%9A%E4%B9%89" rel="nofollow">🩸1. 定义</a></p> 
<p id="%F0%9F%92%8A2.%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#%F0%9F%92%8A2.%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C" rel="nofollow">💊2. 基本操作</a></p> 
<p id="%F0%9F%A9%B93.%20%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#%F0%9F%A9%B93.%20%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C" rel="nofollow">🩹3. 插入操作</a></p> 
<p id="%F0%9F%A9%BC4.%20%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#%F0%9F%A9%BC4.%20%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C" rel="nofollow">🩼4. 查找操作</a></p> 
<p id="%F0%9F%A9%BA5.%20%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C*-toc" style="margin-left:40px;"><a href="#%F0%9F%A9%BA5.%20%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C*" rel="nofollow">🩺5. 删除操作*</a></p> 
<p id="%F0%9F%A9%BB6.%20%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#%F0%9F%A9%BB6.%20%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C" rel="nofollow">🩻6. 遍历操作</a></p> 
<p id="%F0%9F%AA%927.%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#%F0%9F%AA%927.%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90" rel="nofollow">🪒7.性能分析</a></p> 
<p id="%F0%9F%AA%A5%E4%BA%8C.TreeSet-toc" style="margin-left:0px;"><a href="#%F0%9F%AA%A5%E4%BA%8C.TreeSet" rel="nofollow">🪥二.TreeSet</a></p> 
<p id="%F0%9F%A7%BD1.%20%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#%F0%9F%A7%BD1.%20%E5%AE%9A%E4%B9%89" rel="nofollow">🧽1. 定义</a></p> 
<p id="%F0%9F%A7%BB%C2%A02.%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#%F0%9F%A7%BB%C2%A02.%E6%93%8D%E4%BD%9C" rel="nofollow">🧻 2.操作</a></p> 
<p id="%F0%9F%AA%A33.%20Set%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#%F0%9F%AA%A33.%20Set%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7" rel="nofollow">🪣3. Set主要特性</a></p> 
<p id="%F0%9F%AB%A74.%20TreeSet%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%F0%9F%AB%A74.%20TreeSet%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0" rel="nofollow">🫧4. TreeSet的内部实现</a></p> 
<p id="%F0%9F%9B%925.%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#%F0%9F%9B%925.%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">🛒5. 应用场景</a></p> 
<p id="%F0%9F%A7%AF%E4%B8%89.TreeMap-toc" style="margin-left:0px;"><a href="#%F0%9F%A7%AF%E4%B8%89.TreeMap" rel="nofollow">🧯三.TreeMap</a></p> 
<p id="%F0%9F%A7%B91.%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#%F0%9F%A7%B91.%E5%AE%9A%E4%B9%89" rel="nofollow">🧹1.定义</a></p> 
<p id="%F0%9F%AA%A42.%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#%F0%9F%AA%A42.%E6%93%8D%E4%BD%9C" rel="nofollow">🪤2.操作</a></p> 
<p id="%F0%9F%A7%B73.Map%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#%F0%9F%A7%B73.Map%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7" rel="nofollow">🧷3.Map的主要特性</a></p> 
<p id="%F0%9F%A7%BF4.%20TreeMap%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%F0%9F%A7%BF4.%20TreeMap%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0" rel="nofollow">🧿4. TreeMap的内部实现</a></p> 
<p id="%F0%9F%AA%AC5.%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%C2%A0-toc" style="margin-left:40px;"><a href="#%F0%9F%AA%AC5.%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%C2%A0" rel="nofollow">🪬5.应用场景 </a></p> 
<p id="%F0%9F%97%BF%E5%9B%9B.%E6%80%BB%E7%BB%93%E4%B8%8E%E5%8F%8D%E6%80%9D-toc" style="margin-left:0px;"><a href="#%F0%9F%97%BF%E5%9B%9B.%E6%80%BB%E7%BB%93%E4%B8%8E%E5%8F%8D%E6%80%9D" rel="nofollow">🗿四.总结与反思</a></p> 
<hr> 
<h2 id="%F0%9F%92%89%C2%A0%E4%B8%80.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">💉 一.二叉搜索树</h2> 
<p>首先我们要知道<strong>TreeSet/TreeMap</strong>底层都采用的都是一种二叉搜索树（也叫自平衡二叉树），因此我们先来了解一下二叉搜索树。</p> 
<p>对于他的学习若之前没有了解的可以参考：<a class="link-info" href="https://blog.csdn.net/2302_79806056/article/details/138137558?spm=1001.2014.3001.5501" title="Java 【数据结构】 二叉树（Binary_Tree）【神装】">Java 【数据结构】 二叉树（Binary_Tree）【神装】</a></p> 
<h3 id="%F0%9F%A9%B81.%20%E5%AE%9A%E4%B9%89">🩸1. 定义</h3> 
<p>二叉搜索树（Binary Search Tree，简称BST），是一种特殊的二叉树，它具有以下性质：</p> 
<ul><li>每个节点都有一个键（Key）和两个指向其他节点的指针（左子指针和右子指针）。</li><li>任意节点的左子树中的所有键都小于该节点的键。</li><li>任意节点的右子树中的所有键都大于该节点的键。</li><li>左右子树也都是二叉搜索树。</li><li>不存在键值相等的节点。</li></ul> 
<p class="img-center"><img alt="" height="271" src="https://images2.imgbox.com/e1/0a/Wex5yhqt_o.png" width="467"></p> 
<p>在Java中，我们可以这样定义一个二叉搜索树：</p> 
<pre><code>public class BinarySearchTree {
    private class Node {
        int val;
        Node left;
        Node right;
        
        Node(int val) {
            this.val = val;
            left = null;
            right = null;
        }
    }
    
    private Node root;
    
    // 构造函数、插入方法、查找方法、删除方法等...
}
</code></pre> 
<h3 id="%F0%9F%92%8A2.%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">💊2. 基本操作</h3> 
<p>二叉搜索树支持以下基本操作：</p> 
<ul><li><strong>插入（Insert）</strong>：向树中插入一个新节点，保持树的二叉搜索性质。</li><li><strong>查找（Search）</strong>：在树中查找一个特定的节点。</li><li><strong>删除（Delete）</strong>：从树中删除一个节点，并保持树的二叉搜索性质。</li><li><strong>遍历（Traverse）</strong>：对树进行遍历，常用的遍历方式有前序、中序和后序遍历。</li></ul> 
<blockquote> 
 <p>接下来我们详细介绍一下它的各个操作，因为后续二叉树本身是数据结构中一个很关键的知识点，像红黑树，AVL树等等，我们需要牢牢掌握！</p> 
</blockquote> 
<h3 id="%F0%9F%A9%B93.%20%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C">🩹3. 插入操作</h3> 
<p>插入操作的步骤如下：</p> 
<ol><li>创建新节点。</li><li>比较新节点的键与根节点的键： 
  <ul><li>如果新节点的键小于根节点的键，则将新节点插入到根节点的左子树中。</li><li>如果新节点的键大于根节点的键，则将新节点插入到根节点的右子树中。</li></ul></li><li>如果插入点是空，则直接在新位置插入新节点。</li><li>如果插入点非空，则递归地在相应子树中进行插入操作。</li></ol> 
<p class="img-center"><img alt="" height="583" src="https://images2.imgbox.com/04/e4/tYT4a5Gz_o.png" width="1200"></p> 
<p>代码: </p> 
<pre><code> /**
     * 插入一个元素
     * @param key
     */
    public void insert(int key) {
        TreeNode node=new TreeNode(key);
        //若该搜索树为空，则直接作为根节点；
        if (root==null){
            root=node;
        }

        TreeNode cur=root;
        TreeNode parent=null;

        while(cur!=null){
            if (cur.key&lt;key){
                parent = cur;
                cur=cur.right;
            }else if(cur.key&gt;key){
                parent = cur;
                cur=cur.left;
            }else{
                return ;
            }
        }

        if (parent.key&gt;key){
            parent.left=node;
        }else{
            parent.right=node;
        }

    }</code></pre> 
<h3 id="%F0%9F%A9%BC4.%20%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C">🩼4. 查找操作</h3> 
<p>查找操作的步骤如下：</p> 
<ol><li>从根节点开始比较。</li><li>如果查找的键小于当前节点的键，则递归地在左子树中查找。</li><li>如果查找的键大于当前节点的键，则递归地在右子树中查找。</li><li>如果找到节点，则返回该节点。</li><li>如果没有找到，则返回null。</li></ol> 
<p class="img-center"><img alt="" height="696" src="https://images2.imgbox.com/43/bd/b4csSBup_o.png" width="1200"></p> 
<p>代码</p> 
<pre><code> //查找key是否存在
    public TreeNode search(int key) {
        TreeNode cur =root;
        while(cur!=null){
            if (cur.key&lt;key){
                cur=cur.right;
            }else if(cur.key&gt;key){
                cur=cur.left;
            }else{
                return cur;
            }
        }
        return null;
    }</code></pre> 
<h3 id="%F0%9F%A9%BA5.%20%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C*">🩺5. 删除操作*</h3> 
<div> 
 <span style="color:#333333;"><strong>设待删除结点为</strong></span> 
 <span style="color:#333333;"><strong> cur, </strong></span> 
 <span style="color:#333333;"><strong>待删除结点的双亲结点为</strong></span> 
 <span style="color:#333333;"><strong> parent </strong></span> 
</div> 
<div> 
 <span style="color:#333333;">1. </span> 
 <span style="color:#333333;"><strong>cur.left == null </strong></span> 
</div> 
<ol><li><span style="color:#333333;">cur </span><span style="color:#333333;">是</span><span style="color:#333333;"> root</span><span style="color:#333333;">，则</span><span style="color:#333333;"> root = cur.right </span></li><li><span style="color:#333333;">cur </span><span style="color:#333333;">不是</span><span style="color:#333333;"> root</span><span style="color:#333333;">，</span><span style="color:#333333;">cur </span><span style="color:#333333;">是</span><span style="color:#333333;"> parent.left</span><span style="color:#333333;">，则</span><span style="color:#333333;"> parent.left = cur.right </span></li><li><span style="color:#333333;">cur </span><span style="color:#333333;">不是</span><span style="color:#333333;"> root</span><span style="color:#333333;">，</span><span style="color:#333333;">cur </span><span style="color:#333333;">是</span><span style="color:#333333;"> parent.right</span><span style="color:#333333;">，则</span><span style="color:#333333;"> parent.right = cur.right </span></li></ol> 
<div> 
 <span style="color:#333333;">2. </span> 
 <span style="color:#333333;"><strong>cur.right == null </strong></span> 
</div> 
<ol><li><span style="color:#333333;">cur </span><span style="color:#333333;">是</span><span style="color:#333333;"> root</span><span style="color:#333333;">，则</span><span style="color:#333333;"> root = cur.left </span></li><li><span style="color:#333333;">cur 不是</span><span style="color:#333333;"> root</span><span style="color:#333333;">，</span><span style="color:#333333;">cur </span><span style="color:#333333;">是</span><span style="color:#333333;"> parent.left</span><span style="color:#333333;">，则</span><span style="color:#333333;"> parent.left = cur.left</span></li><li><span style="color:#333333;">cur </span><span style="color:#333333;">不是</span><span style="color:#333333;"> root</span><span style="color:#333333;">，</span><span style="color:#333333;">cur </span><span style="color:#333333;">是</span><span style="color:#333333;"> parent.right</span><span style="color:#333333;">，则</span><span style="color:#333333;"> parent.right = cur.left</span></li></ol> 
<div> 
 <div> 
  <span style="color:#333333;">3. </span> 
  <span style="color:#333333;"><strong>cur.left != null &amp;&amp; cur.right != null </strong></span> 
 </div> 
 <ul><li><span style="color:#333333;">需要使用</span><span style="color:#333333;"><strong>替换法</strong></span><span style="color:#333333;">进行删除，即在它的右子树中寻找中序下的第一个结点</span><span style="color:#333333;">(</span><span style="color:#333333;">关键码最小</span><span style="color:#333333;">)</span><span style="color:#333333;">，用它的值填补到被删除节点中，再来处理该结点的删除问题</span></li></ul> 
 <p><span style="color:#333333;">代码</span></p> 
 <pre><code>//删除key的值
    public boolean remove(int key) {
        TreeNode cur =root;
        TreeNode parent=null;
        while(cur!=null){
            if (cur.key&gt;key){
                parent=cur;
                cur=cur.left;
            }else if (cur.key&lt;key){
                parent=cur;
                cur=cur.right;
            }else{
                removeNode(parent,cur);
                return true;
            }
        }
        return false;
    }

    public void removeNode(TreeNode parent,TreeNode cur){
        if (cur.left==null){//左子树为空
            if (cur==root){
                root=cur.right;
            }else if(cur==parent.left){
                parent.left=cur.right;
            }else{
                parent.right=cur.right;
            }
        }else if (cur.right==null){//右子树为空
            if (cur==root){
                root=cur.left;
            }else if (cur==parent.left){
                parent.left=cur.left;
            }else{
                parent.right=cur.left;
            }
        }else{//左右子树都不为空 右子树的最小值代替
            TreeNode targetp=cur;
            TreeNode target=cur.right;
            while(target!=null){
                targetp=target;
                target=target.left;
            }
            cur.key=target.key;
            //删除原本数值
            if (targetp.left==target){
                targetp.left=target.left;
            }else{
                targetp.right=target.right;
            }
        }
    }</code></pre> 
</div> 
<h3 id="%F0%9F%A9%BB6.%20%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C">🩻6. 遍历操作</h3> 
<p>二叉搜索树的遍历操作与普通二叉树相同，可以使用前序、中序和后序遍历。</p> 
<blockquote> 
 <p>中序遍历会按照从小到大的顺序访问所有节点，是一个有序数列</p> 
</blockquote> 
<p>前序遍历代码举例</p> 
<pre><code>  public void prevOreder(TreeNode root){
        if (root==null){
            return;
        }
        prevOreder(root.left);
        System.out.print(root.key+" ");
        prevOreder(root.right);
    }</code></pre> 
<p>其余遍历方式，包括非递归的遍历方式：  <a class="link-info" href="https://blog.csdn.net/2302_79806056/article/details/138137558?spm=1001.2014.3001.5501" title="Java 【数据结构】 二叉树（Binary_Tree）【神装】">Java 【数据结构】 二叉树（Binary_Tree）【神装】</a></p> 
<h3 id="%F0%9F%AA%927.%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">🪒7.性能分析</h3> 
<div> 
 <span style="color:#333333;">        插入和删除操作都必须先查找，查找效率代表了二叉搜索树中各个操作的性能。对有n个结点的二叉搜索树，若每个元素查找的概率相等，则二叉搜索树平均查找长度是结点在二叉搜索树的深度的函数，即结点越深，则比较次数越多。 </span> 
</div> 
<div> 
 <span style="color:#333333;">        但对于同一个关键码集合，如果各关键码插入的次序不同，可能得到不同结构的二叉搜索树：</span> 
 <p class="img-center"><img alt="" height="813" src="https://images2.imgbox.com/7a/fa/o4Z4VpVm_o.png" width="1200"></p> 
</div> 
<blockquote> 
 <div> 
  <span style="color:#333333;">最优情况下，二叉搜索树为完全二叉树，其平均比较次数为：log N</span> 
 </div> 
 <div> 
  <span style="color:#333333;">最差情况下，二叉搜索树退化为单支树，其平均比较次数为：N/2</span> 
 </div> 
</blockquote> 
<h2 id="%F0%9F%AA%A5%E4%BA%8C.TreeSet">🪥二.TreeSet</h2> 
<h3 id="%F0%9F%A7%BD1.%20%E5%AE%9A%E4%B9%89">🧽1. 定义</h3> 
<p>TreeSet是Java集合框架中的一种有序集合，它实现了Set接口，因此具有<strong>不允许重复元素</strong>的特性。与HashSet不同，TreeSet使用红黑树数据结构来存储元素，这使得元素在集合中保持有序。</p> 
<p class="img-center"><img alt="" height="754" src="https://images2.imgbox.com/a9/f5/CEA1vYEA_o.png" width="1200"></p> 
<p class="img-center"><img alt="" height="297" src="https://images2.imgbox.com/28/8c/Ixfk8gkB_o.png" width="420"></p> 
<h3 id="%F0%9F%A7%BB%C2%A02.%E6%93%8D%E4%BD%9C">🧻 2.操作</h3> 
<table border="1" cellpadding="1" cellspacing="1" style="width:700px;"><tbody><tr><td> 
    <div> 
     <span style="color:#333333;"><strong>方法</strong></span> 
    </div> </td><td> 
    <div> 
     <span style="color:#333333;"><strong>解释</strong></span> 
    </div> </td></tr><tr><td> 
    <div> 
     <span style="color:#333333;">boolean </span> 
     <span style="color:#4183c4;">add</span> 
     <span style="color:#333333;">(E e)</span> 
    </div> </td><td> 
    <div> 
     <span style="color:#333333;">添加元素，但重复元素不会被添加成功</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <span style="color:#333333;">void </span> 
     <span style="color:#4183c4;">clear</span> 
     <span style="color:#333333;">() </span> 
    </div> </td><td> 
    <div> 
     <span style="color:#333333;">清空集合</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <span style="color:#333333;">boolean </span> 
     <span style="color:#4183c4;">contains</span> 
     <span style="color:#333333;">(Object o) </span> 
    </div> </td><td> 
    <div> 
     <span style="color:#333333;">判断</span> 
     <span style="color:#333333;"> o </span> 
     <span style="color:#333333;">是否在集合中</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <span style="color:#333333;">Iterator&lt;E&gt; </span> 
     <span style="color:#4183c4;">iterator</span> 
     <span style="color:#333333;">()</span> 
    </div> </td><td> 
    <div> 
     <span style="color:#333333;">返回迭代器</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <span style="color:#333333;">boolean </span> 
     <span style="color:#4183c4;">remove</span> 
     <span style="color:#333333;">(Object o) </span> 
    </div> </td><td> 
    <div> 
     <span style="color:#333333;">删除集合中的</span> 
     <span style="color:#333333;"> o</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <span style="color:#333333;">int size() </span> 
    </div> </td><td> 
    <div> 
     <span style="color:#333333;">返回</span> 
     <span style="color:#333333;">set</span> 
     <span style="color:#333333;">中元素的个数 </span> 
    </div> </td></tr><tr><td> 
    <div> 
     <span style="color:#333333;">boolean isEmpty() </span> 
    </div> </td><td> 
    <div> 
     <span style="color:#333333;">检测</span> 
     <span style="color:#333333;">set</span> 
     <span style="color:#333333;">是否为空，空返回</span> 
     <span style="color:#333333;">true</span> 
     <span style="color:#333333;">，否则返回</span> 
     <span style="color:#333333;">false</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <span style="color:#333333;">Object[] toArray() </span> 
    </div> </td><td> 
    <div> 
     <span style="color:#333333;">将</span> 
     <span style="color:#333333;">set</span> 
     <span style="color:#333333;">中的元素转换为数组返回 </span> 
    </div> </td></tr><tr><td> 
    <div> 
     <span style="color:#333333;">boolean containsAll(Collection&lt;?&gt; c)</span> 
    </div> </td><td> 
    <div> 
     <span style="color:#333333;">集合</span> 
     <span style="color:#333333;">c</span> 
     <span style="color:#333333;">中的元素是否在</span> 
     <span style="color:#333333;">set</span> 
     <span style="color:#333333;">中全部存在，是返回</span> 
     <span style="color:#333333;">true</span> 
     <span style="color:#333333;">，否则返回 false</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <span style="color:#333333;">boolean addAll(Collection&lt;? extends E&gt; c)</span> 
    </div> </td><td> 
    <div> 
     <span style="color:#333333;">将集合</span> 
     <span style="color:#333333;">c</span> 
     <span style="color:#333333;">中的元素添加到</span> 
     <span style="color:#333333;">set</span> 
     <span style="color:#333333;">中，可以达到去重的效果 </span> 
    </div> </td></tr></tbody></table> 
<pre><code>import java.util.TreeSet;

public class TreeSetExample {
    public static void main(String[] args) {
        // 创建一个TreeSet，元素自然排序（升序）
        TreeSet&lt;Integer&gt; numbers = new TreeSet&lt;&gt;();

        // 添加一些元素
        numbers.add(5);
        numbers.add(3);
        numbers.add(8);
        numbers.add(1);

        // 打印整个TreeSet
        System.out.println("TreeSet: " + numbers);

        // 查找是否存在某个元素
        System.out.println("Contains 6: " + numbers.contains(6));

        // 删除一个元素
        numbers.remove(3);
        System.out.println("TreeSet after removing 3: " + numbers);

        // 遍历TreeSet
        System.out.println("Traversing TreeSet:");
        for (int number : numbers) {
            System.out.println(number);
        }

        // 排序和检索操作
        System.out.println("First element: " + numbers.first());
        System.out.println("Last element: " + numbers.last());
        System.out.println("Element greater than 4: " + numbers.higher(4));
        System.out.println("Element lower than 4: " + numbers.lower(4));
    }
}
</code></pre> 
<h3 id="%F0%9F%AA%A33.%20Set%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7">🪣3. Set主要特性</h3> 
<ul><li><span style="color:#333333;">Set</span><span style="color:#333333;">是继承自</span><span style="color:#333333;">Collection</span><span style="color:#333333;">的一个接口类 </span></li><li> 
  <div> 
   <span style="color:#333333;">TreeSet</span> 
   <span style="color:#333333;">中不能插入</span> 
   <span style="color:#333333;">null</span> 
   <span style="color:#333333;">的</span> 
   <span style="color:#333333;">key</span> 
   <span style="color:#333333;">，</span> 
   <span style="color:#333333;">HashSet</span> 
   <span style="color:#333333;">可以。</span> 
  </div> </li><li> 
  <div> 
   <div> 
    <span style="color:#333333;">实现</span> 
    <span style="color:#333333;">Set</span> 
    <span style="color:#333333;">接口的常用类有</span> 
    <span style="color:#333333;">TreeSet</span> 
    <span style="color:#333333;">和</span> 
    <span style="color:#333333;">HashSet</span> 
    <span style="color:#333333;">，还有一个</span> 
    <span style="color:#333333;">LinkedHashSet</span> 
    <span style="color:#333333;">，</span> 
    <span style="color:#333333;">LinkedHashSet</span> 
    <span style="color:#333333;">是在</span> 
    <span style="color:#333333;">HashSet</span> 
    <span style="color:#333333;">的基础上维护了一个双向链表来记录元素的插入次序。</span> 
   </div> 
  </div> </li><li><strong>有序性</strong>：元素按照自然顺序或者根据提供的Comparator进行排序。当向<code>TreeSet</code>中添加元素时，会根据元素之间的比较关系进行自动排序。</li><li><strong>不可重复性</strong>：TreeSet中的元素不允许重复。<span style="color:#333333;">Set</span><span style="color:#333333;">最大的功能就是对集合中的元素进行去重 </span></li><li><strong>基于红黑树实现</strong>：通过红黑树数据结构实现了有序的、唯一元素存储。</li></ul> 
<table border="1" cellpadding="1" cellspacing="1" style="width:700px;"><tbody><tr><td> 
    <div style="text-align:center;"> 
     <span style="color:#333333;"><strong>Set</strong></span> 
     <span style="color:#333333;"><strong>底层结构</strong></span> 
    </div> </td><td> 
    <div style="text-align:center;"> 
     <span style="color:#333333;"><strong>TreeSet</strong></span> 
    </div> </td></tr><tr><td> 
    <div style="text-align:center;"> 
     <span style="color:#333333;">底层结构</span> 
    </div> </td><td> 
    <div style="text-align:center;"> 
     <span style="color:#333333;">红黑树</span> 
    </div> </td></tr><tr><td> 
    <div style="text-align:center;"> 
     <span style="color:#333333;">插入</span> 
     <span style="color:#333333;">/</span> 
     <span style="color:#333333;">删除</span> 
     <span style="color:#333333;">/</span> 
     <span style="color:#333333;">查找时间 </span> 
    </div> 
    <div style="text-align:center;"> 
     <span style="color:#333333;">复杂度</span> 
    </div> </td><td style="text-align:center;">O(log N)</td></tr><tr><td> 
    <div style="text-align:center;"> 
     <span style="color:#333333;">是否有序</span> 
    </div> </td><td> 
    <div style="text-align:center;"> 
     <span style="color:#333333;">关于</span> 
     <span style="color:#333333;">Key</span> 
     <span style="color:#333333;">有序</span> 
    </div> </td></tr><tr><td> 
    <div style="text-align:center;"> 
     <span style="color:#333333;">线程安全</span> 
    </div> </td><td> 
    <div style="text-align:center;"> 
     <span style="color:#333333;">不安全</span> 
    </div> </td></tr><tr><td> 
    <div style="text-align:center;"> 
     <span style="color:#333333;">插入</span> 
     <span style="color:#333333;">/</span> 
     <span style="color:#333333;">删除</span> 
     <span style="color:#333333;">/</span> 
     <span style="color:#333333;">查找区别</span> 
    </div> </td><td> 
    <div style="text-align:center;"> 
     <span style="color:#333333;">按照红黑树的特性来进行插入和删除</span> 
    </div> </td></tr><tr><td> 
    <div style="text-align:center;"> 
     <span style="color:#333333;">比较与覆写</span> 
    </div> </td><td> 
    <div style="text-align:center;"> 
     <span style="color:#333333;">key</span> 
     <span style="color:#333333;">必须能够比较，否则会抛出 </span> 
    </div> 
    <div style="text-align:center;"> 
     <span style="color:#333333;">ClassCastException</span> 
     <span style="color:#333333;">异常</span> 
    </div> </td></tr><tr><td> 
    <div style="text-align:center;"> 
     <span style="color:#333333;">应用场景</span> 
    </div> </td><td> 
    <div style="text-align:center;"> 
     <span style="color:#333333;">需要</span> 
     <span style="color:#333333;">Key</span> 
     <span style="color:#333333;">有序场景下</span> 
    </div> </td></tr></tbody></table> 
<h3 id="%F0%9F%AB%A74.%20TreeSet%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0">🫧4. TreeSet的内部实现</h3> 
<p>TreeSet通过红黑树（Red-Black Tree）数据结构实现了有序的、唯一元素存储。红黑树是一种自平衡的二叉查找树，在插入和删除操作后能够保持相对较低的高度，从而保证了检索、插入和删除操作的时间复杂度为O(log n)。</p> 
<h3 id="%F0%9F%9B%925.%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">🛒5. 应用场景</h3> 
<p>TreeSet适用于需要保持元素有序并且去除重复元素的场景。由于其基于红黑树实现，可以高效地支持元素的查找、插入和删除操作。因此，在需要有序集合且不允许重复元素的情况下，TreeSet是一个十分实用的选择。总而言之：</p> 
<ul><li>当需要保持元素的有序性且不允许重复时，<code>TreeSet</code>是一个很好的选择。</li><li>常用于需要按照特定顺序处理元素的情况。</li></ul> 
<h2 id="%F0%9F%A7%AF%E4%B8%89.TreeMap">🧯三.TreeMap</h2> 
<h3 id="%F0%9F%A7%B91.%E5%AE%9A%E4%B9%89">🧹1.定义</h3> 
<div> 
 <p><code>TreeMap</code>是基于红黑树数据结构的键值对映射。它保证键的有序性，键按照其自然顺序（通过键的<code>compareTo</code>方法确定的顺序）进行排序。</p> 
 <p class="img-center"><img alt="" height="266" src="https://images2.imgbox.com/48/ac/QhqOpe53_o.png" width="379"></p> 
 <h3 id="%F0%9F%AA%A42.%E6%93%8D%E4%BD%9C">🪤2.操作</h3> 
 <table border="1" cellpadding="1" cellspacing="1" style="width:700px;"><tbody><tr><td> 
     <div> 
      <span style="color:#333333;"><strong>方法 </strong></span> 
     </div> </td><td> 
     <div> 
      <span style="color:#333333;"><strong>解释</strong></span> 
     </div> </td></tr><tr><td> 
     <div> 
      <span style="color:#333333;">V </span> 
      <span style="color:#4183c4;">get</span> 
      <span style="color:#333333;">(Object key) </span> 
     </div> </td><td> 
     <div> 
      <span style="color:#333333;">返回</span> 
      <span style="color:#333333;"> key </span> 
      <span style="color:#333333;">对应的</span> 
      <span style="color:#333333;"> value</span> 
     </div> </td></tr><tr><td> 
     <div> 
      <span style="color:#333333;">V </span> 
      <span style="color:#4183c4;">getOrDefault</span> 
      <span style="color:#333333;">(Object key, V defaultValue) </span> 
     </div> </td><td> 
     <div> 
      <span style="color:#333333;">返回</span> 
      <span style="color:#333333;"> key </span> 
      <span style="color:#333333;">对应的</span> 
      <span style="color:#333333;"> value</span> 
      <span style="color:#333333;">，</span> 
      <span style="color:#333333;">key </span> 
      <span style="color:#333333;">不存在，返回默认值</span> 
     </div> </td></tr><tr><td> 
     <div> 
      <span style="color:#333333;">V </span> 
      <span style="color:#4183c4;">put</span> 
      <span style="color:#333333;">(K key, V value)</span> 
     </div> </td><td> 
     <div> 
      <span style="color:#333333;">设置</span> 
      <span style="color:#333333;"> key </span> 
      <span style="color:#333333;">对应的</span> 
      <span style="color:#333333;"> value</span> 
     </div> </td></tr><tr><td> 
     <div> 
      <span style="color:#333333;">V </span> 
      <span style="color:#4183c4;">remove</span> 
      <span style="color:#333333;">(Object key)</span> 
     </div> </td><td> 
     <div> 
      <span style="color:#333333;">删除</span> 
      <span style="color:#333333;"> key </span> 
      <span style="color:#333333;">对应的映射关系 </span> 
     </div> </td></tr><tr><td> 
     <div> 
      <span style="color:#333333;">Set&lt;K&gt; </span> 
      <span style="color:#4183c4;">keySet</span> 
      <span style="color:#333333;">() </span> 
     </div> </td><td> 
     <div> 
      <span style="color:#333333;">返回所有</span> 
      <span style="color:#333333;"> key </span> 
      <span style="color:#333333;">的不重复集合</span> 
     </div> </td></tr><tr><td> 
     <div> 
      <span style="color:#333333;">Collection&lt;V&gt; </span> 
      <span style="color:#4183c4;">values</span> 
      <span style="color:#333333;">() </span> 
     </div> </td><td> 
     <div> 
      <span style="color:#333333;">返回所有</span> 
      <span style="color:#333333;"> value </span> 
      <span style="color:#333333;">的可重复集合</span> 
     </div> </td></tr><tr><td> 
     <div> 
      <span style="color:#333333;">Set&lt;Map.Entry&lt;K, V&gt;&gt; </span> 
      <span style="color:#4183c4;">entrySet</span> 
      <span style="color:#333333;">() </span> 
     </div> </td><td> 
     <div> 
      <span style="color:#333333;">返回所有的</span> 
      <span style="color:#333333;"> key-value </span> 
      <span style="color:#333333;">映射关系 </span> 
     </div> </td></tr><tr><td> 
     <div> 
      <span style="color:#333333;">boolean </span> 
      <span style="color:#4183c4;">containsKey</span> 
      <span style="color:#333333;">(Object key) </span> 
     </div> </td><td> 
     <div> 
      <span style="color:#333333;">判断是否包含</span> 
      <span style="color:#333333;"> key</span> 
     </div> </td></tr><tr><td> 
     <div> 
      <span style="color:#333333;">boolean </span> 
      <span style="color:#4183c4;">containsValue</span> 
      <span style="color:#333333;">(Object value) </span> 
     </div> </td><td> 
     <div> 
      <span style="color:#333333;">判断是否包含</span> 
      <span style="color:#333333;"> value</span> 
     </div> </td></tr></tbody></table> 
 <pre><code>import java.util.Map;
import java.util.TreeMap;

public class TreeMapExample {
    public static void main(String[] args) {
        // 创建一个 TreeMap
        TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;&gt;();

        // 向 TreeMap 中添加键值对
        treeMap.put(1, "value1");
        treeMap.put(2, "value2");
        treeMap.put(3, "value3");
        treeMap.put(4, "value4");
        treeMap.put(5, "value5");

        // 打印 TreeMap
        System.out.println("TreeMap: " + treeMap);

        // 获取一个键对应的值
        String value = treeMap.get(3);
        System.out.println("Value for key 3: " + value);

        // 删除一个键值对
        boolean removed = treeMap.remove(2);
        System.out.println("Remove key 2: " + removed);

        // 获取 TreeMap 的大小
        int size = treeMap.size();
        System.out.println("Size of TreeMap: " + size);

        // 检查 TreeMap 是否为空
        boolean isEmpty = treeMap.isEmpty();
        System.out.println("Is TreeMap empty: " + isEmpty);

        // 遍历 TreeMap
        for (Map.Entry&lt;Integer, String&gt; entry : treeMap.entrySet()) {
            System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());
        }
    }
}
</code></pre> 
 <h3 id="%F0%9F%A7%B73.Map%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7">🧷3.Map的主要特性</h3> 
 <ol><li><span style="color:#333333;">Map</span><span style="color:#333333;">是一个接口，不能直接实例化对象</span><span style="color:#333333;">，如果</span><span style="color:#333333;">要实例化对象只能实例化其实现类</span><span style="color:#333333;">TreeMap</span><span style="color:#333333;">或者</span><span style="color:#333333;">HashMap </span></li><li><span style="color:#333333;">Map</span><span style="color:#333333;">中存放键值对的</span><span style="color:#333333;">Key</span><span style="color:#333333;">是唯一的，</span><span style="color:#333333;">value</span><span style="color:#333333;">是可以重复的 </span></li><li><span style="color:#333333;">在</span><span style="color:#333333;">TreeMap</span><span style="color:#333333;">中插入键值对时，</span><span style="color:#333333;">key</span><span style="color:#333333;">不能为空，否则就会抛</span><span style="color:#333333;">NullPointerException</span><span style="color:#333333;">异常</span><span style="color:#333333;">，</span><span style="color:#333333;">value</span><span style="color:#333333;">可以为空。但是HashMap</span><span style="color:#333333;">的</span><span style="color:#333333;">key</span><span style="color:#333333;">和</span><span style="color:#333333;">value</span><span style="color:#333333;">都可以为空。 </span></li><li><span style="color:#333333;">Map</span><span style="color:#333333;">中的</span><span style="color:#333333;">Key</span><span style="color:#333333;">可以全部分离出来，存储到</span><span style="color:#333333;">Set</span><span style="color:#333333;">中</span><span style="color:#333333;">来进行访问</span><span style="color:#333333;">(</span><span style="color:#333333;">因为</span><span style="color:#333333;">Key</span><span style="color:#333333;">不能重复</span><span style="color:#333333;">)</span><span style="color:#333333;">。 </span></li><li><span style="color:#333333;">Map</span><span style="color:#333333;">中的</span><span style="color:#333333;">value</span><span style="color:#333333;">可以全部分离出来，存储在</span><span style="color:#333333;">Collection</span><span style="color:#333333;">的任何一个子集合中</span><span style="color:#333333;">(value</span><span style="color:#333333;">可能有重复</span><span style="color:#333333;">)</span><span style="color:#333333;">。 </span></li><li><span style="color:#333333;">Map</span><span style="color:#333333;">中键值对的</span><span style="color:#333333;">Key</span><span style="color:#333333;">不能直接修改，</span><span style="color:#333333;">value</span><span style="color:#333333;">可以修改，如果要修改</span><span style="color:#333333;">key</span><span style="color:#333333;">，只能先将该</span><span style="color:#333333;">key</span><span style="color:#333333;">删除掉，然后再来进行重新插入。</span></li></ol> 
 <p></p> 
 <table border="1" cellpadding="1" cellspacing="1" style="width:700px;"><tbody><tr><td> 
     <div style="text-align:center;"> 
      <span style="color:#333333;"><strong>Map底层结构</strong></span> 
     </div> </td><td> 
     <div style="text-align:center;"> 
      <span style="color:#333333;"><strong>TreeMap</strong></span> 
     </div> </td></tr><tr><td> 
     <div style="text-align:center;"> 
      <span style="color:#333333;">底层结构</span> 
     </div> </td><td> 
     <div style="text-align:center;"> 
      <span style="color:#333333;">红黑树</span> 
     </div> </td></tr><tr><td> 
     <div style="text-align:center;"> 
      <span style="color:#333333;">插入</span> 
      <span style="color:#333333;">/</span> 
      <span style="color:#333333;">删除</span> 
      <span style="color:#333333;">/</span> 
      <span style="color:#333333;">查找时间 </span> 
     </div> 
     <div style="text-align:center;"> 
      <span style="color:#333333;">复杂度</span> 
     </div> </td><td style="text-align:center;">O(log N)</td></tr><tr><td> 
     <div style="text-align:center;"> 
      <span style="color:#333333;">是否有序</span> 
     </div> </td><td> 
     <div style="text-align:center;"> 
      <span style="color:#333333;">关于</span> 
      <span style="color:#333333;">Key</span> 
      <span style="color:#333333;">有序</span> 
     </div> </td></tr><tr><td> 
     <div style="text-align:center;"> 
      <span style="color:#333333;">线程安全</span> 
     </div> </td><td> 
     <div style="text-align:center;"> 
      <span style="color:#333333;">不安全</span> 
     </div> </td></tr><tr><td> 
     <div style="text-align:center;"> 
      <span style="color:#333333;">插入</span> 
      <span style="color:#333333;">/</span> 
      <span style="color:#333333;">删除</span> 
      <span style="color:#333333;">/</span> 
      <span style="color:#333333;">查找区别</span> 
     </div> </td><td> 
     <div style="text-align:center;"> 
      <span style="color:#333333;">需要进行元素比较</span> 
     </div> </td></tr><tr><td> 
     <div style="text-align:center;"> 
      <span style="color:#333333;">比较与覆写</span> 
     </div> </td><td> 
     <div style="text-align:center;"> 
      <span style="color:#333333;">key</span> 
      <span style="color:#333333;">必须能够比较，否则会抛出 </span> 
     </div> 
     <div style="text-align:center;"> 
      <span style="color:#333333;">ClassCastException</span> 
      <span style="color:#333333;">异常</span> 
     </div> </td></tr><tr><td> 
     <div style="text-align:center;"> 
      <span style="color:#333333;">应用场景</span> 
     </div> </td><td> 
     <div style="text-align:center;"> 
      <span style="color:#333333;">需要</span> 
      <span style="color:#333333;">Key</span> 
      <span style="color:#333333;">有序场景下</span> 
     </div> </td></tr></tbody></table> 
</div> 
<h3 id="%F0%9F%A7%BF4.%20TreeMap%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0">🧿4. TreeMap的内部实现</h3> 
<p><code>TreeMap</code>的内部实现是通过红黑树来存储键值对的。红黑树是一种自平衡的二叉查找树，它保证了在插入和删除操作后，树的高度保持相对较低，从而保证了高效的查找、插入和删除操作。 </p> 
<h3 id="%F0%9F%AA%AC5.%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%C2%A0">🪬5.应用场景 </h3> 
<p>在实际应用中，如果你需要一个<strong>有序的映射表</strong>，并且不允许键重复，那么<code>TreeMap</code>是一个很好的选择。它既满足了有序性的需求，又提供了高效的操作性能。总而言之：</p> 
<ul><li>当需要保持键的有序性且需要根据键快速查找值时，<code>TreeMap</code>是一个很好的选择。</li><li>常用于需要按照特定顺序处理键值对的情况。</li></ul> 
<h2 id="%F0%9F%97%BF%E5%9B%9B.%E6%80%BB%E7%BB%93%E4%B8%8E%E5%8F%8D%E6%80%9D" style="background-color:transparent;">🗿四.总结与反思</h2> 
<blockquote> 
 <p>人们在一起可以做出单独一个人所不能做出的事业；智慧+双手+力量结合在一起，几乎是万能的。——韦伯斯特</p> 
</blockquote> 
<p>        在学习二叉搜索树和TreeSet/TreeMap的过程中，我深刻体会到了数据结构在编程中的应用和重要性。二叉搜索树作为一种特殊的二叉树，其特性包括每个节点的左子树都比当前节点小，右子树都比当前节点大，这使得在二叉搜索树中进行查找、插入和删除操作的时间复杂度可以达到O(log n)，相比于线性搜索的O(n)有了显著的提升。而TreeSet和TreeMap的底层实现正是基于这种高效的数据结构——红黑树。</p> 
<p>        红黑树是一种自平衡的二叉查找树，它通过红黑规则来保持树的平衡，确保任何节点的左子树的高度最多比右子树高1，从而保证了树的平衡性。在TreeSet和TreeMap中，插入、删除和查找操作的时间复杂度均为O(log n)，这使得它们在处理大量数据时依然能够保持高效。</p> 
<p>        学习二叉搜索树和TreeSet/TreeMap的过程中，我认识到数据结构的选择对于程序的性能有着至关重要的影响。虽然HashMap在查找、插入和删除操作上提供了O(1)的时间复杂度，但是它不保证元素的顺序，而TreeSet和TreeMap在保持有序的同时，牺牲了一部分时间复杂度。在实际应用中，我们需要根据具体需求选择合适的数据结构，以达到最优的性能。</p> 
<p>        此外，在学习过程中，我也意识到了在多线程环境中使用TreeMap时需要注意同步问题。TreeMap不是线程安全的，如果需要在多线程环境中使用，需要程序员手动同步，或者通过包装等方式将TreeMap变成同步的。</p> 
<p>        总的来说，学习二叉搜索树和TreeSet/TreeMap让我对数据结构和算法有了更深入的理解，也让我认识到在实际编程中选择合适的数据结构的重要性。在未来的学习和工作中，我会继续探索和运用这些知识，以提高程序的性能和可靠性。</p> 
<hr> 
<p>🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀</p> 
<p>以上，就是本期的全部内容啦，若有错误疏忽希望各位大佬及时指出💐</p> 
<p>  制作不易，希望能对各位提供微小的帮助，可否留下你免费的赞呢🌸</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/553e9dabd8e7397ec3980a98694bacf1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">网上跳蚤市场|基于SSM＋vue的网上跳蚤市场系统的设计与实现(源码&#43;数据库&#43;文档)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/868ae83a9356cc0fcfac4cc76c75cbea/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【MySQL数据库】初步认识数据库，实现基本操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>