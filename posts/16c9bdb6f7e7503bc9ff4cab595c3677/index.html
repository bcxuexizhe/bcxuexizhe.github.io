<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>第十三章 DFS与BFS（保姆级教学！！超级详细的图示！！） - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/16c9bdb6f7e7503bc9ff4cab595c3677/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="第十三章 DFS与BFS（保姆级教学！！超级详细的图示！！）">
  <meta property="og:description" content="第十三章 DFS与BFS 一、深度优先搜索1、什么是DFS？2、DFS代码模板（1）问题：（2）分析：（3）模板： 3、DFS代码分析 二、广度优先搜索1、什么是BFS？2、BFS代码模板（1）问题：（2）代码： 3、BFS代码分析（1）问题1：为什么要用队列？（2）问题2：方向向量怎么用？（3）问题3：为什么最后的输出是最短路？ 一、深度优先搜索 1、什么是DFS？ DFS即Depth First Search，深度优先搜索。简单地理解为一条路走到黑。那么什么叫一条路走到黑呢？假设我们想在如下的地图中走出一条最长的路，那么最粗暴的方式就是枚举出每一种情况。
因此，按照DFS一条路走到黑的思想，我们将会出现如下路线：
先走A，然后到B，到了B有三种情况，意味着这条路还没走完，那我就接着走，从B走到E，走到E之后没路了。那我就回溯到B,为什么呢？
因为我原本走到B的时候就有三种情况，但是刚刚只走了一种情况，因此我要回到B再去尝试第二条路，于是我们就从E回到B，然后从B去F。到了F，又没路了，那我们就回到B走第三种情况，从B到G。这样我们就走完了从A-&gt;B的三种情况。又因为在A处其实还有三种情况，因此我们走完B的三种情况后，回到A,去走除了从A-&gt;B的第二种情况，即A-&gt;C。由此以往。
简而言之，就是我们一头扎进去，撞了南墙，我就退一步，但是决不放弃，在原基础上做出局部的改变去尝试第二条路，直到所有的情况我都试了，实在没有其他情况了，那我就回到A，从头出发，再做选择，再一头扎进去，直到成功。
2、DFS代码模板 （1）问题： （2）分析： 我们将其各种选择，继续画成一棵树：
这张图就清晰很多了，因此想要用DFS，我们首先要有逻辑地画出一张地图，有了地图才能去搜。
（3）模板： #include&lt;iostream&gt; using namespace std; const int N=10; int ans[N]; bool mark[N]; int n; void dfs(int u) { //&#34;回头&#34;的条件 if(u==n) { for(int i=0;i&lt;n;i&#43;&#43;)cout&lt;&lt;ans[i]&lt;&lt;&#34; &#34;; puts(&#34;&#34;); return; } for(int i=1;i&lt;=n;i&#43;&#43;) { if(mark[i]==false) { mark[i]=true; ans[u]=i; dfs(u&#43;1); //复原 mark[i]=false; ans[u]=0; } } } int main() { cin&gt;&gt;n; dfs(0); return 0; } 3、DFS代码分析 当然这个过程很抽象，那么我就帮大家模拟一下函数进行的过程吧^ _ ^（这里只模拟一部分，不理解的读者可自己模拟完。）">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-10-12T09:47:28+08:00">
    <meta property="article:modified_time" content="2023-10-12T09:47:28+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">第十三章 DFS与BFS（保姆级教学！！超级详细的图示！！）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>第十三章 DFS与BFS</h4> 
 <ul><li><a href="#_1" rel="nofollow">一、深度优先搜索</a></li><li><ul><li><a href="#1DFS_2" rel="nofollow">1、什么是DFS？</a></li><li><a href="#2DFS_12" rel="nofollow">2、DFS代码模板</a></li><li><ul><li><a href="#1_13" rel="nofollow">（1）问题：</a></li><li><a href="#2_15" rel="nofollow">（2）分析：</a></li><li><a href="#3_20" rel="nofollow">（3）模板：</a></li></ul> 
   </li><li><a href="#3DFS_61" rel="nofollow">3、DFS代码分析</a></li></ul> 
  </li><li><a href="#_68" rel="nofollow">二、广度优先搜索</a></li><li><ul><li><a href="#1BFS_69" rel="nofollow">1、什么是BFS？</a></li><li><a href="#2BFS_77" rel="nofollow">2、BFS代码模板</a></li><li><ul><li><a href="#1_78" rel="nofollow">（1）问题：</a></li><li><a href="#2_81" rel="nofollow">（2）代码：</a></li></ul> 
   </li><li><a href="#3BFS_127" rel="nofollow">3、BFS代码分析</a></li><li><ul><li><a href="#11_129" rel="nofollow">（1）问题1：为什么要用队列？</a></li><li><a href="#22_134" rel="nofollow">（2）问题2：方向向量怎么用？</a></li><li><a href="#33_142" rel="nofollow">（3）问题3：为什么最后的输出是最短路？</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>一、深度优先搜索</h2> 
<h3><a id="1DFS_2"></a>1、什么是DFS？</h3> 
<p>DFS即Depth First Search，深度优先搜索。简单地理解为一条路走到黑。那么什么叫一条路走到黑呢？假设我们想在如下的地图中走出一条最长的路，那么最粗暴的方式就是枚举出每一种情况。<br> <img src="https://images2.imgbox.com/67/d0/atxsQMOU_o.png" alt="在这里插入图片描述"><br> 因此，按照DFS一条路走到黑的思想，我们将会出现如下路线：<br> <img src="https://images2.imgbox.com/11/ab/rEfD1blJ_o.png" alt="在这里插入图片描述"><br> 先走A，然后到B，到了B有三种情况，意味着这条路还没走完，那我就接着走，从B走到E，走到E之后没路了。那我就回溯到B,为什么呢？<br> 因为我原本走到B的时候就有三种情况，但是刚刚只走了一种情况，因此我要回到B再去尝试第二条路，于是我们就从E回到B，然后从B去F。到了F，又没路了，那我们就回到B走第三种情况，从B到G。这样我们就走完了从A-&gt;B的三种情况。又因为在A处其实还有三种情况，因此我们走完B的三种情况后，回到A,去走除了从A-&gt;B的第二种情况，即A-&gt;C。由此以往。</p> 
<p>简而言之，就是我们一头扎进去，撞了南墙，我就退一步，但是决不放弃，在原基础上做出局部的改变去尝试第二条路，直到所有的情况我都试了，实在没有其他情况了，那我就回到A，从头出发，再做选择，再一头扎进去，直到成功。</p> 
<h3><a id="2DFS_12"></a>2、DFS代码模板</h3> 
<h4><a id="1_13"></a>（1）问题：</h4> 
<p><img src="https://images2.imgbox.com/2d/bd/9OBq9puq_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_15"></a>（2）分析：</h4> 
<p><img src="https://images2.imgbox.com/f6/e2/FNydDUun_o.png" alt="在这里插入图片描述"><br> 我们将其各种选择，继续画成一棵树：<br> <img src="https://images2.imgbox.com/c7/01/RkWsqWaR_o.png" alt="在这里插入图片描述"><br> 这张图就清晰很多了，因此想要用DFS，我们首先要有逻辑地画出一张地图，有了地图才能去搜。</p> 
<h4><a id="3_20"></a>（3）模板：</h4> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> ans<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> mark<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//"回头"的条件</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>u<span class="token operator">==</span>n<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>cout<span class="token operator">&lt;&lt;</span>ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>
        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>mark<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">false</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            mark<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
            ans<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>u<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//复原</span>
            mark<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>
            ans<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    cin<span class="token operator">&gt;&gt;</span>n<span class="token punctuation">;</span>
    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="3DFS_61"></a>3、DFS代码分析</h3> 
<p><img src="https://images2.imgbox.com/0d/a3/1gowIyai_o.png" alt="在这里插入图片描述"><br> 当然这个过程很抽象，那么我就帮大家模拟一下函数进行的过程吧^ _ ^（这里只模拟一部分，不理解的读者可自己模拟完。）<br> <img src="https://images2.imgbox.com/db/d8/OPAl8qQH_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_68"></a>二、广度优先搜索</h2> 
<h3><a id="1BFS_69"></a>1、什么是BFS？</h3> 
<p>BFS即Breadth First Search，即广度优先搜索。如果说DFS是一条路走到黑的话，BFS就完全相反了。BFS会在每个岔路口都各向前走一步。因此其遍历顺序如下图所示：</p> 
<p><img src="https://images2.imgbox.com/ca/c6/GBn61CrC_o.png" alt="在这里插入图片描述"><br> 我们发现每次搜索的位置都是距离当前节点最近的点。因此，BFS是具有最短路的性质的。为什么呢？这就类似于我们后面要学习的贪心策略。这里简单地介绍一下贪心，假设我们可以做出12次选择。我们想得到一个最好的方案。那么我们可以在第一次选择的时候，做出当前最好的选择，在第二次选择的时候，再做出那时候最好的选择，由此积累。当我们在每次的选择面前，都做到了当前最好的选择，那么我们就可以由局部最优推出整体最优。</p> 
<p>这里也是类似的，我们可以在每次出发的时候，走到离自己最近的点，由此我们每次都保证走最近的，那从局部最近推整体最近，必有一条路是整体最近的。所以我们可以利用BFS做最短路问题。</p> 
<h3><a id="2BFS_77"></a>2、BFS代码模板</h3> 
<h4><a id="1_78"></a>（1）问题：</h4> 
<p><img src="https://images2.imgbox.com/0b/d4/dqJDo574_o.png" alt="在这里插入图片描述"><br> 本题求的是最短路，因此我们可以利用BFS从当前节点出发，每次都向周围拓展。</p> 
<h4><a id="2_81"></a>（2）代码：</h4> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstring&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;queue&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">110</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;</span> PII<span class="token punctuation">;</span>
<span class="token keyword">int</span> map<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>mark<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> dx<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>dy<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span>m<span class="token punctuation">,</span>ans<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">memset</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span> mark<span class="token punctuation">)</span><span class="token punctuation">;</span>
    queue<span class="token operator">&lt;</span>PII<span class="token operator">&gt;</span>q<span class="token punctuation">;</span>
    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    mark<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        PII top<span class="token operator">=</span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> nex<span class="token operator">=</span>top<span class="token punctuation">.</span>first<span class="token operator">+</span>dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>ney<span class="token operator">=</span>top<span class="token punctuation">.</span>second<span class="token operator">+</span>dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nex<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>nex<span class="token operator">&lt;</span>n<span class="token operator">&amp;&amp;</span>ney<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>ney<span class="token operator">&lt;</span>m<span class="token operator">&amp;&amp;</span>mark<span class="token punctuation">[</span>nex<span class="token punctuation">]</span><span class="token punctuation">[</span>ney<span class="token punctuation">]</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>map<span class="token punctuation">[</span>nex<span class="token punctuation">]</span><span class="token punctuation">[</span>ney<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                mark<span class="token punctuation">[</span>nex<span class="token punctuation">]</span><span class="token punctuation">[</span>ney<span class="token punctuation">]</span><span class="token operator">=</span>mark<span class="token punctuation">[</span>top<span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token punctuation">[</span>top<span class="token punctuation">.</span>second<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
                q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>nex<span class="token punctuation">,</span>ney<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout<span class="token operator">&lt;&lt;</span>mark<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    cin<span class="token operator">&gt;&gt;</span>n<span class="token operator">&gt;&gt;</span>m<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>map<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="3BFS_127"></a>3、BFS代码分析</h3> 
<p><img src="https://images2.imgbox.com/33/72/I7CipDgn_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="11_129"></a>（1）问题1：为什么要用队列？</h4> 
<p>BFS要保证的第一件事就是我们需要先走最近的，因此，队列的作用就是基于此的。<br> <img src="https://images2.imgbox.com/03/77/pxMAzOyN_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/70/27/yQBTEHGl_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a6/3a/U2VyGD3f_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="22_134"></a>（2）问题2：方向向量怎么用？</h4> 
<p><img src="https://images2.imgbox.com/c3/e6/2BHD0JwG_o.png" alt="在这里插入图片描述"><br> 我们将上面的方向变化可以写成如下的数组：<br> <img src="https://images2.imgbox.com/cc/5b/n0wqMyKk_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="33_142"></a>（3）问题3：为什么最后的输出是最短路？</h4> 
<p>我们每个点都是同时向外拓展一步，并且只拓展一次。那么我们将其速度看作1步/次。每个点都向外探索一次。那么此时我们的次数可以类比为时间，由此每条路的速度和时间都是一样的，因此每条路的<strong>路程</strong>都是一样的。</p> 
<p>而各个点都是从起点开始扩散的。我们看下面的例子：</p> 
<p><img src="https://images2.imgbox.com/89/79/vc4t0LJa_o.png" alt="在这里插入图片描述"><br> 某时刻，绿色线到达了B点，此时各个路线的长度都是L，那么接下来再走的话，蓝色线的路程和黄色线的路程只会更长，因此其再到达B点的时候，<strong>必不如绿色线近</strong>。<mark><strong>因此，第一次到达某个点的路线，就是最短的路线</strong></mark></p> 
<p>由于mark数组中的点，踩过一次后，就不许再经过了。于是，我们惊奇地发现，<strong>每个点记录的路程都是从起点到该点的最短路！！！</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/59f443737d1583da7a1cb97cb69311cd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2023年（2024届）211低rank计算机保研记录（中南大数据、北邮软院、东南软院、中科院、大工软院等）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cf5f0a4947de51211ed777cc7b64f034/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Eureka（服务注册和发现）——Eureka的简介和原理 &amp; Eureka的使用和分析 &amp; 心跳续约策略，服务的下线和剔除，自我保护 &amp; Eureka集群的搭建</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>