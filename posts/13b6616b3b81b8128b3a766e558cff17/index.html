<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】日期类Date（详解） - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/13b6616b3b81b8128b3a766e558cff17/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【C&#43;&#43;】日期类Date（详解）">
  <meta property="og:description" content="🔥个人主页：Forcible Bug Maker
🔥专栏：C&#43;&#43;
目录
前言
日期类
日期类实现地图
获取某年某月的天数：GetMonthDay
检查日期合法，构造函数，拷贝构造函数，赋值运算符重载及析构函数
日期类的&#43;=day和&#43;day
日期类的-=day和-day
前置&#43;&#43;和后置&#43;&#43;
前置--和后置--
比大小运算符的重载
日期-日期返回天数
暴力&#43;&#43;法
直接相减法
const成员
流插入和流提取重载
友元（friend）
结语
前言 本篇主要内容：日期类的实现
上篇我们介绍了拷贝构造函数和赋值运算符重载两大类的默认成员函数，本篇将会介绍更多关于操作符重载的实例运用。日期类，是与日期相关的类，主要用于处理与日期和时间相关的操作。我们将在完善一个日期类的过程中加深对运算符重载的理解和运用。在理解操作符重载之后，最后两个默认成员函数学习起来也就不是什么大问题了。
日期类 日期类实现地图 在实现日期类之前，需事先要知道要实现哪些内容。我会给出一份类的指南，也就是成员变量和成员函数的声明，然后根据声明一步步实现其中的成员函数。在代码编写过程中，成员函数是可以直接定义在类内部的；但是在实际开发过程中，考虑到工程级项目的规模，一般采用声明和定义分离的方式经行类的实现。将声明统一放在 Date.h 中，把成员函数的定义统一放在 Date.cpp 中，道理跟C语言的声明定义分离一样。
#include&lt;iostream&gt; #include&lt;cassert&gt; using namespace std; class Date { // 友元 friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const Date&amp; d); friend istream&amp; operator&gt;&gt;(istream&amp; in, Date&amp; d); public: // 获取某年某月的天数 int GetMonthDay(int year, int month); // 检查日期是否合法 bool CheckDate(); // 全缺省的构造函数 Date(int year = 1900, int month = 1, int day = 1); // 拷贝构造函数 // d2(d1) Date(const Date&amp; d); // 赋值运算符重载 // d2 = d3 -&gt; d2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-21T12:54:26+08:00">
    <meta property="article:modified_time" content="2024-04-21T12:54:26+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】日期类Date（详解）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" src="https://images2.imgbox.com/a0/59/f3BvjwsJ_o.png"></p> 
<p style="text-align:center;">🔥<span style="color:#ff9900;"><strong>个人主页：</strong></span><a href="https://blog.csdn.net/2303_79329831?type=blog" title="Forcible Bug Maker">Forcible Bug Maker</a></p> 
<p style="text-align:center;">🔥<span style="color:#ff9900;"><strong>专栏：</strong></span><a href="https://blog.csdn.net/2303_79329831/category_12597496.html" title="C++">C++</a></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%E6%97%A5%E6%9C%9F%E7%B1%BB-toc" style="margin-left:0px;"><a href="#%E6%97%A5%E6%9C%9F%E7%B1%BB" rel="nofollow">日期类</a></p> 
<p id="%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%9C%B0%E5%9B%BE-toc" style="margin-left:40px;"><a href="#%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%9C%B0%E5%9B%BE" rel="nofollow">日期类实现地图</a></p> 
<p id="%E8%8E%B7%E5%8F%96%E6%9F%90%E5%B9%B4%E6%9F%90%E6%9C%88%E7%9A%84%E5%A4%A9%E6%95%B0%EF%BC%9AGetMonthDay-toc" style="margin-left:40px;"><a href="#%E8%8E%B7%E5%8F%96%E6%9F%90%E5%B9%B4%E6%9F%90%E6%9C%88%E7%9A%84%E5%A4%A9%E6%95%B0%EF%BC%9AGetMonthDay" rel="nofollow">获取某年某月的天数：GetMonthDay</a></p> 
<p id="%E6%A3%80%E6%9F%A5%E6%97%A5%E6%9C%9F%E5%90%88%E6%B3%95%EF%BC%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%8F%8A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E6%A3%80%E6%9F%A5%E6%97%A5%E6%9C%9F%E5%90%88%E6%B3%95%EF%BC%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%8F%8A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0" rel="nofollow">检查日期合法，构造函数，拷贝构造函数，赋值运算符重载及析构函数</a></p> 
<p id="%E6%97%A5%E6%9C%9F%E7%B1%BB%E7%9A%84%2B%3Dday%E5%92%8C%2Bday-toc" style="margin-left:40px;"><a href="#%E6%97%A5%E6%9C%9F%E7%B1%BB%E7%9A%84%2B%3Dday%E5%92%8C%2Bday" rel="nofollow">日期类的+=day和+day</a></p> 
<p id="%E6%97%A5%E6%9C%9F%E7%B1%BB%E7%9A%84-%3Dday%E5%92%8C-day-toc" style="margin-left:40px;"><a href="#%E6%97%A5%E6%9C%9F%E7%B1%BB%E7%9A%84-%3Dday%E5%92%8C-day" rel="nofollow">日期类的-=day和-day</a></p> 
<p id="%E5%89%8D%E7%BD%AE%2B%2B%E5%92%8C%E5%90%8E%E7%BD%AE%2B%2B-toc" style="margin-left:40px;"><a href="#%E5%89%8D%E7%BD%AE%2B%2B%E5%92%8C%E5%90%8E%E7%BD%AE%2B%2B" rel="nofollow">前置++和后置++</a></p> 
<p id="%E5%89%8D%E7%BD%AE--%E5%92%8C%E5%90%8E%E7%BD%AE---toc" style="margin-left:40px;"><a href="#%E5%89%8D%E7%BD%AE--%E5%92%8C%E5%90%8E%E7%BD%AE--" rel="nofollow">前置--和后置--</a></p> 
<p id="%E6%AF%94%E5%A4%A7%E5%B0%8F%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD-toc" style="margin-left:40px;"><a href="#%E6%AF%94%E5%A4%A7%E5%B0%8F%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD" rel="nofollow">比大小运算符的重载</a></p> 
<p id="%E6%97%A5%E6%9C%9F-%E6%97%A5%E6%9C%9F%E8%BF%94%E5%9B%9E%E5%A4%A9%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E6%97%A5%E6%9C%9F-%E6%97%A5%E6%9C%9F%E8%BF%94%E5%9B%9E%E5%A4%A9%E6%95%B0" rel="nofollow">日期-日期返回天数</a></p> 
<p id="%E6%9A%B4%E5%8A%9B%2B%2B%E6%B3%95-toc" style="margin-left:80px;"><a href="#%E6%9A%B4%E5%8A%9B%2B%2B%E6%B3%95" rel="nofollow">暴力++法</a></p> 
<p id="%E7%9B%B4%E6%8E%A5%E7%9B%B8%E5%87%8F%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E7%9B%B4%E6%8E%A5%E7%9B%B8%E5%87%8F%E6%B3%95" rel="nofollow">直接相减法</a></p> 
<p id="const%E6%88%90%E5%91%98-toc" style="margin-left:40px;"><a href="#const%E6%88%90%E5%91%98" rel="nofollow">const成员</a></p> 
<p id="%E6%B5%81%E6%8F%92%E5%85%A5%E5%92%8C%E6%B5%81%E6%8F%90%E5%8F%96%E9%87%8D%E8%BD%BD-toc" style="margin-left:40px;"><a href="#%E6%B5%81%E6%8F%92%E5%85%A5%E5%92%8C%E6%B5%81%E6%8F%90%E5%8F%96%E9%87%8D%E8%BD%BD" rel="nofollow">流插入和流提取重载</a></p> 
<p id="%E5%8F%8B%E5%85%83%EF%BC%88friend%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E5%8F%8B%E5%85%83%EF%BC%88friend%EF%BC%89" rel="nofollow">友元（friend）</a></p> 
<p id="%E7%BB%93%E8%AF%AD-toc" style="margin-left:0px;"><a href="#%E7%BB%93%E8%AF%AD" rel="nofollow">结语</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<blockquote> 
 <p>本篇主要内容：<span style="background-color:#a2e043;">日期类的实现</span></p> 
</blockquote> 
<p>上篇我们介绍了拷贝构造函数和赋值运算符重载两大类的默认成员函数，本篇将会介绍更多关于操作符重载的实例运用。日期类，是与日期相关的类，主要用于处理与日期和时间相关的操作。我们将在完善一个日期类的过程中加深对运算符重载的理解和运用。在理解操作符重载之后，最后两个默认成员函数学习起来也就不是什么大问题了。</p> 
<h2 id="%E6%97%A5%E6%9C%9F%E7%B1%BB">日期类</h2> 
<h3 id="%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%9C%B0%E5%9B%BE">日期类实现地图</h3> 
<p>在实现日期类之前，需事先要知道要实现哪些内容。我会给出一份类的指南，也就是成员变量和成员函数的声明，然后根据声明一步步实现其中的成员函数。在代码编写过程中，成员函数是可以直接定义在类内部的；但是在实际开发过程中，考虑到工程级项目的规模，<strong>一般采用声明和定义分离的方式经行类的实现</strong>。将<span style="background-color:#a2e043;">声明统一放在 Date.h 中</span>，把<span style="background-color:#a2e043;">成员函数的定义统一放在 Date.cpp 中</span>，道理跟C语言的声明定义分离一样。</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cassert&gt;
using namespace std;

class Date
{
	// 友元
	friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const Date&amp; d);
	friend istream&amp; operator&gt;&gt;(istream&amp; in, Date&amp; d);
public:
	// 获取某年某月的天数
	int GetMonthDay(int year, int month);
	// 检查日期是否合法
	bool CheckDate();
	// 全缺省的构造函数
	Date(int year = 1900, int month = 1, int day = 1);
	// 拷贝构造函数
  // d2(d1)
	Date(const Date&amp; d);
	// 赋值运算符重载
  // d2 = d3 -&gt; d2.operator=(&amp;d2, d3)
	Date&amp; operator=(const Date&amp; d);
	// 析构函数
	~Date();
	// 日期+=天数
	Date&amp; operator+=(int day);
	// 日期+天数
	Date operator+(int day);
	// 日期-天数
	Date operator-(int day);
	// 日期-=天数
	Date&amp; operator-=(int day);
	// 前置++
	Date&amp; operator++();
	// 后置++
	Date operator++(int);
	// 后置--
	Date operator--(int);
	// 前置--
	Date&amp; operator--();
	// &gt;运算符重载
	bool operator&gt;(const Date&amp; d);
	// ==运算符重载
	bool operator==(const Date&amp; d);
	// &gt;=运算符重载
	bool operator &gt;= (const Date&amp; d);
	// &lt;运算符重载
	bool operator &lt; (const Date&amp; d);
	// &lt;=运算符重载
	bool operator &lt;= (const Date&amp; d);
	// !=运算符重载
	bool operator != (const Date&amp; d);
	// 日期-日期 返回天数
	int operator-(const Date&amp; d);
	void Print() 
	{
		cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl;
	}
private:
	int _year;
	int _month;
	int _day;
};

// 输出流重载
ostream&amp; operator&lt;&lt;(ostream&amp; out, const Date&amp; d);
// 输入流重载
istream&amp; operator&gt;&gt;(istream&amp; in, Date&amp; d);</code></pre> 
<p>这份地图中大家也许会发现很多陌生的内容，如友元，重载前置++和后置++，流插入和流提取重载等。不过不用着急，接下来都会讲到。</p> 
<h3 id="%E8%8E%B7%E5%8F%96%E6%9F%90%E5%B9%B4%E6%9F%90%E6%9C%88%E7%9A%84%E5%A4%A9%E6%95%B0%EF%BC%9AGetMonthDay">获取某年某月的天数：GetMonthDay</h3> 
<p>GetMonthDay函数用于获取某年某月的天数，由于其在<span style="background-color:#ffd900;">日期加天数和减天数运算符重载的函数中被频繁调用</span>，且<span style="background-color:#a2e043;">代码量较少</span>，我们<span style="background-color:#38d8f0;">可以直接将其设置为内联，定义到类的内部</span>（<strong>定义到类内部的成员函数都默认加了内联inline，而分离定义的成员函数没有此特性</strong>）。</p> 
<blockquote> 
 <p>注：分离声明和定义的函数是<strong>无法内联的</strong>。</p> 
</blockquote> 
<pre><code class="language-cpp">int GetMonthDay(int year, int month)
{
	assert(month &gt; 0 &amp;&amp; month &lt; 13);
	int months[13] = { -1,31,28,31,30,31,30,31,31,30,31,30,31 };
   	if (month == 2 &amp;&amp; (year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0)) {
	    return 29;
	}
	else return months[month];
}</code></pre> 
<p>由于此函数定义在类的内部，故没有 <strong><span style="background-color:#faa572;">Date::</span></strong> 来指定命名空间，此函数的其他逻辑应该也好理解，最终通过传过来的年和月来确定当月的天数，考虑到闰年判断等问题。</p> 
<h3 id="%E6%A3%80%E6%9F%A5%E6%97%A5%E6%9C%9F%E5%90%88%E6%B3%95%EF%BC%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%8F%8A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">检查日期合法，构造函数，拷贝构造函数，赋值运算符重载及析构函数</h3> 
<p>检查日期是否合法，需要检查月不能小于1或者大于12，日要根据年和月来判断，见代码：</p> 
<pre><code class="language-cpp">bool Date::CheckDate() // 由于声明和定义分离，定义函数时需指定一下命名空间Date::
{
	if (_month &lt; 1 || _month &gt; 12
		|| _day &lt; 1 || _day &gt; GetMonthDay(_year, _month)) {
		return false;
	}
	else return true;
}
</code></pre> 
<p>构造函数，拷贝构造以及赋值重载等没什么好说的，注意拷贝构造需判断一下日期是否合法：</p> 
<pre><code class="language-cpp">// 全缺省的构造函数
Date::Date(int year, int month, int day)
{
	_year = year;
	_month = month;
	_day = day;
	if (!CheckDate()) {
		cout &lt;&lt; "日期非法\n" &lt;&lt; endl;
	}
}

// 拷贝构造函数
// d2(d1)
Date::Date(const Date&amp; d)
{
	_year = d._year;
	_month = d._month;
	_day = d._day;
}

// 赋值运算符重载
 // d2 = d3 -&gt; d2.operator=(&amp;d2, d3)
Date&amp; Date::operator=(const Date&amp; d)
{
	_year = d._year;
	_month = d._month;
	_day = d._day;
	return *this;
}

// 析构函数
Date::~Date()
{
	_year = 0;
	_month = 0;
	_day = 0;
}</code></pre> 
<h3 id="%E6%97%A5%E6%9C%9F%E7%B1%BB%E7%9A%84%2B%3Dday%E5%92%8C%2Bday">日期类的+=day和+day</h3> 
<p>日期类可以+吗？答案是肯定的，不过不是两个日期相加，而是一个日期去+一个天数，如，今天是2024/4/20，加上5就是五天后，五天后是2024/4/25。如何实现+=，来看看代码：</p> 
<pre><code class="language-cpp">// 日期+=天数
Date&amp; Date::operator+=(int day)
{
    // 此处是对+的day为负时的处理
	if (day &lt; 0) {
		*this -= (-day); // 复用了-=，下文会讲
		return *this;
	}
	_day += day;
	while (_day &gt; GetMonthDay(_year, _month)) {
		_day -= GetMonthDay(_year, _month);
		++_month;
		if (_month == 13) {
			++_year;
			_month = 1;
		}
	}
	return *this;
}</code></pre> 
<p>如果day为大于0的数，首先将day的值加到成员变量_day上，然后循环判断_day是否大于当月天数，如果大于，就减去当月天数，_month+1，_year根据_month是否大于12判断自增；如果_day小于当月天数，则跳出循环。最后返回值是为了贴合内置类型连续运算赋值的规则，如，a=b+=c；而<span style="background-color:#ffd900;">Date&amp;引用返回则是为了减少拷贝</span>。</p> 
<p>写道这里，就即将到类和对象一个神奇的使用方式了，它的名字叫——<strong><span style="background-color:#a2e043;">复用</span></strong>！</p> 
<p>我们可以直接复用+=来实现+，来看看具体的复用代码：</p> 
<pre><code class="language-cpp">// 日期+天数
Date Date::operator+(int day)
{
	Date tmp(*this);
	tmp += day; // 复用+=
	return tmp;
}</code></pre> 
<p>日期+day的规则是不能改变运算日期的值，所以这里在成员函数中定义了一个tmp拷贝，用来执行运算操作，最后传值返回，是因为tmp作为临时变量，出了函数就会销毁。</p> 
<blockquote> 
 <p>注：这里提供的是+=复用+的设计模式。实际上，用+复用+=也是可行的，但是这种复用方式却比+=复用的质量差，大家感兴趣可以自行实现并考虑其中原因。</p> 
</blockquote> 
<h3 id="%E6%97%A5%E6%9C%9F%E7%B1%BB%E7%9A%84-%3Dday%E5%92%8C-day">日期类的-=day和-day</h3> 
<p>-=day虽然思路和+=差不多，但是逻辑却比+=难搞一些，建议仔细思考后在上手写。</p> 
<pre><code class="language-cpp">// 日期-=天数
Date&amp; Date::operator-=(int day)
{
    // 当减的天数为负时的操作
	if (day &lt; 0) {
		*this += (-day);// 复用了刚才写的+=
		return *this;
	}
	_day -= day;
	while (_day &lt; 1) {
		--_month;
		if (_month == 0) {
			--_year;
			_month = 12;
		}
		day += GetMonthDay(_year, _month);
	}
	return *this;
}</code></pre> 
<p>在给_day+=天数时，注意加的是上个月的天数，并非本月天数。写了-=，-的实现也就是简单的复用操作了：</p> 
<pre><code class="language-cpp">// 日期-天数
Date Date::operator-(int day)
{
	Date tmp(*this);
	tmp -= day;
	return tmp;
}</code></pre> 
<p>返回值是否引用返回和+=day和+day是同理的。</p> 
<h3 id="%E5%89%8D%E7%BD%AE%2B%2B%E5%92%8C%E5%90%8E%E7%BD%AE%2B%2B">前置++和后置++</h3> 
<p>知道内置类型的前置++和后置++吗？如++a，a++等，它们的作用都是给变量a自增1，学了这么长时间，你是否对它们的区别了如指掌。本篇我们讲的是自定义类型的自增，如，日期类，我们要给一个自定义类型（日期类）自增，但计算机并不知道日期自增的规则，这时就需要人为提供内置类型的自增运算符。其实，上面刚刚讲过复用，我们直接复用+=和-=就可以了，你想想，什么是++？什么是--？不就是+=1和-=1嘛！</p> 
<pre><code class="language-cpp">// 前置++：返回+1之后的结果
Date&amp; Date::operator++()
{
	*this += 1;
	return *this;
}</code></pre> 
<blockquote> 
 <p>注：this指向的对象函数结束后不会销毁，故以<strong>引用方式返回提高效率</strong>。</p> 
</blockquote> 
<p>如果不提供参数，在C++的定义之下，默认就是放到对象前面的重载运算符：++d，但如果单将一个运算符放到对象后面构成运算符重载应该怎么办呢？看看C++提供的解决方式：</p> 
<pre><code class="language-cpp">// 后置++：自增，返回自增之前的拷贝
Date Date::operator++(int)
{
	Date tmp(*this);
	*this += 1;
	return tmp;
}</code></pre> 
<blockquote> 
 <p>前置++和后置++都是一元运算符，<strong>为了可以让前置++和后置++形成正确重载，C++规定</strong>：<span style="background-color:#38d8f0;">后置++重载时多增加一个int类型的参数，但调用参数时该参数不用传递，编译器自动传递</span>。</p> 
</blockquote> 
<blockquote> 
 <p>注：后置++是先使用后+1，因此只需要返回+1前的值，故需要先将this保存一份，然后给this+1。而代码中的<span style="background-color:#a2e043;">tmp是临时对象</span>，因此<span style="background-color:#ffd900;">只能以值得方式返回</span>，而<span style="background-color:#38d8f0;">不能返回引用</span>。</p> 
</blockquote> 
<h3 id="%E5%89%8D%E7%BD%AE--%E5%92%8C%E5%90%8E%E7%BD%AE--">前置--和后置--</h3> 
<p>不想多说了，四个字——<strong>同理，复用</strong>！</p> 
<pre><code class="language-cpp">// 前置--
Date&amp; Date::operator--()
{
	*this -= 1;
	return *this;
}

// 后置--
Date Date::operator--(int)
{
	Date tmp(*this);
	*this -= 1;
	return tmp;
}</code></pre> 
<p>注意区分前置和后置的区别，控制下返回值是否引用返回就行。</p> 
<h3 id="%E6%AF%94%E5%A4%A7%E5%B0%8F%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD">比大小运算符的重载</h3> 
<p>为什么要给日期提供比大小重载，因为内置类型无法完成比较日期的任务。比大小需要提供的重载函数就多了，包括 &lt;，&lt;=，==，&gt;，&gt;=，!= ，一套写下来，岂不是能把人累瘫，别着急，实际上，需要你完成的实际上只有两个，<span style="background-color:#a2e043;">&gt; 和 ==</span>，当然你选择 <span style="background-color:#a2e043;">&lt; 和 ==</span>，或者 <span style="background-color:#a2e043;">&lt;，!=</span> 统统都可以，如果还没想通，没关系，来看看我是如何实现的，这里以<span style="background-color:#a2e043;">&gt; 和 ==</span>为例。</p> 
<pre><code class="language-cpp">// &gt;运算符重载
bool Date::operator&gt;(const Date&amp; d)
{
	if (_year &gt; d._year
		|| _year == d._year &amp;&amp; _month &gt; d._month
		|| _year == d._year &amp;&amp; _month == d._month &amp;&amp; _day &gt; d._day) return true;
	return false;
}

// ==运算符重载
bool Date::operator==(const Date&amp; d)
{
	return _year == d._year
		&amp;&amp; _month == d._month
		&amp;&amp; _day == d._day;
}</code></pre> 
<p>这里是对于&gt;和==的重载，其中逻辑不难理解。</p> 
<blockquote> 
 <p>此时如果我们想要实现 &gt;= ，直接复用上面两个重载就可以了。</p> 
</blockquote> 
<pre><code class="language-cpp">// &gt;=运算符重载
bool Date::operator&gt;=(const Date&amp; d)
{
	return *this &gt; d || *this == d;
}</code></pre> 
<p>发现C++运算符重载和复用的魅力了吗？</p> 
<p>如果此时你需要一个 &lt; 重载：</p> 
<pre><code class="language-cpp">// &lt;运算符重载
bool Date::operator&lt;(const Date&amp; d)
{
	return !(*this &gt; d || *this == d);
}</code></pre> 
<p>如果此时你需要一个 &lt;= 重载：</p> 
<pre><code class="language-cpp">// &lt;=运算符重载
bool Date::operator&lt;=(const Date&amp; d)
{
	return !(*this &gt; d);
}</code></pre> 
<p>如果此时你需要一个  != 重载：</p> 
<pre><code class="language-cpp">// !=运算符重载
bool Date::operator!=(const Date&amp; d)
{
	return !(*this == d);
}</code></pre> 
<p>如果……哦，已经没有如果了，这就是所有的比大小运算符重载🙂，很有意思吧。</p> 
<h3 id="%E6%97%A5%E6%9C%9F-%E6%97%A5%E6%9C%9F%E8%BF%94%E5%9B%9E%E5%A4%A9%E6%95%B0">日期-日期返回天数</h3> 
<p>日期减日期为的是计算两个日期之间的天数间隔。对于日期相减，这里提供了两种实现方案。</p> 
<h4 id="%E6%9A%B4%E5%8A%9B%2B%2B%E6%B3%95">暴力++法</h4> 
<p>找出日期中小的那个，然后通过记录每次++的次数n来记录两日期之间的间隔，同时设置一个变量flag来记录两个日期之间的差是正的还是负的。</p> 
<pre><code class="language-cpp">// 日期-日期 返回天数
int Date::operator-(const Date&amp; d)
{
	Date max = *this;// 假设大的那个是*this
	Date min = d;
	int flag = 1;
	int n = 0;
	if (*this &lt; d) { //判断并重置max和min以及日期间隔正负
		max = d;
		min = *this;
        flag = -1;
	}
	while (min != max) {
		++min;
		++n;
	}
	return n * flag;
}</code></pre> 
<blockquote> 
 <p>此方法也是最好理解的一种，虽然暴力++会有一些消耗，但是对于目前计算机的算力来说却是微不足道的。</p> 
</blockquote> 
<h3 id="%E7%9B%B4%E6%8E%A5%E7%9B%B8%E5%87%8F%E6%B3%95">直接相减法</h3> 
<p>这个过程就稍稍有些复杂，你可以先确定<span style="background-color:#ffd900;">max（大日期对象）</span><strong>下一年的第一天</strong>为<span style="background-color:#a2e043;">tmpmax</span>和<span style="background-color:#ffd900;">min（小日期对象）</span><strong>本年的第一天</strong><span style="background-color:#a2e043;">tmpmin</span>，让它们的<span style="background-color:#38d8f0;">差值✖365</span>，加到 <strong>n </strong>上，同时遍历一遍这些年，找到一个闰年就让n+1。最后定义两个整型变量（tmp1，tmp2），<span style="background-color:#ffd7b9;">让tmpmin逐次++（++使用的是之前重载的日期类++，最好用前置++，减少拷贝的消耗），同时用tmp1计数，直到和min相等</span>；<span style="background-color:#ffd7b9;">让max逐次++，同时tmp2计数，直到和tmpmax相等</span>。这时让<span style="background-color:#f9eda6;">n减去tmp1和tmp2后</span>，得到的就是两个日期之间的差值了。</p> 
<p>以下是实现代码，亲测正确：</p> 
<pre><code class="language-cpp">int Date::operator-(const Date&amp; d)
{
	Date max = *this;
	Date min = d;
	int flag = 1;
	int n = 0;
	if (*this &lt; d) {
		max = d;
		min = *this;
		flag = -1;
	}
    // 以上是比较日期确定max和min
	n += (max._year - min._year + 1) * 365;
	for (int i = min._year; i &lt;= max._year; i++)
		if (i % 4 == 0 &amp;&amp; i % 100 != 0 || i % 400 == 0)
			++n;
    // 以上是根据年计算间隔的天数
	Date tmpmax(max._year + 1, 1, 1);int tmp1 = 0;
	Date tmpmin(min._year, 1, 1);int tmp2 = 0;
	while (tmpmax != max) {
		++max;
		++tmp1;
	}
	while (tmpmin != min) {
		++tmpmin;
		++tmp2;
	}
    // 以上是日期矫正，计算tmp1和tmp2
	n -= tmp1;
	n -= tmp2;
	return n * flag;
}</code></pre> 
<p>对于日期相减，不止有这两种实现，大家想到一些别的方式也可以自己亲自试一试，还是很有意思的。</p> 
<h3 id="const%E6%88%90%E5%91%98">const成员</h3> 
<p><strong>将const修饰的“成员函数”称之为const成员函数</strong>，const修饰类成员函数，实际修饰该成员函数<strong>隐含的this指针</strong>，表明在该成员函数中<strong>不能对类的任何成员进行修改</strong>。</p> 
<p>具体怎么修饰呢？写一个const在参数列表后面：</p> 
<p><img alt="" height="528" src="https://images2.imgbox.com/e2/31/Nj1RTmva_o.png" width="1083"></p> 
<p>在（）括号后放const是<strong>将隐式传递的<span style="background-color:#a2e043;">*this</span>指针类型变成了<span style="background-color:#a2e043;">const *this</span></strong>指针类型，这种解决方案是为了应对*this无法被显示改变为const类型而产生的。</p> 
<p>对于const类型的对象，和内置类型的const修饰规则非常相似，权限只能平移和缩小，而不能放大。看看代码案例：</p> 
<pre><code class="language-cpp">const Date d1;
Date&amp; d2 = d1;// 不支持，d2是Date类型，取d1的引用属权限放大
const Date&amp; d3 = d1;//支持，权限平移

Date d4;
const Date&amp; d5 = d4;// 支持，权限缩小</code></pre> 
<blockquote> 
 <p>故<span style="background-color:#a2e043;">对于const成员函数内部，是不可以调用非const成员函数的</span>；而<span style="background-color:#a2e043;">非const成员函数却可以调用其他的const成员函数</span>。</p> 
</blockquote> 
<p>所以，对于一些不会改动Date对象数据的成员函数，尽量提供const类型的成员函数即可，如下：</p> 
<pre><code class="language-cpp">// 获取某年某月的天数const版
int GetMonthDay(int year, int month)const
{
	assert(month &gt; 0 &amp;&amp; month &lt; 13);
	int months[13] = { -1,31,28,31,30,31,30,31,31,30,31,30,31 };
	if (month == 2 &amp;&amp; (year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0)) {
		return 29;
	}
	else return months[month];
}</code></pre> 
<p>GetMonthDay定义在类内部，故不需要限定命名空间。</p> 
<pre><code class="language-cpp">// 检查日期是否合法const版
bool Date::CheckDate()const
{
	if (_month &lt; 1 || _month&gt;12
		|| _day &lt; 1 || _day&gt;GetMonthDay(_year, _month)) {
		return false;
	}
	else return true;
}</code></pre> 
<p>基本上就是在函数（）后加上const即可，需要这样调整的函数还包括比大小重载函数，日期相减函数，-day和+day，Print打印日期函数等等，这里就不一一列举了。</p> 
<h3 id="%E6%B5%81%E6%8F%92%E5%85%A5%E5%92%8C%E6%B5%81%E6%8F%90%E5%8F%96%E9%87%8D%E8%BD%BD">流插入和流提取重载</h3> 
<p>大家之前可能接触过C语言，这里就能体现出C语言输入输出的局限性了，它没办法支持对象类型的输入输出。在C++标准库<span style="background-color:#fbd4d0;">&lt;iostream&gt;（包含istream类和ostream类）</span>中，内含了输入流对象<span style="background-color:#fbd4d0;">cin</span>和输出流对象<span style="background-color:#fbd4d0;">cout</span>，通过使用这两个对象，我们可以支持输出所有的内置类型变量。今天要讲的流插入和流提取重载，就是可以帮助大家直接用cin和cout支持内置类型的输入输出。</p> 
<p>如果需要定义一个流插入的重载，你会如何定义呢？</p> 
<pre><code class="language-cpp">void Date::operator&lt;&lt;(ostream&amp; out)
{
    cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt;_day &lt;&lt;endl;
}</code></pre> 
<p>是这样吗？那就大错特错了，按照运算符重载规则，</p> 
<blockquote> 
 <p>cout &lt;&lt; d；</p> 
</blockquote> 
<p>这种书写方式明显不符合重载时的参数顺序，所以如果想要调用上面这份重载，需要这样写：</p> 
<blockquote> 
 <p>d &lt;&lt; cout；</p> 
</blockquote> 
<p>但是，这种使用方式明显<span style="background-color:#ff9900;">违背了像内置类型那样使用输入输出流的初衷</span>。产生这种问题的主要原因还是<strong>无法改变</strong><span style="background-color:#a2e043;">调用类内部定义的成员函数时</span>，<span style="background-color:#ffd900;">第一个传过去的元素永远是this指针</span>。</p> 
<p>为解决这样的问题，需要我们把流插入和流提取的函数重载在类的外部，像下面这样：</p> 
<pre><code class="language-cpp">ostream&amp; operator&lt;&lt;(ostream&amp; out, const Date&amp; d)
{
	out &lt;&lt; d._year &lt;&lt; "年" &lt;&lt; d._month &lt;&lt; "月" &lt;&lt; d._day &lt;&lt; "日" &lt;&lt; endl;
	return out;
}</code></pre> 
<p>这里返回一个对象引用类型是为了贴合内置类型的使用规则，连续输出，如cout &lt;&lt; a &lt;&lt; b &lt;&lt; c；如果没有此返回值，那么使用对象时，就只能用一次cout打印一个Date对象，如cout &lt;&lt; d；而不是cout &lt;&lt; d1 &lt;&lt; d2 &lt;&lt; d3；。</p> 
<p>流提取也是同样的方法：</p> 
<pre><code class="language-cpp">istream&amp; operator&gt;&gt;(istream&amp; in, Date&amp; d)
{
	cout &lt;&lt; "请输入年月日，用空格分隔:";
	in &gt;&gt; d._year &gt;&gt; d._month &gt;&gt; d._day;
	if (!d.CheckDate()) {
		cout &lt;&lt; "日期非法\n" &lt;&lt; endl;
	}
	return in;
}</code></pre> 
<p>返回一个对象的引用也是为了贴合内置类型使用规则。</p> 
<p>到这里，你不免会问，如果将重载函数定义在了类的外部，那么该如何使用类内部定义的私有成员变量，如_year，_month，_day呢？别急，接下来补一下之前挖的坑，友元。</p> 
<h3 id="%E5%8F%8B%E5%85%83%EF%BC%88friend%EF%BC%89">友元（friend）</h3> 
<p>在C++中，<strong>友元</strong>（Friend）是一个特殊的机制，它<span style="background-color:#a2e043;">允许一个非成员函数或者一个类（或类的成员函数）访问另一个类的私有（private）或保护（protected）成员</span>。友元不是类的成员，但它可以访问类的所有成员，包括私有和保护成员。这种访问权限的赋予是通过在类的定义中使用<code><span style="background-color:#ffd900;">friend</span></code><span style="background-color:#ffd900;">关键字</span>来实现的。只需要<strong>在类的内部添加上类外定义的函数的声明，并在声明前加上关键字friend即可</strong>，一般这种友元函数允许写在类内部的任意地方，一般来说会把它放在整个类的开头。<strong>当一个函数成为一个类的友元</strong>，那么这个函数内部就可以<strong>随意使用类中的</strong><strong>私有（private）或保护（protected）成员了</strong>。</p> 
<pre><code class="language-cpp">class Date
{
	// 友元
	friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const Date&amp; d);
	friend istream&amp; operator&gt;&gt;(istream&amp; in, Date&amp; d);
public:
    //。。。
private:
    //。。。
}</code></pre> 
<p><img alt="" height="378" src="https://images2.imgbox.com/ef/83/fbgxeZRf_o.png" width="1006"></p> 
<h2 id="%E7%BB%93%E8%AF%AD">结语</h2> 
<p>本篇博客<strong>实现了日期类Date，加深对运算符重载的运用，讲了前置++和后置++：传一个改变成后置++样式的int；还讲到const成员：由于无法改变*this类型而添加的const；流插入和流提取重载：由于无法改变传参顺序而定义到类的外部等等</strong>。这篇博客也算是对之前学到类和对象内容的一个阶段性的应用和总结吧。</p> 
<p>博主后续还会产出更多有意思的内容，感谢大家的支持！♥</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/81e4de5dd86a617d2fa5a2de8991bb9b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Rust面试宝典第6题：快乐数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/617a8b29a312d20beb181c40504409ee/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">离线数仓（五）【数据仓库建模】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>