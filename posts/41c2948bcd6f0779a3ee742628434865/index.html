<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法学习：数组 vs 链表 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/41c2948bcd6f0779a3ee742628434865/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="算法学习：数组 vs 链表">
  <meta property="og:description" content="🔥 个人主页：空白诗 文章目录 🎯 引言🛠️ 内存基础什么是内存❓内存的工作原理 🎯 📦 数组（Array）📖 什么是数组🌀 数组的存储📝 示例代码（go语言）🎯 执行增加操作🎯 执行删除操作 📊 优缺点分析 🔗 链表（Linked List）📖 什么是链表🌀 链表的存储📝 示例代码（go语言）📊 优缺点分析 📊 数组与链表的对比🎯 访问速度🎯 插入与删除效率🎯 空间利用效率🎯 应用场景 📚 小结 🎯 引言 在编程的奇妙世界里，数组和链表作为两种基础且重要的数据结构，各自扮演着不可替代的角色。它们在存储和管理数据方面展现出了不同的优势和局限。本文将带领你深入了解数组(Array)与链表(Linked List)的奥秘🚀
🛠️ 内存基础 什么是内存❓ 内存，尤其是随机存取存储器（RAM），是计算机中用于临时存储数据和程序指令的部分。与硬盘相比，内存访问速度快，但信息非持久保存。
想象一下，当你在解决一个复杂的算法问题时，那些数字、字符，乃至复杂的数据结构，都需要一个地方暂时停留和操作——这个地方就是内存
内存的工作原理 🎯 内存由一系列连续或非连续的存储单元组成，每个单元都有一个独一无二的地址。通过地址，CPU（中央处理器）可以迅速找到所需的数据。
就好比内存是一个储物柜，你将东西放进去后会给你一个号码，通过号码你可以快速找到你存储物品的柜子。
需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式——数组和链表。
📦 数组（Array） 📖 什么是数组 数组是一种线性数据结构，它将元素按照一定的顺序存储在一块连续的内存区域中。每个元素都有一个索引（从0开始），通过索引可以快速访问数组中的任意元素。但是对于插入和删除，特别是当位置不在末尾时，可能需要移动后续的所有元素，以保持连续性，导致最坏情况下的时间复杂度为O(n)。
&#43;---&#43;---&#43;---&#43;---&#43; | 1 | 2 | 3 | 4 | &#43;---&#43;---&#43;---&#43;---&#43; ^ ^ | | 索引0 索引3 🌀 数组的存储 数组在创建时会一次性申请足够的内存空间进行存储。这意味着数组的大小是固定的，一旦声明，不能轻易改变。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-08T09:11:04+08:00">
    <meta property="article:modified_time" content="2024-05-08T09:11:04+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法学习：数组 vs 链表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/b4/79/4fIjlgB8_o.png" alt="在这里插入图片描述"></p> 
<center> 
 <strong><font color="red">🔥 个人主页：<a href="https://blog.csdn.net/m0_52827996?spm=1010.2135.3001.5343">空白诗</a></font></strong> 
</center> 
<p><img src="https://images2.imgbox.com/46/62/7eopWkfd_o.gif" alt="在这里插入图片描述"></p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#__12" rel="nofollow">🎯 引言</a></li><li><a href="#__20" rel="nofollow">🛠️ 内存基础</a></li><li><ul><li><a href="#_22" rel="nofollow">什么是内存❓</a></li><li><a href="#__28" rel="nofollow">内存的工作原理 🎯</a></li></ul> 
   </li><li><a href="#_Array_38" rel="nofollow">📦 数组（Array）</a></li><li><ul><li><a href="#__40" rel="nofollow">📖 什么是数组</a></li><li><a href="#__55" rel="nofollow">🌀 数组的存储</a></li><li><a href="#_go_68" rel="nofollow">📝 示例代码（go语言）</a></li><li><ul><li><a href="#__117" rel="nofollow">🎯 执行增加操作</a></li><li><a href="#__149" rel="nofollow">🎯 执行删除操作</a></li></ul> 
    </li><li><a href="#___181" rel="nofollow">📊 优缺点分析</a></li></ul> 
   </li><li><a href="#_Linked_List_193" rel="nofollow">🔗 链表（Linked List）</a></li><li><ul><li><a href="#__195" rel="nofollow">📖 什么是链表</a></li><li><a href="#__202" rel="nofollow">🌀 链表的存储</a></li><li><a href="#_go_209" rel="nofollow">📝 示例代码（go语言）</a></li><li><a href="#___309" rel="nofollow">📊 优缺点分析</a></li></ul> 
   </li><li><a href="#__323" rel="nofollow">📊 数组与链表的对比</a></li><li><ul><li><a href="#__328" rel="nofollow">🎯 访问速度</a></li><li><a href="#__332" rel="nofollow">🎯 插入与删除效率</a></li><li><a href="#__336" rel="nofollow">🎯 空间利用效率</a></li><li><a href="#__340" rel="nofollow">🎯 应用场景</a></li></ul> 
   </li><li><a href="#__347" rel="nofollow">📚 小结</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h3><a id="__12"></a>🎯 引言</h3> 
<blockquote> 
 <p>在编程的奇妙世界里，数组和链表作为两种基础且重要的数据结构，各自扮演着不可替代的角色。它们在存储和管理数据方面展现出了不同的优势和局限。本文将带领你深入了解<code>数组(Array)</code>与<code>链表(Linked List)</code>的奥秘🚀</p> 
</blockquote> 
<hr> 
<h3><a id="__20"></a>🛠️ 内存基础</h3> 
<h4><a id="_22"></a>什么是内存❓</h4> 
<p><strong>内存</strong>，尤其是随机存取存储器（RAM），是计算机中用于临时存储数据和程序指令的部分。与硬盘相比，内存访问速度快，但信息非持久保存。</p> 
<blockquote> 
 <p>想象一下，当你在解决一个复杂的算法问题时，那些数字、字符，乃至复杂的数据结构，都需要一个地方暂时停留和操作——这个地方就是内存</p> 
</blockquote> 
<h4><a id="__28"></a>内存的工作原理 🎯</h4> 
<p><strong>内存</strong>由一系列连续或非连续的<strong>存储单元</strong>组成，每个单元都有一个独一无二的地址。通过<strong>地址</strong>，CPU（中央处理器）可以迅速找到所需的数据。</p> 
<blockquote> 
 <p>就好比内存是一个储物柜，你将东西放进去后会给你一个号码，通过号码你可以快速找到你存储物品的柜子。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/60/f4/lyGtkwgT_o.png" alt="在这里插入图片描述"></p> 
<p>需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式——<mark>数组和链表</mark>。</p> 
<hr> 
<h3><a id="_Array_38"></a>📦 数组（Array）</h3> 
<h4><a id="__40"></a>📖 什么是数组</h4> 
<p><strong>数组</strong>是一种<mark>线性数据结构</mark>，<font color="green"><strong>它将元素按照一定的顺序存储在一块连续的内存区域中</strong></font>。每个元素都有一个索引（从0开始），<mark>通过索引可以快速访问数组中的任意元素</mark>。但是对于插入和删除，特别是当位置不在末尾时，可能需要移动后续的所有元素，以保持连续性，导致最坏情况下的时间复杂度为O(n)。</p> 
<pre><code class="prism language-plaintext">+---+---+---+---+
| 1 | 2 | 3 | 4 |
+---+---+---+---+
  ^           ^
  |           |
 索引0       索引3
</code></pre> 
<h4><a id="__55"></a>🌀 数组的存储</h4> 
<p>数组在创建时会一次性申请足够的内存空间进行存储。这意味着数组的大小是固定的，一旦声明，不能轻易改变。</p> 
<blockquote> 
 <p>如果需要在数组中添加新元素很麻烦，因为数组必须是连续的。比如你和3个朋友一起去看电影，已经选好了连坐的4个位置并且付款。此时又有一个朋友要与你们一起看，你们想要连排座，但是你们已经选好的这4个位置旁边没有了空位，所以你们只能放弃这4个位置进行退款，然后重新选择有5个连坐的位置。如果又来了一位朋友，而当前坐的地方也没有空位，你们就得再次转移！真是太麻烦了。如果没有了空间，就得移到内存的其他地方，因此添加新元素的速度会很慢。</p> 
</blockquote> 
<blockquote> 
 <p>而此时如果中间某个人不看电影了，那么后面的人就需要向前靠拢和大家坐在一起，即在数组中删除元素，就需要移动后面的所有元素。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/75/8e/u9uLhuZd_o.png" alt="在这里插入图片描述"><br> 如上图，此时如果再来一个人，只能舍弃原本的四个位置，去重新找有五个连续的位置。如果此时’王五‘不看电影了，那右边的赵六就需要向左边坐一个位置与大家靠拢。</p> 
<h4><a id="_go_68"></a>📝 示例代码（go语言）</h4> 
<pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 定义一个整型切片</span>
	arr <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span>
	temp <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{<!-- --></span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">}</span>
	<span class="token comment">// 遍历切片并打印每个元素及其地址</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> arr <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Element: %d, Address: %p\n"</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> temp <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"temp: %d, Address: %p\n"</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 添加一个元素</span>
	arr <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span>

	<span class="token comment">// 删除索引为3的元素（值为4）</span>
	<span class="token comment">//arr = append(arr[:3], arr[4:]...)</span>

	<span class="token comment">// 	遍历切片并打印每个元素及其地址</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"-----\n"</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> arr <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Element: %d, Address: %p\n"</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> temp <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"temp: %d, Address: %p\n"</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在Go语言中，数组和切片的处理方式有所不同。首先，理解一下基本概念：</p> 
<ul><li><strong>数组</strong>：固定大小的元素序列，分配一块连续的内存。</li><li><strong>切片</strong>：是对数组的一个引用，包含指向底层数组的指针、长度和容量信息。切片本身是轻量级的，修改切片（如追加、删除）操作可能引起底层数组的重新分配。</li></ul> 
<p>这段代码中，<code>arr</code> 是一个切片，但它的初始化方式 <code>[1, 2, 3, 4, 5]</code> 实际上创建了一个底层数组，并用这个数组来初始化切片。而 <code>temp</code> 同样是一个基于数组初始化的切片。</p> 
<p>假设初始时，<code>arr</code> 的底层数组在内存中的布局如下（简化表示）：</p> 
<pre><code>| arr[0]: 1 | arr[1]: 2 | arr[2]: 3 | arr[3]: 4 | arr[4]: 5 |
</code></pre> 
<blockquote> 
 <p>每个元素旁边标注的是其值和大致的内存地址（实际地址会更复杂，但这里为了简化说明）。注意，<code>&amp;arr[i]</code> 获取的是元素的地址，对于切片中的元素，这实际上是底层数组中相应元素的地址。</p> 
</blockquote> 
<h5><a id="__117"></a>🎯 执行增加操作</h5> 
<pre><code class="prism language-bash">Element: <span class="token number">1</span>, Address: 0x14000016180
Element: <span class="token number">2</span>, Address: 0x14000016188
Element: <span class="token number">3</span>, Address: 0x14000016190
Element: <span class="token number">4</span>, Address: 0x14000016198
Element: <span class="token number">5</span>, Address: 0x140000161a0
temp: <span class="token number">10</span>, Address: 0x1400000e0a0
temp: <span class="token number">11</span>, Address: 0x1400000e0a8
-----
Element: <span class="token number">1</span>, Address: 0x1400001c140
Element: <span class="token number">2</span>, Address: 0x1400001c148
Element: <span class="token number">3</span>, Address: 0x1400001c150
Element: <span class="token number">4</span>, Address: 0x1400001c158
Element: <span class="token number">5</span>, Address: 0x1400001c160
Element: <span class="token number">6</span>, Address: 0x1400001c168
temp: <span class="token number">10</span>, Address: 0x1400000e0a0
temp: <span class="token number">11</span>, Address: 0x1400000e0a8
</code></pre> 
<p>如上输出结果所示，增加元素时数组的地址全部发生了变化。</p> 
<p>在Go语言中，当你对切片（slice）执行<code>append</code>操作时，如果切片的容量（cap）不足以容纳新的元素，Go会执行以下步骤：</p> 
<ol><li> <p><strong>检查容量</strong>: 首先，Go检查切片的当前容量是否足够容纳新元素。如果足够，切片会在原地扩展，也就是直接在现有底层数组的末尾添加新元素，此时原有元素的地址不会改变。</p> </li><li> <p><strong>容量不足时的处理</strong>: 如果当前切片的容量不足以容纳新元素，Go会创建一个新的、容量更大的底层数组。然后，它会将原切片中的所有元素复制到新数组中，再在新数组的末尾追加新元素。这意味着所有元素都会被移动到新的内存位置，因此它们的地址会改变。</p> </li></ol> 
<p>在代码示例中，由于初始时没有明确指定切片的容量，切片会有一个默认的容量。当你调用<code>append</code>添加第六个元素时，如果这个操作导致需要更多空间超出了切片的当前容量，Go就会执行上述的第二步，即创建新的底层数组并复制元素。因此，追加元素后你会观察到<mark>每个元素的地址都发生了变化</mark>，<mark>因为它们都被移到了新的内存位置上</mark>。</p> 
<p>总结来说，切片追加元素后地址变化的原因在于添加操作导致了底层数组的重新分配，从而引发了元素地址的更新。</p> 
<h5><a id="__149"></a>🎯 执行删除操作</h5> 
<pre><code class="prism language-bash">Element: <span class="token number">1</span>, Address: 0x140000b6030
Element: <span class="token number">2</span>, Address: 0x140000b6038
Element: <span class="token number">3</span>, Address: 0x140000b6040
Element: <span class="token number">4</span>, Address: 0x140000b6048
Element: <span class="token number">5</span>, Address: 0x140000b6050
temp: <span class="token number">10</span>, Address: 0x140000a4020
temp: <span class="token number">11</span>, Address: 0x140000a4028
-----
Element: <span class="token number">1</span>, Address: 0x140000b6030
Element: <span class="token number">2</span>, Address: 0x140000b6038
Element: <span class="token number">3</span>, Address: 0x140000b6040
Element: <span class="token number">5</span>, Address: 0x140000b6048
temp: <span class="token number">10</span>, Address: 0x140000a4020
temp: <span class="token number">11</span>, Address: 0x140000a4028
</code></pre> 
<p>如上输出结果所示，当删除数组一个元素时（此时删除了索引为3的元素），后续数组的所有元素都向前移动。</p> 
<p>当执行 <code>arr = append(arr[:3], arr[4:]...)</code> 这行代码时，Go的切片操作实际上做了以下几步：</p> 
<ol><li><strong>切片操作</strong>：首先，它创建了两个新的切片，一个包含从开始到索引3（不包括3）的元素，另一个包含从索引4开始到最后的元素。</li><li><strong>合并与重新分配</strong>：然后，使用 <code>append</code> 函数将这两个切片的内容合并。由于原切片的连续性被打破（需要“跳过”索引3的元素），<code>append</code> 可能会检查当前切片的容量是否足够存放新数据。如果不够，它可能会分配一个新的足够大的底层数组来存储合并后的结果；如果当前切片的剩余容量足够，则直接在原有底层数组的基础上进行操作。</li></ol> 
<p>删除元素并重新分配内存后，<code>arr</code> 中剩余元素的地址发生了改变，因为它们现在位于一个全新的、连续的内存区域。当打印出每个元素的地址时，你会发现从原来索引3之后的所有元素的地址相比之前都“向前移动”了，这是因为它们现在位于一个起始位置更早的连续块中。</p> 
<p>而对于 <code>temp</code> 切片，因为它没有进行任何删除或添加操作，所以其元素的地址保持不变。每次打印 <code>temp</code> 的元素地址时，你会看到相同的地址输出，因为这部分内存没有被重新分配。</p> 
<p>总之，删除切片中的元素并导致元素地址“向前移动”的根本原因，在于<code>append</code>操作可能触发的底层数组的重新分配和数据复制到新位置的过程，以维持切片元素的连续性。</p> 
<h4><a id="___181"></a>📊 优缺点分析</h4> 
<ul><li> <p><strong>优点</strong>:</p> 
  <ul><li><strong>随机访问</strong>: 直接通过索引访问，时间复杂度为O(1)。</li><li><strong>简单易用</strong>: 大多数编程语言内置支持，易于理解和实现。</li></ul> </li><li> <p><strong>缺点</strong>:</p> 
  <ul><li><strong>插入与删除</strong>: 在数组中插入或删除元素需要移动元素，最坏情况下时间复杂度为O(n)。</li><li><strong>固定大小限制</strong>: 传统数组大小固定，动态数组虽然可以自动扩容，但在扩容时可能会导致性能开销。</li></ul> </li></ul> 
<hr> 
<h3><a id="_Linked_List_193"></a>🔗 链表（Linked List）</h3> 
<h4><a id="__195"></a>📖 什么是链表</h4> 
<p><strong>链表</strong>也是一种<mark>线性数据结构</mark>，但与数组不同，链表中的元素在内存中并不是顺序存放的，而是通过存在元素中的指针链接起来。每个链表节点包含两个部分：<mark>数据域</mark>和<mark>指针域</mark>。</p> 
<p><strong>链表</strong>访问某个元素需要从头节点开始，沿着指针一步步遍历，最坏情况下时间复杂度为O(n)，意味着<mark>数据越大，查找越慢</mark>。但是在插入和删除操作上链表表现出色，特别是在链表的头部或尾部进行时，只需调整相邻节点的指针即可，时间复杂度为O(1)，即使在中间操作，也仅需改动少量指针，避免了大量数据移动。</p> 
<h4><a id="__202"></a>🌀 链表的存储</h4> 
<p>链表中的元素可存储在内存的任何地方，因为链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。</p> 
<p><img src="https://images2.imgbox.com/29/97/mk5Bwizi_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>这犹如寻宝游戏。你前往第一个地址，那里有一张纸条写着“下一个元素的地址为 123”。因此，你前往地址 123，那里又有一张纸条，写着“下一个元素的地址为 847”，以此类推。在链表中添加元素很容易：只需将其放入内存，并将其地址存储到前一个元素中。</p> 
</blockquote> 
<p>因此使用链表时，根本就不需要移动元素，只要有足够的内存空间，就能为链表分配内存。</p> 
<h4><a id="_go_209"></a>📝 示例代码（go语言）</h4> 
<pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
<span class="token punctuation">)</span>

<span class="token comment">// ListNode 定义链表节点</span>
<span class="token keyword">type</span> ListNode <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	Value <span class="token builtin">int</span>
	Next  <span class="token operator">*</span>ListNode
<span class="token punctuation">}</span>

<span class="token comment">// LinkedList 定义链表结构</span>
<span class="token keyword">type</span> LinkedList <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	Head <span class="token operator">*</span>ListNode
<span class="token punctuation">}</span>

<span class="token comment">// NewListNode 创建新节点</span>
<span class="token keyword">func</span> <span class="token function">NewListNode</span><span class="token punctuation">(</span>value <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>ListNode <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>ListNode<span class="token punctuation">{<!-- --></span>Value<span class="token punctuation">:</span> value<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// Append 向链表末尾追加节点</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>list <span class="token operator">*</span>LinkedList<span class="token punctuation">)</span> <span class="token function">Append</span><span class="token punctuation">(</span>value <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	newNode <span class="token operator">:=</span> <span class="token function">NewListNode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
	<span class="token keyword">if</span> list<span class="token punctuation">.</span>Head <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		list<span class="token punctuation">.</span>Head <span class="token operator">=</span> newNode
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
		current <span class="token operator">:=</span> list<span class="token punctuation">.</span>Head
		<span class="token keyword">for</span> current<span class="token punctuation">.</span>Next <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
			current <span class="token operator">=</span> current<span class="token punctuation">.</span>Next
		<span class="token punctuation">}</span>
		current<span class="token punctuation">.</span>Next <span class="token operator">=</span> newNode
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// Delete 删除链表中第一个匹配值的节点</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>list <span class="token operator">*</span>LinkedList<span class="token punctuation">)</span> <span class="token function">Delete</span><span class="token punctuation">(</span>value <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> list<span class="token punctuation">.</span>Head <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> list<span class="token punctuation">.</span>Head<span class="token punctuation">.</span>Value <span class="token operator">==</span> value <span class="token punctuation">{<!-- --></span>
		list<span class="token punctuation">.</span>Head <span class="token operator">=</span> list<span class="token punctuation">.</span>Head<span class="token punctuation">.</span>Next
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	current <span class="token operator">:=</span> list<span class="token punctuation">.</span>Head
	<span class="token keyword">for</span> current<span class="token punctuation">.</span>Next <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> current<span class="token punctuation">.</span>Next<span class="token punctuation">.</span>Value <span class="token operator">!=</span> value <span class="token punctuation">{<!-- --></span>
		current <span class="token operator">=</span> current<span class="token punctuation">.</span>Next
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> current<span class="token punctuation">.</span>Next <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		current<span class="token punctuation">.</span>Next <span class="token operator">=</span> current<span class="token punctuation">.</span>Next<span class="token punctuation">.</span>Next
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// PrintListWithAddresses 打印链表节点值和地址</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>list <span class="token operator">*</span>LinkedList<span class="token punctuation">)</span> <span class="token function">PrintListWithAddresses</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	current <span class="token operator">:=</span> list<span class="token punctuation">.</span>Head
	<span class="token keyword">for</span> current <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Value: %d, Address: %p -&gt; "</span><span class="token punctuation">,</span> current<span class="token punctuation">.</span>Value<span class="token punctuation">,</span> current<span class="token punctuation">)</span>
		current <span class="token operator">=</span> current<span class="token punctuation">.</span>Next
	<span class="token punctuation">}</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"nil"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 创建链表实例</span>
	linkedList <span class="token operator">:=</span> <span class="token operator">&amp;</span>LinkedList<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	<span class="token comment">// 增加节点</span>
	linkedList<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	linkedList<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
	linkedList<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"增加前："</span><span class="token punctuation">)</span>
	linkedList<span class="token punctuation">.</span><span class="token function">PrintListWithAddresses</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// 删除索引为1的元素（值为2）</span>
	linkedList<span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"删除后："</span><span class="token punctuation">)</span>
	linkedList<span class="token punctuation">.</span><span class="token function">PrintListWithAddresses</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// 再次增加节点</span>
	linkedList<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"增加后："</span><span class="token punctuation">)</span>
	linkedList<span class="token punctuation">.</span><span class="token function">PrintListWithAddresses</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-bash">增加前：
Value: <span class="token number">1</span>, Address: 0x1400010a240 -<span class="token operator">&gt;</span> Value: <span class="token number">2</span>, Address: 0x1400010a250 -<span class="token operator">&gt;</span> Value: <span class="token number">3</span>, Address: 0x1400010a260 -<span class="token operator">&gt;</span> nil
删除后：
Value: <span class="token number">1</span>, Address: 0x1400010a240 -<span class="token operator">&gt;</span> Value: <span class="token number">3</span>, Address: 0x1400010a260 -<span class="token operator">&gt;</span> nil
增加后：
Value: <span class="token number">1</span>, Address: 0x1400010a240 -<span class="token operator">&gt;</span> Value: <span class="token number">3</span>, Address: 0x1400010a260 -<span class="token operator">&gt;</span> Value: <span class="token number">4</span>, Address: 0x1400010a270 -<span class="token operator">&gt;</span> nil
</code></pre> 
<p>这是一个简单的Go语言示例，模拟演示了链表的创建、增加节点、删除节点以及输出节点值和地址的操作。从上述输出结果可以看见，不管是增加还是删除，改变的只有元素的指向，并没有修改其内存地址，删除也没有移动其他元素的内存地址。</p> 
<h4><a id="___309"></a>📊 优缺点分析</h4> 
<ul><li> <p><strong>优点</strong>:</p> 
  <ul><li><strong>动态大小</strong>: 链表的长度可以在运行时动态改变，无需担心预先分配内存的问题。</li><li><strong>高效插入删除</strong>: 在链表中插入或删除元素只需要修改相邻节点的指针，时间复杂度为O(1)（在有指针的情况下）。</li></ul> </li><li> <p><strong>缺点</strong>:</p> 
  <ul><li><strong>访问速度</strong>: 不能直接通过索引访问，需要从头节点开始遍历，时间复杂度为O(n)。</li><li><strong>额外空间开销</strong>: 每个节点除了存储数据，还需要存储指向下一个节点的指针。</li></ul> </li></ul> 
<hr> 
<h3><a id="__323"></a>📊 数组与链表的对比</h3> 
<p><img src="https://images2.imgbox.com/cc/74/k6rZEIYu_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="__328"></a>🎯 访问速度</h4> 
<ul><li><strong>数组</strong>: 🏆 胜出在于其提供了常数时间O(1)的访问速度。由于元素在内存中连续存储，给定索引后，计算元素地址简单直接，瞬间定位。</li><li><strong>链表</strong>: 访问某个元素需要从头节点开始，沿着指针一步步遍历，最坏情况下时间复杂度为O(n)，意味着数据越大，查找越慢。</li></ul> 
<h4><a id="__332"></a>🎯 插入与删除效率</h4> 
<ul><li><strong>链表</strong>: 🏆 在插入和删除操作上表现出色，特别是在链表的头部或尾部进行时，只需调整相邻节点的指针即可，时间复杂度为O(1)。即使在中间操作，也仅需改动少量指针，避免了大量数据移动。</li><li><strong>数组</strong>: 对于插入和删除，特别是当位置不在末尾时，可能需要移动后续的所有元素，以保持连续性，导致最坏情况下的时间复杂度为O(n)。</li></ul> 
<h4><a id="__336"></a>🎯 空间利用效率</h4> 
<ul><li><strong>数组</strong>: 可能导致内存浪费。预先分配固定大小的内存空间，如果未填满，则有未使用的空间。不过，对于确切知道大小的数据集，这不构成太大问题。</li><li><strong>链表</strong>: 每个节点除了存储数据外，还需要额外的内存来存储指向下一个节点的指针，这构成了空间上的开销。然而，链表能够根据需要动态调整大小，避免了预分配过大内存的问题。</li></ul> 
<h4><a id="__340"></a>🎯 应用场景</h4> 
<ul><li><strong>数组</strong>: 非常适合于需要快速随机访问数据的场景，例如图像处理、音频数据、大规模科学计算等，其中数据一旦加载，就频繁查询而很少修改。</li><li><strong>链表</strong>: 在频繁进行插入和删除操作的场景中大放异彩，如实现动态数据结构（如队列、栈）、构建更复杂的数据结构（如哈希表的链地址法解决冲突、图的邻接表表示）或者处理不确定长度的数据流。</li></ul> 
<hr> 
<h3><a id="__347"></a>📚 小结</h3> 
<blockquote> 
 <p>数组与链表各有千秋，选择合适的工具对于提高程序性能至关重要。理解它们的底层原理，能帮助我们在面对具体问题时做出明智的选择。希望这篇学习笔记能加深你对这两种基础数据结构的理解，为你的编程之旅增添一份助力！✨</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bf3cf3a625832d68545e8c02faa87cfd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于大数据&#43;Hadoop的豆瓣电子图书推荐系统设计和实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/63c629158baeaaa3dfb0c6aef5f32be5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【MsSQL】数据库基础 &amp; 库的基本操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>