<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java---类和对象第一节 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/6b262059a9f5f261dcc3a5543f8e184d/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Java---类和对象第一节">
  <meta property="og:description" content="目录
1.面向对象初步认识
1.1什么是面向对象
1.2面向对象和面向过程的区别
2.类的定义和使用
2.1简单认识类
2.2类的定义格式
2.3类的实例化
2.4类和对象的说明
3.this关键字
3.1访问本类成员变量
3.2调用构造方法初始化成员变量
3.3this引用的特性
4.对象的构造以及初始化
4.1就地初始化与默认初始化
4.2构造方法
4.2.1默认构造方法
4.2.2构造方法的特性：
4.2.3构造方法中，通过this调用其他构造方法
1.面向对象初步认识 1.1什么是面向对象 Java是一门纯面向对象的语言(Object Oriented Program，简称OOP)，在面向对象的世界里，一切皆为对象。面向对象是解决问题的一种思想，主要依靠对象之间的交互完成一件事情。用面向对象的思想来涉及程序，更符合人们对事物的认知，对于大型程序的设计、扩展以及维护都非常友好。
1.2面向对象和面向过程的区别 传统洗衣服：
传统洗衣服注重的是面向过程，也就是按照步骤一步一步实现，少一个步骤都不行
每一种衣服鞋子清洗的方式都不同，处理起来就比较麻烦
如果我们按这种方式去写代码，后期对代码的扩展和维护就比较麻烦
现代洗衣服：
现代洗衣服方式中总共有4个对象：人，衣服，洗衣液，洗衣机
洗衣服的过程：人将衣服和洗衣液放进洗衣机，启动洗衣机
在整个洗衣服的过程中，人，衣服，洗衣液，洗衣机这4个对象交互完成了洗衣服这件事，而人并不需要关系衣服是怎么被搓干净和拧干净的
以面向对象方式来进行处理，就不关注洗衣服的过程，具体洗衣机是怎么来洗衣服，如何来甩干的，用户不用去关心，只需要将衣服放进洗衣机，倒入洗衣粉，启动开关即可，通过对象之间的交互来完成的。
注意：面向过程和面相对象并不是一门语言，而是解决问题的方法，没有那个好坏之分，都有其专门的应用场景。
2.类的定义和使用 2.1简单认识类 类是对一个实物（对象）的属性以及功能进行描述的
对比于现实生活中产品的说明书
在这个说明书里有产品的属性：产品名称，产品部件，型号等等
产品的功能：使用方法，安装，拆卸，清洁
2.2类的定义格式 java中定义一个类需要用到class关键字
class ClassName{ //ClassName为类名 ﬁeld; // 字段(属性) 或者 成员变量 method; // 行为 或者 成员方法 } 类中包含的内容称为类的成员。属性主要是用来描述类的，称之为类的成员属性或者类成员变量。方法主要说明类 具有哪些功能，称为类的成员方法。
定义一个洗衣机的类
class Washer{ public String name; //名称 public int size; //大小 public String model; //型号 public String color; //颜色 public void function1(){ //洗衣功能 System.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-14T16:29:03+08:00">
    <meta property="article:modified_time" content="2024-05-14T16:29:03+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java---类和对象第一节</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="1.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86-toc" style="margin-left:0px;"><a href="#1.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86" rel="nofollow">1.面向对象初步认识</a></p> 
<p id="1.1%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#1.1%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1" rel="nofollow">1.1什么是面向对象</a></p> 
<p id="1.2%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#1.2%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">1.2面向对象和面向过程的区别</a></p> 
<p id="2.%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#2.%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8" rel="nofollow">2.类的定义和使用</a></p> 
<p id="2.1%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86%E7%B1%BB-toc" style="margin-left:40px;"><a href="#2.1%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86%E7%B1%BB" rel="nofollow">2.1简单认识类</a></p> 
<p id="2.2%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F-toc" style="margin-left:40px;"><a href="#2.2%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F" rel="nofollow">2.2类的定义格式</a></p> 
<p id="2.3%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#2.3%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96" rel="nofollow">2.3类的实例化</a></p> 
<p id="2.4%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AF%B4%E6%98%8E-toc" style="margin-left:40px;"><a href="#2.4%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AF%B4%E6%98%8E" rel="nofollow">2.4类和对象的说明</a></p> 
<p id="3.this%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:0px;"><a href="#3.this%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">3.this关键字</a></p> 
<p id="3.1%E8%AE%BF%E9%97%AE%E6%9C%AC%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-toc" style="margin-left:40px;"><a href="#3.1%E8%AE%BF%E9%97%AE%E6%9C%AC%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F" rel="nofollow">3.1访问本类成员变量</a></p> 
<p id="3.2%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-toc" style="margin-left:40px;"><a href="#3.2%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F" rel="nofollow">3.2调用构造方法初始化成员变量</a></p> 
<p id="3.3this%E5%BC%95%E7%94%A8%E7%9A%84%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#3.3this%E5%BC%95%E7%94%A8%E7%9A%84%E7%89%B9%E6%80%A7" rel="nofollow">3.3this引用的特性</a></p> 
<p id="4.%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E4%BB%A5%E5%8F%8A%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:0px;"><a href="#4.%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E4%BB%A5%E5%8F%8A%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">4.对象的构造以及初始化</a></p> 
<p id="4.1%E5%B0%B1%E5%9C%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#4.1%E5%B0%B1%E5%9C%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">4.1就地初始化与默认初始化</a></p> 
<p id="4.2%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#4.2%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95" rel="nofollow">4.2构造方法</a></p> 
<p id="4.2.1%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#4.2.1%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95" rel="nofollow">4.2.1默认构造方法</a></p> 
<p id="4.2.2%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%9A-toc" style="margin-left:80px;"><a href="#4.2.2%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%9A" rel="nofollow">4.2.2构造方法的特性：</a></p> 
<p id="4.2.3%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%AD%EF%BC%8C%E9%80%9A%E8%BF%87this%E8%B0%83%E7%94%A8%E5%85%B6%E4%BB%96%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#4.2.3%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%AD%EF%BC%8C%E9%80%9A%E8%BF%87this%E8%B0%83%E7%94%A8%E5%85%B6%E4%BB%96%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95" rel="nofollow">4.2.3构造方法中，通过this调用其他构造方法</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86">1.面向对象初步认识</h2> 
<h3 id="1.1%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">1.1什么是面向对象</h3> 
<blockquote> 
 <p>Java是一门纯面向对象的语言(Object Oriented Program，简称<span style="background-color:#c7e6ea;">OOP</span>)，在面向对象的世界里，<span style="background-color:#79c6cd;">一切皆为对象</span>。面向对象是解决问题的一种思想，主要依靠对象之间的交互完成一件事情。用面向对象的思想来涉及程序，更符合人们对事物的认知，对于大型程序的设计、扩展以及维护都非常友好。</p> 
</blockquote> 
<h3></h3> 
<h3 id="1.2%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB">1.2面向对象和面向过程的区别</h3> 
<p>传统洗衣服：</p> 
<p><img alt="" height="198" src="https://images2.imgbox.com/a2/38/23iy4Vvg_o.png" width="303"><img alt="" height="217" src="https://images2.imgbox.com/80/7d/YcvqaBVk_o.png" width="369"></p> 
<p>传统洗衣服注重的是面向过程，也就是按照步骤一步一步实现，少一个步骤都不行</p> 
<p>每一种衣服鞋子清洗的方式都不同，处理起来就比较麻烦</p> 
<p>如果我们按这种方式去写代码，后期对代码的扩展和维护就比较麻烦</p> 
<p></p> 
<p>现代洗衣服：</p> 
<p><img alt="" height="214" src="https://images2.imgbox.com/cf/98/39wFOe3C_o.png" width="322"><img alt="" height="211" src="https://images2.imgbox.com/bf/9d/e4VoIaTg_o.png" width="360"></p> 
<p>现代洗衣服方式中总共有<span style="color:#ffd900;">4个对象</span>：<span style="background-color:#6eaad7;">人，衣服，洗衣液，洗衣机</span></p> 
<p>洗衣服的过程：人将衣服和洗衣液放进洗衣机，启动洗衣机</p> 
<p>在整个洗衣服的过程中，人，衣服，洗衣液，洗衣机这4个对象交互完成了洗衣服这件事，而人并不需要关系衣服是怎么被搓干净和拧干净的</p> 
<p></p> 
<p>以面向对象方式来进行处理，就不关注洗衣服的过程，具体洗衣机是怎么来洗衣服，如何来甩干的，用户不用去关心，只需要将衣服放进洗衣机，倒入洗衣粉，启动开关即可，通过对象之间的交互来完成的。</p> 
<p><span style="color:#fe2c24;">注意：</span>面向过程和面相对象并不是一门语言，而是解决问题的方法，没有那个好坏之分，都有其专门的应用场景。</p> 
<p></p> 
<h2 id="2.%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8">2.类的定义和使用</h2> 
<h3 id="2.1%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86%E7%B1%BB">2.1简单认识类</h3> 
<p>类是对一个实物（对象）的属性以及功能进行描述的</p> 
<p>对比于现实生活中产品的说明书</p> 
<p><img alt="" height="531" src="https://images2.imgbox.com/3b/3c/5fhCwI5t_o.png" width="641"></p> 
<p>在这个说明书里有产品的属性：产品名称，产品部件，型号等等</p> 
<p>产品的功能：使用方法，安装，拆卸，清洁</p> 
<p></p> 
<h3 id="2.2%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F">2.2类的定义格式</h3> 
<p>java中定义一个类需要用到class关键字</p> 
<pre><code>class ClassName{  //ClassName为类名
    ﬁeld;       // 字段(属性) 或者 成员变量
    method;      // 行为 或者 成员方法
}</code></pre> 
<p>类中包含的内容称为类的成员。属性主要是用来描述类的，称之为类的成员属性或者类成员变量。方法主要说明类 具有哪些功能，称为类的成员方法。</p> 
<p></p> 
<p>定义一个洗衣机的类</p> 
<pre><code>class Washer{
    public String name;  //名称
    public int size;     //大小
    public String model; //型号
    public String color; //颜色

public void function1(){     //洗衣功能
    System.out.println("洗衣功能");
}

public void function2(){     //脱水功能
    System.out.println("脱水功能");
}
}</code></pre> 
<p>在行业里，类名一般采用大驼峰的命名规则</p> 
<p></p> 
<h3 id="2.3%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96">2.3类的实例化</h3> 
<p>类相当于一份说明书，我们要完成某件事就需要一个这个类描述的实物来帮我们进行完成</p> 
<p>当我们了解了这个类的功能和用途，我们就需要“买”这个类对应的产品，而“买”这个类对应的产品就叫类的实例化</p> 
<p>用类类型创建对象的过程，称为类的实例化，在java中采用<span style="background-color:#98c091;">new</span>关键字，配合类名来实例化对象。</p> 
<p>举例：</p> 
<p>创建一个洗衣机类的对象</p> 
<pre><code>类名 对象名=new 类名（）;
Washer washer=new Washer();
</code></pre> 
<p>这样实例化一个对象，washer就相当于我们买回来的那个产品了</p> 
<p><span style="background-color:#ffd900;">注意事项：</span></p> 
<p>1.new 关键字用于创建一个对象的实例.</p> 
<p>2.使用 . 来访问对象中的属性和方法.</p> 
<p>3.同一个类可以创建对个实例</p> 
<p></p> 
<h3 id="2.4%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AF%B4%E6%98%8E">2.4类和对象的说明</h3> 
<p>1. 类只是一个模型一样的东西，用来对一个实体进行描述，限定了类有哪些成员.</p> 
<p>2. 类是一种自定义的类型，可以用来定义变量.</p> 
<p>3. 一个类可以实例化出多个对象，实例化出的对象 占用实际的物理空间，存储类成员变量</p> 
<p>4. 做个比方，类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图，只设计出需要什么东 西，但是并没有实体的建筑存在，同样类也只是一个设计，实例化出的对象才能实际存储数据，占用物理空间</p> 
<p>对比一下：</p> 
<p><img alt="" height="197" src="https://images2.imgbox.com/30/be/Hy5bibVH_o.png" width="338"><img alt="" height="202" src="https://images2.imgbox.com/ac/7d/mUYSBAjZ_o.png" width="285"></p> 
<p></p> 
<p></p> 
<h2 id="3.this%E5%85%B3%E9%94%AE%E5%AD%97">3.this关键字</h2> 
<h3 id="3.1%E8%AE%BF%E9%97%AE%E6%9C%AC%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">3.1访问本类成员变量</h3> 
<pre><code>class Student{
    private String name;
    private int age;
    private String id;
    public Student(String name,int age,String id){
        name=name;
        age=age;
        id=id;
    }
    public void show(){
        System.out.println("我是"+name+",今年"+age+"岁了,我的id是"+id);
    }
}

public class Test1 {
    public static void main(String[] args) {
        Student student=new Student("小明",18,"2024511");
        student.show();
    }
}</code></pre> 
<p>先来看看这段代码它的输出结果</p> 
<p>我相信你的第一反应应该是：我是小明，今年18岁了，我的id是2024511；</p> 
<p>但<span style="background-color:#ffd900;">输出结果</span>是我是null，今年0岁了，我的id是null;</p> 
<p><span style="background-color:#e6b223;">解释:</span></p> 
<p>在这下面这段代码中</p> 
<pre><code>  public Student(String name,int age,String id){
        name=name;
        age=age;
        id=id;
    }</code></pre> 
<p>我们认为左边的name，age，id是成员变量，但实际上在这段代码中左边的name，age，id是局部变量，此时局部变量给局部变赋值，没有给成员变量赋值，成员变量的值没有改变，依然是默认值</p> 
<p>然而当构造方法中的形参名和成员变量名不相同时，就不会出现以上情况</p> 
<pre><code>class Student{
    private String name;
    private int age;
    private String id;
    public Student(String n,int a,String i){
        name=n;
        age=a;
        id=i;
    }
    public void show(){
        System.out.println("我是"+name+",今年"+age+"岁了,我的id是"+id);
    }
}

public class Test1 {
    public static void main(String[] args) {
        Student student=new Student("小明",18,"2024511");
        student.show();
    }</code></pre> 
<p>输出结果是：我是小明,今年18岁了,我的id是2024511</p> 
<p>想要解决形参名与成员变量名相同时给成员变量赋值的问题就需要使用this关键字，this关键字表示本类中的成员变量和成员方法</p> 
<pre><code>  public Student(String name,int age,String id){
        this.name=name;
        this.age=age;
        this.id=id;
    }</code></pre> 
<p>加上this就表示本类中的成员变量</p> 
<p>在成员变量和局部变量重名时，优先使用局部变量，也就是就近原则。</p> 
<p></p> 
<h3 id="3.2%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">3.2调用构造方法初始化成员变量</h3> 
<pre><code>class Student{
    private String name;
    private int age;
    private String id;
    public Student(){
        this("haha",12,"202451101");
    }
    public Student(String name,int age,String id){
      this.name=name;
      this.age=age;
      this.id=id;
    }
    public void show(){
        System.out.println("我是"+name+",今年"+age+"岁了,我的id是"+id);
    }
}</code></pre> 
<p>在不带参数的构造方法中初始化成员变量，用this调用带三个参数的构造方法，直接在this后面的括号中填写对应的参数就行</p> 
<p>在构造方法中使用this调用其他构造方法对成员变量进行初始化时<span style="background-color:#79c6cd;">this语句必须放在该构造方法的第一行</span></p> 
<p></p> 
<h3 id="3.3this%E5%BC%95%E7%94%A8%E7%9A%84%E7%89%B9%E6%80%A7">3.3this引用的特性</h3> 
<blockquote> 
 <p>1. this的类型：对应类类型引用，即哪个对象调用就是哪个对象的引用类型</p> 
 <p>2. this只能在"成员方法"中使用</p> 
 <p>3. 在"成员方法"中，this只能引用当前对象，不能再引用其他对象</p> 
 <p>4. this是“成员方法”第一个隐藏的参数，编译器会自动传递，在成员方法执行时，编译器会负责将调用成员方法 对象的引用传递给该成员方法，this负责来接收 在代码层面来简单演示---&gt;注意：下图右侧中的Date类也是可以通过编译的</p> 
</blockquote> 
<p><img alt="" height="623" src="https://images2.imgbox.com/2f/c1/yPNttApZ_o.png" width="1200"></p> 
<p></p> 
<h2 id="4.%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E4%BB%A5%E5%8F%8A%E5%88%9D%E5%A7%8B%E5%8C%96">4.对象的构造以及初始化</h2> 
<h3 id="4.1%E5%B0%B1%E5%9C%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96">4.1就地初始化与默认初始化</h3> 
<p>在Java方法内部定义一个局部变量时，必须要初始化，否则会编译失败。</p> 
<pre><code>   public static void main(String[] args) {
        int a;
        System.out.println(a);
    }
//运行结果：java: 可能尚未初始化变量a</code></pre> 
<p>所以在创建局部变量时需要在使用变量之前对变量进行初始化</p> 
<p>但是在创建类时，对类进行实例化后调用成员变量时我们会发现，编译器没有报错，这是为什么呢？</p> 
<pre><code>class Date{
    private int year;
    private int month;
    private int day;
private String zodiac;
    public void setDate(int y, int m, int d) {
        year = y;
        month = m;
        day = d;
    }
    public void show(){
        System.out.println("year:"+year+" month:"+month+" day: "+day+" zodiac"+zodiac);
    }
}

public class Test01 {
    public static void main(String[] args) {
        Date date=new Date();
        date.show();
    }
}</code></pre> 
<p>这是因为我们在实例化对象时，编译器默认的给我成员变量赋值了</p> 
<p><img alt="" height="661" src="https://images2.imgbox.com/32/8a/gFMuYcyO_o.png" width="605"></p> 
<p>当然我们不需要默认初始化的值可以就地初始化，也就是创建类的时候就给成员变量赋值</p> 
<pre><code>class Date{
    private int year=2024;
    private int month=5;
    private int day=12;
}</code></pre> 
<p></p> 
<h3 id="4.2%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">4.2构造方法</h3> 
<p>构造方法(也称为构造器)是一个特殊的成员方法，名字必须与类名相同，在创建对象时，由编译器自动调用，并且在整个对象的生命周期内只调用一次。</p> 
<h4 id="4.2.1%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">4.2.1默认构造方法</h4> 
<pre><code>class Date{
    private int year=2024;
    private int month=5;
    private int day=12;
    
    // 构造方法：
    // 名字与类名相同，没有返回值类型，设置为void也不行
    // 一般情况下使用public修饰
    // 在创建对象时由编译器自动调用，并且在对象的生命周期内只调用一次
    public Date(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }

    public void show(){
        System.out.println("year:"+year+" month:"+month+" day: "+day);
    }
}</code></pre> 
<p>当我们实例化对象时下面这样写会报错</p> 
<p><img alt="" height="133" src="https://images2.imgbox.com/ee/2d/YLHIJxQr_o.png" width="669"></p> 
<p>这是为什么呢，我们没写构造方法前是对的，反而写了就错了。难道我们写的代码有问题？</p> 
<p>这是因为编译器有一个就穷不救急的性格，当我们没有构造方法时，他会提供一个默认的构造方法，当我们写了构造方法，他就不提供默认的构造方法了，如果想使用默认的构造方法就必须自己在类里面写一个</p> 
<pre><code>  public Date(){
        
    }</code></pre> 
<p>添加一个这样的类就行了，方法体什么都不写</p> 
<p></p> 
<h4 id="4.2.2%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%9A">4.2.2构造方法的特性：</h4> 
<blockquote> 
 <p>1. 名字必须与类名相同</p> 
 <p>2. 没有返回值类型，设置为void也不行</p> 
 <p>3. 创建对象时由编译器自动调用，并且在对象的生命周期内只调用一次(相当于人的出生，每个人只能出生一次)</p> 
 <p>4. 构造方法可以重载(用户根据自己的需求提供不同参数的构造方法)</p> 
 <pre><code>    public Date(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }

    public Date(int year, int month) {
        this.year = year;
        this.month = month;
    }</code></pre> 
 <p>上述两个构造方法：名字相同，参数列表不同，因此构成了方法重载。</p> 
</blockquote> 
<p></p> 
<h4 id="4.2.3%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%AD%EF%BC%8C%E9%80%9A%E8%BF%87this%E8%B0%83%E7%94%A8%E5%85%B6%E4%BB%96%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">4.2.3构造方法中，通过<span style="background-color:#a2e043;">this</span>调用其他构造方法</h4> 
<p>在构造方法中，可以通过this调用其他构造方法来简化代码</p> 
<pre><code>    public Date(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }

    public Date(int year, int month) {
        this.year = year;
        this.month = month;
    }
    
    public Date(){
this(1900,2,12);
    }</code></pre> 
<p>在构造方法中使用this调用其他构造方法时，要注意在这个构造方法中方法的重载问题</p> 
<pre><code>public Date(){
        
}
    public Date(){
this(1900,2,12);
    }</code></pre> 
<p>比如这样，我们写的默认构造方法和this的构造方法形参一样，编译器就会报错</p> 
<p><span style="color:#fe2c24;"><strong>注意：</strong></span></p> 
<p><strong>1.this在构造方法中必须是第一条语句</strong></p> 
<p><strong>2.this调用其他构造方法时不能成环</strong></p> 
<pre><code>public Date(){
   this(1900,1,1);
}
 
public Date(int year, int month, int day) {
   this();
}</code></pre> 
<blockquote> 
 <p>无参构造器调用三个参数的构造器，而三个参数构造器有调用无参的构造器，形成构造器的递归调用<br> 编译报错：Error:(19, 12) java: 递归构造器调用</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d4df57e88d3d0eb6a48a95cfe03da909/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【学一点儿前端】vue3&#43;vite不能使用require引入包的问题（require is not defined）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6564d03ec7414f2f1bebd27a00215a44/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android studio Gradle下载失败，如何手动配置解决该问题详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>