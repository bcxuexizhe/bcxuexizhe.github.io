<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>头歌 算法 实验七 动态规划 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/124489eab87437f3a4a41ceac8f9b389/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="头歌 算法 实验七 动态规划">
  <meta property="og:description" content="第1关：数塔问题 300
任务要求参考答案评论9 任务描述相关知识编程要求解题思路：测试说明 任务描述 本关任务：编写用动态规划解决数塔问题。
相关知识 为了完成本关任务，你需要掌握：动态规划。
编程要求 求上图从顶层到顶层的一个路径，使路径上的数字和最大。要求输出最大的数字和max和数值和最大的路径。
解题思路： 原始信息有层数和数塔中的数据，层数用一个整型变量n存储，数塔中的数据用二维数组data，存储成如下的下三角阵:
912 1510 6 82 18 9 519 7 10 4 16 必需用二维数组d存储各阶段的决策结果。二维数组d的存储内容如下：
d[n][j]=data[n][j]， j=1,2,……,n；d[i][j]=max(d[i&#43;1][j]，d[i&#43;1][j&#43;1])&#43;data[i][j]， i=n-1,n-2,……1，j=1,2,……,i 最后d[1][1]存储的就是问题的结果。
测试说明 平台会对你编写的代码进行测试：
测试输入：
5912 1510 6 82 18 9 519 7 10 4 16 输出示例：
max=59数值和最大的路径是：9-&gt;12-&gt;10-&gt;18-&gt;10 开始你的任务吧，祝你成功！
#include &lt;stdio.h&gt; int main(){ int a[50][50][4],i,j,n; // printf(&#34;Please input the number of rows:\n&#34;); // scanf(&#34;%d&#34;,&amp;n); n = 5; i=1; a[1][1][1]=9; a[2][1][1]=12, a[2][2][1]=15; a[3][1][1]=10, a[3][2][1]=6, a[3][3][1]=8; a[4][1][1]=2, a[4][2][1]=18, a[4][3][1]=9, a[4][4][1]=5; a[5][1][1]=19, a[5][2][1]=7, a[5][3][1]=10, a[5][4][1]=4, a[5][5][1]=16; for(i=1;i&lt;=n;i&#43;&#43;) for(j=1; j&lt;=i; j&#43;&#43;) { a[i][j][2]=a[i][j][1]; a[i][j][3]=0; } for(i=n-1; i&gt;=1; i--) for(j=1; j&lt;=i; j&#43;&#43;) if(a[i&#43;1][j][2]&gt;a[i&#43;1][j&#43;1][2]) { a[i][j][2] = a[i][j][2] &#43; a[i&#43;1][j][2]; a[i][j][3] = 0; } else { a[i][j][2] = a[i][j][2] &#43; a[i&#43;1][j&#43;1][2]; a[i][j][3] = 1; } printf(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-22T18:24:20+08:00">
    <meta property="article:modified_time" content="2024-01-22T18:24:20+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">头歌 算法 实验七 动态规划</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>第1关：数塔问题</h4> 
<p>300</p> 
<ul><li id="0">任务要求</li><li id="2">参考答案</li><li id="3">评论9</li></ul> 
<ul><li><a href="https://www.educoder.net/tasks/s9qtgw7h/1101739/epfbsc73kz24#%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0" rel="nofollow" title="任务描述">任务描述</a></li><li><a href="https://www.educoder.net/tasks/s9qtgw7h/1101739/epfbsc73kz24#%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86" rel="nofollow" title="相关知识">相关知识</a></li><li><a href="https://www.educoder.net/tasks/s9qtgw7h/1101739/epfbsc73kz24#%E7%BC%96%E7%A8%8B%E8%A6%81%E6%B1%82" rel="nofollow" title="编程要求">编程要求</a></li><li><a href="https://www.educoder.net/tasks/s9qtgw7h/1101739/epfbsc73kz24#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A" rel="nofollow" title="解题思路：">解题思路：</a></li><li><a href="https://www.educoder.net/tasks/s9qtgw7h/1101739/epfbsc73kz24#%E6%B5%8B%E8%AF%95%E8%AF%B4%E6%98%8E" rel="nofollow" title="测试说明">测试说明</a></li></ul> 
<hr> 
<h4 id="任务描述">任务描述</h4> 
<p>本关任务：编写用动态规划解决数塔问题。</p> 
<h4 id="相关知识">相关知识</h4> 
<p>为了完成本关任务，你需要掌握：动态规划。</p> 
<h4 id="编程要求">编程要求</h4> 
<p></p> 
<p class="img-center"><img alt="," height="144" src="https://images2.imgbox.com/b5/1b/TQhXbEZ6_o.png" width="282"></p> 
<p>求上图从顶层到顶层的一个路径，使路径上的数字和最大。要求输出最大的数字和max和数值和最大的路径。</p> 
<h4 id="解题思路：">解题思路：</h4> 
<p>原始信息有层数和数塔中的数据，层数用一个整型变量n存储，数塔中的数据用二维数组data，存储成如下的下三角阵:</p> 
<pre></pre> 
<ol><li><code>9</code></li><li><code>12 15</code></li><li><code>10 6 8</code></li><li><code>2 18 9 5</code></li><li><code>19 7 10 4 16</code></li></ol> 
<p>必需用二维数组d存储各阶段的决策结果。二维数组d的存储内容如下：</p> 
<pre></pre> 
<ol><li><code>d[n][j]=data[n][j]， j=1,2,……,n；</code></li><li><code>d[i][j]=max(d[i+1][j]，d[i+1][j+1])+data[i][j]， i=n-1,n-2,……1，j=1,2,……,i </code></li></ol> 
<p>最后<code>d[1][1]</code>存储的就是问题的结果。</p> 
<h4 id="测试说明">测试说明</h4> 
<p>平台会对你编写的代码进行测试：</p> 
<p>测试输入：</p> 
<pre></pre> 
<ol><li><code>5</code></li><li><code>9</code></li><li><code>12 15</code></li><li><code>10 6 8</code></li><li><code>2 18 9 5</code></li><li><code>19 7 10 4 16</code></li></ol> 
<p>输出示例：</p> 
<pre></pre> 
<ol><li><code>max=59</code></li><li><code>数值和最大的路径是：9-&gt;12-&gt;10-&gt;18-&gt;10</code></li></ol> 
<hr> 
<p>开始你的任务吧，祝你成功！</p> 
<pre><code>#include &lt;stdio.h&gt;
int main(){
    int a[50][50][4],i,j,n;
    // printf("Please input the number of rows:\n");
    // scanf("%d",&amp;n);
    n = 5;
    i=1;
    a[1][1][1]=9;
    a[2][1][1]=12, a[2][2][1]=15;
    a[3][1][1]=10, a[3][2][1]=6,  a[3][3][1]=8;
    a[4][1][1]=2,  a[4][2][1]=18, a[4][3][1]=9,  a[4][4][1]=5;
    a[5][1][1]=19, a[5][2][1]=7,  a[5][3][1]=10, a[5][4][1]=4, a[5][5][1]=16;
    for(i=1;i&lt;=n;i++)
        for(j=1; j&lt;=i; j++)
        {
            a[i][j][2]=a[i][j][1];
            a[i][j][3]=0;
        }
    for(i=n-1; i&gt;=1; i--)
        for(j=1; j&lt;=i; j++)
            if(a[i+1][j][2]&gt;a[i+1][j+1][2])
            {
                 a[i][j][2] = a[i][j][2] + a[i+1][j][2];
                 a[i][j][3] = 0;
            }
            else
            {
                 a[i][j][2] = a[i][j][2] + a[i+1][j+1][2];
                 a[i][j][3] = 1;
            }
            printf("max=%d\n",a[1][1][2]);
            printf("数值和最大的路径是：");
            j=1;
            for(i=1;i&lt;=n-1;i++)
            {
                printf("%d-&gt;",a[i][j][1]);
                j = j+a[i][j][3];
            }
            printf("%d\n\n\n",a[n][j][1]);
    return 0;
}</code></pre> 
<h4>第2关：最长公共子序列</h4> 
<p>400</p> 
<ul><li>任务要求</li><li>参考答案</li><li>评论9</li></ul> 
<ul><li><a href="https://www.educoder.net/tasks/s9qtgw7h/1101739/ptolqze8ik9j#%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0" rel="nofollow" title="任务描述">任务描述</a></li><li><a href="https://www.educoder.net/tasks/s9qtgw7h/1101739/ptolqze8ik9j#%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86" rel="nofollow" title="相关知识">相关知识</a></li><li><a href="https://www.educoder.net/tasks/s9qtgw7h/1101739/ptolqze8ik9j#%E7%BC%96%E7%A8%8B%E8%A6%81%E6%B1%82" rel="nofollow" title="编程要求">编程要求</a></li><li><a href="https://www.educoder.net/tasks/s9qtgw7h/1101739/ptolqze8ik9j#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A" rel="nofollow" title="解题思路：">解题思路：</a></li><li><a href="https://www.educoder.net/tasks/s9qtgw7h/1101739/ptolqze8ik9j#%E6%B5%8B%E8%AF%95%E8%AF%B4%E6%98%8E" rel="nofollow" title="测试说明">测试说明</a></li></ul> 
<hr> 
<h4>任务描述</h4> 
<p>本关任务：编写用动态规划解决最长公共子序列问题。</p> 
<h4>相关知识</h4> 
<p>为了完成本关任务，你需要掌握：动态规划。</p> 
<h4>编程要求</h4> 
<p>求字符串序列“ABCDBAB”和“BDCABA”的最长公共子序列</p> 
<h4>解题思路：</h4> 
<p>递推关系分析： 设 A=“a0，a1，…，am−1”，B=“b0，b1，…，bn−1”，Z=“z0,z1,…,zk−1” 为它们的最长公共子序列。 有以下结论： 1）如果am−1=bn−1,则zk−1=am−1=bn−1,且“z0,z1,…,zk−2”是“a0,a1,…,am−2”和“b0,b1,…,bn−2”的一个最长公共子序列； 2）如果am−1​=bn−1，则若zk−1​=am−1，蕴涵“z0，z1，…，zk−1”是“a0,a1,…,am−2”和“b0,b1,…,bn−1”的一个最长公共子序列； 3）如果am−1​=bn−1，则若zk−1​=bn−1，蕴涵“z0，z1，…，zk−1”是“a0，a1，…，am−1”和“b0，b1，…，bn−2”的一个最长公共子序列。 定义c[i][j]为序列“a0,a1,…,ai−1”和“b0,b1,…,bj−1”的最长公共子序列的长度，计算c[i][j]可递归地表述如下： 1）c[i][j]=0 如果i=0或j=0； 2）c[i][j]=c[i−1][j−1]+1 如果i,j&gt;0,且a[i−1]=b[j−1]； 3）c[i][j]=max(c[i][j−1],c[i−1][j]) 如果i,j&gt;0,且a[i−1]​=b[j−1]。 由二维数组c的递归定义，c[i][j]的结果依赖于c[i−1][j−1]，c[i−1][j]和c[i][j−1]。可以从c[m][n]开始，跟踪c[i][j]结果的产生过程，从而逆向构造出最长公共子序列。</p> 
<h4>测试说明</h4> 
<p>平台会对你编写的代码进行测试：</p> 
<p>测试输入：</p> 
<pre></pre> 
<ol><li><code>a=“ABCDBAB”</code></li><li><code>b=“BDCABA”</code></li></ol> 
<p>输出示例：</p> 
<pre></pre> 
<ol><li><code>BCBA</code></li></ol> 
<hr> 
<p>开始你的任务吧，祝你成功！</p> 
<pre><code>#include "stdio.h"
#include "string.h"
char a[1000]="ABCDBAB";
char b[1000]="BDCABA";
char str[100];
int c[100][100]; 
int lcs_len()
{   
    int m,n,i,j,lcs;
    m = strlen(a);
    n = strlen(b);
    for(i=0;i&lt;=m;i++) c[i][0]=0;
    for(i=0;i&lt;=n;i++) c[0][i]=0;
    for(i=1;i&lt;=m;i++)
       for(j=1;j&lt;=n;j++)
       {
           if(a[i-1]==b[j-1])
               c[i][j] = c[i-1][j-1]+1;
           else if(c[i-1][j]&gt;=c[i][j-1])
                   c[i][j] = c[i-1][j];
                else
                   c[i][j] = c[i][j-1];
       }
    lcs = c[m][n];
    return lcs; 
}
void build_lcs()
{   
    int k,i=strlen(a),j=strlen(b);
    k = lcs_len();
    str[k]=' ';
    while(k&gt;0)
        if(c[i][j]==c[i-1][j])
            i=i-1;
        else if(c[i][j]==c[i][j-1])
                j=j-1;
             else
             {
                 k=k-1;
                 str[k]=a[i-1];
                 j=j-1;
             }
}
int main()
{  
    build_lcs();
    printf("%s",str); 
    return 0;
}</code></pre> 
<h4>第3关：求序列-2 11 -4 13 -5 -2的最大子段和</h4> 
<p>300</p> 
<ul><li>任务要求</li><li>参考答案</li><li>评论9</li></ul> 
<ul><li><a href="https://www.educoder.net/tasks/s9qtgw7h/1101739/9fftzl6w3p2b#%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0" rel="nofollow" title="任务描述">任务描述</a></li><li><a href="https://www.educoder.net/tasks/s9qtgw7h/1101739/9fftzl6w3p2b#%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86" rel="nofollow" title="相关知识">相关知识</a></li><li><a href="https://www.educoder.net/tasks/s9qtgw7h/1101739/9fftzl6w3p2b#%E7%BC%96%E7%A8%8B%E8%A6%81%E6%B1%82" rel="nofollow" title="编程要求">编程要求</a></li><li><a href="https://www.educoder.net/tasks/s9qtgw7h/1101739/9fftzl6w3p2b#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A" rel="nofollow" title="解题思路：">解题思路：</a></li><li><a href="https://www.educoder.net/tasks/s9qtgw7h/1101739/9fftzl6w3p2b#%E6%B5%8B%E8%AF%95%E8%AF%B4%E6%98%8E" rel="nofollow" title="测试说明">测试说明</a></li></ul> 
<hr> 
<h4>任务描述</h4> 
<p>本关任务：编写用动态规划解决最大子段和问题。</p> 
<h4>相关知识</h4> 
<p>为了完成本关任务，你需要掌握：动态规划。</p> 
<h4>编程要求</h4> 
<p>给定由n个整数（可能为负数）组成的序列：a1,a2,……,an, 求该序列的最大子段和。当所有整数均为负数，定义其最大子段和为0。</p> 
<h4>解题思路：</h4> 
<p>定义b[j]=max(a[i]+a[i+1]+…+a[j])，其中1&lt;=i&lt;=j，并且1&lt;=j&lt;=n。那么所求的最大子段和可以表示为max b[j]，1&lt;=j&lt;=n。 由b[j]的定义可知，当b[j−1]&gt;0时b[j]=b[j−1]+a[j]，否则b[j]=a[j]。故b[j]的动态规划递归表达式为: b[j]=max(b[j−1]+a[j],a[j])，1&lt;=j&lt;=n。</p> 
<h4>测试说明</h4> 
<p>平台会对你编写的代码进行测试：</p> 
<p>测试输入：</p> 
<pre></pre> 
<ol><li><code>6</code></li><li><code>-2 11 -4 13 -5 -2</code></li></ol> 
<p>输出示例：</p> 
<pre></pre> 
<ol><li><code>20</code></li></ol> 
<hr> 
<p>开始你的任务吧，祝你成功！</p> 
<pre><code>#include &lt;stdio.h&gt;
int maxsubsequence(int n,int a[],int b[],int max)
{
    for (int i = 0; i &lt; n; i++)
    {
        if (i == 0)
        {
            b[i] = a[i];
            max = b[i];
        }
        else
        {
            if (b[i - 1] &lt;= 0)
                b[i] = a[i];
            else
                b[i] = b[i - 1] + a[i];
            if (b[i] &gt; max)
                max = b[i];
        }
    }
    return max;
}
int main()
{
    int n;
    scanf("%d",&amp;n);
    int a[1000];
    for (int i = 0; i &lt; n; i++)
        scanf("%d",&amp;a[i]);
    int b[100],max = 0;
    max = maxsubsequence(n, a, b, max);
    printf("%d",max);
}</code></pre> 
<h4>第4关：求最长的单调递增子序列长度</h4> 
<p>400</p> 
<ul><li>任务要求</li><li>参考答案</li><li>评论9</li></ul> 
<ul><li><a href="https://www.educoder.net/tasks/s9qtgw7h/1101739/jaxbomnp84t6#%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0" rel="nofollow" title="任务描述">任务描述</a></li><li><a href="https://www.educoder.net/tasks/s9qtgw7h/1101739/jaxbomnp84t6#%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86" rel="nofollow" title="相关知识">相关知识</a></li><li><a href="https://www.educoder.net/tasks/s9qtgw7h/1101739/jaxbomnp84t6#%E7%BC%96%E7%A8%8B%E8%A6%81%E6%B1%82" rel="nofollow" title="编程要求">编程要求</a></li><li><a href="https://www.educoder.net/tasks/s9qtgw7h/1101739/jaxbomnp84t6#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A" rel="nofollow" title="解题思路：">解题思路：</a></li><li><a href="https://www.educoder.net/tasks/s9qtgw7h/1101739/jaxbomnp84t6#%E6%B5%8B%E8%AF%95%E8%AF%B4%E6%98%8E" rel="nofollow" title="测试说明">测试说明</a></li></ul> 
<hr> 
<h4>任务描述</h4> 
<p>本关任务：编写用动态规划解决求最长的单调递增子序列长度问题。</p> 
<h4>相关知识</h4> 
<p>为了完成本关任务，你需要掌握：动态规划。</p> 
<h4>编程要求</h4> 
<p>给定一个长度为n的数组，找出一个最长的单调递增子序列（不一定连续，但是顺序不能乱）。例如：给定一个长度为7的数组A5，6，7，1，2，8,9，则其最长的单调递增子序列为5，6，7，8，9，长度为5。求318714101223411624的最长的单调递增子序列长度。</p> 
<h4>解题思路：</h4> 
<p>设长度为n的数组为(a[0]，a[1],a[2],...，a[n−1])，则假定以a[j]结尾的数组序列的最长递增子序列长度为L(j)，则L(j)=max(L(i))+1,i&lt;j且a[i]&lt;a[j]。也就是说，我们需要遍历在j之前的所有位置i(从0到j−1)，找出满足条件a[i]&lt;a[j]的L(i)，求出max(L(i))+1即为L(j)的值。最后，我们遍历所有的L(j)（从0到n−1），找出最大值即为最大递增子序列。</p> 
<h4>测试说明</h4> 
<p>平台会对你编写的代码进行测试：</p> 
<p>测试输入：</p> 
<pre></pre> 
<ol><li><code>10</code></li><li><code>3 18 7 14 10 12 23 41 16 24</code></li></ol> 
<p>输出示例：</p> 
<pre></pre> 
<ol><li><code>6</code></li></ol> 
<hr> 
<p>开始你的任务吧，祝你成功！</p> 
<p></p> 
<pre><code>#include &lt;stdio.h&gt;
/********** Begin **********/
int main(){
	 int n;
	 scanf("%d",&amp;n);
	 int m[n][3];
	 m[0][1]=1;
	 m[0][2]=0;
	 for(int i=0;i&lt;n;i++){
		scanf("%d",&amp;m[i][0]);
		if(i!=0){
			m[i][1]=0;
			int k=i-1;
			while(k&gt;=0){
				if(m[i][0]&gt;m[k][0]){
						if(k==i-1){
							m[i][1]=m[k][1]+1;
							m[i][2]=k;
						}
						else{
							int max=m[k][1]+1;
							if(max&gt;m[i][1]){
								m[i][1]=max;
								m[i][2]=k;	
							}
					    }
				}
			 k--;
			}
			if(k&lt;0&amp;&amp;m[i][1]==0){
			    m[i][1]=1;
			    m[i][2]=i;
			}
		}
	 }
 
	int max=m[0][1],j=0;
	for(int i=0;i&lt;n;i++){
	      if(m[i][1]&gt;=max){
	             max=m[i][1];
	             j=i;
	      }
	 }
	printf("%d\n",max);
 
 
}
/********** End **********/</code></pre> 
<h4>第5关：矩阵连乘问题</h4> 
<p>400</p> 
<ul><li>任务要求</li><li>参考答案</li><li>评论9</li></ul> 
<ul><li><a href="https://www.educoder.net/tasks/s9qtgw7h/1101739/vef3lcaxhnu9#%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0" rel="nofollow" title="任务描述">任务描述</a></li><li><a href="https://www.educoder.net/tasks/s9qtgw7h/1101739/vef3lcaxhnu9#%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86" rel="nofollow" title="相关知识">相关知识</a></li><li><a href="https://www.educoder.net/tasks/s9qtgw7h/1101739/vef3lcaxhnu9#%E7%BC%96%E7%A8%8B%E8%A6%81%E6%B1%82" rel="nofollow" title="编程要求">编程要求</a></li><li><a href="https://www.educoder.net/tasks/s9qtgw7h/1101739/vef3lcaxhnu9#%E6%B5%8B%E8%AF%95%E8%AF%B4%E6%98%8E" rel="nofollow" title="测试说明">测试说明</a></li></ul> 
<hr> 
<h4>任务描述</h4> 
<p>本关任务：编写用动态规划解决矩阵连乘问题。</p> 
<h4>相关知识</h4> 
<p>为了完成本关任务，你需要掌握：动态规划。</p> 
<h4>编程要求</h4> 
<p>将矩阵连乘积AiAi+1…Aj简记为A[i:j]，其中i&lt;=j。设在矩阵Ak和Ak+1之间将矩阵链断开，则其相应加括号为(AiAi+1…Ak) (Ak+1Ak+2…Aj)。A[i:j]的计算量等于三部分计算量之和： （1）A[i:k]的计算量， （2）A[k+1:j]的计算量， （3）A[i:k]与A[k+1:j]相乘的计算量。 设计算A[i:j]所需最少乘积数目为，则原问题的最优值为。 当i=j时,a[i:j]=Ai​，因此，m[i][j]=0,i=1,⋅⋅⋅,n 当i&lt;j时，m[i][j]=i&lt;k&lt;jmin​{m[i][k]+m[k+1][j]+pi−1​pk​pj​} 其中，矩阵Ai​的矩阵数为pi−1​×pi​ 矩阵A1​的维度：p0​p1​=3035 矩阵A2​的维度：p1​p2​=3515 矩阵A3​的维度：p2​p3​=155 矩阵A4​的维度：p3​p4​=510 矩阵A5​的维度：p4​p5​=1020 矩阵A6​的维度：p5​p6​=2025 求这6个矩阵连乘的最小相乘次数。</p> 
<h4>测试说明</h4> 
<p>平台会对你编写的代码进行测试：</p> 
<p>测试输入：</p> 
<pre></pre> 
<ol><li><code>6</code></li><li><code>30 35</code></li><li><code>35 15</code></li><li><code>15 5</code></li><li><code>5 10</code></li><li><code>10 20</code></li><li><code>20 25</code></li></ol> 
<p>输出示例：</p> 
<pre></pre> 
<ol><li><code>m[1][6]=15125</code></li></ol> 
<hr> 
<p>开始你的任务吧，祝你成功！</p> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
/********** Begin **********/
int main(){
	int n;
	scanf("%d",&amp;n);
	int a[n][2];
	int b[n][n]={0};
	for(int i=0;i&lt;n;i++){
	    scanf("%d %d",&amp;a[i][0],&amp;a[i][1]);   
	}
	
	for(int i=1;i&lt;n;i++){
	    for(int j=0;j&lt;n-i;j++){
	      b[j][j+i]=b[j][j]+b[j+1][j+i]+a[j][0]*a[j][1]*a[j+i][1];         
	      int k=j+1;
	      for(;k&lt;j+i;k++){
	              int t=b[j][k]+b[k+1][j+i]+a[j][0]*a[k][1]*a[j+i][1];
	                if(t&lt;b[j][j+i]) {
	                    b[j][j+i]=t;
	                }
	              
	      }
	
	    }
	        
	}
	printf("m[%d][%d]=%d",1,n,b[0][n-1]);
	return 0;
}
/********** End **********/</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8e8233227c5b38d61e3d2bf4606b4d74/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java中List排序的3种方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c3c3a6c85307dc5421947c72c80f6870/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于Python和Neo4j搭建知识图谱医药问答系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>