<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>如何把自有数据接入GPT大模型？ - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/767d39602873f69faf0b13ec7592955d/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="如何把自有数据接入GPT大模型？">
  <meta property="og:description" content="ChatGPT引发了AI革命，大家都想探究如何让它发挥更大价值。
以它为代表的大模型并未完全掌握所有专业知识，这也正是我们创业的契机。
我们应该思考如何让AI在专业领域中释放更大的价值潜能。
就像开发者挖掘出某个鲜为人知的资源一样，我们可以开发出AI在特定领域的潜力，从而在市场上脱颖而出。
以OpenAI的API为例，让大模型支持自己专业领域的知识，有两种方式：微调模型和封装到Prompt。
一、微调（Fine-tuning）注入专业领域知识 微调是在基础大模型训练成熟之后，通过Fine-tuning模式，利用标注数据调整模型参数以适应不同任务需求。
传统的微调需要做调整损失函数、增加额外层等工作，但自2018年以来，随着预训练模型的体量不断增大，预训练模型Fine-tune所需的硬件和数据需求也在不断增长。此外，下游任务的丰富多样性使得预训练和微调阶段的设计更为复杂。
如今，像GTP-4这样的模型已经采用了一种新的训练模式，即单向语言模型预训练&#43;zero shot prompt/Instruct，它不需要在预训练后进行任务Fine-tuning，而是通过自然语言指令来解决下游任务，这为模型的优化提供了全新的可能性。
OpenAI在GPT-4上花了6个月的时间才放出来，是为了使其更安全、更一致，而不是新的专业领域知识的注入，新专业领域知识的注入耗时非常短的，也就根据数据量，几分钟到几小时。
从OpenAI的微调文档 https://platform.openai.com/docs/guides/fine-tuning 可以看出，要准备的数据包含prompt（输入文本）和completion（输出文本）两部分：
prompt是我们给模型的输入文本，它可以是任何文本，例如一个问题、一个描述、一个开头、一个例子等。prompt的作用是告诉模型我们想要完成什么样的任务，并给出一些上下文或模式。
completion是模型根据prompt生成的输出文本，它可以是任何文本，例如一个答案、一个续写、一个列表、一段代码等。completion的作用是尽可能地满足prompt的要求，并保持语义和逻辑的连贯性。
下面是一些数据例子：
{ &#34;prompt&#34;: &#34;对以下商品进行夸赞：彩妆中的口红品类，卖点为颜色是正红色，能提升气色 -&gt;&#34;, &#34;completion&#34;: &#34; 这口红正红色太好看了，完美提升气色，日常使用特别棒\\n&#34; } 更多的例子可以看如下链接：
GPT-for-E-Commerce/test-v1.1.jsonl at b6dd9d018dce670efd28448dbd0dde0edecb3e42 · Royce17/GPT-for-E-Commerce · GitHubfinetune-with-openai/faq.jsonl at 334a69224d7e87a92de09b0d627f616be4ffa43a · A-baoYang/finetune-with-openai · GitHub 要微调的效果好，就要使用更多高质量的示例进行Fine-tuning，我们应该如上面链接例子一样，提供至少几百个高质量的示例，而且最好由专家审查过。
二、在Prompt中带入知识 只需设计恰当的输入，就能让ChatGPT在上下文中生成有价值的答案，而无需修改模型的结构或参数。
输入问题时，还可以引入相关知识，使问题更加全面。这种方法的局限性在于每次输入的长度有限。
下面是一些例子：
例1：作为专业DBA，回答SQL相关问题 这里在输入问题时，引入了我们的数据库表结构这个专业知识。
问：
我要你扮演一个专业DBA。我将提供给你数据表结构以及我的需求，你的目标是告知我性能最优的可执行的SQL语句，并尽可能的向我解释这段SQL语句，如果有更好的优化建议也可以提出来。
我的数据表结构为:
CREATE TABLE `user` ( `id` int NOT NULL AUTO_INCREMENT, `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT &#39;&#39; COMMENT &#39;名字&#39;, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT=&#39;用户表&#39;; 我的需求为：根据用户的名字查询用户的id">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-03-21T06:30:00+08:00">
    <meta property="article:modified_time" content="2023-03-21T06:30:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">如何把自有数据接入GPT大模型？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>ChatGPT引发了AI革命，大家都想探究如何让它发挥更大价值。</p> 
<p>以它为代表的大模型并未完全掌握所有专业知识，这也正是我们创业的契机。</p> 
<blockquote> 
 <p>我们应该思考如何让AI在<strong>专业领域</strong>中释放更大的价值潜能。<br> 就像开发者挖掘出某个鲜为人知的资源一样，我们可以开发出AI在特定领域的潜力，从而在市场上脱颖而出。</p> 
</blockquote> 
<p>以OpenAI的API为例，让大模型支持自己专业领域的知识，有两种方式：微调模型和封装到Prompt。</p> 
<p><img alt="" height="1140" src="https://images2.imgbox.com/95/3b/To6xPfTe_o.png" width="1200"></p> 
<p> </p> 
<p></p> 
<h3><a id="%E4%B8%80%E3%80%81%E5%BE%AE%E8%B0%83%EF%BC%88fine-tuning%EF%BC%89%E6%B3%A8%E5%85%A5%E4%B8%93%E4%B8%9A%E9%A2%86%E5%9F%9F%E7%9F%A5%E8%AF%86"></a>一、微调（Fine-tuning）注入专业领域知识</h3> 
<p>微调是在基础大模型训练成熟之后，通过Fine-tuning模式，利用<strong>标注数据</strong>调整模型参数以适应不同任务需求。</p> 
<p>传统的微调需要做调整损失函数、增加额外层等工作，但自2018年以来，随着预训练模型的体量不断增大，预训练模型Fine-tune所需的硬件和数据需求也在不断增长。此外，下游任务的丰富多样性使得预训练和微调阶段的设计更为复杂。</p> 
<p>如今，像GTP-4这样的模型已经采用了一种新的训练模式，即单向语言模型预训练+zero shot prompt/Instruct，它不需要在预训练后进行任务Fine-tuning，而是通过自然语言指令来解决下游任务，这为模型的优化提供了全新的可能性。</p> 
<p>OpenAI在GPT-4上花了6个月的时间才放出来，是为了使其更安全、更一致，而不是新的专业领域知识的注入，新专业领域知识的注入耗时非常短的，也就根据数据量，几分钟到几小时。</p> 
<p>从OpenAI的微调文档 <a href="https://platform.openai.com/docs/guides/fine-tuning" rel="nofollow" title="https://platform.openai.com/docs/guides/fine-tuning">https://platform.openai.com/docs/guides/fine-tuning</a> 可以看出，要准备的数据包含prompt（输入文本）和completion（输出文本）两部分：</p> 
<ul><li> <p>prompt是我们给模型的输入文本，它可以是任何文本，例如一个问题、一个描述、一个开头、一个例子等。prompt的作用是告诉模型我们想要完成什么样的任务，并给出一些上下文或模式。</p> </li><li> <p>completion是模型根据prompt生成的输出文本，它可以是任何文本，例如一个答案、一个续写、一个列表、一段代码等。completion的作用是尽可能地满足prompt的要求，并保持语义和逻辑的连贯性。</p> </li></ul> 
<p>下面是一些数据例子：</p> 
<pre><code>{
    "prompt": "对以下商品进行夸赞：彩妆中的口红品类，卖点为颜色是正红色，能提升气色 -&gt;", 
    "completion": " 这口红正红色太好看了，完美提升气色，日常使用特别棒\\n"
}
</code></pre> 
<p>更多的例子可以看如下链接：</p> 
<ul><li><a href="https://github.com/Royce17/GPT-for-E-Commerce/blob/b6dd9d018dce670efd28448dbd0dde0edecb3e42/dataset/train/test-v1.1.jsonl" title="GPT-for-E-Commerce/test-v1.1.jsonl at b6dd9d018dce670efd28448dbd0dde0edecb3e42 · Royce17/GPT-for-E-Commerce · GitHub">GPT-for-E-Commerce/test-v1.1.jsonl at b6dd9d018dce670efd28448dbd0dde0edecb3e42 · Royce17/GPT-for-E-Commerce · GitHub</a></li><li><a href="https://github.com/A-baoYang/finetune-with-openai/blob/334a69224d7e87a92de09b0d627f616be4ffa43a/example_data/faq.jsonl" title="finetune-with-openai/faq.jsonl at 334a69224d7e87a92de09b0d627f616be4ffa43a · A-baoYang/finetune-with-openai · GitHub">finetune-with-openai/faq.jsonl at 334a69224d7e87a92de09b0d627f616be4ffa43a · A-baoYang/finetune-with-openai · GitHub</a></li></ul> 
<p>要微调的效果好，就要使用更多高质量的示例进行Fine-tuning，我们应该如上面链接例子一样，提供至少几百个高质量的示例，而且最好由专家审查过。</p> 
<h3><a id="%E4%BA%8C%E3%80%81%E5%9C%A8prompt%E4%B8%AD%E5%B8%A6%E5%85%A5%E7%9F%A5%E8%AF%86"></a>二、在Prompt中带入知识</h3> 
<p>只需设计恰当的输入，就能让ChatGPT在上下文中生成有价值的答案，而无需修改模型的结构或参数。</p> 
<p>输入问题时，还可以引入相关知识，使问题更加全面。这种方法的局限性在于每次输入的长度有限。</p> 
<p>下面是一些例子：</p> 
<h4><a id="%E4%BE%8B1%EF%BC%9A%E4%BD%9C%E4%B8%BA%E4%B8%93%E4%B8%9Adba%EF%BC%8C%E5%9B%9E%E7%AD%94sql%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"></a>例1：作为专业DBA，回答SQL相关问题</h4> 
<p>这里在输入问题时，引入了我们的数据库表结构这个专业知识。</p> 
<p>问：</p> 
<blockquote> 
 <p>我要你扮演一个专业DBA。我将提供给你数据表结构以及我的需求，你的目标是告知我性能最优的可执行的SQL语句，并尽可能的向我解释这段SQL语句，如果有更好的优化建议也可以提出来。</p> 
 <p>我的数据表结构为:</p> 
 <pre><code>CREATE TABLE `user` (
`id` int NOT NULL AUTO_INCREMENT,
`name` varchar(255) CHARACTER SET  utf8mb4 
      COLLATE utf8mb4_unicode_ci 
      NOT NULL DEFAULT '' 
      COMMENT '名字',
PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 
      COLLATE=utf8mb4_unicode_ci 
      COMMENT='用户表';
</code></pre> 
 <p>我的需求为：根据用户的名字查询用户的id</p> 
</blockquote> 
<p>回答</p> 
<blockquote> 
 <p>好的，根据您提供的数据表结构和需求，可以使用以下SQL语句来查询用户的id：</p> 
 <pre><code>SELECT id FROM user WHERE name = '用户的名字';
</code></pre> 
 <p>这条SQL语句将会在用户表中查找指定名字的用户，然后返回该用户的id。为了进一步优化查询性能，您可以在name字段上创建索引，这将会使查询更快速地匹配到所需的记录。</p> 
 <p>您可以使用以下SQL语句来为name字段创建索引：</p> 
 <pre><code>ALTER TABLE user ADD INDEX name_index (name);
</code></pre> 
 <p>此外，为了保证查询的效率，您需要注意以下几点：</p> 
 <ol><li> <p>数据表的数据量过大时，查询的速度可能会变慢。如果您的数据表中包含大量的数据，可以考虑对表进行分区或分表。</p> </li><li> <p>如果您的查询需求经常变化，您可能需要对数据库进行优化。可以通过监控数据库的性能指标，识别哪些查询最耗时，然后对其进行优化。</p> </li></ol> 
</blockquote> 
<h4><a id="%E4%BE%8B2%EF%BC%9A%E6%99%BA%E8%83%BD%E5%AE%A2%E6%9C%8D"></a>例2：智能客服</h4> 
<p>比如我们要做智能客服，有一些客服准则（<a href="https://mp.weixin.qq.com/s/479mR9Y9S_bOMd6BaGy8zw" rel="nofollow" title="ChatGPT做智能客服的十条服务准则">ChatGPT做智能客服的十条服务准则</a> ），对于OpenAI的API来说，要注入的知识如下链接：</p> 
<blockquote> 
 <p><a href="https://github.com/maxim-top/lanying-connector/blob/master/configs/openai-xiaolan.json" title="lanying-connector/openai-xiaolan.json at master · maxim-top/lanying-connector · GitHub">lanying-connector/openai-xiaolan.json at master · maxim-top/lanying-connector · GitHub</a></p> 
</blockquote> 
<p>下面代码通过消息对象的数组注入了一些上下文知识。</p> 
<pre><code>
# Note: you need to be using OpenAI Python v0.27.0 for the code below to work
import openai

openai.ChatCompletion.create(
  model="gpt-3.5-turbo",
  messages=[
        {"role": "system", "content": "You are a helpful assistant."},
        {"role": "user", "content": "Who won the world series in 2020?"},
        {"role": "assistant", "content": "The Los Angeles Dodgers won the World Series in 2020."},
        {"role": "user", "content": "Where was it played?"}
    ]
)

</code></pre> 
<p>其中</p> 
<ul><li>系统消息（system）有助于设置助手的行为。在上面的例子中，prompt被指示“You are a helpful assistant.”。</li><li>用户消息（user）有助于指导助手。它们可以由应用程序的最终用户生成，也可以由开发人员设置为指令。在上面的例子中，用户的最后一个问题是“在哪里比赛的？” 就是通过提前设置的对话消息来帮助回答。由于模型没有过去请求的记忆，因此所有相关信息必须通过对话提供。如果对话无法满足模型的token限制，则需要以某种方式缩短。</li><li>助理消息（assistant）有助于存储之前的回复。它们也可以由开发人员编写，以帮助提供所需行为的示例。</li></ul> 
<p>通过上面的方式就可以完成专业领域知识的注入。</p> 
<h4><a id="%E4%BE%8B3%EF%BC%9A%E9%80%9A%E8%BF%87%E5%A4%96%E9%83%A8%E9%93%BE%E6%8E%A5%E6%8A%8A%E5%86%85%E5%AE%B9%E5%B8%A6%E5%85%A5"></a>例3：通过外部链接把内容带入</h4> 
<p>下面只包含我们发起的对话部分，会话结果比较长，省略了：</p> 
<blockquote> 
 <p>User : 您是一个金融专家，我会向您发送微软的年度报告，并在我向您发送链接后反馈给我微软10个利好和10个消极因素。你明白吗？<br> ...<br> User : <a href="https://www.microsoft.com/investor/reports/ar22/index.html" rel="nofollow" title="Microsoft 2022 Annual Report">Microsoft 2022 Annual Report</a><br> ...<br> User : 我会把Nvidia最近的财报链接发给你，你能反馈我和上面微软类似的答案吗，你明白吗?<br> ...<br> User: <a href="https://nvidianews.nvidia.com/news/nvidia-announces-financial-results-for-fourth-quarter-and-fiscal-2023" rel="nofollow" title="NVIDIA Announces Financial Results for Fourth Quarter and Fiscal 2023 | NVIDIA Newsroom">NVIDIA Announces Financial Results for Fourth Quarter and Fiscal 2023 | NVIDIA Newsroom</a><br> ...<br> User: 您能否从Nvidia的报告中提供更多财务见解?<br> ...<br> User: 我会把戴尔最近的财务报告的链接发给你，你能反馈我和上面微软类似的答案吗，你明白吗?<br> ....</p> 
 <p>User: 比较微软、英伟达和戴尔，用表格对比下他们的资本支出、运营支出、收入、利润率和利润率百分比。<br> ...<br> User：预测下戴尔未来12个月的现金流。</p> 
</blockquote> 
<p>这种方式要确保链接可以被GPT访问到，外部链接持续稳定的可访问是必须考虑的问题。</p> 
<h3><a id="%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E5%AF%B9%E6%AF%94"></a>适用场景对比</h3> 
<h4><a id="%E4%BB%B7%E6%A0%BC%E5%AF%B9%E6%AF%94"></a>价格对比</h4> 
<p>OpenAI的相关报价看： <a href="https://openai.com/pricing" rel="nofollow" title="Pricing">Pricing</a></p> 
<p>对话类：GPT4远远高于GTP3.5。</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/5c/1b/ByDbzG5p_o.png" width="1200"></p> 
<p> </p> 
<p>目前提供的可微调的这几个模型：Ada、Babbage、Curie、Davinci 均是原始的 GPT-3 基本模型，其中，Davinci 是最强大的模型，成本也最高，而 Curie 又比 Babbage 功能更强大（且成本更高），依此类推，这些名称是相对的。</p> 
<p><img alt="" height="754" src="https://images2.imgbox.com/e2/49/yqVvzQOt_o.png" width="1200"></p> 
<p> </p> 
<p>GPT3.5 和 GTP4 由于目前没有 fine-tune，所以成本就只有每次问答的成本，但由于大部分时候需要带大量的 prompts，其实隐性的成本是挺高的，我们经常可以看到一个简短的问题会带有上千个字符的 prompts。</p> 
<p>而 Davinci 的 fine-tune 模型的训练成本是较高的，但一旦获得专属模型后，后续的聊天中就不再需要做预检索和背景知识的 prompts 了，可以直接进行关于该领域的知识问答。不仅 token 消耗会变小，而且速度也会更快。</p> 
<p>所以目前阶段还是用在Prompt中带入知识方案比较合适，后续等对应的微调模型出来后，可以切换过去。</p> 
<h4><a id="%E9%95%BF%E5%BA%A6%E9%97%AE%E9%A2%98"></a>长度问题</h4> 
<p>ChatGPT的API当前是无状态的，需要自己维护会话状态和保存上下文。这可能会导致请求内容越来越大，带来高昂的费用。</p> 
<p>但是，你可以借助OpenAI的embedding模型（<a href="https://platform.openai.com/docs/guides/embeddings/what-are-embeddings" rel="nofollow" title="https://platform.openai.com/docs/guides/embeddings/what-are-embeddings">https://platform.openai.com/docs/guides/embeddings/what-are-embeddings</a>）和本地数据库，以更智能的方式维护上下文，并且节省成本。</p> 
<p>首先，将文本资料准备成易于处理的格式，并且分成小块(这是OpenAI embeddings模型的输入长度限制)。接着，利用程序调用OpenAI embedding的API将这些文本块转换成数字向量，并且将结果保存到本地数据库中。（注意，为了能够反向获得原始文本，需要将原始文本块和数字向量一起存储。）</p> 
<p>当需要搜索的时候，将搜索关键字转换成数字向量，并且在本地数据库中进行检索。结果集将根据匹配相似度进行打分，分越高表示越匹配。这样，可以按照匹配度倒序返回相关结果。</p> 
<p>聊天场景下，当用户提问后，需要先把提问内容关键字搜索到一个相关结果集（可以本地检索，也可以通过OpenAI embedding接口获得向量后比较相似度）。然后根据拿到的结果集，将结果集加入到请求ChatGPT的prompt中。</p> 
<p>比如说用户提了一个问题：</p> 
<blockquote> 
 <p>“What's the makers's schedule?”</p> 
</blockquote> 
<p>从数据库中检索到相关的文字段落是：</p> 
<blockquote> 
 <p>“What I worked on...”<br> "Taste for Makers..."</p> 
</blockquote> 
<p>那么最终的prompt看起来就像这样：</p> 
<pre><code>
[
 {
  role: "system",
  content: "You are a helpful assistant that accurately answers queries using Paul Graham's essays. Use the text provided to form your answer, but avoid copying word-for-word from the essays. Try to use your own words when possible. Keep your answer under 5 sentences. Be accurate, helpful, concise, and clear."
 },
 {
 role: "user",
 content: `Use the following passages to provide an answer
to the query: "What's the makers's schedule?"
1. What I worked on...
2. Taste for Makers...`
 }
]

</code></pre> 
<p>这样ChatGPT在返回结果的时候，就会加上你的数据集。</p> 
<p>具体实现看: <a href="https://github.com/mckaywrigley/paul-graham-gpt" title="GitHub - mckaywrigley/paul-graham-gpt: AI search &amp; chat for all of Paul Graham’s essays.">GitHub - mckaywrigley/paul-graham-gpt: AI search &amp; chat for all of Paul Graham’s essays.</a></p> 
<h3><a id="%E6%80%BB%E7%BB%93"></a>总结</h3> 
<p>大模型的可能性真的非常多。想象一下，如果你将自己的思想和博客输入大模型，你可以训练出一个包含自己想法的模型。这个模型可以被定位为模仿人进行交流，最终创造出一个虚拟的你。对于专业领域的KOL（关键意见领袖）来说，这种方法非常有用，因为粉丝可以直接针对他的思想进行提问和交流。</p> 
<p>而对于不善写作的人来说，也可以将自己的想法以简单的问答对的形式输出，训练出一个专属机器人，再利用大模型的语言和逻辑能力来撰写包含自己思想的文章。这种方法非常值得尝试。</p> 
<h3><a id="%E5%8F%82%E8%80%83"></a>参考</h3> 
<ul><li> <p>如何用 ChatGPT 构建你的专属知识问答机器人 <a href="https://blog.frankzhao.cn/build_gpt_bot_for_doc/" rel="nofollow" title="如何用 ChatGPT 构建你的专属知识问答机器人 - Frank 的个人博客">如何用 ChatGPT 构建你的专属知识问答机器人 - Frank 的个人博客</a></p> </li><li> <p>搭建基于知识库内容的机器人 <a href="https://learningprompt.wiki/docs/tutorial-extras/%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8E%E7%9F%A5%E8%AF%86%E5%BA%93%E5%86%85%E5%AE%B9%E7%9A%84%E6%9C%BA%E5%99%A8%E4%BA%BA" rel="nofollow" title="搭建基于知识库内容的机器人 | Learning Prompt">搭建基于知识库内容的机器人 | Learning Prompt</a></p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ed20e984e0ae6db51c0464c6dea40bb6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">XGBoost详解（原理篇）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c510b50694062ecbe0d1f4ba789020ed/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">大数据开发语言Scala（一）——scala入门</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>