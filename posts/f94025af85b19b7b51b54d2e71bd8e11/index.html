<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>删除链表中等于给定值 val 的所有结点（三种方法深入解析） - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/f94025af85b19b7b51b54d2e71bd8e11/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="删除链表中等于给定值 val 的所有结点（三种方法深入解析）">
  <meta property="og:description" content="又见面啦，接下来的链表相关Oj题目我会根据我自己的理解来给大家讲解，包括解析和代码，希望你可以对链表有更加深入的理解！！
题目： 先上链接：
OJ题目
给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。
方法一：迭代 想法：遍历链表，找到这个val前面一个结点，让这个结点指向val的next
注意：在寻找为给定值的结点时，需要先判断结点是否为空结点
if (head != nullptr &amp;&amp; head-&gt;val == val) { head = head-&gt;next; } 结果如下：
struct ListNode* removeElements(struct ListNode* head, int val) { if (head != nullptr &amp;&amp; head-&gt;val == val) { head = head-&gt;next; } if(NULL==head){ return head; } struct ListNode*pre=head; while(pre-&gt;next!=NULL) { if(pre-&gt;next-&gt;val==val) { pre-&gt;next=pre-&gt;next-&gt;next; } else { pre=pre-&gt;next; } } return head; } 方法二：双指针 设置两个指针，值为head">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-03T16:23:02+08:00">
    <meta property="article:modified_time" content="2024-05-03T16:23:02+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">删除链表中等于给定值 val 的所有结点（三种方法深入解析）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>又见面啦，接下来的链表相关Oj题目我会根据我自己的理解来给大家讲解，包括解析和代码，希望你可以对链表有更加深入的理解！！</p> 
<hr> 
<h2>题目：</h2> 
<p>先上链接：</p> 
<p><a class="link-info" href="https://leetcode.cn/problems/remove-linked-list-elements/" rel="nofollow" title="OJ题目">OJ题目</a></p> 
<p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p> 
<p><img src="https://images2.imgbox.com/d0/fa/tBFXdT4f_o.png" alt="4189df03ee304a54a1f7e8a707f212d5.png"></p> 
<h2>方法一：迭代 </h2> 
<blockquote> 
 <p> 想法：遍历链表，找到这个val前面一个结点，让这个结点指向val的next</p> 
</blockquote> 
<p> 注意：在寻找为给定值的结点时，需要先判断结点是否为空结点</p> 
<pre><code class="language-cpp">if (head != nullptr &amp;&amp; head-&gt;val == val) {
	head = head-&gt;next;
}</code></pre> 
<p> <img src="https://images2.imgbox.com/b1/71/4C4rkwN6_o.png" alt="8db00eae410d418abfd1919fcaef00f8.png"></p> 
<p> 结果如下：</p> 
<pre><code class="language-cpp">struct ListNode* removeElements(struct ListNode* head, int val) {
    if (head != nullptr &amp;&amp; head-&gt;val == val) {
	head = head-&gt;next;
}
    if(NULL==head){
        return head;
    }
    struct ListNode*pre=head;
    while(pre-&gt;next!=NULL)
    {
        if(pre-&gt;next-&gt;val==val)
        {
            pre-&gt;next=pre-&gt;next-&gt;next;
        }
        else 
        {
            pre=pre-&gt;next;
        }

    }
    return head;

    
}</code></pre> 
<h2>方法二：双指针</h2> 
<p><img src="https://images2.imgbox.com/a5/25/97FcIhkm_o.png" alt="31bbdc0944a148c8b82ea5714322ec93.png"></p> 
<p>设置两个指针，值为head</p> 
<p> <img src="https://images2.imgbox.com/b0/18/RSEoPzGy_o.png" alt="3793c861dc6a4f7a829e310fee33b9ca.png"></p> 
<p>cur右移判断他的val 是否为要删除的值，如果不是pre右移</p> 
<p> <img src="https://images2.imgbox.com/8a/bb/colIw2bH_o.png" alt="89f26529bc2f4c629c81873268f65698.png"></p> 
<p> <img src="https://images2.imgbox.com/d4/10/PhXDt7wl_o.png" alt="b2e8f99bc022472f9b9eb6bdcfba3be3.png"></p> 
<p>直到cur-&gt;val==val;这个时候的pre就是这个需要删除结点的前结点，让pre-&gt;next=cur-&gt;next， 遍历完整个链表就可以了</p> 
<p> 看一下代码</p> 
<pre><code class="language-cpp">struct ListNode* removeElements(struct ListNode* head, int val){
    while (NULL != head &amp;&amp; head-&gt;val == val) {
        head = head-&gt;next;
    }
    
    struct ListNode* cur = head;
    struct ListNode* pre = head;
    while (cur != NULL) {
        if (cur-&gt;val == val) {
            pre-&gt;next = cur-&gt;next;
        } else {
            pre = cur;
        }
        cur = cur-&gt;next;
    }
    return head;
}

</code></pre> 
<h2>虚拟头结点</h2> 
<blockquote> 
 <p>可以通过在头结点前增加虚拟头结点，这样子头结点就变成了普通结点</p> 
</blockquote> 
<p>看代码</p> 
<pre><code class="language-cpp">struct ListNode* removeElements(struct ListNode* head, int val) {
    struct ListNode*dummyhead=malloc(sizeof(struct ListNode));
    if(dummyhead==NULL){
        return NULL;
    }
    dummyhead-&gt;next=head;
    struct ListNode*cur=dummyhead;
    while(cur-&gt;next!=NULL)
    {
        if(cur-&gt;next-&gt;val==val){
            cur-&gt;next=cur-&gt;next-&gt;next;
        }
        else{
            cur=cur-&gt;next;
        }
    }
    struct ListNode*retNode=dummyhead-&gt;next;
    free(dummyhead);
    return retNode;
    
}</code></pre> 
<p><img src="https://images2.imgbox.com/00/56/n9z3Xvtw_o.png" alt="3e3ee8879df64331b0cede8137ebe5bc.png"></p> 
<hr> 
<p>每天进步一点点，积少成多，大家一起努力！ </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/926f6e5129f495cfdd1fe5f0c1dbbd62/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">DS：链表的分类</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f82902ab0ee4f119f9bbdb0d9a43e7b8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JavaEE 初阶篇-深入了解 Junit 单元测试框架和 Java 中的反射机制（使用反射做一个简易版框架）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>