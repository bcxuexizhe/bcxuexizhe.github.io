<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring常见问题 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/e1ec0a156be3bdddafeb9b8e57762615/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Spring常见问题">
  <meta property="og:description" content="如何理解spring属于低侵入式设计？ 在代码中不需要写明具体依赖对象，在运行时进行自动注入，降低了组件的耦合依赖的是接口，而接口的实现类具有拓展性 Spring IOC 实现了什么功能，谈谈你对IOC的理解。 负责创建对象，管理对象（通过依赖注入（DI）装配对象、配置对象）并且管理这些对象的整个生命周期。
功能：
依赖注入（DI）： 生命周期管理：Spring
控制反转：将对象的创建权交由外部容器，将Bean加入IOC容器 Spring IOC
IOC容器还负责管理Bean的生命周期。它会根据配置来创建Bean，初始化Bean，以及在不再需要时销毁Bean。
配置集中管理：Spring IOC容器允许将应用的配置集中到一个或多个地方，使得配置的管理更加方便。
Spring提供了哪些实现DI的方式？ Spring提供了以下几种实现依赖注入（DI）的方式：
Setter注入：这是最常用的注入方式。Spring IOC容器通过调用Bean的setter方法，将依赖注入到Bean中。
构造器注入：Spring IOC容器通过调用Bean的构造器，并传入所需的依赖，来完成依赖注入。
注解注入：Spring还支持基于注解的依赖注入。例如，可以使用@Autowired注解来自动注入依赖。
自动装配注入：Spring IOC容器可以自动装配Bean的依赖。例如，如果一个Bean需要另一个Bean，Spring IOC容器可以自动找到并注入所需的Bean。
静态工厂注入：通过静态工厂方法返回的实例进行依赖注入。
实例工厂注入：通过实例工厂方法返回的实例进行依赖注入。
DI注入如何实现单例变多例，这个过程中产生的现象都是谁在管理？ [在Spring中，Bean默认是单例模式，也就是说，Spring IOC容器在初始化时会创建Bean的一个实例，并在整个应用中复用这个实例。但是，我们可以通过配置将单例模式变为多例模式]
实现单例变多例的方式主要有以下几种：
XML配置：在Bean的XML配置中，可以通过设置scope=&#34;prototype&#34;来实现多例模式
例如：
&lt;bean id=&#34;xxx&#34; class=&#34;全类名&#34; scope=&#34;prototype&#34;&gt;&lt;/bean&gt; 注解：可以使用@Scope(&#34;prototype&#34;)注解来使对象成为多例模式
例如：
@Component @Scope(&#34;prototype&#34;) public class SomeClass { // ... } [在这个过程中，所有的现象都是由Spring IOC容器来管理的。当我们将一个Bean配置为多例模式后，每次从Spring IOC容器中获取该Bean时，都会创建一个新的实例。
需要注意的是，多例模式在进行注入时，不能使用@Autowired，否则注入的还是单例模式。实现多例模式需要使用工厂模式例如，可以通过实现BeanFactoryAware接口来获得factory
此外，如果你想在一个请求的生命周期内保持Bean的实例是唯一的，你可以使用@Scope(&#34;request&#34;)或@Scope(&#34;session&#34;)。这两种模式分别表示在一次HTTP请求中和在一个会话中，被注解的Bean都是同一个Bean
OOP 和 AOP 的区别是什么？ OOP面向对象编程，纵向结构关系，关注类之间的关系.OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。它导致了大量代码的重复，而不利于各个模块的重用。
AOP可以说是OOP（Object Oriented
Programming，面向对象编程）的补充和完善。AOP面向切面编程，横向结构关系，关注类的内容.
剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块.使用AOP，可以在不修改原来代码的基础上添加新功能。
Spring 通过AOP实现了什么功能？这项技术你是如何使用的？ 【实现功能】
使用AOP，可以在不修改原来代码的基础上添加新功能。 模块化横切关注点：Spring
AOP将横切关注点（例如日志记录、事务管理、安全性检查等）从主业务逻辑代码中分离出来，以模块化的方式实现对这些关注点的管理和重用
动态代理:Spring AOP使用动态代理技术，在目标对象方法执行时将切面的逻辑织入到目标对象的方法中">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-23T17:35:36+08:00">
    <meta property="article:modified_time" content="2024-05-23T17:35:36+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring常见问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="spring_1"></a>如何理解spring属于低侵入式设计？</h3> 
<blockquote> 
 <ul><li>在代码中不需要写明具体依赖对象，在运行时进行自动注入，降低了组件的耦合</li><li>依赖的是接口，而接口的实现类具有拓展性</li></ul> 
</blockquote> 
<h3><a id="Spring_IOC_IOC_11"></a>Spring IOC 实现了什么功能，谈谈你对IOC的理解。</h3> 
<blockquote> 
 <p>负责创建对象，管理对象（通过依赖注入（DI）装配对象、配置对象）并且管理这些对象的整个生命周期。</p> 
 <p>功能：<br> 依赖注入（DI）： 生命周期管理：Spring<br> 控制反转：将对象的创建权交由外部容器，将Bean加入IOC容器 Spring IOC<br> IOC容器还负责管理Bean的生命周期。它会根据配置来创建Bean，初始化Bean，以及在不再需要时销毁Bean。<br> 配置集中管理：Spring IOC容器允许将应用的配置集中到一个或多个地方，使得配置的管理更加方便。</p> 
</blockquote> 
<h3><a id="SpringDI_26"></a>Spring提供了哪些实现DI的方式？</h3> 
<blockquote> 
 <p>Spring提供了以下几种实现依赖注入（DI）的方式：</p> 
 <ol><li> <p><strong>Setter注入</strong>：这是最常用的注入方式。Spring IOC容器通过调用Bean的setter方法，将依赖注入到Bean中。</p> </li><li> <p><strong>构造器注入</strong>：Spring IOC容器通过调用Bean的构造器，并传入所需的依赖，来完成依赖注入。</p> </li><li> <p><strong>注解注入</strong>：Spring还支持基于注解的依赖注入。例如，可以使用@Autowired注解来自动注入依赖。</p> </li><li> <p><strong>自动装配注入</strong>：Spring IOC容器可以自动装配Bean的依赖。例如，如果一个Bean需要另一个Bean，Spring IOC容器可以自动找到并注入所需的Bean。</p> </li><li> <p><strong>静态工厂注入</strong>：通过静态工厂方法返回的实例进行依赖注入。</p> </li><li> <p><strong>实例工厂注入</strong>：通过实例工厂方法返回的实例进行依赖注入。</p> </li></ol> 
</blockquote> 
<h3><a id="DI_43"></a>DI注入如何实现单例变多例，这个过程中产生的现象都是谁在管理？</h3> 
<blockquote> 
 <p>[在Spring中，Bean默认是单例模式，也就是说，Spring IOC容器在初始化时会创建Bean的一个实例，并在整个应用中复用这个实例。但是，我们可以通过配置将单例模式变为多例模式]</p> 
 <p>实现单例变多例的方式主要有以下几种：</p> 
 <ol><li> <p><strong>XML配置</strong>：在Bean的XML配置中，可以通过设置<code>scope="prototype"</code>来实现多例模式</p> <p>例如：</p> <pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>xxx<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>全类名<span class="token punctuation">"</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>prototype<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre> </li><li> <p><strong>注解</strong>：可以使用<code>@Scope("prototype")</code>注解来使对象成为多例模式</p> <p>例如：</p> <pre><code class="prism language-java"><span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span><span class="token string">"prototype"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SomeClass</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> </li></ol> 
 <p>[在这个过程中，所有的现象都是由Spring IOC容器来管理的。当我们将一个Bean配置为多例模式后，每次从Spring IOC容器中获取该Bean时，都会创建一个新的实例。</p> 
 <p>需要注意的是，多例模式在进行注入时，不能使用<code>@Autowired</code>，否则注入的还是单例模式。实现多例模式需要使用工厂模式例如，可以通过实现<code>BeanFactoryAware</code>接口来获得factory</p> 
 <p>此外，如果你想在一个请求的生命周期内保持Bean的实例是唯一的，你可以使用<code>@Scope("request")</code>或<code>@Scope("session")</code>。这两种模式分别表示在一次HTTP请求中和在一个会话中，被注解的Bean都是同一个Bean</p> 
</blockquote> 
<h3><a id="OOP__AOP__75"></a>OOP 和 AOP 的区别是什么？</h3> 
<blockquote> 
 <p><strong>OOP面向对象编程</strong>，纵向结构关系，关注类之间的关系.OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。它导致了大量代码的重复，而不利于各个模块的重用。<br> <strong>AOP</strong>可以说是OOP（Object Oriented<br> Programming，面向对象编程）的补充和完善。AOP面向切面编程，横向结构关系，关注类的内容.<br> 剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块.使用AOP，可以在不修改原来代码的基础上添加新功能。</p> 
</blockquote> 
<h3><a id="Spring_AOP_86"></a>Spring 通过AOP实现了什么功能？这项技术你是如何使用的？</h3> 
<blockquote> 
 <p>【实现功能】<br> 使用AOP，可以在不修改原来代码的基础上添加新功能。 模块化横切关注点：Spring<br> AOP将横切关注点（例如日志记录、事务管理、安全性检查等）从主业务逻辑代码中分离出来，以模块化的方式实现对这些关注点的管理和重用<br> 动态代理:Spring AOP使用动态代理技术，在目标对象方法执行时将切面的逻辑织入到目标对象的方法中</p> 
 <p>【使用】<br> 定义普通业务组件：这是我们的主业务逻辑，它包含了我们的核心功能。[切面类]<br> 定义切入点：切入点定义了哪些连接点上应该应用通知。切点通过表达式进行定义，如匹配所有 public<br> 方法或匹配某个包下的所有方法等。[编写切入表达式]<br> 定义增强处理：增强处理就是在AOP框架为普通业务组件织入的处理动作。这包括前置增强（Before Advice）、后置增强（After<br> Advice）、环绕增强（Around Advice）、异常增强（After Throwing Advice）等。[书写通知]</p> 
</blockquote> 
<h3><a id="AOP_105"></a>AOP的实现用到了哪种设计模式，它有哪些实现方式？</h3> 
<blockquote> 
 <p>Spring AOP（面向切面编程）的实现主要用到了以下设计模式：</p> 
 <ol><li><a href="https://blog.csdn.net/m0_56688298/article/details/119575228"><strong>代理模式</strong>：Spring AOP是围绕着代理模式设计的。这里的代理模式，其实就是指使用一个代理对象来控制对原对象的访问，这个代理对象在原对象的基础上增加了一些额外的功能</a>。</li><li><a href="https://blog.csdn.net/m0_56688298/article/details/119575228"><strong>工厂模式</strong>：在Spring AOP中，工厂模式主要用于创建代理对象和目标对象</a>。</li></ol> 
 <p>Spring AOP的实现方式主要有以下几种：</p> 
 <ol><li><a href="https://blog.csdn.net/m0_56688298/article/details/119575228"><strong>JDK动态代理</strong>：JDK动态代理主要针对目标对象的接口进行代理，动态生成接口的实现类</a><a href="https://zhuanlan.zhihu.com/p/146785040" rel="nofollow">2</a><a href="https://zhuanlan.zhihu.com/p/127009669" rel="nofollow">5</a><a href="https://blog.csdn.net/m0_56688298/article/details/119575228">。这种方式需要目标对象实现一个或多个接口，否则不能使用JDK动态代理</a>)。</li><li><a href="https://blog.csdn.net/m0_56688298/article/details/119575228"><strong>CGLIB代理</strong>：CGLIB代理可以针对类进行代理，生成目标类的子类</a><a href="https://zhuanlan.zhihu.com/p/146785040" rel="nofollow">2</a><a href="https://zhuanlan.zhihu.com/p/127009669" rel="nofollow">5</a><a href="https://blog.csdn.net/m0_56688298/article/details/119575228">。这种方式不需要目标对象实现接口，也可以进行代理</a>。</li><li><a href="https://blog.csdn.net/m0_56688298/article/details/119575228"><strong>Spring API实现AOP</strong>：通过实现Spring提供的AOP接口，如<code>MethodBeforeAdvice</code>、<code>AfterReturningAdvice</code>、<code>MethodInterceptor</code>等，来实现AOP</a>。</li><li><a href="https://blog.csdn.net/m0_56688298/article/details/119575228"><strong>自定义类实现AOP</strong>：通过自定义切入类和配置，来实现AOP</a>。通过使用Spring的<code>@Aspect</code>、<code>@Pointcut</code>、<code>@Before</code>、<code>@After</code>等注解，来实现AOP</li></ol> 
</blockquote> 
<h3><a id="_119"></a>理解什么是连接点、切面、切点、通知、目标对象、织入、引入。</h3> 
<blockquote> 
 <ul><li> <p>连接点 JoinPoint：要增强的哪些方法（目标方法）</p> </li><li> <p>通知 Advice：进行增强的重复逻辑，也就是共性的功能。（增强方法） 通知是切面在连接点处执行的代码，例如在方法调用前、方法调用后、方法抛出异常时执行的代码。通知可以分为<br> Before、After、AfterReturning、AfterThrowing 和 Around 五种类型</p> </li><li> <p>切入点 PointCut：匹配连接点的条件，通知仅会在切入点方法执行时被应用（为共性的功能标记目标方法）</p> </li><li> <p>切面 Aspect：，描述通知与切入点的对应关系（通知+切入点）【切面所在的类，我们一般称为切面类（被@Aspect注解标识的类）】</p> </li><li> <p>目标对象：Target，通知所应用的对象（要增强目标方法所在对象）</p> </li><li> <p>织入 weave：指把通知应用到目标上，生成代理对象的过程。</p> </li><li> <p>引入（Introduction）：引入允许我们向现有类添加新方法或属性</p> </li></ul> 
</blockquote> 
<h3><a id="Spring_135"></a>Spring是如何实现事务的？它和以往的实现有什么区别？</h3> 
<p><strong>实现：</strong></p> 
<blockquote> 
 <p><strong>Spring实现事务的方式主要是通过AOP（面向切面编程）和事务管理器</strong></p> 
 <p><strong>事务管理器（PlatformTransactionManager）</strong>：Spring的事务管理器是事务管理的顶层接口，它规定了事务的基本操作：创建事务，提交事务和回滚事务。<br> <strong>事务拦截器（TransactionInterceptor）</strong>：Spring的事务拦截器负责拦截带有@Transactional注解的方法。当这些方法被调用时，拦截器会在方法执行前后应用事务逻辑。<br> <strong>代理对象</strong>：Spring会为带有@Transactional注解的类生成一个代理对象，并将这个代理对象作为bean。【aop操作】 当这个代理对象的方法被调用时，如果该方法上存在@Transactional注解，那么代理逻辑会先把事务的自动提交设置为false，然后再去执行原本的业务逻辑方法。如果执行过程中没有出现异常，那么代理逻辑就会将事务提交，如果出现了异常，那么就会将事务进行回滚</p> 
</blockquote> 
<p><strong>区别:</strong></p> 
<blockquote> 
 <ul><li>具体事务的实现由第三方框架实现，避免我们直接进行事务操作！</li><li>声明式事务管理：Spring支持声明式事务管理，通过@Transactional注解或XML配置来声明开启事务，让Spring来接管事务的实现逻辑。这使得开发者只需要关注业务逻辑，而无需手动管理事务的生命周期。</li><li>事务传播行为和隔离级别：Spring提供了丰富的事务传播行为和隔离级别设置，可以更精细地控制事务的行为</li></ul> 
</blockquote> 
<h3><a id="_151"></a>事务的传播机制都有哪些？</h3> 
<blockquote> 
 <ol><li><strong>Propagation.REQUIRED：如果当前存在事务，则加入当前事务，否则创建一个新事务。【默认】</strong></li><li><strong>Propagation.REQUIRES_NEW：创建一个新事务，并在新事务中执行。如果当前存在事务，则挂起当前事务，即使新事务抛出异常，也不会影响当前事务</strong>。</li><li>Propagation.NESTED：如果当前存在事务，则在该事务中嵌套一个新事务，如果没有事务，则与Propagation.REQUIRED一样。</li><li>Propagation.SUPPORTS：如果当前存在事务，则加入该事务，否则以非事务方式执行。</li><li>Propagation.NOT_SUPPORTED：以非事务方式执行，如果当前存在事务，挂起该事务。</li><li>Propagation.MANDATORY：必须在一个已有的事务中执行，否则抛出异常。</li><li>Propagation.NEVER：必须在没有事务的情况下执行，否则抛出异常。</li></ol> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/772dab2bfa76384447eb399b7ffebbe7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前端项目使用docker编译发版和gitlab-cicd发版方式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/26c38ce757e2e57f9ef4d7db57c3b5b8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">绿色智能：AI机器学习在环境保护中的深度应用与实践案例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>