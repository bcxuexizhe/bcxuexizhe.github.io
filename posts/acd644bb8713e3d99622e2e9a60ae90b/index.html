<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>详解循环队列——链表与数组双版本 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/acd644bb8713e3d99622e2e9a60ae90b/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="详解循环队列——链表与数组双版本">
  <meta property="og:description" content="前言：本节内容主要是讲解循环队列。 在本篇中会讲到两个版本——数组版本、链表版本。本篇内容适合正在学习数据结构队列章节或者已经学过队列但对循环队列感觉模糊的友友们 。
首先先来看一下什么是循环队列
什么是循环队列 因为是刚开始讲解， 所以我们要先来看什么是循环队列：循环队列就是首和尾相连接的队列。如图分别是链表和数组形式的循环队列：
循环队列和普通队列的相同点是：都是从队尾进数据， 从队头出数据。
循环队列和普通队列的不同点是： 普通队列的容量是动态的， 会根据数据的增加而增加。 但是循环队列的容量是静态的， 它不会随着数据的增加而增加。 当队满时， 我们如果想要再添加数据， 只有将对头的数据取出来才能再次添加数据。 循环队列也被成为： 环形缓冲器。
数组版本 判断队空与队满 博主认为对于一个数组版本的循环队列来说， 最重要的就是如何判断它的队空与队满。我们先来看一下如何判断队空和队满
我们利用上图进行分析。 图中tail 和 head为两个指针。 队列中的数字不是存放的数据， 而是数组的下标索引。
我们假设初始化队空的时候tail 和 head指向同一块空间。 那么因为此时队空，所以tail 和head指向的这块空间内没有数据。
然后我们进行入队操作， 入队一个‘5’， 这个‘5’我用绿色用来表示存放的数据。如下图：
既然， ‘5’入队， 那么tail一定要向后移动一位， 所以结果就是上图的情况。 接下来我们再进行入队操作， 依次入队‘6’、‘1’、‘8‘、’6‘、’1‘。这些元素入队后的情况如下图： ok， 到了这一步请思考一下， 这个循环队列应该是此时为满， 还是应该再入队一个元素才满？ 我们在这里进行假设如果再入队一个元素为满。 那么再入队一个元素后，假设这个元素为‘5’，循环队列的情况就是这个样子：
现在， 请将这两个图对比着看：
要知道， 如果此时的状态为满， 那么判满的条件就是 tail == head ； 而判空的条件我们上面说到了也是 tail == head 。那么我们如何区分这个条件下到底是满还是空？所以我们的假设是错误的。真正为满的时候应该是这样的：
这个时侯其实就是该循环队列队满的情况。 那么为什么会空出来一个位置， 这个位置怎么处理？ 对于这个问题。 回答是循环队列的元素个数要比开的空间数小一。 当然有别的办法解决这个问题， 但是传统的数组循环队列， 这里就是这样处理的：元素个数的最大容量要比开的空间数小一。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-13T18:38:19+08:00">
    <meta property="article:modified_time" content="2024-05-13T18:38:19+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">详解循环队列——链表与数组双版本</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        <span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">前言：</span></strong></span>本节内容主要是讲解循环队列。 在本篇中会讲到两个版本——数组版本、链表版本。本篇内容适合正在学习数据结构队列章节或者已经学过队列但对循环队列感觉模糊的友友们 。</p> 
<p></p> 
<p>首先先来看一下什么是循环队列</p> 
<h2>什么是循环队列</h2> 
<p>        因为是刚开始讲解， 所以我们要先来看什么是循环队列：<span style="color:#be191c;"><strong><span style="background-color:#fff5e6;">循环队列就是首和尾相连接的队列</span></strong></span>。如图分别是链表和数组形式的循环队列：</p> 
<p><img alt="" height="371" src="https://images2.imgbox.com/2b/27/UybVZLP0_o.png" width="572"></p> 
<p><img alt="" height="409" src="https://images2.imgbox.com/40/e8/bUNfV9Pd_o.png" width="515"></p> 
<p>        <strong>循环队列</strong>和<strong>普通队列</strong>的<span style="color:#be191c;"><strong><span style="background-color:#ffd7b9;">相同点</span></strong></span>是：都是从队尾进数据， 从队头出数据。</p> 
<p>        <strong>循环队列</strong>和<strong>普通队列</strong>的<strong><span style="color:#be191c;"><span style="background-color:#ffd7b9;">不同点</span></span></strong>是： 普通队列的容量是<strong><span style="color:#fe2c24;">动态</span></strong>的， 会根据数据的增加而增加。 但是循环队列的容量是<strong><span style="color:#fe2c24;">静态</span></strong>的， 它不会随着数据的增加而增加。 当队满时， 我们如果想要再添加数据， 只有将对头的数据取出来才能再次添加数据。 循环队列也被成为： <span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">环形缓冲器</span></strong></span>。</p> 
<p></p> 
<h2>数组版本</h2> 
<h3>判断队空与队满</h3> 
<p>        博主认为对于一个数组版本的循环队列来说， 最重要的就是如何判断它的队空与队满。我们先来看一下如何判断队空和队满</p> 
<p>        <img alt="" height="424" src="https://images2.imgbox.com/a2/a6/yNS183gX_o.png" width="359"></p> 
<p>        我们利用上图进行分析。 图中tail 和 head为两个指针。 队列中的数字不是存放的数据， 而是数组的下标索引。</p> 
<p>        我们假设初始化队空的时候tail 和 head指向同一块空间。 那么因为此时队空，所以tail 和head指向的这块空间内没有数据。</p> 
<p>        然后我们进行入队操作， 入队一个‘5’， 这个‘5’我用绿色用来表示存放的数据。如下图：</p> 
<p><img alt="" height="733" src="https://images2.imgbox.com/61/b7/uqlybWjK_o.png" width="1200"></p> 
<p>        既然， ‘5’入队， 那么tail一定要向后移动一位， 所以结果就是上图的情况。 接下来我们再进行入队操作， 依次入队‘6’、‘1’、‘8‘、’6‘、’1‘。这些元素入队后的情况如下图：<img alt="" height="400" src="https://images2.imgbox.com/2f/ac/Rb4Yfe6g_o.png" width="591"> </p> 
<p>        ok， 到了这一步请思考一下， 这个循环队列<span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">应该是此时为满， 还是应该再入队一个元素才满</span></strong></span>？ </p> 
<p>        我们在这里进行假设如果再入队一个元素为满。 那么再入队一个元素后，假设这个元素为‘5’，循环队列的情况就是这个样子：</p> 
<p><img alt="" height="496" src="https://images2.imgbox.com/60/93/mLbSpWeC_o.png" width="447"></p> 
<p>现在， 请将这两个图对比着看：</p> 
<p><img alt="" height="654" src="https://images2.imgbox.com/9f/7a/gyDo7Rsq_o.png" width="1052"></p> 
<p>        要知道， 如果此时的状态为满， 那么判满的条件就是<span style="background-color:#ffd7b9;"> </span><span style="color:#be191c;"><strong><span style="background-color:#ffd7b9;">tail == head</span></strong></span> ； 而判空的条件我们上面说到了也是<span style="background-color:#ffd7b9;"> </span><span style="color:#be191c;"><strong><span style="background-color:#ffd7b9;">tail == head</span></strong></span> 。那么我们如何区分这个条件下到底是满还是空？所以我们的假设是错误的。真正为满的时候应该是这样的：</p> 
<p>        <img alt="" height="456" src="https://images2.imgbox.com/30/a9/L6jyIYVw_o.png" width="471"> </p> 
<p>        这个时侯其实就是该循环队列队满的情况。 那么为什么会空出来一个位置， 这个位置怎么处理？ 对于这个问题。 回答是循环队列的元素个数要比开的空间数小一。 当然<strong>有别的办法解决这个问题</strong>， 但是<strong>传统的数组循环队列， 这里就是这样处理的</strong>：<span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">元素个数的最大容量要比开的空间数小一</span></strong></span>。</p> 
<h3>入队和出队</h3> 
<p>        第二个重要的需要搞明白的就是对于数组循环队列来说的插入和删除。指针如何偏移的问题。 </p> 
<p><img alt="" height="148" src="https://images2.imgbox.com/fd/a5/ta3FysKi_o.png" width="113"></p> 
<p>        我们在上面画的这个圆是我们想象出来的逻辑结构， 而真正的数组应该是一串连续的空间。 如下图：</p> 
<p><img alt="" height="267" src="https://images2.imgbox.com/d1/97/ZoHEG6IW_o.png" width="906"></p> 
<p>        那么如果我们给这个队列入数据， 当队满时真正的物理结构其实是这种情况：</p> 
<p><img alt="" height="218" src="https://images2.imgbox.com/8c/05/Al7zxbSg_o.png" width="596"></p> 
<p>        逻辑结构是这样的情况：</p> 
<p><img alt="" height="317" src="https://images2.imgbox.com/35/a2/fZoANnjA_o.png" width="332"></p> 
<p>       </p> 
<p>        然后我们出一次数据：</p> 
<p>        这是物理结构：</p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/51/9e/vTZynBge_o.png" width="897"></p> 
<p>            这是逻辑结构：</p> 
<p><img alt="" height="327" src="https://images2.imgbox.com/fb/9f/3H6O8Ll2_o.png" width="450">     </p> 
<p>        从逻辑结构我们可以看出来循环队列这个时候已经不是队满了。 但是在真正的物理结构里我们如果入数据， 那么tail指针就会越界。 如何解决这个问题呢？</p> 
<p>        这里用到的是一点数学的运算。 </p> 
<p>        我们设这个循环队列的最大空间是数是：<span style="color:#38d8f0;"><strong>maxsize</strong></span>。那么我们只需要在每次入数据和出数据的时候让tail或者head模上一个maxsize就可以解决这个问题。 </p> 
<p>        比如图中tail == 6， maxsize == 7. 那么当tail向后移动一位时， 再取模变成<span style="color:#38d8f0;"><strong> (tail + 1) % maxsize</strong></span>；</p> 
<p>        所以， 综上，当tail 指针或者 head指针在进行入队或者出队时， 要进行的操作是 : <span style="color:#38d8f0;"><strong>(tail + 1) % maxsize</strong></span> 或者 <span style="color:#38d8f0;"><strong>(head + 1) % maxsize</strong></span>; </p> 
<h3>取对头和取队尾</h3> 
<p>        取对头比较简单， 因为head指针指向的位置就是对头的位置。如图：</p> 
<p><img alt="" height="395" src="https://images2.imgbox.com/2e/36/jQxAuS9f_o.png" width="407"></p> 
<p>这个时候我们直接取对头的数据 :</p> 
<pre><code class="language-cpp">data[head];  //伪代码</code></pre> 
<p>但是取队尾就可能有问题。 就像上图，此时tail指向了索引为0的位置。 然后在逻辑结构上面我们看到只要 tail - 1 就可以拿到索引为6的队尾数据5。但是要知道， 上图的是逻辑结构。 这个循环队列真正的物理结构应该是一块连续的数组， 就像下图这样：</p> 
<p><img alt="" height="175" src="https://images2.imgbox.com/43/e1/np3AWiRC_o.png" width="524">  </p> 
<p>        这个时候我们直接取 data[tail - 1]就会越界访问，显然是不正确的。</p> 
<p>        那么解决这个问题也是用取模的方法， 但是在取模的时候要先加上一个maxsize。也就是这样</p> 
<pre><code class="language-cpp">int index = (tail - 1 + maxsize) % maxsize;
data[index];    //伪代码</code></pre> 
<p>        当tail - 1 &gt;= 0的时候，加上maxsize 再模上maxsize相当于将加上的maxsize又消去了。 </p> 
<p>        当tail - 1 &lt; 0的时候， 加上maxsize就变成了小于maxsize的正数， 取模后还是它本身。 </p> 
<p> 以上， 就是取对头和取队尾的需要注意的事项。</p> 
<h3>代码</h3> 
<p>        知道了上面的知识点后， 我们就可以着手用代码实现我们的循环队列了。 由于知识点已经讲过了， 所以代码直接贴图了。部分内容会有注释， 但不做讲解。</p> 
<pre><code class="language-cpp">
//重定义数据类型。 便于维护
typedef int SQDataType;

typedef struct SeqQueue 
{
	SQDataType* _data;
	int _tail;
	int _head;
	int _maxsize;
}SQ; 


//初始化                     maxsize为循环队列的最大容量
void Init_SQ(SQ* sq, size_t maxsize) 
{
	sq-&gt;_maxsize = maxsize;
	sq-&gt;_data = (SQDataType*)malloc(sizeof(SQDataType) * maxsize);
	//
	sq-&gt;_tail = 0;
	sq-&gt;_head = 0;
}

//判断队满 
bool judge_full(SQ* sq) 
{
	return (sq-&gt;_tail + 1) % sq-&gt;_maxsize == sq-&gt;_head;    //逻辑上tail + 1 == head为队满
}

//判断队空
bool judge_empty(SQ* sq) 
{
	return sq-&gt;_tail == sq-&gt;_head;                         //当tail == head队空
}

//入队列
void Push_SQ(SQ* sq, SQDataType data)                      
{
	//先判断队列是否为满， 如果满了就返回
	if (judge_full(sq))
	{
		printf("队满\n");
		return;

	}

	sq-&gt;_data[sq-&gt;_tail] = data;
	sq-&gt;_tail = (sq-&gt;_tail + 1) % sq-&gt;_maxsize;               //入队列要取模
}

//出队列
void Pop_SQ(SQ* sq) 
{
	//判断队列是否为空， 如果为空就返回
	if (judge_empty(sq))                                     
	{
		printf("队空\n");
		return;
	}

	sq-&gt;_head = (sq-&gt;_head + 1) % sq-&gt;_maxsize;
}

//取对头数据
SQDataType Top_SQ(SQ* sq) 
{
	//判断是否为空
	if (judge_empty(sq))
	{
		printf("队空\n");
		exit(-1);
	}

	return sq-&gt;_data[sq-&gt;_head];
}

//取队尾数据
SQDataType Back_SQ(SQ* sq) 
{
	//判断是否为满
	if (judge_empty(sq))
	{
		printf("队空\n");
		exit(-1);
	}
    int index = ((sq-&gt;_tail - 1) + maxsize) % maxsize;
	return sq-&gt;_data[index];
}
</code></pre> 
<p></p> 
<h2>链表版本</h2> 
<h3>入出队以及取队中数据</h3> 
<p>        其实循环队列链表版本要比数组版本更加麻烦。 首先我在这里先抛出几个问题：</p> 
<p><img alt="" height="449" src="https://images2.imgbox.com/d7/9d/Cznphasu_o.png" width="368"></p> 
<p>        首先， 我们让这个循环队列的初始位置仍旧是tail == head。 那么它的队满位置由上面的学习我们知道是 tail-&gt;next == head;(下图中绿色数字表示节点中存放的数据)</p> 
<p>        <img alt="" height="386" src="https://images2.imgbox.com/a2/df/LcgudBBn_o.png" width="390">   </p> 
<blockquote> 
 <p>这里有两个问题： </p> 
 <ul><li><span style="color:#be191c;"><strong><span style="background-color:#ffd7b9;">我们如何取到队尾的元素？</span></strong></span></li><li><span style="color:#be191c;"><strong><span style="background-color:#ffd7b9;">我们如何进行出队和入队操作？出队需要释放节点吗？ 如果释放节点， 那么入队时是不是需要申请节点？又或者我们直接偏移指针就可以？ </span></strong></span></li></ul> 
</blockquote> 
<p>对于这两个问题， 我们先来思考一下第一个问题：</p> 
<p>        想要取到队尾元素， 就要拿到tail指向节点的前一个节点。 那么就有两个办法解决这个问题——第一个办法就是创建一个前置指针指向tail的前一个节点， 如图：</p> 
<p><img alt="" height="377" src="https://images2.imgbox.com/38/4b/ZCsxjjKh_o.png" width="478"></p> 
<p>        第二个办法就是弄成双向链表</p> 
<p><img alt="" height="459" src="https://images2.imgbox.com/8f/ed/KTcvOh7J_o.png" width="521"></p> 
<p>这样取队尾就可以直接访问tail的前一个节点。 </p> 
<p>        然后再思考第二个问题：我们在入队和出队的时候需要释放节点和申请节点吗？</p> 
<p>        那么请看如果我们释放节点的时候会发生什么情况？如图是该循环队列的某个状态：</p> 
<p><img alt="" height="519" src="https://images2.imgbox.com/29/53/JR9Qc4Aj_o.png" width="563"></p> 
<p>在这个状态下， 我们如果出队， 那么释放节点后让head指向下一个节点：</p> 
<p><img alt="" height="504" src="https://images2.imgbox.com/7a/b5/dTBhArf2_o.png" width="574"></p> 
<p>那么注意， 现在的容量减少了。 我们如果再进行入队， 假设我们入一个’5‘。 那么就变成了</p> 
<p><img alt="" height="484" src="https://images2.imgbox.com/f4/e9/ZTBQ9fAo_o.png" width="559"></p> 
<p>好， 现在我们再对比一下这个状态和开始的状态:</p> 
<p><img alt="" height="815" src="https://images2.imgbox.com/53/02/xp2zlzzp_o.png" width="1200"></p> 
<blockquote> 
 <p>        <strong>这两种状态， 是不是就是相当于head指针从一开始的指向1那个节点， 然后向后偏移一个节点。 而tail指针也相当于向后偏移了一个节点。 那么我们还有必要释放和申请节点来进行操作吗？ 是不是只要偏移指针就可以了？这样是不是减少了申请和释放节点的成本， 更快更简便？</strong></p> 
 <p>       <strong> 所以， 综上， 我们就可以推断出， <span style="color:#fe2c24;"><span style="background-color:#ffd900;">链表的入队和出队操作我们不必要申请和释放节点， 和数组版本一样， 只要指针偏移即可</span></span>。</strong> </p> 
</blockquote> 
<h3>循环队列的初始化</h3> 
<p>        链表循环队列另一个比较重要的要搞清楚的就是 这个队列的初始化结构是什么样的？</p> 
<p>        其实，我们在初始化的时候将所有节点开好就可以， 然后让tail指针和head指针指向同一个节点。如图：</p> 
<p><img alt="" height="651" src="https://images2.imgbox.com/d2/14/HCVhsxIi_o.png" width="580"></p> 
<p></p> 
<h3>代码</h3> 
<p>        知道上面的所有注意事项后， 我们就可以设计链表循环队列了。 这里使用前置prevtail解决取队尾的问题。 如下为代码：</p> 
<pre><code class="language-cpp">typedef int QDataType;

typedef struct QueueNode
{
	QDataType _data;
	QueueNode* _next;
}QNode;

struct Queue 
{
	QNode* _head;
	QNode* _tail;
	QNode* _prevtail;
};


//链表队列初始化
void Init_Q(Queue* pq, int n) 
{
	pq-&gt;_head = NULL;
	pq-&gt;_tail = NULL;
	QNode* cur = NULL;
	while (n) 
	{
		if (cur == NULL)  //创建第一个节点， head， tail ， prev都指向第一个节点 
		{
			cur = pq-&gt;_head = pq-&gt;_tail = pq-&gt;_prevtail = new QNode;
			cur-&gt;_next = NULL;
		}
		else              //创建之后的节点
		{
			cur-&gt;_next = new QNode;
			cur = cur-&gt;_next;
		}
		n--;
	}
	cur-&gt;_next = pq-&gt;_head; //成环
}

//判断空
bool Empty_Q(Queue* pq)
{
	return pq-&gt;_head == pq-&gt;_tail;
}

//判断队满
bool Full_Q(Queue* pq)
{
	return pq-&gt;_tail-&gt;_next == pq-&gt;_head;
}

//入队列
void Push_Q(Queue* pq, QDataType x) 
{
	if (Full_Q(pq)) 
	{
		printf("队满\n");
		return;

	}
	//将数据给tail，prev到tail的位置，tail向后偏移一位
	pq-&gt;_tail-&gt;_data = x;
	pq-&gt;_prevtail = pq-&gt;_tail;
	pq-&gt;_tail = pq-&gt;_tail-&gt;_next;
}

//出队列
void Pop_Q(Queue* pq) 
{
	if (Empty_Q(pq))
	{
		printf("队空\n");
		return;

	}

	//head指针向后移动一位即可
	pq-&gt;_head = pq-&gt;_head-&gt;_next;
}


//取队头
QDataType Front_Q(Queue* pq) 
{
	if (Empty_Q(pq))
	{
		printf("队空\n");
		return -1;

	}

	return pq-&gt;_head-&gt;_data;
}

//取队尾
QDataType Back_Q(Queue* pq) 
{

	if (Empty_Q(pq))
	{
		printf("队空\n");
		return -1;

	}
	return pq-&gt;_prevtail-&gt;_data;
}
</code></pre> 
<p><img alt="" height="351" src="https://images2.imgbox.com/e3/09/SZmfmS2t_o.png" width="630"></p> 
<p></p> 
<p>--------------------------------------------------------------------------------------------------------------------------------</p> 
<p>以上就是本节的全部内容。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ee9da9629140428924253503fc78ca8b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android 系统省电软件分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b24459880bf84d2861d0a41726a91cfc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构十三：八大排序算法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>