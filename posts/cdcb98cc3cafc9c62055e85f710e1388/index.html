<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【算法】【二叉树，DFS，哈希集合，分类讨论】力扣1110. 删点成林 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/cdcb98cc3cafc9c62055e85f710e1388/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【算法】【二叉树，DFS，哈希集合，分类讨论】力扣1110. 删点成林">
  <meta property="og:description" content="1110. 删点成林
文章目录 【算法】力扣【二叉树，DFS，哈希集合，分类讨论】1110. 删点成林题目描述示例 1：示例 2： 输入输出示例解释思路解析核心思想算法步骤复杂度分析 代码实现总结 【算法】力扣【二叉树，DFS，哈希集合，分类讨论】1110. 删点成林 题目描述 给出二叉树的根节点 root，树上每个节点都有一个不同的值。如果节点值在 to_delete 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。返回森林中的每棵树。你可以按任意顺序组织答案。
示例 1： 输入：root = [1,2,3,4,5,6,7], to_delete = [3,5]
输出：[[1,2,null,4],[6],[7]]
解释：
节点3被删除后，子节点6和7成为新的树的根节点。节点5被删除后，子节点4成为新的树的根节点。 示例 2： 输入：root = [1,2,4,null,3], to_delete = [3]
输出：[[1,2,4]]
解释：
节点3被删除后，没有新的树产生，剩余的树仍然是[1,2,4]。 输入输出示例解释 输入： root为二叉树的根节点to_delete为需要删除的节点值的列表 输出： 森林中每棵树的根节点列表 思路解析 核心思想 我们需要遍历二叉树，判断每个节点是否需要被删除。根据分类讨论：
如果当前节点需要被删除：
移除当前节点与父节点的连接递归处理其左右子树 如果当前节点不需要被删除：
如果父节点被删除，则当前节点是新树的根节点，加入结果集递归处理其左右子树 算法步骤 初始化：将to_delete列表转化为集合，方便O(1)时间复杂度判断。深度优先搜索（DFS）： 递归遍历二叉树。根据当前节点是否需要删除，决定是否断开与父节点的连接。根据父节点是否被删除，判断当前节点是否为新树的根节点。 返回结果：最终返回森林中的所有树的根节点。 复杂度分析 时间复杂度： O ( n ) O(n) O(n)，其中 n n n为二叉树的节点数，每个节点遍历一次。空间复杂度： O ( n ) O(n) O(n)，递归调用栈的深度为树的高度，最坏情况下为 O ( n ) O(n) O(n)。 代码实现 # Definition for a binary tree node.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-20T18:16:07+08:00">
    <meta property="article:modified_time" content="2024-05-20T18:16:07+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【算法】【二叉树，DFS，哈希集合，分类讨论】力扣1110. 删点成林</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p><a href="https://leetcode.cn/problems/delete-nodes-and-return-forest/" rel="nofollow">1110. 删点成林</a><br> </p> 
 <div class="toc"> 
  <h4>文章目录</h4> 
  <ul><li><a href="#DFS1110__5" rel="nofollow">【算法】力扣【二叉树，DFS，哈希集合，分类讨论】1110. 删点成林</a></li><li><ul><li><a href="#_7" rel="nofollow">题目描述</a></li><li><ul><li><a href="#_1_11" rel="nofollow">示例 1：</a></li><li><a href="#_2_25" rel="nofollow">示例 2：</a></li></ul> 
    </li><li><a href="#_35" rel="nofollow">输入输出示例解释</a></li><li><a href="#_43" rel="nofollow">思路解析</a></li><li><ul><li><a href="#_45" rel="nofollow">核心思想</a></li><li><a href="#_57" rel="nofollow">算法步骤</a></li><li><a href="#_66" rel="nofollow">复杂度分析</a></li></ul> 
    </li><li><a href="#_71" rel="nofollow">代码实现</a></li><li><a href="#_133" rel="nofollow">总结</a></li></ul> 
  </li></ul> 
 </div> 
 <p></p> 
</blockquote> 
<hr> 
<h2><a id="DFS1110__5"></a>【算法】力扣【二叉树，DFS，哈希集合，分类讨论】1110. 删点成林</h2> 
<h3><a id="_7"></a>题目描述</h3> 
<p>给出二叉树的根节点 <code>root</code>，树上每个节点都有一个不同的值。如果节点值在 <code>to_delete</code> 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。返回森林中的每棵树。你可以按任意顺序组织答案。</p> 
<h4><a id="_1_11"></a>示例 1：</h4> 
<p><img src="https://images2.imgbox.com/b8/4d/4Q8xfiFP_o.png" alt="在这里插入图片描述"></p> 
<p>输入：<code>root = [1,2,3,4,5,6,7]</code>, <code>to_delete = [3,5]</code></p> 
<p>输出：<code>[[1,2,null,4],[6],[7]]</code></p> 
<p><strong>解释：</strong></p> 
<ul><li>节点3被删除后，子节点6和7成为新的树的根节点。</li><li>节点5被删除后，子节点4成为新的树的根节点。</li></ul> 
<h4><a id="_2_25"></a>示例 2：</h4> 
<p>输入：<code>root = [1,2,4,null,3]</code>, <code>to_delete = [3]</code></p> 
<p>输出：<code>[[1,2,4]]</code></p> 
<p><strong>解释：</strong></p> 
<ul><li>节点3被删除后，没有新的树产生，剩余的树仍然是<code>[1,2,4]</code>。</li></ul> 
<h3><a id="_35"></a>输入输出示例解释</h3> 
<ul><li><strong>输入：</strong> 
  <ul><li><code>root</code>为二叉树的根节点</li><li><code>to_delete</code>为需要删除的节点值的列表</li></ul> </li><li><strong>输出：</strong> 
  <ul><li>森林中每棵树的根节点列表</li></ul> </li></ul> 
<h3><a id="_43"></a>思路解析</h3> 
<h4><a id="_45"></a>核心思想</h4> 
<p>我们需要遍历二叉树，判断每个节点是否需要被删除。根据分类讨论：</p> 
<ol><li> <p>如果当前节点需要被删除：</p> 
  <ul><li>移除当前节点与父节点的连接</li><li>递归处理其左右子树</li></ul> </li><li> <p>如果当前节点不需要被删除：</p> 
  <ul><li>如果父节点被删除，则当前节点是新树的根节点，加入结果集</li><li>递归处理其左右子树</li></ul> </li></ol> 
<h4><a id="_57"></a>算法步骤</h4> 
<ol><li><strong>初始化</strong>：将<code>to_delete</code>列表转化为集合，方便O(1)时间复杂度判断。</li><li><strong>深度优先搜索（DFS）</strong>： 
  <ul><li>递归遍历二叉树。</li><li>根据当前节点是否需要删除，决定是否断开与父节点的连接。</li><li>根据父节点是否被删除，判断当前节点是否为新树的根节点。</li></ul> </li><li><strong>返回结果</strong>：最终返回森林中的所有树的根节点。</li></ol> 
<h4><a id="_66"></a>复杂度分析</h4> 
<ul><li>时间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
       
         O(n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>，其中<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          n 
         
        
       
         n 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>为二叉树的节点数，每个节点遍历一次。</li><li>空间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
       
         O(n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>，递归调用栈的深度为树的高度，最坏情况下为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
       
         O(n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>。</li></ul> 
<h3><a id="_71"></a>代码实现</h3> 
<pre><code class="prism language-python"><span class="token comment"># Definition for a binary tree node.</span>
<span class="token comment"># class TreeNode:</span>
<span class="token comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="token comment">#         self.val = val</span>
<span class="token comment">#         self.left = left</span>
<span class="token comment">#         self.right = right</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">delNodes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">,</span> to_delete<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">:</span>
        
        <span class="token triple-quoted-string string">"""
        遍历二叉树在所难免，每个节点非删即不删，因此，我们先从分类讨论开始思考。

        如果当前节点要被删除，则：
            移除当前节点与上一个节点的连接

        否则：
            检查上一个节点是否被删除：
                如果上一个节点被删除，那么当前节点就是森林中的一棵树的根节点。
                否则，当前节点就不是根节点
        """</span>
        
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>fa<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> node<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> is_del<span class="token punctuation">:</span> <span class="token builtin">bool</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> node <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            
            <span class="token comment"># 保留父节点是否需要被删除这一信息</span>
            fa_is_del <span class="token operator">=</span> is_del
            
            <span class="token comment"># 获取当前节点是否需要被删除这一信息</span>
            is_del <span class="token operator">=</span> node<span class="token punctuation">.</span>val <span class="token keyword">in</span> to_delete

            <span class="token keyword">if</span> is_del<span class="token punctuation">:</span>
                <span class="token comment"># 如果当前节点需要删除，则断开与其父节点的连接</span>
                <span class="token keyword">if</span> node <span class="token operator">==</span> fa<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                    fa<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token boolean">None</span>
                <span class="token keyword">elif</span> node <span class="token operator">==</span> fa<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                    fa<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token boolean">None</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token comment"># 否则，根据父节点是否被删除，确定当前节点是否为一个子树的根节点</span>
                <span class="token keyword">if</span> fa_is_del<span class="token punctuation">:</span>
                    <span class="token comment"># 父节点被删除，当前节点是根节点</span>
                    ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
            
            <span class="token comment"># 递归遍历左右子树</span>
            dfs<span class="token punctuation">(</span>node<span class="token punctuation">,</span> node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> is_del<span class="token punctuation">)</span>
            dfs<span class="token punctuation">(</span>node<span class="token punctuation">,</span> node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> is_del<span class="token punctuation">)</span>

        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        to_delete <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span>to_delete<span class="token punctuation">)</span>  <span class="token comment"># 转为哈希集合，以O(1)的时间判断每个节点是否需要删除。</span>
        
        <span class="token comment"># 特殊情况：如果根节点不为空且根节点不在删除列表中，需要将根节点作为结果的一部分</span>
        <span class="token keyword">if</span> root <span class="token keyword">and</span> root<span class="token punctuation">.</span>val <span class="token keyword">not</span> <span class="token keyword">in</span> to_delete<span class="token punctuation">:</span>
            ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        
        dfs<span class="token punctuation">(</span>TreeNode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> root<span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span>
        
        <span class="token keyword">return</span> ans
</code></pre> 
<h3><a id="_133"></a>总结</h3> 
<p>本题通过DFS遍历二叉树，结合分类讨论的方法，逐步删除指定节点并生成新的森林。该算法有效地处理了节点删除后树结构的调整问题，并通过哈希集合优化删除判断的时间复杂度，最终实现了高效的解决方案。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/75a4f6df83a99c84dcce4e8ed5fd2a60/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Linux】进程信号及相关函数/系统调用的简单认识与使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/78fe36420d5266f131590e13d1c2162e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43;】探索STL中的高效容器：vector</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>