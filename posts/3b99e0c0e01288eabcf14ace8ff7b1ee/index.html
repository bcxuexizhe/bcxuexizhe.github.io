<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c语言常用操作符(2) - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/3b99e0c0e01288eabcf14ace8ff7b1ee/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="c语言常用操作符(2)">
  <meta property="og:description" content="1.移位操作符 移位操作符分为&lt;&lt;左移操作符和右移操作符&gt;&gt;
注：移位操作符的操作数只能是整数，同时移位操作符移动的是存储在内存中的二进制位（也就是补码）
同时移位操作符不要移动负数位，这个是标准未定义的。
1.&lt;&lt;操作符 移位规则：左边抛弃、右边补0
例1 #include&lt;stdio.h&gt; int main() { int a=10; int b=a&lt;&lt;1; printf(&#34;a=%d\n&#34;,a); printf(&#34;b=%d\n&#34;,b); return 0; } 由于a为正整数，所以补码与原码相同 所以b输出结果为20
例2 #include&lt;stdio.h&gt; int main() { int a = -1; int b = a &lt;&lt; 1; printf(&#34;a=%d\n&#34;, a); printf(&#34;b=%d\n&#34;, b); return 0; } 由于a为负整数，所以补码等于原码取反加一
所以输出b输出结果为-2
由以上例1与例2可以发现左移操作符有乘2的效果
2.&gt;&gt;操作符 在右移操作符不同于左移操作符，右移操作符有两种运算
1. 逻辑右移：左边用0填充，右边丢弃
2. 算术右移：左边用原该值的符号位填充，右边丢弃
例1 #include&lt;stdio.h&gt; int main() { int a = -1; int b = a &gt;&gt; 1; printf(&#34;a=%d\n&#34;, a); printf(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-08T17:00:38+08:00">
    <meta property="article:modified_time" content="2024-05-08T17:00:38+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c语言常用操作符(2)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2> 1.移位操作符</h2> 
<p>移位操作符分为&lt;&lt;左移操作符和右移操作符&gt;&gt;<br> 注：移位操作符的操作数只能是<strong>整数</strong>，同时移位操作符移动的是<strong>存储在内存中的二进制位</strong>（也就是<strong>补码</strong>）</p> 
<p>同时<span style="color:#fe2c24;"><strong>移位操作符不要移动负数位，这个是标准未定义的。</strong></span></p> 
<h3>1.&lt;&lt;操作符</h3> 
<p><strong><span style="color:#fe2c24;">移位规则：左边抛弃、右边补0</span></strong></p> 
<h5>例1</h5> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
int main()
{
  int a=10;
  int b=a&lt;&lt;1;
  printf("a=%d\n",a);
  printf("b=%d\n",b);

 return 0;
}</code></pre> 
<p><strong>由于a为正整数，所以补码与原码相同 </strong></p> 
<p><img alt="" height="354" src="https://images2.imgbox.com/42/41/ToLtyZIJ_o.png" width="1200"> 所以b输出结果为20<br><img alt="" height="710" src="https://images2.imgbox.com/c5/4b/UhAzOgGS_o.png" width="1200"></p> 
<h5>例2 </h5> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
int main()
{
	int a = -1;
	int b = a &lt;&lt; 1;
	printf("a=%d\n", a);
	printf("b=%d\n", b);

	return 0;
}</code></pre> 
<p><strong>由于a为负整数，所以补码等于原码取反加一</strong><br><img alt="" height="421" src="https://images2.imgbox.com/3e/2c/TXNpFNNn_o.png" width="973"></p> 
<p>所以输出b输出结果为-2<br><img alt="" height="674" src="https://images2.imgbox.com/d4/16/le88sB7G_o.png" width="1200"> 由以上例1与例2可以发现左移操作符有<strong>乘2的效果</strong></p> 
<h3> 2.&gt;&gt;操作符</h3> 
<p>在右移操作符不同于左移操作符，右移操作符有两种运算<br><strong>1. 逻辑右移：左边用0填充，右边丢弃<br> 2. 算术右移：左边用原该值的符号位填充，右边丢弃</strong></p> 
<h5> 例1</h5> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
int main()
{
	int a = -1;
	int b = a &gt;&gt; 1;
	printf("a=%d\n", a);
	printf("b=%d\n", b);

	return 0;
}</code></pre> 
<p><img alt="" height="456" src="https://images2.imgbox.com/2b/b3/A4slXJ6p_o.png" width="1200"> <img alt="" height="401" src="https://images2.imgbox.com/04/f2/mXjIvEks_o.png" width="1200"></p> 
<p>所以算数右移b等于-1，逻辑右移b等于一个很大的正整数 </p> 
<p><img alt="" height="544" src="https://images2.imgbox.com/16/fa/Z9poW96F_o.png" width="1200"></p> 
<p><strong>右移是采取算数右移还是逻辑右移是取决于编译器的 通常采取的都是<span style="color:#fe2c24;">算数右移</span></strong><br> 在vs中采取的也是<strong>算数右移</strong></p> 
<h5>例2</h5> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
int main()
{
	int a = 10;
	int b = a &gt;&gt; 1;
	printf("a=%d\n", a);
	printf("b=%d\n", b);

	return 0;
}</code></pre> 
<p> 以上代码输出结果为<img alt="" height="565" src="https://images2.imgbox.com/ea/cc/GKNQv4P5_o.png" width="1200"></p> 
<p>通过以上代码可以发现<strong>右移有除2的效果 </strong></p> 
<h2>2.位操作符</h2> 
<blockquote> 
 <p><strong>位操作符有：<br> &amp;  按位与<br> |    按位或<br> ^   按位异或<br> ~   按位取反</strong></p> 
</blockquote> 
<p><span style="color:#fe2c24;">注：位操作符的操作数必须是整数,同时位操作符是对</span><strong>存储在内存中的二进制位（</strong>也就是<strong>补码</strong>）<span style="color:#fe2c24;">进行运算</span></p> 
<p><img alt="" height="205" src="https://images2.imgbox.com/3d/24/Q5ExMc6K_o.png" width="682"></p> 
<p><span style="color:#0d0016;">在这不要将&amp;和|与之前讲到的&amp;&amp;和||混淆 <strong>&amp;&amp;和||关注的是操作符两端的真假 &amp;和|关注的是操作符两端的二进制序列</strong></span></p> 
<h3 style="background-color:transparent;">1.&amp; 按位与</h3> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
int main()
{
	int a = -7;
	int b = 6;
	int c = a &amp; b;
	printf("c=%d\n", c);

	return 0;
}</code></pre> 
<p>在以上代码中a&amp;b  首先我们知道&amp;是对操作数在内存中存储的二进制位进行运算，所以先将a和b的<strong>补码</strong>表示出来<strong>如下所示</strong><br><img alt="" height="481" src="https://images2.imgbox.com/50/b4/6GqUhrRH_o.png" width="1200"></p> 
<p>在<strong>按位与操作符</strong>中两个操作数对应二进制位<span style="color:#fe2c24;"><strong>有0则为0，俩个都为1时，才为1</strong></span> </p> 
<p>所以就可得出c的补码<br><img alt="" height="326" src="https://images2.imgbox.com/df/87/8mfbUT4i_o.png" width="977"></p> 
<p> <strong>最终c的结果为0</strong><br> 运行程序验证以上运算<br><img alt="" height="653" src="https://images2.imgbox.com/31/de/LaszKAPf_o.png" width="1200"></p> 
<h3>2.<strong>|  按位或</strong></h3> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
int main()
{
	int a = -7;
	int b = 6;
	int c = a | b;
	printf("c=%d\n", c);

	return 0;
}</code></pre> 
<p>将此先的代码再使用一遍，而这时将<strong>c=a | b </strong></p> 
<p> 在<strong>按位或操作符</strong>中两个操作数对应二进制位<span style="color:#fe2c24;"><strong>有1则为1，俩个都为0时，才为0</strong></span></p> 
<p>所以就可得出c的补码<br><img alt="" height="269" src="https://images2.imgbox.com/0f/09/CZo4nPKc_o.png" width="1028"></p> 
<p> <strong>最终c的结果为-1</strong><br> 运行程序验证以上运算<br><img alt="" height="494" src="https://images2.imgbox.com/74/f6/k8H1KuG4_o.png" width="1200"></p> 
<h3></h3> 
<h3>3.^   按位异或</h3> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
int main()
{
	int a = -7;
	int b = 6;
	int c = a ^ b;
	printf("c=%d\n", c);

	return 0;
}</code></pre> 
<p>在以上代码中用到了按位异或操作符，要得到c的结果首先要知道^的计算逻辑<br> 在<strong>按位异或操作符</strong>中两个操作数对应二进制位<span style="color:#fe2c24;"><strong>不同则为1，俩个相同时，才为0</strong></span><br>  <img alt="" height="261" src="https://images2.imgbox.com/d4/46/b9UM8BMR_o.png" width="948"></p> 
<p><strong>所以最终c输出结果为-1</strong><br> 运行程序验证以上运算<br><img alt="" height="517" src="https://images2.imgbox.com/8e/09/880ehnAm_o.png" width="1200"></p> 
<h3>4.~   按位取反  </h3> 
<p>按位取反操作符是将整数的<strong>二进制位全部取反</strong> </p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
int main()
{
	int a = -7;
	int b = 6;
	int c = a ^ b;
	int d = ~c;
	printf("d=%d\n", d);

	return 0;
}</code></pre> 
<p>例如在以上代码中<strong>对c按位取反</strong> 最终d输出结果为0<br><img alt="" height="267" src="https://images2.imgbox.com/5d/2b/cyEgGiT2_o.png" width="1013"></p> 
<p> 运行程序验证以上运算<br><img alt="" height="468" src="https://images2.imgbox.com/df/a5/LR72BCte_o.png" width="1200"></p> 
<h3>5.练习</h3> 
<h4>练习1.一道面试题</h4> 
<p><strong><span style="color:#fe2c24;">不能创建临时变量</span>（第三个变量），实现两个整数的交换。</strong><br>  </p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
int main()
{
	int a = 0;
	int b = 0;;
	scanf("%d %d", &amp;a, &amp;b);
	 a = a ^ b;
	 b = a ^ b;
	 a = a ^ b;
	printf("a=%d b=%d",a,b);

	return 0;
}</code></pre> 
<blockquote> 
 <p>要理解这种方法就要再了解一下^的一些特点 <br> 1.a^a=0<br> 2.a^0=a<br> 3.a^b^c=a^c^b=b^a^c=b^c^a=c^a^b=c^b^a(<strong>异或是支持交换率</strong>)</p> 
</blockquote> 
<p>来举一些例子让我们更好理解以上特点 </p> 
<p> <strong>例如</strong>：3^3操作符的二进制位都相同所以异或后都为0，所以最终3^3=0<br>             3^0操作符的二进制位都不同所以异或后都为原来3的二进制位，3^0=3<br>             1^2^3与3^2^1最终计算结果是相同的</p> 
<p>在此之后我们再来理解以上代码<br><img alt="" height="873" src="https://images2.imgbox.com/f1/76/4LlHrdO5_o.png" width="1200"></p> 
<p><strong>在b=a^b中的a=a^b,在最后的a=a^b中a=a^b b=a</strong></p> 
<p>运行程序验证以上运算<br><img alt="" height="530" src="https://images2.imgbox.com/06/2a/1cVDmJiq_o.png" width="1200"><br>        </p> 
<h4>练习2</h4> 
<p><strong>编写代码实现：求⼀个整数存储在内存中的二进制中1的个数 </strong></p> 
<p>我们知道要将一个数从十进制转换为二进制是需要通过不断整除2然后<strong>取出余数</strong><br> 所以我们可以想到以下方法来求一个数二进制中1的个数</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int Number(int n)
{
 int count=0;
 while(a)
 {
  if(a%2==1)
  {
   count++;
  }
  a=a/2;
 }
 return count;
}

int main()
{

 int a=0;
 scanf("%d",&amp;a);
 int n=Number(a);  
 printf("%d",n);

 return 0;
}</code></pre> 
<p>在以上方法会存在一个问题就是无法计算负数的二进制1的个数 这时有的读者会想到将形参用<strong>unsigned int</strong>，这种方法确实能解决问题 但有没有更好的方法呢？</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int Number(int a)
{
 int count=0;
 int i=0;
 for(i=0;i&lt;32;i++)
 {
  if((a&gt;&gt;i)&amp;1)
  {
   count++; 
  }
 }
 return count;
}

int main()
{

 int a=0;
 scanf("%d",&amp;a);
 int n=Number(a);  
 printf("%d",n);

 return 0;
}</code></pre> 
<p> 以上这种方法是将整数的二进制数的<strong>每一位都按位与1</strong>，若输出为1就count++；实现二进制位中1的计数 但这种方法也有一定的缺陷就是无论输入整数的二进制位中有几个1都需要将<strong>32位全部遍历一遍</strong>，这样会使得代码的效率不高 因此我们能否再设计一种方法来让统计出所有二进制1时就停止循环呢？</p> 
<p></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int Number(int a)
{
 int count=0;
 int i=0;
 while(n)
  {
   a=a&amp;(a-1);
   count++; 
  }
 return count;
}

int main()
{

 int a=0;
 scanf("%d",&amp;a);
 int n=Number(a);  
 printf("%d",n);

 return 0;
}</code></pre> 
<p> 要理解上面这种方法首先要了解<strong>n&amp;(n-1)结果的特点</strong></p> 
<p><strong>n&amp;(n-1)能将整数的二进制位中去除一个1</strong><br> 例如当n=5时<br><img alt="" height="428" src="https://images2.imgbox.com/6b/7d/idWDefgF_o.png" width="754"></p> 
<p>所以利用这种方法就可以在<strong>二进制位1的个数为0时不再继续执行程序</strong>，提升了程序的效率</p> 
<p></p> 
<h4 style="background-color:transparent;">练习3</h4> 
<p><strong>二进制位置0或者置1</strong></p> 
<blockquote> 
 <p><strong> 编写代码将13二进制序列的第5位修改为1，然后再改回0<br> 13的2进制序列： 00000000000000000000000000001101<br> 将第5位置为1后：00000000000000000000000000011101<br> 将第5位再置为0：00000000000000000000000000001101</strong></p> 
</blockquote> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{

 int a=13;
 printf("%d",a);
  a=a|(1&lt;&lt;4);
 printf("%d",a);
  a=a&amp;~(1&lt;&lt;4);
 printf("%d",a);
 return 0;
}</code></pre> 
<h2>3.逗号操作符</h2> 
<blockquote> 
 <p> 首先了解什么是逗号表达式<br> 1 exp1, exp2, exp3, …expN</p> 
</blockquote> 
<p>正如以上所示用逗号隔开的多个表达式就是<strong>逗号表达式，</strong>而这其中的逗号就是<strong>逗号操作符</strong></p> 
<p><strong>逗号表达式中有一特点</strong>：从左向右依次执行并计算，整个表达式的<span style="color:#fe2c24;"><strong>结果是最后⼀个表达式的结果</strong></span></p> 
<pre><code class="language-cpp">int a = 1;
int b = 2;
int c = (a&gt;b, a=b+10, a, b=a+1);//逗号表达式
c是多少？</code></pre> 
<p> 在以上代码中c的等号右边是<strong>一个逗号表达式</strong>，要<strong>从左向右计算</strong>得出的才是正确结果，因为<strong>前面表达式的计算可能会影响后面表达式的计算</strong><br> a=b+10=12后b=a+1=13 所以最终c=13</p> 
<blockquote> 
 <p>逗号表达式同时还能在if；while等语句的判断部分使用，起到简化代码的作用</p> 
 <pre><code class="language-cpp">a = get_val();
count_val(a);
while (a &gt; 0)
{
//业务处理
//...
a = get_val();
count_val(a);
}
</code></pre> 
 <p>如果使用逗号表达式就可以简化为：</p> 
 <pre><code class="language-cpp">while (a = get_val(), count_val(a), a&gt;0)
{
//业务处理
}</code></pre> 
</blockquote> 
<h2>4.下标访问操作符、函数调用操作符</h2> 
<h3>1. [ ] 下标引用操作符 </h3> 
<blockquote> 
 <pre><code class="language-cpp">int arr[4]={1，2，3，4}；
int n=arr[3];</code></pre> 
 <p>arr[3]表示数组下标为3的元素是4 这里面的<strong>[]</strong>就是<strong>下标引用操作符 </strong>arr[3]中<strong><span style="color:#fe2c24;">操作数</span></strong>是<strong>arr和3</strong> </p> 
</blockquote> 
<p>由此可见 [ ]下标引用操作符也是<strong>双目操作符</strong> </p> 
<p>注：在int arr[4]中的[ ]是<strong>用来指定数组元素大小</strong>，<strong>不是在访问数组的某个元素</strong>，所以<strong><span style="color:#fe2c24;">不是</span></strong>下标引用操作符</p> 
<blockquote> 
 <h3>2.函数调用操作符</h3> 
 <pre><code class="language-cpp">#include&lt;stdio.h&gt;
int Add(int x,int y)
{
  return x+y;
}

int main()
{
int a=0;
scanf("%d %d",&amp;a,&amp;b);
printf("%d %d\n",a,b);
int n=Add(a,b);
printf("%d",n);
return 0;
}
</code></pre> 
 <p>在以上代码中库函数printf和自定义函数Add后的括号都是<strong>函数调用操作符<br> 其中Add后()的操作数是Add ，3，5</strong></p> 
</blockquote> 
<p><strong>那函数调用操作符至少有几个操作数呢？<br> 答案是<span style="color:#fe2c24;">至少有一个</span>，原因是在调用时候<span style="color:#fe2c24;">函数名不可省略</span>，但参数可能为0</strong></p> 
<h2>5. 结构成员访问操作符</h2> 
<p>但要描述一个复杂对象时单一的数据类型已经不足以实现，C语言为了解决这个问题，增加了<strong>结构体</strong>这种自定义的数据类型，让程序员可以自己创造适合的类型。</p> 
<blockquote> 
 <p>📌 结构是⼀些值的集合，这些值称为成员变量。结构的每个成员可以是<strong>不同类型的变量</strong>，如：<br> 标量、数组、指针，甚至是其他结构体。</p> 
</blockquote> 
<h3>1.结构的声明 </h3> 
<p>在结构体的声明要用到<strong>struct关键字</strong><br>  </p> 
<pre><code class="language-cpp">struct tag//tag的名字可是自定义的
{
member-list;//成员列表
}variable-list;//变量列表</code></pre> 
<p>例如用struct定义一个学生类型<br>  </p> 
<pre><code class="language-cpp">struct Stu//学生类型
{
char name[20];//名字
int age;//年龄
char sex[5];//性别
char id[20];//学号
}; //分号不能丢</code></pre> 
<h3>2.结构体变量的定义和初始化</h3> 
<h4><strong>变量的定义</strong> </h4> 
<pre><code class="language-cpp">struct Stu//学生类型
{
char name[20];//名字
int age;//年龄
char sex[5];//性别
char id[20];//学号
}s3,s4;

struct student s2;

int main()
{
 struct student s1;

 return 0;
}
</code></pre> 
<p>正如以上所示变量的创建可以是<strong>全局变量</strong>也可以是<strong>局部变量</strong>，还可以<strong>在结构体声明的末端</strong></p> 
<h4> 变量的初始化</h4> 
<pre><code class="language-cpp">struct Stu        //类型声明
{
char name[15];//名字
int age;//年龄
};

struct Stu s1 = {"zhangsan", 20};//初始化

struct Node
{
int data;
struct Stu p;
 int arr[4];
}n1 = {1,{"zhangsan", 20},{1,2,3,4},};//结构体嵌套初始化

struct Node n2 = {6,{"lisi", 19},{9,2,5,4},};//结构体嵌套初始化
</code></pre> 
<h4><strong>结构成员访问操作符</strong></h4> 
<p><strong>结构体成员的直接访问是通过点操作符（.）访问的。<br> 使用方式：<span style="color:#fe2c24;">结构体变量.成员名</span></strong></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
struct Stu        //类型声明
{
char name[15];//名字
int age;//年龄
};

struct Stu s1 = {"zhangsan", 20};//初始化

struct Node
{
int data;
struct Stu p;
 int arr[4];
}n1 = {1,{"zhangsan", 20},{1,2,3,4},};//结构体嵌套初始化

struct Node n2 = {6,{"lisi", 19},{9,2,5,4},};//结构体嵌套初始化

int main()
{

printf("%d %s %d %d",n2.data,n2.p.name,n2.p.age,n2.arr[1]);

 return 0;
}</code></pre> 
<p> 代码运行结果</p> 
<p><img alt="" height="530" src="https://images2.imgbox.com/0d/e4/aBJEMZFL_o.png" width="1200"> </p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7ed6499757186abc7eb63c5c3067ae88/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c&#43;&#43;笔记——概述运算符重载——解析运算符重载的难点</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a0fa4906cc5fe2e5bf8531e3de57009e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Java】Java基础 使用集合实现斗地主分牌</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>