<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Java--数据结构】模拟实现ArrayList - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/acb05b2bc8af2f45cd5e897d1e87597a/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【Java--数据结构】模拟实现ArrayList">
  <meta property="og:description" content="欢迎关注个人主页：逸狼
创造不易，可以点点赞吗~
如有错误，欢迎指出~
目录
LIst
顺序表ArrayList
顺序表优点
IList接口
ArrayList中定义要操作的数组
在MyArrayList中 重写接口方法
新增元素
在指定位置插入元素
pos不合法异常
判断和查找元素
获取和更新元素
删除元素和清空顺序表
获取顺序表的长度和打印顺序表
LIst List是个接口，并不能直接用来实例化。 如果要使用，必须去实例化List的实现类。在集合框架中，ArrayList和LinkedList都实现了List接口。
ArrayList：实现了List接口，底层为动态类型顺序表LinkedList：实现了List接口，底层为双向链表 Java类和接口总览
顺序表ArrayList 顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存储。在数组上完成 数据的增删查改。
顺序表优点 适合根据 下标进行 查找 和 更新 的场景
访问速度比较快（在给定下标的情况下可以达到O（1））
下面我们要自己模拟实现一个 顺序表MyArrayList,理解它底层的数据结构原理，方便我们未来更好的使用ArrayList中的方法。
IList接口 package arrayList; public interface IList { // 新增元素,默认在数组最后新增 void add(int data); // 在 pos 位置新增元素 void add(int pos, int data) ; // 判定是否包含某个元素 boolean contains(int toFind); // 查找某个元素对应的位置 int indexOf(int toFind) ; // 获取 pos 位置的元素 int get(int pos) ; //给 pos 位置的元素设为 value void set(int pos, int value) ; //删除第一次出现的关键字key void remove(int toRemove) ; // 获取顺序表长度 int size() ; // 清空顺序表 void clear(); // 打印顺序表，注意：该方法并不是顺序表中的方法，为了方便看测试结果给出的 void display() ; boolean isFull(); } ArrayList中定义要操作的数组 package arrayList; import java.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-23T20:00:35+08:00">
    <meta property="article:modified_time" content="2024-04-23T20:00:35+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java--数据结构】模拟实现ArrayList</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <h2 style="background-color:transparent;"></h2> 
 <p style="text-align:center;"><img alt="" height="1055" src="https://images2.imgbox.com/4d/96/g5Zjk8Yz_o.png" width="1200"></p> 
 <p style="text-align:center;">欢迎关注个人主页：<a href="https://blog.csdn.net/2301_80898480" title="逸狼">逸狼</a></p> 
 <hr> 
 <p style="text-align:center;">创造不易，可以点点赞吗~</p> 
 <p style="text-align:center;">如有错误，欢迎指出~</p> 
 <hr> 
 <hr> 
 <p id="main-toc"><strong>目录</strong></p> 
 <p id="-toc" style="margin-left:0px;"></p> 
 <p id="LIst-toc" style="margin-left:0px;"><a href="#LIst" rel="nofollow">LIst</a></p> 
 <p id="%E9%A1%BA%E5%BA%8F%E8%A1%A8ArrayList-toc" style="margin-left:0px;"><a href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8ArrayList" rel="nofollow">顺序表ArrayList</a></p> 
 <p id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%BC%98%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%BC%98%E7%82%B9" rel="nofollow">顺序表优点</a></p> 
 <p id="IList%E6%8E%A5%E5%8F%A3-toc" style="margin-left:0px;"><a href="#IList%E6%8E%A5%E5%8F%A3" rel="nofollow">IList接口</a></p> 
 <p id="ArrayList%E4%B8%AD%E5%AE%9A%E4%B9%89%E8%A6%81%E6%93%8D%E4%BD%9C%E7%9A%84%E6%95%B0%E7%BB%84-toc" style="margin-left:0px;"><a href="#ArrayList%E4%B8%AD%E5%AE%9A%E4%B9%89%E8%A6%81%E6%93%8D%E4%BD%9C%E7%9A%84%E6%95%B0%E7%BB%84" rel="nofollow">ArrayList中定义要操作的数组</a></p> 
 <p id="%E5%9C%A8MyArrayList%E4%B8%AD%20%E9%87%8D%E5%86%99%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E5%9C%A8MyArrayList%E4%B8%AD%20%E9%87%8D%E5%86%99%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95" rel="nofollow">在MyArrayList中 重写接口方法</a></p> 
 <p id="%E6%96%B0%E5%A2%9E%E5%85%83%E7%B4%A0-toc" style="margin-left:40px;"><a href="#%E6%96%B0%E5%A2%9E%E5%85%83%E7%B4%A0" rel="nofollow">新增元素</a></p> 
 <p id="%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0-toc" style="margin-left:40px;"><a href="#%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0" rel="nofollow">在指定位置插入元素</a></p> 
 <p id="%C2%A0pos%E4%B8%8D%E5%90%88%E6%B3%95%E5%BC%82%E5%B8%B8-toc" style="margin-left:80px;"><a href="#%C2%A0pos%E4%B8%8D%E5%90%88%E6%B3%95%E5%BC%82%E5%B8%B8" rel="nofollow"> pos不合法异常</a></p> 
 <p id="%E5%88%A4%E6%96%AD%E5%92%8C%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0-toc" style="margin-left:40px;"><a href="#%E5%88%A4%E6%96%AD%E5%92%8C%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0" rel="nofollow">判断和查找元素</a></p> 
 <p id="%E8%8E%B7%E5%8F%96%E5%92%8C%E6%9B%B4%E6%96%B0%E5%85%83%E7%B4%A0-toc" style="margin-left:40px;"><a href="#%E8%8E%B7%E5%8F%96%E5%92%8C%E6%9B%B4%E6%96%B0%E5%85%83%E7%B4%A0" rel="nofollow">获取和更新元素</a></p> 
 <p id="%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E5%92%8C%E6%B8%85%E7%A9%BA%E9%A1%BA%E5%BA%8F%E8%A1%A8-toc" style="margin-left:40px;"><a href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E5%92%8C%E6%B8%85%E7%A9%BA%E9%A1%BA%E5%BA%8F%E8%A1%A8" rel="nofollow">删除元素和清空顺序表</a></p> 
 <p id="%E8%8E%B7%E5%8F%96%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6%E5%92%8C%E6%89%93%E5%8D%B0%E9%A1%BA%E5%BA%8F%E8%A1%A8-toc" style="margin-left:40px;"><a href="#%E8%8E%B7%E5%8F%96%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6%E5%92%8C%E6%89%93%E5%8D%B0%E9%A1%BA%E5%BA%8F%E8%A1%A8" rel="nofollow">获取顺序表的长度和打印顺序表</a></p> 
 <hr id="hr-toc"> 
 <p></p> 
</blockquote> 
<h2 id="LIst" style="background-color:transparent;">LIst</h2> 
<p>List是个接口，并不能直接用来实例化。 如果要使用，<strong>必须去实例化List的实现类</strong>。在集合框架中，ArrayList和LinkedList都实现了List接口。</p> 
<ul><li>ArrayList：实现了List接口，底层为动态类型顺序表</li><li>LinkedList：实现了List接口，底层为双向链表</li></ul> 
<p></p> 
<p><img alt="" height="591" src="https://images2.imgbox.com/03/a7/rUMl5IEx_o.png" width="1200"></p> 
<p style="text-align:center;"> Java类和接口总览</p> 
<p><img alt="" height="280" src="https://images2.imgbox.com/66/3b/4S80eily_o.png" width="1016"></p> 
<h2 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8ArrayList" style="background-color:transparent;">顺序表ArrayList</h2> 
<p>顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存储。在数组上完成 数据的增删查改。</p> 
<p><img alt="" height="144" src="https://images2.imgbox.com/d0/03/RulIara6_o.png" width="645"></p> 
<h3 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%BC%98%E7%82%B9" style="background-color:transparent;">顺序表优点</h3> 
<p>适合根据<strong> 下标进行 查找 和 更新 </strong>的场景</p> 
<p>访问速度比较快（在给定下标的情况下可以达到<strong>O（1）</strong>）</p> 
<p>下面我们要自己模拟实现一个 顺序表MyArrayList,理解它底层的数据结构原理，方便我们未来更好的使用ArrayList中的方法。</p> 
<p><img alt="" height="944" src="https://images2.imgbox.com/be/e0/GNASGd5I_o.png" width="460"></p> 
<h2 id="IList%E6%8E%A5%E5%8F%A3" style="background-color:transparent;">IList接口</h2> 
<pre><code>package arrayList;

public interface IList {
     // 新增元素,默认在数组最后新增
     void add(int data);
     // 在 pos 位置新增元素
     void add(int pos, int data) ;
     // 判定是否包含某个元素
     boolean contains(int toFind);
     // 查找某个元素对应的位置
     int indexOf(int toFind) ;
     // 获取 pos 位置的元素
     int get(int pos) ;
     //给 pos 位置的元素设为 value
     void set(int pos, int value) ;
     //删除第一次出现的关键字key
     void remove(int toRemove) ;
     // 获取顺序表长度
     int size() ;
     // 清空顺序表
     void clear();
     // 打印顺序表，注意：该方法并不是顺序表中的方法，为了方便看测试结果给出的
     void display() ;

     boolean isFull();
}</code></pre> 
<h2 id="ArrayList%E4%B8%AD%E5%AE%9A%E4%B9%89%E8%A6%81%E6%93%8D%E4%BD%9C%E7%9A%84%E6%95%B0%E7%BB%84" style="background-color:transparent;">ArrayList中定义要操作的数组</h2> 
<pre><code>package arrayList;

import java.util.Arrays;
//定义顺序表，实现IList 接口
public class MyArrayList implements IList{

    //定义要操作的数组
    public int[]elem;
    public int usedSize;//数组中存储的数据个数

    public MyArrayList(){
        this.elem=new int[10];//表示数组长度是10

    }</code></pre> 
<h2 id="%E5%9C%A8MyArrayList%E4%B8%AD%20%E9%87%8D%E5%86%99%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95" style="background-color:transparent;">在MyArrayList中 重写接口方法</h2> 
<h3 id="%E6%96%B0%E5%A2%9E%E5%85%83%E7%B4%A0">新增元素</h3> 
<pre><code>    @Override     // 新增元素,默认在数组最后新增
    public void add(int data) {
        //如果满了，要扩容
        if(isFull()){
            //扩容
            elem= Arrays.copyOf(elem,2*elem.length);
        }
        this.elem[usedSize]=data;
        this.usedSize++;
    }

    @Override//用于判断顺序表是否满了
    public boolean isFull() {
        return usedSize==elem.length;
    }</code></pre> 
<h3 id="%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0">在指定位置插入元素</h3> 
<pre><code>@Override     // 在 pos 位置新增元素
    public void add(int pos, int data) {
        //插入数据的时候一定要保证插入的位置前面有数据
        try{
            checkPosOfAdd(pos);
        }catch (PosNotLegalException e){
            e.printStackTrace();
        }
        //判断是否满了
        if(isFull()){
            elem= Arrays.copyOf(elem,2*elem.length);
        }
        //移动元素
        for (int i = usedSize-1; i&gt;=pos  ; i--) {
            elem[i+1]=elem[i];
        }
        //插入元素
        elem[pos]=data;
        usedSize++;
    }

    //该方法用来 判断添加元素时 pos是否合法
    private void checkPosOfAdd(int pos){
        if(pos&lt;0||pos&gt;usedSize){
            throw new PosNotLegalException("在pos位置插入元素时Pos位置不合法。。。");//抛出一个异常
        }
    }</code></pre> 
<h4 id="%C2%A0pos%E4%B8%8D%E5%90%88%E6%B3%95%E5%BC%82%E5%B8%B8"> pos不合法异常</h4> 
<pre><code>package arrayList;
//定义一个异常，用于对pos不合法时的报警
public class PosNotLegalException extends RuntimeException{
    public PosNotLegalException(){

    }
    public PosNotLegalException(String msg){
        super(msg);
    }
}
</code></pre> 
<h3 id="%E5%88%A4%E6%96%AD%E5%92%8C%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0">判断和查找元素</h3> 
<pre><code>    @Override     // 判定是否包含某个元素
    public boolean contains(int toFind) {
        //只需要找usedSize次
        for (int i = 0; i &lt; usedSize; i++) {
            if(elem[i]==toFind){
                return true;
            }
        }
        return false;
    }

    @Override     // 查找某个元素对应的位置
    public int indexOf(int toFind) {
        for (int i = 0; i &lt; usedSize; i++) {
            if(elem[i]==toFind){
                return i;//与上面contains方法的代码一样，只是返回的是下标
            }
        }
        return -1;
    }</code></pre> 
<h3 id="%E8%8E%B7%E5%8F%96%E5%92%8C%E6%9B%B4%E6%96%B0%E5%85%83%E7%B4%A0">获取和更新元素</h3> 
<pre><code> //get/set时，判断pos是否合法
    private void checkPosOfGet(int pos)throws PosNotLegalException{
        if(pos&lt;0||pos&gt;=usedSize){
            throw new PosNotLegalException("get/set获取元素的时候pos位置不合法。。。");
        }
    }
    @Override     // 获取 pos 位置的元素
    public int get(int pos) {
        try{
            checkPosOfGet(pos);
        }catch (PosNotLegalException e){
            e.printStackTrace();
        }
        return elem[pos];
    }

    @Override     //给 pos 位置的元素设为 value   更新pos位置的值为value
    public void set(int pos, int value) {
        try{
            checkPosOfGet(pos);
        }catch (PosNotLegalException e){
            e.printStackTrace();
        }
        elem[pos]=value;
    }</code></pre> 
<h3 id="%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E5%92%8C%E6%B8%85%E7%A9%BA%E9%A1%BA%E5%BA%8F%E8%A1%A8">删除元素和清空顺序表</h3> 
<pre><code> @Override     //删除第一次出现的关键字key
    public void remove(int toRemove) {
        //要查找是否查找要删除的关键字 toRemove
        int pos =indexOf(toRemove);
        if(pos==-1){
            System.out.println("没有要删除的数字！");
            return;
        }
        for (int i = 0; i &lt; usedSize-1; i++) {
            elem[i]=elem[i+1];
        }
        usedSize--;
    }


    @Override     // 清空顺序表
    public void clear() {
        //1.如果是数组元素，直接将usedSize置为0
        //2.如果是引用类型，则置为null
        /*        for (int i = 0; i &lt; usedSize; i++) {
            elem[i]=null;
        }*/
        usedSize=0;//这里是数组


    }</code></pre> 
<h3 id="%E8%8E%B7%E5%8F%96%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6%E5%92%8C%E6%89%93%E5%8D%B0%E9%A1%BA%E5%BA%8F%E8%A1%A8">获取顺序表的长度和打印顺序表</h3> 
<pre><code>@Override     // 获取顺序表长度
    public int size() {
        return usedSize;
    }

    @Override //打印顺序表
    public void display() {
        for (int i = 0; i &lt; usedSize; i++) {
            System.out.print(elem[i]+" ");
        }
        System.out.println();
    }

</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/344b6ec242a75a0508057622ceea74f9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HBase的简单学习三</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/82143de029ee31a4ce1e305089deb200/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">本地环境运行Llama 3大型模型：可行性与实践指南</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>