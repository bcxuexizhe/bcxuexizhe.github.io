<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux 进程 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/f1f6a55546ba960809591977ab7743e1/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Linux 进程">
  <meta property="og:description" content="文章目录 冯诺依曼体系 操作系统为什么要有操作系统系统调用和库函数概念进程的组成如何理解进程动态运行系统调用接口和用户操作接口 进程PCBPIDPCB和PIDgetpid()getppid()获取父进程pid`fork()` 创建进程父子进程为什么要创建子进程/proc 目录内查看进程文件夹chdir()改变进程的工作目录 进程状态查看进程状态R运行状态S睡眠状态D磁盘休眠状态t状态T停止状态X死亡状态Z僵尸状态危害杀死僵尸进程 孤儿进程杀死进程并发和并行阻塞态挂起态CPU内的寄存器挂起态CPU内的寄存器 冯诺依曼体系 任何计算机系统都包含一个基本的程序集合，称为操作系统(OS)
笼统的理解，操作系统包括：内核（进程管理，内存管理，文件管理，驱动管理）其他程序（例如函数库， shell程序等等） 操作系统 为什么要有操作系统 操作系统对下&lt;手段&gt;进行软硬件管理工作，对上层提供良好（稳定、安全、高效）的运行环境&lt;目的&gt;。
系统调用和库函数概念 在开发角度，操作系统对外会表现为一个整体，但是会暴露自己的部分接口，供上层开发使用，这部分由操作系统提供的接口，叫做系统调用。
系统调用在使用上，功能比较基础，对用户的要求相对也比较高，所以，有心的开发者可以对部分系统调用进行适度封装，从而形成库，有了库，就很有利于更
层用户或者开发者进行二次开发。
进程的组成 一个进程内包括 内核task_struct结构体&#43;程序的代码和数据
如何理解进程动态运行 只要我们的进程task_struct，将来在不同的队列中，进程就可以访问不同的资源
系统调用接口和用户操作接口 系统调用接口是操作系统提供给用户程序的接口，用于请求操作系统内核提供的服务和功能。
用户操作接口是用户程序提供给用户自身或其他用户程序的接口，用于实现用户程序的功能和交互。
进程 PCB 定义：PCB是操作系统中用于管理和维护进程信息的数据结构。每个进程都有对应的 PCB，用于存储进程的状态、优先级、程序计数器、内存分配情况、打开文件列表等信息。作用：PCB用于跟踪和管理进程的运行状态，操作系统通过维护 PCB 来管理进程的调度、资源分配和状态转换。内容：PCB 包含了进程的所有关键信息，如进程标识符（PID）、程序计数器、寄存器状态、内存分配情况、打开文件列表等。存储位置：每个进程的 PCB 存储在操作系统内核的进程表中，操作系统通过访问 PCB 来管理进程。 PID 定义：PID是操作系统中用于标识和区分不同进程的唯一标识符。每个进程都有一个对应的 PID，用于在系统中唯一标识该进程。作用：PID用于操作系统识别和管理不同的进程，通过 PID 可以查找对应进程的 PCB，并对进程进行操作和控制。分配方式：PID 是由操作系统在创建进程时分配的，通常是一个唯一的整数值。使用方式：进程通过 PID 可以获取自身的信息，也可以通过 PID 与其他进程进行通信和协作。 PCB和PID PCB是操作系统中用于管理进程信息的数据结构，包含了进程的所有关键信息。
PID是用于表示不同进程的唯一标识符，用于操作系统识别和管理进程。
getpid() ​ 头文件是unistd.h
#include &lt;iostream&gt; #include &lt;unistd.h&gt; int main() { pid_t pid = getpid(); std::cout &lt;&lt; &#34;PID: &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-21T15:44:57+08:00">
    <meta property="article:modified_time" content="2024-05-21T15:44:57+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux 进程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_1" rel="nofollow">冯诺依曼体系</a></li></ul> 
  </li><li><a href="#_12" rel="nofollow">操作系统</a></li><li><ul><li><a href="#_14" rel="nofollow">为什么要有操作系统</a></li><li><a href="#_23" rel="nofollow">系统调用和库函数概念</a></li><li><a href="#_31" rel="nofollow">进程的组成</a></li><li><a href="#_35" rel="nofollow">如何理解进程动态运行</a></li><li><a href="#_39" rel="nofollow">系统调用接口和用户操作接口</a></li></ul> 
  </li><li><a href="#_45" rel="nofollow">进程</a></li><li><ul><li><a href="#PCB_47" rel="nofollow">PCB</a></li><li><a href="#PID_54" rel="nofollow">PID</a></li><li><a href="#PCBPID_61" rel="nofollow">PCB和PID</a></li><li><a href="#getpid_67" rel="nofollow">getpid()</a></li><li><a href="#getppidpid_80" rel="nofollow">getppid()获取父进程pid</a></li><li><a href="#fork__94" rel="nofollow">`fork()` 创建进程</a></li><li><a href="#_130" rel="nofollow">父子进程</a></li><li><a href="#_138" rel="nofollow">为什么要创建子进程</a></li><li><a href="#proc__144" rel="nofollow">/proc 目录内查看进程文件夹</a></li><li><a href="#chdir_153" rel="nofollow">chdir()改变进程的工作目录</a></li></ul> 
  </li><li><a href="#_159" rel="nofollow">进程状态</a></li><li><ul><li><a href="#_161" rel="nofollow">查看进程状态</a></li><li><a href="#R_177" rel="nofollow">R运行状态</a></li><li><a href="#S_181" rel="nofollow">S睡眠状态</a></li><li><a href="#D_193" rel="nofollow">D磁盘休眠状态</a></li><li><a href="#t_197" rel="nofollow">t状态</a></li><li><a href="#T_201" rel="nofollow">T停止状态</a></li><li><a href="#X_211" rel="nofollow">X死亡状态</a></li><li><a href="#Z_215" rel="nofollow">Z僵尸状态</a></li><li><ul><li><a href="#_223" rel="nofollow">危害</a></li><li><a href="#_244" rel="nofollow">杀死僵尸进程</a></li></ul> 
   </li><li><a href="#_248" rel="nofollow">孤儿进程</a></li><li><a href="#_254" rel="nofollow">杀死进程</a></li><li><a href="#_268" rel="nofollow">并发和并行</a></li><li><a href="#_278" rel="nofollow">阻塞态</a></li><li><a href="#_286" rel="nofollow">挂起态</a></li><li><a href="#CPU_292" rel="nofollow">CPU内的寄存器</a></li><li><a href="#_304" rel="nofollow">挂起态</a></li><li><a href="#CPU_310" rel="nofollow">CPU内的寄存器</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_1"></a>冯诺依曼体系</h3> 
<p>任何计算机系统都包含一个基本的程序集合，称为操作系统(OS)</p> 
<ul><li>笼统的理解，操作系统包括：</li><li>内核（进程管理，内存管理，文件管理，驱动管理）</li><li>其他程序（例如函数库， shell程序等等）</li></ul> 
<p><img src="https://images2.imgbox.com/d0/44/qR16ePmd_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_12"></a>操作系统</h2> 
<h3><a id="_14"></a>为什么要有操作系统</h3> 
<p>操作系统对下&lt;手段&gt;进行软硬件管理工作，<mark>对上层</mark>提供良好（稳定、安全、高效）的运行环境&lt;目的&gt;。</p> 
<p><img src="https://images2.imgbox.com/c4/74/2P1UocOS_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_23"></a>系统调用和库函数概念</h3> 
<p>在开发角度，操作系统对外会表现为一个整体，但是会暴露自己的部分接口，供上层开发使用，这部分由操作系统提供的接口，叫做系统调用。</p> 
<p>系统调用在使用上，功能比较基础，对用户的要求相对也比较高，所以，有心的开发者可以对部分系统调用进行适度封装，从而形成库，有了库，就很有利于更</p> 
<p>层用户或者开发者进行二次开发。</p> 
<h3><a id="_31"></a>进程的组成</h3> 
<p>一个进程内包括 内核task_struct结构体+程序的代码和数据</p> 
<h3><a id="_35"></a>如何理解进程动态运行</h3> 
<p>只要我们的进程task_struct，将来在不同的队列中，进程就可以访问不同的资源</p> 
<h3><a id="_39"></a>系统调用接口和用户操作接口</h3> 
<p>系统调用接口是操作系统提供给用户程序的接口，用于请求操作系统内核提供的服务和功能。</p> 
<p>用户操作接口是用户程序提供给用户自身或其他用户程序的接口，用于实现用户程序的功能和交互。</p> 
<h2><a id="_45"></a>进程</h2> 
<h3><a id="PCB_47"></a>PCB</h3> 
<ul><li><strong>定义</strong>：PCB是操作系统中用于管理和维护进程信息的数据结构。每个进程都有对应的 PCB，用于存储进程的状态、优先级、程序计数器、内存分配情况、打开文件列表等信息。</li><li><strong>作用</strong>：PCB用于跟踪和管理进程的运行状态，操作系统通过维护 PCB 来管理进程的调度、资源分配和状态转换。</li><li><strong>内容</strong>：PCB 包含了进程的所有关键信息，如进程标识符（PID）、程序计数器、寄存器状态、内存分配情况、打开文件列表等。</li><li><strong>存储位置</strong>：每个进程的 PCB 存储在操作系统内核的进程表中，操作系统通过访问 PCB 来管理进程。</li></ul> 
<h3><a id="PID_54"></a>PID</h3> 
<ul><li><strong>定义</strong>：PID是操作系统中用于标识和区分不同进程的唯一标识符。每个进程都有一个对应的 <strong>PID</strong>，用于在系统中唯一标识该进程。</li><li><strong>作用</strong>：PID用于操作系统识别和管理不同的进程，通过 PID 可以查找对应进程的 PCB，并对进程进行操作和控制。</li><li><strong>分配方式</strong>：PID 是由操作系统在创建进程时分配的，通常是一个唯一的整数值。</li><li><strong>使用方式</strong>：进程通过 PID 可以获取自身的信息，也可以通过 PID 与其他进程进行通信和协作。</li></ul> 
<h3><a id="PCBPID_61"></a>PCB和PID</h3> 
<p>PCB是操作系统中用于管理进程信息的数据结构，包含了进程的所有关键信息。</p> 
<p>PID是用于表示不同进程的唯一标识符，用于操作系统识别和管理进程。</p> 
<h3><a id="getpid_67"></a>getpid()</h3> 
<p>​ 头文件是<strong>unistd.h</strong></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    pid_t pid <span class="token operator">=</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"PID: "</span> <span class="token operator">&lt;&lt;</span> pid <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="getppidpid_80"></a>getppid()获取父进程pid</h3> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    pid_t parent_pid <span class="token operator">=</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Parent PID: "</span> <span class="token operator">&lt;&lt;</span> parent_pid <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="fork__94"></a><code>fork()</code> 创建进程</h3> 
<p>需要头文件**<code>unistd.h</code>**</p> 
<p>返回值为0表示子进程，返回值为子进程的pid表示父进程</p> 
<p><strong><code>fork</code>中子进程被创建便开始共享代码，但是数据是分开的</strong></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    pid_t pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 子进程代码</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"This is the child process. PID: "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 父进程代码</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"This is the parent process. Child PID: "</span> <span class="token operator">&lt;&lt;</span> pid <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// fork()失败</span>
        std<span class="token double-colon punctuation">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Fork failed."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="_130"></a>父子进程</h3> 
<p>父进程的代码和数据是从磁盘加载来的</p> 
<p>子进程的代码和数据则是继承父进程的代码和数据而来</p> 
<p>fork() 之后代码共享</p> 
<h3><a id="_138"></a>为什么要创建子进程</h3> 
<p>让子进程执行和父进程不一样的代码。</p> 
<p>实现并行处理、任务分割、资源隔离、错误处理、并发编程等功能，提高程序的性能、可靠性和灵活性。</p> 
<h3><a id="proc__144"></a>/proc 目录内查看进程文件夹</h3> 
<p>每个运行中的进程在/<strong>proc</strong>目录下都有一个以进程pid命名的子目录，其中包含了该进程的相关信息，包括当前的工作路径。</p> 
<p>怎样查看进程的当前工作路径？</p> 
<ol><li><code>ps 进程名</code> 获取进程pid</li><li>假设pid为1234 <code>ls -l /proc/1234/cwd</code> 查看路径</li></ol> 
<h3><a id="chdir_153"></a>chdir()改变进程的工作目录</h3> 
<p>chdir(“路径”)</p> 
<p>请确保指定的路径存在并且有相应的权限</p> 
<h2><a id="_159"></a>进程状态</h2> 
<h3><a id="_161"></a>查看进程状态</h3> 
<p><code>ps ajx</code></p> 
<p><code>ps ajx | head -1</code> 查看一行</p> 
<p><code>ps ajx | grep 'a' | grep -v 'b'</code> 查看状态并且搜索a关键字，过滤b关键字</p> 
<p><code>ps -la</code> 用于显示当前用户的所有进程的详细信息，进程以列表形式显示</p> 
<p><strong>kill -l 列出linux系统可用的信号列表的命令</strong></p> 
<hr> 
<h3><a id="R_177"></a>R运行状态</h3> 
<p>并不意味着进程一定在运行中，它表明进程要么是在运行中要么在运行队列里。</p> 
<h3><a id="S_181"></a>S睡眠状态</h3> 
<p>意味着进程在等待事件完成(<strong>可中断睡眠</strong>)</p> 
<p>在此状态下，进程通常无法被<code>Ctrl+C</code>中断。因为S状态表示进程正在睡眠等待某些事情的发生，他可能是正在<strong>等待I/O操作完成、等待信号、等待资源</strong>等。此时，进程并不处于运行状态，因此无法响应<code>Ctrl+C</code>中断信号。</p> 
<p>通常情况下，只有处于运行状态的进程才能接收并响应<code> Ctrl+C</code> 信号。如果进程处于 “S” 状态，那么 Ctrl+C 信号可能会被系统忽略，直到进程重新进入运行状态或者其他条件发生变化。</p> 
<p>但是可以使用 kill -9 pid 来强制终止，这个命令会发送一个SIGKILL信号给指定的进程，这个信号不可忽略，即使进程处于睡眠状态也会被强制终止。</p> 
<h3><a id="D_193"></a>D磁盘休眠状态</h3> 
<p><strong>不可中断睡眠</strong>状态，在这个状态的进程通常会等待IO的结束。</p> 
<h3><a id="t_197"></a>t状态</h3> 
<ul><li>“tracing stop” 是一种特定于调试器或跟踪工具的状态，用于暂停进程以进行调试和跟踪。</li></ul> 
<h3><a id="T_201"></a>T停止状态</h3> 
<p>可以通过发送信号来停止进程。也可以通过发送信号让进程继续运行。</p> 
<p>“stopped” 是一种通用状态，表示进程被暂停执行，可以由多种原因导致。</p> 
<p><code>kill -19 pid</code>暂停进程</p> 
<p><code>kill -18 pid</code>继续运行进程</p> 
<h3><a id="X_211"></a>X死亡状态</h3> 
<p>这个状态只是一个返回状态，你不会在任务列表里看到这个状态</p> 
<h3><a id="Z_215"></a>Z僵尸状态</h3> 
<p>当子进程退出并且父进程没有读取到子进程退出的返回代码时就会产生僵尸进程</p> 
<p>僵尸进程会以终止状态保持在进程表中，并且会一直在等待父进程读取退出状态代码</p> 
<p>所以，只要子进程退出，父进程还在运行，但父进程没有读取子进程状态，子进程进入僵尸状态</p> 
<h4><a id="_223"></a>危害</h4> 
<p>进程的退出状态必须被维持下去，因为他要告诉关心它的进程（父进程），你交给我的任务，我办的怎么样了。可父进程如果一直不读取，那子进程就一直处于Z状态？</p> 
<p>​ 是的！</p> 
<p>维护退出状态本身就是要用数据维护，也属于进程基本信息，所以保存在task_struct(PCB)中，换句话说， Z状态一直不退出， PCB一直都要维护？</p> 
<p>​ 是的！</p> 
<p>那一个父进程创建了很多子进程，就是不回收，是不是就会造成内存资源的浪费？</p> 
<p>​ 是的！ 因为数据结构对象本身就要<mark>占用内存</mark>，想想C中定义一个结构体变量（对象），是要在内存的某个位置进行开辟空间！</p> 
<p>内存泄漏?</p> 
<p>​ 是的！</p> 
<p><img src="https://images2.imgbox.com/97/aa/lsSuqJ5k_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_244"></a>杀死僵尸进程</h4> 
<p>僵尸进程相当于进程已经死了，是<strong>不能被再次杀</strong>的</p> 
<h3><a id="_248"></a>孤儿进程</h3> 
<p>父进程提前退出，子进程称之为孤儿进程</p> 
<p>孤儿进程被pid为1的init进程领养，所以变成僵尸进程后有init进程回收</p> 
<h3><a id="_254"></a>杀死进程</h3> 
<p><code>kill -9 pid</code> 强制杀死进程</p> 
<p><code>kill -9</code> 命令会发送一个 SIGKILL 信号给指定的进程，这个信号是<strong>不可忽略的</strong>，即使进程处于**“S"睡眠状态**也会被强制终止，即使目标进程处于 <strong>“D” 状态</strong>也可以终止。但它并不能解决造成进程进入 <strong>“D” 状态</strong>的根本”"问题，通常 <strong>“D” 状态</strong>表示系统中的某些 I/O 操作出现了问题。</p> 
<p><code>Ctrl+C</code> 终止在前台运行的进程</p> 
<p>两种方式</p> 
<hr> 
<h3><a id="_268"></a>并发和并行</h3> 
<ul><li> <p>并发指多个任务可以重叠执行,但不一定同时执行。它利用了任务切换带来的时间重叠效应。</p> <p>多个进程在一个CPU下采用进程切换的方式，在一段时间之内，让多个进程都得以推进，称之为并发。</p> </li><li> <p>并行指多个任务真正的同时(同一时刻)在多个处理元素上执行。</p> <p>多个进程在多个CPU下分别同时进行，这称之为并行。</p> </li></ul> 
<h3><a id="_278"></a>阻塞态</h3> 
<p>进程由于等待某些事件的发生而暂时停止执行的状态。</p> 
<p>在阻塞状态下，进程会暂停执行，不会占用 CPU 时间片，直到等待的事件发生或条件满足后才会被唤醒并继续执行。</p> 
<p>阻塞和运行的状态变化，往往伴随着PCB被列入不同的队列中。 运行队列或资源的等待队列</p> 
<h3><a id="_286"></a>挂起态</h3> 
<p>进程被暂时挂起，不会执行任何操作，但仍然保留在内存中。</p> 
<p>挂起态进程通常保存在内存中，以确保快速恢复执行并保持进程的完整性。只有在系统需要释放内存或长时间不需要执行的情况下，才会将进程保存到磁盘中进行休眠或换出操作。 维护系统中的进程。</p> 
<h3><a id="CPU_292"></a>CPU内的寄存器</h3> 
<p>寄存器本身是硬件，具有数据的存储能力，CPU的寄存器硬件只有一套</p> 
<p>CPU内部的数据可以有多套，有几个进程，就有几套和该进程对应的上下文数据</p> 
<p>​ 寄存器!=寄存器的内容</p> 
<p>CPU内部的所有的寄存器中的临时数据，叫做进程的上下文</p> 
<p>入不同的队列中。 运行队列或资源的等待队列</p> 
<h3><a id="_304"></a>挂起态</h3> 
<p>进程被暂时挂起，不会执行任何操作，但仍然保留在内存中。</p> 
<p>挂起态进程通常保存在内存中，以确保快速恢复执行并保持进程的完整性。只有在系统需要释放内存或长时间不需要执行的情况下，才会将进程保存到磁盘中进行休眠或换出操作。 维护系统中的进程。</p> 
<h3><a id="CPU_310"></a>CPU内的寄存器</h3> 
<p>寄存器本身是硬件，具有数据的存储能力，CPU的寄存器硬件只有一套</p> 
<p>CPU内部的数据可以有多套，有几个进程，就有几套和该进程对应的上下文数据</p> 
<p>​ 寄存器!=寄存器的内容</p> 
<p>CPU内部的所有的寄存器中的临时数据，叫做进程的上下文</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6085c3faccab5d98e5fe2a528b826cea/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">24-LINUX-UDP网络连接</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9d9339a67f65d37854f88420dbc2bbd7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【测试SQLite】测试SQLite支持的SQL语句分类</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>