<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;：哈希表和unordered系列容器的封装 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/ca3524b561081090c4c4495b696bf7d6/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="C&#43;&#43;：哈希表和unordered系列容器的封装">
  <meta property="og:description" content="一、unordered系列关联式容器的介绍 在C&#43;&#43;98中，STL提供了底层为红黑树结构的一系列关联式容器，在查询时效率可达到log2N，即最差情况下需要比较红黑树的高度次，当树中的节点非常多时，查询效率也不理想。最好的查询是，进行很少的比较次数就能够将元素找到，因此在C&#43;&#43;11中，STL又提供了4个unordered系列的关联式容器，这四个容器与红黑树结构的关联式容器使用方式基本类似，只是
其底层结构不同（哈希表）
1.1 unordered_map unordered_map的介绍
1. unordered_map是存储&lt;key, value&gt;键值对的关联式容器，其允许通过keys快速的索引到与其对应的value。
2. 在unordered_map中，键值通常用于惟一地标识元素，而映射值是一个对象，其内容与此键关联。键和映射值的类型可能不同。
3. 在内部,unordered_map没有对&lt;kye, value&gt;按照任何特定的顺序排序, 为了能在常数范围内找到key所对应的value，unordered_map将相同哈希值的键值对放在相同的桶中。
4. unordered_map容器通过key访问单个元素要比map快，但它通常在遍历元素子集的范围迭代方面效率较低。
5. unordered_maps实现了直接访问操作符(operator[])，它允许使用key作为参数直接访问value。
6. 它的迭代器至少是前向迭代器。
7.unordered就是无序的意思
使用细节基本上和map一致
1.2 unordered_set unordered_set的文档说明
1.3 性能对比 通过一个测试代码来比较unordered_set 和set的效率
void testop() //测试 底层是红黑树和哈希表的效率比对 { const size_t N = 1000000; unordered_set&lt;int&gt; us; set&lt;int&gt; s; vector&lt;int&gt; v; v.reserve(N); srand((unsigned int)time(0)); for (size_t i = 0; i &lt; N; &#43;&#43;i) { v.push_back(rand()); //v.push_back(rand()&#43;i); //v.push_back(i); } size_t begin1 = clock(); for (auto e : v) { s.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-06T18:52:05+08:00">
    <meta property="article:modified_time" content="2024-05-06T18:52:05+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;：哈希表和unordered系列容器的封装</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="text-align:center;"><img alt="" height="276" src="https://images2.imgbox.com/dc/86/OpT4UJcZ_o.gif" width="538"></h2> 
<h2>一、unordered系列关联式容器的介绍</h2> 
<p>         在C++98中，STL提供了底层为红黑树结构的一系列关联式容器，在查询时效率可达到log2N，即最差情况下需要比较红黑树的高度次，当树中的节点非常多时，查询效率也不理想。最好的查询是，进行很少的比较次数就能够将元素找到，因此<span style="color:#fe2c24;"><strong>在C++11中，STL又提供了4个unordered系列的关联式容器，这四个容器与红黑树结构的关联式容器使用方式基本类似，只是<br> 其底层结构不同（哈希表）</strong></span></p> 
<h3>1.1 unordered_map</h3> 
<p><a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/?kw=unordered_map" rel="nofollow" title="unordered_map的介绍">unordered_map的介绍</a></p> 
<p>1. unordered_map是<span style="color:#fe2c24;"><strong>存储&lt;key, value&gt;键值对</strong></span>的关联式容器，其允许通过keys快速的索引到与其对应的value。<br> 2. 在unordered_map中，键值通常用于惟一地标识元素，而映射值是一个对象，其内容与此键关联。<span style="color:#fe2c24;"><strong>键和映射值的类型可能不同</strong></span>。<br> 3. 在内部,unordered_map没有对&lt;kye, value&gt;按照任何特定的顺序排序, 为了能在常数范围内找到key所对应的value，<span style="color:#fe2c24;"><strong>unordered_map将相同哈希值的键值对放在相同的桶中。</strong></span><br> 4. <span style="color:#fe2c24;"><strong>unordered_map容器通过key访问单个元素要比map快，但它通常在遍历元素子集的范围迭代方面效率较低。</strong></span><br> 5. unordered_maps实现了直接访问操作符(operator[])，它允许使用key作为参数直接访问value。<br> 6. 它的<span style="color:#fe2c24;"><strong>迭代器至少是前向迭代器。</strong></span></p> 
<p><span style="color:#0d0016;">7.unordered就是无序的意思</span></p> 
<p>使用细节基本上和map一致</p> 
<h3><br> 1.2 unordered_set</h3> 
<p><a href="https://cplusplus.com/reference/unordered_set/unordered_set/?kw=unordered_set" rel="nofollow" title="unordered_set的文档说明">unordered_set的文档说明</a></p> 
<h3>1.3 性能对比</h3> 
<p>通过一个测试代码来比较unordered_set 和set的效率</p> 
<pre><code class="language-cpp">void testop() //测试  底层是红黑树和哈希表的效率比对    
{
	const size_t N = 1000000;

	unordered_set&lt;int&gt; us;
	set&lt;int&gt; s;

	vector&lt;int&gt; v;
	v.reserve(N);
	srand((unsigned int)time(0));
	for (size_t i = 0; i &lt; N; ++i)
	{
		v.push_back(rand());
		//v.push_back(rand()+i);
		//v.push_back(i);
	}

	size_t begin1 = clock();
	for (auto e : v)
	{
		s.insert(e);
	}
	size_t end1 = clock();
	cout &lt;&lt; "set insert:" &lt;&lt; end1 - begin1 &lt;&lt; endl;

	size_t begin2 = clock();
	for (auto e : v)
	{
		us.insert(e);
	}
	size_t end2 = clock();
	cout &lt;&lt; "unordered_set insert:" &lt;&lt; end2 - begin2 &lt;&lt; endl;


	size_t begin3 = clock();
	for (auto e : v)
	{
		s.find(e);
	}
	size_t end3 = clock();
	cout &lt;&lt; "set find:" &lt;&lt; end3 - begin3 &lt;&lt; endl;

	size_t begin4 = clock();
	for (auto e : v)
	{
		us.find(e);
	}
	size_t end4 = clock();
	cout &lt;&lt; "unordered_set find:" &lt;&lt; end4 - begin4 &lt;&lt; endl &lt;&lt; endl;

	cout &lt;&lt; s.size() &lt;&lt; endl;
	cout &lt;&lt; us.size() &lt;&lt; endl &lt;&lt; endl;;

	size_t begin5 = clock();
	for (auto e : v)
	{
		s.erase(e);
	}
	size_t end5 = clock();
	cout &lt;&lt; "set erase:" &lt;&lt; end5 - begin5 &lt;&lt; endl;

	size_t begin6 = clock();
	for (auto e : v)
	{
		us.erase(e);
	}
	size_t end6 = clock();
	cout &lt;&lt; "unordered_set erase:" &lt;&lt; end6 - begin6 &lt;&lt; endl &lt;&lt; endl;
}
</code></pre> 
<p><img alt="" height="383" src="https://images2.imgbox.com/17/c4/SbHNAWFR_o.png" width="1200"></p> 
<p> 我们发现，整体而言都是unordered系列更优一点，尤其是find的效率最为突出</p> 
<h2>二、哈希表</h2> 
<p>unordered系列的关联式容器之所以效率比较高，是因为其底层使用了哈希结构。</p> 
<h3>2.1 哈希表的概念</h3> 
<p>        顺序结构以及平衡树中，<span style="color:#fe2c24;">元素关键码与其存储位置之间没有对应的关系</span>，因此在查找一个元素时，必须要经过关键码的多次比较。<span style="color:#fe2c24;">顺序查找时间复杂度为O(N)，平衡树中为树的高度，即<br> O(log2 N)</span>，搜索的效率取决于搜索过程中元素的比较次数<br>  </p> 
<p>理想的搜索方法：<span style="color:#fe2c24;"><strong>可以不经过任何比较，一次直接从表中得到要搜索的元素。如果构造一种存储结构，通过某种函数(hashFunc-&gt;哈希函数)使元素的存储位置与它的关键码之间能够建立一一映射的关系，那么在查找时通过该函数可以很快找到该元素-&gt;哈希表</strong></span></p> 
<p>（1）插入元素<br>        根据待插入元素的关键码，以此哈希函数计算出该元素的存储位置并按此位置进行存放<br> （2）搜索元素<br>        对元素的关键码进行同样的计算，把求得的函数值当做元素的存储位置，在结构中按此位置<br> 取元素比较，若关键码相等，则搜索成功<br> （3）删除元素</p> 
<p>       对元素的关键码进行同样的计算，找到对应的位置并删除</p> 
<p>        <span style="color:#fe2c24;"><strong>该方式即为哈希(散列)方法，哈希方法中使用的转换函数称为哈希(散列)函数，构造出来的结构称为哈希表(Hash Table)(或者称散列表</strong></span><br>  </p> 
<p><img alt="" height="332" src="https://images2.imgbox.com/2e/db/ihCH9B6f_o.png" width="980"></p> 
<h3>2.2 哈希冲突</h3> 
<p><strong><span style="color:#fe2c24;">         不同关键字通过相同哈希哈数计算出相同的哈希地址（</span><span style="color:#ff9900;">不同的值映射到了同一个位置</span></strong><span style="color:#fe2c24;"><strong>），该种现象称为</strong></span><span style="color:#4da8ee;"><strong>哈希冲突或哈希碰撞</strong></span><span style="color:#fe2c24;"><strong>。</strong></span><span style="color:#fe2c24;"><strong>把具有不同关键码而具有相同哈希地址的数据元素称为“</strong></span><span style="color:#4da8ee;"><strong>同义词</strong></span><span style="color:#fe2c24;"><strong>”。</strong></span></p> 
<p><br> 下面我们就会重点介绍什么情况下会出现哈希冲突以及如何解决哈希冲突！！</p> 
<h3>2.3 哈希函数</h3> 
<p>哈希函数：<span style="color:#fe2c24;"><strong>将任意长度的数据映射到固定长度输出的算法（将键值映射为存储位置）</strong></span></p> 
<p>哈希函数设计原则：<br> （1）哈希函数的定义域必须包括需要存储的全部关键码，而如果散列表允许有m个地址时，其值域必须在0到m-1之间<br> （2）哈希函数计算出来的地址能均匀分布在整个空间中<br> （3）哈希函数应该比较简单</p> 
<p>引起哈希冲突的一个原因可能是：<span style="color:#fe2c24;"><strong>哈希函数设计不够合理。</strong></span><br>  </p> 
<p>常见的哈希函数：</p> 
<p>（1）直接定址法--(常用)</p> 
<p>取关键字的某个线性函数为散列地址：Hash（Key）= A*Key + B<br> 优点：简单、均匀<br> 缺点：<span style="color:#fe2c24;"><strong>需要事先知道关键字的分布情况</strong></span><br> 使用场景：<span style="color:#fe2c24;"><strong>适合查找比较小且连续的情况</strong></span></p> 
<p><br> 我们的位图其实就是用的直接定址法，可以理解为每个键值都有一个单独的映射位置。</p> 
<p>（2） 除留余数法（常用）</p> 
<p>设散列表中允许的<span style="color:#fe2c24;"><strong>地址数为m，取一个不大于m，但最接近或者等于m的质数p作为除数，按照哈希函数：Hash(key) = key% p(p&lt;=m),将关键码转换成哈希地址</strong></span><br>  </p> 
<p>哈希表的实现就是用的这个方法！！</p> 
<p>（3）平方取中法--(不常用)</p> 
<p>假设关键字为1234，对它平方就是1522756，抽取中间的3位227作为哈希地址；再比如关键字为4321，对它平方就是18671041，抽取中间的3位671(或710)作为哈希地址<br> 平方取中法比较适合：<span style="color:#fe2c24;"><strong>不知道关键字的分布，而位数又不是很大的情况</strong></span><br>  </p> 
<p>（4）折叠法--（不常用）</p> 
<p>折叠法是将关键字从左到右分割成位数相等的几部分(最后一部分位数可以短些)，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。<br> 折叠法适合：<span style="color:#fe2c24;"><strong>事先不需要知道关键字的分布，适合关键字位数比较多的情况</strong></span><br>  </p> 
<p>（5）随机数法--（不常用）</p> 
<p>选择一个随机函数，取关键字的随机函数值为它的哈希地址，即H(key) = random(key),其中random为随机数函数。<br><span style="color:#fe2c24;"><strong>通常应用于关键字长度不等时采用此法</strong></span><br>  </p> 
<p>（6）数学分析法（不常用）</p> 
<p>       设有n个d位数，每一位可能有r种不同的符号，这r种不同的符号在各位上出现的频率不一定<br> 相同，可能在某些位上分布比较均匀，每种符号出现的机会均等，在某些位上分布不均匀只有某几种符号经常出现。可<span style="color:#fe2c24;">根据散列表的大小，选择其中各种符号分布均匀的若干位作为散列地址。</span></p> 
<p class="img-center"><img alt="" height="330" src="https://images2.imgbox.com/bf/35/VxHvPxlQ_o.png" width="606"></p> 
<p>       假设要存储某家公司员工登记表，如果用手机号作为关键字，那么极有可能前7位都是 相同<br> 的，那么我们可以选择后面的四位作为散列地址，如果这样的抽取工作还容易出现 冲突，还可以对抽取出来的数字进行反转(如1234改成4321)、右环位移(如1234改成4123)、左环移位、前两数与后两数叠加(如1234改成12+34=46)等方法。<br>           数字分析法通常<span style="color:#fe2c24;"><strong>适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的<br> 若干位分布较均匀的情况</strong></span><br>  </p> 
<p><span style="color:#fe2c24;"><strong>哈希函数设计的越精妙，产生哈希冲突的可能性就越低，但是无法避免哈希冲突</strong></span></p> 
<p></p> 
<p><span style="color:#0d0016;">接下来我们将会重点讲解哈希表的实现，其底层用的是</span><strong><span style="color:#fe2c24;">除留余数法，  </span><span style="color:#0d0016;">解决其哈希冲突的方法有两种，即开放定址法和拉链法。</span></strong><br>  </p> 
<h3>2.4 开放定址法实现简单哈希表</h3> 
<p>闭散列：也叫开放定址法，当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有空位置，那么<span style="color:#fe2c24;">可以把key存放到冲突位置中的“下一个” 空位置中去。</span><br>      </p> 
<p>那么我们如何寻找下一个位置呢？答案就是线性探测。</p> 
<p><img alt="" height="332" src="https://images2.imgbox.com/13/06/N2YyJ8Q7_o.png" width="980"></p> 
<p>         比如图中的场景，现在需要插入元素44，先通过哈希函数计算哈希地址，hashAddr为4，因此44理论上应该插在该位置，但是该位置已经放了值为4的元素，即发生<span style="color:#fe2c24;">哈希冲突</span>。<br>        <strong> <span style="color:#4da8ee;">但是线性探测会存在以下两个问题：</span></strong></p> 
<p><strong><span style="color:#4da8ee;">（1）不确定每个位置的初始值放多少，不能是放0，否则该位置如果本来就要放0的话，这个时候我们就没办法区分了！！</span></strong></p> 
<p><strong><span style="color:#4da8ee;">（2）插入的时候线性探测是向后查找直到空停止并放入，所以删除的时候也应该是线性探测向后查找直到空的这段区域必然可以找到这个要删除的元素，但是如上图44的位置依赖于前面4567的定位，假如4-7中的任意一个元素删除了，那么下一次要删44的时候就会找不到44.</span></strong></p> 
<p></p> 
<p><span style="color:#fe2c24;"><strong>    </strong></span><strong><span style="color:#fe2c24;">为了解决上面的两个问题，我们的策略就是设置3种状态，EMPTY 表示空， EXIST表示有，DELETE表示已删除。 我们给每个位置都存一个状态。</span></strong></p> 
<p>    同时为了防止元素扎堆的情况，可以采用二次线性探测，这样可以减少冲突。</p> 
<h4>2.4.1 基本结构</h4> 
<pre><code class="language-cpp">enum State //设置状态本质上是为了解决两个问题 1，一开始的元素不知道是多少比较合适  如果是0的话  可能加入的数也正好是0  2.如果该位置元素删除了，那么会导致因为该元素占位而到别的位置的元素找不到！！！
{
	EMPTY,//空
	EXIST,//存在
	DELETE //删除  
};

template&lt;class K, class V&gt;
struct HashData
{
	pair&lt;K, V&gt; _kv;//会调用自己的默认构造
	State _state = EMPTY;
};


template&lt;class K, class V&gt;
class HashTable
{
public:
	
private:
	vector&lt;HashData&lt;K, V&gt;&gt; _tables;
	size_t _n = 0; //记录有效的数据个数
};
</code></pre> 
<h4>2.4.2 插入</h4> 
<pre><code class="language-cpp">bool Insert(const pair&lt;K, V&gt;&amp; kv)
{
	if (Find(kv.first))  return false;//键值不冗余， 所以如果存在，就没有必要去插入

	//考虑扩容的问题   负载因子为0.7
	if (_tables.size() == 0 || _n * 10 / _tables.size() &gt;= 7)
	{
	   //利用现代写法 让你去搞  然后窃取革命成果
		size_t newsize = _tables.size() == 0 ? 10 :_tables.size()*2;
		HashTable&lt;K, V&gt; newt;
		newt._tables.resize(newsize);
	    //遍历旧表 然后重新搞到新表上
		for (auto&amp; data : _tables)
			if (data._state == EXIST)
				newt.Insert(data._kv);
		_tables.swap(newt._tables);//窃取革命成果
	}


	size_t hashi = kv.first % _tables.size();//%容量是没有用的，%size才是有用的  因为光扩容，也是不敢随机访问的！
	//进行线性探测 当前如果存在就要往后推
	size_t i = 1;
	size_t index = hashi;
	while (_tables[index]._state == EXIST) //
	{
		index = hashi + i; //这样子方便后面修改成二次检测
		//index可能会越界，可能需要去修正一下
		index %= _tables.size();
		++i;
	}
	//在相应的位置进行操作
	_tables[index]._kv = kv;
	_tables[index]._state = EXIST;
	++_n; //更新次数

	return true;
}</code></pre> 
<p>  (1) 哈希表在%的时候一定要%size而不是%capacity（可能会存在越界，比如说size只有10，而capacity是20，如果映射到15也是不可以访问的！！），因为我们空间一定是开好了的而不是中间插入进去。 扩容的时候也是一定要用resize而不是reserve。</p> 
<p>（2）哈希表在某些时候需要去扩容，我们设置一个负载因子（假设0.7）,超出这个范围我们就是扩容，但是我们不能单纯地去resize，因为映射关系会完全改变。比如说原本10的空间，12是插入在2的位置，但是空间变成20后，12就应该插入到12的位置上。所以我们要创建一个新表，然后遍历旧表拿数据，重新计算映射位置。      <span style="color:#fe2c24;">每次又要走一次线性探测，为了防止代码冗余，此时有两种方案，一种是将线性探测的代码封装起来，然后复用   另一种方案是现代写法，再创建一个新的对象，然后让该对象去调用insert，最后再利用swap窃取成果。</span></p> 
<h4>2.4.3 查找</h4> 
<pre><code class="language-cpp">HashData&lt;K, V&gt;* Find(const K&amp; key) //返回值为指针是方便我们在找不到的时候可以返回空
{
	if (_tables.size() == 0) return nullptr;
	//一样要进行线性探测
	size_t hashi = key % _tables.size();
	size_t i = 1;
	size_t index = hashi;
	while (_tables[index]._state != EMPTY)  //不等于空的时候往后走
	{
		if (_tables[index]._state == EXIST &amp;&amp; _tables[index]._kv.first == key)  //前面的判断是确保当前位置不为DETELE 状态  因为为我们封装的删除是一个伪删除，并不是真的删除
			return &amp;_tables[index];
		//如果找不到，往后继续走
		index = hashi + i;
		index %= _tables.size();
		++i;

		//极端情况    插入一部分 +删除一部分 +插入一部分 正好所有的位置都是存在+删除 此时上面面临着死循环  所以我们堆i进行判断，如果index==hashi说明已经找了一圈了，此时就跳出去
		if (index == hashi) break;
	}
	return nullptr;
}</code></pre> 
<p>        不等于空就可以继续向后线性探测，因为我们设置delete状态就是想实现伪删除，这样在删除某些元素的时候不会影响线性探测。</p> 
<p><span style="color:#fe2c24;"><strong>极端情况：如果正好插入一部分，删除一部分，再插入一部分，导致所有的位置都是存在+删除，那么循环永远不会停止，这个时候我们就要去判断如果正好走了一圈了，就可以break了。</strong></span></p> 
<h4>2.4.4 删除</h4> 
<pre><code class="language-cpp">bool Erase(const K&amp; key)
{
	HashData&lt;K, V&gt;* ret = Find(key); //复用find
	if (ret) //如果找到了  将该位置改成删除
	{
		ret-&gt;_state = DELETE; //伪删除
		--_n;
		return true;
	}
	return false;
}</code></pre> 
<p>复用Find即可，然后进行伪删除。 </p> 
<h4>2.4.5 整体代码的实现</h4> 
<pre><code class="language-cpp">	enum State //设置状态本质上是为了解决两个问题 1，一开始的元素不知道是多少比较合适  如果是0的话  可能加入的数也正好是0  2.如果该位置元素删除了，那么会导致因为该元素占位而到别的位置的元素找不到！！！
	{
		EMPTY,//空
		EXIST,//存在
		DELETE //删除  
	};

	template&lt;class K, class V&gt;
	struct HashData
	{
		pair&lt;K, V&gt; _kv;//会调用自己的默认构造
		State _state = EMPTY;
	};


	template&lt;class K, class V&gt;
	class HashTable
	{
	public:
		bool Insert(const pair&lt;K, V&gt;&amp; kv)
		{
			if (Find(kv.first))  return false;//键值不冗余， 所以如果存在，就没有必要去插入

			//考虑扩容的问题   负载因子为0.7
			if (_tables.size() == 0 || _n * 10 / _tables.size() &gt;= 7)
			{
			   //利用现代写法 让你去搞  然后窃取革命成果
				size_t newsize = _tables.size() == 0 ? 10 :_tables.size()*2;
				HashTable&lt;K, V&gt; newt;
				newt._tables.resize(newsize);
			    //遍历旧表 然后重新搞到新表上
				for (auto&amp; data : _tables)
					if (data._state == EXIST)
						newt.Insert(data._kv);
				_tables.swap(newt._tables);//窃取革命成果
			}


			size_t hashi = kv.first % _tables.size();//%容量是没有用的，%size才是有用的  因为光扩容，也是不敢随机访问的！
			//进行线性探测 当前如果存在就要往后推
			size_t i = 1;
			size_t index = hashi;
			while (_tables[index]._state == EXIST) //
			{
				index = hashi + i; //这样子方便后面修改成二次检测
				//index可能会越界，可能需要去修正一下
				index %= _tables.size();
				++i;
			}
			//在相应的位置进行操作
			_tables[index]._kv = kv;
			_tables[index]._state = EXIST;
			++_n; //更新次数

			return true;
		}

		HashData&lt;K, V&gt;* Find(const K&amp; key) //返回值为指针是方便我们在找不到的时候可以返回空
		{
			if (_tables.size() == 0) return nullptr;
			//一样要进行线性探测
			size_t hashi = key % _tables.size();
			size_t i = 1;
			size_t index = hashi;
			while (_tables[index]._state != EMPTY)  //不等于空的时候往后走
			{
				if (_tables[index]._state == EXIST &amp;&amp; _tables[index]._kv.first == key)  //前面的判断是确保当前位置不为DETELE 状态  因为为我们封装的删除是一个伪删除，并不是真的删除
					return &amp;_tables[index];
				//如果找不到，往后继续走
				index = hashi + i;
				index %= _tables.size();
				++i;

				//极端情况    插入一部分 +删除一部分 +插入一部分 正好所有的位置都是存在+删除 此时上面面临着死循环  所以我们堆i进行判断，如果index==hashi说明已经找了一圈了，此时就跳出去
				if (index == hashi) break;
			}
			return nullptr;
		}

		bool Erase(const K&amp; key)
		{
			HashData&lt;K, V&gt;* ret = Find(key); //复用find
			if (ret) //如果找到了  将该位置改成删除
			{
				ret-&gt;_state = DELETE; //伪删除
				--_n;
				return true;
			}
			return false;
		}


	private:
		vector&lt;HashData&lt;K, V&gt;&gt; _tables;
		size_t _n = 0; //记录有效的数据个数
	};</code></pre> 
<h3>2.5 拉链法实现简单哈希表</h3> 
<p>        开放定址法是一个比较粗暴的方式，因为其是一种恶性循环，冲突之后就占别的位置，而后面一旦出现本该放在该位置的元素，也得另外占别的位置。 </p> 
<p>       而拉链法相对来说更文明一点，如果发生冲突了，我就跟你挤一挤。接在一起。</p> 
<p>      <span style="color:#fe2c24;"><strong>开散列法又叫链地址法(开链法)</strong></span>，首先对关键码集合用散列函数计算散列地址，具有相同地址的关键码归于同一子集合，每一个子集合称为一个桶（哈希桶），各个桶中的元素通过一个单链表链接起来，各链表的头结点存储在哈希表中。<br>      <img alt="" height="538" src="https://images2.imgbox.com/5d/45/CSTlXyGh_o.png" width="736"></p> 
<p><span style="color:#fe2c24;"><strong>开散列中每个桶中放的都是发生哈希冲突的元素。</strong></span></p> 
<pre><code class="language-cpp">//因为有扩容(负载因子控制)的存在!!!!，哈希桶增删查改的时间复杂度都是O（1）      虽然插入可能会存在扩容，扩容操作是O（N） 但是整体而言扩容只在那一瞬间 因为我们的哈希表是不断在插入元素的 
                                                   //相当于是一个好学生考试，他大多数情况下都考得好就偶尔一两次考不好  同理，这边插入的时间复杂度大多数情况是O(1) O(N)只在一瞬间
//跟快排一样，快排也非常难出现最坏情况 因为有了随机取KEY（针对有序） 以及这个三路划分（针对重复）
namespace HashBucket //哈希桶  拉链法  开散列
{

	template&lt;class K,class V&gt;
	struct HashNode
	{
		HashNode&lt;K, V&gt;* _next;
		pair&lt;K, V&gt; _kv;
        
		HashNode(const pair&lt;K, V&gt;&amp; kv)
			:_next(nullptr)
			, _kv(kv)
		{}
	};


	template&lt;class K&gt;
	struct HashFunc //默认 int
	{
		size_t operator()(const K&amp; key)
		{
			return key;
		}
	};

	template&lt;&gt;  //因为string 用的比较多， 所以我们可以专门搞一个模板特化版本  专门针对string  有特化走特化，没特化走普通类型
	struct HashFunc&lt;string&gt;
	{
		// 尽量要控制不要重复  1.将字符串的所有ASCII码加起来 2，但是加起来之后，对于字符相同但是顺序不同的字符串 还是不太好区分，所以这里要用以恶搞BKDR哈希算法
		size_t operator()(const string&amp; s)
		{
			size_t hash = 0;
			for (auto ch : s)  //将字符串转化成整型，通过映射整型去找到字符串对应的位置
			{
				hash += ch;  //但是光有这一句代码的话， 应对一些字符相同但是顺序相同的字符串的时候，仍然是不好区分的 
				hash *= 31;  //BKDR哈希 
			}

			return hash;
		}
	};


	template&lt;class K,class V,class Hash= HashFunc&lt;K&gt;&gt;
	class HashTable
	{
		typedef HashNode&lt;K, V&gt; Node;
	public:
		~HashTable()
		{
			clear();
		}

		bool Insert(const pair&lt;K, V&gt;&amp; kv)
		{
			if (Find(kv.first)) return false;//如果有就不用找了  
			Hash hash;//通过仿函数控制可以K变成可以取模
			//负载因子为1时进行扩容
			if (_n == _tables.size()) //这里不适合用现代写法，因为如果去调用insert的话，会重新申请很多新的结点，然后又要释放很多结点 效率太低了    //解决方案就是  原表的结点重新计算，挪动到新表的位置                                                                  
			{
				//size_t newsize = _tables.size() == 0 ? 10 : _tables.size() * 2; 原来的版本

				size_t newsize = GetNextPrime(_tables.size()); //按照SGI版本的素数表
				第一种方案  创建一个新的表来完成这个任务
				//HashTable&lt;K, V&gt; newht;
				//newht._tables.resize(newsize);
				//for (auto&amp;cur : _tables)
				//{
				//	while (cur)
				//	{
				//		newht.Insert(cur-&gt;_kv);
				//		cur = cur-&gt;_next;
				//	}
				//}
				//_tables.swap(newht._tables); 

				vector&lt;Node*&gt; newtables(newsize, nullptr);
				//将结点一个个解下来放到新表中 （复用的话会创建很多新的结点 其实没有什么必要 ）
				for (Node*&amp; cur : _tables)
					while (cur)
					{
						Node* next = cur-&gt;_next;
						size_t hashi = hash(cur-&gt;_kv.first) % newtables.size(); //重新计算   
						//头插到新表
						cur-&gt;_next = newtables[hashi];
						newtables[hashi] = cur;
						cur = next;
					}
				_tables.swap(newtables);//交换过来 
			}
			size_t hashi = hash(kv.first) % _tables.size();  //只有整形是支持取模的，其他的类型是不一定的
			//执行头插的逻辑
			Node* newnode = new Node(kv);
			newnode-&gt;_next = _tables[hashi];
			_tables[hashi] = newnode;//成为新的头
			++_n;
			return true;
		}

			Node* Find(const K&amp;key)
			{
				if (_tables.size() == 0)  return nullptr;
				Hash hash;
				size_t hashi = hash(key) % _tables.size(); //找到这个点
				Node* cur = _tables[hashi];
				while (cur)
				{
					if (cur-&gt;_kv.first == key) return cur;
					cur = cur-&gt;_next;
				}
				return nullptr;
			}

			bool Erase(const K&amp; key)
			{
				Hash hash;
				//这边就不能直接复用find了，因为只是拿到该结点，但是还得从里面删掉才有用
				size_t hashi = hash(key) % _tables.size();//找到这个位置
				Node* prev = nullptr;
				Node* cur = _tables[hashi];
				while (cur)
				{
					if (cur-&gt;_kv.first == key) //执行删除
					{
						if (prev == nullptr)   _tables[hashi] = cur-&gt;_next;         //说明第一个就要删
						else  prev-&gt;_next = cur-&gt;_next;
							delete cur;
							--_n;
							return true;
					}
					prev = cur;
					cur = cur-&gt;_next;
				}
				return false; //说明找不到
			}


			size_t MaxBucketSize() //统计桶的最大长度并返回  检测查找的效率
			{
				size_t max = 0;
				for (size_t i = 0; i &lt; _tables.size(); ++i)
				{
					auto cur = _tables[i];
					size_t size = 0;
					while (cur)
					{
						++size;
						cur = cur-&gt;_next;
					}
					printf("[%zd]-&gt;%zd\n", i, size); //打印所有桶的长度 让我们看到具体的分布情况  这样就可以测出查找的时间复杂度
					if (size &gt; max) 	max = size;
				}
				return max;
			}

			void clear()
			{
				for (Node*&amp; cur : _tables)
				{
					while (cur)
					{
						Node* next = cur-&gt;_next;
						delete cur;
						cur = next;
					}

					cur = nullptr;
				}
			}


			//SGI版本    主要是数学上提到说如果表的长度是素数的话，模的时候更不容易冲突  
			//但是如果我们正常的扩2倍肯定是难以维持他是素数的，所以就有了这样一个解决方案，专门给了一个素数表 让哈希表的长度按照这个表去更新 这样可以保证长度一直是素数
			//SGI版本是这么实现的
			size_t GetNextPrime(size_t prime)
			{
				// SGI
				static const int __stl_num_primes = 28;
				static const unsigned long __stl_prime_list[__stl_num_primes] =
				{
					53, 97, 193, 389, 769,
					1543, 3079, 6151, 12289, 24593,
					49157, 98317, 196613, 393241, 786433,
					1572869, 3145739, 6291469, 12582917, 25165843,
					50331653, 100663319, 201326611, 402653189, 805306457,
					1610612741, 3221225473, 4294967291
				}; //实际上是不可能扩到最大的 因为 2^32次方  哪怕是char类型都有4G了  指针都有16G了
				    /*1Byte（字节）=8bit（位）
				    1 KB = 1024 Byte
					1 MB = 1024 KB
					1 GB = 1024 MB
					1TB = 1024GB*/
			

				size_t i = 0;
				for (; i &lt; __stl_num_primes; ++i)
				{
					if (__stl_prime_list[i] &gt; prime)
						return __stl_prime_list[i];
				}

				return __stl_prime_list[i];  //在表里依次遍历 找到比原先大的那个素数值
			}

	private:
		vector&lt;Node*&gt; _tables; //指针数组
		size_t _n=0;//记录有效元素的个数 
	};</code></pre> 
<h2>三、unordered系列容器的封装</h2> 
<h3>3.1 改造拉链法哈希表</h3> 
<pre><code class="language-cpp">//自己实现的时候  一定要一步一步来， 先封装哈希表 然后再封装简单的map和set  然后再封装迭代器让插入跑起来，然后再去考虑其他的一些细节问题， 不要一下子把所有的模板参数都加上 
//要一步一步来

template&lt;class T&gt;
struct HashNode
{
	HashNode&lt;T&gt;* _next;
	T _data; //T决定存的是KV 还是K

	HashNode(const T&amp; data)
		:_next(nullptr)
		,_data(data)
	{}
};
template&lt;class K&gt;
struct HashFunc //默认 int
{
	size_t operator()(const K&amp; key)
	{
		return key;
	}
};

template&lt;&gt;  //因为string 用的比较多， 所以我们可以专门搞一个模板特化版本  专门针对string  有特化走特化，没特化走普通类型  默认支持
struct HashFunc&lt;string&gt;
{
	// 尽量要控制不要重复  1.将字符串的所有ASCII码加起来 2，但是加起来之后，对于字符相同但是顺序不同的字符串 还是不太好区分，所以这里要用以恶搞BKDR哈希算法
	size_t operator()(const string&amp; s)
	{
		size_t hash = 0;
		for (auto ch : s)  //将字符串转化成整型，通过映射整型去找到字符串对应的位置
		{
			hash += ch;  //但是光有这一句代码的话， 应对一些字符相同但是顺序相同的字符串的时候，仍然是不好区分的 
			hash *= 31;  //BKDR哈希 
		}

		return hash;
	}
};

template&lt;class K, class T, class KeyOfT, class Hash&gt; //  前置声明 不要给缺省参数 
class HashTable;


template&lt;class K, class T, class Ref, class Ptr, class KeyOfT,class Hash&gt;//缺省不能在这传  在这传会写死
struct _HashIterator //迭代器的封装
{
	typedef HashNode&lt;T&gt; Node;//结点
	typedef HashTable&lt;K, T, KeyOfT,Hash&gt; HT;//处理指向哈希桶的指针
	typedef _HashIterator&lt;K, T, Ref, Ptr, KeyOfT,Hash&gt; Self;//自己
	typedef _HashIterator&lt;K, T, T&amp;, T*, KeyOfT, Hash&gt; Iterator; //服务set普通迭代器 
	//在红黑树中也是按照这个逻辑，key被修改会破坏红黑树的整体结构， 所以我们必须要去控制
    
	//成员变量 必然要有结点指针以及哈希桶的指针
	Node* _node;
	const HT* _ht;


	_HashIterator(Node* node,const HT* ht) //这样可以保证const可以接收 普通的也可以接收 因为权限可以缩小
		:_node(node)
		, _ht(ht)
	{}

	_HashIterator(const Iterator&amp; it) //拷贝构造  本质上是为了set去服务的
		:_node(it._node)   //普通迭代器可以转化成const迭代器 
		, _ht(it._ht)
	{}

	Ref operator*()
	{
		return _node-&gt;_data;
	}

	Ptr operator-&gt;()
	{
		return &amp;operator*();
	}

	bool operator!=(const Self&amp; s)
	{
		return _node != s._node;
	}

	Self&amp; operator++()
	{
		if (_node-&gt;_next) _node = _node-&gt;_next;// 如果结点下一个不为空，就去找下一个
		else //如果结点的下一个为空，那么就去哈希桶找下一个桶
		{
			KeyOfT kot;//控制data取出来的是什么
			//先算一下自己在当前桶的位置 
			size_t hashi = _ht-&gt;bucket(kot(_node-&gt;_data)); //无法访问私有成员 要么用友元 要么封装gettable和getbucketsize这两个函数 
			++hashi;
			while (hashi &lt; _ht-&gt;_buckets.size())
			{
				if (_ht-&gt;_buckets[hashi]) //如果找到了
				{
					_node = _ht-&gt;_buckets[hashi];
					break;
				}
				++hashi; //继续找下一个桶
			}
           //此时可能有两种情况  一种是成功找到，一种是走到最后都没找到
			if (hashi == _ht-&gt;_buckets.size()) _node = nullptr;
		}
		return *this;
	}

	Self operator++(int)
	{
		Self temp = *this;
		++*this;
		return temp;
	}

};

//    class Pred = equal_to&lt;Key&gt;

template&lt;class K, class T, class KeyOfT,class Hash&gt;
class HashTable
{
	     typedef HashNode&lt;T&gt; Node;
		 //友元  为了能够让迭代器访问私有成员table  但是这样会破坏封装性 不推荐使用  还有一种方法是封装一个getbucketsize函数和gettables的函数  
	     template&lt;class K, class T, class Ref, class Ptr, class KeyOfT, class Hash&gt;
		 friend	struct _HashIterator; 
public:
	~HashTable()
	{
		clear();
	}

	typedef _HashIterator&lt;K, T,T&amp;,T*,KeyOfT, Hash&gt;  iterator;
	typedef _HashIterator&lt;K, T, const T&amp;, const T*, KeyOfT, Hash&gt; const_iterator;
	typedef HashTable&lt;K, T, KeyOfT, Hash&gt;   Self;
	iterator begin()  //得找到第一个有效的桶
	{
		Node* cur = nullptr; //防止全部为空的时候
		for (size_t i = 0; i &lt; _buckets.size(); ++i)
		{
			if (_buckets[i])
			{
				cur = _buckets[i];
				break;
			}
		}
		return iterator(cur, this);  //this指针
	}

	iterator end()  
	{
		return iterator(nullptr, this);  //this指针
	}


	const_iterator begin() const
	{
		Node* cur = nullptr;
		for (size_t i = 0; i &lt; _buckets.size(); ++i)
		{
			cur = _buckets[i];
			if (_buckets[i])
			{
				cur = _buckets[i];
				break;
			}
		}
		return const_iterator(cur, this);
	}


	
	const_iterator end() const
	{
		return const_iterator(nullptr, this);
	}


	pair&lt;iterator, bool&gt; Insert(const T&amp; data)
	{
		KeyOfT kot;//控制data取出来的是什么
		iterator it = Find(kot(data));
		if (it != end()) return make_pair(it, false);//如果有就不用找了  
		
		//负载因子为1时进行扩容
		if (_n == _buckets.size()) //这里不适合用现代写法，因为如果去调用insert的话，会重新申请很多新的结点，然后又要释放很多结点 效率太低了    //解决方案就是  原表的结点重新计算，挪动到新表的位置                                                                  
		{
			//size_t newsize = _buckets.size() == 0 ? 10 : _buckets.size() * 2; 原来的版本

			size_t newsize = GetNextPrime(_buckets.size()); //按照SGI版本的素数表
			第一种方案  创建一个新的表来完成这个任务
			//HashTable&lt;K, V&gt; newht;
			//newht._buckets.resize(newsize);
			//for (auto&amp;cur : _buckets)
			//{
			//	while (cur)
			//	{
			//		newht.Insert(cur-&gt;_kv);
			//		cur = cur-&gt;_next;
			//	}
			//}
			//_buckets.swap(newht._buckets); 

			vector&lt;Node*&gt; newtables(newsize, nullptr);
			//将结点一个个解下来放到新表中 （复用的话会创建很多新的结点 其实没有什么必要 ） 所以这里不用第一种方法  
			for (Node*&amp; cur : _buckets)
				while (cur)
				{
					Node* next = cur-&gt;_next;
					size_t hashi = bucket(kot(cur-&gt;_data)); //重新计算   
					//头插到新表
					cur-&gt;_next = newtables[hashi];
					newtables[hashi] = cur;
					cur = next;
				}
			_buckets.swap(newtables);//交换过来 
		}
		size_t hashi = bucket(kot(data));  //只有整形是支持取模的，其他的类型是不一定的
		//执行头插的逻辑
		Node* newnode = new Node(data);
		newnode-&gt;_next = _buckets[hashi];
		_buckets[hashi] = newnode;//成为新的头
		++_n;
		return make_pair(iterator(newnode,this),true);
	}

	iterator Find(const K&amp; key)
	{
		if (empty())  return end(); //为空 就没啥好找的了
		KeyOfT kot;//控制data取出来的是什么
		size_t hashi = bucket(key); //找到这个点
		Node* cur = _buckets[hashi];
		while (cur)
		{
			if (kot(cur-&gt;_data) == key) return iterator(cur, this);
			cur = cur-&gt;_next;
		}
		return iterator(nullptr, this);
	}

	bool Erase(const K&amp; key)
	{
		Hash hash;//控制模出来的情况 因为可能会是字符串什么的
		KeyOfT kot;//控制data取出来的是什么
		//这边就不能直接复用find了，因为只是拿到该结点，但是还得从里面删掉才有用
		size_t hashi = bucket(key);//找到key对应的桶
		Node* prev = nullptr;
		Node* cur = _buckets[hashi];
		while (cur)
		{
			if (kot(cur-&gt;_data) == key) //执行删除
			{
				if (prev == nullptr)   _buckets[hashi] = cur-&gt;_next;         //说明第一个就要删
				else  prev-&gt;_next = cur-&gt;_next;
				delete cur;
				--_n;
				return true;
			}
			prev = cur;
			cur = cur-&gt;_next;
		}
		return false; //说明找不到
	}

	void clear() //清空桶中的元素
	{
		for (Node*&amp; cur : _buckets)
		{
			while (cur)
			{
				Node* next = cur-&gt;_next;
				delete cur;
				cur = next;
			}
			cur = nullptr;
		}
	}
	

	size_t size() const //哈希表中的元素个数
	{
		return _n;
	}

	bool empty() const
	{
		return size() == 0;
	}

	void swap(Self&amp; s)
	{
		_buckets.swap(s._buckets);
		std::swap(_n, s._n);
	}


	//SGI版本    主要是数学上提到说如果表的长度是素数的话，模的时候更不容易冲突  
	//但是如果我们正常的扩2倍肯定是难以维持他是素数的，所以就有了这样一个解决方案，专门给了一个素数表 让哈希表的长度按照这个表去更新 这样可以保证长度一直是素数
	//SGI版本是这么实现的
	size_t GetNextPrime(size_t prime)
	{
		// SGI
		static const int __stl_num_primes = 28;
		static const unsigned long __stl_prime_list[__stl_num_primes] =
		{
			53, 97, 193, 389, 769,
			1543, 3079, 6151, 12289, 24593,
			49157, 98317, 196613, 393241, 786433,
			1572869, 3145739, 6291469, 12582917, 25165843,
			50331653, 100663319, 201326611, 402653189, 805306457,
			1610612741, 3221225473, 4294967291
		}; //实际上是不可能扩到最大的 因为 2^32次方  哪怕是char类型都有4G了  指针都有16G了
		/*1Byte（字节）=8bit（位）
		1 KB = 1024 Byte
		1 MB = 1024 KB
		1 GB = 1024 MB
		1TB = 1024GB*/


		size_t i = 0;
		for (; i &lt; __stl_num_primes; ++i)
		{
			if (__stl_prime_list[i] &gt; prime)
				return __stl_prime_list[i];
		}

		return __stl_prime_list[i];  //在表里依次遍历 找到比原先大的那个素数值
	}

	const size_t MaxBucketSize() const  //统计桶的最大长度并返回  检测查找的效率   测试用的  不是刚需
	{
		size_t max = 0;
		for (size_t i = 0; i &lt; _buckets.size(); ++i)
		{
			Node* cur = _buckets[i];
			size_t size = bucket_size(cur);
			printf("[%zd]-&gt;%zd\n", i, size); //打印所有桶的长度 让我们看到具体的分布情况  这样就可以测出查找的时间复杂度
			if (size &gt; max) 	max = size;
		}
		return max;
	}

	 size_t bucket(const K&amp; key) const //返回key所在哈希桶的编号
	{
		Hash hash;//控制模出来的情况 因为可能会是字符串什么的
		size_t hashi = hash(key) % _buckets.size(); //找到这个点
		return hashi;
	}

	 size_t bucket_size(size_t n) const  //返回这个桶有多少个元素
	 {
		 Node* cur = _buckets[n];
		 size_t size = 0;
		 while (cur)
		 {
			 ++size;
			 cur = cur-&gt;_next;
		 }
		 return size;
	 }

private:
	vector&lt;Node*&gt; _buckets; //指针数组  哈希桶集合
	size_t _n = 0;//记录有效元素的个数 
};</code></pre> 
<p><a href="https://www.cnblogs.com/-clq/archive/2012/05/31/2528153.html" rel="nofollow" title="字符串哈希函数算法">字符串哈希函数算法</a></p> 
<p>由于string很常用，所以库里面有默认支持string类型的哈希函数，将哈希函数转化成可以取模的整数</p> 
<h3>3.2 unordered_set的封装</h3> 
<pre><code class="language-cpp">#pragma once
#include"HashTable.h"

namespace cyx
{
	template&lt;class K , class Hash = HashFunc&lt;K&gt;&gt; //不要再Hashtable里面传  会写死 这样自定义类型的key就没有办法解决了
	class unordered_set
	{
	public:
		struct SetKeyOfT
		{
			const K&amp; operator()(const K&amp; key)
			{
				return key;
			}
		};

		~unordered_set()
		{
			 clear();
		}

		//取类模板的内嵌类型 一定要用typename  不然无法区分这是一个类型还是成员变量 
		typedef typename HashTable&lt;K, K,SetKeyOfT,Hash&gt; ::const_iterator iterator; //set的迭代器不可被修改
		typedef typename HashTable&lt;K, K, SetKeyOfT, Hash&gt;::const_iterator const_iterator;
		iterator begin() //普通迭代器转化const迭代器 就会去调用那个拷贝构造
		{
			return _ht.begin();
		}
		iterator end()
		{
			return _ht.end();
		}

		const_iterator begin() const
		{
			return _ht.begin();
		}

		const_iterator end() const
		{
			return _ht.end();
		}

		pair&lt;iterator, bool&gt; insert(const K&amp; key)
		{
			return _ht.Insert(key);
		}

		iterator find(const K&amp; key)
		{
			return _ht.Find(key);
		}

		bool erase(const K&amp; key)
		{
			return _ht.Erase(key);
		}

		void clear() 
		{
			_ht.clear();
		}

		bool empty() const
		{
			return _ht.empty();
		}

	private:
		HashTable&lt;K, K, SetKeyOfT, Hash&gt;  _ht ;
	};
}</code></pre> 
<h3>3.3 unordered_map的封装</h3> 
<pre><code class="language-cpp">#pragma once
#include"HashTable.h"

namespace cyx
{
	template&lt;class K,class V,class Hash = HashFunc&lt;K&gt;&gt;
	class unordered_map
	{
	public:
		struct MapKeyOfT
		{
			const K&amp; operator()(const pair&lt;K,V&gt;&amp; kv) //帮助我们拿到key
			{
				return kv.first;
			}
		};

		 ~unordered_map()
		{
			clear();
		}

		//取类模板的内嵌类型 一定要用typename  不然无法区分这是一个类型还是成员变量 
		typedef typename HashTable&lt;K, pair&lt;const K, V&gt;, MapKeyOfT,Hash&gt; ::iterator iterator; //pair的key无论什么情况都不能修改 所以我们通过传const K控制
		typedef typename HashTable&lt;K, pair&lt;const K, V&gt;, MapKeyOfT,Hash&gt;::const_iterator const_iterator;
		typedef unordered_map&lt;K, V, Hash&gt; Self;

		iterator begin()
		{
			return _ht.begin();
		}
		iterator end()
		{
			return _ht.end();
		}

		const_iterator begin() const
		{
			return _ht.begin();
		}

		const_iterator end() const
		{
			return _ht.end();
		}


		pair&lt;iterator, bool&gt; insert(const pair&lt;K,V&gt;&amp; kv)
		{
			return _ht.Insert(kv);
		}

		iterator find(const K&amp; key) const
		{
			return _ht.Find(key);
		}

		bool erase(const K&amp; key)
		{
			return _ht.Erase();
		}

		V&amp; operator[](const K&amp; key)  //重载方括号
		{
			pair&lt;iterator, bool&gt; ret = insert(make_pair(key, V()));
			return ret.first-&gt;second;
		}
		

		void clear() 
		{
			_ht.clear();
		}

		bool empty() const
		{
			return _ht.empty();
		}


		void swap(Self&amp; s)
		{
			_ht.swap(s._ht);
		}
	private:
		HashTable&lt;K, pair&lt;const K, V&gt;, MapKeyOfT, Hash&gt; _ht; 
	};
</code></pre> 
<h3> 3.4 自定义类型的key</h3> 
<pre><code class="language-cpp">	class Date
	{
		friend struct HashDate; //确保能够访问其私有成员
	public:
		Date(int year = 1900, int month = 1, int day = 1)
			: _year(year)
			, _month(month)
			, _day(day)
		{}

		bool operator&lt;(const Date&amp; d)const
		{
			return (_year &lt; d._year) ||
				(_year == d._year &amp;&amp; _month &lt; d._month) ||
				(_year == d._year &amp;&amp; _month == d._month &amp;&amp; _day &lt; d._day);
		}

		bool operator&gt;(const Date&amp; d)const
		{
			return (_year &gt; d._year) ||
				(_year == d._year &amp;&amp; _month &gt; d._month) ||
				(_year == d._year &amp;&amp; _month == d._month &amp;&amp; _day &gt; d._day);
		}

		bool operator==(const Date&amp; d) const
		{
			return _year == d._year
				&amp;&amp; _month == d._month
				&amp;&amp; _day == d._day;
		}

		friend ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Date&amp; d);
	private:
		int _year;
		int _month;
		int _day;
	};

	ostream&amp; operator&lt;&lt;(ostream&amp; cout, const Date&amp; d)
	{
		cout &lt;&lt; d._year &lt;&lt; "-" &lt;&lt; d._month &lt;&lt; "-" &lt;&lt; d._day;
		return cout;
	}

	struct HashDate //自定义类型的key就手动传一个
	{
		size_t operator()(const Date&amp; d)
		{
			size_t hash = 0;
			hash += d._year;
			hash *= 31;

			hash += d._month;
			hash *= 31;

			hash += d._day;
			hash *= 31;

			return hash;
		}
	};

	// 一个类型要做unordered_map/unordered_set的key，要满足支持转换成取模的整形 和 ==比较
	
	// 一个类型要做map/set的key，要满足支持&lt;比较
	/*if (cur-&gt;key &lt; key)
	{}
	else if (key &lt; cur-&gt;key)
	{}
	else
	{}*/


	//如果有些类不是你写的，并不支持上面的东西 但是你还是想要去比较怎么办呢？？   其实库里面还提供了一个仿函数  class Pred = equal_to&lt;Key&gt;//判断各个键值对相同的规则

	void test_unordered_map4()
	{
		Date d1(2023, 3, 13);
		Date d2(2023, 3, 13);
		Date d3(2023, 3, 12);
		Date d4(2023, 3, 11);
		Date d5(2023, 3, 12);
		Date d6(2023, 3, 13);

		Date a[] = { d1, d2, d3, d4, d5, d6 };

		unordered_map&lt;Date, int, HashDate&gt; countMap;
		for (auto e : a)  ++countMap[e];
		for (auto&amp; kv : countMap)  cout &lt;&lt; kv.first &lt;&lt; ":" &lt;&lt; kv.second &lt;&lt; endl;
	}</code></pre> 
<p><img alt="" height="273" src="https://images2.imgbox.com/f7/43/YJ778Uxa_o.png" width="689"></p> 
<p>注意：</p> 
<p>1、 一个类型要做unordered_map/unordered_set的key，满足支持转换成 <span style="color:#fe2c24;"><strong>取模的整形</strong></span> 和 <span style="color:#fe2c24;"><strong>==比较</strong></span><br>        一个类型要做map/set的key，要满足<span style="color:#fe2c24;"><strong>支持&lt;比较 </strong></span></p> 
<p><span style="color:#0d0016;">2、但是如果该类不是你自己写的，我们没有办法直接去访问其私有成员，那就得再加一个模版参数</span><span style="color:#fe2c24;"><strong>class Pred = equal_to&lt;Key&gt; </strong></span><span style="color:#0d0016;">。增加判断键值相同的规则。</span></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/92/f8/WKqs0ssZ_o.jpg"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/367fbfe437b454add8cb4d018e009d95/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring IoC&amp;DI（1）—入门</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2efe50d08b0ba71b910197d5b0b1a40d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构与算法】之五道链表进阶面试题详解！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>