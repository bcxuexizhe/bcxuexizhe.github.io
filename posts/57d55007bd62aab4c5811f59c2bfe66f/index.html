<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Leetcode】vector刷题 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/57d55007bd62aab4c5811f59c2bfe66f/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【Leetcode】vector刷题">
  <meta property="og:description" content="🔥个人主页：Quitecoder
🔥专栏：Leetcode刷题
目录 1.只出现一次的数字2.杨辉三角3.删除有序数组中的重复项4.只出现一次的数字II5.只出现一次的数字III6.电话号码的字母组合 1.只出现一次的数字 题目链接：136.只出现一次的数字
题目描述：
这道题很简单，我们只需要遍历一遍数组，利用异或操作的性质（一个数与自身异或结果为0，任何数与0异或还是其本身）
class Solution { public: int singleNumber(vector&lt;int&gt;&amp; nums) { int value =0; for(auto v:nums) { value^=v; } return value; } }; 2.杨辉三角 题目链接：118.杨辉三角
题目描述：
这道题我们需要构造二维数组，典型的vector的嵌套使用
首先，我们先构建二维数组，开辟行数大小：
vector&lt;vector&lt;int&gt;&gt; v(numRows); 接着对每一行进行开辟空间，并将两端初始化为1
for(int i=0;i&lt;numRows;i&#43;&#43;) { v[i].resize(i&#43;1); v[i][0]=1;v[i][i]=1; } 注意，resize是会进行初始化的，我们没有传值，默认为零
所以我们只需要遍历一遍，遍历到的位置为0，进行相加操作
完整代码如下：
class Solution { public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) { vector&lt;vector&lt;int&gt;&gt; v(numRows); for(int i=0;i&lt;numRows;i&#43;&#43;) { v[i].resize(i&#43;1); v[i][0]=1;v[i][i]=1; } for(int i=0;i&lt;numRows;i&#43;&#43;) { for(int j=0;j&lt;i;j&#43;&#43;) { if(v[i][j]==0) { v[i][j]=v[i-1][j]&#43;v[i-1][j-1]; } } } return v; } }; 3.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-26T21:43:59+08:00">
    <meta property="article:modified_time" content="2024-04-26T21:43:59+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Leetcode】vector刷题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/33/b7/zVlDj4MP_o.png" alt="Alt" width="300" height="170"></p> 
<p><font color="peru" size="4"><b>🔥个人主页</b>：<a href="https://blog.csdn.net/arf_dog?type=blog"><font color="#33CCCC" size="4"><b>Quitecoder</b></font></a></font></p> 
<p><font color="peru" size="4">🔥<strong>专栏</strong></font>：<a href="https://blog.csdn.net/arf_dog/category_12623500.html?spm=1001.2014.3001.5482"><font color="#33CCCC" size="4"><b>Leetcode刷题</b></font></a></p> 
<p><img src="https://images2.imgbox.com/72/e1/lGfn6fos_o.gif" alt="Alt"><br> </p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#1_11" rel="nofollow">1.只出现一次的数字</a></li><li><a href="#2_31" rel="nofollow">2.杨辉三角</a></li><li><a href="#3_83" rel="nofollow">3.删除有序数组中的重复项</a></li><li><a href="#4II_110" rel="nofollow">4.只出现一次的数字II</a></li><li><a href="#5III_178" rel="nofollow">5.只出现一次的数字III</a></li><li><a href="#6_254" rel="nofollow">6.电话号码的字母组合</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1_11"></a>1.只出现一次的数字</h2> 
<blockquote> 
 <p><strong>题目链接</strong>：<a href="https://leetcode.cn/problems/single-number/" rel="nofollow">136.只出现一次的数字</a><br> <strong>题目描述</strong>：<img src="https://images2.imgbox.com/de/47/JqO7KdwY_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p><strong>这道题很简单，我们只需要遍历一遍数组，利用异或操作的性质（一个数与自身异或结果为0，任何数与0异或还是其本身）</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> value <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> v<span class="token operator">:</span>nums<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            value<span class="token operator">^=</span>v<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="2_31"></a>2.杨辉三角</h2> 
<blockquote> 
 <p><strong>题目链接</strong>：<a href="https://leetcode.cn/problems/pascals-triangle/description/" rel="nofollow">118.杨辉三角</a><br> <strong>题目描述</strong>：<img src="https://images2.imgbox.com/e9/78/cEwdrFDE_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>这道题我们需要构造二维数组，典型的vector的嵌套使用</p> 
<p><img src="https://images2.imgbox.com/87/2d/axKaNn2R_o.png" alt="在这里插入图片描述"><br> 首先，我们先构建二维数组，开辟行数大小：</p> 
<pre><code class="prism language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">v</span><span class="token punctuation">(</span>numRows<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>接着对每一行进行开辟空间，并将两端初始化为1</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>numRows<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>注意，resize是会进行初始化的，我们没有传值，<strong>默认为零</strong></p> 
<p>所以我们只需要遍历一遍，<strong>遍历到的位置为0，进行相加操作</strong></p> 
<p>完整代码如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">generate</span><span class="token punctuation">(</span><span class="token keyword">int</span> numRows<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">v</span><span class="token punctuation">(</span>numRows<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>numRows<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>numRows<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>v<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>v<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token keyword">return</span> v<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="3_83"></a>3.删除有序数组中的重复项</h2> 
<blockquote> 
 <p><strong>题目链接</strong>：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/" rel="nofollow">26.删除有序数组中的重复项</a><br> <strong>题目描述</strong>：<img src="https://images2.imgbox.com/6d/52/ePZCy71d_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>这题是一道简单的双指针思路的题，由于已经排序好，我们只需要设置两个索引，一个向后遍历，若与前面的索引指向值不相同，则对前面的值进行修改</p> 
<pre><code class="prism language-cpp">lass Solution <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> slow <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> fast <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> fast <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> fast<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span> <span class="token operator">!=</span> nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                slow<span class="token operator">++</span><span class="token punctuation">;</span>
                nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> slow <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>完成了<strong>值的覆盖过程</strong></p> 
<h2><a id="4II_110"></a>4.只出现一次的数字II</h2> 
<blockquote> 
 <p><strong>题目链接</strong>：<a href="https://leetcode.cn/problems/single-number-ii/" rel="nofollow">137.只出现一次的数字II</a><br> <strong>题目描述</strong>：<img src="https://images2.imgbox.com/c8/c9/QYlkCtu0_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>这个问题的解决方案基于位操作和有限状态自动机的原理。我们要处理的数字是32位整数，因此，我们需要考虑每一位相加后的结果。由于除了一个数字以外，其它数字都出现了三次，我们可以构造一个数字的每一位相加后，模3的结果就是这个只出现一次的数字的相应位</p> 
<p>思路如下：</p> 
<p>使用两个整数变量<code>ones</code>和<code>twos</code>。<code>ones</code>将会记录每个位只出现一次的情况，而<code>twos</code>将会记录每个位出现两次的情况</p> 
<p>对于每个数字<code>num</code>及其每一位，我们更新<code>ones</code>和<code>twos</code>：</p> 
<ol><li> <p>在第<code>i</code>个位置上，如果<code>ones</code>里的位是1，则表示<code>num</code>要么是第一次遇到<code>i</code>位为1，要么是第四次。如果是第四次，我们已经在<code>twos</code>里记录了两次，所以这次应该把<code>ones</code>里的该位清零，否则保持不变</p> </li><li> <p>同理，如果<code>twos</code>里的位是1，则是第二次遇到<code>i</code>位为1或者是第五次。如果是第五次，我们既要在<code>ones</code>里面加1，同时也要在<code>twos</code>里面清零该位，否则保持不变</p> </li><li> <p>由于我们只需要考虑每个位上1出现的次数，所以任何时候位上的1出现3次，我们都应该清零</p> </li></ol> 
<p>最后，<code>ones</code>保留的就是每位上出现一次的结果，而<code>twos</code>将会是0。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> ones <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> twos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            ones <span class="token operator">=</span> <span class="token punctuation">(</span>ones <span class="token operator">^</span> num<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span>twos<span class="token punctuation">;</span>
            twos <span class="token operator">=</span> <span class="token punctuation">(</span>twos <span class="token operator">^</span> num<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span>ones<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ones<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>当我们讨论处理出现三次的数字和一个只出现一次的数字时，<code>ones</code> 和 <code>twos</code> 的位操作确实是难以理解的 ，分解这两行代码：</p> 
<p>对于每一个新的数字 <code>num</code>，我们用 <code>ones</code> 和 <code>twos</code> 来跟踪彼此独立的状态：</p> 
<ol><li><code>ones = (ones ^ num) &amp; ~twos;</code></li></ol> 
<p>这里，我们正更新 <code>ones</code> 以包含出现一次的位。让我们分解这行代码：</p> 
<ul><li> <p><code>ones ^ num</code>：这个<strong>按位异或操作</strong>背后的思想是：当前的 <code>ones</code> 表示上一步迭代中已经出现一次的位。当我们再次看到这些位时（即 <code>num</code> 中的对应位也是1），我们希望重置 <code>ones</code> 中的那些位（因为出现一次变成了两次）。对于 <code>num</code> 中新出现的1，<code>ones</code> 中还没有记录，这将被加进 <code>ones</code></p> </li><li> <p><code>&amp; ~twos</code>：接下来的<strong>按位与操作</strong>与 <code>~twos</code> 结合表示：我们删除 <code>twos</code> 中已经出现两次的位。<code>~twos</code> 是对 <code>twos</code> 取反，意味着取出 <code>twos</code> 中为0的位。只有那些在 <code>twos</code> 中没有记录（即还没达到两次）的1才应该加入 <code>ones</code>。即使刚才 <code>ones ^ num</code> 把某些位变成了1，若那些位在 <code>twos</code> 中已经出现过两次，我们必须确保它们在 <code>ones</code> 中不变成1</p> </li></ul> 
<p>结合二者，<code>ones</code> 在每次迭代结束时仅保留那些恰好出现一次的位。如果某位在 <code>ones</code> 中变成了1但已经在 <code>twos</code> 中出现过，我们需要重置 <code>ones</code> 中的那位为0</p> 
<ol start="2"><li><code>twos = (twos ^ num) &amp; ~ones;</code></li></ol> 
<p>接着我们更新 <code>twos</code> 来反映那些已经看到两次的位：</p> 
<ul><li> <p><code>twos ^ num</code>：与更新 <code>ones</code> 类似，我们对于每个新来的 <code>num</code>，我们都会用<strong>按位异或</strong>更新 <code>twos</code>。如果在 <code>twos</code> 中的位是1，且对应的 <code>num</code> 中的位也是1，那么它们会重置为0，因为现在这个位出现了第三次，而我们的目标是找到出现了一次和两次的位。如果出现的是一个新的1（即 <code>num</code> 中的1，而 <code>twos</code> 中并没有记录），<code>twos</code> 就会记录它。这会出现加到三的情况，我们随后会处理。</p> </li><li> <p><code>&amp; ~ones</code>：这个<strong>按位与</strong>操作保证如果在 <code>ones</code> 中有1（意味着这个位已经出现了一次），我们不会在 <code>twos</code> 中加入该位。如果某个位同时在 <code>ones</code> 和 <code>twos</code> 中出现，这意味着这个位出现了3次，并且最终会被忽略。</p> </li></ul> 
<p>通过 <code>&amp; ~ones</code>，我们确保了一个位仅仅当它在 <code>num</code> 中为1且在 <code>ones</code> 中尚未出现（即 <code>ones</code> 中为0）时，才会被加入 <code>twos</code>。</p> 
<p>总结来说，这两步操作是相互独立并且排他的：它们保证一个位在 <code>ones</code> 或 <code>twos</code> 中出现，但不会同时出现。我们在整体数组中使用循环来考虑每个数字的影响。最终，由于所有出现三次的数字在这两个变量中都被消去，<code>ones</code> 会留下那个出现一次的唯一位</p> 
<h2><a id="5III_178"></a>5.只出现一次的数字III</h2> 
<blockquote> 
 <p><strong>题目链接</strong>：<a href="https://leetcode.cn/problems/single-number-iii/description/" rel="nofollow">260.只出现一次的数字III</a><br> <strong>题目描述</strong>：<img src="https://images2.imgbox.com/e7/6d/Kl9nVpbk_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>此类问题可以通过位运算（异或操作）来解决。首先，我们可以通过对所有数组元素执行异或操作来找出两个只出现一次的元素的异或结果。因为异或操作具有交换律和结合律，<strong>同时一个数字和自己进行异或会变成0，所以最终剩下的结果就是那两个只出现一次的数字的异或结果</strong></p> 
<p>这个结果中至少有一个位是1（<strong>否则这两个数相同</strong>），我们可以找到这个数中的任何一个为1的位，用它来把原数组分成两组，一组在该位上是1，一组在该位上是0。这样每组就包含了一个只出现一次的数字和一些成对出现的数字。然后再对这两个组分别进行异或操作，即可得到这两个只出现一次的数字。</p> 
<p>下面是这个算法实现：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 第一步，对所有元素进行异或，最终的结果就是两个只出现一次数的异或结果</span>
        <span class="token keyword">int</span> diff <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            diff <span class="token operator">^=</span> num<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token comment">// 找到diff中任何为1的位，可以使用diff &amp; -diff快速找到</span>
        <span class="token comment">// 这个操作可以隔离出diff最右端的1</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> diff_unsigned <span class="token operator">=</span> diff<span class="token punctuation">;</span>
        diff_unsigned <span class="token operator">&amp;=</span> <span class="token operator">-</span>diff_unsigned<span class="token punctuation">;</span>

        <span class="token comment">// 使用找到的这一位将数组中的数字分成两组</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">results</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 最终结果</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>num <span class="token operator">&amp;</span> diff_unsigned<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 第一组，与diff_unsigned对应位为0</span>
                results<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">^=</span> num<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 第二组，与diff_unsigned对应位为1</span>
                results<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">^=</span> num<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        
        <span class="token keyword">return</span> results<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>在这个代码中：</p> 
<ul><li><code>diff_unsigned</code> 最终会被设置为两个目标数字的异或结果。</li><li><code>diff_unsigned &amp;= -diff_unsigned;</code> 的结果是取出 <code>diff_unsigned</code> 最右边的1位，也就是两个只出现一次的数在这一位上不同的地方。</li><li>然后我们通过判断这一位是否为1来将全部数字分为两组，并再次分别对它们进行异或操作，以此找到两个只出现一次的数。</li></ul> 
<p>这条语句 <code>diff_unsigned &amp;= -diff_unsigned;</code> 是一种计算机用来找到一个数字中最右边的1的位，并且保持所有其他位为0的技巧。为了更好地理解这个技巧，我们需要先了解计算机中的数字表示——特别是补码表示法，因为这个技巧与负数的二进制表示相关</p> 
<p>在补码表示中，一个负数是通过取其正值的二进制表示的反码（每个位取反）然后加1得到的。例如，假设我们有一个4位的系统：</p> 
<pre><code class="prism language-bash">正数 <span class="token number">2</span> 的二进制表示:  0010
反码 <span class="token punctuation">(</span>invert<span class="token punctuation">)</span>:      <span class="token number">1101</span>
加1得到负数 -2:      <span class="token number">1110</span>
</code></pre> 
<p>观察发现，从正数2的二进制表示到负数-2的表示，最右边的1以及之前的所有0都保持不变，而最右边的1之后的所有位都翻转了。这给了我们一种找到最右边的1的方法。现在，如果我们对2和-2执行按位与操作：</p> 
<pre><code class="prism language-bash">正数 <span class="token number">2</span>:                0010
负数 -2:               <span class="token number">1110</span>
按位与:                0010
</code></pre> 
<p>按位与操作的结果就是只有最右边的1保留了下来，其它所有位都变成了0。换句话说，<code>diff_unsigned &amp;= -diff_unsigned;</code> 将结果的所有位都置为0，除了最右边的1所在的位。</p> 
<p>在解决问题时，我们首先会通过对所有数字进行异或得到 <code>diff</code>，这代表了两个只出现一次的数字的差异。<br> diff 变量首先被转换成一个无符号整数 diff_unsigned，然后对它进行取负和按位与操作，<strong>以避免未定义行为</strong>。这样就保证了即使 diff 的最高有效位是1，我们也不会超出无符号整型的范围</p> 
<p>然后使用 <code>diff_unsigned &amp;= -diff_unsigned;</code> 来保留最右边的1，这是两个独特数字在二进制表示中第一个不同的位。</p> 
<p>通过这个位的差异，我们可以将所有的数字分成两组来进一步操作，每组包含一个只出现一次的数字以及成对出现的数字。这个1所在的位将用于分辨哪些数字在该位为0或1 —— 这正是对数组进行划分的依据</p> 
<h2><a id="6_254"></a>6.电话号码的字母组合</h2> 
<blockquote> 
 <p><strong>题目链接</strong>：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/" rel="nofollow">17.电话号码的字母组合</a><br> <strong>题目描述</strong>：<img src="https://images2.imgbox.com/2c/4f/vlufbwjS_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>这个问题可以通过回溯法解决，这是一种通过穷举所有可能的解来找到全部解的算法。基本思想是从左到右遍历数字字符串，对于每个数字，向当前的字母组合中添加对应的每个字母，然后对剩余的字符串重复这个过程。</p> 
<p>下面是递归解决实现：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">letterCombinations</span><span class="token punctuation">(</span>string digits<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>digits<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 如果输入为空，直接返回空数组</span>
        
        vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> mappings <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>  <span class="token comment">// 数字到字母的映射</span>
            <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"def"</span><span class="token punctuation">,</span>   <span class="token comment">// '0','1','2',...</span>
            <span class="token string">"ghi"</span><span class="token punctuation">,</span> <span class="token string">"jkl"</span><span class="token punctuation">,</span> <span class="token string">"mno"</span><span class="token punctuation">,</span>
            <span class="token string">"pqrs"</span><span class="token punctuation">,</span> <span class="token string">"tuv"</span><span class="token punctuation">,</span> <span class="token string">"wxyz"</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> result<span class="token punctuation">;</span>
        string current<span class="token punctuation">;</span>
        
        <span class="token function">backtrack</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> digits<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> current<span class="token punctuation">,</span> mappings<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token operator">&amp;</span> result<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> digits<span class="token punctuation">,</span> 
                   <span class="token keyword">int</span> index<span class="token punctuation">,</span> string<span class="token operator">&amp;</span> current<span class="token punctuation">,</span> <span class="token keyword">const</span> vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token operator">&amp;</span> mappings<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> digits<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 如果到达了数字字符串的末尾，就添加当前的字母组合到结果中</span>
            result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        string letters <span class="token operator">=</span> mappings<span class="token punctuation">[</span>digits<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前数字对应的所有字母</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> letter <span class="token operator">:</span> letters<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 遍历这些字母</span>
            current<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>letter<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 添加当前的字母</span>
            <span class="token function">backtrack</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> digits<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> current<span class="token punctuation">,</span> mappings<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 继续处理下一个数字</span>
            current<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 回溯，移除当前字母，以便尝试下一个字母</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>这段代码定义了一个辅助函数 <code>backtrack</code>，用来递归寻找所有可能的字母组合。我们维护一个 <code>current</code> 字符串，它保存当前的部分组合。函数的工作流程是这样的：</p> 
<ol><li> <p>确定终止条件：如果 <code>current</code> 的长度与输入数字字符串的长度相同，说明当前递归路径已经走到头，我们找到了一个完整的字母组合，将其添加到结果中。</p> </li><li> <p>确定递归逻辑：从 <code>mappings</code> 数组中获取当前处理的数字对应的所有可能字母，然后逐一向 <code>current</code> 添加每个字母，并递归地调用自己处理下一个数字。</p> </li><li> <p>回溯处理：每次递归调用完成后，需要将之前添加的字母移除，以便对当前位置尝试不同的字母。</p> </li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/92c72a90cad7cb2911bd035aba8990d3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Kafka 3.x.x 入门到精通（03）——Kafka基础生产消息</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/71228584a2fb1c680f46c6cb2bfd273a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CentOS 7配置hadoop和hbase伪分布式模式保姆级教程（近乎零基础跟着配也能配对）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>