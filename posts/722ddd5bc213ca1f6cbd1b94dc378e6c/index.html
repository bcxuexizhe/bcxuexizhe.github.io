<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【c&#43;&#43;】模板编程解密：C&#43;&#43;中的特化、实例化和分离编译 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/722ddd5bc213ca1f6cbd1b94dc378e6c/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【c&#43;&#43;】模板编程解密：C&#43;&#43;中的特化、实例化和分离编译">
  <meta property="og:description" content="🔥个人主页：Quitecoder
🔥专栏：c&#43;&#43;笔记仓
朋友们大家好，本篇文章我们来学习模版的进阶部分
目录 `1.非类型模版参数``按需实例化` `2.模版的特化``函数模版特化``函数模版的特化``类模版``全特化``偏特化` `3.分离编译``模版分离编译` 1.非类型模版参数 模板参数分类类型形参与非类型形参。
类型形参即：出现在模板参数列表中，跟在class或者typename之类的参数类型名称非类型形参，就是用一个常量作为类(函数)模板的一个参数，在类(函数)模板中可将该参数当成常量来使用 非类型模板参数允许你将一个值（而不是一个类型）直接传递给一个模板。非类型模板参数可以是一个整型值、一个指针或者一个引用，因为这些参数不是类型，所以被称为“非类型模板参数”。
非类型模板参数可以让你根据这些值创建模板实例。例如，你可以根据整型非类型模板参数定义编译时决定大小的数组
引入下面的例子：
#define N 10 template&lt;class T&gt; class array { public: T&amp; operator[](size_t index) { return _array[index]; } const T&amp; operator[](size_t index)const { return _array[index]; } size_t size()const { return _size; } bool empty()const { return 0 == _size; } private: T _array[N]; size_t _size; }; 对于这个静态数组，我们只能用宏定义来确定数组的大小，那如果我一次性想要开两个大小不同的数组呢？
array&lt;int&gt; a1;//大小为10 array&lt;int&gt; a2;//大小为100 这里就需要非类型模版参数
template&lt;class T, size_t N = 10&gt; class array { public: T&amp; operator[](size_t index) { return _array[index]; } const T&amp; operator[](size_t index)const { return _array[index]; } size_t size()const { return _size; } bool empty()const { return 0 == _size; } private: T _array[N]; size_t _size; }; 在这个例子中，N 就是一个非类型模板参数，它表示数组的大小，而 T 是一个类型模板参数代表数组中元素的类型">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-01T23:25:00+08:00">
    <meta property="article:modified_time" content="2024-05-01T23:25:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【c&#43;&#43;】模板编程解密：C&#43;&#43;中的特化、实例化和分离编译</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/4f/6e/RyHu7uMU_o.png" alt="Alt" width="300" height="170"></p> 
<p><font color="peru" size="4"><b>🔥个人主页</b>：<a href="https://blog.csdn.net/arf_dog?type=blog"><font color="#33CCCC" size="4"><b>Quitecoder</b></font></a></font></p> 
<p><font color="peru" size="4">🔥<strong>专栏</strong></font>：<a href="https://blog.csdn.net/arf_dog/category_12614029.html?spm=1001.2014.3001.5482"><font color="#33CCCC" size="4"><b>c++笔记仓</b></font></a></p> 
<p><img src="https://images2.imgbox.com/e8/ca/4cwk7wpW_o.gif" alt="Alt"></p> 
<blockquote> 
 <p>朋友们大家好，本篇文章我们来学习<strong>模版的进阶</strong>部分</p> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#1_17" rel="nofollow">`1.非类型模版参数`</a></li><li><ul><li><a href="#_86" rel="nofollow">`按需实例化`</a></li></ul> 
  </li><li><a href="#2_122" rel="nofollow">`2.模版的特化`</a></li><li><ul><li><a href="#_124" rel="nofollow">`函数模版特化`</a></li><li><a href="#_151" rel="nofollow">`函数模版的特化`</a></li><li><a href="#_187" rel="nofollow">`类模版`</a></li><li><ul><li><a href="#_189" rel="nofollow">`全特化`</a></li><li><a href="#_233" rel="nofollow">`偏特化`</a></li></ul> 
  </li></ul> 
  </li><li><a href="#3_378" rel="nofollow">`3.分离编译`</a></li><li><ul><li><a href="#_426" rel="nofollow">`模版分离编译`</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1_17"></a><code>1.非类型模版参数</code></h2> 
<p>模板参数分类类型形参与非类型形参。</p> 
<ul><li>类型形参即：出现在模板参数列表中，<strong>跟在class或者typename之类的参数类型名称</strong></li><li>非类型形参，<strong>就是用一个常量作为类(函数)模板的一个参数，在类(函数)模板中可将该参数当成常量来使用</strong></li></ul> 
<p>非类型模板参数允许你将一个值（而不是一个类型）直接传递给一个模板。非类型模板参数可以是一个整型值、一个指针或者一个引用，因为这些参数不是类型，所以被称为“非类型模板参数”。</p> 
<p>非类型模板参数可以让你根据这些值创建模板实例。例如，你可以根据整型非类型模板参数定义编译时决定大小的数组</p> 
<p><strong>引入下面的例子</strong>：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">10</span></span></span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">array</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t index<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> _array<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
	<span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t index<span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> _array<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

	size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> _size<span class="token punctuation">;</span> <span class="token punctuation">}</span>
	<span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token number">0</span> <span class="token operator">==</span> _size<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	T _array<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
	size_t _size<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>对于这个静态数组，我们只能用宏定义来确定数组的大小，<strong>那如果我一次性想要开两个大小不同的数组呢</strong>？</p> 
<pre><code class="prism language-cpp">array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> a1<span class="token punctuation">;</span><span class="token comment">//大小为10</span>
array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> a2<span class="token punctuation">;</span><span class="token comment">//大小为100</span>
</code></pre> 
<p>这里就需要非类型模版参数</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> size_t N <span class="token operator">=</span> <span class="token number">10</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">array</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t index<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> _array<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
	<span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t index<span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> _array<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

	size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> _size<span class="token punctuation">;</span> <span class="token punctuation">}</span>
	<span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token number">0</span> <span class="token operator">==</span> _size<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	T _array<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
	size_t _size<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>在这个例子中，<code>N</code> 就是一个非类型模板参数，它表示<strong>数组的大小</strong>，而 T 是一个类型模板参数代表数组中元素的类型</p> 
<p>使用方法：</p> 
<pre><code class="prism language-cpp">array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token operator">&gt;</span> a1<span class="token punctuation">;</span>
array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token operator">&gt;</span> a2<span class="token punctuation">;</span>
</code></pre> 
<p><font color="red" size="5">注意：</font></p> 
<ul><li><strong>浮点数、类对象以及字符串是不允许作为非类型模板参数的</strong></li><li><mark>使用非类型模板参数的时候，你传递的值必须在编译时就确定下来。这意味着你不能用动态计算的值或者运行时才能得知的值作为非类型模板参数的实参</mark></li></ul> 
<h3><a id="_86"></a><code>按需实例化</code></h3> 
<p>按需实例化，是 C++ 模板的一个重要特性，<mark>指的是模板代码只有在真正被使用时才会被编译器实例化</mark></p> 
<p>在 C++ 中，模板本身并不直接生成可执行代码；它们是用于生成代码的蓝图。当你编写一个模板类或模板函数时，你实际上是在告诉编译器如何在需要的时候用具体的类型或值生成代码。<strong>这种生成过程只有在模板被用到的时候才会发生，换言之，只有在代码中显式或隐式地引用了模板的具体实例</strong>，编译器才会根据模板生成那个特定实例的代码。这就是所谓的按需实例化</p> 
<p>比如，对于上面的代码，我在<code>T&amp; operator[]</code>函数中写一个错误的语法：</p> 
<pre><code class="prism language-cpp">T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t index<span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">size</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> _array<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
</code></pre> 
<p><strong>并没有产生编译错误</strong></p> 
<blockquote> 
 <p><strong>由于模板的这个行为，如果模板的某些部分（在本例中是 _size的使用）没有在代码中被实际使用，那么编译器可能不会去实例化或者编译这个部分，它可能不会产生编译错误</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>在一些编译器和编译设置下，成员函数模板只有在被调用时才会实例化。如果编译器没有看到 <code>size()</code> 或者 <code>empty()</code>的任何调用，它也就不会去检查 <code>_size</code> 是否已经初始化，就不会产生潜在的错误</strong></p> 
</blockquote> 
<p>此外，对于 <code>operator[]</code> 的实现：</p> 
<pre><code class="prism language-cpp">T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t index<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">size</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里的调用看上去像是一个函数调用，但是没有意义，因为它对程序行为没有任何影响。</span>
    <span class="token keyword">return</span> _array<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>size(1);</code> 这行代码试图调用 <code>size()</code> 成员函数并传递一个参数，但这显然是不正确的，因为 <code>size()</code> 没有定义接受参数的版本，应该是 <code>size_t size()const</code>。<strong>如果在代码中有地方调用了这个重载的 <code>operator[]</code>，并且编译器实例化了这部分代码，则会产生编译错误。但如果没有任何地方使用了这个重载的 <code>operator[]</code>，编译器则不会去检查这部分代码，错误也就没有暴露出来</strong></p> 
<h2><a id="2_122"></a><code>2.模版的特化</code></h2> 
<h3><a id="_124"></a><code>函数模版特化</code></h3> 
<p>通常情况下，<strong>使用模板可以实现一些与类型无关的代码，但对于一些特殊类型的可能会得到一些错误的结果，需要特殊处理</strong>，比如：实现了一个专门用来进行小于比较的函数模板</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">bool</span> <span class="token function">Less</span><span class="token punctuation">(</span>T left<span class="token punctuation">,</span> T right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token function">Less</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 可以比较，结果正确</span>
	Date <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">2022</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Date <span class="token function">d2</span><span class="token punctuation">(</span><span class="token number">2022</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token function">Less</span><span class="token punctuation">(</span>d1<span class="token punctuation">,</span> d2<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 可以比较，结果正确</span>
	Date<span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>d1<span class="token punctuation">;</span>
	Date<span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>d2<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token function">Less</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 可以比较，结果错误</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>可以看到，Less绝对多数情况下都可以正常比较，但是在特殊场景下就得到错误的结果。上述示例中，p1指向的d1显然小于p2指向的d2对象，但是Less内部并没有比较p1和p2指向的对象内容，而比较的是p1和p2指针的地址，这就无法达到预期而错误</strong></p> 
<p>此时，就需要对模板进行特化。即：在原模板类的基础上，针对特殊类型所进行特殊化的实现方式。模板特化中分为<mark>函数模板特化</mark>与<mark>类模板特化</mark></p> 
<h3><a id="_151"></a><code>函数模版的特化</code></h3> 
<p><strong>函数模板的特化步骤</strong>：</p> 
<ol><li><strong>必须要先有一个基础的函数模板</strong></li><li><strong>关键字template后面接一对空的尖括号<code>&lt;&gt;</code></strong></li><li><strong>函数名后跟一对尖括号，尖括号中指定需要特化的类型</strong></li><li><mark>函数形参表: 必须要和模板函数的基础参数类型完全相同，如果不同编译器可能会报一些奇怪的错误</mark></li></ol> 
<pre><code class="prism language-cpp"><span class="token comment">// 函数模板 -- 参数匹配</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">bool</span> <span class="token function">Less</span><span class="token punctuation">(</span>T left<span class="token punctuation">,</span> T right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 对Less函数模板进行特化</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>
<span class="token keyword">bool</span> <span class="token generic-function"><span class="token function">Less</span><span class="token generic class-name"><span class="token operator">&lt;</span>Date<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>Date<span class="token operator">*</span> left<span class="token punctuation">,</span> Date<span class="token operator">*</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token operator">*</span>left <span class="token operator">&lt;</span> <span class="token operator">*</span>right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>特化，针对某些特殊类型可以进行特殊处理</strong></p> 
<blockquote> 
 <p><strong>注意：一般情况下如果函数模板遇到不能处理或者处理有误的类型，为了实现简单通常都是将该函数直接给出</strong></p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">Less</span><span class="token punctuation">(</span>Date<span class="token operator">*</span> left<span class="token punctuation">,</span> Date<span class="token operator">*</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token operator">*</span>left <span class="token operator">&lt;</span> <span class="token operator">*</span>right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>该种实现简单明了，代码的可读性高，容易书写，因为对于一些参数类型复杂的函数模板，特化时特别给出，因此函数模板不建议特化</strong></p> 
<h3><a id="_187"></a><code>类模版</code></h3> 
<h4><a id="_189"></a><code>全特化</code></h4> 
<p>比如我们有下面这个模版类：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Data</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Data&lt;T1, T2&gt;"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	T1 _d1<span class="token punctuation">;</span>
	T2 _d2<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>全特化即是将模板参数列表中所有的参数都确定化</strong>，如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Data</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&gt;</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Data&lt;int, char&gt;"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _d1<span class="token punctuation">;</span>
	<span class="token keyword">char</span> _d2<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>注意格式，<code>template&lt;&gt;</code>关键字加尖括号，尖括号里面为空，在类后面加尖括号给具体的类型</strong></p> 
<p>这个全特化是对于模板实参为 int 和 char 的情况。这意味着当创建一个 <code>Data&lt;int, char&gt;</code> 类型的实例时，<strong>这个特化版本会被使用，而不是泛型的基础模板</strong></p> 
<p>测试如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Data<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> d1<span class="token punctuation">;</span>
	Data<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&gt;</span> d2<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/12/be/MvJU9tEt_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_233"></a><code>偏特化</code></h4> 
<p><strong>偏特化：任何针对模版参数进一步进行条件限制设计的特化版本。比如对于以下模板类：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Data</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Data&lt;T1, T2&gt;"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	T1 _d1<span class="token punctuation">;</span>
	T2 _d2<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>偏特化有以下两种表现方式</strong>：</p> 
<ul><li>部分特化：<strong>将模板参数类表中的一部分参数特化</strong></li></ul> 
<pre><code class="prism language-cpp"><span class="token comment">// 将第二个参数特化为int</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Data</span><span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Data&lt;T1, int&gt;"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	T1 _d1<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _d2<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>测试匹配结果：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Data<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">&gt;</span> d1<span class="token punctuation">;</span>
	Data<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&gt;</span> d2<span class="token punctuation">;</span>
	Data<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span>d3<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/2a/c7/iLWe0b5K_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>参数更进一步的限制</strong>：<mark>偏特化并不仅仅是指特化部分参数，而是针对模板参数更进一步的条件限制所设计出来的一个特化版本</mark></li></ul> 
<p>比如，两个参数偏特化为<strong>指针类型</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Data</span> <span class="token operator">&lt;</span>T1<span class="token operator">*</span><span class="token punctuation">,</span> T2<span class="token operator">*</span><span class="token operator">&gt;</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Data&lt;T1*, T2*&gt;"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	 T1 _d1<span class="token punctuation">;</span>
	 T2 _d2<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>两个参数偏特化为<strong>引用类型</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Data</span> <span class="token operator">&lt;</span>T1<span class="token operator">&amp;</span><span class="token punctuation">,</span> T2<span class="token operator">&amp;</span><span class="token operator">&gt;</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Data</span><span class="token punctuation">(</span><span class="token keyword">const</span> T1<span class="token operator">&amp;</span> d1<span class="token punctuation">,</span> <span class="token keyword">const</span> T2<span class="token operator">&amp;</span> d2<span class="token punctuation">)</span>
		<span class="token operator">:</span> <span class="token function">_d1</span><span class="token punctuation">(</span>d1<span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_d2</span><span class="token punctuation">(</span>d2<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Data&lt;T1&amp;, T2&amp;&gt;"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">const</span> T1<span class="token operator">&amp;</span> _d1<span class="token punctuation">;</span>
	<span class="token keyword">const</span> T2<span class="token operator">&amp;</span> _d2<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>测试如下：</p> 
<pre><code class="prism language-cpp">Data<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">&gt;</span> d1<span class="token punctuation">;</span>
Data<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&gt;</span> d2<span class="token punctuation">;</span>
Data<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span>d3<span class="token punctuation">;</span>
Data<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">*</span><span class="token operator">&gt;</span> d4<span class="token punctuation">;</span>
Data<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">&gt;</span> <span class="token function">d5</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/6b/02/oH6q0rvI_o.png" alt="在这里插入图片描述"></p> 
<p><font color="blue" size="5">示例：</font></p> 
<p><strong>有如下专门用来按照小于比较的类模板Less</strong></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">Less</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> y<span class="token punctuation">)</span> <span class="token keyword">const</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> x <span class="token operator">&lt;</span> y<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>我们可以进行下面的排序：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Date <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">2022</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Date <span class="token function">d2</span><span class="token punctuation">(</span><span class="token number">2022</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Date <span class="token function">d3</span><span class="token punctuation">(</span><span class="token number">2022</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span>Date<span class="token operator">&gt;</span> v1<span class="token punctuation">;</span>
	v1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>d1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	v1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>d2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	v1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>d3<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 可以直接排序，结果是日期升序</span>
	<span class="token function">sort</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">Less</span><span class="token generic class-name"><span class="token operator">&lt;</span>Date<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>但是看下面的排序对象：</p> 
<pre><code class="prism language-cpp">vector<span class="token operator">&lt;</span>Date<span class="token operator">*</span><span class="token operator">&gt;</span> v2<span class="token punctuation">;</span>
v2<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d1<span class="token punctuation">)</span><span class="token punctuation">;</span>
v2<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d2<span class="token punctuation">)</span><span class="token punctuation">;</span>
v2<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">sort</span><span class="token punctuation">(</span>v2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">Less</span><span class="token generic class-name"><span class="token operator">&lt;</span>Date<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>可以直接排序，结果错误，<strong>日期还不是升序，而v2中放的地址是升序</strong></p> 
<p><strong>通过观察上述程序的结果发现，对于日期对象可以直接排序，并且结果是正确的。但是如果待排序元素是指针，结果就不一定正确。因为：sort最终按照Less模板中方式比较，所以只会比较指针，而不是比较指针指向空间中内容，此时可以使用类版本特化来处理上述问题：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">Less</span><span class="token operator">&lt;</span>Date<span class="token operator">*</span><span class="token operator">&gt;</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Date<span class="token operator">*</span> x<span class="token punctuation">,</span> Date<span class="token operator">*</span> y<span class="token punctuation">)</span> <span class="token keyword">const</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token operator">*</span>x <span class="token operator">&lt;</span> <span class="token operator">*</span>y<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>特化之后，再运行上述代码，就可以得到正确的结果</strong></p> 
<h2><a id="3_378"></a><code>3.分离编译</code></h2> 
<blockquote> 
 <p><strong>分离编译允许将程序的不同部分分别编译成单独的编译单元，通常是目标文件（object file，拓展名通常为 <code>.o</code> 或<code>.obj</code>）。然后，这些分别编译的编译单元将被链接器（linker）合并成一个完整的可执行程序或库</strong></p> 
</blockquote> 
<p>在分离编译的环境中，通常会有：</p> 
<ul><li><strong>头文件</strong>: <code>.h</code> 或 <code>.hpp</code> 文件，包含类的声明、函数原型、模板、宏定义、全局变量的声明以及内联函数等。</li><li><strong>源文件</strong>: <code>.cpp</code> 或 <code>.cc</code> 文件，包含定义在头文件中声明过的类的成员函数、全局变量的定义等。它并不包含那些在编译时必须要知道全部信息的实体，如模板的完整定义</li></ul> 
<p>举个具体的例子：</p> 
<pre><code class="prism language-cpp"><span class="token comment">// myclass.h - 头文件</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">MYCLASS_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MYCLASS_H</span></span>

<span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// MYCLASS_H</span></span>

<span class="token comment">// myclass.cpp - 源文件</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"myclass.h"</span></span>

<span class="token keyword">void</span> <span class="token class-name">MyClass</span><span class="token double-colon punctuation">::</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 实现细节</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>假设还有一个 main.cpp 文件：</p> 
<pre><code class="prism language-cpp"><span class="token comment">// main.cpp - 源文件</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"myclass.h"</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    MyClass myObj<span class="token punctuation">;</span>
    myObj<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个分离编译的例子中，当修改 <code>MyClass</code> 的实现（myclass.cpp）时，<strong>只需要重新编译 myclass.cpp，而不需要重新编译 main.cpp。这些独立的编译单元最后将被链接成一个单个的可执行文件</strong></p> 
<h3><a id="_426"></a><code>模版分离编译</code></h3> 
<p>假如有以下场景，模板的声明与定义分离开，在头文件中进行声明，源文件中完成定义：</p> 
<ol><li>在头文件 <code>a.h</code> 中声明了一个函数模板 <code>Add</code>：</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
T <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> left<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ol start="2"><li>接着在 <code>a.cpp</code> 文件中给出了这个模板的定义：</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
T <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> left<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> left <span class="token operator">+</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="3"><li>然后在 <code>main.cpp</code> 中，包含了头文件 <code>a.h</code> 并调用函数模板 <code>Add</code>：</li></ol> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"a.h"</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font color="red" size="5">存在问题：</font></p> 
<p><mark>在 C++ 中，编译器需要在编译时知道模板函数的完整定义，因为它必须用具体的类型对模板进行实例化</mark>。所以，当在 <code>main.cpp</code> 中调用 <code>Add(1, 2)</code> 和 <code>Add(1.0, 2.0)</code> 时，编译器需要看到 <code>Add</code> 函数模板的完整定义，以便能够分别为类型 <code>int</code> 和 <code>double</code> 实例化它</p> 
<p><strong>但是由于模板定义在 <code>a.cpp</code> 中，而且通常情况下源文件是单独编译的，编译 <code>main.cpp</code> 时，编译器看不到 <code>Add</code> 的定义，这会导致链接错误</strong></p> 
<p><font color="red" size="5">解决方案：</font></p> 
<p>为了解决这个问题（即确保编译器能在必要的时候看到完整的模板定义），常见的做法是将模板的声明和定义都放到头文件中，就像这样：</p> 
<pre><code class="prism language-cpp"><span class="token comment">// a.h</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
T <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> left<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> left <span class="token operator">+</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这就意味着当你在 <code>main.cpp</code> 中包含 <code>a.h</code> 时，编译器能够看到 <code>Add</code> 的完整定义，从而能够实例化任何需要的模板。</p> 
<p>如果你有特定的原因要将模板定义与声明分离（例如减少头文件的大小，或者模板的定义非常复杂），另一种解决方法是<strong>显式实例化</strong>。这是告诉编译器在编译 <code>a.cpp</code> 文件时创建特定类型的实例。显式实例化看起来像这样：</p> 
<pre><code class="prism language-cpp"><span class="token comment">// a.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"a.h"</span></span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
T <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> left<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> left <span class="token operator">+</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 显式实例化</span>
<span class="token keyword">template</span> <span class="token keyword">int</span> <span class="token generic-function"><span class="token function">Add</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> left<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token keyword">double</span> <span class="token generic-function"><span class="token function">Add</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">double</span><span class="token operator">&amp;</span> left<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">double</span><span class="token operator">&amp;</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p><strong>但请注意，显式实例化依旧要求所有使用特定实例化的源文件需要被链接到包含这些实例化的目标文件。此外，这种显式实例化方式只适用于你能预先知道所需类型的情况，这在泛型编程中并不常见。因此，最通用且常用的方法是将模板的定义放在头文件中</strong></p> 
</blockquote> 
<p><mark>前面我们知道，单个函数，进行定义分离没有错误，为什么类模版不行呢？</mark></p> 
<p>单个函数（非模板函数）和类模板在有很大的不同，特别是在声明和定义分离。</p> 
<ol><li><strong>非模板函数的声明和定义分离</strong></li></ol> 
<blockquote> 
 <p><strong>对于非模板函数，你可以在头文件中声明它们，并在一个单独的源文件中定义它们。编译器在处理非模板函数的声明时，无需知道函数的实现细节，它只需要知道函数的签名（返回类型、函数名和参数列表）。当编译器编译调用该函数的源文件时，它只检查函数的声明（通常在一个头文件中）；实际的函数定义可以在程序的其他部分单独编译</strong></p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token comment">// func.h</span>
<span class="token keyword">void</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 声明</span>

<span class="token comment">// func.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"func.h"</span></span>
<span class="token keyword">void</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">/* 定义 */</span> <span class="token punctuation">}</span> <span class="token comment">// 定义</span>
</code></pre> 
<p>在链接阶段，链接器将解析这些调用，找到函数定义，并完成它们之间的连接。</p> 
<ol start="2"><li><strong>类模板的声明和定义</strong></li></ol> 
<p><strong>类模板涉及到模板的实例化。模板本质上是编译时的一种生成代码的指令集，它们告诉编译器如何创建类型或函数的特定版本</strong></p> 
<p>当你在代码中使用类模板时，比如创建一个模板类的对象或调用一个模板函数，<mark>编译器必须能看到模板的整个定义，以便能够实例化模板</mark>。<strong>实例化过程中，编译器使用具体的类型替换模板参数。</strong></p> 
<blockquote> 
 <p><strong>对于非模板函数，声明和定义可以分离，因为编译器知道函数的大小和调用约定，所以它可以在没有函数体的情况下编译调用该函数的代码。但是对于类模板，编译器需要在编译时创建模板实例，所以它需要能够看到完整的定义</strong></p> 
</blockquote> 
<p>本节内容到此结束！感谢大家阅读！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/58fe9b298d08cf7a7d06b9a34b394a9b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【版本控制】mac平台SVN客户端: macSvn 下载与使用指南</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5d51b5690c128f4748a1f0d774a38413/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构-之八大排序(下)，冒泡排序，快速排序，挖坑法，归并排序】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>