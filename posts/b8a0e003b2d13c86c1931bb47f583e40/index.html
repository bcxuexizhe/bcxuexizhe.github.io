<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【MySQL】——并发控制 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/b8a0e003b2d13c86c1931bb47f583e40/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【MySQL】——并发控制">
  <meta property="og:description" content="💻博主现有专栏：
C51单片机（STC89C516），c语言，c&#43;&#43;，离散数学，算法设计与分析，数据结构，Python，Java基础，MySQL，linux，基于HTML5的网页设计及应用，Rust（官方文档重点总结），jQuery，前端vue.js，Javaweb开发，Python机器学习等
🥏主页链接：
Y小夜-CSDN博客
目录
🎯并发控制概述
🎃丢失修改
🎃不可重复读
🎃读“脏”数据
🎯 封锁
🎃什么是封锁
🎃基本封锁类型
🎃锁的相容矩阵
🎯封锁协议
🎃一级封锁协议
🎃二级封锁协议
🎃三级封锁协议
🎯并发调度的可串行性
🎃 可串行化调度
🎃冲突可串行化调度
🎯并发控制
🎯并发控制概述 事务是并发控制的基本单位
并发控制机制的任务
对并发操作进行正确调度保证事务的隔离性保证数据库的一致性 并发操作带来的数据不一致性
1.丢失修改（Lost Update）2.不可重复读（Non-repeatable Read）3.读“脏”数据（Dirty Read） 记号
R(x):读数据xW(x):写数据x 数据不一致性：由于并发操作破坏了事务的隔离性
并发控制就是要用正确的方式调度并发操作，使一个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性
对数据库的应用有时允许某些不一致性，例如有些统计工作涉及数据量很大，读到一些“脏”数据对统计精度没什么影响，可以降低对一致性的要求以减少系统开销
并发控制的主要技术
封锁(Locking)时间戳(Timestamp)乐观控制法多版本并发控制(MVCC) 🎃丢失修改 两个事务T1和T2读入同一数据并修改，T2的提交结果破坏了T1提交的结果，导致T1的修改被丢失。
🎃不可重复读 不可重复读是指事务T1读取数据后，事务T2 执行更新操作，使T1无法再现前一次读取结果。
不可重复读包括三种情况：
（1）事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读该数据时，得到与前一次不同的值
（2）事务T1按一定条件从数据库中读取了某些数据记录后，事务T2删除了其中部分记录，当T1再次按相同条件读取数据时，发现某些记录神秘地消失了。
（3）事务T1按一定条件从数据库中读取某些数据记录后，事务T2插入了一些记录，当T1再次按相同条件读取数据时，发现多了一些记录。 后两种不可重复读有时也称为幻影现象（Phantom Row）
🎃读“脏”数据 读“脏”数据是指：
事务T1修改某一数据，并将其写回磁盘事务T2读取同一数据后，T1由于某种原因被撤销这时T1已修改过的数据恢复原值，T2读到的数据就与数据库中的数据不一致T2读到的数据就为“脏”数据，即不正确的数据 🎯 封锁 🎃什么是封锁 封锁就是事务T在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁
加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象。
封锁是实现并发控制的一个非常重要的技术
🎃基本封锁类型 一个事务对某个数据对象加锁后究竟拥有什么样的控制由封锁的类型决定。
基本封锁类型
排它锁（Exclusive Locks，简记为X锁）共享锁（Share Locks，简记为S锁） 排它锁又称为写锁
若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁保证其他事务在T释放A上的锁之前不能再读取和修改A 共享锁又称为读锁
若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁保证其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改 🎃锁的相容矩阵 Y=Yes，相容的请求 N=No，不相容的请求">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-23T09:37:19+08:00">
    <meta property="article:modified_time" content="2024-05-23T09:37:19+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【MySQL】——并发控制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>💻博主现有专栏：</strong></p> 
 <p><strong>                C51单片机（STC89C516），c语言，c++，离散数学，算法设计与分析，数据结构，Python，Java基础，MySQL，linux，基于HTML5的网页设计及应用，Rust（官方文档重点总结），jQuery，前端vue.js，Javaweb开发，Python机器学习等<br> 🥏主页链接：</strong></p> 
 <p><strong>                </strong><a href="https://blog.csdn.net/shsjssnn?spm=1000.2115.3001.5343" title="Y小夜-CSDN博客">Y小夜-CSDN博客</a></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%F0%9F%8E%AF%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><a href="#%F0%9F%8E%AF%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%A6%82%E8%BF%B0" rel="nofollow">🎯并发控制概述</a></p> 
<p id="%F0%9F%8E%83%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9-toc" style="margin-left:40px;"><a href="#%F0%9F%8E%83%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9" rel="nofollow">🎃丢失修改</a></p> 
<p id="%F0%9F%8E%83%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB-toc" style="margin-left:40px;"><a href="#%F0%9F%8E%83%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB" rel="nofollow">🎃不可重复读</a></p> 
<p id="%F0%9F%8E%83%E8%AF%BB%E2%80%9C%E8%84%8F%E2%80%9D%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#%F0%9F%8E%83%E8%AF%BB%E2%80%9C%E8%84%8F%E2%80%9D%E6%95%B0%E6%8D%AE" rel="nofollow">🎃读“脏”数据</a></p> 
<p id="%F0%9F%8E%AF%C2%A0%E5%B0%81%E9%94%81-toc" style="margin-left:0px;"><a href="#%F0%9F%8E%AF%C2%A0%E5%B0%81%E9%94%81" rel="nofollow">🎯 封锁</a></p> 
<p id="%F0%9F%8E%83%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%81%E9%94%81-toc" style="margin-left:40px;"><a href="#%F0%9F%8E%83%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%81%E9%94%81" rel="nofollow">🎃什么是封锁</a></p> 
<p id="%F0%9F%8E%83%E5%9F%BA%E6%9C%AC%E5%B0%81%E9%94%81%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#%F0%9F%8E%83%E5%9F%BA%E6%9C%AC%E5%B0%81%E9%94%81%E7%B1%BB%E5%9E%8B" rel="nofollow">🎃基本封锁类型</a></p> 
<p id="%F0%9F%8E%83%E9%94%81%E7%9A%84%E7%9B%B8%E5%AE%B9%E7%9F%A9%E9%98%B5-toc" style="margin-left:40px;"><a href="#%F0%9F%8E%83%E9%94%81%E7%9A%84%E7%9B%B8%E5%AE%B9%E7%9F%A9%E9%98%B5" rel="nofollow">🎃锁的相容矩阵</a></p> 
<p id="%F0%9F%8E%AF%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE-toc" style="margin-left:0px;"><a href="#%F0%9F%8E%AF%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE" rel="nofollow">🎯封锁协议</a></p> 
<p id="%F0%9F%8E%83%E4%B8%80%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE-toc" style="margin-left:40px;"><a href="#%F0%9F%8E%83%E4%B8%80%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE" rel="nofollow">🎃一级封锁协议</a></p> 
<p id="%F0%9F%8E%83%E4%BA%8C%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE-toc" style="margin-left:40px;"><a href="#%F0%9F%8E%83%E4%BA%8C%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE" rel="nofollow">🎃二级封锁协议</a></p> 
<p id="%F0%9F%8E%83%E4%B8%89%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE-toc" style="margin-left:40px;"><a href="#%F0%9F%8E%83%E4%B8%89%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE" rel="nofollow">🎃三级封锁协议</a></p> 
<p id="%F0%9F%8E%AF%E5%B9%B6%E5%8F%91%E8%B0%83%E5%BA%A6%E7%9A%84%E5%8F%AF%E4%B8%B2%E8%A1%8C%E6%80%A7-toc" style="margin-left:0px;"><a href="#%F0%9F%8E%AF%E5%B9%B6%E5%8F%91%E8%B0%83%E5%BA%A6%E7%9A%84%E5%8F%AF%E4%B8%B2%E8%A1%8C%E6%80%A7" rel="nofollow">🎯并发调度的可串行性</a></p> 
<p id="%F0%9F%8E%83%C2%A0%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96%E8%B0%83%E5%BA%A6-toc" style="margin-left:40px;"><a href="#%F0%9F%8E%83%C2%A0%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96%E8%B0%83%E5%BA%A6" rel="nofollow">🎃 可串行化调度</a></p> 
<p id="%F0%9F%8E%83%E5%86%B2%E7%AA%81%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96%E8%B0%83%E5%BA%A6-toc" style="margin-left:40px;"><a href="#%F0%9F%8E%83%E5%86%B2%E7%AA%81%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96%E8%B0%83%E5%BA%A6" rel="nofollow">🎃冲突可串行化调度</a></p> 
<p id="%F0%9F%8E%AF%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6-toc" style="margin-left:0px;"><a href="#%F0%9F%8E%AF%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6" rel="nofollow">🎯并发控制</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%F0%9F%8E%AF%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%A6%82%E8%BF%B0">🎯并发控制概述</h2> 
<blockquote> 
 <p>事务是并发控制的基本单位</p> 
 <p>并发控制机制的任务</p> 
 <ul><li>对并发操作进行正确调度</li><li>保证事务的隔离性</li><li>保证数据库的一致性</li></ul> 
 <p>并发操作带来的数据不一致性</p> 
 <ul><li>1.丢失修改（Lost Update）</li><li>2.不可重复读（Non-repeatable Read）</li><li>3.读“脏”数据（Dirty Read）</li></ul> 
 <p>记号</p> 
 <ul><li>R(x):读数据x</li><li>W(x):写数据x</li></ul> 
 <p>数据不一致性：由于并发操作破坏了事务的隔离性</p> 
 <p>        并发控制就是要用正确的方式调度并发操作，使一个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性</p> 
 <p>        对数据库的应用有时允许某些不一致性，例如有些统计工作涉及数据量很大，读到一些“脏”数据对统计精度没什么影响，可以降低对一致性的要求以减少系统开销</p> 
 <p><strong>并发控制的主要技术</strong></p> 
 <ul><li>封锁(Locking)</li><li>时间戳(Timestamp)</li><li>乐观控制法</li><li>多版本并发控制(MVCC)</li></ul> 
 <p></p> 
</blockquote> 
<p></p> 
<h3 id="%F0%9F%8E%83%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9">🎃丢失修改</h3> 
<blockquote> 
 <p>        两个事务T1和T2读入同一数据并修改，T2的提交结果破坏了T1提交的结果，导致T1的修改被丢失。</p> 
 <p><img alt="" height="437" src="https://images2.imgbox.com/0c/64/KAuEl2e6_o.png" width="514"></p> 
</blockquote> 
<h3 id="%F0%9F%8E%83%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB">🎃不可重复读</h3> 
<blockquote> 
 <p>        不可重复读是指事务T1读取数据后，事务T2     执行更新操作，使T1无法再现前一次读取结果。</p> 
 <p>        不可重复读包括三种情况：</p> 
 <p>（1）事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读该数据时，得到与前一次不同的值</p> 
 <p><img alt="" height="467" src="https://images2.imgbox.com/db/fb/UpD9n3K5_o.png" width="389"></p> 
 <p>（2）事务T1按一定条件从数据库中读取了某些数据记录后，事务T2删除了其中部分记录，当T1再次按相同条件读取数据时，发现某些记录神秘地消失了。</p> 
 <p>（3）事务T1按一定条件从数据库中读取某些数据记录后，事务T2插入了一些记录，当T1再次按相同条件读取数据时，发现多了一些记录。      后两种不可重复读有时也称为幻影现象（Phantom Row）</p> 
</blockquote> 
<h3 id="%F0%9F%8E%83%E8%AF%BB%E2%80%9C%E8%84%8F%E2%80%9D%E6%95%B0%E6%8D%AE">🎃读“脏”数据</h3> 
<blockquote> 
 <p> 读“脏”数据是指：</p> 
 <ul><li>事务T1修改某一数据，并将其写回磁盘</li><li>事务T2读取同一数据后，T1由于某种原因被撤销</li><li>这时T1已修改过的数据恢复原值，T2读到的数据就与数据库中的数据不一致</li><li>T2读到的数据就为“脏”数据，即不正确的数据</li></ul> 
 <p><img alt="" height="446" src="https://images2.imgbox.com/8a/2f/0NUtQ5Mz_o.png" width="412"></p> 
</blockquote> 
<h2 id="%F0%9F%8E%AF%C2%A0%E5%B0%81%E9%94%81">🎯 封锁</h2> 
<h3 id="%F0%9F%8E%83%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%81%E9%94%81">🎃什么是封锁</h3> 
<blockquote> 
 <p>        封锁就是事务T在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁</p> 
 <p>        加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象。</p> 
 <p>        封锁是实现并发控制的一个非常重要的技术</p> 
</blockquote> 
<h3 id="%F0%9F%8E%83%E5%9F%BA%E6%9C%AC%E5%B0%81%E9%94%81%E7%B1%BB%E5%9E%8B">🎃基本封锁类型</h3> 
<blockquote> 
 <p>        一个事务对某个数据对象加锁后究竟拥有什么样的控制由封锁的类型决定。</p> 
 <p>基本封锁类型</p> 
 <ul><li>排它锁（Exclusive Locks，简记为X锁）</li><li>共享锁（Share Locks，简记为S锁）</li></ul> 
 <p><strong>排它锁又称为写锁</strong></p> 
 <ul><li>若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁</li><li>保证其他事务在T释放A上的锁之前不能再读取和修改A</li></ul> 
 <p><strong>共享锁又称为读锁</strong></p> 
 <ul><li>若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁</li><li>保证其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改</li></ul> 
</blockquote> 
<h3 id="%F0%9F%8E%83%E9%94%81%E7%9A%84%E7%9B%B8%E5%AE%B9%E7%9F%A9%E9%98%B5">🎃锁的相容矩阵</h3> 
<blockquote> 
 <p><strong>Y=Yes，相容的请求 </strong></p> 
 <p><strong>N=No，不相容的请求</strong></p> 
 <p><img alt="" height="285" src="https://images2.imgbox.com/51/ba/bthIu6Dq_o.png" width="678"></p> 
 <p>在锁的相容矩阵中：</p> 
 <ul><li>最左边一列表示事务T1已经获得的数据对象上的锁的类型，其中横线表示没有加锁。</li><li>最上面一行表示另一事务T2对同一数据对象发出的封锁请求</li><li> T2的封锁请求能否被满足用矩阵中的Y和N表示 
   <ul><li>Y表示事务T2的封锁要求与T1已持有的锁相容，封锁请求可以满足</li><li>N表示T2的封锁请求与T1已持有的锁冲突，T2的请求被拒绝</li></ul></li></ul> 
</blockquote> 
<h2 id="%F0%9F%8E%AF%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE">🎯封锁协议</h2> 
<blockquote> 
 <p>什么是封锁协议</p> 
 <ul><li>在运用X锁和S锁对数据对象加锁时，需要约定一些规则，这些规则为封锁协议（Locking Protocol）。 
   <ul><li>何时申请X锁或S锁</li><li>持锁时间</li><li>何时释放</li></ul></li><li>对封锁方式规定不同的规则，就形成了各种不同的封锁协议，它们分别在不同的程度上为并发操作的正确调度提供一定的保证。</li></ul> 
</blockquote> 
<h3 id="%F0%9F%8E%83%E4%B8%80%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE">🎃一级封锁协议</h3> 
<blockquote> 
 <ul><li>一级封锁协议 
   <ul><li>事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。 
     <ul><li>正常结束（COMMIT）</li><li>非正常结束（ROLLBACK）</li></ul></li></ul></li><li>一级封锁协议可防止丢失修改，并保证事务T是可恢复的。</li><li>在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它不能保证可重复读和不读“脏”数据。</li></ul> 
 <p><img alt="" height="533" src="https://images2.imgbox.com/f5/9d/2agEYqls_o.png" width="433"></p> 
</blockquote> 
<h3 id="%F0%9F%8E%83%E4%BA%8C%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE">🎃二级封锁协议</h3> 
<blockquote> 
 <ul><li>二级封锁协议 
   <ul><li>一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁。</li></ul></li><li>二级封锁协议可以防止丢失修改和读“脏”数据。</li><li>在二级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。</li></ul> 
 <p><img alt="" height="545" src="https://images2.imgbox.com/e3/d6/blz7q6Az_o.png" width="381"></p> 
</blockquote> 
<h3 id="%F0%9F%8E%83%E4%B8%89%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE">🎃三级封锁协议</h3> 
<blockquote> 
 <ul><li>三级封锁协议 
   <ul><li>一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。</li></ul></li><li>三级封锁协议可防止丢失修改、读脏数据和不可重复读。</li></ul> 
 <p><img alt="" height="548" src="https://images2.imgbox.com/cd/33/3HXp0gQp_o.png" width="280"></p> 
</blockquote> 
<h2 id="%F0%9F%8E%AF%E5%B9%B6%E5%8F%91%E8%B0%83%E5%BA%A6%E7%9A%84%E5%8F%AF%E4%B8%B2%E8%A1%8C%E6%80%A7">🎯并发调度的可串行性</h2> 
<blockquote> 
 <ul><li>数据库管理系统对并发事务不同的调度可能会产生不同的结果</li><li>串行调度是正确的</li><li>执行结果等价于串行调度的调度也是正确的，称为可串行化调度</li></ul> 
</blockquote> 
<h3 id="%F0%9F%8E%83%C2%A0%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96%E8%B0%83%E5%BA%A6">🎃 可串行化调度</h3> 
<blockquote> 
 <p>可串行化(Serializable)调度</p> 
 <ul><li>多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同</li></ul> 
 <p>可串行性(Serializability)</p> 
 <ul><li>是并发事务正确调度的准则</li><li>一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度</li></ul> 
</blockquote> 
<h3 id="%F0%9F%8E%83%E5%86%B2%E7%AA%81%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96%E8%B0%83%E5%BA%A6">🎃冲突可串行化调度</h3> 
<blockquote> 
 <p>冲突可串行化</p> 
 <p>一个比可串行化更严格的条件</p> 
 <p>商用系统中的调度器采用</p> 
 <p>冲突操作：是指不同的事务对同一数据的读写操作和写写操作：</p> 
 <p>        Ri(x)与Wj(x)           /*事务Ti读x，Tj写x，其中i≠j*/</p> 
 <p>        Wi(x)与Wj(x)         /*事务Ti写x，Tj写x，其中i≠j*/</p> 
 <p>       其他操作是不冲突操作</p> 
</blockquote> 
<h2 id="%F0%9F%8E%AF%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6">🎯并发控制</h2> 
<blockquote> 
 <p>数据库管理系统普遍采用两段锁协议的方法实现并发调度的可串行性，从而保证调度的正确性</p> 
 <p>两段锁协议</p> 
 <p>     指所有事务必须分两个阶段对数据项加锁和解锁</p> 
 <ul><li>在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁</li><li> 在释放一个封锁之后，事务不再申请和获得任何其他封锁</li></ul> 
 <p>“两段”锁的含义</p> 
 <p>事务分为两个阶段</p> 
 <ul><li> 第一阶段是获得封锁，也称为扩展阶段 
   <ul><li>事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁</li></ul></li><li> 第二阶段是释放封锁，也称为收缩阶段 
   <ul><li>事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁</li></ul></li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>学习推荐：</strong></p> 
 <p>        在当今这个飞速发展的信息时代，人工智能（AI）已经成为了一个不可或缺的技术力量，它正在逐步改变着我们的生活、工作乃至整个社会的运作方式。从智能语音助手到自动驾驶汽车，从精准医疗到智慧城市，人工智能的应用已经渗透到了我们生活的方方面面。因此，学习和掌握人工智能相关的知识和技能，对于任何希望在这个时代保持竞争力的个人来说，都已经变得至关重要。</p> 
 <p>        然而，人工智能是一个涉及数学、计算机科学、数据科学、机器学习、神经网络等多个领域的交叉学科，其学习曲线相对陡峭，对初学者来说可能会有一定的挑战性。幸运的是，随着互联网教育资源的丰富，现在有大量优秀的在线平台和网站提供了丰富的人工智能学习材料，包括视频教程、互动课程、实战项目等，这些资源无疑为学习者打开了一扇通往人工智能世界的大门。</p> 
 <p>        前些天发现了一个巨牛的人工智能学习网站：<a href="https://www.captainbed.cn/ysa" rel="nofollow" title="前言 – 人工智能教程">前言 – 人工智能教程</a>通俗易懂，风趣幽默，忍不住分享一下给大家。</p> 
</blockquote> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/febab887af203ad70220ec1b62b63e5d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【高阶数据结构(六)】B-树详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1ae37fc6f173e90e919780564e6bddfc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何将短信从 iPhone 传输到计算机 - 5 种灵活的方式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>