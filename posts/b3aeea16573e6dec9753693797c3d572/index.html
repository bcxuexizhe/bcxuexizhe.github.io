<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java进阶-SpringCloud设计模式-工厂模式的设计与详解 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/b3aeea16573e6dec9753693797c3d572/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Java进阶-SpringCloud设计模式-工厂模式的设计与详解">
  <meta property="og:description" content="一、设计模式介绍 设计模式是我们开发中常常需要面对的核心概念，它们是解决特定问题的模板或者说是经验的总结。这些模式被设计出来是为了让软件设计更加清晰、代码更加可维护且能应对未来的变化。良好的设计模式不仅能解决重复代码的问题，还能使团队中的每个成员都能理解并遵循统一的开发方式。
使用良好的设计模式可以显著提高软件项目的质量和开发效率。它们帮助开发者抽象复杂度，通过预定义的架构方式简化系统结构的设计和实现。设计模式还提供了一种通用语言，使得开发者在讨论架构问题时能够迅速地达成共识，同时确保代码的健壁性和可扩展性。不论是在创建对象、组织复杂的类结构，还是处理类与类之间的关系时，设计模式都提供了有效的管理和优化策略，使得软件更加稳健，易于管理和扩展。
下面是常见的 23 种设计模式：
本文详细介绍了设计模式中的工厂模式，旨在为软件开发人员提供清晰的理解和应用指南。工厂模式是一种创建型设计模式，用于在不直接指定具体类的情况下创建对象，从而增强代码的灵活性和可扩展性。我们探讨了工厂模式的三种主要形式：简单工厂模式、工厂方法模式和抽象工厂模式。每种模式都通过其结构、代码示例和类图进行了解释，以展示它们在实际开发中如何减少系统的依赖性、提高可维护性和支持易变需求。此外，本文还讨论了每种模式的优势、适用场景以及它们在现实世界软件开发中的实际应用，帮助开发者在面对不同的编程挑战时，能选择合适的模式以优化设计和实现过程。
二、工厂模式概述 工厂模式（Factory Pattern）是一种常用的创建型设计模式，其核心目的是实现创建对象的接口和具体的实例化分离，通过建立一个工厂类，对实现了同一接口的一些类进行实例的创建，以增加系统的灵活性和可维护性。
当需要大量创建一个类的实例的时候，可以使用工厂模式，即从原生的使用类的构造去创建对象的形式迁移到基于工厂提供的方法去创建对象的形式。基于工厂模式的实例创建具有以下好处：
大批量创建对象的时候有统一的入口，易于代码维护；当发生修改时，仅需修改工厂类的创建方法即可；符合现实世界的模式，即由工厂来制作产品（对象）； 本文将通过类图及示例代码详细介绍工厂模式的三种形式：简单工厂模式、工厂方法模式 和 抽象工厂模式。
三、简单工厂模式 简单工厂模式是一种创建型设计模式，它提供了一个创建对象的接口，让其子类决定实例化哪一个类。该模式将对象的创建集中管理，通过专门的工厂类来负责创建所有实例，这样可以避免在客户代码中重复创建对象，降低系统的耦合度，提高模块的可复用性。
1. 简单工厂模式类图 以下类图展示了简单工厂模式的结构：
在这个类图中，Client 不直接与具体产品类（ConcreteProductA 和 ConcreteProductB）交互，而是通过 Factory 类来进行。这样做的优点是客户端从具体产品的创建过程中解耦，提高了程序的扩展性和可维护性。
2. 简单工厂模式示例代码 下面的示例代码进一步阐释了简单工厂模式的应用：
抽象产品：定义了产品的接口，所有的产品都必须实现这个接口。 interface Product { void use(); } 具体产品：实现了产品接口的实体类，定义了具体产品的行为。 class ConcreteProductA implements Product { public void use() { System.out.println(&#34;Using ConcreteProductA&#34;); } } class ConcreteProductB implements Product { public void use() { System.out.println(&#34;Using ConcreteProductB&#34;); } } 简单工厂：一个工厂类，提供了一个创建对象的方法，客户端通过调用这个方法并传入参数来创建不同的产品实例。 class Factory { public static Product createProduct(String type) { if (type.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-13T20:41:22+08:00">
    <meta property="article:modified_time" content="2024-05-13T20:41:22+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java进阶-SpringCloud设计模式-工厂模式的设计与详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>一、设计模式介绍</h3> 
<p>设计模式是我们开发中常常需要面对的核心概念，它们是解决特定问题的模板或者说是经验的总结。这些模式被设计出来是为了让软件设计更加清晰、代码更加可维护且能应对未来的变化。良好的设计模式不仅能解决重复代码的问题，还能使团队中的每个成员都能理解并遵循统一的开发方式。</p> 
<p>使用良好的设计模式可以显著提高软件项目的质量和开发效率。它们帮助开发者抽象复杂度，通过预定义的架构方式简化系统结构的设计和实现。设计模式还提供了一种通用语言，使得开发者在讨论架构问题时能够迅速地达成共识，同时确保代码的健壁性和可扩展性。不论是在创建对象、组织复杂的类结构，还是处理类与类之间的关系时，设计模式都提供了有效的管理和优化策略，使得软件更加稳健，易于管理和扩展。</p> 
<p>下面是常见的 23 种设计模式：</p> 
<p><img src="https://images2.imgbox.com/3e/96/62YQkTnH_o.png" alt="在这里插入图片描述"></p> 
<p>本文详细介绍了设计模式中的工厂模式，旨在为软件开发人员提供清晰的理解和应用指南。工厂模式是一种创建型设计模式，用于在不直接指定具体类的情况下创建对象，从而增强代码的灵活性和可扩展性。我们探讨了工厂模式的三种主要形式：简单工厂模式、工厂方法模式和抽象工厂模式。每种模式都通过其结构、代码示例和类图进行了解释，以展示它们在实际开发中如何减少系统的依赖性、提高可维护性和支持易变需求。此外，本文还讨论了每种模式的优势、适用场景以及它们在现实世界软件开发中的实际应用，帮助开发者在面对不同的编程挑战时，能选择合适的模式以优化设计和实现过程。</p> 
<hr> 
<h3><a id="_13"></a>二、工厂模式概述</h3> 
<p>工厂模式（Factory Pattern）是一种常用的创建型设计模式，其核心目的是实现创建对象的接口和具体的实例化分离，通过建立一个工厂类，对实现了同一接口的一些类进行实例的创建，以增加系统的灵活性和可维护性。</p> 
<p>当需要大量创建一个类的实例的时候，可以使用工厂模式，即从原生的使用类的构造去创建对象的形式迁移到基于工厂提供的方法去创建对象的形式。基于工厂模式的实例创建具有以下好处：</p> 
<ul><li>大批量创建对象的时候有统一的入口，易于代码维护；</li><li>当发生修改时，仅需修改工厂类的创建方法即可；</li><li>符合现实世界的模式，即由工厂来制作产品（对象）；</li></ul> 
<p>本文将通过类图及示例代码详细介绍工厂模式的三种形式：<em><strong>简单工厂模式</strong></em>、<em><strong>工厂方法模式</strong></em> 和 <em><strong>抽象工厂模式</strong></em>。</p> 
<p><img src="https://images2.imgbox.com/78/70/sMS8c3Zf_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="_29"></a>三、简单工厂模式</h3> 
<p>简单工厂模式是一种创建型设计模式，它提供了一个创建对象的接口，让其子类决定实例化哪一个类。该模式将对象的创建集中管理，通过专门的工厂类来负责创建所有实例，这样可以避免在客户代码中重复创建对象，降低系统的耦合度，提高模块的可复用性。</p> 
<h4><a id="1__32"></a>1. 简单工厂模式类图</h4> 
<p>以下类图展示了简单工厂模式的结构：</p> 
<p><img src="https://images2.imgbox.com/9e/d0/cxmUhXXt_o.png" alt="在这里插入图片描述"></p> 
<p>在这个类图中，<code>Client</code> 不直接与具体产品类（<code>ConcreteProductA</code> 和 <code>ConcreteProductB</code>）交互，而是通过 <code>Factory</code> 类来进行。这样做的优点是客户端从具体产品的创建过程中解耦，提高了程序的扩展性和可维护性。</p> 
<hr> 
<h4><a id="2__41"></a>2. 简单工厂模式示例代码</h4> 
<p>下面的示例代码进一步阐释了简单工厂模式的应用：</p> 
<ul><li><strong>抽象产品</strong>：定义了产品的接口，所有的产品都必须实现这个接口。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">interface</span> <span class="token class-name">Product</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>具体产品</strong>：实现了产品接口的实体类，定义了具体产品的行为。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">ConcreteProductA</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Using ConcreteProductA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">ConcreteProductB</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Using ConcreteProductB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>简单工厂</strong>：一个工厂类，提供了一个创建对象的方法，客户端通过调用这个方法并传入参数来创建不同的产品实例。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Factory</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Product</span> <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token class-name">String</span> type<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>调用简单工厂示例</strong>：客户端使用 <code>Factory</code> 类创建具体的产品实例。这种方式的主要优点是工厂类包含必要的逻辑判断，可以决定在运行时创建哪个产品的实例。由于使用了工厂类，客户端可以完全从具体产品的实现中解耦，只需要关心产品的接口。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Product</span> product <span class="token operator">=</span> <span class="token class-name">Factory</span><span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        product<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通过这种方式，简单工厂模式使得新增产品类时，只需要扩展工厂类而不需要修改现有的客户代码，从而增加了系统的灵活性。</p> 
<p>也就是将"A"换成其他产品，如果产品类不存在，我们需要新增产品类，同时添加createProduct里type为新产品的情况，其实还是有点麻烦的，所有下面的工厂方法就是对此的改进。</p> 
<hr> 
<h3><a id="_100"></a>四、工厂方法模式</h3> 
<p>工厂方法模式是一种创建型设计模式，它提供了一个创建对象的方法，但实际的工作将由子类完成，这样的设计模式可以让类的实例化推迟到其子类中进行。这种模式通过定义一个创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类，从而使代码管理更加简单，同时也扩展了系统的可能功能。</p> 
<h4><a id="1__103"></a>1. 工厂方法模式类图</h4> 
<p>下面的类图描述了工厂方法模式的结构：</p> 
<p><img src="https://images2.imgbox.com/0c/52/eSFrPDXx_o.png" alt="在这里插入图片描述"></p> 
<p>在这个模式中，<code>Creator</code> 类定义了一个抽象的 <code>factoryMethod()</code>，该方法需要被子类实现以返回一个 <code>Product</code> 类的实例。这样，客户端代码只依赖于 <code>Product</code> 接口，而具体实例化哪个产品类由具体的 <code>Creator</code> 子类决定，这样提高了系统的灵活性和扩展性。</p> 
<hr> 
<h4><a id="2__112"></a>2. 工厂方法模式示例代码</h4> 
<p>以下示例代码进一步阐释了工厂方法模式的应用：</p> 
<ul><li><strong>产品接口</strong>：定义了所有具体产品需要实现的接口。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">interface</span> <span class="token class-name">Product</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>具体产品</strong>：实现了产品接口的具体类，这些类定义了具体产品的行为。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">ConcreteProductA</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Using ConcreteProductA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">ConcreteProductB</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Using ConcreteProductB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>抽象创建者</strong>：定义了抽象的工厂方法，由具体创建者来实现。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Creator</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">abstract</span> <span class="token class-name">Product</span> <span class="token function">factoryMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>具体创建者</strong>：继承抽象创建者，实现了工厂方法，决定实际生产的产品。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">ConcreteCreatorA</span> <span class="token keyword">extends</span> <span class="token class-name">Creator</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token class-name">Product</span> <span class="token function">factoryMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">ConcreteCreatorB</span> <span class="token keyword">extends</span> <span class="token class-name">Creator</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token class-name">Product</span> <span class="token function">factoryMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>客户端使用</strong>：客户端代码通过调用工厂方法来获取产品对象，而无需知道具体的产品类。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Creator</span> creator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteCreatorA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Product</span> product <span class="token operator">=</span> creator<span class="token punctuation">.</span><span class="token function">factoryMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        product<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通过这种方式，工厂方法模式使得添加新产品类时，只需添加一个具体的创建者而无需修改现有代码，符合开闭原则，提高了代码的可维护性和扩展性。</p> 
<p>与简单工厂加个产品需要改一揽子的代码相比，工厂方法只需要创建一个新的创建者类，客户端调用时ConcreteCreatorA更换为新类名就可以。</p> 
<hr> 
<h3><a id="_184"></a>五、抽象工厂模式</h3> 
<p>抽象工厂模式是创建型设计模式中的一种，它提供了一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。这种模式是工厂方法模式的一种扩展，它用于创建产品家族，而不仅仅是单一产品。通过这种方式，可以增强程序的灵活性和可维护性，同时也支持良好的封装性和扩展性。</p> 
<h4><a id="1__188"></a>1. 抽象工厂模式类图</h4> 
<p>以下类图清晰展示了抽象工厂模式的结构和组件之间的关系：</p> 
<p><img src="https://images2.imgbox.com/eb/32/kpV4yrks_o.png" alt="在这里插入图片描述"></p> 
<p>在这个模式中，<code>AbstractFactory</code> 是一个抽象类，定义了创建一系列产品的接口。每个具体工厂类（如 <code>ConcreteFactory1</code> 和 <code>ConcreteFactory2</code>）实现这个接口，生产具体的产品实例。客户端通过使用工厂接口，而不是直接实例化产品，从而使得具体的产品在客户端保持抽象状态。</p> 
<h4><a id="2__196"></a>2. 抽象工厂模式示例代码</h4> 
<p>以下示例代码详细说明了抽象工厂模式的实现：</p> 
<ul><li><strong>产品接口</strong>：定义了产品的操作。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">interface</span> <span class="token class-name">AbstractProductA</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">AbstractProductB</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>具体产品</strong>：实现产品接口的具体类。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">ConcreteProductA1</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractProductA</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Using ConcreteProductA1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">ConcreteProductA2</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractProductA</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Using ConcreteProductA2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">ConcreteProductB1</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractProductB</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Using ConcreteProductB1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">ConcreteProductB2</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractProductB</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Using ConcreteProductB2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>抽象工厂</strong>：定义了创建一系列产品的方法。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">abstract</span> <span class="token class-name">AbstractProductA</span> <span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">abstract</span> <span class="token class-name">AbstractProductB</span> <span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>具体工厂</strong>：实现抽象工厂，定义了生产具体产品的方式。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">ConcreteFactory1</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token class-name">AbstractProductA</span> <span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProductA1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token class-name">AbstractProductB</span> <span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProductB1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">ConcreteFactory2</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token class-name">AbstractProductA</span> <span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProductA2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token class-name">AbstractProductB</span> <span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>


        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProductB2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>客户端使用</strong>：客户端通过抽象工厂接口创建并使用产品。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">AbstractFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteFactory1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">AbstractProductA</span> productA <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">AbstractProductB</span> productB <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        productA<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        productB<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通过这种方式，抽象工厂模式允许系统在不具体指定产品的情况下创建一系列相关或依赖的对象，支持配置多个工厂，每个工厂创建不同的产品实例，从而增强系统的灵活性和扩展性。</p> 
<p>这也是工厂方法模式的升级，虽然在开闭原则上做出了让步，但是为更强的灵活和扩展创造了条件。</p> 
<hr> 
<h3><a id="_299"></a>六、三种工厂模式异同</h3> 
<p>首先，我们来看三种工厂模式的定义：</p> 
<ul><li><strong>简单工厂模式</strong>：最简单的工厂模式，适合产品种类较少且不经常变化的情况。工厂类集中处理所有产品的创建逻辑，这简化了代码但降低了系统的扩展性。</li><li><strong>工厂方法模式</strong>：允许多个创建者子类来实现具体的产品创建。这种分散的创建过程提高了系统的灵活性，并且增强了代码的可扩展性。</li><li><strong>抽象工厂模式</strong>：提供一个创建一系列相关或互依赖对象的接口，而无需指定它们具体的类。适用于处理多个系列产品的情况，每个具体工厂都能生产一个完整的产品家族。</li></ul> 
<p><img src="https://images2.imgbox.com/b3/79/R5msduKD_o.png" alt="在这里插入图片描述"></p> 
<p>接着，我们用一张表来总结三种工厂模式的特性差异：</p> 
<table><thead><tr><th>特点/模式</th><th>简单工厂模式</th><th>工厂方法模式</th><th>抽象工厂模式</th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>提供一个创建对象的接口，由接口决定创建哪一种产品类的实例。</td><td>定义一个用于创建对象的接口，但由子类决定要实例化的类是哪一个。</td><td>提供一个接口，用于创建相关的对象家族，而不需要明确指定具体类。</td></tr><tr><td><strong>对象创建的责任</strong></td><td>集中于一个工厂类，通过接收特定参数决定创建对象的类型。</td><td>分散到多个子类中，每个子类封装了一个产品的创建过程。</td><td>集中于多个工厂类，每个工厂类负责创建一个产品家族。</td></tr><tr><td><strong>实现复杂度</strong></td><td>低</td><td>中</td><td>高</td></tr><tr><td><strong>灵活性</strong></td><td>低，增加新产品需要修改工厂类</td><td>高，每个产品有其对应的具体工厂类</td><td>非常高，支持创建产品家族且易于添加新的产品组合</td></tr><tr><td><strong>产品扩展性</strong></td><td>较差，扩展新产品时可能需要修改工厂逻辑</td><td>好，扩展新产品时仅需添加相应的具体工厂类</td><td>优，允许通过添加具体工厂和产品类的方式来扩展产品家族</td></tr><tr><td><strong>应用场景</strong></td><td>适用于产品类型数量不多且变动不频繁的情况</td><td>适用于一个类族有多个变体，但仅需使用其一的情况</td><td>适用于需要创建多系列产品或产品族，且产品族需要一起使用的情况</td></tr></tbody></table> 
<p>通过上述表格，我们可以清晰地看到每种工厂模式的特点及其适用的场景。在不同的开发需求下，我们需要选择最合适的模式。</p> 
<hr> 
<h3><a id="_323"></a>七、工厂模式的优势与应用场景</h3> 
<h4><a id="1__324"></a>1. 工厂模式的优势</h4> 
<table><thead><tr><th>优势</th><th>说明</th></tr></thead><tbody><tr><td>封装性</td><td>用户仅需知道产品对应的工厂名，无需关心产品的具体创建细节，从而降低了系统的复杂度。</td></tr><tr><td>扩展性</td><td>新增产品时，只需扩展一个工厂类，而不需修改现有代码，符合开闭原则，易于系统扩展和维护。</td></tr><tr><td>解耦</td><td>分离了产品的实例化过程，使用抽象层促使产品的实现和使用分离，提高了系统的灵活性和可维护性。</td></tr><tr><td>代码可维护性</td><td>由于工厂类和产品类的职责清晰，系统的不同部分可以独立变化而互不影响，从而提高代码的可维护性。</td></tr></tbody></table> 
<h4><a id="2__332"></a>2. 工厂模式的应用场景</h4> 
<ul><li>当系统中的产品有多于一个的产品族，而系统只消费其中某一产品族时。</li><li>当属于同一个产品族的一组产品被设计用于一起使用时，可以使用抽象工厂模式。</li><li>当系统需要被配置成一个具有多个不同行为的产品组成时，可以使用工厂模式确保其灵活性和可扩展性。</li></ul> 
<hr> 
<h3><a id="_339"></a>八、工厂模式总结</h3> 
<p>工厂模式是设计模式中非常关键的一类，主要用于解决对象创建过程中的复杂性，并帮助将对象的实例化过程与使用者分离，从而增加系统的整体封装性和灵活性。通过定义一个用于创建对象的接口，允许子类决定实例化哪一个类，工厂模式使一个类的实例化延迟到其子类。这种模式不仅帮助管理和维护大型软件系统中的对象创建问题，也使系统更加模块化，易于理解和扩展。总的来说，工厂模式在需要生成复杂对象时，提供了极大的便利和高效的管理与维护策略。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d3d17756040a24906017310e1077cd47/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">DS高阶：B树系列</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b072da5962d0dd6154a42aa04aa483b6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2024年大数据最全腾讯T4专家精心整理：大数据&#43;机器学习&#43;数据挖掘&#43;算法大集结(1)，2024年最新大数据开发开发框架</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>