<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【MySQL精炼宝库】数据库的约束 | 表的设计 | 聚合查询 | 联合查询 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/a10a1140ea75f226d03bbb00e47fd7c5/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【MySQL精炼宝库】数据库的约束 | 表的设计 | 聚合查询 | 联合查询">
  <meta property="og:description" content="目录
一、数据库约束
1.1 约束类型：
1.2 案例演示：
二、表的设计
2.1 一对一:
2.2 一对多:
2.3 多对多:
2.4 内容小结：
三、新增
四、查询
4.1 聚合查询：
4.1.1 聚合函数：
4.1.2 GROUP BY子句：
4.1.3 HAVING：
4.2 联合查询：
4.2.1 内连接：
4.2.2 外连接：
4.2.3 自连接： 4.2.4 子查询：
4.2.5 合并查询：
一、数据库约束 1.1 约束类型： • NOT NULL：指示某列不能存储 NULL 值。
• UNIQUE：保证某列的每行必须有唯一的值。
• DEFAULT：规定没有给列赋值时的默认值。
• PRIMARY KEY：NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标 识，有助于更容易更快速地找到表中的一个特定的记录。
• FOREIGN KEY：保证一个表中的数据匹配另一个表中的值的参照完整性。
• CHECK（了解）：保证列中的值符合指定的条件。对于MySQL数据库，对CHECK子句进行分析，但是忽略 CHECK子句。
1.2 案例演示： • NULL约束：
创建表时，可以指定某列不为空，对应SQL脚本如下：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-28T12:37:42+08:00">
    <meta property="article:modified_time" content="2024-04-28T12:37:42+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【MySQL精炼宝库】数据库的约束 | 表的设计 | 聚合查询 | 联合查询</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BA%A6%E6%9D%9F-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BA%A6%E6%9D%9F" rel="nofollow">一、数据库约束</a></p> 
<p id="1.1%20%E7%BA%A6%E6%9D%9F%E7%B1%BB%E5%9E%8B%EF%BC%9A-toc" style="margin-left:40px;"><a href="#1.1%20%E7%BA%A6%E6%9D%9F%E7%B1%BB%E5%9E%8B%EF%BC%9A" rel="nofollow">1.1 约束类型：</a></p> 
<p id="1.2%20%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA%EF%BC%9A-toc" style="margin-left:40px;"><a href="#1.2%20%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA%EF%BC%9A" rel="nofollow">1.2 案例演示：</a></p> 
<p id="%E4%BA%8C%E3%80%81%E8%A1%A8%E7%9A%84%E8%AE%BE%E8%AE%A1-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E8%A1%A8%E7%9A%84%E8%AE%BE%E8%AE%A1" rel="nofollow">二、表的设计</a></p> 
<p id="2.1%C2%A0%E4%B8%80%E5%AF%B9%E4%B8%80%3A-toc" style="margin-left:40px;"><a href="#2.1%C2%A0%E4%B8%80%E5%AF%B9%E4%B8%80%3A" rel="nofollow">2.1 一对一:</a></p> 
<p id="2.2%C2%A0%E4%B8%80%E5%AF%B9%E5%A4%9A%3A-toc" style="margin-left:40px;"><a href="#2.2%C2%A0%E4%B8%80%E5%AF%B9%E5%A4%9A%3A" rel="nofollow">2.2 一对多:</a></p> 
<p id="2.3%C2%A0%E5%A4%9A%E5%AF%B9%E5%A4%9A%3A-toc" style="margin-left:40px;"><a href="#2.3%C2%A0%E5%A4%9A%E5%AF%B9%E5%A4%9A%3A" rel="nofollow">2.3 多对多:</a></p> 
<p id="%C2%A02.4%C2%A0%E5%86%85%E5%AE%B9%E5%B0%8F%E7%BB%93%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A02.4%C2%A0%E5%86%85%E5%AE%B9%E5%B0%8F%E7%BB%93%EF%BC%9A" rel="nofollow">2.4 内容小结：</a></p> 
<p id="%E4%B8%89%E3%80%81%E6%96%B0%E5%A2%9E-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E6%96%B0%E5%A2%9E" rel="nofollow">三、新增</a></p> 
<p id="%E5%9B%9B%E3%80%81%E6%9F%A5%E8%AF%A2-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E6%9F%A5%E8%AF%A2" rel="nofollow">四、查询</a></p> 
<p id="4.1%20%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2%C2%A0-toc" style="margin-left:40px;"><a href="#4.1%20%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2%C2%A0" rel="nofollow">4.1 聚合查询：</a></p> 
<p id="4.1.1%20%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#4.1.1%20%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0" rel="nofollow">4.1.1 聚合函数：</a></p> 
<p id="4.1.2%20GROUP%20BY%E5%AD%90%E5%8F%A5-toc" style="margin-left:80px;"><a href="#4.1.2%20GROUP%20BY%E5%AD%90%E5%8F%A5" rel="nofollow">4.1.2 GROUP BY子句：</a></p> 
<p id="4.1.3%20HAVING-toc" style="margin-left:80px;"><a href="#4.1.3%20HAVING" rel="nofollow">4.1.3 HAVING：</a></p> 
<p id="4.2%20%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2-toc" style="margin-left:40px;"><a href="#4.2%20%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2" rel="nofollow">4.2 联合查询：</a></p> 
<p id="4.2.1%20%E5%86%85%E8%BF%9E%E6%8E%A5-toc" style="margin-left:80px;"><a href="#4.2.1%20%E5%86%85%E8%BF%9E%E6%8E%A5" rel="nofollow">4.2.1 内连接：</a></p> 
<p id="4.2.2%20%E5%A4%96%E8%BF%9E%E6%8E%A5%C2%A0-toc" style="margin-left:80px;"><a href="#4.2.2%20%E5%A4%96%E8%BF%9E%E6%8E%A5%C2%A0" rel="nofollow">4.2.2 外连接：</a></p> 
<p id="4.2.3%20%E8%87%AA%E8%BF%9E%E6%8E%A5%C2%A0-toc" style="margin-left:80px;"><a href="#4.2.3%20%E8%87%AA%E8%BF%9E%E6%8E%A5%C2%A0" rel="nofollow">4.2.3 自连接： </a></p> 
<p id="4.2.4%20%E5%AD%90%E6%9F%A5%E8%AF%A2-toc" style="margin-left:80px;"><a href="#4.2.4%20%E5%AD%90%E6%9F%A5%E8%AF%A2" rel="nofollow">4.2.4 子查询：</a></p> 
<p id="4.2.5%20%E5%90%88%E5%B9%B6%E6%9F%A5%E8%AF%A2-toc" style="margin-left:80px;"><a href="#4.2.5%20%E5%90%88%E5%B9%B6%E6%9F%A5%E8%AF%A2" rel="nofollow">4.2.5 合并查询：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BA%A6%E6%9D%9F">一、数据库约束</h2> 
<h3 id="1.1%20%E7%BA%A6%E6%9D%9F%E7%B1%BB%E5%9E%8B%EF%BC%9A">1.1 约束类型：</h3> 
<blockquote> 
 <p>• NOT NULL：指示某列不能存储 NULL 值。</p> 
 <p>• UNIQUE：保证某列的每行必须有唯一的值。</p> 
 <p>• DEFAULT：规定没有给列赋值时的默认值。</p> 
 <p>• PRIMARY KEY：NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标 识，有助于更容易更快速地找到表中的一个特定的记录。</p> 
 <p>• FOREIGN KEY：保证一个表中的数据匹配另一个表中的值的参照完整性。</p> 
 <p>• CHECK（了解）：保证列中的值符合指定的条件。对于MySQL数据库，对CHECK子句进行分析，但是忽略 CHECK子句。</p> 
</blockquote> 
<h3 id="1.2%20%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA%EF%BC%9A">1.2 案例演示：</h3> 
<p>• NULL约束：</p> 
<p>创建表时，可以指定某列不为空，对应SQL脚本如下：</p> 
<pre><code class="language-sql">-- 重新设置学生表结构
DROP TABLE IF EXISTS student;
CREATE TABLE student (
   id INT NOT NULL,
   sn INT,
   name VARCHAR(20),
   qq_mail VARCHAR(20)
);</code></pre> 
<p>案例演示效果如下：</p> 
<p><img alt="" height="144" src="https://images2.imgbox.com/88/e6/JLxNqD31_o.png" width="1200"></p> 
<p>• UNIQUE：唯一约束 ：</p> 
<p>指定sn列为唯一的、不重复的，对应SQL脚本如下：</p> 
<pre><code class="language-sql">-- 重新设置学生表结构
DROP TABLE IF EXISTS student;
CREATE TABLE student (
   id INT NOT NULL,
   sn INT UNIQUE,
   name VARCHAR(20),
   qq_mail VARCHAR(20)
);</code></pre> 
<p>案例演示效果如下：</p> 
<p><img alt="" height="132" src="https://images2.imgbox.com/3a/36/wzEEKKK5_o.png" width="1200"></p> 
<p>• DEFAULT：默认值约束：</p> 
<p>指定插入数据时，name列为空，默认值unkown，对应SQL脚本：</p> 
<pre><code class="language-sql">-- 重新设置学生表结构
DROP TABLE IF EXISTS student;
CREATE TABLE student (
   id INT NOT NULL,
   sn INT UNIQUE,
   name VARCHAR(20) DEFAULT 'unkown',
   qq_mail VARCHAR(20)
);
</code></pre> 
<p>案例演示效果如下：</p> 
<p><img alt="" height="465" src="https://images2.imgbox.com/39/d5/k66ECIKa_o.png" width="1200"></p> 
<p>• PRIMARY KEY：主键约束：</p> 
<p>指定id列为主键，对应SQL脚本如下：</p> 
<pre><code class="language-sql">-- 重新设置学生表结构
DROP TABLE IF EXISTS student;
CREATE TABLE student (
   id INT NOT NULL PRIMARY KEY,
   sn INT UNIQUE,
   name VARCHAR(20) DEFAULT 'unkown',
   qq_mail VARCHAR(20)
);
</code></pre> 
<p>对于整数类型的主键，常配搭自增长auto_increment来使用。插入数据对应字段不给值时，使用最大值+1。</p> 
<p>SQL脚本：</p> 
<pre><code class="language-sql">-- 主键是 NOT NULL 和 UNIQUE 的结合，可以不用 NOT NULL
id INT PRIMARY KEY auto_increment,
</code></pre> 
<p>由于不加上 auto_increment 的主键和前面的哪几种约束报错差不多这里就不再演示，这里只演示加上 auto increment 的情况。</p> 
<p>案例演示效果如下：</p> 
<p><img alt="" height="578" src="https://images2.imgbox.com/e5/d4/ITDP4cFF_o.png" width="1200"></p> 
<p>• FOREIGN KEY：外键约束：</p> 
<p><strong>外键用于关联其他表的主键或唯一键</strong>，对应SQL脚本语法：</p> 
<pre><code class="language-sql">foreign key (字段名) references 主表(列) 
</code></pre> 
<p>案例演示：</p> 
<p>为了方便叙述这里关联的表就采用 primary_key里面的案例： </p> 
<p><img alt="" height="615" src="https://images2.imgbox.com/b0/3e/InxJk6M9_o.png" width="1200"></p> 
<p>至于CHECK了解即可这里就就不演示了。</p> 
<h2 id="%E4%BA%8C%E3%80%81%E8%A1%A8%E7%9A%84%E8%AE%BE%E8%AE%A1">二、表的设计</h2> 
<p>数据库中表的设计有三大范式：</p> 
<h3 id="2.1%C2%A0%E4%B8%80%E5%AF%B9%E4%B8%80%3A">2.1 一对一:</h3> 
<p>一句话梳理:一个学生只能有一个账号，一个账号只能属于一个学生。</p> 
<p><img alt="" height="197" src="https://images2.imgbox.com/84/31/olSTu53W_o.png" width="1200"></p> 
<h3 id="2.2%C2%A0%E4%B8%80%E5%AF%B9%E5%A4%9A%3A">2.2 一对多:</h3> 
<p>一句话梳理：一个学生只能属于一个班级，一个班级可以有多个学生。</p> 
<p><img alt="" height="218" src="https://images2.imgbox.com/93/3b/QsyTjacl_o.png" width="1200"></p> 
<h3 id="2.3%C2%A0%E5%A4%9A%E5%AF%B9%E5%A4%9A%3A">2.3 多对多:</h3> 
<p>一句话梳理：一个学生可以选择多个课程，一个课程可以被多个学生选择。</p> 
<p><img alt="" height="542" src="https://images2.imgbox.com/7b/ce/WBYAs1Ae_o.png" width="1200"></p> 
<h3 id="%C2%A02.4%C2%A0%E5%86%85%E5%AE%B9%E5%B0%8F%E7%BB%93%EF%BC%9A">2.4 内容小结：</h3> 
<p>• 一对一的表：随便在一个表中建立一个合适的外键即可把两个表关联起来。</p> 
<p>• 一对多的表：先建立 1 的那个表设个主键，再建立多的表并再多的表中建立外键关联起 1 的表。</p> 
<p>• 多对多的表：这个只能再建立一个新表把两个表联系起来，例如：在学生表和课程表这个多对多的表中我们可以建立一个成绩表把它们关联起来，在成绩表中要设置两个外键分别关联两个表。</p> 
<h2 id="%E4%B8%89%E3%80%81%E6%96%B0%E5%A2%9E">三、新增</h2> 
<p>• SQL脚本语法：</p> 
<pre><code class="language-sql">INSERT INTO table_name [(column [, column ...])] SELECT ...</code></pre> 
<p>案例演示：</p> 
<p>案例：创建一张用户表，设计有name姓名、id编号、sex性别、mobile手机号字段。需要把已有的学生数据复制进来，可以复制的字段为name、id。</p> 
<pre><code class="language-sql">-- 创建用户表
DROP TABLE IF EXISTS test_user;
CREATE TABLE test_user (
   id INT primary key auto_increment,
   name VARCHAR(20) comment '姓名',
   age INT comment '年龄',
   email VARCHAR(20) comment '邮箱',
 sex varchar(1) comment '性别',
 mobile varchar(20) comment '手机号'
);
</code></pre> 
<p>案例演示效果如下： </p> 
<p><img alt="" height="543" src="https://images2.imgbox.com/b9/00/ppFTAmTc_o.png" width="1200"></p> 
<h2 id="%E5%9B%9B%E3%80%81%E6%9F%A5%E8%AF%A2">四、查询</h2> 
<h3 id="4.1%20%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2%C2%A0">4.1 聚合查询：</h3> 
<h4 id="4.1.1%20%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0">4.1.1 聚合函数：</h4> 
<p>常见的统计总数、计算平局值等操作，可以使用聚合函数来实现，常见的聚合函数有：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>函数</td><td>说明</td></tr><tr><td>COUNT([DISTINCT] expr)</td><td>返回查询到的数据的 数量</td></tr><tr><td>SUM([DISTINCT] expr)</td><td>返回查询到的数据的 总和，不是数字没有意义</td></tr><tr><td>AVG([DISTINCT] expr)</td><td>返回查询到的数据的 平均值，不是数字没有意义</td></tr><tr><td>MAX([DISTINCT] expr)</td><td>返回查询到的数据的 最大值，不是数字没有意义</td></tr><tr><td>MIN([DISTINCT] expr)</td><td>返回查询到的数据的 最小值，不是数字没有意义</td></tr></tbody></table> 
<p><span style="color:#fe2c24;">[ ]里面的代表可以省略.</span></p> 
<p>案例演示：</p> 
<p>• COUNT</p> 
<pre><code class="language-sql">-- 统计班级共有多少同学
SELECT COUNT(*) FROM student;
SELECT COUNT(0) FROM student;
-- 统计班级收集的 qq_mail 有多少个，qq_mail 为 NULL 的数据不会计入结果
SELECT COUNT(qq_mail) FROM student;
</code></pre> 
<p>注意：如果count里面的列里面的值全部为NULL的话不计数。</p> 
<p>• SUM</p> 
<pre><code class="language-sql">-- 统计数学成绩总分
SELECT SUM(math) FROM exam_result;
-- 不及格 &lt; 60 的总分，没有结果，返回 NULL
SELECT SUM(math) FROM exam_result WHERE math &lt; 60;</code></pre> 
<p>• AVG</p> 
<pre><code class="language-sql">-- 统计平均总分
SELECT AVG(chinese + math + english) 平均总分 FROM exam_result;
</code></pre> 
<p>• MAX</p> 
<pre><code class="language-sql">-- 返回英语最高分
SELECT MAX(english) FROM exam_result;
</code></pre> 
<p>• MIN</p> 
<pre><code class="language-sql">-- 返回 &gt; 70 分以上的数学最低分
SELECT MIN(math) FROM exam_result WHERE math &gt; 70;
</code></pre> 
<h4 id="4.1.2%20GROUP%20BY%E5%AD%90%E5%8F%A5">4.1.2 GROUP BY子句：</h4> 
<p><strong><span style="color:#ff9900;">• SELECT 中使用 GROUP BY 子句可以对指定列进行分组查询。需要满足：使用 GROUP BY 进行分组查询时，SELECT 指定的字段必须是“分组依据字段”，其他字段若想出现在SELECT 中则必须包含在聚合函数中。</span></strong></p> 
<p>一定要记住上面这句话非常重要。 </p> 
<p>对于SQL脚本：</p> 
<pre><code class="language-sql">select column1, sum(column2), .. from table group by column1,column3;</code></pre> 
<p>案例：</p> 
<p>1. 准备测试表及数据：职员表，有id（主键）、name（姓名）、role（角色）、salary（薪水）。</p> 
<pre><code class="language-sql">create table emp(
 id int primary key auto_increment,
 name varchar(20) not null,
 role varchar(20) not null,
 salary numeric(11,2)
);
insert into emp(name, role, salary) values
('马云','服务员', 1000.20),
('马化腾','游戏陪玩', 2000.99),
('孙悟空','游戏角色', 999.11),
('猪无能','游戏角色', 333.5),
('沙和尚','游戏角色', 700.33),
('隔壁老王','董事长', 12000.66);
</code></pre> 
<p>2. 查询每个角色的最高工资、最低工资和平均工资 。</p> 
<pre><code class="language-sql">select role,max(salary),min(salary),avg(salary) from emp group by role;</code></pre> 
<p>案例效果如下： </p> 
<p><img alt="" height="393" src="https://images2.imgbox.com/c4/f6/NL6kY4sC_o.png" width="1200"></p> 
<p> 如果查询的组不是分组的依据列话且不再聚合函数里面，那么得到的数据没有一点实际意义。</p> 
<h4 id="4.1.3%20HAVING">4.1.3 HAVING：</h4> 
<p><span style="color:#ff9900;">• GROUP BY 子句进行分组以后，需要对分组结果再进行条件过滤时，不能使用 WHERE 语句，而需要用 HAVING。</span></p> 
<p>案例演示：</p> 
<p>显示平均工资低于1500的角色和它的平均工资。</p> 
<p>对应SQL脚本：</p> 
<pre><code class="language-sql">select role,max(salary),min(salary),avg(salary) from emp group by role 
having avg(salary)&lt;1500;</code></pre> 
<p><img alt="" height="363" src="https://images2.imgbox.com/53/63/lmEx5hRy_o.png" width="1200"></p> 
<h3 id="4.2%20%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2">4.2 联合查询：</h3> 
<p>联合查询可以说是本节内容的最重要部分。</p> 
<p>实际开发中往往数据来自不同的表，所以需要多表联合查询。多表查询是对多张表的数据取笛卡尔积：</p> 
<p><img alt="" height="883" src="https://images2.imgbox.com/0f/6c/dmTxCJfU_o.png" width="1200"></p> 
<p>注意：关联查询可以对关联表使用别名。</p> 
<p>• 初始化测试数据： </p> 
<pre><code class="language-sql">insert into classes(name, `desc`) values 
('计算机系2019级1班', '学习了计算机原理、C和Java语言、数据结构和算法'),
('中文系2019级3班','学习了中国传统文学'),
('自动化2019级5班','学习了机械自动化');
insert into student(sn, name, qq_mail, classes_id) values
('09982','黑旋风李逵','xuanfeng@qq.com',1),
('00835','菩提老祖',null,1),
('00391','白素贞',null,1),
('00031','许仙','xuxian@qq.com',1),
('00054','不想毕业',null,1),
('51234','好好说话','say@qq.com',2),
('83223','tellme',null,2),
('09527','老外学中文','foreigner@qq.com',2);
insert into course(name) values
('Java'),('中国传统文化'),('计算机原理'),('语文'),('高阶数学'),('英文');
insert into score(score, student_id, course_id) values
-- 黑旋风李逵
(70.5, 1, 1),(98.5, 1, 3),(33, 1, 5),(98, 1, 6),
-- 菩提老祖
(60, 2, 1),(59.5, 2, 5),
-- 白素贞
(33, 3, 1),(68, 3, 3),(99, 3, 5),
-- 许仙
(67, 4, 1),(23, 4, 3),(56, 4, 5),(72, 4, 6),
-- 不想毕业
(81, 5, 1),(37, 5, 5),
-- 好好说话
(56, 6, 2),(43, 6, 4),(79, 6, 6),
-- tellme
(80, 7, 2),(92, 7, 6);</code></pre> 
<p>为了方便叙述下面给出内连接和外连接在集合角度上的示意图：</p> 
<p><img alt="" height="761" src="https://images2.imgbox.com/c0/81/ei7kC8P7_o.png" width="1200"></p> 
<h4 id="4.2.1%20%E5%86%85%E8%BF%9E%E6%8E%A5">4.2.1 内连接：</h4> 
<p>SQL脚本语法：</p> 
<pre><code class="language-sql">select 字段 from 表1 别名1 [inner] join 表2 别名2 on 连接条件 and 其他条件;
select 字段 from 表1 别名1,表2 别名2 where 连接条件 and 其他条件;
</code></pre> 
<p>案例演示：</p> 
<p>• 查询“许仙”同学的成绩</p> 
<p>两种SQL语句是一样的。</p> 
<pre><code class="language-sql">select sco.score from student stu inner join score sco on stu.id=sco.student_id 
and stu.name='许仙';
-- 或者
select sco.score from student stu, score sco where stu.id=sco.student_id and 
stu.name='许仙';</code></pre> 
<p><img alt="" height="929" src="https://images2.imgbox.com/42/f9/2CZhBjZP_o.png" width="1200"></p> 
<h4 id="4.2.2%20%E5%A4%96%E8%BF%9E%E6%8E%A5%C2%A0">4.2.2 外连接：</h4> 
<p>• 外连接分为左外连接和右外连接。如果联合查询，左侧的表完全显示我们就说是左外连接；右侧的表完 全显示我们就说是右外连接。</p> 
<p>SQL脚本语法：</p> 
<pre><code class="language-sql">-- 左外连接，表1完全显示
select 字段名  from 表名1 left join 表名2 on 连接条件;
-- 右外连接，表2完全显示
select 字段 from 表名1 right join 表名2 on 连接条件;</code></pre> 
<p>案例：查询所有同学的成绩，及同学的个人信息，如果该同学没有成绩，也需要显示。</p> 
<pre><code class="language-sql">-- “老外学中文”同学 没有考试成绩，也显示出来了
select * from student stu left join score sco on stu.id=sco.student_id;
-- 对应的右外连接为：
select * from score sco right join student stu on stu.id=sco.student_id;
</code></pre> 
<p>案例结果如下： </p> 
<p>由于结果有点多故截取了中间的一点无用数据。</p> 
<p><img alt="" height="1008" src="https://images2.imgbox.com/97/d1/lJm4U3XH_o.png" width="1200"></p> 
<h4 id="4.2.3%20%E8%87%AA%E8%BF%9E%E6%8E%A5%C2%A0">4.2.3 自连接： </h4> 
<p><span style="color:#ff9900;">• 自连接是指在同一张表连接自身进行查询。</span></p> 
<p><span style="color:#ff9900;">自连接一般用于特殊场景，可以把行的比较转换成列的比较（MySQL只能进行列的比较）。</span></p> 
<p>案例：</p> 
<p>显示所有“计算机原理”成绩比“Java”成绩高的成绩信息。</p> 
<pre><code class="language-sql">SELECT
 stu.*,
 s1.score Java,
 s2.score 计算机原理 
FROM
 score s1
 JOIN score s2 ON s1.student_id = s2.student_id
 JOIN student stu ON s1.student_id = stu.id
 JOIN course c1 ON s1.course_id = c1.id
 JOIN course c2 ON s2.course_id = c2.id 
 AND s1.score &lt; s2.score 
 AND c1.NAME = 'Java' 
 AND c2.NAME = '计算机原理';
</code></pre> 
<p><img alt="" height="276" src="https://images2.imgbox.com/f0/d3/0e3efVCy_o.png" width="1200"></p> 
<h4 id="4.2.4%20%E5%AD%90%E6%9F%A5%E8%AF%A2">4.2.4 子查询：</h4> 
<p><span style="color:#ff9900;">• 子查询是指嵌入在其他sql语句中的select语句，也叫嵌套查询。</span></p> 
<p>子查询是把多个sql嵌套成了一个sql，这个写法在实际开发中要慎重使用，因为这种写法违背编程中的基本思想原则化繁为简（子查询是化简为繁）。</p> 
<p>• 单行子查询：返回一行记录的子查询</p> 
<p>案例：查询与“不想毕业” 同学的同班同学</p> 
<pre><code class="language-sql">select * from student where classes_id=(select classes_id from student where 
name='不想毕业');
</code></pre> 
<p>• 多行子查询：返回多行记录的子查询</p> 
<p>案例：查询“语文”或“英文”课程的成绩信息</p> 
<pre><code class="language-sql">select * from score where course_id in (select id from course where 
name='语文' or name='英文');
</code></pre> 
<p>可以使用多列包含：</p> 
<p>案例：查询重复的分数</p> 
<pre><code class="language-sql">SELECT
 * 
FROM
 score 
WHERE
 ( score, student_id, course_id ) IN ( SELECT score, student_id, 
course_id FROM score GROUP BY score, student_id, course_id HAVING 
count( 0 ) &gt; 1 );
</code></pre> 
<p>• 在from子句中使用子查询：子查询语句出现在from子句中。这里要用到数据查询的技巧，把一个 子查询当做一个临时表使用。</p> 
<p>1.查询所有比“中文系2019级3班”平均分高的成绩信息：</p> 
<pre><code class="language-sql">-- 获取“中文系2019级3班”的平均分，将其看作临时表
SELECT
 avg( sco.score ) score 
FROM
 score sco
 JOIN student stu ON sco.student_id = stu.id
 JOIN classes cls ON stu.classes_id = cls.id 
WHERE
 cls.NAME = '中文系2019级3班';
</code></pre> 
<p>案例结果如下： </p> 
<p><img alt="" height="539" src="https://images2.imgbox.com/6a/66/EuCQbGMo_o.png" width="1200"></p> 
<p>2.查询成绩表中，比以上临时表平均分高的成绩：</p> 
<pre><code class="language-sql">SELECT
 * 
FROM
 score sco,
 (
 SELECT
 avg( sco.score ) score 
 FROM
 score sco
 JOIN student stu ON sco.student_id = stu.id
 JOIN classes cls ON stu.classes_id = cls.id 
 WHERE
cls.NAME = '中文系2019级3班' 
 ) tmp 
WHERE
 sco.score &gt; tmp.score;</code></pre> 
<p>案例结果如下： </p> 
<p><img alt="" height="527" src="https://images2.imgbox.com/5c/dd/C5sGHJmz_o.png" width="1200"></p> 
<h4 id="4.2.5%20%E5%90%88%E5%B9%B6%E6%9F%A5%E8%AF%A2">4.2.5 合并查询：</h4> 
<p><span style="color:#ff9900;">在实际应用中，为了合并多个select的执行结果，可以使用集合操作符 union，union all。使用UNION 和UNION ALL时，前后查询的结果集中，字段需要一致。</span></p> 
<p>• union</p> 
<p><span style="color:#ff9900;">该操作符用于取得两个结果集的并集。当使用该操作符时，会自动去掉结果集中的重复行。</span></p> 
<p>案例：查询id小于3，或者名字为“英文”的课程：</p> 
<pre><code class="language-sql">select * from course where id&lt;3 
union
select * from course where name='英文';
</code></pre> 
<p><img alt="" height="464" src="https://images2.imgbox.com/38/a1/PUajiWjE_o.png" width="1200"></p> 
<p><span style="color:#fe2c24;">问题：使用where里面的条件语句也可以做到，为什么还要union呢？</span></p> 
<p><span style="color:#fe2c24;">解答：union 允许你从不同的多个表分别查询，只要每个表查询的结果集合列的类型和个数匹配，都能合并。</span></p> 
<p>• union all</p> 
<p><span style="color:#ff9900;">该操作符用于取得两个结果集的并集。当使用该操作符时，不会去掉结果集中的重复行。</span></p> 
<p>案例：查询id小于3，或者名字为“Java”的课程</p> 
<pre><code class="language-sql">-- 可以看到结果集中出现重复数据Java
select * from course where id&lt;3 
union all
select * from course where name='英文';</code></pre> 
<p><img alt="" height="460" src="https://images2.imgbox.com/9f/99/9dvrmPk6_o.png" width="1200"></p> 
<p><strong>结语：</strong></p> 
<p><strong>其实写博客不仅仅是为了教大家，同时这也有利于我巩固知识点，和做一个学习的总结，由于作者水平有限，对文章有任何问题还请指出，非常感谢。如果大家有所收获的话还请不要吝啬你们的点赞收藏和关注，这可以激励我写出更加优秀的文章。</strong></p> 
<p><img alt="" height="400" src="https://images2.imgbox.com/c1/21/IRumDV9M_o.png" width="1080"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3c52441cd46ee1fd930c8f97b65fd1f5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java之多态</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3db053236763afb13b5ca3be00c4552a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C#】.net core 6.0 MVC返回JsonResult显示API接口返回值不可被JSON反序列化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>