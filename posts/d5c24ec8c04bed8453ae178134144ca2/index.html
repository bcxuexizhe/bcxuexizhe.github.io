<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】链表与LinkedList - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/d5c24ec8c04bed8453ae178134144ca2/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【数据结构】链表与LinkedList">
  <meta property="og:description" content="在上一篇文章中我们介绍了ArrayList使用方法，并进行了简单的模拟实现，但通过分析我们发现其不方便进行插入和删除操作，因为要移动数组元素，最坏情况下时间复杂度会达到O(n)效率比较低，因此ArrayList不适合做任意位置插入和删除比较多的场景。因此：java集合中又引入了LinkedList，即链表结构。
一、什么是链表 概念：链表是一种物理存储结构上非连续存储结构，数据元素的逻辑顺序是通过链表中的引用链接次序实现的 。
注意： 链式结构是在逻辑上连续，但在物理上不一定连续。
实际中链表的结构非常多样，以下情况组合起来就有 8 种链表结构： 1. 单向或者双向 2. 带头或者不带头 3. 循环或者非循环 虽然有这么多的链表的结构，但是我们重点掌握两种 : 无头单向非循环链表 ： 结构简单 ，一般不会单独用来存数据。实际中更多是作为 其他数据结构的子结构 ，如 哈希桶、图的邻接表等等。 无头双向链表 ：在 Java 的集合框架库中 LinkedList 底层实现就是无头双向循环链表。 二、MyLinkedList实现 1、IList接口 public interface IList { //头插法 void addFirst(int data); //尾插法 void addLast(int data); //任意位置插入,第一个数据节点为0号下标 void addIndex(int index,int data); //查找是否包含关键字key是否在单链表当中 boolean contains(int key); //删除第一次出现关键字为key的节点 void remove(int key); //删除所有值为key的节点 void removeAllKey(int key); //得到单链表的长度 int size(); void clear(); void display(); } 2、MyLinkList实现 1、基础结构">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-17T21:19:35+08:00">
    <meta property="article:modified_time" content="2024-05-17T21:19:35+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】链表与LinkedList</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#e8e6e3;">        在上一篇文章中我们介绍了ArrayList使用方法，并进行了简单的模拟实现，但通过分析我们发现其</span>不方便进行插入和删除操作，因为要移动数组元素，最坏情况下时间复杂度会达到O(n)<span style="color:#333333;">效率比较低，因此ArrayList</span><span style="color:#333333;">不适合做任意位置插入和删除比较多的场景</span><span style="color:#333333;">。因此：</span><span style="color:#333333;">java集合中又引入了LinkedList，即链表结构。</span></p> 
<h2>一、什么是链表</h2> 
<blockquote> 
 <p>概念：<span style="color:#333333;">链表是一种</span><span style="color:#333333;"><strong>物理存储结构上非连续</strong></span><span style="color:#333333;">存储结构，数据元素的</span><span style="color:#333333;"><strong>逻辑顺序</strong></span><span style="color:#333333;">是通过链表中的</span><span style="color:#333333;"><strong>引用链接</strong></span><span style="color:#333333;">次序实现的 。</span></p> 
</blockquote> 
<p><img alt="" height="111" src="https://images2.imgbox.com/51/2a/5fTE7cvQ_o.png" width="824"></p> 
<blockquote> 
 <p><strong><em><code>注意： 链式结构是在逻辑上连续，但在物理上不一定连续。</code></em></strong></p> 
</blockquote> 
<div> 
 <span style="color:#333333;">实际中链表的结构非常多样，以下情况组合起来就有</span> 
 <span style="color:#333333;">8</span> 
 <span style="color:#333333;">种链表结构： </span> 
</div> 
<div></div> 
<div> 
 <div> 
  <span style="color:#333333;">1. </span> 
  <span style="color:#333333;"><strong>单向或者双向 </strong></span> 
 </div> 
 <div> 
  <img alt="" height="174" src="https://images2.imgbox.com/91/c8/8COSusT6_o.png" width="660"> 
 </div> 
 <div></div> 
</div> 
<div> 
 <span style="color:#333333;">2. </span> 
 <span style="color:#333333;"><strong>带头或者不带头</strong></span> 
</div> 
<p><img alt="" height="205" src="https://images2.imgbox.com/08/b5/yQmvInOc_o.png" width="619"></p> 
<div> 
 <span style="color:#333333;">3. </span> 
 <span style="color:#333333;"><strong>循环或者非循环</strong></span> 
</div> 
<div> 
 <img alt="" height="198" src="https://images2.imgbox.com/be/2d/LfpBDhK0_o.png" width="516"> 
</div> 
<div></div> 
<div> 
 <div> 
  <span style="color:#333333;">虽然有这么多的链表的结构，但是我们重点掌握两种</span> 
  <span style="color:#333333;">:</span> 
 </div> 
 <div></div> 
</div> 
<div> 
 <div> 
  <span style="color:#333333;"><strong>无头单向非循环链表</strong></span> 
  <span style="color:#333333;">：</span> 
  <span style="color:#333333;"><strong>结构简单</strong></span> 
  <span style="color:#333333;">，一般不会单独用来存数据。实际中更多是作为</span> 
  <span style="color:#333333;"><strong>其他数据结构的子结构</strong></span> 
  <span style="color:#333333;">，如 哈希桶、图的邻接表等等。</span> 
 </div> 
 <div></div> 
</div> 
<div> 
 <img alt="" height="131" src="https://images2.imgbox.com/6d/00/OI2rH4QV_o.png" width="460"> 
</div> 
<div></div> 
<div> 
 <div> 
  <span style="color:#333333;"><strong>无头双向链表</strong></span> 
  <span style="color:#333333;">：在</span> 
  <span style="color:#333333;">Java</span> 
  <span style="color:#333333;">的集合框架库中</span> 
  <span style="color:#333333;">LinkedList</span> 
  <span style="color:#333333;">底层实现就是无头双向循环链表。</span> 
 </div> 
</div> 
<div></div> 
<div></div> 
<h2>二、MyLinkedList实现</h2> 
<h3>1、IList接口</h3> 
<pre><code class="language-java">public interface IList {
    //头插法
    void addFirst(int data);
    //尾插法
    void addLast(int data);
    //任意位置插入,第一个数据节点为0号下标
    void addIndex(int index,int data);
    //查找是否包含关键字key是否在单链表当中
    boolean contains(int key);
    //删除第一次出现关键字为key的节点
    void remove(int key);
    //删除所有值为key的节点
    void removeAllKey(int key);
    //得到单链表的长度
    int size();
    void clear();
    void display();
}</code></pre> 
<h3>2、MyLinkList实现</h3> 
<p>1、基础结构</p> 
<pre><code class="language-java">public class MyLinkList implements IList{
    //内部类
    class Node{
        public int val;
        public Node next;//下一个结点
        public Node head;//头结点
        public Node(int val){
            this.val=val;
        }
    }  
}</code></pre> 
<hr> 
<p>2、插入数据</p> 
<p>（1）头插法</p> 
<pre><code class="language-java">public void addFirst(int data) {
        Node node=new Node(data);
        node.next=head;
        head=node;
    }</code></pre> 
<p>（2）尾插法</p> 
<pre><code class="language-java">public void addLast(int data) {
        Node node=new Node(data);
        Node end=head;
        while (end.next!=null){
            end=end.next;
        }
        end.next=node;
    }</code></pre> 
<p>（3）在指定位置插入一个元素</p> 
<pre><code class="language-java">public void addIndex(int index, int data) {
    if(index&lt;0||index&gt;size()){
        System.out.println("位置不合法");
        return;
    }
    if(index==0){
        addFirst(data);
        return;
    }
    if(index==size()){
        addLast(data);
        return;
    }
    Node node=new Node(data);
    Node pre=getNode(index);
    node.next=pre.next;
    pre.next=node;
    }
    public Node getNode(int index){
        Node node=head;
        while (index-1!=0){
            node=node.next;
            index--;
        }
        return node;
    }</code></pre> 
<blockquote> 
 <p>注意：</p> 
 <p>一定要检查插入数据的<strong>合法性</strong>，避免程序运行出现问题</p> 
 <p><strong>数据结构是一门十分严谨的学科，所以我们一定要注意好这些小细节</strong></p> 
</blockquote> 
<hr> 
<p>3、是否包含某一个元素</p> 
<pre><code class="language-java">public boolean contains(int key) {
        Node node=head;
        while (node!=null){
            if(node.val==key){
                return true;
            }
            node=node.next;
        }
        return false;
    }</code></pre> 
<hr> 
<p>4、删除指定数据</p> 
<p>（1）删除第一个为key的元素</p> 
<pre><code class="language-java">public void remove(int key) {
        if(head.val==key){
            head=head.next;
            return;
        }
        int index=getindex(key);
        Node node=head;

        while (index-1!=0){
            node=node.next;
            index--;
        }
        node.next=node.next.next;
    }</code></pre> 
<p>（2）删除所有为key的元素</p> 
<pre><code class="language-java">public void removeAllKey(int key) {
        if (head==null){
            return;
        }
        Node node=head;
        Node cur=head.next;
        while (cur!=null){
            if(cur.val==key){
                node.next=cur.next;
                cur=cur.next;
            }else {
                node=node.next;
                cur=cur.next;
            }
        }
        if(head.val==key){
            head=head.next;
        }
    }</code></pre> 
<hr> 
<p>5、其它操作</p> 
<pre><code class="language-java">    //根据key返回它的前一个坐标    
    public int getindex(int key){
        int count=0;
        Node node=head;
        while (node!=null){
            if(node.val==key){
                return count;
            }
            node=node.next;
            count++;
        }
        return -1;
    }

    //求链表大小
    public int size() {
        Node node=head;
        int count=0;
        while (node!=null){
            count++;
            node=node.next;
        }
        return count;
    }

    //清空链表
    public void clear() {
        Node node=head;
        while (node!=null){
            Node next=node.next;
            node.next=null;
            node=next;
        }
        head=null;
    }

    //打印链表
    public void display() {
        Node node=head;
        while (node!=null){
            System.out.print(node.val+" ");
            node=node.next;
        }

    }</code></pre> 
<hr> 
<p></p> 
<h2>三、LinkedList</h2> 
<h3>1、LinkedList是什么</h3> 
<div> 
 <span style="color:#333333;">        LinkedList的底层是双向链表结构</span> 
 <span style="color:#333333;">(</span> 
 <span style="color:#333333;">链表后面介绍</span> 
 <span style="color:#333333;">)</span> 
 <span style="color:#333333;">，由于链表没有将元素存储在连续的空间中，元素存储在单独的节点中，然后通过引用将节点连接起来了，因此在在任意位置插入或者删除元素时，不需要搬移元素，效率比较高。 </span> 
</div> 
<div> 
 <img alt="" height="396" src="https://images2.imgbox.com/98/72/UC7v7Unz_o.png" width="816"> 
</div> 
<div></div> 
<div></div> 
<p>LinedList源码：</p> 
<p><img alt="" height="410" src="https://images2.imgbox.com/94/1c/lx0HR5hN_o.png" width="804"></p> 
<blockquote> 
 <p>可以看出：</p> 
 <div> 
  <span style="color:#333333;">1. LinkedList</span> 
  <span style="color:#333333;">实现了</span> 
  <span style="color:#333333;">List</span> 
  <span style="color:#333333;">接口 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">2. LinkedList</span> 
  <span style="color:#333333;">的底层使用了双向链表 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">3. LinkedList</span> 
  <span style="color:#333333;">没有实现</span> 
  <span style="color:#333333;">RandomAccess</span> 
  <span style="color:#333333;">接口，因此</span> 
  <span style="color:#333333;">LinkedList</span> 
  <span style="color:#333333;">不支持随机访问</span> 
 </div> 
 <div> 
  <div> 
   <span style="color:#333333;">4. LinkedList</span> 
   <span style="color:#333333;">的任意位置插入和删除元素时效率比较高，时间复杂度为</span> 
   <span style="color:#333333;">O(1) </span> 
  </div> 
  <div> 
   <span style="color:#333333;">5. LinkedList</span> 
   <span style="color:#333333;">比较适合任意位置插入的场景 </span> 
  </div> 
 </div> 
</blockquote> 
<p></p> 
<h3>2、LinkedList的使用</h3> 
<p>（1）构造</p> 
<p><img alt="" height="125" src="https://images2.imgbox.com/95/f5/tIOUe82N_o.png" width="770"></p> 
<pre><code class="language-java">public static void main(String[] args) {
    // 构造一个空的LinkedList
    List&lt;Integer&gt; list1 = new LinkedList&lt;&gt;();
    List&lt;String&gt; list2 = new java.util.ArrayList&lt;&gt;();
    list2.add("JavaSE");
    list2.add("JavaWeb");
    list2.add("JavaEE");
    // 使用ArrayList构造LinkedList
    List&lt;String&gt; list3 = new LinkedList&lt;&gt;(list2);
}</code></pre> 
<div> 
 <span style="color:#333333;"><strong>其他常用方法介绍：</strong></span> 
</div> 
<div></div> 
<p><img alt="" height="538" src="https://images2.imgbox.com/a9/c0/TQkjPWjB_o.png" width="770"></p> 
<p></p> 
<p>（2）遍历</p> 
<pre><code class="language-java">public static void main(String[] args) {
    LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;();
    list.add(1); // add(elem): 表示尾插
    list.add(2);
    list.add(3);
    list.add(4);
    list.add(5);
    list.add(6);
    list.add(7);
    System.out.println(list.size());
    // foreach遍历
    for (int e:list) {
        System.out.print(e + " ");
    }
    System.out.println();
    // 使用迭代器遍历---正向遍历
    ListIterator&lt;Integer&gt; it = list.listIterator();
    while(it.hasNext()){
        System.out.print(it.next()+ " ");
    }
    System.out.println();
    // 使用反向迭代器---反向遍历
    ListIterator&lt;Integer&gt; rit = list.listIterator(list.size());
    while (rit.hasPrevious()){
        System.out.print(rit.previous() +" ");
    }
    System.out.println();
}
</code></pre> 
<h3>3、<span style="color:#333333;"><strong>ArrayList</strong></span><span style="color:#333333;"><strong>和</strong></span><span style="color:#333333;"><strong>LinkedList</strong></span><span style="color:#333333;"><strong>的区别</strong></span></h3> 
<p><img alt="" height="254" src="https://images2.imgbox.com/51/0e/fOc3m0GB_o.png" width="810"></p> 
<p></p> 
<h2>总结</h2> 
<p>        </p> 
<blockquote> 
 <p>链表的优点：</p> 
 <ul><li><span style="color:#333333;">适合频繁进行任意位置插入的场景</span></li></ul> 
 <p>缺点：</p> 
 <ul><li>不支持随机访问，访问随机数据时，最坏情况下时间复杂度会达到O(n)</li></ul> 
</blockquote> 
<p>        我们在实际应用中要对比着使用<span style="color:#333333;">ArrayList</span><span style="color:#333333;">和</span><span style="color:#333333;">LinkedList,根据应用场景选择合适的数据结构，要记住，<strong>没有最好的数据结构，只有最合适的数据结构</strong></span></p> 
<hr> 
<blockquote> 
 <p>那么本篇文章就到此为止了，如果觉得这篇文章对你有帮助的话，可以点一下关注和点赞来支持作者哦。作者还是一个萌新，如果有什么讲的不对的地方欢迎在评论区指出，希望能够和你们一起进步✊</p> 
</blockquote> 
<p><img alt="" height="675" src="https://images2.imgbox.com/fc/6a/EVHQe1Ox_o.png" width="1200"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/310889d727ef3555de7efce22a9ef997/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【SQL国际标准】ISO/IEC 9075:2023 系列SQL的国际标准详情</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/45dda9a3937c208b98b7017fbae24a94/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AI大模型探索之路-训练篇24：ChatGLM3微调实战-多卡方案微调步骤详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>