<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言：函数递归详解（建议收藏） - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/6046937776a44ec3a4c494d11b42e077/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="C语言：函数递归详解（建议收藏）">
  <meta property="og:description" content="文章目录 一.基础概念1.1函数递归的定义1.2函数递归的优缺点1.3函数递归的两个必要条件 二. 入门级函数递归例题2.1函数递归之死循环2.2输入输出1234 三. 函数递归典型例题的实现3.1求n的阶乘3.2strlen函数的模拟实现3.3求n的k次幂3.4字符串逆序3.5斐波那契数（递归实现和非递归实现）3.5.1递归的实现3.5.2非递归的实现3.5.3斐波那契数的非递归的实现优于递归实现的原因 3.6经典问题之《青蛙跳台阶》3.7经典问题之《汉诺塔问题》过程演示 一.基础概念 1.1函数递归的定义 程序调用自身的编程技巧称为递归（ recursion）。
递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接
调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。
1.2函数递归的优缺点 优点：函数递归只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的主要思考方式在于：把大事化小（这种思考方式十分重要）。
缺点：①如果函数递归使用不恰当，会导致栈溢出，因为每一次函数调用都会在栈区上申请内存空间。②每一次函数递归（函数调用）都会在函数栈帧上开辟一块空间，所谓的压栈。这样会大大降低我们代码的执行效率（这会在函数递归例题详解：斐波那系数中解释）。
1.3函数递归的两个必要条件 存在限制条件，当满足这个限制条件的时候，递归便不再继续。每次递归调用之后越来越接近这个限制条件。 二. 入门级函数递归例题 2.1函数递归之死循环 我们了解了函数递归的基础概念后，来看看这段有趣而危险的代码。
#include &lt;stdio.h&gt; int main() { printf(&#34;cc\n&#34;); main(); //重复调用main函数 return 0; } 可想而知，程序最终会崩溃。因为每一次函数调用都会在栈上开辟一块空间，这种死循环的代码会一直开辟空间，直至栈溢出，正如上面的缺点②。
2.2输入输出1234 题目描述:
接受一个整型值（无符号），按照顺序打印它的每一位。
例如：
输入：1234，输出 1234
解题思路：这种输入输出数字的题，我们一定要想到取模和取余的方法,并且要有限制条件，每次函数递归后，都会越来越接近这个值。
所以先函数递推1234%10=4,123%10=3,12%10=2,1%10=1，给定限制条件n&gt;9,直到n=1，打印出最后值（1），最后函数回归打印出1234。
设n为1234
print(1234/10) &#43; 1234%10 (=4)
print(123/10) &#43; 123%10（=3）
print(12/10) &#43; 12%10（=2）
当n最后为1时，不满足我们给定的限制条件n&gt;9时，即打印1%10（=1）
代码实现：
void print(unsigned int n) { if (n &gt; 9) //限定条件 { print(n / 10); //取模 } printf(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-10-28T14:22:20+08:00">
    <meta property="article:modified_time" content="2022-10-28T14:22:20+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言：函数递归详解（建议收藏）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">一.基础概念</a></li><li><ul><li><a href="#11_3" rel="nofollow">1.1函数递归的定义</a></li><li><a href="#12_7" rel="nofollow">1.2函数递归的优缺点</a></li><li><a href="#13_10" rel="nofollow">1.3函数递归的两个必要条件</a></li></ul> 
  </li><li><a href="#__13" rel="nofollow">二. 入门级函数递归例题</a></li><li><ul><li><a href="#21_15" rel="nofollow">2.1函数递归之死循环</a></li><li><a href="#221234_28" rel="nofollow">2.2输入输出1234</a></li></ul> 
  </li><li><a href="#__63" rel="nofollow">三. 函数递归典型例题的实现</a></li><li><ul><li><a href="#31n_65" rel="nofollow">3.1求n的阶乘</a></li><li><a href="#32strlen_99" rel="nofollow">3.2strlen函数的模拟实现</a></li><li><a href="#33nk_133" rel="nofollow">3.3求n的k次幂</a></li><li><a href="#34_170" rel="nofollow">3.4字符串逆序</a></li><li><a href="#35_206" rel="nofollow">3.5斐波那契数（递归实现和非递归实现）</a></li><li><ul><li><a href="#351_207" rel="nofollow">3.5.1递归的实现</a></li><li><a href="#352_242" rel="nofollow">3.5.2非递归的实现</a></li><li><a href="#353_282" rel="nofollow">3.5.3斐波那契数的非递归的实现优于递归实现的原因</a></li></ul> 
   </li><li><a href="#36_288" rel="nofollow">3.6经典问题之《青蛙跳台阶》</a></li><li><a href="#37_323" rel="nofollow">3.7经典问题之《汉诺塔问题》</a></li><li><ul><li><a href="#_370" rel="nofollow">过程演示</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>一.基础概念</h2> 
<hr> 
<h3><a id="11_3"></a>1.1函数递归的定义</h3> 
<p>程序调用自身的编程技巧称为<strong>递归</strong>（ recursion）。<br> 递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接<br> <strong>调用自身</strong>的一种方法，<strong>它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解</strong>。</p> 
<h3><a id="12_7"></a>1.2函数递归的优缺点</h3> 
<p><strong>优点</strong>：函数递归只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的主要思考方式在于：把<mark>大事化小</mark>（这种思考方式十分重要）。<br> <strong>缺点</strong>：①如果函数递归使用不恰当，会导致<strong>栈溢出</strong>，因为每一次函数调用都会在栈区上申请内存空间。②每一次函数递归（函数调用）都会在<strong>函数栈帧</strong>上开辟一块空间，所谓的压栈。这样会大大降低我们代码的<strong>执行效率</strong>（这会在函数递归例题详解：<strong>斐波那系数</strong>中解释）。</p> 
<h3><a id="13_10"></a>1.3函数递归的两个必要条件</h3> 
<blockquote> 
 <ul><li>存在<strong>限制条件</strong>，当满足这个限制条件的时候，递归便不再继续。</li><li>每次递归调用之后越来越<strong>接近</strong>这个限制条件。</li></ul> 
</blockquote> 
<h2><a id="__13"></a>二. 入门级函数递归例题</h2> 
<hr> 
<h3><a id="21_15"></a>2.1函数递归之死循环</h3> 
<p>我们了解了函数递归的基础概念后，来看看这段<strong>有趣而危险</strong>的代码。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"cc\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//重复调用main函数</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可想而知，程序最终会崩溃。因为每一次函数调用都会在栈上开辟一块空间，这种死循环的代码会一直开辟空间，直至<strong>栈溢出</strong>，正如上面的缺点②。</p> 
<h3><a id="221234_28"></a>2.2输入输出1234</h3> 
<p><strong>题目描述</strong>:</p> 
<blockquote> 
 <p>接受一个整型值（无符号），按照顺序打印它的每一位。<br> 例如：<br> 输入：1234，输出 1234</p> 
</blockquote> 
<p><strong>解题思路</strong>：这种输入输出数字的题，我们一定要想到<strong>取模和取余</strong>的方法,并且要有<strong>限制条件</strong>，每次函数递归后，都会越来越<strong>接近</strong>这个值。<br> 所以先<strong>函数递推</strong>1234%10=4,123%10=3,12%10=2,1%10=1，给定限制条件n&gt;9,直到n=1，打印出最后值（1），最后<strong>函数回归</strong>打印出<strong>1234</strong>。</p> 
<blockquote> 
 <p>设n为1234<br> print(1234/10) + 1234%10 (=<strong>4</strong>)<br> print(123/10) + 123%10（=<strong>3</strong>）<br> print(12/10) + 12%10（=<strong>2</strong>）<br> 当n最后为1时，不满足我们给定的<strong>限制条件n&gt;9</strong>时，即<strong>打印</strong>1%10（=<strong>1</strong>）</p> 
</blockquote> 
<p><strong>代码实现</strong>：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token number">9</span><span class="token punctuation">)</span>     <span class="token comment">//限定条件</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">print</span><span class="token punctuation">(</span>n <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//取模</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> n <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//取余</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%u"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//按顺序打印1234</span>
	<span class="token function">print</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/5c/c6/2H2FRGdb_o.jpg" alt="图片 1" height="300"></p> 
<h2><a id="__63"></a>三. 函数递归典型例题的实现</h2> 
<hr> 
<h3><a id="31n_65"></a>3.1求n的阶乘</h3> 
<p><strong>题目描述</strong>:</p> 
<blockquote> 
 <p>用递归的方法求n的阶乘（不考虑溢出问题）<br> 例如：<br> 输入：4，输出 24</p> 
</blockquote> 
<p><strong>解题思路</strong>：n的阶乘为1<em>2</em>3<em>4</em>…<em>(n-1)<em>n，我们可以先用<strong>递推</strong>的思想，先算出n</em>(n-1)的值，再用n</em>(n-1)的值乘以(n-2),这样依次乘下去，<strong>以n=1为限制条件</strong>，返回1。然后再用<strong>回归</strong>思想，返回回去，及可得到n的阶乘。</p> 
<blockquote> 
 <p>JC(n)<br> n * JC(n-1)<br> n * JC(n-1) * JC(n-2)<br> n * JC(n-1) * JC(n-2) * JC(n-3)<br> …<br> n * JC(n-1) * JC(n-2) * JC(n-3)…JC(1)<br> 当满足我们的<strong>限制条件n=1</strong>时，返回1，然后回归</p> 
</blockquote> 
<p><strong>代码实现</strong>：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">JC</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span> 
	<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> 
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		<span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token function">JC</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//阶乘的递归实现方式        </span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">JC</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"n的阶乘为：%d"</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/b0/8b/KXAcK8wD_o.jpg" alt="图片 2" height="300"></p> 
<h3><a id="32strlen_99"></a>3.2strlen函数的模拟实现</h3> 
<p><strong>题目描述</strong>:</p> 
<blockquote> 
 <p>用递归的方法模拟实现strlen函数<br> 例如：<br> 输入：abc，输出 3</p> 
</blockquote> 
<p><strong>解题思路</strong>：strlen函数遇到’\0’才会停止，所以我们<strong>以’\0’为限制条件</strong>，我们每调用一次我们自己实现的my_strlen函数，次数就加一，直到遇到’\0’停止。</p> 
<blockquote> 
 <p>my_strlen(abc)--------------这里是指针在移动<br> 1+my_strlen(bc)<br> 1+my_strlen(b)<br> 1+my_strlen(‘\0’)<br> 当满足我们的**限制条件’\0’**时，返回0，然后回归</p> 
</blockquote> 
<p><strong>代码实现</strong>：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">my_strlen</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>str <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">my_strlen</span><span class="token punctuation">(</span>str <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//strlen函数的模拟实现方式</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">my_strlen</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/b8/65/iQlTRz32_o.jpg" alt="图片 3" height="300"></p> 
<h3><a id="33nk_133"></a>3.3求n的k次幂</h3> 
<p><strong>题目描述</strong>:</p> 
<blockquote> 
 <p>用递归的方法实现n的k次幂<br> 例如：<br> 输入：3,3，输出 27</p> 
</blockquote> 
<p><strong>解题思路</strong>：<strong>以k&gt;0和k=0为限制条件</strong>，每一次<strong>递推</strong>就乘以n，并且k都减一次1，直到不满足限定条件，然后回归，即为27。</p> 
<blockquote> 
 <p>n=3,k=3<br> Pow(n,3)<br> n * Pow(n,3-1)<br> n * Pow(n,2-1)<br> n * Pow(n,1-1)<br> <strong>以k&gt;0和k=0为限制条件</strong>，当k=0时，直接返回1，然后回归</p> 
</blockquote> 
<p><strong>代码实现</strong>：</p> 
<pre><code class="prism language-c"><span class="token keyword">double</span> <span class="token function">Pow</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token function">Pow</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//①    </span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		<span class="token keyword">return</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token function">Pow</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token operator">-</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//k是负数的时候---------------可以去步骤①,因为k大于零了 </span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span><span class="token operator">&amp;</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">double</span> ret <span class="token operator">=</span> <span class="token function">Pow</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.1lf\n"</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/88/d3/ukKDTtlR_o.jpg" alt="图片 4" height="300"></p> 
<h3><a id="34_170"></a>3.4字符串逆序</h3> 
<p><strong>题目描述</strong>:</p> 
<blockquote> 
 <p>用递归的方法实现字符串逆序<br> 例如：<br> 输入：abcdef，输出 fedcba</p> 
</blockquote> 
<p><strong>解题思路</strong>：这题我们要<strong>以字符串长度为限制条件</strong>，先用临时变量tmp把a存起来，然后把f赋值给a,再把f置<strong>为’\0’（便于之后用strlen函数求字符串长度）</strong>，每一次<strong>递推</strong>后面都要带有把tmp赋值给’\0’。之后再用临时变量tmp把存b起来,然后把e赋值给b,再把e置<strong>为’\0’…依次递推，直到</strong>字符串长度不大于1**时，<strong>回归</strong>回去，即可得到fedcba。</p> 
<blockquote> 
 <p><strong>递推</strong>：<br> f b c d e \0<br> f e c d \0 \0<br> f e d \0 \0 \0<br> <strong>回归</strong>：<br> f e d c \0 \0<br> f e d c b \0<br> f e d c b a</p> 
</blockquote> 
<p><strong>代码实现</strong>：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">reverse_string</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> string<span class="token punctuation">)</span>                      
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span> tmp <span class="token operator">=</span> <span class="token operator">*</span>string<span class="token punctuation">;</span> 
	<span class="token operator">*</span>string <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>string <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token operator">*</span><span class="token punctuation">(</span>string <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>string<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token punctuation">)</span>           
		<span class="token function">reverse_string</span><span class="token punctuation">(</span>string <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token operator">*</span><span class="token punctuation">(</span>string <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>             <span class="token comment">//这一步才能赋值，把tmp 赋值为'\0'</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abcdef"</span><span class="token punctuation">;</span>
	<span class="token function">reverse_string</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/19/f9/6vTOuJlw_o.jpg" alt="图片 5" height="300"></p> 
<h3><a id="35_206"></a>3.5斐波那契数（递归实现和非递归实现）</h3> 
<h4><a id="351_207"></a>3.5.1递归的实现</h4> 
<p><strong>题目描述</strong>:</p> 
<blockquote> 
 <p>计算斐波那契数递归实现求第n个斐波那契数<br> 例如：<br> 输入：5 输出：5<br> 输入：10， 输出：55<br> 输入：2， 输出：1</p> 
</blockquote> 
<p><strong>解题思路</strong>：斐波那系数是前两项加起来等于后一项：1，1，2，3，5，8，13…,所以我们可以<strong>以n&lt;=2为限制条件</strong>，当n=1或2时，返回1，然后到<strong>n=3项时就是n=1项和n=2项之和</strong>，然后依次往后推，即<strong>Fib(n)就是Fib(n-1)和Fib(n-2)之和</strong>。</p> 
<blockquote> 
 <p>Fib(n)<br> Fib(n-1) + Fib(n-2)<br> Fib(n-2)+Fib(n-3) , Fib(n-3)+Fib(n-4)<br> …<br> 一直<strong>递推</strong>下去，直至到Fib(1)和Fib(2)返回值为1，然后回归，得到第n个斐波那契数</p> 
</blockquote> 
<p><strong>代码实现</strong>：</p> 
<pre><code class="prism language-c"><span class="token keyword">long</span> <span class="token function">Fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		<span class="token keyword">return</span> <span class="token function">Fib</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">Fib</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//前两项加起来等于后一项</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">long</span> ret <span class="token operator">=</span> <span class="token function">Fib</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%ld"</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/0e/07/a5dktJVJ_o.jpg" alt="图片 6" height="300"></p> 
<h4><a id="352_242"></a>3.5.2非递归的实现</h4> 
<p><strong>题目描述</strong>:</p> 
<blockquote> 
 <p>计算斐波那契数递归实现求第n个斐波那契数<br> 例如：<br> 输入：5 输出：5<br> 输入：10， 输出：55<br> 输入：2， 输出：1</p> 
</blockquote> 
<p><strong>解题思路</strong>：也可以参考上面递归实现的思路，我们可以用三个变量相互替换来解决，<strong>n1为第一项，n2为第二项，tmp为第三项</strong>，运用while()循环，每一次循环n就减1，直到n=2，最后输出tmp。</p> 
<blockquote> 
 <p>n=5<br> n1=1,n2=1 ,tmp=n1+n2=2<br> n1=n2=1,n2=tmp=2,tmp=n1+n2=3<br> …<br> 依次类推直到n为2停下，即可得第n个斐波那契数</p> 
</blockquote> 
<p><strong>代码实现</strong>：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> n1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> n2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">long</span> tmp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">&gt;</span><span class="token number">2</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		tmp <span class="token operator">=</span> n1 <span class="token operator">+</span> n2<span class="token punctuation">;</span>    <span class="token comment">//三项互相替换</span>
		n1 <span class="token operator">=</span> n2<span class="token punctuation">;</span>
		n2 <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
		n<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%1d"</span><span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="353_282"></a>3.5.3斐波那契数的非递归的实现优于递归实现的原因</h4> 
<p>①.函数递归的原则是大事化小”，对于很多问题的求解上是很遍历，而且非常迅速。但是他也是有缺点的，世界上没有完美的“事物”，函数递归也不例外。因为每一次函数递归（函数调用）都会在<strong>函数栈帧</strong>上开辟一块空间，所谓的压栈。这样会大大降低我们代码的<strong>执行效率</strong>。</p> 
<p>②.这题用递归法实现的斐波那契数正对应了其<strong>缺点</strong>，<strong>因为它的递推时会有很多分支，一个分支下面又有很多分支，每一个小分支都是函数的调用，然而还有回归，函数栈帧需要销毁，这会大大降低代码的执行效率，如果n=50，则代码执行时间都要1个多小时（这里会涉及到数据结构中时间复杂度和空间复杂度的概念），所以用递归法实现的斐波那系数其实是不实用的</strong>。</p> 
<p>③.而用非递归的方法实现，可以大大提高代码的运行效率。只是每一次循环，n1,n2,tmp会被赋值，代码执行次数大大减少，所以斐波那契数的非递归的实现优于递归实现的。</p> 
<h3><a id="36_288"></a>3.6经典问题之《青蛙跳台阶》</h3> 
<p><strong>题目描述</strong>:</p> 
<blockquote> 
 <p>青蛙一次可以跳一级台阶，也可以跳两级台阶。求该青蛙跳n级台阶共有多少种跳法？<br> 例如：<br> 输入：5 输出：8</p> 
</blockquote> 
<p><strong>解题思路</strong>：<strong>青蛙跳台阶的思路是和斐波那系数的思路是完全等价的</strong>,只不过有了个主人公青蛙而已。因为青蛙跳1级台阶有一种走法，跳2级台阶有两种走法，而跳3级台阶有三种走法，所以跳3级台阶的走法是前面跳1级台阶和2级台阶之和，所以依次类推<strong>青蛙跳级台阶有一种走法等于跳n-1级台阶和n-2级台阶之和</strong>,所以问题就转变为求解第n个斐波那系数了。</p> 
<blockquote> 
 <p>walk(n)<br> walk(n-1) + walk(n-2)<br> walk(n-2)+walk(n-3) , walk(n-3)+walk(n-4)<br> …<br> 一直<strong>递推</strong>下去，直至到walk(1)和walk(2)分别返回值为1和2，然后回归，得到青蛙跳n级台阶的跳法</p> 
</blockquote> 
<p><strong>代码实现</strong>：</p> 
<pre><code class="prism language-c"><span class="token keyword">long</span> <span class="token function">walk</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		<span class="token keyword">return</span> <span class="token function">walk</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">walk</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//前两项加起来等于后一项</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">long</span> ret <span class="token operator">=</span> <span class="token function">walk</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%ld"</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/58/22/Qgu0LlEu_o.jpg" alt="图片 7" height="300"><br> <img src="https://images2.imgbox.com/48/54/RFw9V5rR_o.jpg" alt="图片 8" height="300"></p> 
<h3><a id="37_323"></a>3.7经典问题之《汉诺塔问题》</h3> 
<p><strong>题目描述</strong>:</p> 
<blockquote> 
 <p>总共有<strong>三个柱子</strong>，在一根柱子上，从下往上按照大小顺序摞着n片圆盘。我们需要按大小顺序重新摆放在另一根柱子上。并且规定，在移动过程，小圆盘上不能放大圆盘，<strong>在三根柱子之间一次只能移动一个圆盘</strong>。</p> 
</blockquote> 
<p><strong>解题思路</strong>：我们需要把圆盘看做一个一个的整体，而且需要有<strong>大事化小</strong>的思想。假设我们有三根柱子：A,B,C（<strong>A:表示起始位置，B:表示中转站<br> ，C:表示目标位置</strong>）</p> 
<ul><li>如果A柱有<strong>n=1</strong>个盘子，我们只要把它移动到C柱上就可以了。<strong>对应过程演示（1）</strong>。</li><li>如果A柱有<strong>n=2</strong>个盘子，则需先把<strong>A柱</strong>上第一个盘子放到<strong>B柱</strong>上 -&gt; 再把<strong>A柱</strong>上第二个盘子（<strong>这时n=1</strong>）放到<strong>C柱</strong>上。<strong>对应过程演示（2）</strong>。</li><li>如果A柱有<strong>n=3</strong>个盘子，①.第一步：则需先把<strong>A柱</strong>上第一个盘子放到<strong>C柱</strong>上 -&gt; 再把<strong>A柱</strong>上第二个盘子放到<strong>B柱</strong>上 -&gt; 然后把<strong>C柱</strong>上的盘子放到<strong>B柱</strong>上面 -&gt; 然后把<strong>A柱</strong>上第三个盘子（<strong>这时n=1</strong>）放到<strong>C柱</strong>上。②.第二步：再想办法把<strong>B柱</strong>上的圆盘移动到<strong>A柱</strong>上,先把<strong>B柱</strong>上第一个圆盘放到<strong>A柱</strong>上 -&gt; 再把<strong>B柱</strong>上的圆盘放到<strong>C柱</strong>上 -&gt; 最后再把<strong>A柱</strong>上的圆盘放到<strong>C柱</strong>上。<strong>对应过程演示（3）</strong>。</li><li>…</li><li>如果A柱有<strong>n</strong>个盘子，步骤是一样的，肯定是先想办法把<strong>A柱</strong>上<strong>n-1</strong>个圆盘移动到<strong>B柱</strong>上 -&gt; 之后才能想办法把<strong>第n个</strong>圆盘从<strong>A柱</strong>放到<strong>C柱</strong>上面（<strong>即n=1的时候，递归的限制条件</strong>） -&gt; 最后想办法把<strong>B柱</strong>上的圆盘移动到<strong>C柱</strong>上面。<strong>对应过程演示（4）</strong>。</li></ul> 
<blockquote> 
 <p>这里<strong>递归的限制条件是n=1</strong><br> 并且一定要注意：我们在解决汉诺塔问题时，一定不能太过于深究里面圆盘移动的过程，因为比较复杂，很容易让人绕进去。所以我们这里<strong>不考虑上述中的“想办法”（即移动的过程）</strong><br> 我们只要懂其中的原理就可以把汉诺塔实现出来，运用<strong>大事化小</strong>的思想</p> 
</blockquote> 
<p><strong>代码实现</strong>：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">Move</span><span class="token punctuation">(</span><span class="token keyword">char</span> src<span class="token punctuation">,</span> <span class="token keyword">char</span> dest<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// src表示的是起始位置，dest表示的是目标位置</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"盘子从%c柱子-&gt;%c柱子\n"</span><span class="token punctuation">,</span>src<span class="token punctuation">,</span>dest<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">Plate_Move</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">char</span> A<span class="token punctuation">,</span> <span class="token keyword">char</span> B<span class="token punctuation">,</span> <span class="token keyword">char</span> C<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">Move</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//这里即递归停下来的地方，把最底下一层的盘子（n），移动到C柱上</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token comment">//这里下面都是在递归ing!!! （下面这三条语句其实都是在同步进行的）</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">Plate_Move</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>A<span class="token punctuation">,</span>C<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//当不只一个圆盘时，我们先将上面 （n -1）个圆盘 借助 C柱子  从 A 柱子移动到 B 柱子</span>
		
		<span class="token function">Move</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//A柱剩余一个圆盘，将剩下的一个圆盘从 A 移动到 C</span>
		
		<span class="token function">Plate_Move</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> B<span class="token punctuation">,</span> A<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//以A柱为中转站，把B柱上的圆盘放在C上。</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Plate_Move</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token char">'A'</span><span class="token punctuation">,</span> <span class="token char">'B'</span><span class="token punctuation">,</span> <span class="token char">'C'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//n为几个圆盘，A,B,C分别对应A，B，C三个柱子</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_370"></a>过程演示</h4> 
<p><strong>（1）A柱上有1个圆盘：</strong></p> 
<p><img src="https://images2.imgbox.com/18/50/jbrHCNXQ_o.jpg" alt="图片 9" height="200"><br> <strong>（2）A柱上有2个圆盘：</strong></p> 
<p><img src="https://images2.imgbox.com/77/78/X37OgdKp_o.jpg" alt="图片 10" height="300"><br> <strong>（3）A柱上有3个圆盘：</strong></p> 
<p><img src="https://images2.imgbox.com/36/14/4tY61jeE_o.jpg" alt="图片 11" height="700"><br> <strong>（4）A柱上有n个圆盘：</strong></p> 
<p><img src="https://images2.imgbox.com/99/89/yfpSuvpm_o.jpg" alt="图片 12" height="350"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a5b4989c2dc3cdd4ea7c468378605767/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">echarts入门教程（超级详细带案例）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a4ab83e8e7b57e2c52b917540b40bec8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SQL常用语句大全</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>