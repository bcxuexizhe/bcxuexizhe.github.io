<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>23种设计模式学习导航（Java完整版） - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/7ea648647bcf98658f12bbf7cfa728f1/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="23种设计模式学习导航（Java完整版）">
  <meta property="og:description" content="本篇文章是作者对23种设计模式学习的一个总结，包含设计模式的三大分类（创建型5种，结构型7种，行为型11种）和七个面向对象设计原则，为了方便大家学习，现将23种设计模式的链接进行了整理，希望对大家有所帮助。 23种设计模式源码地址：GitHub - lkydog/Design-Pattern: ⭐java实现，23种设计模式
一、什么是设计模式 设计模式一种在软件开发种非常重要的编程技巧，它提供了经过验证的解决方案，可以使代码更加可读、可扩展和可维护，我们可以将常见的变成模式抽象出来，从而形成一组通用的解决方案，应用于不同的情况。
ps：设计模式代表的是一种思想，至于怎么千变万化就看大家的了。
二、设计模式的三大分类及对应模式（导航） 注意：以下学习难度和使用频率的星级，仅代表个人观点。
2.1 创建型模式（5种） 定义：主要涉及对象创建的机制，按照合适的方式避免直接创建对象，在系统运行过程中降低对象创建和管理的负担。
1.单例模式-Singleton Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】 定义：确保一个类最多只有一个实例，并提供一个全局访问点。描述：包含饿汉式2种、懒汉式4种、静态内部类、枚举等实现方式。 2.工厂模式-Factory Pattern【学习难度：★★☆☆☆，使用频率：★★★★★】 定义：提供一个公共的接口，使得可以在不暴露对象创建逻辑的情况下创建。描述：包含简单工厂模式、方法工厂模式以及抽象工厂模式。简单工厂和方法工厂以卖包子为例，抽象工厂以卖包子和卖蛋糕为例。 3.抽象工厂模式（工厂模式已包含，不再赘述） 4.建造者模式-Builder Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】 定义：封装一个复杂对象构造过程，并允许按步骤构造。描述：以肯德基套餐为例。 5.原型模式-Prototype Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】 定义：通过复制现有实例来创建新的实例，无需知道相应类的信息。描述：以英雄联盟塞拉斯窃取其他英雄大招为例。 2.2 结构型模式（7种） 定义：主要关注对象组合的方式，解决对象之间的关系，解决子系统之间的耦合度和扩展问题。
1.适配器模式-Adapter Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】 定义：允许不兼容的接口之间进行合作。描述：以英汉互译为例，包含类适配器、对象适配器、接口适配器。 2.装饰者模式-Decorator Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】 定义：动态的将新功能附加到对象上。描述：以LOL中盲僧学习技能（Q、W、E、R）为例。 3.代理模式-Proxy Pattern【学习难度：★★☆☆☆，使用频率：★★★★☆】 定义：给某一个对象提供一个代理对象，并由代理对象控制对原有对象的引用。描述：以房屋中介为例，包含静态代理、JDK动态代理和Cglib代理。 4.外观模式-Facade Pattern【学习难度：★☆☆☆☆，使用频率：★★★★★】 定义：隐藏了系统的复杂性，并向客户端提供了一个可以访问系统的接口。描述：以旅行社为例。 5.桥接模式-Bridge Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】 定义：将抽象部分与它的实现部分分离，使它们都可以独立地变化。描述：以不同品牌手机和蓝牙耳机为例。 6.组合模式-Composite Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】 定义：将对象组合成树形的层次结构，用来表示“整体-部分”的关系。描述：以算数表达式为例。 7.享元模式-Flyweight Pattern【学习难度：★★★★☆，使用频率：★★☆☆☆】 定义：通过共享的方式减少创建对象的数量，以减少内存占用和提升性能。描述：以共享单车为例。 2.3 行为型模式（11种） 定义：主要关注对象之间的交流和协作，解决类或对象之间的交互问题。
1.策略模式-Strategy Pattern【学习难度：★☆☆☆☆，使用频率：★★★★★】 定义：定义了一系列的算法，并将每个算法封装起来，是他们可以相互替换。描述：以刷视频选择视频平台为例。 2.模板模式-Template Pattern【学习难度：★★☆☆☆，使用频率：★★★★☆】 定义：在抽象类中定义算法的骨架，把具体的操作留给子类来实现。描述：以订外卖为例。 3.观察者模式-Observer Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】 定义：它定义了对象之间的一对多依赖关系，当一个对象的状态发生变化时，它所有的依赖对象都会自动收到通知并更新自身。描述：以报纸和报纸订阅者为例。 4.迭代器模式-Iterator Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】 定义：提供了一种统一的方式来访问集合对象中的元素，而不是暴露集合内部的表示方式。描述：以遍历班级学生为例。 5.解释器模式-Interpreter Pattern【学习难度：★★★★★，使用频率：★☆☆☆☆】 定义：定义了一种语言，并定义该语言中语句的解释器，从而允许以编程方式定义语法、解析语法以及处理语法中的解释器。描述：以四则运算为例。 6.中介者模式-Mediator Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】 定义：用于降低多个对象之间的耦合度，通过引入一个中介者对象来协调对象之间的交互。描述：以物流公司协调运输公司和商家为例。 7.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-27T15:47:44+08:00">
    <meta property="article:modified_time" content="2024-04-27T15:47:44+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">23种设计模式学习导航（Java完整版）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>本篇文章是作者对23种设计模式学习的一个总结，包含设计模式的<strong><span style="color:#1c7331;">三大分类（创建型5种，结构型7种，行为型11种）和七个面向对象设计原则</span></strong>，为了方便大家学习，现将23种设计模式的链接进行了整理，希望对大家有所帮助。 </p> 
<p><strong><span style="color:#956fe7;">23种设计模式源码地址：</span></strong><a href="https://github.com/lkydog/Design-Pattern" title="GitHub - lkydog/Design-Pattern: ⭐java实现，23种设计模式">GitHub - lkydog/Design-Pattern: ⭐java实现，23种设计模式</a></p> 
<h2>一、什么是设计模式</h2> 
<blockquote> 
 <p>设计模式一种在软件开发种非常重要的编程技巧，它提供了经过验证的解决方案，可以使代码更加可读、可扩展和可维护，我们可以将常见的变成模式抽象出来，从而形成一组通用的解决方案，应用于不同的情况。</p> 
 <p><span style="color:#fe2c24;">ps：设计模式代表的是一种思想，至于怎么千变万化就看大家的了。</span></p> 
</blockquote> 
<h2 id="%E4%B8%89%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%89%E5%A4%A7%E5%88%86%E7%B1%BB%E5%8F%8A%E5%AF%B9%E5%BA%94%E6%A8%A1%E5%BC%8F">二、设计模式的三大分类及对应模式（导航）</h2> 
<p><span style="color:#fe2c24;">注意：以下学习难度和使用频率的星级，仅代表个人观点。</span></p> 
<h3 id="3.1%20%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%885%E7%A7%8D%EF%BC%89">2.1 创建型模式（5种）</h3> 
<p><strong>定义：主要涉及对象创建的机制，按照合适的方式避免直接创建对象，在系统运行过程中降低对象创建和管理的负担。</strong></p> 
<h4><a class="link-info" href="https://blog.csdn.net/weixin_45433817/article/details/130853883?spm=1001.2014.3001.5501" title="1.单例模式-Singleton Pattern">1.单例模式-Singleton Pattern</a><strong>【</strong><strong>学习难度：<span style="color:#fe2c24;">★☆☆☆☆</span>，使用频率：<span style="color:#fe2c24;">★★★★☆</span>】</strong></h4> 
<blockquote> 
 <ul><li><strong>定义：确保一个类最多只有一个实例，并提供一个全局访问点。</strong></li><li><strong>描述：包含饿汉式2种、懒汉式4种、静态内部类、枚举等实现方式。</strong></li></ul> 
</blockquote> 
<h4><a class="link-info" href="https://blog.csdn.net/weixin_45433817/article/details/130934548?spm=1001.2014.3001.5501" title="2.工厂模式-Factory Pattern">2.工厂模式-Factory Pattern</a><strong>【学习难度：<span style="color:#fe2c24;">★★☆☆☆</span>，使用频率：<span style="color:#fe2c24;">★★★★★</span>】</strong></h4> 
<blockquote> 
 <ul><li><strong>定义：提供一个公共的接口，使得可以在不暴露对象创建逻辑的情况下创建。</strong></li><li><strong>描述：包含简单工厂模式、方法工厂模式以及抽象工厂模式。简单工厂和方法工厂以卖包子为例，抽象工厂以卖包子和卖蛋糕为例。</strong></li></ul> 
</blockquote> 
<h4><strong>3.抽象工厂模式（<span style="color:#fe2c24;">工厂模式</span>已包含，不再赘述）</strong></h4> 
<h4><a class="link-info" href="https://blog.csdn.net/weixin_45433817/article/details/131175862?spm=1001.2014.3001.5501" title="4.建造者模式-Builder Pattern">4.建造者模式-Builder Pattern</a><strong>【学习难度：<span style="color:#fe2c24;">★★★☆☆</span>，使用频率：<span style="color:#fe2c24;">★★☆☆☆</span>】</strong></h4> 
<blockquote> 
 <ul><li><strong>定义：封装一个复杂对象构造过程，并允许按步骤构造。</strong></li><li><strong>描述：以肯德基套餐为例。</strong></li></ul> 
</blockquote> 
<h4><a class="link-info" href="https://blog.csdn.net/weixin_45433817/article/details/131095164?spm=1001.2014.3001.5501" title="5.原型模式-Prototype Pattern">5.原型模式-Prototype Pattern</a>【<strong>学习难度：<span style="color:#fe2c24;">★★★☆☆</span>，使用频率：<span style="color:#fe2c24;">★★★☆☆</span></strong>】</h4> 
<blockquote> 
 <ul><li><strong>定义：通过复制现有实例来创建新的实例，无需知道相应类的信息。</strong></li><li><strong>描述：以英雄联盟塞拉斯窃取其他英雄大招为例。</strong></li></ul> 
</blockquote> 
<h3 id="3.2%20%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%887%E7%A7%8D%EF%BC%89">2.2 结构型模式（7种）</h3> 
<p><strong>定义：主要关注对象组合的方式，解决对象之间的关系，解决子系统之间的耦合度和扩展问题。</strong></p> 
<h4><a class="link-info" href="https://blog.csdn.net/weixin_45433817/article/details/131153032?spm=1001.2014.3001.5501" title="1.适配器模式-Adapter Pattern">1.适配器模式-Adapter Pattern</a>【<strong>学习难度：<span style="color:#fe2c24;">★★☆☆☆</span>，使用频率：<span style="color:#fe2c24;">★★★☆☆</span></strong>】</h4> 
<blockquote> 
 <ul><li><strong>定义：允许不兼容的接口之间进行合作。</strong></li><li><strong>描述：以英汉互译为例，包含类适配器、对象适配器、接口适配器。</strong></li></ul> 
</blockquote> 
<h4><a class="link-info" href="https://blog.csdn.net/weixin_45433817/article/details/131074125?spm=1001.2014.3001.5501" title="2.装饰者模式-Decorator Pattern">2.装饰者模式-Decorator Pattern</a>【<strong>学习难度：<span style="color:#fe2c24;">★★★☆☆</span>，使用频率：<span style="color:#fe2c24;">★★★☆☆</span></strong>】</h4> 
<blockquote> 
 <ul><li><strong>定义：动态的将新功能附加到对象上。</strong></li><li><strong>描述：以LOL中盲僧学习技能（Q、W、E、R）为例。</strong></li></ul> 
</blockquote> 
<h4><a class="link-info" href="https://blog.csdn.net/weixin_45433817/article/details/130975792?spm=1001.2014.3001.5501" title="3.代理模式-Proxy Pattern">3.代理模式-Proxy Pattern</a>【<strong>学习难度：<span style="color:#fe2c24;">★★☆☆☆</span>，使用频率：<span style="color:#fe2c24;">★★★★☆</span></strong>】</h4> 
<blockquote> 
 <ul><li><strong>定义：给某一个对象提供一个代理对象，并由代理对象控制对原有对象的引用。</strong></li><li><strong>描述：以房屋中介为例，包含静态代理、JDK动态代理和Cglib代理。</strong></li></ul> 
</blockquote> 
<h4><a class="link-info" href="https://blog.csdn.net/weixin_45433817/article/details/131214686?spm=1001.2014.3001.5501" title="4.外观模式-Facade Pattern">4.外观模式-Facade Pattern</a>【<strong>学习难度：<span style="color:#fe2c24;">★☆☆☆☆</span>，使用频率：<span style="color:#fe2c24;">★★★★★</span></strong>】</h4> 
<blockquote> 
 <ul><li><strong>定义：隐藏了系统的复杂性，并向客户端提供了一个可以访问系统的接口。</strong></li><li><strong>描述：以旅行社为例。</strong></li></ul> 
</blockquote> 
<h4><a class="link-info" href="https://blog.csdn.net/weixin_45433817/article/details/131234978?spm=1001.2014.3001.5501" title="5.桥接模式-Bridge Pattern">5.桥接模式-Bridge Pattern</a>【<strong>学习难度：<span style="color:#fe2c24;">★★★☆☆</span>，使用频率：<span style="color:#fe2c24;">★★☆☆☆</span></strong>】</h4> 
<blockquote> 
 <ul><li><strong>定义：将抽象部分与它的实现部分分离，使它们都可以独立地变化。</strong></li><li><strong>描述：以不同品牌手机和蓝牙耳机为例。</strong></li></ul> 
</blockquote> 
<h4><a class="link-info" href="https://blog.csdn.net/weixin_45433817/article/details/131293595?spm=1001.2014.3001.5501" title="6.组合模式-Composite Pattern">6.组合模式-Composite Pattern</a>【<strong>学习难度：<span style="color:#fe2c24;">★★★☆☆</span>，使用频率：<span style="color:#fe2c24;">★★★★☆</span></strong>】</h4> 
<blockquote> 
 <ul><li><strong>定义：将对象组合成树形的层次结构，用来表示“整体-部分”的关系。</strong></li><li><strong>描述：以算数表达式为例。</strong></li></ul> 
</blockquote> 
<h4><a class="link-info" href="https://blog.csdn.net/weixin_45433817/article/details/131335574?spm=1001.2014.3001.5501" title="7.享元模式-Flyweight Pattern">7.享元模式-Flyweight Pattern</a>【<strong>学习难度：<span style="color:#fe2c24;">★★★★☆</span>，使用频率：<span style="color:#fe2c24;">★★☆☆☆</span></strong>】</h4> 
<blockquote> 
 <ul><li><strong>定义：通过共享的方式减少创建对象的数量，以减少内存占用和提升性能。</strong></li><li><strong>描述：以共享单车为例。</strong></li></ul> 
</blockquote> 
<h3 id="3.3%20%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%8811%E7%A7%8D%EF%BC%89">2.3 行为型模式（11种）</h3> 
<p><strong>定义：主要关注对象之间的交流和协作，解决类或对象之间的交互问题。</strong></p> 
<h4><a class="link-info" href="https://blog.csdn.net/weixin_45433817/article/details/130874105?spm=1001.2014.3001.5501" title="1.策略模式-Strategy Pattern">1.策略模式-Strategy Pattern</a>【<strong>学习难度：<span style="color:#fe2c24;">★☆☆☆☆</span>，使用频率：<span style="color:#fe2c24;">★★★★★</span></strong>】</h4> 
<blockquote> 
 <ul><li><strong>定义：定义了一系列的算法，并将每个算法封装起来，是他们可以相互替换。</strong></li><li><strong>描述：以刷视频选择视频平台为例。</strong></li></ul> 
</blockquote> 
<h4><a class="link-info" href="https://blog.csdn.net/weixin_45433817/article/details/131355105?spm=1001.2014.3001.5501" title="2.模板模式-Template Pattern">2.模板模式-Template Pattern</a>【<strong>学习难度：<span style="color:#fe2c24;">★★☆☆☆</span>，使用频率：<span style="color:#fe2c24;">★★★★☆</span></strong>】</h4> 
<blockquote> 
 <ul><li><strong>定义：在抽象类中定义算法的骨架，把具体的操作留给子类来实现。</strong></li><li><strong>描述：以订外卖为例。</strong></li></ul> 
</blockquote> 
<h4><a class="link-info" href="https://blog.csdn.net/weixin_45433817/article/details/130994583?spm=1001.2014.3001.5501" title="3.观察者模式-Observer Pattern">3.观察者模式-Observer Pattern</a>【<strong>学习难度：<span style="color:#fe2c24;">★★★☆☆</span>，使用频率：<span style="color:#fe2c24;">★★★★☆</span></strong>】</h4> 
<blockquote> 
 <ul><li><strong>定义：它定义了对象之间的一对多依赖关系，当一个对象的状态发生变化时，它所有的依赖对象都会自动收到通知并更新自身。</strong></li><li><strong>描述：以报纸和报纸订阅者为例。</strong></li></ul> 
</blockquote> 
<h4><a class="link-info" href="https://blog.csdn.net/weixin_45433817/article/details/131382881?spm=1001.2014.3001.5501" title="4.迭代器模式-Iterator Pattern">4.迭代器模式-Iterator Pattern</a>【<strong>学习难度：<span style="color:#fe2c24;">★★★☆☆</span>，使用频率：<span style="color:#fe2c24;">★★★★☆</span></strong>】</h4> 
<blockquote> 
 <ul><li><strong>定义：提供了一种统一的方式来访问集合对象中的元素，而不是暴露集合内部的表示方式。</strong></li><li><strong>描述：以遍历班级学生为例。</strong></li></ul> 
</blockquote> 
<h4><a class="link-info" href="https://blog.csdn.net/weixin_45433817/article/details/131399271?spm=1001.2014.3001.5501" title="5.解释器模式-Interpreter Pattern">5.解释器模式-Interpreter Pattern</a>【<strong>学习难度：<span style="color:#fe2c24;">★★★★★</span>，使用频率：<span style="color:#fe2c24;">★☆☆☆☆</span></strong>】</h4> 
<blockquote> 
 <ul><li><strong>定义：定义了一种语言，并定义该语言中语句的解释器，从而允许以编程方式定义语法、解析语法以及处理语法中的解释器。</strong></li><li><strong>描述：以四则运算为例。</strong></li></ul> 
</blockquote> 
<h4><a class="link-info" href="https://blog.csdn.net/weixin_45433817/article/details/131444884?spm=1001.2014.3001.5501" title="6.中介者模式-Mediator Pattern">6.中介者模式-Mediator Pattern</a>【<strong>学习难度：<span style="color:#fe2c24;">★★★☆☆</span>，使用频率：<span style="color:#fe2c24;">★★☆☆☆</span></strong>】</h4> 
<blockquote> 
 <ul><li><strong>定义：用于降低多个对象之间的耦合度，通过引入一个中介者对象来协调对象之间的交互。</strong></li><li><strong>描述：以物流公司协调运输公司和商家为例。</strong></li></ul> 
</blockquote> 
<h4><a class="link-info" href="https://blog.csdn.net/weixin_45433817/article/details/131054732?spm=1001.2014.3001.5501" title="7.责任链模式-Chain Pattern">7.责任链模式-Chain Pattern</a>【<strong>学习难度：<span style="color:#fe2c24;">★★★☆☆</span>，使用频率：<span style="color:#fe2c24;">★★☆☆☆</span></strong>】</h4> 
<blockquote> 
 <ul><li><strong>定义：使用一条链来处理请求，该请求沿着链顺序传递，直到有对象处理该请求为止，从而达到解耦请求发送者和请求处理者的目的。</strong></li><li><strong>描述：以学校请假审批流程为例。</strong></li></ul> 
</blockquote> 
<h4><a class="link-info" href="https://blog.csdn.net/weixin_45433817/article/details/131465270?spm=1001.2014.3001.5501" title="8.命令模式-Command Pattern">8.命令模式-Command Pattern</a>【<strong>学习难度：<span style="color:#fe2c24;">★★★☆☆</span>，使用频率：<span style="color:#fe2c24;">★★★★☆</span></strong>】</h4> 
<blockquote> 
 <ul><li><strong>定义：将请求封装成一个对象，从而使不同的请求可以参数化、队列化、记录日志、撤销和重做等操作。</strong></li><li><strong>描述：以餐厅点餐为例。</strong></li></ul> 
</blockquote> 
<h4><a class="link-info" href="https://blog.csdn.net/weixin_45433817/article/details/131501970?spm=1001.2014.3001.5501" title="9.备忘录模式-Memento Pattern">9.备忘录模式-Memento Pattern</a>【<strong>学习难度：<span style="color:#fe2c24;">★★★☆☆</span>，使用频率：<span style="color:#fe2c24;">★★★☆☆</span></strong>】</h4> 
<blockquote> 
 <ul><li><strong>定义：允许将对象的内部状态保存到外部，从而在需要时可以将对象恢复到之前的状态。</strong></li><li><strong>描述：以为本编辑器为例。</strong></li></ul> 
</blockquote> 
<h4><a class="link-info" href="https://blog.csdn.net/weixin_45433817/article/details/131521862?spm=1001.2014.3001.5501" title="10.状态模式-State Pattern">10.状态模式-State Pattern</a>【<strong>学习难度：<span style="color:#fe2c24;">★★★☆☆</span>，使用频率：<span style="color:#fe2c24;">★★☆☆☆</span></strong>】</h4> 
<blockquote> 
 <ul><li><strong>定义：允许对象在内部状态发生改变时改变它的行为。</strong></li><li><strong>描述：以自动售卖机状态为例。</strong></li></ul> 
</blockquote> 
<h4><a class="link-info" href="https://blog.csdn.net/weixin_45433817/article/details/131562332?spm=1001.2014.3001.5501" title="11.访问者模式-Visitor Pattern">11.访问者模式-Visitor Pattern</a>【<strong>学习难度：<span style="color:#fe2c24;">★★★★☆</span>，使用频率：<span style="color:#fe2c24;">★☆☆☆☆</span></strong>】</h4> 
<blockquote> 
 <ul><li><strong>定义：用于在不修改已有对象结构的情况下，定义新的操作方式。</strong></li><li><strong>描述：以“旅游参观”为例。</strong></li></ul> 
</blockquote> 
<h2 id="%E4%BA%8C%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99">三、七大原则</h2> 
<p>设计模式的七大原则，也称为"<span style="color:#fe2c24;">SOLID原则</span>"，是面向对象设计种的基本准则。</p> 
<h3 id="2.1%20%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%EF%BC%88Single%20Responsibility%20Principle%EF%BC%8CSRP%EF%BC%89">3.1 单一职责原则（Single Responsibility Principle，SRP）</h3> 
<blockquote> 
 <ul><li>概念：<strong>一个类应该只有一个职责，即一个类应该只负责一个功能领域中的相应职责。</strong></li><li>例子：比如一个“水果”类，如果既包括了“水果基本属性”又包括了“水果存储方式”，那么这个类就存在着两个职责，违反了单一职责原则。正确的做法是将“水果基本属性”和“水果存储方式”拆分为两个类。</li></ul> 
</blockquote> 
<h3 id="2.2%20%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99%EF%BC%88Open-Closed%20Principle%EF%BC%8COCP%EF%BC%89">3.2 开放封闭原则（Open-Closed Principle，OCP）</h3> 
<blockquote> 
 <ul><li>概念：<strong>对扩展开放，对修改关闭。</strong></li><li>例子：比如一个计算器程序，如果每次添加新的计算方法都要修改原有代码，那么这个程序就违反了开放封闭原则。正确的做法是为每一种计算方法单独编写一个类或方法，这样当需要添加新的计算方法时，只需要增加一个新的类或方法即可，而不需要修改原有代码。</li></ul> 
</blockquote> 
<h3 id="2.3%20%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%EF%BC%88Liskov%20Substitution%20Principle%EF%BC%8CLSP%EF%BC%89">3.3 里氏替换原则（Liskov Substitution Principle，LSP）</h3> 
<blockquote> 
 <ul><li>概念：<strong>所有引用基类对象的地方，都能透明地使用其子类对象，而不会影响程序的正确性。</strong></li><li>例子：比如一个“动物”类和它的子类“鸟”类，如果鸟类无法继承动物类的方法或需要对动物类的方法进行重写才能满足其独有特性，那么这个子类就违反了里氏替换原则。</li></ul> 
</blockquote> 
<h3 id="2.4%20%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%EF%BC%88Interface%20Segregation%20Principle%2C%20ISP%EF%BC%89">3.4 接口隔离原则（Interface Segregation Principle, ISP）</h3> 
<blockquote> 
 <ul><li>概念：<strong>客户端不应该依赖于他们不需要的接口。即一个类对一个类的依赖应该建立在最小的接口上。</strong></li><li>例子：比如一个汽车类，如果其中包含了所有汽车可能用到的接口（加速、刹车、转向等等），其实有些汽车可能用不到这些接口，那么这个类就违反了接口隔离原则。正确的做法是将不同的接口分别放到不同的类中。</li></ul> 
</blockquote> 
<h3 id="2.5%20%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99%EF%BC%88Dependency%20Inversion%20Principle%EF%BC%8CDIP%EF%BC%89">3.5 依赖倒置原则（Dependency Inversion Principle，DIP）</h3> 
<blockquote> 
 <ul><li>概念：<strong>高层模块不应该依赖低层模块，而是应该依赖它们的抽象。即模块间应依赖于接口或抽象类，而不是实现类。</strong></li><li>例子：比如一个销售管理系统中，低层模块“数据库操作”模块依赖于高层模块“订单管理”模块。这样的设计不仅会增加耦合度，还会导致数据泄漏。正确的做法是将抽象的“数据库操作”模块放到更高的抽象层中，由“订单管理”模块调用。</li></ul> 
</blockquote> 
<h3 id="2.6%20%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%8E%9F%E5%88%99%EF%BC%88Law%20of%20Demeter%EF%BC%8CLoD%EF%BC%89">3.6 迪米特法原则（Law of Demeter，LoD）</h3> 
<blockquote> 
 <ul><li>概念：<strong>减少对象之间的依赖，即一个对象应当对其它对象有尽可能少的了解，不和陌生人说话。</strong></li><li>例子：比如一个电商网站，如果一个类要发送邮件通知顾客下单成功，带有的信息应该只包括商品信息和顾客账户信息，而不应该包括商品仓库信息、物流信息等等，这样的设计能够减少依赖关系，避免类之间的耦合。</li></ul> 
</blockquote> 
<h3 id="2.7%20%E7%BB%84%E5%90%88%2F%E8%81%9A%E5%90%88%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99%EF%BC%88Composition%2FAggregation%20Reuse%20Principle%EF%BC%8CCARP%EF%BC%89">3.7 组合/聚合复用原则（Composition/Aggregation Reuse Principle，CARP）</h3> 
<blockquote> 
 <ul><li>概念：<strong>应该优先使用组合或聚合关系复用，而不是使用继承关系复用。</strong></li><li>例子：比如一个“汽车轮子”类和它的子类“越野车轮子”类，如果采用继承关系来实现越野车轮子，那么可能会导致“越野车轮子”过于臃肿，而且未必完全符合实际需求。正确的做法是将两个类一同纳入到“汽车”类中，使用组合或聚合关系复用（即“汽车”类拥有“汽车轮子”类和“越野车轮子”类的实例）。</li></ul> 
</blockquote> 
<h2 id="%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93%C2%A0">四、总结 </h2> 
<blockquote> 
 <p><strong>正确地使用设计模式可以提高代码的可维护性和可扩展性，但错误地使用可能会增加代码复杂度、学习成本和性能开销。还是那句话，<span style="color:#fe2c24;">设计模式只是一个工具，不要为了使用设计模式而用。</span></strong></p> 
</blockquote> 
<h3></h3>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0791d8924a0df6d847fb3ef1afc76557/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring Boot3整合Redis</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/176437101e4abc9d6d079afb713de7c8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用LM Studio与Anything LLM基于Llama-3高效构建本地知识库系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>