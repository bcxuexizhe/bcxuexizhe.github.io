<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Java】JDK1.8 HashMap源码，put源码详细讲解 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/99945ed023ac0e9a510523e0bb6d815d/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【Java】JDK1.8 HashMap源码，put源码详细讲解">
  <meta property="og:description" content="📝个人主页：哈__
期待您的关注 目录
一、HashMap中的变量
1.默认容量
2.最大容量
3.负载因子
4.列表树化的阈值
5.红黑树转列表的阈值
6.树化时的最小数组容量
7.元素数组（存放我们插入的数据）
8.数组的大小（并非容量，而是实际放了多少个数据结点到table数组中） 9.Node结点
10.扩容阈值
二、HashMap的put方法
三、resize方法
在Java中，HashMap结构是被经常使用的，在面试当中也是经常会被问到的。这篇文章我给大家分享一下我对于HashMap结构源码的理解。
HashMap的存储与一般的数组不同，HashMap的每一个元素存储的并不是一个值，而是一个引用类型的Node结点，这也就意味着这个Node结点有被扩充的可能，因为这个Node结点可以是一个链表的Head结点，也可以是一棵树的根节点。
HashMap的存储数组叫做table，也可以称作“桶”，试想这样的一个场景：我们在一排放了3个桶，同时我们有4个苹果，如果我们要把所有的苹果放到桶当中，那么必然有一个桶中 的苹果个数&gt;=2。
这种情况在我们的HashMap中也会出现，我们的HashMap结构是把很多的数据存放到一个容量达不到元素个数的数组当中，就如同桶和苹果一样。
因此我们的HashMap结果会出现上图所示的一种冲突，我们成为散列冲突，也叫做Hash冲突 。
出现冲突不要怕，解决冲突就是了，我们的一个桶当中可以放两个苹果，自然HashMap的table数组的一个位置也可以存放两个元素。
问题来了，我们现在假设有16个桶，同时间断性的向桶中放苹果，而且还要能够方便我们后续去拿苹果和寻找苹果，那我们这16个桶还够用吗？我们这样子直接把苹果放进桶里，还能够方便我们后续找苹果吗？
行了，解决吧，现在假设你是一位苹果管理员，你该怎么优化一下？你看看这样子行不行，不就是放苹果、找苹果嘛，既然让我来管理，那我希望把苹果平均放到桶当中，每次我放的位置尽量不要和之前的苹果放的位置有冲突，如果桶多的话，你也不能一个一个桶去看吧，所以，我们定义了一个算法，我根据这个苹果的生产ID序列号去寻找对应的桶放进去，如同取余放置一样。这是个不错的思路。但序列号都是有规律的，这样会影响我们的放置，我们希望是一个很随机的结果，因此我们给这个序列号随机变动几个位置后在选择桶。在HashMap中，这样的序列号叫做hashCode值，经过一个扰动函数后，我们的到的扰动的值叫做hash。
如何存放的问题解决了，但苹果一旦多了还是会产生冲突，一个桶里放8个我还能找得到，但是一个桶里放20个，30个苹果，那我就找不到那个序列号的苹果了。
二叉树我们都学过，倘若我们把桶内的苹果以二叉树的方式进行存储，那这样我们在查找的时候是不是就省了很多时间呢？因此HashMap中的table内的一个元素列表长度＞8的时候，进行树化操作。但也不是非要进行树化的，毕竟树化也要浪费很多资源。当我们的桶的数量&lt;=64的时候，我们不进行树化操作，我们进行数组扩容，把table扩大2倍，这样的话，我们在放苹果的时候发生冲突的概率就会降低。但如果容量已经达到了64，我们就考虑把链表转为红黑树（也是二叉树）了。
以上的过程不知道你是否理解了没，放苹果的案例和HashMap存储元素的过程相似，现在我们来看代码吧。
一、HashMap中的变量 1.默认容量 HashMap无参构造方法调用时，我们的HashMap数组的初始容量是16。
/** * 默认初始化的容量大小，且必须是2的整数倍 */ static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 2.最大容量 记录了我们HashMap所能存储的最大的元素个数。
/** * 我们的元素数组的最大的容量，如果我们设定的最大容量比这个数还大 * 那我们就把容量设定为这个最大的值 */ static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; 3.负载因子 负载因子决定了HashMap在存储更多数据时如何扩展其容量。默认情况下，当负载因子达到0.75时，HashMap会进行扩容。这意味着，当HashMap中的元素数量达到数组容量的0.75倍时，数组的大小就会翻倍，以便容纳更多的数据。
为什么选择0.75作为默认的负载因子呢？这并不是随意的选择，而是经过深思熟虑后的优化值。负载因子实际上是一个权衡空间和时间的参数。在理想情况下，如果负载因子为1，这意味着每个索引位置上都有一个键值对存在。然而，当两个或更多的键具有相同的哈希值时，就会发生冲突，这会导致查询效率降低。因此，通过设置一个适当的负载因子，可以平衡键值对的存储效率和查询效率。
通过将负载因子设置为0.75，可以在空间和时间效率之间取得平衡。这意味着，当数组接近其容量时，HashMap会进行扩容，以避免因哈希冲突而导致的性能下降。同时，这个值也避免了因频繁扩容而产生的额外开销。在大多数情况下，0.75的负载因子可以提供较好的性能。
/** * 如果我们并没有自己初始化一个平衡因子，这个就是默认的平衡因子 */ static final float DEFAULT_LOAD_FACTOR = 0.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-02T08:30:31+08:00">
    <meta property="article:modified_time" content="2024-05-02T08:30:31+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java】JDK1.8 HashMap源码，put源码详细讲解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" height="150" src="https://images2.imgbox.com/1d/ab/KmqcVrwF_o.png" width="150"></p> 
<p style="text-align:center;"> <strong> 📝个人主页：<a class="link-info" href="https://blog.csdn.net/qq_61024956?type=blog" title="哈__">哈__</a></strong></p> 
<p style="text-align:center;"><span style="color:#fe2c24;">期待您的关注 </span></p> 
<p style="text-align:center;"><img alt="" height="100" src="https://images2.imgbox.com/34/09/zJUWQ7VG_o.gif" width="1000"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81HashMap%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81HashMap%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F" rel="nofollow">一、HashMap中的变量</a></p> 
<p id="1.%E9%BB%98%E8%AE%A4%E5%AE%B9%E9%87%8F-toc" style="margin-left:40px;"><a href="#1.%E9%BB%98%E8%AE%A4%E5%AE%B9%E9%87%8F" rel="nofollow">1.默认容量</a></p> 
<p id="2.%E6%9C%80%E5%A4%A7%E5%AE%B9%E9%87%8F-toc" style="margin-left:40px;"><a href="#2.%E6%9C%80%E5%A4%A7%E5%AE%B9%E9%87%8F" rel="nofollow">2.最大容量</a></p> 
<p id="3.%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90-toc" style="margin-left:40px;"><a href="#3.%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90" rel="nofollow">3.负载因子</a></p> 
<p id="4.%E5%88%97%E8%A1%A8%E6%A0%91%E5%8C%96%E7%9A%84%E9%98%88%E5%80%BC-toc" style="margin-left:40px;"><a href="#4.%E5%88%97%E8%A1%A8%E6%A0%91%E5%8C%96%E7%9A%84%E9%98%88%E5%80%BC" rel="nofollow">4.列表树化的阈值</a></p> 
<p id="5.%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BD%AC%E5%88%97%E8%A1%A8%E7%9A%84%E9%98%88%E5%80%BC-toc" style="margin-left:40px;"><a href="#5.%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BD%AC%E5%88%97%E8%A1%A8%E7%9A%84%E9%98%88%E5%80%BC" rel="nofollow">5.红黑树转列表的阈值</a></p> 
<p id="6.%E6%A0%91%E5%8C%96%E6%97%B6%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E7%BB%84%E5%AE%B9%E9%87%8F-toc" style="margin-left:40px;"><a href="#6.%E6%A0%91%E5%8C%96%E6%97%B6%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E7%BB%84%E5%AE%B9%E9%87%8F" rel="nofollow">6.树化时的最小数组容量</a></p> 
<p id="%C2%A07.%E5%85%83%E7%B4%A0%E6%95%B0%E7%BB%84%EF%BC%88%E5%AD%98%E6%94%BE%E6%88%91%E4%BB%AC%E6%8F%92%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%89-toc" style="margin-left:40px;"><a href="#%C2%A07.%E5%85%83%E7%B4%A0%E6%95%B0%E7%BB%84%EF%BC%88%E5%AD%98%E6%94%BE%E6%88%91%E4%BB%AC%E6%8F%92%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%89" rel="nofollow"> 7.元素数组（存放我们插入的数据）</a></p> 
<p id="8.%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%88%E5%B9%B6%E9%9D%9E%E5%AE%B9%E9%87%8F%EF%BC%8C%E8%80%8C%E6%98%AF%E5%AE%9E%E9%99%85%E6%94%BE%E4%BA%86%E5%A4%9A%E5%B0%91%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%BB%93%E7%82%B9%E5%88%B0table%E6%95%B0%E7%BB%84%E4%B8%AD%EF%BC%89%C2%A0-toc" style="margin-left:40px;"><a href="#8.%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%88%E5%B9%B6%E9%9D%9E%E5%AE%B9%E9%87%8F%EF%BC%8C%E8%80%8C%E6%98%AF%E5%AE%9E%E9%99%85%E6%94%BE%E4%BA%86%E5%A4%9A%E5%B0%91%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%BB%93%E7%82%B9%E5%88%B0table%E6%95%B0%E7%BB%84%E4%B8%AD%EF%BC%89%C2%A0" rel="nofollow">8.数组的大小（并非容量，而是实际放了多少个数据结点到table数组中） </a></p> 
<p id="9.Node%E7%BB%93%E7%82%B9-toc" style="margin-left:40px;"><a href="#9.Node%E7%BB%93%E7%82%B9" rel="nofollow">9.Node结点</a></p> 
<p id="10.%E6%89%A9%E5%AE%B9%E9%98%88%E5%80%BC-toc" style="margin-left:0px;"><a href="#10.%E6%89%A9%E5%AE%B9%E9%98%88%E5%80%BC" rel="nofollow">10.扩容阈值</a></p> 
<p id="%E4%BA%8C%E3%80%81HashMap%E7%9A%84put%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81HashMap%E7%9A%84put%E6%96%B9%E6%B3%95" rel="nofollow">二、HashMap的put方法</a></p> 
<p id="%E4%B8%89%E3%80%81resize%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81resize%E6%96%B9%E6%B3%95" rel="nofollow">三、resize方法</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p>在Java中，HashMap结构是被经常使用的，在面试当中也是经常会被问到的。这篇文章我给大家分享一下我对于HashMap结构源码的理解。</p> 
<p>HashMap的存储与一般的数组不同，HashMap的每一个元素存储的并不是一个值，而是一个引用类型的Node结点，这也就意味着这个Node结点有被扩充的可能，因为这个Node结点可以是一个链表的Head结点，也可以是一棵树的根节点。</p> 
<p>HashMap的存储数组叫做<strong>table，</strong>也可以称作<strong>“桶”</strong>，试想这样的一个场景：我们在一排放了3个桶，同时我们有4个苹果，如果我们要把所有的苹果放到桶当中，那么必然有一个桶中 的苹果个数&gt;=2。</p> 
<p><img alt="" height="278" src="https://images2.imgbox.com/91/bf/xWCAmFZT_o.png" width="794"></p> 
<p>这种情况在我们的HashMap中也会出现，我们的HashMap结构是把很多的数据存放到一个容量达不到元素个数的数组当中，就如同桶和苹果一样。</p> 
<p>因此我们的HashMap结果会出现上图所示的一种冲突，我们成为<strong>散列冲突</strong>，也叫做<strong>Hash冲突 。</strong></p> 
<p>出现冲突不要怕，解决冲突就是了，我们的一个桶当中可以放两个苹果，自然HashMap的table数组的一个位置也可以存放两个元素。</p> 
<p><span style="color:#fe2c24;"><strong>问题来了，我们现在假设有16个桶，同时间断性的向桶中放苹果，而且还要能够方便我们后续去拿苹果和寻找苹果，那我们这16个桶还够用吗？我们这样子直接把苹果放进桶里，还能够方便我们后续找苹果吗？</strong></span></p> 
<p><span style="color:#0d0016;">行了，解决吧，现在假设你是一位苹果管理员，你该怎么优化一下？你看看这样子行不行，不就是放苹果、找苹果嘛，既然让我来管理，那我希望把苹果平均放到桶当中，每次我放的位置尽量不要和之前的苹果放的位置有冲突，如果桶多的话，你也不能一个一个桶去看吧，所以，我们定义了一个算法，我根据这个苹果的生产ID序列号去寻找对应的桶放进去，如同取余放置一样。这是个不错的思路。但序列号都是有规律的，这样会影响我们的放置，我们希望是一个很随机的结果，因此我们给这个序列号随机变动几个位置后在选择桶。在HashMap中，这样的序列号叫做<strong>hashCode值</strong>，经过一个扰动函数后，我们的到的扰动的值叫做<strong>hash。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>如何存放的问题解决了，但苹果一旦多了还是会产生冲突，一个桶里放8个我还能找得到，但是一个桶里放20个，30个苹果，那我就找不到那个序列号的苹果了。</strong></span></p> 
<p><span style="color:#0d0016;">二叉树我们都学过，倘若我们把桶内的苹果以二叉树的方式进行存储，那这样我们在查找的时候是不是就省了很多时间呢？因此HashMap中的table内的一个元素列表长度＞8的时候，进行树化操作。但也不是非要进行树化的，毕竟树化也要浪费很多资源。当我们的桶的数量&lt;=64的时候，我们不进行树化操作，我们进行数组扩容，把table扩大2倍，这样的话，我们在放苹果的时候发生冲突的概率就会降低。</span>但如果容量已经达到了64，我们就考虑把链表转为红黑树（也是二叉树）了。</p> 
<p>以上的过程不知道你是否理解了没，放苹果的案例和HashMap存储元素的过程相似，现在我们来看代码吧。</p> 
<h2 id="%E4%B8%80%E3%80%81HashMap%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F">一、HashMap中的变量</h2> 
<h3 id="1.%E9%BB%98%E8%AE%A4%E5%AE%B9%E9%87%8F"><strong>1.默认容量</strong></h3> 
<p>HashMap无参构造方法调用时，我们的HashMap数组的初始容量是16。</p> 
<pre><code class="language-java">     /**
     * 默认初始化的容量大小，且必须是2的整数倍
     */
    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</code></pre> 
<h3 id="2.%E6%9C%80%E5%A4%A7%E5%AE%B9%E9%87%8F">2.最大容量</h3> 
<p>记录了我们HashMap所能存储的最大的元素个数。</p> 
<pre><code class="language-java">    /**
     * 我们的元素数组的最大的容量，如果我们设定的最大容量比这个数还大
     * 那我们就把容量设定为这个最大的值
     */
    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</code></pre> 
<h3 id="3.%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90">3.负载因子</h3> 
<p>负载因子决定了HashMap在存储更多数据时如何扩展其容量。默认情况下，当负载因子达到0.75时，HashMap会进行扩容。这意味着，当HashMap中的元素数量达到数组容量的0.75倍时，数组的大小就会翻倍，以便容纳更多的数据。</p> 
<p>为什么选择0.75作为默认的负载因子呢？这并不是随意的选择，而是经过深思熟虑后的优化值。负载因子实际上是一个权衡空间和时间的参数。在理想情况下，如果负载因子为1，这意味着每个索引位置上都有一个键值对存在。然而，当两个或更多的键具有相同的哈希值时，就会发生冲突，这会导致查询效率降低。因此，通过设置一个适当的负载因子，可以平衡键值对的存储效率和查询效率。</p> 
<p>通过将负载因子设置为0.75，可以在空间和时间效率之间取得平衡。这意味着，当数组接近其容量时，HashMap会进行扩容，以避免因哈希冲突而导致的性能下降。同时，这个值也避免了因频繁扩容而产生的额外开销。在大多数情况下，0.75的负载因子可以提供较好的性能。</p> 
<pre><code class="language-java">    /**
     * 如果我们并没有自己初始化一个平衡因子，这个就是默认的平衡因子
     */
    static final float DEFAULT_LOAD_FACTOR = 0.75f;</code></pre> 
<h3 id="4.%E5%88%97%E8%A1%A8%E6%A0%91%E5%8C%96%E7%9A%84%E9%98%88%E5%80%BC">4.列表树化的阈值</h3> 
<pre><code class="language-java">    /**
     * 当列表的长度超过了8，达到9的时候就会把列表转为红黑树
     */
    static final int TREEIFY_THRESHOLD = 8;</code></pre> 
<h3 id="5.%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BD%AC%E5%88%97%E8%A1%A8%E7%9A%84%E9%98%88%E5%80%BC">5.红黑树转列表的阈值</h3> 
<p>一个桶里的苹果往外拿了很多，就那么几个苹果我数的清，用不到树了。</p> 
<pre><code class="language-java">    /**
     * 当树中的结点的个数小于6的时候我们就把红黑树转为列表了
     */
    static final int UNTREEIFY_THRESHOLD = 6;</code></pre> 
<h3 id="6.%E6%A0%91%E5%8C%96%E6%97%B6%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E7%BB%84%E5%AE%B9%E9%87%8F">6.树化时的最小数组容量</h3> 
<pre><code class="language-java">     /**
     * 在我们的列表转为红黑树的时候，如果我们的数组长度（也就是容量）达不到64，那我们就扩充数组
     * 而不是进行红黑树的转化
     **/
    static final int MIN_TREEIFY_CAPACITY = 64;</code></pre> 
<h3 id="%C2%A07.%E5%85%83%E7%B4%A0%E6%95%B0%E7%BB%84%EF%BC%88%E5%AD%98%E6%94%BE%E6%88%91%E4%BB%AC%E6%8F%92%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%89"> 7.元素数组（存放我们插入的数据）</h3> 
<p>这就是我们的桶。</p> 
<pre><code class="language-java">    transient Node&lt;K,V&gt;[] table;</code></pre> 
<h3 id="8.%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%88%E5%B9%B6%E9%9D%9E%E5%AE%B9%E9%87%8F%EF%BC%8C%E8%80%8C%E6%98%AF%E5%AE%9E%E9%99%85%E6%94%BE%E4%BA%86%E5%A4%9A%E5%B0%91%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%BB%93%E7%82%B9%E5%88%B0table%E6%95%B0%E7%BB%84%E4%B8%AD%EF%BC%89%C2%A0">8.数组的大小（并非容量，而是实际放了多少个数据结点到table数组中） </h3> 
<pre><code class="language-java">    /**
     * 此映射中包含的键值映射数。
     */
    transient int size;</code></pre> 
<p>这些变量看完了之后，我们在介绍一个结点类<span style="background-color:#38d8f0;">Node</span>，我们的元素在存储的时候都是这个类型。</p> 
<h3 id="9.Node%E7%BB%93%E7%82%B9">9.Node结点</h3> 
<pre><code class="language-java"> static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
        final int hash; //hash值
        final K key;   //key
        V value;    //value
        Node&lt;K,V&gt; next;    //记录下一个元素
}</code></pre> 
<h2 id="10.%E6%89%A9%E5%AE%B9%E9%98%88%E5%80%BC">10.扩容阈值</h2> 
<p>当table中的元素个数达到了这个值的时候进行resize操作，并非所有node节点的个数，而是我们的一维table中存放元素的个数(存放的链表和树算一个元素)。</p> 
<pre><code class="language-java">    /**
     * table中存放的元素的个数达到了这个值进行resize操作
     */
    int threshold;</code></pre> 
<h2 id="%E4%BA%8C%E3%80%81HashMap%E7%9A%84put%E6%96%B9%E6%B3%95">二、HashMap的put方法</h2> 
<p>我们只以无参构造的HashMap为例。</p> 
<pre><code class="language-java">    HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;();
    map.put("张三",18);</code></pre> 
<p>我们看看这个put方法到底干了些什么。</p> 
<p>我们点进去这个put方法，发现调用的是putVal方法，这个方法有五个参数，第一个参数传入了一个hash方法，第二个就是我们的key，第三个就是value，而后边的两个是默认的boolean类型的值，我们不看后边的两个。</p> 
<pre><code class="language-java">public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }</code></pre> 
<p>hash到底是什么，我们上边其实也讲到过，这是一个扰动函数，意在把我们要插入的这个元素更加随机、均匀的分布到table中。想了解这个过程我们先往下走，到了具体的位置在讲解。</p> 
<p>我们看看这个putVal方法。代码倒是挺多的，不过没关系，你就看我写的注释。</p> 
<pre><code class="language-java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        //这里初始化了一个tab用于保存我们最终的结果  还有一个临时的结点p
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        //这种写法要弄清，=是赋值，==是判断，如果我们的table还没有初始化的话
        if ((tab = table) == null || (n = tab.length) == 0)
            //我们就把这个n记录成我们这个tab初始化后的大小
            n = (tab = resize()).length;
        //这里就是进行位置判断的代码了，如果当前遍历的结点是个空的，我们直接把node放到这个桶里
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else { //如果当前位置不为空
            //定义一个e结点用于遍历
            Node&lt;K,V&gt; e; K k;
            //如果这个结点的key和我们插入元素的key相同，那我们把这个e指向这个结点
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            //但如果不同，而且这个结点还是个树形结点，我们调用专门的方法遍历树
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else {//如果不是树，那就是链表了，我们进行链表遍历去插入我们的新元素
                for (int binCount = 0; ; ++binCount) {
                    //如果我们遍历到的结点已经遍历完了，那我们把元素插入
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        //如果达到了树化阈值，那我们进行树化操作
                        //这里注意一下为什么是-1，因为我们从0开始遍历，当我们达到了7说明
                        已经遍历了8次，同时上边进行了一次插入，结点数达到了9
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    //如果当前结点的key就是我们插入的key，我们不做操作，这是e是有指向的
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            //如果e不是空，就说明找到了一个key相同的结点，我们进行value的替换
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                //替换后就return了，不对table结构做影响
                return oldValue;
            }
        }
        //如果我们对table的结构影响了，我们把这个值+1
        ++modCount;
        //看看把这个值插进去之后，是否达到了扩容阈值，并不是table中元素的长度满了之后才扩容的

        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }</code></pre> 
<p> <img alt="" height="449" src="https://images2.imgbox.com/ad/e9/rigJUppi_o.png" width="1021"></p> 
<p>在上方的代码中你看到了这样的代码。这样代码就是判断我们元素放到哪个位置的。我们用桶的容量去和hash值进行与操作。</p> 
<p></p> 
<pre><code class="language-java">(p = tab[i = (n - 1) &amp; hash</code></pre> 
<p>假设当前容量是16，那么你看一下这个与操作的核心部分是什么，n的前28位都是0，与后的结果也是0，所以真正影响元素位置的只有n的最后四位和元素hashcode的最后四位。结果也一定是0~15。</p> 
<hr> 
<p>h.hashCode = <span style="color:#956fe7;">1101 0111 1011 1100</span> <span style="color:#fe2c24;">0101 1011 1011<strong> </strong></span><strong><span style="color:#956fe7;">1010</span></strong></p> 
<p><span style="color:#0d0016;">n-1               = 0000 0000 0000 0000 0000 0000 0000</span><span style="color:#fe2c24;"> <strong>1111</strong></span></p> 
<hr> 
<p><strong><span style="color:#0d0016;">那么扰动函数的作用是什么呢。我们上边的与操作只算了元素hashcode的后4位，不够随机，我们想要让hashcode的前16位也要影响最后的结果。所以就有了扰动函数。 </span></strong></p> 
<pre><code class="language-java">static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
    }</code></pre> 
<p>h.hashCode             = <span style="color:#956fe7;">1101 0111 1011 1100</span> <span style="color:#fe2c24;">0101 1011 1011<strong> </strong></span><strong><span style="color:#956fe7;">1010</span></strong></p> 
<p>h.hashCode &gt;&gt;&gt;16  = 0000 0000 0000 0000 <span style="color:#956fe7;">1101 0111 1011 1100</span> </p> 
<p>我们取这两个值的与结果，这样我们的hashcode的高位也能扰动我们放的位置。并非单纯的低位和n-1去进行与运算了。</p> 
<p></p> 
<h2 id="%E4%B8%89%E3%80%81resize%E6%96%B9%E6%B3%95">三、resize方法</h2> 
<p>在上边的代码中有个resize方法的调用，这个方法主要的目的是扩容table。这个resize方法看起来还是非常的恐怖哈。</p> 
<p><strong>resize方法解释了为什么数组的容量一定是二的整数倍。</strong></p> 
<pre><code class="language-java">final Node&lt;K,V&gt;[] resize() {
        //记录一下之前的table
        Node&lt;K,V&gt;[] oldTab = table;
        //算一下之前table的容量
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        //记录一下之前table的扩容阈值
        int oldThr = threshold;
        //把新的容量和扩容阈值定义出来
        int newCap, newThr = 0;
        //如果已经进行过初始化了
        if (oldCap &gt; 0) {
            //如果我们之前的空间大小已经达到了最大容量 -- 很少出现
            if (oldCap &gt;= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            //否则的话 我们新的容量等于旧的容量*2  位移运算
            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                //新的扩容阈值也*2
                newThr = oldThr &lt;&lt; 1; // double threshold
        }
        //这个先不说了
        else if (oldThr &gt; 0) // initial capacity was placed in threshold
            newCap = oldThr;
       // 这个else重要啊，如果我们没有进行过初始化，那我们就把新容量定位16 新的扩容阈值定为12
         else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        //如果新的扩容阈值等于0 我们要进行处理等于新的容量×负载因子
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        //修改我们的扩容阈值
        threshold = newThr;
        @SuppressWarnings({"rawtypes","unchecked"})
        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        table = newTab;
        if (oldTab != null) {
            for (int j = 0; j &lt; oldCap; ++j) {
                Node&lt;K,V&gt; e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash &amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                    else { // preserve order
                        Node&lt;K,V&gt; loHead = null, loTail = null;
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;
                        Node&lt;K,V&gt; next;
                        do {
                            next = e.next;
                            if ((e.hash &amp; oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }</code></pre> 
<p>我们分析一下下边的代码。写了注释的直接看看就好，关于树的我不说了，只说链表。</p> 
<pre><code class="language-java">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        table = newTab;
        //如果我们之前的table不为空的话我们要进行一下元素迁移
        if (oldTab != null) {
            for (int j = 0; j &lt; oldCap; ++j) {
                Node&lt;K,V&gt; e;
                //如果当前结点不为空
                if ((e = oldTab[j]) != null) {
                    //清空原来的table中的位置，便于垃圾回收
                    oldTab[j] = null;
                    //如果就一个node 把他搬到新的table中
                    if (e.next == null)
                        newTab[e.hash &amp; (newCap - 1)] = e;
                    //如果是树形结点 调用split方法
                    else if (e instanceof TreeNode)
                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                    //如果是个链表
                    else { // preserve order
                        // 低链表     
                        Node&lt;K,V&gt; loHead = null, loTail = null;
                        //高链表
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;
                        Node&lt;K,V&gt; next;
                        do {
                            next = e.next;
                            //判断这个结点放到高链表或者低链表中
                            if ((e.hash &amp; oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }</code></pre> 
<p></p> 
<p> 什么是高链表和低链表。在之前我们说到过元素是如何定位的，靠的是hash和数组容量-1的与操作。但如果我们数组容量不减1呢？因为我们的数组容量是2的整数倍，如果不减1，那么就说明只有一个位置为1，其他的全为0（假设容量是16）。</p> 
<hr> 
<p>h.hashCode = <span style="color:#956fe7;">1101 0111 1011 1100</span> <span style="color:#fe2c24;">0101 1011 1011<strong> </strong></span><strong><span style="color:#956fe7;">1010</span></strong></p> 
<p><span style="color:#0d0016;">n                  = 0000 0000 0000 0000 0000 0000 0001</span><span style="color:#fe2c24;"> <strong>0000</strong></span></p> 
<hr> 
<p><span style="color:#0d0016;">如同上方的例子，这个元素到底分到哪里，就看这个元素的hash值的倒数第五位，如果是1，就在高链表，如果是0就在低链表。我们通过这样的方式来把元素分到低链表或者高链表当中。</span></p> 
<p>for循环的最后把我们这个临时的低链表和高链表放到我们新的table中。 </p> 
<p><span style="color:#0d0016;">最后将新的table返回。</span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5d51b5690c128f4748a1f0d774a38413/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数据结构-之八大排序(下)，冒泡排序，快速排序，挖坑法，归并排序】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/daff6d67cac9c4099054aef3d1af11f1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C——双向链表</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>