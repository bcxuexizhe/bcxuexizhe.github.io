<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Frida实战：Java、Native、SO层面的Hook与主动调用详解 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/7e1e6ed285d2d392431da4a111326d75/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Frida实战：Java、Native、SO层面的Hook与主动调用详解">
  <meta property="og:description" content="引言 Frida是一款强大的动态代码插桩工具，支持对Android和iOS应用进行实时调试和注入。本文将通过实例详细解析如何在Frida中实现对Java层、Native层（JNI）以及.so库内函数的Hook与主动调用。
一、Hook Java层函数 首先，我们展示如何使用Frida Hook Java层的方法：
Javascript
// 引入Frida的Java API
Java.perform(function () {
// 获取待Hook的目标类
var targetClass = Java.use(‘com.example.target.ClassName’);
// 定义要Hook的方法 targetClass.methodToHook.implementation = function (...args) { console.log(&#34;成功Hook到Java方法: &#34; &#43; this.toString()); console.log(&#34;方法参数: &#34;, args); // 调用原始方法 var originalResult = this.methodToHook.apply(this, args); // 在原始方法执行后添加自定义逻辑 console.log(&#34;方法返回值: &#34;, originalResult); return originalResult; }; });
二、Hook Native层（JNI）函数 接下来，我们演示如何Hook JNI/Native层的函数：
Javascript
// 获取目标so库模块
var libtarget = Module.findExportByName(‘libnative.so’, ‘native_function’);
// 定义Hook逻辑
Interceptor.attach(libtarget, {
onEnter: function (args) {">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-06T16:24:55+08:00">
    <meta property="article:modified_time" content="2024-03-06T16:24:55+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Frida实战：Java、Native、SO层面的Hook与主动调用详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>引言</h2> 
<p>Frida是一款强大的动态代码插桩工具，支持对Android和iOS应用进行实时调试和注入。本文将通过实例详细解析如何在Frida中实现对Java层、Native层（JNI）以及.so库内函数的Hook与主动调用。</p> 
<h3><a id="Hook_Java_4"></a>一、Hook Java层函数</h3> 
<p>首先，我们展示如何使用Frida Hook Java层的方法：</p> 
<p>Javascript<br> // 引入Frida的Java API<br> Java.perform(function () {<!-- --><br> // 获取待Hook的目标类<br> var targetClass = Java.use(‘com.example.target.ClassName’);</p> 
<pre><code>// 定义要Hook的方法
targetClass.methodToHook.implementation = function (...args) {
    console.log("成功Hook到Java方法: " + this.toString());
    console.log("方法参数: ", args);

    // 调用原始方法
    var originalResult = this.methodToHook.apply(this, args);

    // 在原始方法执行后添加自定义逻辑
    console.log("方法返回值: ", originalResult);

    return originalResult;
};
</code></pre> 
<p>});</p> 
<h3><a id="Hook_NativeJNI_27"></a>二、Hook Native层（JNI）函数</h3> 
<p>接下来，我们演示如何Hook JNI/Native层的函数：</p> 
<p>Javascript<br> // 获取目标so库模块<br> var libtarget = Module.findExportByName(‘libnative.so’, ‘native_function’);</p> 
<p>// 定义Hook逻辑<br> Interceptor.attach(libtarget, {<!-- --><br> onEnter: function (args) {<!-- --><br> console.log("成功Hook到Native函数: " + this.name);</p> 
<pre><code>    // 输出传入参数
    for (var i = 0; i &lt; args.length; i++) {
        console.log("参数 " + i + ": 0x" + args[i].toString(16));
    }
},
onLeave(retval) {
    // 输出返回值
    console.log("函数返回值: 0x" + retval.toString(16));

    // 如需修改返回值，可在此处进行
    // retval.replace(newValue);
}
</code></pre> 
<p>});</p> 
<h3><a id="Java_52"></a>三、主动调用Java层函数</h3> 
<p>在Frida中主动调用Java方法如下：</p> 
<p>Javascript<br> Java.perform(function () {<!-- --><br> // 获取目标类并创建实例（如适用）<br> var targetClass = Java.use(‘com.example.target.ClassName’);<br> var instance = targetClass.$new();</p> 
<pre><code>// 定义要调用的方法名及其参数
var methodName = 'methodToCall';
var methodArgs = [param1, param2]; // 根据实际参数填入

// 主动调用Java方法
var result = instance[methodName].apply(instance, methodArgs);
console.log("Java方法调用结果: ", result);
</code></pre> 
<p>});</p> 
<p>// 静态方法调用示例<br> Java.use(‘com.example.target.StaticMethods’).staticMethodToCall(param);</p> 
<h3><a id="JNINativeso_72"></a>四、主动调用JNI/Native层函数与.so库内部函数</h3> 
<p>对于JNI/Native函数以及.so库内部函数的主动调用，可通过创建NativeFunction对象实现：</p> 
<p>Javascript<br> // 获取so库模块并找到函数地址<br> var libnative = Process.getModuleByName(‘libnative.so’);<br> var nativeFuncAddr = libnative.getExportByName(‘nativeMethodName’);</p> 
<p>// 定义NativeFunction结构体以匹配原生函数原型<br> var nativeFunc = new NativeFunction(<br> nativeFuncAddr,<br> ‘int’, // 返回类型<br> [‘int’, ‘string’] // 参数类型列表<br> );</p> 
<p>// 准备参数<br> var arg1 = 123;<br> var arg2 = Memory.allocUtf8String(‘来自Frida的消息’);</p> 
<p>// 主动调用Native函数<br> var nativeResult = nativeFunc(arg1, arg2);<br> console.log('JNI/Native函数调用结果: ', nativeResult);</p> 
<p>// 对于非JNI接口的.so库内部函数调用，原理相同，只需确保获取正确的函数地址和参数类型即可。<br> 总结来说，Frida提供了一种灵活的方式来Hook和调用应用程序在不同层面的函数，这对于逆向工程、安全测试等领域具有很高的实用价值。在实际操作中，请务必根据目标函数的实际签名和环境进行适当调整。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/647fe561661a8c9ee549ba6d4688288b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android Studio Plugin [id: ‘com.android.application‘, version: ‘8.2.2‘, apply: false] was not found</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a96c24027246689a9aca08a61bf01abd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【AI绘画】Stable Diffusion学习——自用大模型分享</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>