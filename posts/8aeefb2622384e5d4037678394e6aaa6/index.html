<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;航海王：追寻罗杰的编程之路】多态你了解多少？ - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/8aeefb2622384e5d4037678394e6aaa6/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【C&#43;&#43;航海王：追寻罗杰的编程之路】多态你了解多少？">
  <meta property="og:description" content="目录
1 -&gt; 多态的概念
1.1 -&gt; 概念
2 -&gt; 多态的定义及实现
2.1 -&gt; 多态的构成条件
2.2 -&gt; 虚函数
2.3 -&gt; 虚函数的重写
2.4 -&gt; C&#43;&#43;11 override和final
2.5 -&gt; 重载、覆盖(重写)、隐藏(重定义)的对比
3 -&gt; 抽象类
3.1 -&gt; 概念
3.2 -&gt; 接口继承和实现继承
4 -&gt; 多态的原理
4.1 -&gt; 虚函数表
4.2 -&gt; 多态的原理
4.3 -&gt; 动态绑定与静态绑定
5 -&gt; 单继承和多继承关系的虚函数表
5.1 -&gt; 单继承中的虚函数表
5.2 -&gt; 多继承中的虚函数表
1 -&gt; 多态的概念 1.1 -&gt; 概念 多态的概念：通俗来说，就是多种形态，具体点就是去完成某个行为，当不同的对象去完成时会产生不同的状态。
比方说买票这个行为，当普通人买票时，是全价票；学生买票时，是半价票；军人买票时，是优先购票。
2 -&gt; 多态的定义及实现 2.1 -&gt; 多态的构成条件 多态是在不同继承关系的类对象，去调用同一函数，产生了不同的行为。比如Student继承了Person。Person对象买票全价，Student对象买票半价。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-01T18:34:59+08:00">
    <meta property="article:modified_time" content="2024-05-01T18:34:59+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;航海王：追寻罗杰的编程之路】多态你了解多少？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><span style="color:#e6b223;"><strong>目录</strong></span></p> 
<p id="1%20-%3E%20%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><strong><a href="#1%20-%3E%20%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow"><span style="color:#e6b223;">1 -&gt; 多态的概念</span></a></strong></p> 
<p id="1.1%20-%3E%20%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><strong><a href="#1.1%20-%3E%20%E6%A6%82%E5%BF%B5" rel="nofollow"><span style="color:#e6b223;">1.1 -&gt; 概念</span></a></strong></p> 
<p id="2%20-%3E%20%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><strong><a href="#2%20-%3E%20%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%AE%9E%E7%8E%B0" rel="nofollow"><span style="color:#e6b223;">2 -&gt; 多态的定义及实现</span></a></strong></p> 
<p id="2.1%20-%3E%20%E5%A4%9A%E6%80%81%E7%9A%84%E6%9E%84%E6%88%90%E6%9D%A1%E4%BB%B6-toc" style="margin-left:40px;"><strong><a href="#2.1%20-%3E%20%E5%A4%9A%E6%80%81%E7%9A%84%E6%9E%84%E6%88%90%E6%9D%A1%E4%BB%B6" rel="nofollow"><span style="color:#e6b223;">2.1 -&gt; 多态的构成条件</span></a></strong></p> 
<p id="2.2%20-%3E%20%E8%99%9A%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><strong><a href="#2.2%20-%3E%20%E8%99%9A%E5%87%BD%E6%95%B0" rel="nofollow"><span style="color:#e6b223;">2.2 -&gt; 虚函数</span></a></strong></p> 
<p id="2.3%20-%3E%20%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E5%86%99-toc" style="margin-left:40px;"><strong><a href="#2.3%20-%3E%20%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E5%86%99" rel="nofollow"><span style="color:#e6b223;">2.3 -&gt; 虚函数的重写</span></a></strong></p> 
<p id="2.4%20-%3E%20C%2B%2B11%20override%E5%92%8Cfinal-toc" style="margin-left:40px;"><strong><a href="#2.4%20-%3E%20C%2B%2B11%20override%E5%92%8Cfinal" rel="nofollow"><span style="color:#e6b223;">2.4 -&gt; C++11 override和final</span></a></strong></p> 
<p id="2.5%20-%3E%20%E9%87%8D%E8%BD%BD%E3%80%81%E8%A6%86%E7%9B%96(%E9%87%8D%E5%86%99)%E3%80%81%E9%9A%90%E8%97%8F(%E9%87%8D%E5%AE%9A%E4%B9%89)%E7%9A%84%E5%AF%B9%E6%AF%94-toc" style="margin-left:40px;"><strong><a href="#2.5%20-%3E%20%E9%87%8D%E8%BD%BD%E3%80%81%E8%A6%86%E7%9B%96%28%E9%87%8D%E5%86%99%29%E3%80%81%E9%9A%90%E8%97%8F%28%E9%87%8D%E5%AE%9A%E4%B9%89%29%E7%9A%84%E5%AF%B9%E6%AF%94" rel="nofollow"><span style="color:#e6b223;">2.5 -&gt; 重载、覆盖(重写)、隐藏(重定义)的对比</span></a></strong></p> 
<p id="3%20-%3E%20%E6%8A%BD%E8%B1%A1%E7%B1%BB-toc" style="margin-left:0px;"><strong><a href="#3%20-%3E%20%E6%8A%BD%E8%B1%A1%E7%B1%BB" rel="nofollow"><span style="color:#e6b223;">3 -&gt; 抽象类</span></a></strong></p> 
<p id="3.1%20-%3E%20%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><strong><a href="#3.1%20-%3E%20%E6%A6%82%E5%BF%B5" rel="nofollow"><span style="color:#e6b223;">3.1 -&gt; 概念</span></a></strong></p> 
<p id="3.2%20-%3E%20%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF-toc" style="margin-left:40px;"><strong><a href="#3.2%20-%3E%20%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF" rel="nofollow"><span style="color:#e6b223;">3.2 -&gt; 接口继承和实现继承</span></a></strong></p> 
<p id="4%20-%3E%20%E5%A4%9A%E6%80%81%E7%9A%84%E5%8E%9F%E7%90%86-toc" style="margin-left:0px;"><strong><a href="#4%20-%3E%20%E5%A4%9A%E6%80%81%E7%9A%84%E5%8E%9F%E7%90%86" rel="nofollow"><span style="color:#e6b223;">4 -&gt; 多态的原理</span></a></strong></p> 
<p id="4.1%20-%3E%20%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8-toc" style="margin-left:40px;"><strong><a href="#4.1%20-%3E%20%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8" rel="nofollow"><span style="color:#e6b223;">4.1 -&gt; 虚函数表</span></a></strong></p> 
<p id="4.2%20-%3E%20%E5%A4%9A%E6%80%81%E7%9A%84%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><strong><a href="#4.2%20-%3E%20%E5%A4%9A%E6%80%81%E7%9A%84%E5%8E%9F%E7%90%86" rel="nofollow"><span style="color:#e6b223;">4.2 -&gt; 多态的原理</span></a></strong></p> 
<p id="4.3%20-%3E%20%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E4%B8%8E%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A-toc" style="margin-left:40px;"><strong><a href="#4.3%20-%3E%20%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E4%B8%8E%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A" rel="nofollow"><span style="color:#e6b223;">4.3 -&gt; 动态绑定与静态绑定</span></a></strong></p> 
<p id="5%20-%3E%20%E5%8D%95%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8-toc" style="margin-left:0px;"><strong><a href="#5%20-%3E%20%E5%8D%95%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8" rel="nofollow"><span style="color:#e6b223;">5 -&gt; 单继承和多继承关系的虚函数表</span></a></strong></p> 
<p id="5.1%20-%3E%20%E5%8D%95%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8-toc" style="margin-left:40px;"><strong><a href="#5.1%20-%3E%20%E5%8D%95%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8" rel="nofollow"><span style="color:#e6b223;">5.1 -&gt; 单继承中的虚函数表</span></a></strong></p> 
<p id="5.2%20-%3E%20%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8-toc" style="margin-left:40px;"><strong><a href="#5.2%20-%3E%20%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8" rel="nofollow"><span style="color:#e6b223;">5.2 -&gt; 多继承中的虚函数表</span></a></strong></p> 
<hr id="hr-toc"> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b3/41/FE5FXx2V_o.jpg"></p> 
<h2 id="1%20-%3E%20%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E5%BF%B5">1 -&gt; 多态的概念</h2> 
<h3 id="1.1%20-%3E%20%E6%A6%82%E5%BF%B5">1.1 -&gt; 概念</h3> 
<p><span style="color:#6eaad7;">多态的概念：通俗来说，就是多种形态，<strong>具体点就是去完成某个行为，当不同的对象去完成时会产生不同的状态。</strong></span></p> 
<p><span style="color:#6eaad7;">比方说买票这个行为，当<strong>普通人</strong>买票时，是全价票；<strong>学生</strong>买票时，是半价票；<strong>军人</strong>买票时，是优先购票。</span></p> 
<h2 id="2%20-%3E%20%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%AE%9E%E7%8E%B0">2 -&gt; 多态的定义及实现</h2> 
<h3 id="2.1%20-%3E%20%E5%A4%9A%E6%80%81%E7%9A%84%E6%9E%84%E6%88%90%E6%9D%A1%E4%BB%B6">2.1 -&gt; 多态的构成条件</h3> 
<p><span style="color:#6eaad7;">多态是在不同继承关系的类对象，去调用同一函数，产生了不同的行为。比如Student继承了Person。Person对象买票全价，Student对象买票半价。</span></p> 
<p><span style="color:#6eaad7;">那么在继承中要<strong>构成多态还有两个条件</strong>：</span></p> 
<ol><li><span style="color:#6eaad7;">必须通过基类的指针或者引用调用虚函数。</span></li><li><span style="color:#6eaad7;">被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写。</span></li></ol> 
<p class="img-center"><img alt="" height="468" src="https://images2.imgbox.com/8a/77/2LzYxIF2_o.png" width="764"></p> 
<h3 id="2.2%20-%3E%20%E8%99%9A%E5%87%BD%E6%95%B0">2.2 -&gt; 虚函数</h3> 
<p><span style="color:#6eaad7;">虚函数：即被virtual修饰的类成员函数称为虚函数。</span></p> 
<pre><code class="hljs">#define  _CRT_SECURE_NO_WARNINGS 1

#include &lt;iostream&gt;
using namespace std;

class Person 
{
public:
	virtual void BuyTicket() 
	{ 
		cout &lt;&lt; "买票-全价" &lt;&lt; endl; 
	}
};</code></pre> 
<h3 id="2.3%20-%3E%20%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E5%86%99">2.3 -&gt; 虚函数的重写</h3> 
<p><span style="color:#6eaad7;">虚函数的重写(覆盖)：<strong>派生类中有一个跟基类完全相同的虚函数(即派生类虚函数与基类虚函数的返回值类型、函数名字、参数列表完全相同)</strong>，称子类的虚函数重写了基类的虚函数。</span></p> 
<pre><code class="hljs">#define  _CRT_SECURE_NO_WARNINGS 1

#include &lt;iostream&gt;
using namespace std;

class Person
{
public:
	virtual void BuyTicket()
	{
		cout &lt;&lt; "买票-全价" &lt;&lt; endl;
	}
};

class Student : public Person
{
public:
	virtual void BuyTicket()
	{
		cout &lt;&lt; "买票-半价" &lt;&lt; endl;
	}

	/*注意：在重写基类虚函数时，派生类的虚函数在不加virtual关键字时，虽然也可以构成重写(因
	为继承后基类的虚函数被继承下来了在派生类依旧保持虚函数属性),但是该种写法不是很规范，不建议
	这样使用*/
	/*void BuyTicket() { cout &lt;&lt; "买票-半价" &lt;&lt; endl; }*/
};

void Func(Person&amp; p)
{
	p.BuyTicket();
}

int main()
{
	Person ps;
	Student st;

	Func(ps);
	Func(st);

	return 0;
}</code></pre> 
<p><span style="color:#6eaad7;"><strong>虚函数重写的两个例外：</strong></span></p> 
<p><span style="color:#6eaad7;"><strong>1. 协变(基类与派生类虚函数返回值类型不同)</strong></span></p> 
<p><span style="color:#6eaad7;">派生类重写基类虚函数时，与基类函数返回值类型不同。即基类虚函数返回基类对象的指针或引用，派生类虚函数返回派生类对象的指针或引用时，称为协变。</span></p> 
<pre><code class="hljs">class A {};

class B : public A {};

class Person 
{
public:
	virtual A* f() 
	{ 
		return new A; 
	}
};

class Student : public Person 
{
public:
	virtual B* f() 
	{ 
		return new B; 
	}
};</code></pre> 
<p><span style="color:#6eaad7;"><strong>2. 析构函数的重写(基类与派生类析构函数的名字不同)</strong></span></p> 
<p><span style="color:#6eaad7;">如果基类的析构函数为虚函数，此时派生类析构函数只要定义，无论是否加virtual关键字，都与基类的析构函数构成重写，虽然基类与派生类析构函数名字不同。看起来违背了重写规则，其实不然，这里可以理解为编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成destructor。</span></p> 
<pre><code class="hljs">class Person 
{
public:
	virtual ~Person() 
	{ 
		cout &lt;&lt; "~Person()" &lt;&lt; endl; 
	}
};

class Student : public Person 
{
public:
	virtual ~Student() 
	{ 
		cout &lt;&lt; "~Student()" &lt;&lt; endl; 
	}
};

// 只有派生类Student的析构函数重写了Person的析构函数，下面的delete对象调用析构函
// 数，才能构成多态，才能保证p1和p2指向的对象正确的调用析构函数。
int main()
{
	Person* p1 = new Person;
	Person* p2 = new Student;

	delete p1;
	delete p2;

	return 0;
}
</code></pre> 
<h3 id="2.4%20-%3E%20C%2B%2B11%20override%E5%92%8Cfinal">2.4 -&gt; C++11 override和final</h3> 
<p><span style="color:#6eaad7;">从上面可以看出，C++对函数重写的要求比较严格，但是有些情况下由于疏忽，可能会导致函数名字母次序写反而无法构成重载，而这种错误在编译期间是不会报出的，只有在程序运行时没有得到预期结果才来debug会得不偿失。因此：C++11提供了override和final两个关键字，可以帮助用户检测是否重写。</span></p> 
<p><span style="color:#6eaad7;"><strong>1. final：修饰虚函数，表示该虚函数不能再被重写</strong></span></p> 
<pre><code class="hljs">class Car
{
public:
	virtual void Drive() final {}
};

class Benz :public Car
{
public:
	virtual void Drive() 
	{ 
		cout &lt;&lt; "Benz-舒适" &lt;&lt; endl; 
	}
};</code></pre> 
<p class="img-center"><img alt="" height="51" src="https://images2.imgbox.com/3e/ff/MSJXjQxw_o.png" width="649"></p> 
<p><span style="color:#6eaad7;"><strong>2. override：检查派生类虚函数是否重写了基类某个虚函数，如果没有重写编译报错。</strong></span></p> 
<pre><code class="hljs">class Car 
{
public:
	virtual void Drive() {}
};

class Benz :public Car 
{
public:
	virtual void Drive() override 
	{ 
		cout &lt;&lt; "Benz-舒适" &lt;&lt; endl; 
	}
};</code></pre> 
<h3 id="2.5%20-%3E%20%E9%87%8D%E8%BD%BD%E3%80%81%E8%A6%86%E7%9B%96(%E9%87%8D%E5%86%99)%E3%80%81%E9%9A%90%E8%97%8F(%E9%87%8D%E5%AE%9A%E4%B9%89)%E7%9A%84%E5%AF%B9%E6%AF%94">2.5 -&gt; 重载、覆盖(重写)、隐藏(重定义)的对比</h3> 
<p class="img-center"><img alt="" height="404" src="https://images2.imgbox.com/b6/c0/mtaTOFyV_o.png" width="915"></p> 
<h2 id="3%20-%3E%20%E6%8A%BD%E8%B1%A1%E7%B1%BB">3 -&gt; 抽象类</h2> 
<h3 id="3.1%20-%3E%20%E6%A6%82%E5%BF%B5">3.1 -&gt; 概念</h3> 
<p><span style="color:#6eaad7;">在虚函数的后面写上 = 0，则这个函数为纯虚函数。<strong>包含纯虚函数的类叫做抽象类(也叫接口类)，抽象类不能实例化出对象。</strong>派生类继承后也不能实例化出对象，只有重写纯虚函数，派生类才能实例化出对象。纯虚函数规范了派生类必须重写，另外纯虚函数更体现出了接口继承。</span></p> 
<pre><code class="hljs">class Car
{
public:
	virtual void Drive() = 0;
};

class Benz :public Car
{
public:
	virtual void Drive()
	{
		cout &lt;&lt; "Benz-舒适" &lt;&lt; endl;
	}
};

class BMW :public Car
{
public:
	virtual void Drive()
	{
		cout &lt;&lt; "BMW-操控" &lt;&lt; endl;
	}
};

void Test()
{
	Car* pBenz = new Benz;
	pBenz-&gt;Drive();

	Car* pBMW = new BMW;
	pBMW-&gt;Drive();
}

int main()
{

	Test();

	return 0;
}
</code></pre> 
<h3 id="3.2%20-%3E%20%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF">3.2 -&gt; 接口继承和实现继承</h3> 
<p><span style="color:#6eaad7;">普通函数的继承是一种实现继承，派生类继承了基类函数，可以使用函数，继承的是函数的实现。虚函数的继承是一种接口继承，派生类继承的是基类虚函数的接口，目的是为了重写，达成多态，继承的是接口。所以如果不实现多态，不要把函数定义成虚函数。</span></p> 
<h2 id="4%20-%3E%20%E5%A4%9A%E6%80%81%E7%9A%84%E5%8E%9F%E7%90%86">4 -&gt; 多态的原理</h2> 
<h3 id="4.1%20-%3E%20%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8">4.1 -&gt; 虚函数表</h3> 
<pre><code class="hljs">// 这里常考一道笔试题：sizeof(Base)是多少？
class Base
{
public:
	virtual void Func1()
	{
		cout &lt;&lt; "Func1()" &lt;&lt; endl;
	}

private:
	int _b = 1;
};</code></pre> 
<p><span style="color:#6eaad7;">通过观察测试我们发现b对象是8bytes，除了_b成员，还多一个__vfptr放在对象的前面(注意有些<br> 平台可能会放到对象的最后面，这个跟平台有关)，对象中的这个指针我们叫做虚函数表指针(v代<br> 表virtual，f代表function)。一个含有虚函数的类中都至少都有一个虚函数表指针，因为虚函数<br> 的地址要被放到虚函数表中，虚函数表也简称虚表，。那么派生类中这个表放了些什么呢？我们<br> 接着往下分析。</span></p> 
<p><img alt="" height="159" src="https://images2.imgbox.com/dc/09/OWGKQ6Tt_o.png" width="769"></p> 
<pre><code class="hljs">// 针对上面的代码我们做出以下改造
// 1.我们增加一个派生类Derive去继承Base
// 2.Derive中重写Func1
// 3.Base再增加一个虚函数Func2和一个普通函数Func3
class Base
{
public:
	virtual void Func1()
	{
		cout &lt;&lt; "Base::Func1()" &lt;&lt; endl;
	}

	virtual void Func2()
	{
		cout &lt;&lt; "Base::Func2()" &lt;&lt; endl;
	}

	void Func3()
	{
		cout &lt;&lt; "Base::Func3()" &lt;&lt; endl;
	}

private:
	int _b = 1;
};

class Derive : public Base
{
public:
	virtual void Func1()
	{
		cout &lt;&lt; "Derive::Func1()" &lt;&lt; endl;
	}
private:
	int _d = 2;
};

int main()
{
	Base b;
	Derive d;

	return 0;
}</code></pre> 
<p><span style="color:#6eaad7;">通过观察和测试，我们发现了以下几点问题：</span></p> 
<ol><li><span style="color:#6eaad7;">派生类对象d中也有一个虚表指针，d对象由两部分构成，一部分是父类继承下来的成员，虚<br> 表指针也就是存在部分的另一部分是自己的成员。</span></li><li><span style="color:#6eaad7;">基类b对象和派生类d对象虚表是不一样的，这里我们发现<strong>Func1完成了重写，所以d的虚表<br> 中存的是重写的Derive::Func1，所以虚函数的重写也叫作覆盖</strong>，覆盖就是指虚表中虚函数<br> 的覆盖。重写是语法的叫法，覆盖是原理层的叫法。</span></li><li><span style="color:#6eaad7;">另外Func2继承下来后是虚函数，所以放进了虚表，Func3也继承下来了，但是不是虚函<br> 数，所以不会放进虚表。</span></li><li><span style="color:#6eaad7;">虚函数表本质是一个存虚函数指针的指针数组，一般情况这个数组最后面放了一个nullptr。</span></li><li><span style="color:#6eaad7;">总结一下派生类的虚表生成：a.先将基类中的虚表内容拷贝一份到派生类虚表中 b.如果派生<br> 类重写了基类中某个虚函数，用派生类自己的虚函数覆盖虚表中基类的虚函数 c.派生类自己<br> 新增加的虚函数按其在派生类中的声明次序增加到派生类虚表的最后。</span></li><li><span style="color:#6eaad7;">这里还有一个童鞋们很容易混淆的问题：<strong>虚函数存在哪的？虚表存在哪的？ 答：虚函数存在<br> 虚表，虚表存在对象中。注意上面的回答的错的。</strong>但是很多童鞋都是这样深以为然的。注意<br><strong>虚表存的是虚函数指针，不是虚函数</strong>，虚函数和普通函数一样的，都是存在代码段的，只是<br> 他的指针又存到了虚表中。另外对象中存的不是虚表，存的是虚表指针。</span></li></ol> 
<h3 id="4.2%20-%3E%20%E5%A4%9A%E6%80%81%E7%9A%84%E5%8E%9F%E7%90%86">4.2 -&gt; 多态的原理</h3> 
<p><span style="color:#6eaad7;">上面分析了这么多，那么多态的原理到底是什么呢？这里Func函数传Person调用的Person::BuyTicket，传Student调用的是Student::BuyTicket</span></p> 
<p class="img-center"><img alt="" height="468" src="https://images2.imgbox.com/22/36/6mnDv29k_o.png" width="764"></p> 
<pre><code class="hljs">class Person 
{
public:
	virtual void BuyTicket() 
	{ 
		cout &lt;&lt; "买票-全价" &lt;&lt; endl; 
	}
};

class Student : public Person 
{
public:
	virtual void BuyTicket() 
	{ 
		cout &lt;&lt; "买票-半价" &lt;&lt; endl; 
	}
};

void Func(Person&amp; p)
{
	p.BuyTicket();
}

int main()
{
	Person Mike;
	Func(Mike);

	Student Johnson;
	Func(Johnson);

	return 0;
}</code></pre> 
<ol><li><span style="color:#6eaad7;"> 观察下图的红色箭头我们看到，p是指向mike对象时，p-&gt;BuyTicket在mike的虚表中找到虚<br> 函数是Person::BuyTicket。</span></li><li><span style="color:#6eaad7;">观察下图的蓝色箭头我们看到，p是指向johnson对象时，p-&gt;BuyTicket在johson的虚表中<br> 找到虚函数是Student::BuyTicket。</span></li><li><span style="color:#6eaad7;">这样就实现出了不同对象去完成同一行为时，展现出不同的形态。</span></li><li><span style="color:#6eaad7;">反过来思考我们要达到多态，有两个条件，一个是虚函数覆盖，一个是对象的指针或引用调<br> 用虚函数。反思一下为什么？</span></li><li> <p><span style="color:#6eaad7;">再通过下面的汇编代码分析，<strong>看出满足多态以后的函数调用，不是在编译时确定的，是运行<br> 起来以后到对象的中取找的。不满足多态的函数调用时编译时确认好的。</strong></span></p> <p class="img-center"><img alt="" height="282" src="https://images2.imgbox.com/16/c3/ocIQ7WGE_o.png" width="781"></p> </li></ol> 
<pre><code class="hljs">void Func(Person* p)
{
 p-&gt;BuyTicket();
}
int main()
{
 Person mike;
 Func(&amp;mike);
 mike.BuyTicket();
    
 return 0;
}
// 以下汇编代码中跟你这个问题不相关的都被去掉了
void Func(Person* p)
{
...
 p-&gt;BuyTicket();
// p中存的是mike对象的指针，将p移动到eax中
001940DE  mov         eax,dword ptr [p]
// [eax]就是取eax值指向的内容，这里相当于把mike对象头4个字节(虚表指针)移动到了edx
001940E1  mov         edx,dword ptr [eax]
// [edx]就是取edx值指向的内容，这里相当于把虚表中的头4字节存的虚函数指针移动到了eax
00B823EE  mov         eax,dword ptr [edx]
// call eax中存虚函数的指针。这里可以看出满足多态的调用，不是在编译时确定的，是运行起来
以后到对象的中取找的。
001940EA  call        eax  
00头1940EC  cmp         esi,esp  
}
int main()
{
... 
// 首先BuyTicket虽然是虚函数，但是mike是对象，不满足多态的条件，所以这里是普通函数的调
用转换成地址时，是在编译时已经从符号表确认了函数的地址，直接call 地址
 mike.BuyTicket();
00195182  lea         ecx,[mike]
00195185  call        Person::BuyTicket (01914F6h)  
... 
}</code></pre> 
<h3 id="4.3%20-%3E%20%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E4%B8%8E%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A">4.3 -&gt; 动态绑定与静态绑定</h3> 
<ol><li><span style="color:#6eaad7;">静态绑定又称为前期绑定(早绑定)，<strong>在程序编译期间确定了程序的行为，也称为静态多态，<br> 比如：函数重载。</strong></span></li><li><span style="color:#6eaad7;">动态绑定又称后期绑定(晚绑定)，是在程序运行期间，根据具体拿到的类型确定程序的具体<br> 行为，调用具体的函数，<strong>也称为动态多态。</strong></span></li></ol> 
<h2 id="5%20-%3E%20%E5%8D%95%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8">5 -&gt; 单继承和多继承关系的虚函数表</h2> 
<p><span style="color:#6eaad7;">需要注意的是在单继承和多继承关系中，下面我们去关注的是派生类对象的虚表模型，因为基类<br> 的虚表模型前面我们已经看过了，没什么需要特别研究的。</span></p> 
<h3 id="5.1%20-%3E%20%E5%8D%95%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8">5.1 -&gt; 单继承中的虚函数表</h3> 
<pre><code class="hljs">class Base 
{
public:
	virtual void func1() 
	{ 
		cout &lt;&lt; "Base::func1" &lt;&lt; endl; 
	}

	virtual void func2() 
	{
		cout &lt;&lt; "Base::func2" &lt;&lt; endl; 
	}

private:
	int a;
};

class Derive :public Base 
{
public:
	virtual void func1() 
	{ 
		cout &lt;&lt; "Derive::func1" &lt;&lt; endl; 
	}

	virtual void func3() 
	{
		cout &lt;&lt; "Derive::func3" &lt;&lt; endl;
	}

	virtual void func4() 
	{ 
		cout &lt;&lt; "Derive::func4" &lt;&lt; endl; 
	}

private:
	int b;
};</code></pre> 
<p><span style="color:#6eaad7;">观察下图中的监视窗口中我们发现看不见func3和func4。这里是编译器的监视窗口故意隐藏了这<br> 两个函数，也可以认为是他的一个小bug。那么我们如何查看d的虚表呢？下面我们使用代码打印<br> 出虚表中的函数。</span></p> 
<p class="img-center"><img alt="" height="277" src="https://images2.imgbox.com/e0/97/5Gb0Q4Tf_o.png" width="752"></p> 
<pre><code class="hljs">typedef void(*VFPTR) ();

void PrintVTable(VFPTR vTable[])
{
	// 依次取虚表中的虚函数指针打印并调用。调用就可以看出存的是哪个函数
	cout &lt;&lt; " 虚表地址&gt;" &lt;&lt; vTable &lt;&lt; endl;
	for (int i = 0; vTable[i] != nullptr; ++i)
	{
		printf(" 第%d个虚函数地址 :0X%x,-&gt;", i, vTable[i]);

		VFPTR f = vTable[i];
		f();
	}

	cout &lt;&lt; endl;
}

int main()
{
	Base b;
	Derive d;
	// 思路：取出b、d对象的头4bytes，就是虚表的指针，前面我们说了虚函数表本质是一个存虚函数指针的指针数组，这个数组最后面放了一个nullptr
		// 1.先取b的地址，强转成一个int*的指针
		// 2.再解引用取值，就取到了b对象头4bytes的值，这个值就是指向虚表的指针
		// 3.再强转成VFPTR*，因为虚表就是一个存VFPTR类型(虚函数指针类型)的数组。
		// 4.虚表指针传递给PrintVTable进行打印虚表
		// 5.需要说明的是这个打印虚表的代码经常会崩溃，因为编译器有时对虚表的处理不干净，虚表最
		//后面没有放nullptr，导致越界，这是编译器的问题。我们只需要点目录栏的 - 生成 - 清理解决方案，再编译就好了。
	VFPTR * vTableb = (VFPTR*)(*(int*)&amp;b);
	PrintVTable(vTableb);

	VFPTR* vTabled = (VFPTR*)(*(int*)&amp;d);
	PrintVTable(vTabled);

	return 0;
}</code></pre> 
<p><img alt="" height="377" src="https://images2.imgbox.com/01/9e/neIF29Fp_o.png" width="775"></p> 
<h3 id="5.2%20-%3E%20%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8">5.2 -&gt; 多继承中的虚函数表</h3> 
<pre><code class="hljs">class Base1 
{
public:
	virtual void func1() 
	{ 
		cout &lt;&lt; "Base1::func1" &lt;&lt; endl; 
	}

	virtual void func2() 
	{ 
		cout &lt;&lt; "Base1::func2" &lt;&lt; endl; 
	}

private:
	int b1;
};

class Base2 
{
public:
	virtual void func1() 
	{ 
		cout &lt;&lt; "Base2::func1" &lt;&lt; endl; 
	}

	virtual void func2() 
	{ 
		cout &lt;&lt; "Base2::func2" &lt;&lt; endl;
	}

private:
	int b2;
};

class Derive : public Base1, public Base2 
{
public:
	virtual void func1() 
	{ 
		cout &lt;&lt; "Derive::func1" &lt;&lt; endl; 
	}

	virtual void func3() 
	{
		cout &lt;&lt; "Derive::func3" &lt;&lt; endl; 
	}

private:
	int d1;
};

typedef void(*VFPTR) ();

void PrintVTable(VFPTR vTable[])
{
	cout &lt;&lt; " 虚表地址&gt;" &lt;&lt; vTable &lt;&lt; endl;
	for (int i = 0; vTable[i] != nullptr; ++i)
	{
		printf(" 第%d个虚函数地址 :0X%x,-&gt;", i, vTable[i]);

		VFPTR f = vTable[i];
		f();
	}

	cout &lt;&lt; endl;
}

int main()
{
	Derive d;

	VFPTR* vTableb1 = (VFPTR*)(*(int*)&amp;d);
	PrintVTable(vTableb1);

	VFPTR* vTableb2 = (VFPTR*)(*(int*)((char*)&amp;d + sizeof(Base1)));
	PrintVTable(vTableb2);

	return 0;
}</code></pre> 
<p><span style="color:#6eaad7;"><strong>观察下图可以看出：多继承派生类的未重写的虚函数放在第一个继承基类部分的虚函数表中。</strong></span></p> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/4b/0b/7Stl2mxh_o.png" width="783"></p> 
<hr> 
<p></p> 
<p></p> 
<p style="text-align:center;"><span style="color:#511b78;"><strong>感谢各位大佬支持！！！</strong></span></p> 
<p style="text-align:center;"><span style="color:#511b78;"><strong>互三啦！！！</strong></span></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/50e2cee85873eeeb28c0cdaa60b6a8de/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AI家居设备的未来：智能家庭的下一个大步</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/506c7bf5b6f783238a693b33ff2569a6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">spring的常用注解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>