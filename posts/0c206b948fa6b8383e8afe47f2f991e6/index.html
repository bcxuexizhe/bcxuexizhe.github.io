<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 【数据结构】 二叉树（Binary_Tree）【神装】 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/0c206b948fa6b8383e8afe47f2f991e6/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Java 【数据结构】 二叉树（Binary_Tree）【神装】">
  <meta property="og:description" content="登神长阶
第五神装 二叉树 Binary-Tree
目录
🎷一.树形结构
🪗1.概念
🎸2.具体应用
🎹 二.二叉树（Binary Tree）
🎺1.概念
🎻2.表现形式
🪕3.特殊类型
🥁3.1完全二叉树（Complete Binary Tree）
🪘3.2满二叉树（Full Binary Tree）
🔋4.性质 🪫5.二叉树的遍历
💿5.1前中后序遍历
📀 5.2层序遍历
🔎 三.总结与反思
🎷一.树形结构 🪗1.概念 树形结构是一种在Java中常见的数据结构，它由节点（node）组成，这些节点之间以分支（branch）相连的方式形成层次关系。树形结构中通常包含一个根节点（root node），以及每个节点可能有零个或多个子节点（child nodes）。每个节点可以有一个父节点（parent node），除了根节点，它没有父节点。
在Java中，树形结构通常通过类和对象来表示。每个节点可以是一个类的实例，这个类通常包含一个指向父节点的引用和一个指向子节点的引用。通过这些引用，可以在树形结构中导航和操作节点。
树形结构在计算机科学中有广泛的应用，例如在文件系统中用于表示文件和文件夹的层次结构，在数据库中用于表示层次化数据，以及在图形用户界面（GUI）中用于构建菜单和组织UI元素等。
注意：树形结构中，子树之间不能有交集，否则就不是树形结构 🎸2.具体应用 树形结构在计算机科学和软件工程中有着广泛的应用，以下是一些常见的应用场景：
文件系统
文件系统通常以树形结构的形式来组织文件和目录，每个目录可以包含零个或多个子目录和文件，形成层次化的结构。这种结构使得用户可以方便地组织和管理文件。 数据库
在数据库中，树形结构常用于表示层次化数据，例如组织结构、产品分类、论坛板块等。通过树形结构，可以方便地进行数据检索、添加、删除和更新操作，同时保持数据的层次关系。 图形用户界面（GUI）
GUI 应用程序中经常使用树形结构来构建菜单、导航栏和组织 UI 元素。例如，文件资源管理器中的目录树、网站导航菜单等都是树形结构的应用。 编程语言中的抽象语法树（AST）
在编译器和解释器中，树形结构被用来表示源代码的抽象语法结构。抽象语法树（AST）将源代码表示为树的形式，每个节点代表源代码中的一个语法结构，如表达式、语句、函数等，方便进行语法分析和程序转换。 网络路由与拓扑排序
在网络领域，树形结构可以用于路由算法的实现，例如通过构建路由表来确定数据包的传输路径。此外，在计算机网络的拓扑结构中，也可以使用树形结构来表示网络节点之间的关系，进行拓扑排序和数据传输优化。 树形结构的应用不仅局限于以上几个领域，还涵盖了许多其他领域，如人工智能、游戏开发、数据可视化等。其灵活性和可扩展性使得树形结构成为解决各种复杂问题的有力工具。
🎹 二.二叉树（Binary Tree） 🎺1.概念 二叉树是树形结构中最常见的一种，具有以下基本概念：
结点的度：一个结点含有子树的个数称为该结点的度； 如上图：A的度为6 树的度：一棵树中，所有结点度的最大值称为树的度； 如上图：树的度为6 叶子结点或终端结点：度为0的结点称为叶结点； 如上图：B、C、H、I...等节点为叶结点 双亲结点或父结点：若一个结点含有子结点，则这个结点称为其子结点的父结点； 如上图：A是B的父结点 孩子结点或子结点：一个结点含有的子树的根结点称为该结点的子结点； 如上图：B是A的孩子结点 根结点：一棵树中，没有双亲结点的结点；如上图：A 结点的层次：从根开始定义起，根为第1层，根的子结点为第2层，以此类推树的高度或深度：树中结点的最大层次； 如上图：树的高度为4 树的以下概念只需了解，在看书时只要知道是什么意思即可： 非终端结点或分支结点：度不为0的结点； 如上图：D、E、F、G.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-23T21:30:12+08:00">
    <meta property="article:modified_time" content="2024-04-23T21:30:12+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 【数据结构】 二叉树（Binary_Tree）【神装】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<p class="img-center"><img alt="" height="140" src="https://images2.imgbox.com/09/c8/LxDJOYt0_o.png" width="407"></p> 
<p class="img-center"><img alt="" height="80" src="https://images2.imgbox.com/58/f0/6K24Nqr4_o.png" width="640"></p> 
<p style="text-align:center;"> <strong>登神长阶</strong></p> 
<p style="text-align:center;"><strong> 第五神装 二叉树 Binary-Tree</strong></p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%C2%A0%F0%9F%8E%B7%E4%B8%80.%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#%C2%A0%F0%9F%8E%B7%E4%B8%80.%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84" rel="nofollow"> 🎷一.树形结构</a></p> 
<p id="%F0%9F%AA%971.%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%F0%9F%AA%971.%E6%A6%82%E5%BF%B5" rel="nofollow">🪗1.概念</a></p> 
<p id="%F0%9F%8E%B82.%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8-toc" style="margin-left:40px;"><a href="#%F0%9F%8E%B82.%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8" rel="nofollow">🎸2.具体应用</a></p> 
<p id="%F0%9F%8E%B9%C2%A0%E4%BA%8C.%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Binary%20Tree%EF%BC%89-toc" style="margin-left:0px;"><a href="#%F0%9F%8E%B9%C2%A0%E4%BA%8C.%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Binary%20Tree%EF%BC%89" rel="nofollow">🎹 二.二叉树（Binary Tree）</a></p> 
<p id="%F0%9F%8E%BA1.%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%F0%9F%8E%BA1.%E6%A6%82%E5%BF%B5" rel="nofollow">🎺1.概念</a></p> 
<p id="%C2%A0%F0%9F%8E%BB2.%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%C2%A0%F0%9F%8E%BB2.%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F" rel="nofollow"> 🎻2.表现形式</a></p> 
<p id="%F0%9F%AA%953.%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#%F0%9F%AA%953.%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B" rel="nofollow">🪕3.特殊类型</a></p> 
<p id="%F0%9F%A5%813.1%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Complete%20Binary%20Tree%EF%BC%89-toc" style="margin-left:80px;"><a href="#%F0%9F%A5%813.1%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Complete%20Binary%20Tree%EF%BC%89" rel="nofollow">🥁3.1完全二叉树（Complete Binary Tree）</a></p> 
<p id="%F0%9F%AA%983.2%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Full%20Binary%20Tree%EF%BC%89-toc" style="margin-left:80px;"><a href="#%F0%9F%AA%983.2%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Full%20Binary%20Tree%EF%BC%89" rel="nofollow">🪘3.2满二叉树（Full Binary Tree）</a></p> 
<p id="%F0%9F%94%8B4.%E6%80%A7%E8%B4%A8%C2%A0-toc" style="margin-left:40px;"><a href="#%F0%9F%94%8B4.%E6%80%A7%E8%B4%A8%C2%A0" rel="nofollow">🔋4.性质 </a></p> 
<p id="%F0%9F%AA%AB5.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#%F0%9F%AA%AB5.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86" rel="nofollow">🪫5.二叉树的遍历</a></p> 
<p id="%F0%9F%92%BF5.1%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:80px;"><a href="#%F0%9F%92%BF5.1%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow">💿5.1前中后序遍历</a></p> 
<p id="%C2%A0-toc" style="margin-left:40px;"><a href="#%C2%A0" rel="nofollow"> </a></p> 
<p id="%F0%9F%93%80%C2%A05.2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:80px;"><a href="#%F0%9F%93%80%C2%A05.2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow">📀 5.2层序遍历</a></p> 
<p id="%F0%9F%94%8E%C2%A0%E4%B8%89.%E6%80%BB%E7%BB%93%E4%B8%8E%E5%8F%8D%E6%80%9D-toc" style="margin-left:0px;"><a href="#%F0%9F%94%8E%C2%A0%E4%B8%89.%E6%80%BB%E7%BB%93%E4%B8%8E%E5%8F%8D%E6%80%9D" rel="nofollow">🔎 三.总结与反思</a></p> 
<hr> 
<h2 id="%C2%A0%F0%9F%8E%B7%E4%B8%80.%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84" style="background-color:transparent;"> 🎷一.树形结构</h2> 
<h3 id="%F0%9F%AA%971.%E6%A6%82%E5%BF%B5">🪗1.概念</h3> 
<p>        树形结构是一种在Java中常见的数据结构，它由<strong>节点（node）</strong>组成，这些节点之间以<strong>分支（branch）</strong>相连的方式形成层次关系。树形结构中通常包含一个<strong>根节点（root node）</strong>，以及每个节点可能有零个或多个<strong>子节点（child nodes）</strong>。每个节点可以有一个<strong>父节点（parent node）</strong>，除了根节点，它没有父节点。</p> 
<p>        在Java中，树形结构通常通过类和对象来表示。每个节点可以是一个类的实例，这个类通常包含一个指向父节点的引用和一个指向子节点的引用。通过这些引用，可以在树形结构中导航和操作节点。</p> 
<p>        树形结构在计算机科学中有广泛的应用，例如在文件系统中用于表示文件和文件夹的层次结构，在数据库中用于表示层次化数据，以及在图形用户界面（GUI）中用于构建菜单和组织UI元素等。</p> 
<p class="img-center"><img alt="" height="354" src="https://images2.imgbox.com/7d/28/fwkXDFMn_o.png" width="442"></p> 
<blockquote> 
 <p> <span style="color:#333333;"><strong>注意：树形结构中，子树之间不能有交集，否则就不是树形结构 </strong></span></p> 
</blockquote> 
<p class="img-center"><img alt="" height="416" src="https://images2.imgbox.com/8a/e7/iaz9e0Yi_o.png" width="536"></p> 
<h3 id="%F0%9F%8E%B82.%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8" style="background-color:transparent;">🎸2.具体应用</h3> 
<p>树形结构在计算机科学和软件工程中有着广泛的应用，以下是一些常见的应用场景：</p> 
<p><strong>文件系统</strong></p> 
<ul><li>文件系统通常以树形结构的形式来组织文件和目录，每个目录可以包含零个或多个子目录和文件，形成层次化的结构。这种结构使得用户可以方便地组织和管理文件。</li></ul> 
<p><strong>数据库</strong></p> 
<ul><li>在数据库中，树形结构常用于表示层次化数据，例如组织结构、产品分类、论坛板块等。通过树形结构，可以方便地进行数据检索、添加、删除和更新操作，同时保持数据的层次关系。</li></ul> 
<p><strong>图形用户界面（GUI）</strong></p> 
<ul><li>GUI 应用程序中经常使用树形结构来构建菜单、导航栏和组织 UI 元素。例如，文件资源管理器中的目录树、网站导航菜单等都是树形结构的应用。</li></ul> 
<p><strong>编程语言中的抽象语法树（AST）</strong></p> 
<ul><li>在编译器和解释器中，树形结构被用来表示源代码的抽象语法结构。抽象语法树（AST）将源代码表示为树的形式，每个节点代表源代码中的一个语法结构，如表达式、语句、函数等，方便进行语法分析和程序转换。</li></ul> 
<p><strong>网络路由与拓扑排序</strong></p> 
<ul><li>在网络领域，树形结构可以用于路由算法的实现，例如通过构建路由表来确定数据包的传输路径。此外，在计算机网络的拓扑结构中，也可以使用树形结构来表示网络节点之间的关系，进行拓扑排序和数据传输优化。</li></ul> 
<blockquote> 
 <p>树形结构的应用不仅局限于以上几个领域，还涵盖了许多其他领域，如人工智能、游戏开发、数据可视化等。其灵活性和可扩展性使得树形结构成为解决各种复杂问题的有力工具。</p> 
</blockquote> 
<h2 id="%F0%9F%8E%B9%C2%A0%E4%BA%8C.%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Binary%20Tree%EF%BC%89" style="background-color:transparent;">🎹 二.二叉树（Binary Tree）</h2> 
<h3 id="%F0%9F%8E%BA1.%E6%A6%82%E5%BF%B5" style="background-color:transparent;">🎺1.概念</h3> 
<p class="img-center"><img alt="" height="693" src="https://images2.imgbox.com/eb/63/FPHCuqjf_o.png" width="1200"></p> 
<p>二叉树是树形结构中最常见的一种，具有以下基本概念：</p> 
<ul><li><span style="color:#333333;"><strong>结点的度</strong></span><span style="color:#333333;">：一个结点含有子树的个数称为该结点的度； 如上图：</span><span style="color:#333333;">A</span><span style="color:#333333;">的度为</span><span style="color:#333333;">6 </span></li><li><span style="color:#333333;"><strong>树的度</strong></span><span style="color:#333333;">：一棵树中，所有结点度的最大值称为树的度； 如上图：树的度为</span><span style="color:#333333;">6 </span></li><li><span style="color:#333333;"><strong>叶子结点或终端结点</strong></span><span style="color:#333333;">：度为</span><span style="color:#333333;">0</span><span style="color:#333333;">的结点称为叶结点； 如上图：</span><span style="color:#333333;">B</span><span style="color:#333333;">、</span><span style="color:#333333;">C</span><span style="color:#333333;">、</span><span style="color:#333333;">H</span><span style="color:#333333;">、</span><span style="color:#333333;">I...</span><span style="color:#333333;">等节点为叶结点 </span></li><li><span style="color:#333333;"><strong>双亲结点或父结点</strong></span><span style="color:#333333;">：若一个结点含有子结点，则这个结点称为其子结点的父结点； 如上图：</span><span style="color:#333333;">A</span><span style="color:#333333;">是</span><span style="color:#333333;">B</span><span style="color:#333333;">的父结点 </span></li><li><span style="color:#333333;"><strong>孩子结点或子结点</strong></span><span style="color:#333333;">：一个结点含有的子树的根结点称为该结点的子结点； 如上图：</span><span style="color:#333333;">B</span><span style="color:#333333;">是</span><span style="color:#333333;">A</span><span style="color:#333333;">的孩子结点 </span></li><li><span style="color:#333333;"><strong>根结点</strong></span><span style="color:#333333;">：一棵树中，没有双亲结点的结点；如上图：</span><span style="color:#333333;">A </span></li><li><span style="color:#333333;"><strong>结点的层次</strong></span><span style="color:#333333;">：从根开始定义起，根为第</span><span style="color:#333333;">1</span><span style="color:#333333;">层，根的子结点为第</span><span style="color:#333333;">2</span><span style="color:#333333;">层，以此类推</span></li><li><span style="color:#333333;"><strong>树的高度或深度</strong></span><span style="color:#333333;">：树中结点的最大层次； 如上图：树的高度为</span><span style="color:#333333;">4 </span></li><li><span style="color:#333333;">树的以下概念只需了解，在看书时只要知道是什么意思即可： </span></li><li><span style="color:#333333;"><strong>非终端结点或分支结点</strong></span><span style="color:#333333;">：度不为</span><span style="color:#333333;">0</span><span style="color:#333333;">的结点； 如上图：</span><span style="color:#333333;">D</span><span style="color:#333333;">、</span><span style="color:#333333;">E</span><span style="color:#333333;">、</span><span style="color:#333333;">F</span><span style="color:#333333;">、</span><span style="color:#333333;">G...</span><span style="color:#333333;">等节点为分支结点 </span></li><li><span style="color:#333333;"><strong>兄弟结点</strong></span><span style="color:#333333;">：具有相同父结点的结点互称为兄弟结点； 如上图：</span><span style="color:#333333;">B</span><span style="color:#333333;">、</span><span style="color:#333333;">C</span><span style="color:#333333;">是兄弟结点 </span></li><li><span style="color:#333333;"><strong>堂兄弟结点</strong></span><span style="color:#333333;">：双亲在同一层的结点互为堂兄弟；如上图：</span><span style="color:#333333;">H</span><span style="color:#333333;">、</span><span style="color:#333333;">I</span><span style="color:#333333;">互为兄弟结点 </span></li><li><span style="color:#333333;"><strong>结点的祖先</strong></span><span style="color:#333333;">：从根到该结点所经分支上的所有结点；如上图：</span><span style="color:#333333;">A</span><span style="color:#333333;">是所有结点的祖先 </span></li><li><span style="color:#333333;"><strong>子孙</strong></span><span style="color:#333333;">：以某结点为根的子树中任一结点都称为该结点的子孙。如上图：所有结点都是</span><span style="color:#333333;">A</span><span style="color:#333333;">的子孙 </span></li><li><span style="color:#333333;"><strong>森林</strong></span><span style="color:#333333;">：由</span><span style="color:#333333;">m</span><span style="color:#333333;">（</span><span style="color:#333333;">m&gt;=0</span><span style="color:#333333;">）棵互不相交的树组成的集合称为森林</span></li></ul> 
<h3 id="%C2%A0%F0%9F%8E%BB2.%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F" style="background-color:transparent;"> 🎻2.表现形式</h3> 
<p class="img-center"><img alt="" height="789" src="https://images2.imgbox.com/3e/d0/OoLZWHhE_o.png" width="1200"></p> 
<p><img alt="" height="469" src="https://images2.imgbox.com/47/36/npgkWcyL_o.png" width="1200"></p> 
<pre><code class="hljs">class TreeNode {
        public char val;
        public TreeNode left;//左孩子的引用
        public TreeNode right;//右孩子的引用

        public TreeNode(char val) {
            this.val = val;
        }
    }
</code></pre> 
<h3 id="%F0%9F%AA%953.%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B" style="background-color:transparent;">🪕3.特殊类型</h3> 
<p class="img-center"><img alt="" height="540" src="https://images2.imgbox.com/c0/85/sqaClo5x_o.png" width="1200"></p> 
<h4 id="%F0%9F%A5%813.1%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Complete%20Binary%20Tree%EF%BC%89" style="background-color:transparent;">🥁3.1完全二叉树（Complete Binary Tree）</h4> 
<p>完全二叉树是指除了最后一层外，其他每一层都被完全填满，并且最后一层的节点都依次从左向右排布，不留有空缺的二叉树。在完全二叉树中，如果某个节点没有右子节点，则它一定没有左子节点。</p> 
<p><strong>性质：</strong></p> 
<ol><li>完全二叉树的高度为 h，节点数目在 [2^(h-1), 2^h - 1] 的范围内。</li><li>如果将完全二叉树按照从上到下、从左到右的顺序对节点进行编号，那么对于任意一个节点 i，其左子节点的编号为 2i，右子节点的编号为 2i + 1，父节点的编号为 i/2（当 i 不为根节点时）。</li><li>完全二叉树的叶子节点一定集中在最底层和次底层，且最底层的叶子节点依次从左到右排布。</li></ol> 
<p><strong>示例：</strong></p> 
<p>下图展示了一个完全二叉树的示例：</p> 
<pre><code class="hljs">          1
        /   \
       2     3
      / \    
     4   5    
</code></pre> 
<p>在这个示例中，该完全二叉树的高度为 3，共有 5 个节点。</p> 
<h4 id="%F0%9F%AA%983.2%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Full%20Binary%20Tree%EF%BC%89" style="background-color:transparent;">🪘3.2满二叉树（Full Binary Tree）</h4> 
<p>满二叉树是一种特殊的二叉树，每个节点要么是叶子节点，要么具有两个子节点。满二叉树的所有非叶子节点都有两个子节点，且所有叶子节点都在同一层上。</p> 
<p><strong>性质：</strong></p> 
<ol><li>满二叉树的高度为 h，节点数目为 (2^h - 1)。</li><li>满二叉树的叶子节点数目等于 (2^(h-1))。</li><li>满二叉树中任意节点的度为 0 或 2。</li></ol> 
<p><strong>示例：</strong></p> 
<p>下图展示了一个满二叉树的示例：</p> 
<pre><code class="hljs">          1
        /   \
       2     3
      / \   / \
     4   5 6   7
</code></pre> 
<p>在这个示例中，该满二叉树的高度为 3，共有 (2^3 - 1 = 7) 个节点，所有叶子节点都在第三层上。</p> 
<hr> 
<blockquote> 
 <div> 
  <strong><span style="color:#333333;">满二叉树是一种特殊的完全二叉树</span></strong> 
 </div> 
</blockquote> 
<h3 id="%F0%9F%94%8B4.%E6%80%A7%E8%B4%A8%C2%A0" style="background-color:transparent;">🔋4.性质 </h3> 
<ol><li><span style="color:#333333;">若规定</span><span style="color:#333333;"><strong>根结点的层数为</strong></span><span style="color:#333333;"><strong>1</strong></span><span style="color:#333333;">，则一棵</span><span style="color:#333333;"><strong>非空二叉树的第</strong></span><span style="color:#333333;"><strong>i</strong></span><span style="color:#333333;"><strong>层上最多有2^i-1</strong></span><span style="color:#333333;"><strong>(i&gt;0)</strong></span><span style="color:#333333;"><strong>个结点 </strong></span></li><li><span style="color:#333333;">若规定只有</span><span style="color:#333333;"><strong>根结点的二叉树的深度为</strong></span><span style="color:#333333;"><strong>1</strong></span><span style="color:#333333;">，则</span><span style="color:#333333;"><strong>深度为</strong></span><span style="color:#333333;"><strong>K</strong></span><span style="color:#333333;"><strong>的二叉树的最大结点数是 </strong>2^k-1(k&gt;=0) </span></li><li><span style="color:#333333;">对任何一棵二叉树</span><span style="color:#333333;">, </span><span style="color:#333333;">如果其</span><span style="color:#333333;"><strong>叶结点个数为</strong></span><span style="color:#333333;"><strong> n0, </strong></span><span style="color:#333333;"><strong>度为</strong></span><span style="color:#333333;"><strong>2</strong></span><span style="color:#333333;"><strong>的非叶结点个数为</strong></span><span style="color:#333333;"><strong> n2,</strong></span><span style="color:#333333;"><strong>则有</strong></span><span style="color:#333333;"><strong>n0</strong></span><span style="color:#333333;"><strong>＝</strong></span><span style="color:#333333;"><strong>n2</strong></span><span style="color:#333333;"><strong>＋</strong></span><span style="color:#333333;"><strong>1 </strong></span></li><li><span style="color:#333333;">具有</span><span style="color:#333333;"><strong>n</strong></span><span style="color:#333333;"><strong>个结点的完全二叉树的深度</strong></span><span style="color:#333333;"><strong>k</strong></span><span style="color:#333333;"><strong>为log2(n+1)</strong></span><span style="color:#333333;"><strong>上取整 </strong></span></li><li><span style="color:#333333;">对于具有</span><span style="color:#333333;"><strong>n</strong></span><span style="color:#333333;"><strong>个结点的完全二叉树</strong></span><span style="color:#333333;">，如果按照</span><span style="color:#333333;"><strong>从上至下从左至右的顺序对所有节点从</strong></span><span style="color:#333333;"><strong>0</strong></span><span style="color:#333333;"><strong>开始编号</strong></span><span style="color:#333333;">，则对于</span><span style="color:#333333;"><strong>序号为</strong></span><span style="color:#333333;"><strong>i</strong></span><span style="color:#333333;"><strong>的结点有</strong></span><span style="color:#333333;">： </span></li></ol> 
<div> 
 <span style="color:#333333;">        若i&gt;0，双亲序号：</span> 
 <span style="color:#333333;">(i-1)/2</span> 
 <span style="color:#333333;">；</span> 
 <span style="color:#333333;">i=0</span> 
 <span style="color:#333333;">，</span> 
 <span style="color:#333333;">i</span> 
 <span style="color:#333333;">为根结点编号，无双亲结点 </span> 
</div> 
<div> 
 <span style="color:#333333;">        若2i+1&lt;n，左孩子序号：</span> 
 <span style="color:#333333;">2i+1，否则无左孩子 </span> 
</div> 
<div> 
 <span style="color:#333333;">        若2i+2&lt;n，右孩子序号：</span> 
 <span style="color:#333333;">2i+2，否则无右孩子</span> 
</div> 
<h3 id="%F0%9F%AA%AB5.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86" style="background-color:transparent;">🪫5.二叉树的遍历</h3> 
<h4 id="%F0%9F%92%BF5.1%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86" style="background-color:transparent;">💿5.1前中后序遍历</h4> 
<div> 
 <span style="color:#333333;">        学习二叉树结构，最简单的方式就是遍历。所谓<strong>遍历</strong></span> 
 <span style="color:#333333;"><strong>(Traversal)</strong></span> 
 <span style="color:#333333;"><strong>是指沿着某条搜索路线，依次对树中每个结</strong></span> 
 <span style="color:#333333;"><strong>点均做一次且仅做一次访问</strong></span> 
 <span style="color:#333333;">。</span> 
 <span style="color:#333333;"><strong>访问结点所做的操作依赖于具体的应用问题</strong></span> 
 <span style="color:#333333;"><strong>(</strong></span> 
 <span style="color:#333333;"><strong>比如：打印节点内容、节点内容加1)</strong>。 遍历是二叉树上最重要的操作之一，是二叉树上进行其它运算之基础。</span> 
</div> 
<div style="text-align:center;"> 
 <img alt="" height="265" src="https://images2.imgbox.com/60/9d/FEGodLuC_o.png" width="480"> 
</div> 
<h3 id="%C2%A0"> </h3> 
<div> 
 <span style="color:#333333;">在遍历二叉树时，如果没有进行某种约定，每个人都按照自己的方式遍历，得出的结果就比较混乱，</span> 
 <span style="color:#333333;"><strong>如果按</strong></span> 
 <span style="color:#333333;"><strong>照某种规则进行约定，则每个人对于同一棵树的遍历结果肯定是相同的</strong></span> 
 <span style="color:#333333;">。如果</span> 
 <span style="color:#333333;">N</span> 
 <span style="color:#333333;">代表根节点，</span> 
 <span style="color:#333333;">L</span> 
 <span style="color:#333333;">代表根节点的左子树，R</span> 
 <span style="color:#333333;">代表根节点的右子树，则根据遍历根节点的先后次序有以下遍历方式： </span> 
</div> 
<ul><li><span style="color:#333333;">NLR</span><span style="color:#333333;">：前序遍历</span><span style="color:#333333;">(Preorder Traversal </span><span style="color:#333333;">亦称先序遍历</span><span style="color:#333333;">)——</span><span style="color:#333333;">访问根结点</span><span style="color:#333333;">---&gt;</span><span style="color:#333333;">根的左子树</span><span style="color:#333333;">---&gt;</span><span style="color:#333333;">根的右子树。 </span></li><li><span style="color:#333333;">LNR</span><span style="color:#333333;">：中序遍历</span><span style="color:#333333;">(Inorder Traversal)——</span><span style="color:#333333;">根的左子树</span><span style="color:#333333;">---&gt;</span><span style="color:#333333;">根节点</span><span style="color:#333333;">---&gt;</span><span style="color:#333333;">根的右子树。 </span></li><li><span style="color:#333333;">LRN</span><span style="color:#333333;">：后序遍历</span><span style="color:#333333;">(Postorder Traversal)——</span><span style="color:#333333;">根的左子树</span><span style="color:#333333;">---&gt;</span><span style="color:#333333;">根的右子树</span><span style="color:#333333;">---&gt;</span><span style="color:#333333;">根节点。 </span></li></ul> 
<p><span style="color:#333333;">以下我们用递归方式，来实现这三种遍历方式，逻辑非常简单，以前序遍历举例：</span></p> 
<p class="img-center"><img alt="" height="778" src="https://images2.imgbox.com/fd/28/xgtZczi0_o.png" width="1200"></p> 
<p>代码如下： </p> 
<pre><code class="hljs"> // 前序遍历
    public void preOrder(TreeNode root) {
        if (root==null){
            return;
        }
        System.out.print(root.val+" ");
        preOrder(root.left);
        preOrder(root.right);
    }

 // 中序遍历
    void inOrder(TreeNode root) {
        if (root==null){
            return;
        }
        inOrder(root.left);
        System.out.print(root.val+" ");
        inOrder(root.right);
    }

 // 后序遍历
    void postOrder(TreeNode root) {
        if (root==null){
            return;
        }
        postOrder(root.left);
        postOrder(root.right);
        System.out.print(root.val+" ");
    }</code></pre> 
<blockquote> 
 <div> 
  <span style="color:#333333;">前序遍历结果：</span> 
  <span style="color:#333333;">1 2 3 4 5 6 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">中序遍历结果：</span> 
  <span style="color:#333333;">3 2 1 5 4 6 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">后序遍历结果：</span> 
  <span style="color:#333333;">3 1 5 6 4 1</span> 
 </div> 
</blockquote> 
<h4 id="%F0%9F%93%80%C2%A05.2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86" style="background-color:transparent;">📀 5.2层序遍历</h4> 
<div> 
 <span style="color:#333333;">        设二叉树的根节点所在层数为1，层序遍历就是从所在二叉树的根节点出发，首先访问第一层的树根节点，然后从左到右访问第2层上的节点，接着是第三层的节点，以此类推，自上而下，自左至右逐层访问树的结点的过程就是层序遍历。</span> 
</div> 
<p class="img-center"><img alt="" height="352" src="https://images2.imgbox.com/d6/79/W8U5eQ5U_o.png" width="388"></p> 
<p>        首先检查根节点是否为空，然后创建一个队列来存储待处理的节点。在遍历过程中，每次从队列中取出当前层的所有节点，并将它们的值添加到当前层的列表中。然后将每个节点的子节点（如果存在）加入队列，以便遍历下一层。最后将当前层的列表添加到结果列表中，直到队列为空，遍历完成。 </p> 
<pre><code class="hljs">import java.util.*;

// 二叉树节点类
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int x) {
        val = x;
    }
}


public class LevelOrderTraversal {
    //返回List&lt;List&lt;Integer&gt;&gt;
    public List&lt;List&lt;Integer&gt;&gt; levelOrder1(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        if (root == null)
            return result;

        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int levelSize = queue.size(); // 当前层的节点数
            List&lt;Integer&gt; currentLevel = new ArrayList&lt;&gt;();

            // 遍历当前层的所有节点
            for (int i = 0; i &lt; levelSize; i++) {
                TreeNode node = queue.poll();
                currentLevel.add(node.val); // 将当前节点的值加入当前层列表

                // 将当前节点的子节点加入队列，用于遍历下一层
                if (node.left != null)
                    queue.offer(node.left);
                if (node.right != null)
                    queue.offer(node.right);
            }

            result.add(currentLevel); // 将当前层的列表加入结果列表
        }

        return result;
    }

    //直接打印
     public void levelOrder2(TreeNode root) {
        
        Queue&lt;TreeNode&gt; queue=new LinkedList&lt;&gt;();
        if (root==null){
            return;
        }
        queue.offer(root);
        while(!queue.isEmpty()){
            TreeNode cur=queue.poll();
            System.out.print(cur.val+" ");
            if (cur.left!=null){
                queue.offer(cur.left);
            }
            if (cur.right!=null){
                queue.offer(cur.right);
            }
        }
        System.out.println("");
    }
}
</code></pre> 
<h2 id="%F0%9F%94%8E%C2%A0%E4%B8%89.%E6%80%BB%E7%BB%93%E4%B8%8E%E5%8F%8D%E6%80%9D" style="background-color:transparent;">🔎 三.总结与反思</h2> 
<blockquote> 
 <p>漫长的岁月既毁坏了坟墓又损坏了墓碑可是光阴对于书却无能为力。——瓦鲁阿</p> 
</blockquote> 
<p>        学习了Java中二叉树的过程让我受益匪浅。首先，我意识到了数据结构在编程中的关键性，二叉树作为其中的重要一环，对算法设计和问题解决都有着深远的影响。深入理解二叉树的基本概念，如节点、根节点、子节点等，为我理解二叉树结构和算法打下了坚实的基础。掌握了常见的操作和遍历算法，如插入节点、删除节点以及深度优先遍历和广度优先遍历，这些都是对树形结构理解和应用至关重要的。</p> 
<p>        通过编写Java代码实现二叉树的操作和算法，我不仅加深了对二叉树的理解，也提升了编程能力。在未来，我希望能更深入地理解算法原理，探索二叉树在不同应用场景中的多样化应用，并持续学习与实践，以不断提升自己的编程能力和解决问题的能力。</p> 
<hr> 
<p>🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀</p> 
<p>以上，就是本期的全部内容啦，若有错误疏忽希望各位大佬及时指出💐</p> 
<p>  制作不易，希望能对各位提供微小的帮助，可否留下你免费的赞呢🌸</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/32e5f6575ca50321b9c6278617f14d05/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LLama的激活函数SwiGLU 解释</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5a3b1ee5d2e1959b1bb7ba44e10d5270/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【前后端】django与vue的结合使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>