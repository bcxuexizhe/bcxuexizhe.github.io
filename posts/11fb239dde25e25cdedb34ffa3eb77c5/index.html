<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Java】深入了解双亲委派机制（常说的类加载机制） - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/11fb239dde25e25cdedb34ffa3eb77c5/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【Java】深入了解双亲委派机制（常说的类加载机制）">
  <meta property="og:description" content="前言： ava虚拟机（JVM）的类加载机制是Java应用中不可或缺的一部分。本文将详细介绍JVM的双亲委派机制，并阐述各关键点。
一、什么是双亲委派机制？ 双亲委派机制（Parent-Delegate Model）是Java类加载器中采用的一种类加载策略。该机制的核心思想是：如果一个类加载器收到了类加载请求，默认先将该请求委托给其父类加载器处理。只有当父级加载器无法加载该类时，才会尝试自行加载。
二、类加载器与层级关系 Java中的类加载器主要有如下三种：
启动类加载器（Bootstrap ClassLoader）： 负责加载 %JAVA_HOME%/jre/lib 目录下的核心Java类库如 rt.jar、charsets.jar 等。
扩展类加载器（Extension ClassLoader）： 负责加载 %JAVA_HOME%/jre/lib/ext 目录下的扩展类库。
应用类加载器（Application ClassLoader）： 负责加载用户类路径（ClassPath）下的应用程序类。
这三种类加载器之间存在父子层级关系。启动类加载器是最高级别的加载器，没有父加载器；扩展类加载器的父加载器是启动类加载器；应用类加载器的父加载器是扩展类加载器。
除了以上三个内置类加载器，用户还可以通过继承 java.lang.ClassLoader 类自定义类加载器，根据实际需求处理类加载请求。
三：双亲委派机制作用及如何破环机制 通过上述两块内容，我们对双亲委派机制、加载流程及层级有了一些了解，这时我们不妨抛出几个疑问。
为什么需要双亲委派双亲委派机制有哪些优缺点如何打破这个机制有哪些工具选择了破坏机制。 1. 为什么需要双亲委派 1. 通过双亲委派机制，可以避免类的重复加载，当父加载器已经加载过某一个类时，子加载器就不会再重新加载这个类。
2. 通过双亲委派机制，可以保证安全性。因为BootstrapClassLoader在加载的时候，只会加载JAVA_HOME中的jar包里面的类，如java.lang.String，那么这个类是不会被随意替换的。
那么，就可以避免有人自定义一个有破坏功能的java.lang.String被加载。这样可以有效的防止核心Java API被篡改。
这是在JDK1.8的java.lang.ClassLoader类中的源码，这个方法就是用于加载指定的类。
实现双亲委派机制 的代码也都集中在这个方法之中：
protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException{ synchronized (getClassLoadingLock(name)) { // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) { long t0 = System.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-08-30T22:21:37+08:00">
    <meta property="article:modified_time" content="2023-08-30T22:21:37+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java】深入了解双亲委派机制（常说的类加载机制）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>前言：</h3> 
<p>ava虚拟机（JVM）的类加载机制是Java应用中不可或缺的一部分。本文将详细介绍JVM的双亲委派机制，并阐述各关键点。</p> 
<h3><a id="_3"></a>一、什么是双亲委派机制？</h3> 
<p>双亲委派机制（Parent-Delegate Model）是Java类加载器中采用的一种类加载策略。该机制的核心思想是：如果一个类加载器收到了类加载请求，默认先将该请求委托给其父类加载器处理。只有当父级加载器无法加载该类时，才会尝试自行加载。</p> 
<h3><a id="_6"></a>二、类加载器与层级关系</h3> 
<p>Java中的类加载器主要有如下三种：<br> <img src="https://images2.imgbox.com/91/b1/KudiLmGp_o.png" alt="在这里插入图片描述" width="700" height="500"></p> 
<ul><li> <p><strong>启动类加载器（Bootstrap ClassLoader）：</strong> 负责加载 <code>%JAVA_HOME%/jre/lib</code> 目录下的核心Java类库如 rt.jar、charsets.jar 等。</p> </li><li> <p><strong>扩展类加载器（Extension ClassLoader）：</strong> 负责加载 <code>%JAVA_HOME%/jre/lib/ext</code> 目录下的扩展类库。</p> </li><li> <p><strong>应用类加载器（Application ClassLoader）：</strong> 负责加载用户类路径（<code>ClassPath</code>）下的应用程序类。</p> </li></ul> 
<p>这三种类加载器之间存在父子层级关系。启动类加载器是最高级别的加载器，没有父加载器；扩展类加载器的父加载器是启动类加载器；应用类加载器的父加载器是扩展类加载器。</p> 
<p>  除了以上三个内置类加载器，用户还可以通过继承 <strong>java.lang.ClassLoader 类自定义类加载器</strong>，根据实际需求处理类加载请求。</p> 
<h3><a id="_18"></a>三：双亲委派机制作用及如何破环机制</h3> 
<p>通过上述两块内容，我们对双亲委派机制、加载流程及层级有了一些了解，这时我们不妨抛出几个疑问。</p> 
<ul><li>为什么需要双亲委派</li><li>双亲委派机制有哪些优缺点</li><li>如何打破这个机制</li><li>有哪些工具选择了破坏机制。</li></ul> 
<h4><a id="1__25"></a>1. 为什么需要双亲委派</h4> 
<p>  1. 通过双亲委派机制，可以<strong>避免类的重复加载</strong>，当父加载器已经加载过某一个类时，子加载器就不会再重新加载这个类。</p> 
<p>  2. 通过双亲委派机制，<strong>可以保证安全性</strong>。因为BootstrapClassLoader在加载的时候，只会加载JAVA_HOME中的jar包里面的类，如java.lang.String，那么这个类是不会被随意替换的。</p> 
<p>那么，就可以避免有人自定义一个有破坏功能的java.lang.String被加载。这样可以有效的防止核心Java API被篡改。</p> 
<p>这是在JDK1.8的java.lang.ClassLoader类中的源码，这个方法就是用于加载指定的类。<br> <strong>实现双亲委派机制</strong> 的代码也都集中在这个方法之中：</p> 
<pre><code class="prism language-java"><span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// First, check if the class has already been loaded</span>
            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">long</span> t0 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                        c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">// ClassNotFoundException thrown if class not found</span>
                    <span class="token comment">// from the non-null parent class loader</span>
                <span class="token punctuation">}</span>

                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">// If still not found, then invoke findClass in order</span>
                    <span class="token comment">// to find the class.</span>
                    <span class="token keyword">long</span> t1 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>

                    <span class="token comment">// this is the defining class loader; record the stats</span>
                    <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getParentDelegationTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addTime</span><span class="token punctuation">(</span>t1 <span class="token operator">-</span> t0<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getFindClassTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addElapsedTimeFrom</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getFindClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> c<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>通过以上代码得出结论：</p> 
<ul><li>当类加载器接收到类加载的请求时，首先检查该类是否已经被当前类加载器加载；</li><li>若该类未被加载过，当前类加载器会将加载请求委托给父类加载器去完成；</li><li>若当前类加载器的父类加载器为null，会委托启动类加载器完成加载；</li><li>若父类加载器无法完成类的加载，当前类加载器才会去尝试加载该类。</li></ul> 
<h4><a id="2__80"></a>2. 双亲委派机制的优缺点</h4> 
<p><strong>优点：</strong></p> 
<ol><li>避免重复加载：由于类加载器直接从父类加载器那里加载类，避免了类的重复加载。</li><li>提高安全性：通过双亲委派模型，Java 标准库中的核心类库（如 java.lang.*）由启动类加载器加载，这样能保证这些核心类库不会被恶意代码篡改或替换，从而提高程序的安全性。</li><li>保持类加载的一致性：这种方式确保了同一个类的加载由同一个类加载器完成，从而在运行时保证了类型的唯一性和相同性。这也有助于减轻类加载器在处理相互关联的类时的复杂性。</li></ol> 
<p><strong>缺点：</strong></p> 
<ol><li>灵活性降低：由于类加载的过程需要不断地委托给父类加载器，这种机制可能导致实际应用中类加载的灵活性降低。</li><li>增加了类加载时间：在类加载的过程中，需要不断地查询并委托父类加载器，这意味着类加载所需要的时间可能会增加。在类数量庞大或类加载器层次比较深的情况下，这种时间延迟可能会变得更加明显。</li></ol> 
<h4><a id="3__92"></a>3. 如何打破这个机制</h4> 
<p>既然上述文章中我们已经知道了双亲委派的实现方式，那么如何打破这个机制呢。</p> 
<p>想要破坏这种机制，那么就需要自定义一个类加载器，继承ClassLoader类重写其中的loadClass方法，使其不进行双亲委派即可。<br> 写个示例</p> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Method</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span></span><span class="token class-name">Files</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span></span><span class="token class-name">Paths</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{<!-- --></span>
    
    <span class="token comment">// 自定义类加载器必须提供一个加载类文件的位置</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> classesPath<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">CustomClassLoader</span><span class="token punctuation">(</span><span class="token class-name">String</span> classesPath<span class="token punctuation">,</span> <span class="token class-name">ClassLoader</span> parent<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>classesPath <span class="token operator">=</span> classesPath<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//首先,检查已加载的类</span>
        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> loadedClass <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>loadedClass <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 如果已加载类中没有该类, 尝试用自定义的方法加载</span>
            <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                loadedClass <span class="token operator">=</span> <span class="token function">findClassInPath</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 如果自定义加载方法找不到类,则委托给父类加载器</span>
                loadedClass <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> resolve<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">resolveClass</span><span class="token punctuation">(</span>loadedClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token keyword">return</span> loadedClass<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">findClassInPath</span><span class="token punctuation">(</span><span class="token class-name">String</span> className<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">String</span> filePath <span class="token operator">=</span> className<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token char">'.'</span><span class="token punctuation">,</span> <span class="token char">'/'</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">".class"</span><span class="token punctuation">;</span>
            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classBytes <span class="token operator">=</span> <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">readAllBytes</span><span class="token punctuation">(</span><span class="token class-name">Paths</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>classesPath<span class="token punctuation">,</span> filePath<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>className<span class="token punctuation">,</span> classBytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> classBytes<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span><span class="token string">"Class not found in classes path: "</span> <span class="token operator">+</span> className<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">String</span> pathToClasses <span class="token operator">=</span> <span class="token string">"/path/to/your/classes"</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> className <span class="token operator">=</span> <span class="token string">"com.example.SampleClass"</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> methodName <span class="token operator">=</span> <span class="token string">"sampleMethod"</span><span class="token punctuation">;</span>

        <span class="token comment">// 创建自定义类加载器实例，将类的加载权交给它</span>
        <span class="token class-name">CustomClassLoader</span> customClassLoader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CustomClassLoader</span><span class="token punctuation">(</span>pathToClasses<span class="token punctuation">,</span> <span class="token class-name">CustomClassLoader</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 使用自定义类加载器加载类</span>
        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> customClass <span class="token operator">=</span> customClassLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 创建类的实例并调用方法</span>
        <span class="token class-name">Object</span> obj <span class="token operator">=</span> customClass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Method</span> method <span class="token operator">=</span> customClass<span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        method<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>上面的示例代码中，我们重写了 <code>loadClass</code> 方法，先尝试通过 <code>findClassInPath</code> 从指定的路径加载类，<strong>如果无法加载就委托给父类加载器</strong>。这样，我们就实现了打破双亲委派机制的自定义类加载器。</p> 
<p><strong>以下是代码的详细解析：</strong></p> 
<ol><li> <p>自定义类加载器 <code>CustomClassLoader</code> 继承 Java <code>ClassLoader</code> 类。</p> </li><li> <p>在类加载器的构造方法中设置自定义类加载器的类路径 <code>classesPath</code> 和父加载器 <code>parent</code>。</p> </li><li> <p>重写 <code>loadClass</code> 方法。首先检查已加载的类，如果已加载则返回。否则尝试用自定义的方法在 <code>classesPath</code> 中加载类。如果自定义加载方法找不到类，则委托给父类加载器。</p> </li><li> <p>实现名为 <code>findClassInPath</code> 的自定义加载方法。这个方法使用类名 <code>className</code> 在 <code>classesPath</code> 指定的目录下查找对应的 .class 文件，然后将文件内容读取为字节数组并调用 <code>defineClass</code> 方法，将其转换为 Java 类的 Class 对象。如果类不存在或出现其他错误，会抛出 <code>ClassNotFoundException</code> 异常。</p> </li><li> <p>在 main 方法中，创建一个 <code>CustomClassLoader</code> 类的实例。将类的加载任务交给自定义类加载器，指定加载路径和要加载的类。</p> </li><li> <p>使用自定义类加载器加载目标类，创建类的实例，并调用指定方法。</p> </li></ol> 
<h4><a id="4__183"></a>4. 有哪些工具选择了破坏机制。</h4> 
<p>既然在上文中，我们已经清楚怎么打破双亲机制，那么有哪些工具选择了破坏机制呢？为什么？</p> 
<ul><li> <p>OSGi（Open Service Gateway Initiative）：OSGi 是一个模块化系统和服务平台，提供了一个强大的类加载器模型。在 OSGi 中，每个模块都有一个独立的类加载器，可以按需加载来自不同模块的类。这有助于解决 JAR 地狱问题，提高模块化和动态更新能力。</p> </li><li> <p>Tomcat Web容器：Tomcat 的 Web 应用类加载器可以加载 Web 应用程序中的本地类库，从而使得每个 Web 应用程序可以使用各自的版本的类库。这些 Web 应用的类加载器都是${tomcat-home}/lib 中类库的子类加载器。</p> </li><li> <p>Java Agent: Java Agent 是一种基于 Java Instrumentation API 的技术，它可以在运行时修改已加载的类的字节码，从而实现类的热替换、AOP（面向切面编程）等功能。这种技术在诸如热部署、性能监控和分布式追踪等场景中有广泛应用。</p> </li><li> <p>JDK 中的 URLClassLoader：JDK 自带的 URLClassLoader 可以用来加载指定 URL 路径下的类。实际上，它实现了一种子类优先的策略，先尝试加载自身路径下的类，再委托给父类加载器，从而打破了双亲委派机制。</p> </li></ul> 
<p>这些工具和技术之所以要打破双亲委派机制，主要是出于以下原因：</p> 
<ul><li> <p>实现模块化和动态更新：例如 OSGi，通过独立的类加载器实现不同模块间解耦，并支持模块的动态卸载和更新。</p> </li><li> <p>解决类库版本冲突（JAR地狱问题）：在复杂系统中，不同模块可能依赖不同版本的类库。为避免版本冲突，可使用独立的类加载器，使它们分别加载各自的类库版本。</p> </li><li> <p>运行时修改类：Java Agent 可以在运行时修改类字节码，从而支持热替换、AOP 和性能监控等功能。</p> </li><li> <p>支持 Web 应用程序的独立部署和更新：例如 Tomcat，可以为每个 Web 应用程序分配一个独立的类加载器，实现各自部署与更新。</p> </li></ul> 
<p>需要注意的是，打破双亲委派机制可能会带来类加载冲突、安全性和性能等问题，因此在实际应用中要谨慎使用。</p> 
<h3><a id="_206"></a>四：总结</h3> 
<p>本文介绍了JVM的双亲委派机制，包括概念、类加载器层级关系、双亲委派流程及实例分析等方面的内容。双亲委派机制可以确保Java应用类型安全，同时避免类加载冲突。在某些特定场景下，我们可以通过自定义类加载器对类加载策略进行调整，以满足应用特性和性能需求。</p> 
<p>本文到此就结束了，多谢观看。<br> <img src="https://images2.imgbox.com/c8/e5/kjNTz8XW_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a4fe747566272eba5192aa7bb0f23d0d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前端上传文件， Content-Type: multipart/form-data； boundary=----WebKitFormBoundarywd2ZRr4Hlgf2m5MT ；</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2ec60e6b94ab82b9fb7e8cf37d24c39f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">《Python入门到精通》webbrowser模块详解，Python webbrowser标准库，Python浏览器控制工具</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>