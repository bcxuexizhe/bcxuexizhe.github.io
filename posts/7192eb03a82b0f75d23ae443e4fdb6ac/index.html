<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【链表】：必写的四道基础题 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/7192eb03a82b0f75d23ae443e4fdb6ac/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【链表】：必写的四道基础题">
  <meta property="og:description" content="🎁个人主页：我们的五年
🔍系列专栏：每日一练
🌷追光的人，终会万丈光芒
目录
🏝问题1：反转链表
⛷问题描述：​编辑
⛷ 问题分析：
⛷代码实现：
🏝问题2：寻找链表的中间节
⛷问题描述：
⛷问题分析：
⛷代码实现：
🏝问题3：返回单链表的倒数第K个节点的值
⛷问题描述：
⛷问题分析： ⛷代码实现：
🏝问题4：合并两个有序链表
⛷问题描述：
⛷问题分析：
⛷代码实现：
前言：
这篇文章会给大家带来几道经典的单链表题目，这些题目的步骤，可能会在一些难的题目中作为基本步骤，也就是难的题目也会应用到这些思想。
比如：
反转一个单链表，寻找一个单链表的中间节点，找到单链表的倒数第K个节点等。
🏝问题1：反转链表 【LeetCode】链接：. - 力扣（LeetCode）
⛷问题描述：
⛷ 问题分析： ●原链表是：1&gt;2&gt;3&gt;4&gt;5
●我们只需要把2节点指向1，3节点指向2……
●但是最重要的还是把1的next指针置为空，不然还是指向2节点，2节点也是指向1节点，就会形成环，所以我们可以先申请一个头节点为NULL，第1个节点指向NULL，然后2&gt;1,3&gt;2,4&gt;3,5&gt;4
●在循环的过程中，要把pcur指向的next指向前一个节点的指针，如果不做任何操作，就直接把next指向newhead，我们就找不到pcur的下一个节点了，所以要先保存下一个节点的指针，然后再去改变pcur的next指针。
⛷代码实现： /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ typedef struct ListNode ListNode; struct ListNode* reverseList(struct ListNode* head) { ListNode* newhead=NULL; ListNode* pcur=head; while(pcur) { ListNode* pnext=pcur-&gt;next; pcur-&gt;next=newhead; newhead=pcur; pcur=pnext; } return newhead; } 🏝问题2：寻找链表的中间节 【LeetCode】链接:.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-25T23:11:04+08:00">
    <meta property="article:modified_time" content="2024-04-25T23:11:04+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【链表】：必写的四道基础题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><strong>🎁个人主页：<a href="https://blog.csdn.net/djdjiejsn?spm=1011.2444.3001.5343" title="我们的五年">我们的五年</a></strong></p> 
<p style="text-align:center;">🔍<strong>系列专栏：</strong><strong><a href="https://blog.csdn.net/djdjiejsn/category_12572079.html" title="每日一练">每日一练</a></strong></p> 
<p style="text-align:center;">🌷<strong>追光的人，终会万丈光芒</strong></p> 
<p><strong><img alt="" src="https://images2.imgbox.com/ef/37/GvU9hFrV_o.gif"></strong></p> 
<p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%C2%A0%F0%9F%8F%9D2.%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%C2%A0%F0%9F%8F%9D2.%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%EF%BC%9A" rel="nofollow">🏝问题1：反转链表</a></p> 
<p id="%E2%9B%B7%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%EF%BC%9A%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:40px;"><a href="#%E2%9B%B7%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%EF%BC%9A%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow">⛷问题描述：​编辑</a></p> 
<p id="%E2%9B%B7%C2%A0%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E2%9B%B7%C2%A0%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A" rel="nofollow">⛷ 问题分析：</a></p> 
<p id="%C2%A0%E2%9B%B7%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A0%E2%9B%B7%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A" rel="nofollow"> ⛷代码实现：</a></p> 
<p id="%C2%A0%F0%9F%8F%9D%E9%97%AE%E9%A2%982%EF%BC%9A%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82-toc" style="margin-left:0px;"><a href="#%C2%A0%F0%9F%8F%9D%E9%97%AE%E9%A2%982%EF%BC%9A%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82" rel="nofollow"> 🏝问题2：寻找链表的中间节</a></p> 
<p id="%C2%A0%E2%9B%B7%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A0%E2%9B%B7%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%EF%BC%9A" rel="nofollow"> ⛷问题描述：</a></p> 
<p id="%C2%A0%E2%9B%B7%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A0%E2%9B%B7%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A" rel="nofollow"> ⛷问题分析：</a></p> 
<p id="%E2%9B%B7%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E2%9B%B7%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A" rel="nofollow">⛷代码实现：</a></p> 
<p id="%C2%A0%F0%9F%8F%9D%E9%97%AE%E9%A2%983%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC-toc" style="margin-left:0px;"><a href="#%C2%A0%F0%9F%8F%9D%E9%97%AE%E9%A2%983%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC" rel="nofollow"> 🏝问题3：返回单链表的倒数第K个节点的值</a></p> 
<p id="%E2%9B%B7%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E2%9B%B7%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%EF%BC%9A" rel="nofollow">⛷问题描述：</a></p> 
<p id="%E2%9B%B7%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A%C2%A0-toc" style="margin-left:40px;"><a href="#%E2%9B%B7%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A%C2%A0" rel="nofollow">⛷问题分析： </a></p> 
<p id="%E2%9B%B7%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E2%9B%B7%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A" rel="nofollow">⛷代码实现：</a></p> 
<p id="%C2%A0%F0%9F%8F%9D%E9%97%AE%E9%A2%984%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#%C2%A0%F0%9F%8F%9D%E9%97%AE%E9%A2%984%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8" rel="nofollow"> 🏝问题4：合并两个有序链表</a></p> 
<p id="%C2%A0%E2%9B%B7%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A0%E2%9B%B7%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%EF%BC%9A" rel="nofollow"> ⛷问题描述：</a></p> 
<p id="%C2%A0%E2%9B%B7%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A0%E2%9B%B7%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A" rel="nofollow"> ⛷问题分析：</a></p> 
<p id="%E2%9B%B7%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E2%9B%B7%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A" rel="nofollow">⛷代码实现：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<blockquote> 
 <p> 前言：</p> 
 <p>这篇文章会给大家带来几道经典的单链表题目，这些题目的步骤，可能会在一些难的题目中作为基本步骤，也就是难的题目也会应用到这些思想。</p> 
 <p>比如：</p> 
 <p>反转一个单链表，寻找一个单链表的中间节点，找到单链表的倒数第K个节点等。</p> 
</blockquote> 
<h2 id="%C2%A0%F0%9F%8F%9D2.%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%EF%BC%9A">🏝问题1：反转链表</h2> 
<p>【LeetCode】链接：<a href="https://leetcode.cn/problems/reverse-linked-list/description/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
<h3 id="%E2%9B%B7%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%EF%BC%9A%E2%80%8B%E7%BC%96%E8%BE%91">⛷问题描述：<br><img alt="" height="233" src="https://images2.imgbox.com/78/fa/gZsAO0H0_o.png" width="536"></h3> 
<p><img alt="" height="407" src="https://images2.imgbox.com/d9/23/VGRjgGEk_o.png" width="532"></p> 
<blockquote> 
 <h3 id="%E2%9B%B7%C2%A0%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A">⛷ 问题分析：</h3> 
 <p>●原链表是：1&gt;2&gt;3&gt;4&gt;5</p> 
 <p>●我们只需要把2节点指向1，3节点指向2……</p> 
 <p>●但是最重要的还是把1的next指针置为空，不然还是指向2节点，2节点也是指向1节点，就会形成环，所以我们可以先申请一个头节点为NULL，第1个节点指向NULL，然后2&gt;1,3&gt;2,4&gt;3,5&gt;4</p> 
 <p>●在循环的过程中，要把pcur指向的next指向前一个节点的指针，如果不做任何操作，就直接把next指向newhead，我们就找不到pcur的下一个节点了，所以要先保存下一个节点的指针，然后再去改变pcur的next指针。</p> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%E2%9B%B7%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A"> ⛷代码实现：</h3> 
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
 typedef struct ListNode ListNode;
struct ListNode* reverseList(struct ListNode* head) {
    ListNode* newhead=NULL;
    ListNode* pcur=head;
    while(pcur)
    {
        ListNode* pnext=pcur-&gt;next;
        pcur-&gt;next=newhead;
        newhead=pcur;
        pcur=pnext;
    } 
    return newhead;
}</code></pre> 
<h2 id="%C2%A0%F0%9F%8F%9D%E9%97%AE%E9%A2%982%EF%BC%9A%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82"> 🏝问题2：寻找链表的中间节</h2> 
<p>【LeetCode】链接:<a href="https://leetcode.cn/problems/middle-of-the-linked-list/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
<h3 id="%C2%A0%E2%9B%B7%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%EF%BC%9A"> ⛷问题描述：</h3> 
<p> <img alt="" height="549" src="https://images2.imgbox.com/b7/59/UPD4jJXX_o.png" width="568"></p> 
<h3 id="%C2%A0%E2%9B%B7%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A"> ⛷问题分析：</h3> 
<blockquote> 
 <p>如果我们先去遍历一下链表有多少个元素，然后把个数除以二去寻找中间节点，这样差不多要进行两次遍历，但是我们用<span style="color:#fe2c24;">快慢指针</span>就能很好的避免这种情况。</p> 
</blockquote> 
<h3 id="%E2%9B%B7%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A">⛷代码实现：</h3> 
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
 typedef struct ListNode ListNode;
struct ListNode* middleNode(struct ListNode* head) {
    ListNode* fast=head;
    ListNode* slow=head;
    while(fast&amp;&amp;fast-&gt;next)
    {
        slow=slow-&gt;next;
        fast=fast-&gt;next-&gt;next;
    }
        return slow;
}</code></pre> 
<h2 id="%C2%A0%F0%9F%8F%9D%E9%97%AE%E9%A2%983%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC"> 🏝问题3：返回单链表的倒数第K个节点的值</h2> 
<p>【LeetCode】链接:<a href="https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/description/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
<h3 id="%E2%9B%B7%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%EF%BC%9A">⛷问题描述：</h3> 
<p><img alt="" height="351" src="https://images2.imgbox.com/73/cf/jJ8v56fK_o.png" width="680"></p> 
<h3 id="%E2%9B%B7%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A%C2%A0">⛷问题分析： </h3> 
<blockquote> 
 <p>这题我们也可以用<span style="color:#fe2c24;">快慢指针</span>去解题，我们需要将快慢指针拉开K个节点的距离，然后我们要快慢指针同步往后走，等fast指针走到NULL，此时slow就是倒数第K个节点。</p> 
</blockquote> 
<h3>⛷代码实现：</h3> 
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

typedef struct ListNode ListNode;
int kthToLast(struct ListNode* head, int k){
    ListNode* fast=head;
    ListNode* slow=head;
    while(k--)
    {
        fast=fast-&gt;next;
    }
    while(fast)
    {
        fast=fast-&gt;next;
        slow=slow-&gt;next;
    }
    return slow-&gt;val;
}
</code></pre> 
<h2 id="%C2%A0%F0%9F%8F%9D%E9%97%AE%E9%A2%984%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"> 🏝问题4：合并两个有序链表</h2> 
<p>【LeetCode】链接：<a href="https://leetcode.cn/problems/merge-two-sorted-lists/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
<h3> ⛷问题描述：</h3> 
<p><img alt="" height="783" src="https://images2.imgbox.com/83/86/CojpcCLv_o.png" width="588"></p> 
<h3> ⛷问题分析：</h3> 
<blockquote> 
 <p>●创建一个头结点，然后要list1和list2区遍历，谁小就放在为节点的尾部，比如list1的节点比list2节点小，我们就可以ptail-&gt;list1,然后让list1往后面遍历，直到有一个节点为NULL，我们就跳出循环。</p> 
 <p>●后面一步我们只要把剩下链表补充到ptail的后面就可以，因为list1和list2是先后遍历，所以list1和list2不可能同时走到NULL，一定有一个先走到NULL，如果是list1先走到NULL，那么我们只要把list2剩余的节点补充到ptail的后面就可以了，即ptail-&gt;next=list1。</p> 
</blockquote> 
<h3>⛷代码实现：</h3> 
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
 typedef struct ListNode ListNode;
struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {
    ListNode* phead=(ListNode*)malloc(sizeof(ListNode));
    ListNode* ptail=phead;
    while(list1&amp;&amp;list2)
    {
        if(list1-&gt;val&gt;list2-&gt;val)
        {
            ptail-&gt;next=list2;
            ptail=list2;
            list2=list2-&gt;next;
        }
        else
        {
            ptail-&gt;next=list1;
            ptail=list1;
            list1=list1-&gt;next;
        }
    }
    ptail-&gt;next=list1==NULL?list2:list1;
    return phead-&gt;next;
}</code></pre> 
<p> 总结：</p> 
<p>这四个题目可以让我们对链表有一个认识，虽然很简单，但是这几个题还是很有用的，可以重点看一下，后期还会继续带来链表较难的题目，可以的铁子可以三连，感谢大家的支持。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5648e1393587d75ab322ec0fba6731e3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">7.MyBatis 操作数据库(初阶)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0326a68432e9386bac1cceb2ad012824/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构】单链表</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>