<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】双向循环链表专题解析 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/10de4526aafbfefcbf36f123b3d0d4bb/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【数据结构】双向循环链表专题解析">
  <meta property="og:description" content="实现自己既定的目标，必须能耐得住寂寞单干。💓💓💓
目录
•✨说在前面
🍋知识点一：双向链表的结构
• 🌰1.&#34;哨兵位&#34;节点
• 🌰2.双向带头循环链表的结构
🍋知识点二：双向带头循环链表
• 🌰1. 动态申请节点 • 🌰2. 双向链表的初始化
• 🌰3. 双向链表元素的打印
• 🌰4. 双向链表头部插入数据
• 🌰5. 双向链表尾部插入数据
• 🌰6. 指定位置pos之后插入数据
• 🌰7.双向链表头部删除元素
• 🌰8.双向链表尾部删除元素
• 🌰9.删除指定位置pos节点
• 🌰10.双向链表的查找
• 🌰10.双向链表的销毁
• ✨SumUp结语
•✨说在前面 亲爱的读者们大家好！💖💖💖，我们又见面了，之前我们学习了顺序表后，又紧接着给大家讲解了链表中最典型的单向不循环链表，也是最常用的一种。但正所谓我们学习应该面面俱到，有了之前的学习基础，再学习双向链表实际上是非常简单的。
如果你没有准备好的话，可以再复习一下单链表以及单链表相关LeetCode的OJ题。
👇👇👇
💘💘💘知识连线时刻（直接点击即可）
🎉🎉🎉复习回顾🎉🎉🎉
【数据结构】单链表专题详细分析
博主主页传送门：愿天垂怜的博客
🍋知识点一：双向链表的结构 • 🌰1.&#34;哨兵位&#34;节点 哨兵位指的是链表中指向链表第一个节点的节点，哨兵位不存储任何有效元素，只是在那里放哨的，顾称为哨兵位节点。
注意：
这里的&#34;带头&#34;跟前面我们说的&#34;链表中的第一个有效节点&#34;是两个概念，实际单链表的头结点不是第一个有效节点，而是哨兵位节点。
&#34;哨兵位&#34;存在的意义：
遍历循环链表避免死循环。
具体带头比不带头有什么优势可以看我上一篇文章中的合并有序链表。
LeetCode/NowCoder-链表经典算法OJ练习1
• 🌰2.双向带头循环链表的结构 结构如下：
由于&#34;哨兵位&#34;节点的存在，我们再实现这样的链表时可以省去一些内容：
🎉插入操作时，不需要检查是否在头部插入，因为哨兵节点作为头结点，总是存在。
🎉删除操作时，不需要处理删除的是否是头节点的情况，因为哨兵节点不会被删除。
🎉简化了代码，因为不需要为头节点和普通节点编写不同的处理逻辑。
类比单链表的结构，可以定义出节点数据为整型的双向带头循环链表节点：
typedef int LTDataType; typedef struct ListNode { LTDataType data; struct ListNode* prev;//指向前一个节点 struct ListNode* next;//指向后一个节点 }LTNode; 🍋知识点二：双向带头循环链表 • 🌰1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-18T20:31:31+08:00">
    <meta property="article:modified_time" content="2024-05-18T20:31:31+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】双向循环链表专题解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><span style="color:#fe2c24;"><strong>实现自己既定的目标，必须能耐得住寂寞单干。💓💓💓</strong></span></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E2%80%A2%E2%9C%A8%E8%AF%B4%E5%9C%A8%E5%89%8D%E9%9D%A2-toc" style="margin-left:40px;"><a href="#%E2%80%A2%E2%9C%A8%E8%AF%B4%E5%9C%A8%E5%89%8D%E9%9D%A2" rel="nofollow">•✨说在前面</a></p> 
<p id="%F0%9F%8D%8B%E9%80%9A%E8%AE%AF%E5%BD%95%E5%9F%BA%E6%9C%AC%E9%87%8F%E8%AE%BE%E8%AE%A1-toc" style="margin-left:40px;"><a href="#%F0%9F%8D%8B%E9%80%9A%E8%AE%AF%E5%BD%95%E5%9F%BA%E6%9C%AC%E9%87%8F%E8%AE%BE%E8%AE%A1" rel="nofollow">🍋知识点一：双向链表的结构</a></p> 
<p id="%C2%A0%E2%80%A2%20%F0%9F%8C%B01.%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%E2%80%A2%20%F0%9F%8C%B01.%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%C2%A0" rel="nofollow"> • 🌰1."哨兵位"节点</a></p> 
<p id="%C2%A0%E2%80%A2%20%F0%9F%8C%B02.%E5%8F%8C%E5%90%91%E5%B8%A6%E5%A4%B4%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#%C2%A0%E2%80%A2%20%F0%9F%8C%B02.%E5%8F%8C%E5%90%91%E5%B8%A6%E5%A4%B4%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84" rel="nofollow"> • 🌰2.双向带头循环链表的结构</a></p> 
<p id="%F0%9F%8D%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C%EF%BC%9A%E5%8F%8C%E5%90%91%E5%B8%A6%E5%A4%B4%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#%F0%9F%8D%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C%EF%BC%9A%E5%8F%8C%E5%90%91%E5%B8%A6%E5%A4%B4%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8" rel="nofollow">🍋知识点二：双向带头循环链表</a></p> 
<p id="%C2%A0%E2%80%A2%20%F0%9F%8C%B01.%C2%A0%E5%8A%A8%E6%80%81%E7%94%B3%E8%AF%B7%E8%8A%82%E7%82%B9%C2%A0-toc" style="margin-left:120px;"><a href="#%C2%A0%E2%80%A2%20%F0%9F%8C%B01.%C2%A0%E5%8A%A8%E6%80%81%E7%94%B3%E8%AF%B7%E8%8A%82%E7%82%B9%C2%A0" rel="nofollow"> • 🌰1. 动态申请节点 </a></p> 
<p id="%C2%A0%E2%80%A2%20%F0%9F%8C%B02.%20%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:120px;"><a href="#%C2%A0%E2%80%A2%20%F0%9F%8C%B02.%20%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow"> • 🌰2. 双向链表的初始化</a></p> 
<p id="%C2%A0%E2%80%A2%20%F0%9F%8C%B03.%20%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E7%9A%84%E6%89%93%E5%8D%B0-toc" style="margin-left:120px;"><a href="#%C2%A0%E2%80%A2%20%F0%9F%8C%B03.%20%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E7%9A%84%E6%89%93%E5%8D%B0" rel="nofollow"> • 🌰3. 双向链表元素的打印</a></p> 
<p id="%C2%A0%E2%80%A2%20%F0%9F%8C%B04.%20%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%A4%B4%E9%83%A8%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE-toc" style="margin-left:120px;"><a href="#%C2%A0%E2%80%A2%20%F0%9F%8C%B04.%20%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%A4%B4%E9%83%A8%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE" rel="nofollow"> • 🌰4. 双向链表头部插入数据</a></p> 
<p id="%C2%A0%E2%80%A2%20%F0%9F%8C%B05.%20%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%B0%BE%E9%83%A8%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE-toc" style="margin-left:120px;"><a href="#%C2%A0%E2%80%A2%20%F0%9F%8C%B05.%20%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%B0%BE%E9%83%A8%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE" rel="nofollow"> • 🌰5. 双向链表尾部插入数据</a></p> 
<p id="%C2%A0%E2%80%A2%20%F0%9F%8C%B06.%20%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AEpos%E4%B9%8B%E5%90%8E%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE-toc" style="margin-left:120px;"><a href="#%C2%A0%E2%80%A2%20%F0%9F%8C%B06.%20%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AEpos%E4%B9%8B%E5%90%8E%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE" rel="nofollow"> • 🌰6. 指定位置pos之后插入数据</a></p> 
<p id="%C2%A0%E2%80%A2%20%F0%9F%8C%B07.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%A4%B4%E9%83%A8%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-toc" style="margin-left:120px;"><a href="#%C2%A0%E2%80%A2%20%F0%9F%8C%B07.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%A4%B4%E9%83%A8%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0" rel="nofollow"> • 🌰7.双向链表头部删除元素</a></p> 
<p id="%C2%A0%E2%80%A2%20%F0%9F%8C%B08.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%B0%BE%E9%83%A8%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-toc" style="margin-left:120px;"><a href="#%C2%A0%E2%80%A2%20%F0%9F%8C%B08.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%B0%BE%E9%83%A8%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0" rel="nofollow"> • 🌰8.双向链表尾部删除元素</a></p> 
<p id="%C2%A0%E2%80%A2%20%F0%9F%8C%B09.%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AEpos%E8%8A%82%E7%82%B9-toc" style="margin-left:120px;"><a href="#%C2%A0%E2%80%A2%20%F0%9F%8C%B09.%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AEpos%E8%8A%82%E7%82%B9" rel="nofollow"> • 🌰9.删除指定位置pos节点</a></p> 
<p id="%C2%A0%E2%80%A2%20%F0%9F%8C%B010.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE-toc" style="margin-left:120px;"><a href="#%C2%A0%E2%80%A2%20%F0%9F%8C%B010.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE" rel="nofollow"> • 🌰10.双向链表的查找</a></p> 
<p id="%C2%A0%E2%80%A2%20%F0%9F%8C%B010.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E9%94%80%E6%AF%81-toc" style="margin-left:120px;"><a href="#%C2%A0%E2%80%A2%20%F0%9F%8C%B010.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E9%94%80%E6%AF%81" rel="nofollow"> • 🌰10.双向链表的销毁</a></p> 
<p id="%E2%80%A2%20%E2%9C%A8SumUp%E7%BB%93%E8%AF%AD-toc" style="margin-left:40px;"><a href="#%E2%80%A2%20%E2%9C%A8SumUp%E7%BB%93%E8%AF%AD" rel="nofollow">• ✨SumUp结语</a></p> 
<hr id="hr-toc"> 
<p></p> 
<blockquote> 
 <h3 id="%E2%80%A2%E2%9C%A8%E8%AF%B4%E5%9C%A8%E5%89%8D%E9%9D%A2">•✨说在前面</h3> 
 <p>亲爱的读者们大家好！💖💖💖，我们又见面了，之前我们学习了顺序表后，<span style="color:#79c6cd;"><strong>又紧接着给大家讲解了链表中最典型的单向不循环链表，也是最常用的一种。</strong></span>但正所谓我们学习应该面面俱到，有了之前的学习基础，再学习双向链表实际上是非常简单的。</p> 
 <p>  </p> 
 <p> 如果你没有准备好的话，可以再复习一下单链表以及单链表相关LeetCode的OJ题。</p> 
 <p>   </p> 
 <p>👇👇👇<br> 💘💘💘知识连线时刻（直接点击即可）</p> 
 <p>  🎉🎉🎉复习回顾🎉🎉🎉</p> 
 <p><a href="https://blog.csdn.net/2302_81580770/article/details/138564253?spm=1001.2014.3001.5502" title="【数据结构】单链表专题详细分析">【数据结构】单链表专题详细分析</a></p> 
 <p>    </p> 
 <p><span style="color:#956fe7;"><strong>  博主主页传送门：</strong></span><a href="https://blog.csdn.net/2302_81580770?type=blog" title="愿天垂怜的博客">愿天垂怜的博客</a></p> 
</blockquote> 
<p> <img alt="" height="298" src="https://images2.imgbox.com/ea/f9/rUdBrRGU_o.png" width="298"></p> 
<p> <img alt="" height="40" src="https://images2.imgbox.com/6f/06/eNYBLGeA_o.png" width="1200"></p> 
<blockquote> 
 <h3 id="%F0%9F%8D%8B%E9%80%9A%E8%AE%AF%E5%BD%95%E5%9F%BA%E6%9C%AC%E9%87%8F%E8%AE%BE%E8%AE%A1"><a name="t4"></a>🍋知识点一：双向链表的结构</h3> 
</blockquote> 
<h4 id="%C2%A0%E2%80%A2%20%F0%9F%8C%B01.%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%C2%A0"> • 🌰1."哨兵位"节点</h4> 
<p>哨兵位指的是链表中指向链表第一个节点的节点，<span style="color:#ff9900;"><strong>哨兵位不存储任何有效元素，只是在那里放哨的，顾称为哨兵位节点</strong></span>。</p> 
<p><img alt="" height="251" src="https://images2.imgbox.com/a2/78/YHqj4CZX_o.png" width="681"></p> 
<p><strong>注意：</strong></p> 
<p>这里的"带头"跟前面我们说的"链表中的第一个有效节点"是两个概念，实际单链表的头结点不是第一个有效节点，而是哨兵位节点。</p> 
<p><strong>"哨兵位"存在的意义：</strong></p> 
<p><span style="color:#79c6cd;"><strong>遍历循环链表避免死循环。</strong></span></p> 
<p>具体带头比不带头有什么优势可以看我上一篇文章中的合并有序链表。</p> 
<p><a href="https://blog.csdn.net/2302_81580770/article/details/138679249?spm=1001.2014.3001.5502" title="LeetCode/NowCoder-链表经典算法OJ练习1">LeetCode/NowCoder-链表经典算法OJ练习1</a></p> 
<p><img alt="" height="40" src="https://images2.imgbox.com/c9/6a/tex5lH3f_o.png" width="1200"></p> 
<h4 id="%C2%A0%E2%80%A2%20%F0%9F%8C%B02.%E5%8F%8C%E5%90%91%E5%B8%A6%E5%A4%B4%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84"> • 🌰2.双向带头循环链表的结构</h4> 
<p><strong>结构如下：</strong></p> 
<p><img alt="" height="556" src="https://images2.imgbox.com/0a/b4/LdT88QXM_o.png" width="1200"></p> 
<p> 由于"哨兵位"节点的存在，我们再实现这样的链表时可以省去一些内容：</p> 
<p><span style="color:#1c7892;">🎉插入操作时，不需要检查是否在头部插入，因为哨兵节点作为头结点，总是存在。<br><br> 🎉删除操作时，不需要处理删除的是否是头节点的情况，因为哨兵节点不会被删除。<br><br> 🎉简化了代码，因为不需要为头节点和普通节点编写不同的处理逻辑。</span></p> 
<p>类比单链表的结构，可以定义出节点数据为<span style="color:#1c7892;"><strong>整型</strong></span>的双向带头循环链表节点：</p> 
<pre><code class="language-cpp">typedef int LTDataType;

typedef struct ListNode
{
	LTDataType data;
	struct ListNode* prev;//指向前一个节点
	struct ListNode* next;//指向后一个节点
}LTNode;</code></pre> 
<p><img alt="" height="40" src="https://images2.imgbox.com/6a/45/plrRABrP_o.png" width="1200"></p> 
<blockquote> 
 <h3 id="%F0%9F%8D%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C%EF%BC%9A%E5%8F%8C%E5%90%91%E5%B8%A6%E5%A4%B4%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8">🍋知识点二：双向带头循环链表</h3> 
</blockquote> 
<h5 id="%C2%A0%E2%80%A2%20%F0%9F%8C%B01.%C2%A0%E5%8A%A8%E6%80%81%E7%94%B3%E8%AF%B7%E8%8A%82%E7%82%B9%C2%A0" style="background-color:transparent;"> • 🌰1. 动态申请节点 </h5> 
<p>在双向带头循环链表提供的方法中，动态申请节点是必不可少的。</p> 
<pre><code class="language-cpp">LTNode* LTBuyNode(LTDataType x)
{
	LTNode* newnode = (LTNode*)malloc(sizeof(LTNode));
	if (newnode == NULL)
	{
		perror("malloc");
		exit(1);
	}
	newnode-&gt;data = x;
	newnode-&gt;next = newnode-&gt;prev = newnode;
    return newnode;
}</code></pre> 
<p>初始化双向链表其实就是创建头节点，那么就需要用到LTBuyNode来申请节点。由于是<span style="color:#1c7892;"><strong>双向</strong></span>的，我们可以让它的next指针和prev指针先指向它自己。</p> 
<p><img alt="" height="190" src="https://images2.imgbox.com/b2/5e/BYJyL73X_o.png" width="318"></p> 
<p>那是否可以将哨兵位的next指针和prev指针初始化为NULL呢？答案是不行的。</p> 
<p><img alt="" height="170" src="https://images2.imgbox.com/c4/e1/b6Op6zsr_o.png" width="402"></p> 
<p>如果哨兵位的前驱指针prev和后继指针next初始化为NULL，这样的链表虽然满足了双向，也满足了带头，但是不满足<span style="color:#1c7892;"><strong>循环</strong></span>，所以不能这样初始化，因此在动态申请节点的时候，就让newnode的prev和next都指向它自己，这样就可以循环起来了。</p> 
<p><img alt="" height="40" src="https://images2.imgbox.com/9b/66/RCR7RY2x_o.png" width="1200"></p> 
<h5 id="%C2%A0%E2%80%A2%20%F0%9F%8C%B02.%20%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"> • 🌰2. 双向链表的初始化</h5> 
<p>初始化双向带头循环链表实际上就是创建"哨兵位"头节点。</p> 
<p><span style="color:#1c7892;"><strong>写法1：</strong></span><strong>传二级指针，函数为void型。</strong></p> 
<pre><code class="language-cpp">void LTInit(LTNode** pphead)
{
	*pphead = LTBuyNode(-1);
}</code></pre> 
<p><span style="color:#1c7892;"><strong>写法2：</strong></span><strong>不传参 ，在函数中创建节点，函数为LTNode*型。</strong></p> 
<pre><code class="language-cpp">LTNode* LTInit()
{
    LTNode* phead = LTBuyNode(-1);
	return phead;
}</code></pre> 
<p>我们将其中存储的值设为-1，表示其为头节点，此时链表中只有一个头节点：</p> 
<p><img alt="" height="215" src="https://images2.imgbox.com/5e/35/nuQCVP0z_o.png" width="299"></p> 
<p><img alt="" height="40" src="https://images2.imgbox.com/84/3b/1Mbv4bgu_o.png" width="1200"></p> 
<h5 id="%C2%A0%E2%80%A2%20%F0%9F%8C%B03.%20%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E7%9A%84%E6%89%93%E5%8D%B0"> • 🌰3. 双向链表元素的打印</h5> 
<p>打印双向链表中的所有节点数据。</p> 
<pre><code class="language-cpp">void LTPrint(LTNode* phead)
{
	LTNode* pcur = phead-&gt;next;
	while (pcur != phead)
	{
		printf("%d-&gt;", pcur-&gt;data);
		pcur = pcur-&gt;next;
	}
	printf("\n");
}</code></pre> 
<p>这个没什么好说的，和之前我们学习的单链表基本是一样的，不过是<span style="color:#1c7892;"><strong>while循环</strong></span>的条件有所变化。我们如果初始化pcur为phead-&gt;next，那它循环完一轮之后会重新变成phead，此时就已经打印完成，不需要继续循环了。</p> 
<p><img alt="" height="40" src="https://images2.imgbox.com/5b/68/dr98b04h_o.png" width="1200"></p> 
<h5 id="%C2%A0%E2%80%A2%20%F0%9F%8C%B04.%20%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%A4%B4%E9%83%A8%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"> • 🌰4. 双向链表头部插入数据</h5> 
<p>向双向链表的头部插入节点和数据，指的是在头节点的后一个位置插入数据，而不是在头节点的前面（头插）。</p> 
<pre><code class="language-cpp">void LTPushFront(LTNode* phead, LTDataType x)
{
	assert(phead);
	LTNode* newnode = LTBuyNode(x);
	newnode-&gt;prev = phead;
	newnode-&gt;next = phead-&gt;next;
	phead-&gt;next = newnode;
	newnode-&gt;next-&gt;prev = newnode;
}</code></pre> 
<p>双向带头循环链表的指针关系比较复杂，但是逻辑却很简单，我们一定要通过画图来理解，不要光看代码，这样是看不出东西的。</p> 
<p><img alt="" height="268" src="https://images2.imgbox.com/98/c7/shzo8FHp_o.png" width="740"></p> 
<p><strong>上述关系红色为先修改，蓝色为后修改。</strong>由于关系比较多，可以先<span style="color:#1c7892;"><strong>从newnode入手</strong></span>，先处理newnode的prev和next指针，这样不会影响到原链表的结构。当设置完newnode时，如果先让phead的后继指针next指向newnode，那么图中红色所标注的phead-&gt;next不在是那个节点的地址，而是newnode的地址，此时它就应该是newnode-&gt;next。</p> 
<p><img alt="" height="40" src="https://images2.imgbox.com/9a/05/z8pFkbVL_o.png" width="1200"></p> 
<h5 id="%C2%A0%E2%80%A2%20%F0%9F%8C%B05.%20%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%B0%BE%E9%83%A8%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"> • 🌰5. 双向链表尾部插入数据</h5> 
<p>向双向链表的尾部插入节点和数据，可以理解为在图中的末尾插入数据，也可以理解为在头节点的前一个位置插入数据。</p> 
<pre><code class="language-cpp">void LTPushBack(LTNode* phead, LTDataType x)
{
	assert(phead);
	LTNode* newnode = LTBuyNode(x);
	newnode-&gt;prev = phead-&gt;prev;
	newnode-&gt;next = phead;
	phead-&gt;prev-&gt;next = newnode;
	phead-&gt;prev = newnode;
}</code></pre> 
<p>由于是循环链表，画图的时候可以在节点顺序不改变的前提下灵活<span style="color:#1c7892;"><strong>变换</strong></span>图像。</p> 
<p><span style="color:#1c7892;"><strong>图1：</strong></span></p> 
<p><img alt="" height="506" src="https://images2.imgbox.com/a3/21/Ijqrlprj_o.jpg" width="1200"></p> 
<p><span style="color:#1c7892;"><strong>图2：</strong></span></p> 
<p><img alt="" height="443" src="https://images2.imgbox.com/25/61/GnltNAB1_o.jpg" width="1200"><br>  两中图理解都是可以的，由于头节点的位置固定，上面两个图都是同一个双向链表。 </p> 
<p><img alt="" height="40" src="https://images2.imgbox.com/34/31/xBLidG1D_o.png" width="1200"></p> 
<h5 id="%C2%A0%E2%80%A2%20%F0%9F%8C%B06.%20%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AEpos%E4%B9%8B%E5%90%8E%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"> • 🌰6. 指定位置pos之后插入数据</h5> 
<p>在指定位置pos的后面插入节点和数据，其实和头插方法很类似，甚至可以说头插其实就是pos后插入数据的一种特殊情况，只不过此时pos=phead而已。</p> 
<pre><code class="language-cpp">void LTInsert(LTNode* pos, LTDataType x)
{
	assert(pos);
	LTNode* newnode = LTBuyNode(x);
	newnode-&gt;prev = pos;
	newnode-&gt;next = pos-&gt;next;
	pos-&gt;next = newnode;
	newnode-&gt;next-&gt;prev = newnode;
}</code></pre> 
<p>可以发现，代码也是及其类似。</p> 
<p><img alt="" height="557" src="https://images2.imgbox.com/fb/6c/kaiCC4tQ_o.png" width="1200"></p> 
<p><img alt="" height="40" src="https://images2.imgbox.com/80/60/qvu6GHz6_o.png" width="1200"></p> 
<h5 id="%C2%A0%E2%80%A2%20%F0%9F%8C%B07.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%A4%B4%E9%83%A8%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"> • 🌰7.双向链表头部删除元素</h5> 
<p>删除链表中的第一个有效节点，即删除头节点的后一个节点。</p> 
<pre><code class="language-cpp">void LTPopFront(LTNode* phead)
{
	assert(phead &amp;&amp; phead-&gt;next != phead);
	LTNode* del = phead-&gt;next;
	phead-&gt;next = del-&gt;next;
	del-&gt;next-&gt;prev = phead;
	free(del);
	del = NULL;
}</code></pre> 
<p>为了防止free释放后无法<span style="color:#1c7892;"><strong>解引用</strong></span>找到下一个节点的问题，引入del保存要删除的节点的地址。</p> 
<p><img alt="" height="444" src="https://images2.imgbox.com/7c/99/GlueYCOA_o.jpg" width="1200"></p> 
<p><img alt="" height="40" src="https://images2.imgbox.com/31/34/E6oAytSD_o.png" width="1200"></p> 
<h5 id="%C2%A0%E2%80%A2%20%F0%9F%8C%B08.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%B0%BE%E9%83%A8%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"> • 🌰8.双向链表尾部删除元素</h5> 
<p> 删除双向链表中的最后一个数据，可以理解为删除图中末尾的数据，也可以理解为删除头节点前面一个数据。</p> 
<pre><code class="language-cpp">void LTPopBack(LTNode* phead)
{
	assert(phead &amp;&amp; phead-&gt;next != phead);
	LTNode* del = phead-&gt;prev;
	phead-&gt;next = del-&gt;prev;
	del-&gt;prev-&gt;next = phead;
	free(del);
	del = NULL;
}</code></pre> 
<p>两种画法和2.5思路一样，这里就画出一种，只要理解一种，另一种就很简单了。</p> 
<p><img alt="" height="604" src="https://images2.imgbox.com/59/2b/UGVGFZkD_o.jpg" width="1200"></p> 
<p><img alt="" height="40" src="https://images2.imgbox.com/f1/0b/dF8lhZ1N_o.png" width="1200"></p> 
<h5 id="%C2%A0%E2%80%A2%20%F0%9F%8C%B09.%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AEpos%E8%8A%82%E7%82%B9"> • 🌰9.删除指定位置pos节点</h5> 
<p>删除指定位置pos的节点，如法炮制。</p> 
<pre><code class="language-cpp">void LTErase(LTNode* pos)
{
	//pos不能为哨兵位
	assert(pos);
	pos-&gt;next-&gt;prev = pos-&gt;prev;
	pos-&gt;prev-&gt;next = pos-&gt;next;
	free(pos);
	pos = NULL;
}</code></pre> 
<p>除了要保证pos不为NULL外，还需要保证pos不能为哨兵位，否则它不是有效节点。</p> 
<p><img alt="" height="462" src="https://images2.imgbox.com/a6/79/KQE1tihg_o.jpg" width="1200"></p> 
<p><img alt="" height="40" src="https://images2.imgbox.com/c4/3d/ogCLpsfB_o.png" width="1200"></p> 
<h5 id="%C2%A0%E2%80%A2%20%F0%9F%8C%B010.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"> • 🌰10.双向链表的查找</h5> 
<p>查找链表中值为x的节点。</p> 
<pre><code class="language-cpp">LTNode* LTFind(LTNode* phead, LTDataType x)
{
	LTNode* pcur = phead-&gt;next;
	while (pcur != phead)
	{
		if (pcur-&gt;data == x)
		{
			return pcur;
		}
		pcur = pcur-&gt;next;
	}
	return NULL;
}</code></pre> 
<p>定义pcur，利用while循环遍历一轮，如果有值为x的节点，则返回该节点，遍历一轮后若仍没有该节点，则返回空指针NULL。</p> 
<p><img alt="" height="40" src="https://images2.imgbox.com/a3/3b/BoOWU2gL_o.png" width="1200"></p> 
<h5 id="%C2%A0%E2%80%A2%20%F0%9F%8C%B010.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E9%94%80%E6%AF%81"> • 🌰10.双向链表的销毁</h5> 
<p>与单链表和顺序表的思想如出一辙，如法炮制。</p> 
<pre><code class="language-cpp">void LTDestory(LTNode* phead)
{
	assert(phead);
	LTNode* pcur = phead-&gt;next;
	while (pcur != phead)
	{
		LTNode* next = pcur-&gt;next;
		free(pcur);
		pcur = next;
	}
	free(phead);
	phead = NULL;
}</code></pre> 
<p><img alt="" height="40" src="https://images2.imgbox.com/42/9c/x2zQ0wVj_o.png" width="1200"></p> 
<blockquote> 
 <h3 id="%E2%80%A2%20%E2%9C%A8SumUp%E7%BB%93%E8%AF%AD">• ✨SumUp结语</h3> 
 <p>数据结构的学习一定要多画图，多理解，多思考，切忌直接抄写代码，就认为自己已经会了，一定到自己动手，才能明白自己哪个地方有问题。</p> 
 <p></p> 
 <p><span style="color:#6eaad7;"><strong>如果大家觉得有帮助，麻烦大家点点赞，如果有错误的地方也欢迎大家指出~</strong></span></p> 
</blockquote> 
<p><img alt="" height="448" src="https://images2.imgbox.com/43/4d/aNTZ9IYQ_o.png" width="449"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5f958eb286cc11e0ce5b32dab61e86f6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android 5.0 ~ 14访问Android/data(obb)目录的方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/231a19ea5e5fc5358b534ef48b85e6ca/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【SpringBoot】SpringBoot整合jasypt进行重要数据加密</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>