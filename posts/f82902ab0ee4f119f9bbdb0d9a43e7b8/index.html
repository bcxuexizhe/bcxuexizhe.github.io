<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JavaEE 初阶篇-深入了解 Junit 单元测试框架和 Java 中的反射机制（使用反射做一个简易版框架） - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/f82902ab0ee4f119f9bbdb0d9a43e7b8/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="JavaEE 初阶篇-深入了解 Junit 单元测试框架和 Java 中的反射机制（使用反射做一个简易版框架）">
  <meta property="og:description" content="🔥博客主页： 【小扳_-CSDN博客】
❤感谢大家点赞👍收藏⭐评论✍
文章目录
1.0 Junit 单元测试框架概述
1.1 使用 Junit 框架进行测试业务代码
1.2 Junit 单元测试框架的常用注解（Junit 4.xxx 版本）
2.0 反射概述
2.1 获取 Class 对象的三种方式
2.2 获取类的构造器并对其进行操作
2.3 获取类的成员变量
2.4 获取类的成员方法
3.0 使用反射做一个简易版的框架
1.0 Junit 单元测试框架概述 可以用来对方法进行测试，它是第三方公司开源出来的（很多开发工具已经集成了 Junit 框架，比如 IDEA）
优点：
1）可以灵活的编写测试代码，可以针对某个方法执行测试，也支持一键完成对全部方法的自动化测试，且各自独立。
2）不需要程序员去分析测试结果，会自动生成测试报告出来。
具体步骤：
1）将 Junit 框架的 jar 包导入到项目中（注意：IDEA 集成了 Junit 框架，不需要我们手动导入）
2）为需要测试的业务类，定义对应的测试类，并为每个方法，编写对应的测试方法（测试方法必须：公共、无参、无返回值）
3）测试方法上必须声明 @Test 注解，然后在测试方法中，编写代码调用被测试的业务方法进行测试。其实就是列出实际例子进行测试。
4）开始测试：选中测试方法，右键选择 “Junit 运行”，如果测试通过则是绿色；如果测试失败，则是红色。
1.1 使用 Junit 框架进行测试业务代码 举个例子：
业务代码：
//这是项目的业务代码 public class ProjectBusiness { //项目业务一:获取字符串的长度 public static void printLength(String str){ System.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-03T16:39:21+08:00">
    <meta property="article:modified_time" content="2024-05-03T16:39:21+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JavaEE 初阶篇-深入了解 Junit 单元测试框架和 Java 中的反射机制（使用反射做一个简易版框架）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>🔥博客主页： 【<strong><a href="https://blog.csdn.net/Tingfeng__?spm=1000.2115.3001.5343" title="小扳_-CSDN博客】">小扳_-CSDN博客】</a></strong><br> ❤感谢大家点赞👍收藏⭐评论✍</strong></p> 
</blockquote> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/05/94/ePKZXmXc_o.jpg" width="400"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/4b/33/0hUOytYK_o.gif"></p> 
<p id="main-toc"><strong>文章目录</strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20Junit%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20Junit%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0" rel="nofollow">        1.0 Junit 单元测试框架概述</a></strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.1%20%E4%BD%BF%E7%94%A8%C2%A0Junit%20%E6%A1%86%E6%9E%B6%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.1%20%E4%BD%BF%E7%94%A8%C2%A0Junit%20%E6%A1%86%E6%9E%B6%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81" rel="nofollow">        1.1 使用 Junit 框架进行测试业务代码</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.2%20Junit%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%EF%BC%88Junit%204.xxx%20%E7%89%88%E6%9C%AC%EF%BC%89-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.2%20Junit%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%EF%BC%88Junit%204.xxx%20%E7%89%88%E6%9C%AC%EF%BC%89" rel="nofollow">        1.2 Junit 单元测试框架的常用注解（Junit 4.xxx 版本）</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.0%20%E5%8F%8D%E5%B0%84%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.0%20%E5%8F%8D%E5%B0%84%E6%A6%82%E8%BF%B0" rel="nofollow">        2.0 反射概述</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1%20%E8%8E%B7%E5%8F%96%20Class%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1%20%E8%8E%B7%E5%8F%96%20Class%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F" rel="nofollow">        2.1 获取 Class 对象的三种方式</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A02.2%20%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%E5%B9%B6%E5%AF%B9%E5%85%B6%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A02.2%20%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%E5%B9%B6%E5%AF%B9%E5%85%B6%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C" rel="nofollow">         2.2 获取类的构造器并对其进行操作</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%20%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%20%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F" rel="nofollow">        2.3 获取类的成员变量</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.4%20%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.4%20%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95" rel="nofollow">        2.4 获取类的成员方法</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E5%81%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%89%88%E7%9A%84%E6%A1%86%E6%9E%B6-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E5%81%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%89%88%E7%9A%84%E6%A1%86%E6%9E%B6" rel="nofollow">        3.0 使用反射做一个简易版的框架</a></strong></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20Junit%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0">        1.0 Junit 单元测试框架概述</h2> 
<p><strong>        可以用来对方法进行测试，它是第三方公司开源出来的（很多开发工具已经集成了 Junit 框架，比如 IDEA）</strong></p> 
<p><span style="color:#fe2c24;"><strong>优点：</strong></span></p> 
<p><strong>        1）可以灵活的编写测试代码，可以针对某个方法执行测试，也支持一键完成对全部方法的自动化测试，且各自独立。</strong></p> 
<p><strong>        2）不需要程序员去分析测试结果，会自动生成测试报告出来。</strong></p> 
<p><span style="color:#fe2c24;"><strong>具体步骤：</strong></span></p> 
<p><strong>        1）将 Junit 框架的 jar 包导入到项目中（注意：IDEA 集成了 Junit 框架，不需要我们手动导入）</strong></p> 
<p><strong>        2）为需要测试的业务类，定义对应的测试类，并为每个方法，编写对应的测试方法（测试方法必须：公共、无参、无返回值）</strong></p> 
<p><strong>        3）测试方法上必须声明 @Test 注解，然后在测试方法中，编写代码调用被测试的业务方法进行测试。其实就是列出实际例子进行测试。</strong></p> 
<p><strong>        4）开始测试：选中测试方法，右键选择 “Junit 运行”，如果测试通过则是绿色；如果测试失败，则是红色。</strong></p> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.1%20%E4%BD%BF%E7%94%A8%C2%A0Junit%20%E6%A1%86%E6%9E%B6%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81">        1.1 使用 Junit 框架进行测试业务代码</h3> 
<p><strong>举个例子：</strong></p> 
<blockquote> 
 <p><strong>业务代码：</strong></p> 
 <pre><code class="language-java">//这是项目的业务代码
public class ProjectBusiness {

    //项目业务一:获取字符串的长度
    public static void printLength(String str){
        System.out.println(str.length());
    }

    //项目业务二:获取字符串最大的索引下标
    public static int getMaxIndex(String str){
        if (str == null){
            return -1;
        }
        return str.length();
    }
}</code></pre> 
 <p><strong>测试业务代码：</strong></p> 
 <pre><code class="language-java">import org.junit.Test;

//测试业务:对项目业务代码进行测试
public class TestBusiness {

    //针对每一个方法进行测试，定义测试方法必须是公开、无参、无返回值

    //对业务一代码进行测试
    //记得要加上注解
    @Test
    public void testPrintLength(){
        //然后调用业务一的代码，列举实际例子
        ProjectBusiness.printLength("你好世界!!!");
        ProjectBusiness.printLength("你好小板");
        ProjectBusiness.printLength(null);
    }


}</code></pre> 
 <p><strong>        对于业务一代码来说很明显是缺少了一个 if 判断是否为 null ，假设我们没有发现，现在来看测试结果：</strong></p> 
 <p class="img-center"><img alt="" height="252" src="https://images2.imgbox.com/6a/e8/vIiBLi3F_o.png" width="666"></p> 
 <p></p> 
 <p><strong>        测试出来的结果也明确的表示是因为空指针导致的测试失败。</strong></p> 
 <p><strong>将代码改进加上 if 判断是否为 null 之后的测试运行结果：</strong></p> 
 <p class="img-center"><img alt="" height="252" src="https://images2.imgbox.com/52/9c/UntPtHVr_o.png" width="572"></p> 
 <p></p> 
 <p><strong>        这样就测试通过了，不过需要注意的是，当前测试通过是指：目前写的业务代码是没有异常报错，但是对于逻辑是否正确，当前的测试正确与代码业务逻辑是否跟我们所想的没有任何关联，再次注意：此时的测试的通过，是指写到实际例子中没有抛异常、没有报错仅此而已，万一程序员写的实际例子考虑不周全，会导致测试覆盖面不够全面。</strong></p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>        断言机制：程序员可以通过预测业务方法的结果，从而实现测试出来的结果与我们一开始所认为的结果是否相同，从而来判断代码逻辑是否正确。</strong></span></p> 
<p><strong>断言方法的参数：</strong></p> 
<blockquote> 
 <p class="img-center"><img alt="" height="139" src="https://images2.imgbox.com/f5/c0/6jYgg5Mn_o.png" width="666"></p> 
 <p></p> 
 <p><strong>        调用静态的断言方法，第一个参数是如果预测的结果与测试出来的结果不一样时，提供的消息。第二个参数是自己预测的结果。第三个参数是测试出来的结果。</strong></p> 
</blockquote> 
<p><strong>对业务二代码进行测试：</strong></p> 
<blockquote> 
 <p><strong>业务二代码：</strong></p> 
 <pre><code class="language-java">//这是项目的业务代码
public class ProjectBusiness {

    //项目业务二:获取字符串最大的索引下标
    public static int getMaxIndex(String str){
        if (str == null){
            return 0;
        }
        return str.length();
    }
}</code></pre> 
 <p><strong>测试业务二代码：</strong></p> 
 <pre><code class="language-java">import org.junit.Assert;
import org.junit.Test;
//测试业务:对项目业务代码进行测试
public class TestBusiness {


    //对业务二代码进行测试
    @Test
    public void testGetMaxIndex(){
        //接着调用业务二的方法
        int index1 = ProjectBusiness.getMaxIndex(null);
        //进行断言
        Assert.assertEquals("此处出现 BUG 啦!!!",0,index1);

        int index2 = ProjectBusiness.getMaxIndex("你好鸭小板");
        //进行断言
        Assert.assertEquals("此处出现 BUG 啦!!!",4,index2);
    }


}</code></pre> 
 <p><strong>测试结果：</strong></p> 
 <p class="img-center"><img alt="" height="222" src="https://images2.imgbox.com/02/ef/lvVRnxnO_o.png" width="666"></p> 
 <p></p> 
 <p><strong>        这里出现了测试错误，我们预期 4 ，实际测试出来的结果是 5 。显然是我们的业务二代码逻辑与我们一开始所认为的结果不一样。</strong></p> 
 <p><strong>        现在将业务二代码逻辑进行改进：</strong></p> 
 <pre><code class="language-java">    //项目业务二:获取字符串最大的索引下标
    public static int getMaxIndex(String str){
        if (str == null){
            return 0;
        }
        return str.length()-1;
    }</code></pre> 
 <p><strong>        再来进行测试。</strong></p> 
 <p><strong>测试结果：</strong></p> 
 <p class="img-center"><img alt="" height="264" src="https://images2.imgbox.com/a2/93/kheYWZ5q_o.png" width="666"></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.2%20Junit%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%EF%BC%88Junit%204.xxx%20%E7%89%88%E6%9C%AC%EF%BC%89">        1.2 Junit 单元测试框架的常用注解（Junit 4.xxx 版本）</h3> 
<p><strong>        1）<span style="color:#fe2c24;">@Test：测试类中的方法必须用它修饰才能成为测试方法，才能启动执行。</span></strong></p> 
<p><strong>        2）<span style="color:#fe2c24;">@Before：用来修饰一个实例方法，该方法会在每一个测试方法执行之前执行一次。</span></strong></p> 
<p><strong>        3）<span style="color:#fe2c24;">@After：用来修饰一个实例方法，该方法会在每一个测试方法执行之后执行一次。</span></strong></p> 
<p><strong>        4）<span style="color:#fe2c24;">@BeforeClass：用来修饰一个静态方法，该方法会在所有测试方法之前只执行一次。</span></strong></p> 
<p><strong>        5）<span style="color:#fe2c24;">@AfterClass：用来修饰一个静态方法，该方法会在所有测试方法之后只执行一次。</span></strong></p> 
<p><strong>        在测试方法执行前执行的方法，常用于：<span style="color:#fe2c24;">初始化资源</span>。</strong></p> 
<p><strong>        在测试方法执行后执行的方法。常用于：<span style="color:#fe2c24;">释放资源</span>。</strong></p> 
<p><strong>代码演示：</strong></p> 
<blockquote> 
 <pre><code class="language-java">import org.junit.*;

//测试业务:对项目业务代码进行测试
public class TestBusiness {

    //在执行全部测试方法之前，先执行以下代码
    @BeforeClass
    public static void bfc(){
        System.out.println("在执行bfc方法，在全部测试方法之前执行且只执行一次");
    }

    //执行每个测试代码之前都会先执行以下的方法
    @Before
    public void bf(){
        System.out.println("在执行bf方法啦!!!");
    }

    //执行每个测试代码之后都会执行以下的方法
    @After
    public void at(){
        System.out.println("在执行at方法啦!!!");
    }

    
    //在执行全部测试方法之后，再执行以下代码
    @AfterClass
    public static void atc(){
        System.out.println("在执行atc方法，在全部测试方法之后执行且只执行一次");
    }


    //针对每一个方法进行测试，定义测试方法必须是公开、无参、无返回值
    //对业务一代码进行测试
    //记得要加上注解
    @Test
    public void testPrintLength(){
        //然后调用业务一的代码，列举实际例子
        ProjectBusiness.printLength("你好世界!!!");
        ProjectBusiness.printLength("你好小板");
        ProjectBusiness.printLength(null);
        System.out.println("业务代码一执行完毕！！！");
    }

    //对业务二代码进行测试
    @Test
    public void testGetMaxIndex(){
        //接着调用业务二的方法
        int index1 = ProjectBusiness.getMaxIndex(null);
        //进行断言
        Assert.assertEquals("此处出现 BUG 啦!!!",0,index1);

        int index2 = ProjectBusiness.getMaxIndex("你好鸭小板");
        //进行断言
        Assert.assertEquals("此处出现 BUG 啦!!!",4,index2);
        System.out.println("业务代码二执行完毕！！！");
    }
    
}</code></pre> 
 <p><strong>全部测试方法的结果：</strong></p> 
 <p class="img-center"><img alt="" height="34" src="https://images2.imgbox.com/be/5d/3fItmuWu_o.png" width="525"></p> 
</blockquote> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.0%20%E5%8F%8D%E5%B0%84%E6%A6%82%E8%BF%B0">        2.0 反射概述</h2> 
<p><strong>        Java 反射是指在运行时动态地获取类的信息、调用类的方法、操作类的属性等能力。Java 反射机制提供了一种在运行时检查类、接口、字段和方法的能力，而不需要在编译时就知道这些信息。</strong></p> 
<p><strong>        使用 Java 反射，可以在运行时动态地加载类、创建对象、调用方法、访问属性等，这为编写灵活的、可扩展的程序提供了便利。反射机制允许程序在运行时获取类的信息，甚至可以动态地修改类的行为。</strong></p> 
<p><span style="color:#fe2c24;"><strong>        简单来说：反射是在类加载之后对类进行操作的一种机制，允许以编程的方式解剖类中的各种成分（构造器、成员变量、成员方法等）。</strong></span></p> 
<p><strong>反射过程：</strong></p> 
<p><strong>        1）反射第一步：加载类、获取类的字节码：Class 对象。</strong></p> 
<p><strong>        2）获取类的构造器：Constructor 对象</strong></p> 
<p><strong>        3）获取类的成员变量：Field 对象</strong></p> 
<p><strong>        4）获取类的成员方法：Method 对象</strong></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1%20%E8%8E%B7%E5%8F%96%20Class%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F">        2.1 获取 Class 对象的三种方式</h3> 
<p><strong>第一种方式：</strong></p> 
<p><span style="color:#fe2c24;"><strong>        Class c1 = 类名.class</strong></span></p> 
<blockquote> 
 <pre><code class="language-java">public class demo1 {
    public static void main(String[] args) throws ClassNotFoundException {

        //通过类名来获取Class对象
        Class c1 = Cat.class;
        System.out.println(c1.getName());

    }
}</code></pre> 
</blockquote> 
<p><strong>第二种方式：</strong></p> 
<p><span style="color:#fe2c24;"><strong>        调用 Class 提供的方法：public static Class forName(String package);</strong></span></p> 
<p><strong>        该参数名为：全类名</strong></p> 
<blockquote> 
 <pre><code class="language-java">public class demo1 {
    public static void main(String[] args) throws ClassNotFoundException {

        //通过全类名获取Class对象
        Class c2 = Class.forName("Reflection.Cat");
        System.out.println(c2.getName());

    }
}</code></pre> 
</blockquote> 
<p><strong>第三种方式：</strong></p> 
<p><span style="color:#fe2c24;"><strong>        Object 提供的方法：public Class getClass();</strong></span></p> 
<blockquote> 
 <pre><code class="language-java">public class demo1 {
    public static void main(String[] args) throws ClassNotFoundException {
        //通过对象名来获取
        Cat cat = new Cat();
        Class c3 = cat.getClass();
        System.out.println(c3.getName());
    }
}</code></pre> 
</blockquote> 
<p><strong>        以上三种获取 Class 对象都是同一个对象，因为 Cat 类的字节码文件只有一份。可以通过代码进行比较以下。</strong></p> 
<blockquote> 
 <pre><code class="language-java">public class demo1 {
    public static void main(String[] args) throws ClassNotFoundException {

        //通过类名来获取Class对象
        Class c1 = Cat.class;
        System.out.println(c1.getName());

        //通过全类名获取Class对象
        Class c2 = Class.forName("Reflection.Cat");
        System.out.println(c2.getName());
        //通过对象名来获取
        Cat cat = new Cat();
        Class c3 = cat.getClass();
        System.out.println(c3.getName());

        System.out.println(c1 == c2);
        System.out.println(c3 == c2);
        System.out.println(c1 == c3);
    }
}</code></pre> 
 <p><strong>运行结果：</strong></p> 
 <p class="img-center"><img alt="" height="229" src="https://images2.imgbox.com/bd/1e/yJfoIpq6_o.png" width="264"></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A02.2%20%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%E5%B9%B6%E5%AF%B9%E5%85%B6%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C">         2.2 获取类的构造器并对其进行操作</h3> 
<p><strong>获取构造器的方法：</strong></p> 
<p><strong>        1）<span style="color:#fe2c24;">Constructor[] getConstructors()：获取全部构造器（只能获取 public 修饰的）</span></strong></p> 
<p><strong>代码演示：</strong></p> 
<blockquote> 
 <pre><code class="language-java">import java.lang.reflect.Constructor;

public class demo2 {
    public static void main(String[] args) {
        //第一步先获取Class对象
        Class c = Cat.class;

        //第二步利用Class对象提供的方法来获取构造器
        //获取全部用 Public 修饰的构造器
        Constructor[] constructors = c.getConstructors();
        for (Constructor constructor : constructors) {
            System.out.println(constructor.getName() + " =&gt; 参数有 " + constructor.getParameterCount() + " 个");
        }

        
    }
}</code></pre> 
 <p><strong>运行结果：</strong></p> 
 <p class="img-center"><img alt="" height="130" src="https://images2.imgbox.com/bc/d9/T1IU83FH_o.png" width="345"></p> 
</blockquote> 
<p><strong>        2）<span style="color:#fe2c24;">Constructor[] getDeclaredConstructors()：获取全部构造器（只要存在就能拿到）</span></strong></p> 
<p><strong>代码演示：</strong></p> 
<blockquote> 
 <pre><code class="language-java">import java.lang.reflect.Constructor;

public class demo3 {
    public static void main(String[] args) {
        //第一步先获取Class对象
        Class c = Cat.class;

        //第二步再来获取全部构造器(即使用private修饰的构造器也可以获取到)
        Constructor[] constructors = c.getDeclaredConstructors();
        for (Constructor constructor : constructors) {
            System.out.println(constructor.getName() + " =&gt;参数有 " + constructor.getParameterCount() + " 个");
        }

    }

}</code></pre> 
 <p><strong>运行结果：</strong></p> 
 <p class="img-center"><img alt="" height="137" src="https://images2.imgbox.com/d2/7c/mC5nIwup_o.png" width="393"></p> 
</blockquote> 
<p><strong>        3）<span style="color:#fe2c24;">Constructor[] getConstructor()：获取某个构造器（只能获取 public 修饰的）</span></strong></p> 
<p><strong>代码演示：</strong></p> 
<blockquote> 
 <pre><code class="language-java">import java.lang.reflect.Constructor;

public class demo4 {
    public static void main(String[] args) throws NoSuchMethodException {
        //第一步先获取Class对象
        Class c = Cat.class;
        //第二步再获取指定的构造器
        //先获取无参的构造器
        Constructor c1 = c.getConstructor();
        System.out.println(c1.getName() + " =&gt; 参数有 " + c1.getParameterCount() + " 个");

        //获取有参的构造器
        Constructor c2 = c.getConstructor(String.class,int.class);
        System.out.println(c2.getName() + " =&gt; 参数有 " + c2.getParameterCount() + " 个");
        
    }
}</code></pre> 
 <p><strong>运行结果：</strong></p> 
 <p class="img-center"><img alt="" height="154" src="https://images2.imgbox.com/90/c1/KYTffcn1_o.png" width="310"></p> 
</blockquote> 
<p><strong>        4）<span style="color:#fe2c24;">Constructor[] getDeclaredConstructor()：获取某个构造器（只要存在就能拿到）</span></strong></p> 
<p><strong>代码演示：</strong></p> 
<blockquote> 
 <pre><code class="language-java">import java.lang.reflect.Constructor;

public class demo5 {
    public static void main(String[] args) throws NoSuchMethodException {
        //第一步先获取Class对象
        Class c = Cat.class;
        //第二步再获取指定的构造器
        //先获取无参的构造器
        Constructor c1 = c.getDeclaredConstructor();
        System.out.println(c1.getName() + " =&gt; 参数有 " + c1.getParameterCount() + " 个");

        //获取有参的构造器
        Constructor c2 = c.getDeclaredConstructor(String.class,int.class);
        System.out.println(c2.getName() + " =&gt; 参数有 " + c2.getParameterCount() + " 个");
    }
}</code></pre> 
 <p><strong>运行结果：</strong></p> 
 <p class="img-center"><img alt="" height="125" src="https://images2.imgbox.com/5e/34/r18N75xI_o.png" width="341"></p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>获取类构造器的作用：</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>        利用获取的构造器来创建对象。</strong></span></p> 
<p><strong>Constructor 提供的方法：</strong></p> 
<p><strong>        1）<span style="color:#fe2c24;">T newInstance(Object)</span>：调用次构造器对象表示的构造器，并传入参数，完成对象的初始化并返回。</strong></p> 
<p><strong>        2）<span style="color:#fe2c24;">public void setAccessible(boolean flag)</span>：设置为 true ，表示禁止检查访问控制（暴力反射）。</strong></p> 
<p><strong>代码演示：</strong></p> 
<blockquote> 
 <p><strong>Cat 类</strong></p> 
 <pre><code class="language-java">public class Cat {
    String name;
    int age;

    public Cat(){

    }

    private Cat(String name,int age){
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Cat{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}</code></pre> 
 <p><strong>利用反射获取有参构造器，来创建 Cat 对象：</strong></p> 
 <pre><code class="language-java">import java.lang.reflect.Constructor;

public class demo6 {
    public static void main(String[] args) throws Exception {
        //第一步先获取Class对象
        Class c = Cat.class;
        //第二步再获取构造器
        Constructor constructor = c.getDeclaredConstructor(String.class,int.class);
        //由于Cat类中的有参构造器是private修饰的，所以需要设置禁止检查
        constructor.setAccessible(true);
        //最后再来利用获取的构造器来创建Cat对象
        Cat cat = (Cat) constructor.newInstance("小板",2);
        //再来查看对象是否创建成功
        System.out.println(cat);
    }
}</code></pre> 
 <p><strong>运行结果：</strong></p> 
 <p class="img-center"><img alt="" height="112" src="https://images2.imgbox.com/56/1a/Kw0bRd7a_o.png" width="275"></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%20%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">        2.3 获取类的成员变量</h3> 
<p><strong>Class 提供从类中获取成员变量的方法：</strong></p> 
<p><strong>        1）<span style="color:#fe2c24;">public Field[] getFields()：获取类的全部成员变量（只能获取 public 修饰的）</span></strong></p> 
<p><strong>代码演示：</strong></p> 
<blockquote> 
 <pre><code class="language-java">import java.lang.reflect.Field;

public class demo7 {
    public static void main(String[] args) {
        //先获取Class对象
        Class c = Cat.class;
        //再获取成员变量(只能获取全部的public修饰的成员变量)
        Field[] fields = c.getFields();
        for (Field field : fields) {
            System.out.println(field.getName());
        }
    }
}</code></pre> 
 <p><strong>运行结果：</strong></p> 
 <p class="img-center"><img alt="" height="123" src="https://images2.imgbox.com/52/28/G0YGuvFK_o.png" width="202"></p> 
</blockquote> 
<p><strong>        2）<span style="color:#fe2c24;">public Field[] getDeclaredFields()：获取类的全部成员变量（只要存在就能拿到）</span></strong></p> 
<p><strong>代码演示：</strong></p> 
<blockquote> 
 <pre><code class="language-java">import java.lang.reflect.Field;

public class demo7 {
    public static void main(String[] args) {
        //先获取Class对象
        Class c = Cat.class;
        //再获取成员变量(只能获取全部的成员变量)
        Field[] fields = c.getDeclaredFields();
        for (Field field : fields) {
            System.out.println(field.getName());
        }
    }
}</code></pre> 
 <p><strong>运行结果：</strong></p> 
 <p class="img-center"><img alt="" height="123" src="https://images2.imgbox.com/e9/26/FpWhN3JZ_o.png" width="202"></p> 
</blockquote> 
<p><strong>        3）<span style="color:#fe2c24;">public Field[] getField(String name)：获取类的某个成员变量（只能获取 public 修饰的）</span></strong></p> 
<p><strong>代码演示：</strong></p> 
<blockquote> 
 <pre><code class="language-java">import java.lang.reflect.Field;

public class demo8 {
    public static void main(String[] args) throws NoSuchFieldException {
        Class c = Cat.class;
        //根据名字来获取变量对象
        Field fieldName = c.getField("name");
        System.out.println(fieldName.getName());

        Field fieldAge = c.getField("age");
        System.out.println(fieldAge.getName());
    }
}</code></pre> 
 <p><strong>运行结果：</strong></p> 
 <p class="img-center"><img alt="" height="118" src="https://images2.imgbox.com/b6/f9/i2Mok71o_o.png" width="204"></p> 
</blockquote> 
<p><strong>        4）<span style="color:#fe2c24;">public Field[] getDeclaredField(String name)：获取类的某个成员变量（只要存在就能拿到）</span></strong></p> 
<p><strong>代码演示：</strong></p> 
<blockquote> 
 <pre><code class="language-java">import java.lang.reflect.Field;

public class demo8 {
    public static void main(String[] args) throws NoSuchFieldException {
        Class c = Cat.class;
        //根据名字来获取变量对象
        Field fieldName = c.getDeclaredField("name");
        System.out.println(fieldName.getName());

        Field fieldAge = c.getDeclaredField("age");
        System.out.println(fieldAge.getName());
    }
}</code></pre> 
 <p><strong>运行结果：</strong></p> 
 <p class="img-center"><img alt="" height="118" src="https://images2.imgbox.com/21/99/ivEqyg0s_o.png" width="204"></p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>获取到成员变量的作用：</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>        获取到的成员变量对象可以用来赋值、取值操作。</strong></span></p> 
<p><strong>常用方法：</strong></p> 
<p><strong>        1）<span style="color:#fe2c24;">void set(Object obj,Object value)</span>：赋值，第一个参数为 Cat 实例对象，第二个参数为需要赋值为 value 。</strong></p> 
<p><strong>        2）<span style="color:#fe2c24;">Object get(Object obj)</span>：取值，参数为 Cat 实例对象。</strong></p> 
<p><strong>        3）<span style="color:#fe2c24;">public void setAccessible(boolean flag)</span>：设置为 true ，表示禁止检查访问控制（暴力反射）</strong></p> 
<p><strong>代码演示：</strong></p> 
<blockquote> 
 <pre><code class="language-java">import java.lang.reflect.Field;

public class demo9 {
    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
        //先获取class对象
        Class c = Cat.class;

        //Cat 的实例对象
        Cat cat = new Cat();
        //再获取变量对象
        Field fieldName = c.getDeclaredField("name");
        Field fieldAge = c.getDeclaredField("age");

        //禁止检查访问控制
        fieldName.setAccessible(true);
        fieldAge.setAccessible(true);
        //进行赋值操作
        fieldName.set(cat,"小板");
        fieldAge.set(cat,2);

        //再进行取值操作
        String name = (String) fieldName.get(cat);
        int age = (int) fieldAge.get(cat);

        //查看是否赋值成功
        System.out.println(cat);

    }
}</code></pre> 
 <p><strong>运行结果：</strong></p> 
 <p class="img-center"><img alt="" height="111" src="https://images2.imgbox.com/64/0a/2B3CCp8j_o.png" width="288"></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.4%20%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95">        2.4 获取类的成员方法</h3> 
<p><strong>Class 提供了从类中获取成员方法的 API ：</strong></p> 
<p><strong>        1）<span style="color:#fe2c24;">Method[] getMethods()：获取类的全部成员方法（只能获取 public 修饰的方法）</span></strong></p> 
<p><strong>代码演示：</strong></p> 
<blockquote> 
 <pre><code class="language-java">
import java.lang.reflect.Method;
import java.util.Arrays;

public class demo10 {
    public static void main(String[] args) {
        //先获取class对象
        Class c = Cat.class;
        //再获取全部public修饰的方法
        Method[] methods = c.getMethods();
        for (Method method : methods) {
            System.out.println(method.getName() + " =&gt;" + Arrays.toString(method.getParameterTypes()) +  " =&gt; " + method.getReturnType());
        }
    }
}</code></pre> 
 <p><strong>运行结果：</strong></p> 
 <p class="img-center"><img alt="" height="335" src="https://images2.imgbox.com/54/9a/LsGP0R29_o.png" width="400"></p> 
</blockquote> 
<p><strong>        2）<span style="color:#fe2c24;">Method[] getDeclaredMethods()：获取类的全部成员方法（只要存在就能拿到）</span></strong></p> 
<p><strong>代码演示：</strong></p> 
<blockquote> 
 <pre><code class="language-java">import java.lang.reflect.Method;
import java.util.Arrays;

public class demo10 {
    public static void main(String[] args) {
        //先获取class对象
        Class c = Cat.class;
        //再获取全部public修饰的方法
        Method[] methods = c.getDeclaredMethods();
        for (Method method : methods) {
            System.out.println(method.getName() + " =&gt;" + Arrays.toString(method.getParameterTypes()) +  " =&gt; " + method.getReturnType());
        }
    }
}</code></pre> 
 <p><strong>运行结果：</strong></p> 
 <p class="img-center"><img alt="" height="167" src="https://images2.imgbox.com/9d/6d/NsAt4d4T_o.png" width="400"></p> 
</blockquote> 
<p><strong>        3）<span style="color:#fe2c24;">Method getMethod(String name,参数类型)：获取类的某个成员方法（只能获取 public 修饰的）</span></strong></p> 
<p><strong>代码演示：</strong></p> 
<blockquote> 
 <pre><code class="language-java">import java.lang.reflect.Method;
import java.util.Arrays;

public class demo11 {
    public static void main(String[] args) throws Exception {
        
        //先获取class对象
        Class c = Cat.class;
        //再获取指定方法
        Method setNameMethod = c.getMethod("setName", String.class);
        System.out.println(setNameMethod.getName() + " =&gt; " + Arrays.toString(setNameMethod.getParameterTypes()) + " =&gt; " + setNameMethod.getReturnType());
        
    }
}</code></pre> 
 <p><strong>运行结果：</strong></p> 
 <p class="img-center"><img alt="" height="99" src="https://images2.imgbox.com/da/ca/U5KcX4qO_o.png" width="500"></p> 
</blockquote> 
<p><strong>        4）<span style="color:#fe2c24;">Method getDeclaredMethod(String name,参数类型)：获取类的某个成员方法（只要存在就能拿到）</span></strong></p> 
<p><strong>代码演示：</strong></p> 
<blockquote> 
 <pre><code class="language-java">import java.lang.reflect.Method;
import java.util.Arrays;

public class demo11 {
    public static void main(String[] args) throws Exception {

        //先获取class对象
        Class c = Cat.class;
        //再获取指定方法
        Method setNameMethod = c.getDeclaredMethod("setName", String.class);
        System.out.println(setNameMethod.getName() + " =&gt; " + Arrays.toString(setNameMethod.getParameterTypes()) + " =&gt; " + setNameMethod.getReturnType());

    }
}</code></pre> 
 <p><strong>运行结果：</strong></p> 
 <p class="img-center"><img alt="" height="95" src="https://images2.imgbox.com/c0/5a/ErS1Ajzx_o.png" width="459"></p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>成员方法的作用：</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>        执行某个对象的方法。</strong></span></p> 
<p><strong>Methos 提供的方法：</strong></p> 
<p><strong>        1）<span style="color:#fe2c24;">public Object invoke(Object obj,方法的参数)：触发某个对象的该方法执行。</span></strong></p> 
<p><strong>        2）<span style="color:#fe2c24;">public void setAccessible(boolean flag)：设置为 true ，表示禁止检查访问控制（暴力反射）</span></strong></p> 
<p><strong>代码演示：</strong></p> 
<blockquote> 
 <pre><code class="language-java">import java.lang.reflect.Method;

public class demo12 {
    public static void main(String[] args) throws Exception {
        //先获取class对象
        Class c = Cat.class;

        //Cat对象
        Cat cat = new Cat();
        //再来获取指定的方法来设置名字,年龄
        Method setNameMethod = c.getDeclaredMethod("setName", String.class);
        setNameMethod.setAccessible(true);
        setNameMethod.invoke(cat,"小板");

        Method setAgeMethod = c.getDeclaredMethod("setAge", int.class);
        setNameMethod.setAccessible(true);
        setAgeMethod.invoke(cat,2);

        //查看是否设置成功
        Method getNameMethod = c.getDeclaredMethod("getName");
        getNameMethod.setAccessible(true);
        String name = (String) getNameMethod.invoke(cat);
        System.out.println(name);

        Method getAgeMethod = c.getDeclaredMethod("getAge");
        getAgeMethod.setAccessible(true);
        int age = (int) getAgeMethod.invoke(cat);
        System.out.println(age);

        System.out.println(cat);
    }
}</code></pre> 
 <p><strong>运行结果：</strong></p> 
 <p class="img-center"><img alt="" height="152" src="https://images2.imgbox.com/65/77/Y5tMV1MX_o.png" width="305"></p> 
</blockquote> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E5%81%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%89%88%E7%9A%84%E6%A1%86%E6%9E%B6">        3.0 使用反射做一个简易版的框架</h2> 
<p><strong>        需求：对于任意一个对象，该框架都可以把对象的字段名和对应的值，保存到文件中去。</strong></p> 
<p><strong>实现步骤：</strong></p> 
<p><span style="color:#fe2c24;"><strong>        1）定义一个方法，可以接收任意对象。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>        2）每收到一个对象后，使用反射获取该对象的 class 对象，然后获取全部成员变量。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>        3）遍历成员遍历，然后提取成员变量在该对象中具体的值。</strong></span></p> 
<p><strong><span style="color:#fe2c24;">        4）把成员变量名和值，写出到文件中即可。</span></strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <p><strong>学生类：</strong></p> 
 <pre><code class="language-java">public class Student {
    public String name;
    public int age;
    public double height;
    public String gender;
    public String description;

    public Student(String name, int age, double height, String gender, String description) {
        this.name = name;
        this.age = age;
        this.height = height;
        this.gender = gender;
        this.description = description;
    }
}</code></pre> 
 <p><strong>老师类：</strong></p> 
 <pre><code class="language-java">public class Teacher {
    public String name;
    public int age;
    public double height;
    public String gender;
    public String description;

    public Teacher(String name, int age, double height, String gender, String description) {
        this.name = name;
        this.age = age;
        this.height = height;
        this.gender = gender;
        this.description = description;
    }
}
</code></pre> 
 <p><strong>核心业务代码：</strong></p> 
 <pre><code class="language-java">import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.lang.reflect.Field;

public class Project {

    public static void business(Object obj) throws IllegalAccessException, FileNotFoundException {
        //创建I/O对象，可追加
        PrintStream ps = new PrintStream(new FileOutputStream("D:\\software\\code\\2023_java\\2023_java_code\\code_24_5_3\\src\\Reflection\\Text.text",true));

        //先获取class对象
        Class c = obj.getClass();
        ps.println("==============" + c.getName() + "==============");

        //再获取全部成员变量
        Field[] fields = c.getDeclaredFields();
        //将其进行遍历
        for (Field field : fields) {
            String name = field.getName();
            String value = field.get(obj) + "";
            ps.println(name + " =&gt; " + value);
        }

        //记得关闭资源
        ps.close();
    }
}</code></pre> 
 <p><strong>对业务代码进行测试：</strong></p> 
 <pre><code class="language-java">import org.junit.Test;

import java.io.FileNotFoundException;

public class TestProject {

    //对该项目业务进行测试:
    @Test
    public void testProject() throws FileNotFoundException, IllegalAccessException {
        Teacher teacher = new Teacher("小板",20,175.5,"男","热爱学习技术且分享技术");
        Teacher teacher1 = new Teacher("小狗",22,179.5,"男","热爱骨头且分享骨头");
        Teacher teacher2 = new Teacher("小扳手",22,174.5,"男","热爱奋斗");

        Student student = new Student("小童",21,170.0,"女","爱笑");
        Student student1 = new Student("小黑",20,178.0,"女","爱哭");

        Project.business(teacher);
        Project.business(teacher1);
        Project.business(teacher2);
        Project.business(student);
        Project.business(student1);

    }
}</code></pre> 
 <p><strong>测试结果：</strong></p> 
 <p class="img-center"><img alt="" height="213" src="https://images2.imgbox.com/ee/d4/0SweyUE4_o.png" width="400"></p> 
 <p></p> 
 <p><strong>生成的文件：</strong></p> 
 <p class="img-center"><img alt="" height="525" src="https://images2.imgbox.com/1c/8e/MWSWp5fz_o.png" width="284"></p> 
</blockquote> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/37/4b/CzBkow5D_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f94025af85b19b7b51b54d2e71bd8e11/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">删除链表中等于给定值 val 的所有结点（三种方法深入解析）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4c5bde7cb86c8ebbc8d506d31dd7c4cd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">初始Java篇（JavaSE基础语法）（7）抽象类和接口（上）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>