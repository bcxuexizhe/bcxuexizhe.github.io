<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java抽象类：为何它是你代码架构的基石？ - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/7575b50c4241b995281c7a759d597341/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Java抽象类：为何它是你代码架构的基石？">
  <meta property="og:description" content="目录
1、抽象类的概念
2、抽象类语法
3、抽象类特性
4、抽象类的作用 5、 完结散花
个人主页：秋风起，再归来~
文章专栏：javaSE的修炼之路 个人格言：悟已往之不谏，知来者犹可追
克心守己，律己则安！
1、抽象类的概念 在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果 一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。 比如：
在打印图形例子中, 我们发现, 父类 Shape 中的 draw 方法好像并没有什么实际工作, 主要的绘制图形都是由 Shape 的各种子类的 draw 方法来完成的. 像这种没有实际工作的方法, 我们可以把它设计成一个 抽象方法(abstract method), 包含抽象方法的类我们称为 抽象类(abstract class).
2、抽象类语法 在Java中，一个类如果被 abstract 修饰称为抽象类，抽象类中被 abstract 修饰的方法称为抽象方法，抽象方法不用 给出具体的实现体。
// 抽象类：被abstract修饰的类 public abstract class Shape { // 抽象方法：被abstract修饰的方法，没有方法体 abstract public void draw(); abstract void calcArea(); // 抽象类也是类，也可以增加普通方法和属性 public double getArea(){ return area; } protected double area; // 面积 } 注意：抽象类也是类，内部可以包含普通方法和属性，甚至构造方法">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-13T21:27:02+08:00">
    <meta property="article:modified_time" content="2024-05-13T21:27:02+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java抽象类：为何它是你代码架构的基石？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><a id="AI_0"></a></h3> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="1%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">1、抽象类的概念</a></p> 
<p id="2%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%AF%AD%E6%B3%95-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%AF%AD%E6%B3%95" rel="nofollow">2、抽象类语法</a></p> 
<p id="3%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%89%B9%E6%80%A7-toc" style="margin-left:0px;"><a href="#3%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%89%B9%E6%80%A7" rel="nofollow">3、抽象类特性</a></p> 
<p id="4%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%C2%A0-toc" style="margin-left:0px;"><a href="#4%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%C2%A0" rel="nofollow">4、抽象类的作用 </a></p> 
<p id="3.%20%E5%AE%8C%E7%BB%93%E6%95%A3%E8%8A%B1-toc" style="margin-left:0px;"><a href="#3.%20%E5%AE%8C%E7%BB%93%E6%95%A3%E8%8A%B1" rel="nofollow">5、 完结散花</a></p> 
<hr id="hr-toc"> 
<p></p> 
<blockquote> 
 <p></p> 
 <p class="img-center"><img alt="" height="270" src="https://images2.imgbox.com/f2/7b/1Dy9HTLT_o.jpg" width="424"></p> 
 <p>                                                                                <a href="https://blog.csdn.net/2301_80221228?spm=1010.2135.3001.5343" title="个人主页：秋风起，再归来~">个人主页：秋风起，再归来~</a></p> 
 <p>                                                             <a href="http://t.csdnimg.cn/iayyH" rel="nofollow" title="  ">  </a>                 <a href="http://t.csdnimg.cn/IkMRG" rel="nofollow" title="文章专栏：javaSE的修炼之路 ">文章专栏：javaSE的修炼之路 </a>                               </p> 
 <p>                                                                        <span style="color:#956fe7;"><strong>个人格言：悟已往之不谏，知来者犹可追</strong></span></p> 
 <p><span style="color:#956fe7;"><strong>                                                                                        克心守己，律己则安！</strong></span></p> 
</blockquote> 
<h2 id="1%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5"><strong>1、抽象类的概念</strong></h2> 
<p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，<strong><span style="background-color:#ffd900;">如果 一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类</span></strong>。 比如：</p> 
<p><img alt="" height="421" src="https://images2.imgbox.com/1c/23/tC1axREm_o.png" width="968"></p> 
<p><img alt="" height="471" src="https://images2.imgbox.com/fd/b2/tZNDFRxB_o.png" width="924"> 在打印图形例子中, 我们发现, <strong>父类 Shape 中的 draw 方法好像并没有什么实际工作, </strong>主要的绘制图形都是由 <strong>Shape 的各种子类的 draw 方法来完成的</strong>. 像这种没有实际工作的方法, <strong>我们可以把它设计成一个 抽象方法(abstract method), 包含抽象方法的类我们称为 抽象类(abstract class).</strong></p> 
<h2 id="2%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%AF%AD%E6%B3%95"><strong>2、抽象类语法</strong></h2> 
<p>在Java中，一个类如果被 abstract 修饰称为抽象类，抽象类中被 abstract 修饰的方法称为抽象方法，抽象方法不用 给出具体的实现体。</p> 
<pre><code class="hljs">// 抽象类：被abstract修饰的类
public abstract class Shape {
    // 抽象方法：被abstract修饰的方法，没有方法体
    abstract public void draw();
    abstract void calcArea();
 
    // 抽象类也是类，也可以增加普通方法和属性
    public double getArea(){
        return area;
   }
 
    protected double area;    // 面积
}</code></pre> 
<p><strong><span style="background-color:#ffd900;">注意：抽象类也是类，内部可以包含普通方法和属性，甚至构造方法</span></strong></p> 
<h2 id="3%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%89%B9%E6%80%A7"><strong>3、抽象类特性</strong></h2> 
<p><strong><span style="color:#0d0016;"><span style="background-color:#a2e043;">1. 抽象类不能直接实例化对象</span></span></strong></p> 
<pre><code class="hljs">abstract class shape {
    abstract public void draw();
}

public class Main {
    public static void main(String[] args) {
    shape s=new shape();//编译报错
    }
}</code></pre> 
<p class="img-center"><img alt="" height="339" src="https://images2.imgbox.com/fe/db/nM2ZpbiO_o.png" width="500"></p> 
<p><strong><span style="background-color:#a2e043;">2. 抽象方法不能是 private 的</span></strong></p> 
<pre><code class="hljs">abstract class shape {
    abstract private void draw();//编译报错
}

public class Main {
    public static void main(String[] args) {
    shape s=new shape();//编译报错
    }
}</code></pre> 
<p><img alt="" height="370" src="https://images2.imgbox.com/a7/7a/tzD5tCJB_o.png" width="840"></p> 
<p><strong><span style="background-color:#a2e043;">3. 抽象方法不能被ﬁnal和static修饰，因为抽象方法要被子类重写</span></strong></p> 
<pre><code class="hljs">abstract class shape {
    abstract static public void methodA();//编译报错
    abstract final public void methodB();//编译报错

}

public class Main {
    public static void main(String[] args) {
    shape s=new shape();//编译报错
    }
}</code></pre> 
<p class="img-center"><img alt="" height="298" src="https://images2.imgbox.com/1f/ac/EzZbqtfF_o.png" width="500"></p> 
<p><strong><span style="background-color:#a2e043;">4. 抽象类必须被继承，并且继承后子类要重写父类中的抽象方法，否则子类也是抽象类，必须要使用 abstract 修 饰</span></strong></p> 
<p><strong><span style="background-color:#ffd900;">当子类不为抽象类时，没有对父类中的抽象方法进行重写就会报错！</span></strong></p> 
<pre><code class="hljs">abstract class Shape {
    abstract  public void draw();//抽象方法
}
 class  Rect extends Shape{

}

public class Main {
    public static void main(String[] args) {
    }
}</code></pre> 
<p><img alt="" height="523" src="https://images2.imgbox.com/db/2b/DKsaUVz5_o.png" width="992"></p> 
<p><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;"> 重写后就不会报错！</span></strong></span></p> 
<pre><code class="hljs">abstract class Shape {
    abstract  public void draw();//抽象方法
}
abstract class  Rect extends Shape{

}

public class Main {
    public static void main(String[] args) {
    }
}</code></pre> 
<p><img alt="" height="469" src="https://images2.imgbox.com/ab/5e/XvBFAcMu_o.png" width="834"></p> 
<p><strong><span style="background-color:#ffd900;">当子类也被abstract修饰时，就算不重写也 不会报错！</span></strong></p> 
<p><img alt="" height="357" src="https://images2.imgbox.com/dc/0f/MX4NonX9_o.png" width="830"> </p> 
<p><strong><span style="background-color:#a2e043;">5. 抽象类中不一定包含抽象方法，但是有抽象方法的类一定是抽象类 </span></strong></p> 
<p><strong><span style="background-color:#a2e043;">6. 抽象类中可以有构造方法，供子类创建对象时，初始化父类的成员变量</span></strong></p> 
<h2 id="4%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%C2%A0"><strong>4、抽象类的作用 </strong></h2> 
<p>抽象类本身不能被实例化, 要想使用, 只能创建该抽象类的子类. 然后让子类重写抽象类中的抽象方法.</p> 
<p><u><strong>普通的类也可以被继承呀, 普通的方法也可以被重写呀, 为啥非得用抽象类和抽象方法 呢?</strong></u></p> 
<p><span style="color:#fe2c24;"><strong>确实如此. 但是使用抽象类相当于多了一重编译器的校验.</strong></span></p> 
<p>使用抽象类的场景就如上面的代码, 实际工作不应该由父类完成, 而应由子类完成. 那么此时如果不小心误用成父类 了, 使用普通类编译器是不会报错的. 但是父类是抽象类就会在实例化的时候提示错误, 让我们尽早发现问题.</p> 
<p>很多语法存在的意义都是为了 "预防出错", 例如我们曾经用过的 ﬁnal 也是类似. 创建的变量用户不去修改, 不 就相当于常量嘛? 但是加上 ﬁnal 能够在不小心误修改的时候, 让编译器及时提醒我们. 充分利用编译器的校验, 在实际开发中是非常有意义的.</p> 
<h2 id="3.%20%E5%AE%8C%E7%BB%93%E6%95%A3%E8%8A%B1" style="background-color:transparent;">5、 完结散花</h2> 
<p><span style="color:#956fe7;"><strong><em>好了，这期的分享到这里就结束了~</em></strong></span></p> 
<p><span style="color:#956fe7;"><strong><em>如果这篇博客对你有帮助的话，可以用你们的小手指点一个免费的赞并收藏起来哟~</em></strong></span></p> 
<p><span style="color:#956fe7;"><strong><em>如果期待博主下期内容的话，可以点点关注，避免找不到我了呢~</em></strong></span></p> 
<p><span style="color:#956fe7;"><strong><em>我们下期不见不散~~</em></strong></span></p> 
<p><img alt="" height="240" src="https://images2.imgbox.com/a4/79/zni6CKSZ_o.gif" width="240">​<img alt="" height="142" src="https://images2.imgbox.com/d9/c3/AWmhkebx_o.gif" width="200">​</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b072da5962d0dd6154a42aa04aa483b6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2024年大数据最全腾讯T4专家精心整理：大数据&#43;机器学习&#43;数据挖掘&#43;算法大集结(1)，2024年最新大数据开发开发框架</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/46ebb4bda2cbdfa76a6f790f9f0f8b6d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构】详解队列</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>