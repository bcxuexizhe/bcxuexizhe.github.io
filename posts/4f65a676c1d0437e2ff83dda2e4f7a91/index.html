<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>网络编程 —— Http进度条 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/4f65a676c1d0437e2ff83dda2e4f7a91/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="网络编程 —— Http进度条">
  <meta property="og:description" content="第一种下载带进度的方法 string url = &#34;https://nodejs.org/dist/v20.10.0/node-v20.10.0-x64.msi&#34;;
1使用getASync获取服务器响应数据 参数1请求的路径，
参数2 HttpCompletionOption.ResponseHeadersRead 请求完成时候等待请求带什么程度才代表请求成功
ResponseHeadersRead 读取到响应头的时候算是请求完成， 响应头有个字段可以获取资源大小
ResponseContentRead 读取到整个响应内容算是请求完成
HttpResponseMessage res = await new HttpClient().GetAsync(url,HttpCompletionOption.ResponseHeadersRead); 2 获取url的文件名称 string fileName = Path.GetFileName(url); 3 将响应数据读取带stream对象中 Stream stream = await res.Content.ReadAsStreamAsync(); 4 记录响应数据的总大小 在响应头里面有一个ContentLength字段获取响应大小也就是下载的总大小 long all = res.Content.Headers.ContentLength ?? 0; 6 定义一个字节数组 字节数组容量是8KB的大小 byte[] bytes = new byte[1024*8]; 从数据流读取到字节数组，并且从0开始读取，到字节数组被容纳完为止
返回值是整型的，代表是读取的位置
stream.Read(bytes, 0, bytes.Length); int nowReadCount = 0; //当前读取的位置 如果读取的位置不为0，证明还有数据，还得再次读取数据
while((nowReadCount = stream.Read(bytes, 0, bytes.Length))!=0) { // 读取数据 //b把当前读取的数据写入本地 fs.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-27T20:53:44+08:00">
    <meta property="article:modified_time" content="2024-05-27T20:53:44+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">网络编程 —— Http进度条</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>第一种下载带进度的方法</h4> 
<p>string url = "https://nodejs.org/dist/v20.10.0/node-v20.10.0-x64.msi";</p> 
<h5>1使用getASync获取服务器响应数据</h5> 
<p>参数1请求的路径，<br>             参数2 HttpCompletionOption.ResponseHeadersRead 请求完成时候等待请求带什么程度才代表请求成功<br>             ResponseHeadersRead 读取到响应头的时候算是请求完成， 响应头有个字段可以获取资源大小<br>             ResponseContentRead 读取到整个响应内容算是请求完成</p> 
<pre><code class="language-cs">HttpResponseMessage res = await new HttpClient().GetAsync(url,HttpCompletionOption.ResponseHeadersRead);</code></pre> 
<h5>2 获取url的文件名称</h5> 
<pre><code class="language-cs"> string fileName = Path.GetFileName(url);</code></pre> 
<h5>3 将响应数据读取带stream对象中</h5> 
<pre><code class="language-cs">Stream stream =  await res.Content.ReadAsStreamAsync();</code></pre> 
<h5>4 记录响应数据的总大小 在响应头里面有一个ContentLength字段获取响应大小也就是下载的总大小</h5> 
<pre><code class="language-cs">long all =  res.Content.Headers.ContentLength ?? 0;</code></pre> 
<h5>6 定义一个字节数组 字节数组容量是8KB的大小</h5> 
<pre><code class="language-cs">byte[] bytes = new byte[1024*8];</code></pre> 
<p>           从数据流读取到字节数组，并且从0开始读取，到字节数组被容纳完为止<br>            返回值是整型的，代表是读取的位置<br>            stream.Read(bytes, 0, bytes.Length); </p> 
<pre><code class="language-cs">int nowReadCount = 0; //当前读取的位置</code></pre> 
<p>如果读取的位置不为0，证明还有数据，还得再次读取数据</p> 
<pre><code class="language-cs">while((nowReadCount = stream.Read(bytes, 0, bytes.Length))!=0)
{
    // 读取数据 
    //b把当前读取的数据写入本地
    fs.Write(bytes, 0, nowReadCount);
    loadByte += nowReadCount;// 记录总下载量
    Console.WriteLine(loadByte);
    //用已经下载量/总量 *100 转成百分制度。
    double progress = (double)loadByte /(double) all * 100;
    this.progressBar1.Value = (int)progress;
}
fs.Close();
MessageBox.Show("下载完成");</code></pre> 
<h4>安装第三方，Microsoft.AspNet.WebApi.Client,<br> 提供了一个下载事件，在事件函数可以获取下载进度</h4> 
<h5>1创建httpclientHandler 事件对象</h5> 
<pre><code class="language-cs">HttpClientHandler handler = new HttpClientHandler();</code></pre> 
<p>2 创建下载进度的事件对象</p> 
<pre><code class="language-cs">ProgressMessageHandler pro = new ProgressMessageHandler(handler);</code></pre> 
<h4>3 创建下载进度的事件函数</h4> 
<pre><code class="language-cs"> pro.HttpReceiveProgress += Pro_HttpReceiveProgress;</code></pre> 
<p>  Pro_HttpReceiveProgress类</p> 
<pre><code class="language-cs">private void Pro_HttpReceiveProgress(object sender, HttpProgressEventArgs e)
{
    Console.WriteLine(e.ProgressPercentage);//记录当前的进度
    //Invoke调用一个方法
    this.Invoke((Action) (() =&gt;
    {
        this.progressBar1.Value = e.ProgressPercentage;
    }));
}</code></pre> 
<h5>4 创建请求对象并且发请求，获取响应 目的是为了通知下载进度对象，再触发对应的Pro_HttpReceiveProgress函数</h5> 
<pre><code class="language-cs"> HttpClient client = new HttpClient(pro);
var res = await  client.GetAsync("https://nodejs.org/dist/v20.10.0/node-v20.10.0-x64.msi");</code></pre> 
<h5>5 读取响应数据写入本地</h5> 
<pre><code class="language-cs">var stream = await res.Content.ReadAsStreamAsync();
var fs = new FileStream("node.msi", FileMode.Create);
fs.CopyTo(fs);
fs.Close();
stream.Close();</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4177b46787bf3009afa345e780007de4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Java继承】（超级详细！！！）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/99301fb57504c8af4397cf4c6258dc45/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【学习记录】服务器转发使用tensorboard</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>