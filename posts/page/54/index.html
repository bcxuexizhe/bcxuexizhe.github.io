<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f80c0fb23f684f196a7dc6cf66024c5d/" rel="bookmark">
			【51单片机系列】proteus仿真单片机的串口通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文参考：https://zhuanlan.zhihu.com/p/425809292。
在proteus之外使用串口软件和单片机通信。通过在proteus设计一个单片机接收PC发送的数据，并将接收的数据发送出去，利用软件【Configure Virtual Serial Port Driver】创建一对虚拟串口，利用软件【串口助手】向单片机发送数据。
proteus仿真电路图如下：
COMPIM器件是COM Port Physical Interface Model串口物理端口模型。proteus中的COMPIM是标准的RS-323端口，可直接使用电脑的物理串口通信，即COMPIM是通过电脑的物理串口进行实际通信的。
也就是说proteus仿真利用COMPIM通过电脑的串口与外界的其它设备进行通信。
需要注意的是COMPIM与单片机的接法：单片机的RXD引脚与COMPIM的RXD引脚连接，单片机的TXD引脚与COMPIM的TXD引脚连接。
设置COMPIM的参数，按照需求设计。如下，设置COM端口号为COM2，波特率为9600bps。要注意单片机的波特率要和各个串口波特率一致；串口选择了COM2表示单片机在COM2逻辑上是相互的，串口上收到的信息，也就是单片机收到的信息，单片机发送的信息就会从COM3发出。
使用软件【Configure Virtual Serial Port Driver】查看或创建当前的端口号，打开软件如下。电脑中只有一个物理端口COM1，可以添加虚拟端口对，点击【Add pair】即可。这时COM2和COM3是相连的，只要在串口助手中监视COM3即可。
打开【串口调试助手】，设置相同的波特率，如下，然后打开串口监视。
编写单片机的代码，单片机接收PC（即串口助手）发送的数据，并将接收到的数据发送出来。编码如下：
/* 实现功能：串口通信，proteus仿真单片机与串口通信 接收PC机数据 [2024-01-16] zoya */ #include &lt;reg52.h&gt; typedef unsigned char u8; typedef unsigned int u16; #define GPIO_LED P1 void UsartInit() { SCON=0x50; // 串口工作方式1，接收数据 TMOD=0x20; // 定时器T1工作方式2 TH1=TL1=0xFD; // 波特率9600bps，不倍增 PCON=0x00; ES=1; // 打开串口中断允许位 EA=1; // 打开CPU中断允许位 TR1=1; // 启动计数 } void main() { UsartInit(); while(1); } void ReceiveDat() interrupt 4 { u8 tmp; if(RI) { tmp=SBUF; RI=0; SBUF=tmp; while(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f80c0fb23f684f196a7dc6cf66024c5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa95b70be6f19385e049d94be1e7eb5e/" rel="bookmark">
			实战whisper：本地化部署通用语音识别模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Whisper 是一种通用语音识别模型。它是在大量不同音频数据集上进行训练的，也是一个多任务模型，可以执行多语言语音识别、语音翻译和语言识别。
这里呢，我将给出我的一些代码，来帮助你尽快实现【语音转文字】的服务部署。
以下是该AI模块的具体使用方式：
https://github.com/openai/whisper
心得 这是一个不错的语言模型，它支持自动识别语音语种，类似中文、英文、日语等它都能胜任，并且可以实现其他语种转英语翻译的功能，支持附加时间戳的字幕导出功能......
总体来说，它甚至可以与市面上领头的语言识别功能相媲美，并且主要它是开源的。
这是它的一些模型大小、需要的GPU显存、相对执行速度的对应表
这是它在命令行模式下的使用方式，这对想要尝尝鲜的小伙伴们来说，已经够了
tips：
1、首次安装完毕whisper后，执行指令时会给你安装你所选的模型，small、medium等，我的显卡已经不支持我使用medium了 2、关于GPU版本的pytorch，可以参考如下教程（使用CPU版本会比较慢）
https://blog.csdn.net/G541788_/article/details/135437236
python调用 作为一名python从业者，我十分幸运能够读懂一些模块的相关使用，这里我通过修改了一些模块源码调用，实现了在python代码中一键导出语音字幕的功能（这些功能在命令行中已拥有，但是我希望在使用python脚本model方法后再实现该功能，可能这些你并不需要，但随意吧）。
这个模块的cli()方法或许能更好实现这一功能（因为命令行模式，其实就是运行了这个方法，但我根据经验和实际代码来看，这会重复加载model，导致不必要的资源损耗）。
1、__init__.py中加入get_writer，让你能通过whisper模块去使用这个方法
from .transcribe import get_writer 2、相关功能代码
import os.path import whisper import time # 这是语种langue参数的解释，或许对你的选择有帮助 LANGUAGES = { "en": "english", "zh": "chinese", "de": "german", "es": "spanish", "ru": "russian", "ko": "korean", "fr": "french", "ja": "japanese", "pt": "portuguese", "tr": "turkish", "pl": "polish", "ca": "catalan", "nl": "dutch", "ar": "arabic", "sv": "swedish", "it": "italian", "id": "indonesian", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa95b70be6f19385e049d94be1e7eb5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a61d4dda20e009dfd7065c873eada6b2/" rel="bookmark">
			AIGC笔记--VQVAE模型搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1--VQVAE模型 VAE 模型生成的内容质量不高，原因可能在于将图片编码成连续变量（映射为标准分布），然而将图片编码成离散变量可能会更好（因为现实生活中习惯用离散变量来形容事物，例如人的高矮胖瘦等都是离散的；）
VQVAE模型的三个关键模块：Encoder、Decoder 和 Codebook；
Encoder 将输入编码成特征向量，计算特征向量与 Codebook 中 Embedding 向量的相似性（L2距离），取最相似的 Embedding 向量作为特征向量的替代，并输入到 Decoder 中进行重构输入；
VQVAE的损失函数包括源图片和重构图片的重构损失，以及 Codebook 中量化过程的量化损失 vq_loss；
VQ-VAE详细介绍参考：轻松理解 VQ-VAE
2--简单代码实例 import torch import torch.nn as nn import torch.nn.functional as F class VectorQuantizer(nn.Module): def __init__(self, num_embeddings, embedding_dim, commitment_cost): super(VectorQuantizer, self).__init__() self._embedding_dim = embedding_dim self._num_embeddings = num_embeddings self._embedding = nn.Embedding(self._num_embeddings, self._embedding_dim) self._embedding.weight.data.uniform_(-1/self._num_embeddings, 1/self._num_embeddings) self._commitment_cost = commitment_cost def forward(self, inputs): # convert inputs from BCHW -&gt; BHWC inputs = inputs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a61d4dda20e009dfd7065c873eada6b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57f46394b726edc2def1d3910ae975ff/" rel="bookmark">
			python如何读取excel表格数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 excel的格式xls格式文件xlrdxlwtexcel读取xls类型数据三个方法 xlsx格式文件openpyxl excel的格式 excel有xls和xlsx两种格式，他们的区别在于
文件格式不同：xls是一个特有的二进制格式，其核心结构是符合文档类型的机构，而xlsx的核心结构是xml类型的结构，采用的事基于xml的压缩方式，使其占用的空间更小。xlsx中最后一个x的意义就在于此。兼容性不同，xlsx格式是向下兼容的，可以兼容xls格式。python自带的模块中有针对xls格式的xlrd和xlwt模块，但是这两个库仅仅针对xls的操作，当我们要操作xlsx格式文件时，则需要使用到openpyxl第三方库
xls格式文件 python中对xls格式文件相关的包有三个：xlrd、xlwt和xlutils
xlrd只能读取文件，不能写入文件xlwt只能写入文件，不能读取文件xlutils通过.copy.copy方法，将xlrd读取的文件复制给xlwt处理，相当于在xlrd和xlwt之间架起一座桥梁 xlrd # xls import xlrd path='11.xls' index=0 sheetname='sheet1' # 打开文件，绝对路径或者相对路径，找不到文件会报错 workbook=xlrd.open_workbook(path) # 获取文件中所有的sheet对象 sheets=workbook.sheets() # 获取文件中所有的sheet名称，返回名称列表 names=workbook.sheet_names() # 获取一个文件中有多少对象 n=workbook.nsheets # 获取对应索引的对象,索引从0开始 sheet_index=workbook.sheet_by_index(index) # 获取指定工作表的表名 name=sheet_index.name # 获取对应名字的对象 sheet_name=workbook.sheet_by_name(sheetname) print(sheet_name) # 获取xls的行和列的数量 nrows=sheet_index.nrows ncols=sheet_index.ncols # 获取工作表对应行和列的单元格组成的列表 # 元素的格式是 数值类型：对应数据 row_list=sheet_index.row(0) print(row_list,'\n') row_list=sheet_index.row(1) # print(row_list,'\n') col_list=sheet_index.col(2) # print(col_list,'\n') # 取出工作表对应行和列的值组成的列表 row_value=sheet_index.row_values(-1)# 最后一行 print(row_value,"\n") col_value=sheet_index.col_values(0) # 输出行和列 row_type=sheet_index.row_types(6)# 数据类型：0.空，1.字符串，2.数字，3.日期，4.布尔，5.error print(row_type,"\n") col_type=sheet_index.col_types(1) # 根据索引值，返回该行的长度，列没有对应操作 len=sheet_index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57f46394b726edc2def1d3910ae975ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b767b4f64a5972cd9396b46eeb591b4c/" rel="bookmark">
			【数据结构】---树：中序遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【数据结构】树—中序遍历 文章目录 【数据结构】树---中序遍历一、什么是中序遍历？二、中序遍历详解总结 一、什么是中序遍历？ 中序遍历，是数据结构中树的遍历方式之一。
特点：左、根、右。
每次遍历时，先遍历左节点的数据，之后遍历本节点，最后遍历右节点，循环往复，直至树中数据遍历完成。
二、中序遍历详解 这是一棵二叉查找树。
以该树为例，如何进行中序遍历？请看我一步步的画图演示。
左根右，指的是遍历的顺序，先遍历左节点，再遍历根节点，最后遍历右节点。
以下图为例，我们进行中序遍历：
10是根节点，先查10的左节点，查到了5节点。
将5当作暂时的根节点，先查5的左节点，查到了3节点。
将3当作暂时的根节点，先查3的左节点，3没有左节点，于是返回至3节点，输出3。
3的左节点、3本身都已经遍历完成，接下来查3的右节点，查到了4节点
将4当作暂时的根节点，先查4的左节点，4没有左节点，于是返回至4节点，输出4。
4的左节点、4本身都已经遍历完成，接下来查4的右节点，4没有右节点，于是返回至4节点。
此时4的左节点、4本身、4的右节点都已经遍历完成，返回其上一级节点：3节点。
此时3的左节点、3本身、3的右节点都已经遍历完成，返回其上一级节点：5节点。
此时5的左节点已经遍历完成，输出5。
5的左节点、5本身都已经遍历完成，接下来查5的右节点，查到了9节点。
将9当作暂时的根节点，先查9的左节点，9没有左节点，于是返回至9节点，输出9。
9的左节点、9本身都已经遍历完成，接下来查9的右节点，9没有右节点，于是返回至9节点。
此时9的左节点、9本身、9的右节点都已经遍历完成，返回其上一级节点：5节点。
此时5的左节点、5本身、5的右节点都已经遍历完成，返回其上一级节点：10节点。
此时10的左节点已经遍历完成，输出10。
10的左节点、10本身都已经遍历完成，接下来查10的右节点，查到了18节点
将18当作暂时的根节点，先查18的左节点，18没有左节点，于是返回至18节点，输出18。
18的左节点、18本身都已经遍历完成，接下来查18的右节点，查到了21节点。
将21当作暂时的根节点，先查21的左节点，查到了19节点。
将19当作暂时的根节点，先查19的左节点，19没有左节点，于是返回至19节点，输出19。
19的左节点、19本身都已经遍历完成，接下来查19的右节点，19没有右节点，于是返回至19节点。
此时19的左节点、19本身、19的右节点都已经遍历完成，返回其上一级节点：21节点。
此时21的左节点已经遍历完成，输出21。
21的左节点、21本身都已经遍历完成，接下来查21的右节点，查到了59节点。
将59当作暂时的根节点，先查59的左节点，查到了33节点。
将33当作暂时的根节点，先查33的左节点，33没有左节点，于是返回至33节点，输出33。
33的左节点、33本身都已经遍历完成，接下来查33的右节点，33没有右节点，于是返回至33节点。
此时33的左节点、33本身、33的右节点都已经遍历完成，返回其上一级节点：59节点。
此时59的左节点已经遍历完成，输出59。
59的左节点、59本身都已经遍历完成，接下来查59的右节点，59没有右节点，于是返回至59节点。
此时59的左节点、59本身、59的右节点都已经遍历完成，返回其上一级节点：21节点。
此时21的左节点、21本身、21的右节点都已经遍历完成，返回其上一级节点：18节点。
此时18的左节点、18本身、18的右节点都已经遍历完成，返回其上一级节点：10节点。
此时根节点10的左节点、根节点本身、根节点的右节点都已经遍历完成，这棵树的中序遍历完成。
遍历结果：
[3，4，5，9，10，18，19，21，33，59]
我们可以发现，二叉查找树经过中序遍历后，会变得有序，当然，这个顺序是依靠二叉查找树的排序规则来进行的。如果排序规则是左边大，右边小，那么经过中序遍历后的序列会是倒序的。
总结 二叉查找树进行中序遍历后，返回的序列是排好序的。
数据结构方面的内容刚刚接触，讲解不够深刻，还望谅解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a61562dc651102bc5611e165b571811/" rel="bookmark">
			mysql-实战案例 （超详细版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎉欢迎您来到我的MySQL基础复习专栏
☆* o(≧▽≦)o *☆哈喽~我是小小恶斯法克🍹
✨博客主页：小小恶斯法克的博客
🎈该系列文章专栏：重拾MySQL
🍹文章作者技术和水平很有限，如果文中出现错误，希望大家能指正🙏
📜 感谢大家的关注！ ❤️
​ 目录
🚀​​​​​​多表查询综合案例
✨查询员工的姓名、年龄、职位、部门信息 （隐式内连接，需要消除笛卡尔积）
✨查询年龄小于29岁的员工的姓名、年龄、职位、部门信息（显式内连接）
✨查询拥有员工的部门ID、部门名称 （难点在于有一个部门是没有员工的）
✨查询所有年龄大于41岁的员工, 及其归属的部门名称; 如果员工没有分配部门, 也需要展示出来(因为没有部门的也要展示，只能使用外连接,外连接大部分采用左外，因为右外也可以通过调换表顺序改为左外)
✨查询所有员工的工资等级 （发现跟部门没有关系，而员工表中只有工资，没有等级，所以涉及新表salgrade）
✨查询 "研发部" 所有员工的信息及工资等级
✨查询 "研发部" 员工的平均工资
✨查询工资比 "n" 高的员工信息。
✨查询比平均薪资高的员工信息
✨查询低于本部门平均工资的员工信息
✨查询所有的部门信息, 并统计部门的员工人数
✨查询所有学生的选课情况, 展示出学生名称, 学号, 课程名称
🚀​​​​​​多表查询综合案例 数据环境准备:
create table salgrade( grade int, --工资等级 lowsal int, --这个等级的最低工资 hightsal int --这个等级的最高工资 ) comment '工资等级表'; insert into salgrade values (1,0,3000); insert into salgrade values (2,3001,5000); insert into salgrade values (3,5001,8000); insert into salgrade values (4,8001,10000); insert into salgrade values (5,10001,15000); insert into salgrade values (6,15001,20000); insert into salgrade values (7,20001,25000); insert into salgrade values (8,25001,30000); 在这个案例中，我们主要运用上面所讲解的多表查询的语法，完成以下的12个需求即可，而这里主要涉及到的表就三张：empcp员工表、dept部门表、salgrade工资等级表 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a61562dc651102bc5611e165b571811/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/595d20356a327db8e5ad26f2b33ad4d7/" rel="bookmark">
			Stable-diffusion-WebUI 的API调用(内含文生图和图生图实例)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前情提要 在之前尝试使用Diffusers库来进行stable-diffusion的接口调用以及各种插件功能实现，但发现diffusers库中各复杂功能的添加较为麻烦，而且难以实现对采样器的添加，safetensors格式模型的读取。在官网上找到了webui有专门的api接口，能够极大方便我们进行类似webui界面的api调用。
diffusers文档
webui项目官网
webui API说明
webui项目部署 这种调用webui自带的api的方法需要先将webui运行起来，无论是自己从官网配置的webui，还是各类启动器一键启动的都是可以的。（我使用的为一键启动包，较为简单）
一键启动包教程
如果是自己配置的
使用
bash webui.sh --nowebui 或者
python launch.py --xformers --api API接口调用 当我们把webui项目启动之后，我们可以看到运行的端口（默认为7860）
可以进行调用
1. 文生图（python示例）：
import json import requests import io import base64 from PIL import Image url = "http://127.0.0.1:7860" prompt = "dog" negative_prompt = "" payload = { # 模型设置 "override_settings":{ "sd_model_checkpoint": "v1-5-pruned.ckpt", "sd_vae": "animevae.pt", "CLIP_stop_at_last_layers": 2, }, # 基本参数 "prompt": prompt, "negative_prompt": negative_prompt, "steps": 30, "sampler_name": "Euler a", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/595d20356a327db8e5ad26f2b33ad4d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c659316861843105ad600c829352318/" rel="bookmark">
			大数据与AI人工智能：AI的影响与应对措施
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景介绍 大数据和人工智能(AI)是当今科技领域的热门话题。随着数据的庞大增长和计算能力的不断提升，人工智能技术已经取得了显著的进展。然而，这种技术的普及也带来了许多挑战和影响。本文将探讨大数据与AI人工智能的关系，以及AI对现代社会的影响及应对措施。
1.1 大数据背景 大数据是指由于互联网、移动互联网等技术的发展，产生的海量、多样化、高速增长的数据。这些数据包括结构化数据(如关系型数据库中的数据)、非结构化数据(如文本、图像、音频、视频等)和半结构化数据(如XML、JSON等)。大数据的特点是五个“三”：三V(量、速度、多样性)和三C(完整性、可用性、及时性)。
大数据技术的发展为人工智能提供了丰富的数据源，有助于提高AI系统的准确性和效率。同时，大数据也为AI带来了挑战，如数据存储、处理和挖掘等。
1.2 AI人工智能背景 AI人工智能是一种试图使计算机具有人类智能的科学领域。AI的目标是让机器能够理解自然语言、进行推理、学习、决策等，从而实现与人类相当的智能。AI可以分为强AI(模拟人类智能)和弱AI(针对特定任务)两类。
AI的发展历程可以分为以下几个阶段：
早期AI(1950年代至1970年代)：这一阶段主要关注逻辑推理、知识表示和搜索算法等基本问题。强化学习(1980年代至2000年代)：这一阶段主要关注机器学习、神经网络和深度学习等领域。深度学习(2010年代至现在)：这一阶段主要关注卷积神经网络、递归神经网络和自然语言处理等领域。 1.3 大数据与AI的关系 大数据与AI之间存在紧密的联系。大数据为AI提供了丰富的数据源，有助于提高AI系统的准确性和效率。同时，AI也为大数据带来了挑战，如数据存储、处理和挖掘等。此外，大数据还为AI提供了新的算法和技术，如机器学习、深度学习等。
2.核心概念与联系 2.1 核心概念 2.1.1 大数据 大数据的核心概念包括：
量：数据量非常庞大，需要使用分布式计算技术进行处理。速度：数据产生和处理速度非常快，需要使用实时计算技术进行处理。多样性：数据类型和结构非常多样，需要使用统一处理技术进行处理。 2.1.2 AI人工智能 AI的核心概念包括：
机器学习：机器学习是一种自动学习和改进的算法，可以使计算机在没有明确编程的情况下进行决策和预测。深度学习：深度学习是一种基于神经网络的机器学习方法，可以处理大量数据并自动学习复杂的模式。自然语言处理：自然语言处理是一种处理和理解自然语言的技术，可以让计算机与人类进行自然语言交互。 2.2 联系 大数据和AI之间的联系可以从以下几个方面进行分析：
数据驱动：大数据为AI提供了丰富的数据源，有助于提高AI系统的准确性和效率。算法与技术：大数据为AI提供了新的算法和技术，如机器学习、深度学习等。应用场景：大数据和AI在许多领域具有广泛的应用，如医疗、金融、物流等。 3.核心算法原理和具体操作步骤以及数学模型公式详细讲解 3.1 核心算法原理 3.1.1 机器学习 机器学习是一种自动学习和改进的算法，可以使计算机在没有明确编程的情况下进行决策和预测。机器学习的核心原理是通过训练数据学习模型，并在新的数据上进行推理和预测。
3.1.2 深度学习 深度学习是一种基于神经网络的机器学习方法，可以处理大量数据并自动学习复杂的模式。深度学习的核心原理是通过多层神经网络进行特征提取和模型学习，从而实现自动学习和决策。
3.1.3 自然语言处理 自然语言处理是一种处理和理解自然语言的技术，可以让计算机与人类进行自然语言交互。自然语言处理的核心原理是通过自然语言处理算法和模型，实现语音识别、文本摘要、机器翻译等功能。
3.2 具体操作步骤 3.2.1 机器学习 数据收集：收集相关的训练数据。数据预处理：对数据进行清洗、转换和归一化等处理。模型选择：选择合适的机器学习算法。模型训练：使用训练数据训练模型。模型评估：使用测试数据评估模型的性能。模型优化：根据评估结果优化模型。模型部署：将优化后的模型部署到生产环境。 3.2.2 深度学习 数据收集：收集相关的训练数据。数据预处理：对数据进行清洗、转换和归一化等处理。神经网络设计：设计多层神经网络。模型训练：使用训练数据训练神经网络。模型评估：使用测试数据评估神经网络的性能。模型优化：根据评估结果优化神经网络。模型部署：将优化后的神经网络部署到生产环境。 3.2.3 自然语言处理 数据收集：收集相关的自然语言数据。数据预处理：对数据进行清洗、转换和分词等处理。算法选择：选择合适的自然语言处理算法。模型训练：使用训练数据训练模型。模型评估：使用测试数据评估模型的性能。模型优化：根据评估结果优化模型。模型部署：将优化后的模型部署到生产环境。 3.3 数学模型公式详细讲解 3.3.1 线性回归 线性回归是一种常用的机器学习算法，用于预测连续变量。线性回归的数学模型公式为：
$$ y = \beta0 + \beta1x1 + \beta2x2 + \cdots + \betanx_n + \epsilon $$
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c659316861843105ad600c829352318/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff78f22f9fdf97c353eda432b974144d/" rel="bookmark">
			Java生成四位数随机验证码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言： 我们生活中登录的时候都要输入验证码，这些验证码是为了增加注册或者登录难度，减少被人用脚本疯狂登录注册导致的一系列危害，减少数据库的一些压力。
毕竟那些用脚本生成的账号都是垃圾账号
本次实践：生成这样的验证码
并且附带一些干扰线
项目想法： 我们生成一个验证码有好几个要求
1.验证码必须是随机的，每次都不能重复出现一模一样的
2.验证码得让人有体验感，最起码得看得清，大小要合适
3.验证码初步需要一些干扰线，防止很轻易的就被脚本识别出来。
初步学习先以这些为要求进行实践。
项目思路： 我们要理解这个验证码的生成过程。
1.我们需要有一个画板
2.我们需要一只笔可以在画板上涂鸦
3.我们需要用笔在画板上画字符
4.我们需要调节画板和字符的颜色，及其大小，提升体验感
5.我们需要画出干扰线
项目实践： 1.我们需要一些字母或者数字，这样组成随机的四位验证码 我们可以写一个程序快速生成这样的数组
public class Zifu { public static void main(String[] args) { for(int i=0; i&lt;26; i++){ char ch = (char) ('a' + i); // 生成字母 if (i != 25) { System.out.print("\"" + ch + "\", "); } else { System.out.print("\"" + ch + "\""); } } for(int i=0; i&lt;10; i++){ char ch=(char)('0'+i); if (i !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff78f22f9fdf97c353eda432b974144d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0148b25f5d7ba93ef3ce789f0bbc2b1/" rel="bookmark">
			Matlab从图（fig）中提取数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 根据Matlab生成的图提取其中数据 在数据分析和处理过程中，我们经常需要从图像中提取有用的数据。Matlab作为一个强大的数据分析工具，提供了丰富的图像处理函数，可以帮助我们从图像中提取数据。本文将介绍如何在Matlab中提取图中数据的方法。
1.1 首先准备一个如图所示的图
1.2 创建一个（.m文件）或者在Matlab的运行窗口输入以下命令
注意：此时图必须是打开状态
h =findall(gca, 'type', 'line'); x = get(h, 'Xdata'); y = get(h, 'Ydata'); h = figure(); ax = axes(h); hold on; for i=1:length(x) plot(ax,x{i},y{i}); end 1.3 运行完以后，我们会在Matlab工作区看到以下内容
1.4 点击进去，我们就得到了我们想要获取的数据
该方法要比现有一些方法更加快捷方便，希望能帮助大家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2c9543752904735962b0e0ce2a3acf2/" rel="bookmark">
			宝塔nginx部署前端页面刷新报404
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
当我们使用脚手架打包前端项目的时候，如果前端项目并没有静态化的配置，如以下
当我们刷新页面，或进行路由配置访问的时候就会报404的错误
原因：
这是因为通常我们做的vue项目属于单页面开发。所以只有index.html。解决这个bug也很简单。只需要将访问重定向到index.html这个页面，交由 index.html 去处理对应的路由跳转就好。 解决办法：修改nginx配置 server { listen 80; # 监听的端口 server_name xx.xx.xxx.xx; # 处理的host地址 （请替换成你对应的项目访问 ip 或 域名）!!! root /usr/share/nginx/html; # vue项目存在的目录（替换成你对应的地址，如果你这是用docker部署的请改成你容器内的地址） # 下面两个配置是关键所在！！！！！！ location / { try_files $uri $uri/ @router;#需要指向下面的@router否则会出现vue的路由在nginx中刷新出现404 index index.html index.htm; } #对应上面的@router，主要原因是路由的路径资源并不是一个真实的路径，所以无法找到具体的文件 #因此需要rewrite到index.html中，然后交给路由在处理请求资源 location @router { rewrite ^.*$ /index.html last; } } 将nginx配置好后，重新打开你的网页，就发现可以进行路由跳转了！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/329101f48c22361a70b8d3581bfe31fd/" rel="bookmark">
			《TrollStore巨魔商店》TrollStore2安装使用教程支持IOS14.0-16.6.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TrollStore(巨魔商店) 简单的说就相当于一个永久的免费证书，它可以给你的iPhone和iPad安装任何你想要安装的App软件，而且不需要越狱,不用担心证书签名过期的问题，不需要个人签名和企业签名。
支持的版本：
TrollStore安装和使用教程：
iPhone6S-X14.0-14.8.1用checkra1n越狱后，Cydia添加源havoc.app安装
iPhone6S-13PM(A8-A15)15.0-15.4.1:https://api.jailbreaks.app/troll
iPhone6S-X(A8-A11)15.5-15.6.1:https://api.jailbreaks.app/troll
XR-13PM(A12-A15)14.0-14.8.1:https://api.jailbreaks.app/troll64e
XR-13PM(A12-A15)15.5-15.6.1:https://api.jailbreaks.app/troll64e
链接复制到设备自带的Safari浏览器下载安装
A12以上处理器IOS15.5-16.6.1安装方法一：
misaka最新版本下载地址:https://wwi.lanzoup.com/b019sha7i密码:ax4l
下载misaka使用Sideloadly、Altstore自签名或者企业签名等方式安装到手机上。
1，打开Misaka，点击Agree，点击最底下Packages。（需要打开科学上网）
2，点左下角四方形蓝色图标。
3，点击install Trollstore。
4, 点击Tips ,自动注销进入桌面（Tips、Books、Home任意选一个）
5，打开桌面提示APP，点击install TrollStore，开始安装巨魔2，安装完成。
A12以上处理器IOS15.5-16.6.1安装方法二：
Picasso最新版本下载地址:https://wwi.lanzoup.com/b019shahi密码:2t2l
下载Picasso最新版本使用Sideloadly、Altstore自签名或者企业签名等方式安装到手机上。
1，到https://repo.sourceloc.net官网注册一个账号。
2，打开Picasso，登录刚刚注册的账号密码（需要打开科学上网）
3，点击最底下Explore，划到最底下选择TrollStore插件，点击Get安装，安装完成点OK。
4，点击最底下Home，点击Apply，弹窗提示OK不要点，直接强制重启手机即可。
5, 重启完打开桌面提示APP，点击install TrollStore开始安装巨魔2，安装完成。
巨魔商店安装应用APP教程：
1，打开巨魔商店APP点击右上角的＋点Install IPA File。
2，选择你提前下载好的应用IPA文件。
3，点击Install安装即可。
整理的应用IPA文件下载地址：https://cowtransfer.com/s/ce53ee9c4b9046 口令：0f49ie
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad010828bf592942418060ff7c98efcc/" rel="bookmark">
			14、MySQL高频面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、内连接和外连接的区别 内连接和外连接都是数据库进行多表联查时使用的连接方式，区别在于二者获取的数据集不同
内连接指的是使用左表中的每一条数据分别去连接右表中的每一条数据，仅仅显示出匹配成功的那部分
外连接有分为左外连接和右外连接
左外连接: 首先要显示出左表的全部，然后使用连接条件匹配右表，能匹配中的就显示，匹配不中的显示为null右外连接: 首先要显示出右表的全部，然后使用连接条件匹配左表，能匹配中的就显示，匹配不中的显示为null 2、drop、delete与truncate区别 这个关键字都是MySQL中用于删除的关键字，区别在于：
delete语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作drop 主要用于删除数据表、表中的列、索引等结构truncate 是直接把表删除，然后再重建表结构 这三种方式在效率方面drop 最高、truncate 其次、delete最低，但是drop和truncate 都不记录日志，无法回滚
3、union与union all的区别 union和union all都是MySQL中用于合并多条select语句结果的关键字，它会将前后两条select语句的结果组合到一个结果集合中
区别在于UNION ALL会返回所有结果，UNION会去掉重复的记录
4、char和varchar的区别 char和varchar是MySQL中的字符串类型，区别在于下面几方面：
最大长度：char最大长度是255字符，varchar最大长度是65535个字节占用长度：char是定长的，不足的部分用隐藏空格填充，varchar是不定长的空间使用：char会浪费空间，varchar会更加节省空间查找效率：char查找效率会很高，varchar查找效率会更低 因此我们如果存储固定长度的列，例如身份证号、手机号建议使用char
其它不定长度的建议使用varchar，使用varchar的时候也要尽量让声明长度贴近实际长度
注意：varchar(50)中50的涵义是最多存放50个字符，varchar(50)和varchar(200)存储hello所占空间一样
5、事务的四大特性 事务的四大特性指的是原子性、一致性、隔离性、持久性
原子性：事务是最小的执行单位，不允许分割，同一个事务中的所有命令要么全部执行，要么全部不执行一致性：事务执行前后，数据的状态要保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的隔离性：并发访问数据库时，一个事务不被其他事务所干扰，各并发事务是独立执行的持久性：一个事务一旦提交，对数据库的改变应该是永久的，即使系统发生故障也不能丢失 6、并发事务带来的问题 并发事务下，可能会产生如下的问题：
脏读：一个事务读取到了另外一个事务没有提交的数据不可重复读：一个事务读取到了另外一个事务修改的数据幻读（虚读）：一个事务读取到了另外一个事务新增的数据 7、事务隔离级别 事务隔离级别是用来解决并发事务问题的方案，不同的隔离级别可以解决的事务问题不一样
读未提交： 允许读取尚未提交的数据，可能会导致脏读、幻读或不可重复读读已提交： 允许读取并发事务已提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生可重复读： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生可串行化： 所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，该级别可以防止脏读、不可重复读以及幻读。 上面的这些事务隔离级别效率依次降低，安全性依次升高，如果不单独设置，MySQL默认的隔离级别是可重复读
8、数据库三大范式 三大范式是指导设计数据库的原则
第一范式：表中的每一列不能再进行拆分，也就是每一列都应该是原子的第二范式：一张表只做一件事，不要将多个层次的数据列保存到一张表中第三范式：数据不能存在传递关系，也就是说可以通过其它字段推出来的字段没必要再存储 在现有的程序设计中认为第三范式是可以不遵守的，也就是通过添加冗余字段，来减少多表联查或计算，我们称为反三范式
9、索引的分类 索引是数据库中用于提供查询效率的一种手段
从物理存储角度上分为聚集索引和非聚集索引
聚集索引指的是数据和索引存储在同一个文件中，InnoDB存储引擎使用的是此类索引存储方式
非聚集索引指的是数据和索引存储在不同的文件中，MyISAM存储引擎使用的是此类索引存储方式
从逻辑角度上分为普通、唯一、主键和联合索引，它们都可以用来提高查询效率，区别点在于
唯一索引可以限制某列数据不出现重复，主键索引能够限制字段唯一、非空
联合索引指的是对多个字段建立一个索引，一般是当经常使用某几个字段查询时才会使用，它比对这几个列单独建立索引效率要高
10、索引的创建原则 索引可以大幅度提高查询的效率，但不是所有的字段都要加，也不是加的越多越好，因为索引会占据磁盘空间，也会影响增删改的效率
我们在建立索引的时候应该遵循下面这些原则：
主键字段、外键字段应该添加索引经常作为查询条件、排序条件或分组条件的字段需要建立索引经常使用聚合函数进行统计的列可以建立索引经常使用多个条件查询时建议使用组合索引代替多个单列索引 除此之外，下面这些情况，不应该建立索引
数据量小的表不建议添加索引数据类型的字段是TEXT、BLOB、BIT等数据类型的字段不建议建索引不要在区分度低的字段建立索引，比如性别字段、年龄字段等 11、索引失效的情况 索引失效指的是虽然在查询的列上添加了索引，但是某些情况下，查询的时候依旧没有用到索引，常见的情况有
使用like关键字时，模糊匹配使用％开头将导致索引失效使用连接条件时，如果条件中存在没有索引的列会导致索引失效在索引列上进行计算、函数运算、类型转换将导致索引失效使用 !=、not in、is null、is not null时会导致索引失效使用联合索引时，没有遵循最左匹配原则会导致索引失效 12、如何知道索引是否失效 MySQL中自带了一个关键字叫explain，它可以加在一个sql的前面来查看这条sql的执行计划
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad010828bf592942418060ff7c98efcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/636171c2cf2f086fc7268e89ddd55649/" rel="bookmark">
			Flink保姆级教程，超全五万字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转载：https://cloud.tencent.com/developer/article/1880497
本文目录：
一、Flink 简介
二、Flink 部署及启动
三、Flink 运行架构
四、Flink 算子大全
五、流处理中的 Time 与 Window
六、Flink 状态管理
七、Flink 容错
八、Flink SQL
九、Flink CEP
十、Flink CDC
十一、基于 Flink 构建全场景实时数仓
十二、Flink 大厂面试题
Flink 涉及的知识点如下图所示，本文将逐一讲解：
本文档参考了 Flink 的官网及其他众多资料整理而成，为了整洁的排版及舒适的阅读，对于模糊不清晰的图片及黑白图片进行重新绘制成了高清彩图。
一、Flink 简介 1. Flink 发展 这几年大数据的飞速发展，出现了很多热门的开源社区，其中著名的有 Hadoop、Storm，以及后来的 Spark，他们都有着各自专注的应用场景。Spark 掀开了内存计算的先河，也以内存为赌注，赢得了内存计算的飞速发展。Spark 的火热或多或少的掩盖了其他分布式计算的系统身影。就像 Flink，也就在这个时候默默的发展着。
在国外一些社区，有很多人将大数据的计算引擎分成了 4 代，当然，也有很多人不会认同。我们先姑且这么认为和讨论。
首先第一代的计算引擎，无疑就是 Hadoop 承载的 MapReduce。这里大家应该都不会对 MapReduce 陌生，它将计算分为两个阶段，分别为 Map 和 Reduce。对于上层应用来说，就不得不想方设法去拆分算法，甚至于不得不在上层应用实现多个 Job 的串联，以完成一个完整的算法，例如迭代计算。
由于这样的弊端，催生了支持 DAG 框架的产生。因此，支持 DAG 的框架被划分为第二代计算引擎。如 Tez 以及更上层的 Oozie。这里我们不去细究各种 DAG 实现之间的区别，不过对于当时的 Tez 和 Oozie 来说，大多还是批处理的任务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/636171c2cf2f086fc7268e89ddd55649/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cae71b118ee7271c75cec9a3074f291/" rel="bookmark">
			MySQL 8.0 修改 Root 密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL 是一种常见的关系型数据库，在数据库管理中 MySQL 8.0 版本也是比较常用的版本，但是 MySQL 在初次安装之后默认设置了 root 用户的密码，对于一些情况下需要修改 root 用户密码的操作，需要使用特定的命令和工具。
一、MySQL 修改 Root 密码 MySQL 8.0 版本在安装完成之后，root 用户默认的密码是空密码，这时需要通过以下的步骤进行修改密码。
1、首先需要使用 MySQL root 用户登录到 MySQL。
$ mysql -u root -p 2、之后会提示输入 root 用户的密码，如果密码是空的，直接回车即可。
Enter password: 3、登录成功后，进入 MySQL 的命令行，并使用以下的 SQL 语句进行密码修改。
mysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'new_password'; 4、执行成功后，需要刷新 MySQL 的系统权限并退出 MySQL。
mysql&gt; FLUSH PRIVILEGES; mysql&gt; EXIT; 以上的命令会将 root 用户的密码修改为 new_password。
二、MySQL 修改 Root 密码命令 在 MySQL 中，使用 ALTER USER 命令可以修改用户的密码，以下是具体的命令步骤和详细的说明。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cae71b118ee7271c75cec9a3074f291/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46f1ff7d8131c1addc4b1b49a0cf6845/" rel="bookmark">
			基于ChatGPT的代码解释神器：GPT Academic、GitHub Copilot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（个人推荐使用第二个GitHub Copilot）
1. GPT 学术优化 (GPT Academic)工具 简介 GPT Academic是什么 为ChatGPT/GLM提供实用化交互界面，特别优化论文阅读/润色/写作体验，模块化设计，支持自定义快捷按钮&amp;函数插件，支持Python和C++等项目剖析&amp;自译解功能，PDF/LaTex论文翻译&amp;总结功能，支持并行问询多种LLM模型，支持chatglm2等本地模型。兼容文心一言, moss, llama2, rwkv, claude2, 通义千问, 书生, 讯飞星火等。
文档及下载地址：https://github.com/binary-husky/gpt_academic?tab=readme-ov-file 功能 功能（⭐= 近期新增功能）描述⭐接入新模型百度千帆与文心一言, 通义千问Qwen，上海AI-Lab书生，讯飞星火，LLaMa2，智谱API，DALLE3, DeepseekCoder润色、翻译、代码解释一键润色、翻译、查找论文语法错误、解释代码自定义快捷键支持自定义快捷键模块化设计支持自定义强大的插件，插件支持热更新程序剖析[插件] 一键剖析Python/C/C++/Java/Lua/…项目树 或 自我剖析读论文、翻译论文[插件] 一键解读latex/pdf论文全文并生成摘要Latex全文翻译、润色[插件] 一键翻译或润色latex论文批量注释生成[插件] 一键批量生成函数注释Markdown中英互译[插件] 看到上面5种语言的README了吗？就是出自他的手笔chat分析报告生成[插件] 运行后自动生成总结汇报PDF论文全文翻译功能[插件] PDF论文提取题目&amp;摘要+翻译全文（多线程）Arxiv小助手[插件] 输入arxiv文章url即可一键翻译摘要+下载PDFLatex论文一键校对[插件] 仿Grammarly对Latex文章进行语法、拼写纠错+输出对照PDF谷歌学术统合小助手[插件] 给定任意谷歌学术搜索页面URL，让gpt帮你写relatedworks互联网信息聚合+GPT[插件] 一键让GPT从互联网获取信息回答问题，让信息永不过时⭐Arxiv论文精细翻译 (Docker)[插件] 一键以超高质量翻译arxiv论文，目前最好的论文翻译工具⭐实时语音对话输入[插件] 异步监听音频，自动断句，自动寻找回答时机公式/图片/表格显示可以同时显示公式的tex形式和渲染形式，支持公式、代码高亮⭐AutoGen多智能体插件[插件] 借助微软AutoGen，探索多Agent的智能涌现可能！启动暗色主题在浏览器url后面添加/?__theme=dark可以切换dark主题多LLM模型支持同时被GPT3.5、GPT4、清华ChatGLM2、复旦MOSS伺候的感觉一定会很不错吧？⭐ChatGLM2微调模型支持加载ChatGLM2微调模型，提供ChatGLM2微调辅助插件更多LLM模型接入，支持huggingface部署加入Newbing接口(新必应)，引入清华Jittorllms支持LLaMA和盘古α⭐void-terminal pip包脱离GUI，在Python中直接调用本项目的所有函数插件（开发中）⭐虚空终端插件[插件] 能够使用自然语言直接调度本项目其他插件更多新功能展示 (图像生成等) ……见本文档结尾处 …… 解读代码的功能： 对于开发人员来说，有个非常nice的功能，只需选择项目目录，GPT Academic就可以直接解读整个项目的代码
收费： 由于GPT Academic需要用到chatgpt的api，刚开始有免费额度，用完得充钱。网上也能搜到如何弄免费版，功能相对有限，但日常使用足够了，缺点是不太稳定。
ChatGPT API的定价
根据OpenAI官方发布的最新收费标准，ChatGPT API的定价如下：
模型价格GPT-3.5 Turbo API1k tokens/$0.002GPT-4.0 API暂未公布 根据以上定价，使用GPT-3.5 Turbo API，每输出100万个单词只需支付2.7美元（约合18元人民币）。
安全性： 2.GitHub Copilot工具 简介 GitHub Copilot 是什么 GitHub Copilot 是一个可以帮助你高效编写代码的工具，由 GPT-3 提供支持。你只需编写所需代码的功能描述——例如，编写一个二分查找算法，Copilot 马上就会为你创建。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46f1ff7d8131c1addc4b1b49a0cf6845/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad19e275a346f213c306be4fb07bd889/" rel="bookmark">
			Android Studio Error “Unsupported class file major version 61“---异常信息记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题一： 问题出在JAVA 17上，并且使用的Gradle JDK是：Android Studio java home版本17.0.1将其更改为：Android Studio默认JDK版本11.0.10 即可解决
问题二：
我的已经用的是jdk1.8了，问题出在androidx和material版本太高了，我改成低版本就好了，改成如下版本：
implementation 'androidx.appcompat:appcompat:1.2.0' implementation 'com.google.android.material:material:1.4.0' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bfdc3d9472a6ecacdea17310feb8fd2/" rel="bookmark">
			Python批量修改文件名全面指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常工作中，经常会遇到需要批量修改文件名的情况，可能是为了更好的组织文件，也可能是为了处理大量的数据文件。Python提供了强大的工具和库来处理这个任务，本文将介绍如何使用Python来批量修改文件名，包括文件名的替换、前缀、后缀的添加等多种操作。
使用os模块和os.path模块 Python的os模块和os.path模块提供了文件和目录操作的基本功能，可以用于文件名的操作。
1. 文件名替换 要批量替换文件名中的特定字符串，可以使用os.listdir()列出目录中的所有文件，然后使用字符串的replace()方法替换文件名中的字符串。
import os def replace_in_filenames(directory, old_str, new_str): for filename in os.listdir(directory): if old_str in filename: new_filename = filename.replace(old_str, new_str) os.rename(os.path.join(directory, filename), os.path.join(directory, new_filename)) # 示例用法 replace_in_filenames('/path/to/directory', 'old_string', 'new_string') 2. 添加前缀和后缀 要在文件名前后添加前缀或后缀，可以使用字符串的拼接操作。
import os def add_prefix_suffix(directory, prefix, suffix): for filename in os.listdir(directory): new_filename = prefix + filename + suffix os.rename(os.path.join(directory, filename), os.path.join(directory, new_filename)) # 示例用法 add_prefix_suffix('/path/to/directory', 'prefix_', '_suffix') 使用glob模块 glob模块提供了更强大的文件匹配和查找功能，可以使用通配符来选择文件。
1. 文件名匹配 要选择符合特定模式的文件，可以使用glob.glob()函数。
import glob files = glob.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bfdc3d9472a6ecacdea17310feb8fd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a20a4a3737a60a0c69ec38d1ce9bd01e/" rel="bookmark">
			Java web 开发常用的框架详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java Web开发是一项庞大而复杂的任务，有许多框架旨在简化和加速这个过程。这些框架提供了一套工具和规范，帮助开发者更高效地构建强大、可扩展和维护的Web应用程序。在这篇文章中，详细讲解一些Java Web开发中常用的框架，包括Spring、Hibernate、Struts、Servlet、以及一些与前端交互的框架。
1. Spring框架 简介： Spring是Java开发中最流行的企业级框架之一。它提供了全面的基础设施支持，包括依赖注入（DI）、面向切面编程（AOP）、事务管理、数据访问等。Spring框架的核心是Spring IoC容器，它管理对象的生命周期和配置。
特点：
依赖注入（DI）： Spring通过DI实现松耦合，降低了组件之间的耦合度，提高了代码的可维护性。面向切面编程（AOP）： Spring提供了AOP支持，允许将横切关注点（如日志、事务管理）从业务逻辑中分离出来。事务管理： Spring框架提供了强大的事务管理支持，可以轻松集成各种事务管理器。模块化设计： Spring框架被划分为多个模块，开发者可以根据项目需求选择使用的模块，从而保持了灵活性。 示例代码：
@Controller @RequestMapping("/hello") public class HelloController { @RequestMapping(method = RequestMethod.GET) public String printHello(ModelMap model) { model.addAttribute("message", "Hello Spring MVC Framework!"); return "hello"; } } 2. Hibernate框架 简介： Hibernate是一个优秀的对象关系映射（ORM）框架，用于简化Java应用程序中关系数据库的访问和操作。它将Java对象与数据库表之间建立映射关系，通过面向对象的方式进行数据库操作。
特点：
对象关系映射： Hibernate允许开发者使用Java对象来表示数据库中的表，通过映射关系实现对象的持久化。透明性： Hibernate提供透明的持久化，开发者无需编写复杂的SQL语句，框架会自动翻译对象操作为对应的SQL语句。跨数据库兼容性： Hibernate支持多种数据库，可以轻松切换数据库引擎而无需修改代码。缓存机制： Hibernate提供了缓存机制，提高了应用程序的性能。 示例代码：
@Entity @Table(name = "employee") public class Employee { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = "id") private int id; @Column(name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a20a4a3737a60a0c69ec38d1ce9bd01e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2754378c42b2040971a5a8c57a7c7697/" rel="bookmark">
			javax.servlet 和 jakarta.servlet的关系和使用tomcat部署 jakarta.servlet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，javax.servlet 和 jakarta.servlet的关系 javax.servlet 和 jakarta.servlet 是 Java Servlet API 的两个版本。
Java Servlet API 是由 Sun Microsystems（现在是 Oracle）开发和维护的，其包名以 javax.servlet 开头。从 Java EE 8 开始，Servlet API 的维护权转交给了 Eclipse Foundation 的 Jakarta EE 社区，因此，在最新的 Jakarta EE 版本中，Servlet API 的包名已经更改为 jakarta.servlet。
javax.servlet 是旧版本的包名，而 jakarta.servlet 是新版本的包名。这个变化是为了反映 Jakarta EE 作为一个独立的开源项目，并且将标准 Java 技术规范的发展移交给了 Jakarta EE 社区。
虽然包名发生了变化，但是 Servlet API 的核心功能和用法并没有大的改变。大多数代码可以无缝地迁移到 jakarta.servlet 包下，只需要修改导入语句和相应的依赖。
所以，javax.servlet 和 jakarta.servlet 的区别仅在于包名的变化，代表不同版本的 Java Servlet API，也就意味着在代码中使用javax.servlet包或者使用jakarta.servlet包，而不需要修改代码。
如：
使用javax.servlet 包
import javax.servlet.*; import javax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2754378c42b2040971a5a8c57a7c7697/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/53/">«</a>
	<span class="pagination__item pagination__item--current">54/71</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/55/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>