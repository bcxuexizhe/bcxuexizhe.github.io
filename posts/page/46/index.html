<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b21a03391cb3b9932083307b237b438/" rel="bookmark">
			AI探索实践8 - 本地运行大模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是feng，感谢你阅读我的博文，如果你也关注AI应用开发，欢迎关注公众号和我一起​探索。如果文章对你有所启发，请为我点赞！
全栈技术探索
一、大模型LLMs简介 大模型LLMs，即大型语言模型（Large Language Models）简称为大模型，是一种基于人工智能和机器学习技术构建的先进模型，旨在理解和生成自然语言文本、图片、视频等。这些模型通过分析和学习海量的文本数据，掌握语言的结构、语法、语义和上下文等复杂特性，从而能够执行各种语言相关的任务。LLM的能力包括但不限于文本生成、问答、文本摘要、翻译、情感分析等。
LLMs例如GPT、LLama、Mistral系列等，通过深度学习的技术架构，如Transformer，使得这些模型能够捕捉到文本之间深层次的关联和含义。模型首先在广泛的数据集上进行预训练，学习语言的一般特征和模式，然后可以针对特定的任务或领域进行微调，以提高其在特定应用中的表现。
预训练阶段让LLMs掌握了大量的语言知识和世界知识，而微调阶段则使模型能够在特定任务上达到更高的性能。这种训练方法赋予了LLMs在处理各种语言任务时的灵活性和适应性，能够为用户提供准确、多样化的信息和服务。
我们可以将大模型想象成人类大脑。预训练“大脑”的过程，就好像人类从幼儿园开始，直到大学毕业的学习知识的过程。这个过程，让“大脑”掌握了大量的知识。当你发送给这个“大脑”信息，“大脑”会反馈给你另一些信息。
请注意，大家平常使用的ChatGPT、通义千问、文心一言、Gemini、Midjourney等，严格意义上来说是大模型的应用，是一个利用大模型的能力，向用户提供智能服务的应用软件或者API，而非大模型本身。
二、本地大模型的必要性 我们可以很方便的在线使用Kimi上传文件来回答我们的问题、使用Dreamina、Midjourney来生成图片、使用Sora来生成视频（OpenAI的文生视频产品，至今尚未发布）等，所以的这些都属于：线上大模型服务。
线上大模型服务向我们提供智能、便捷的服务的同时，也存在以下问题：
2.1 线上大模型服务的问题 2.1.1 个人数据隐私 在线上LLMs的使用过程中，个人数据的隐私成为了一个显著的担忧点，特别是对于那些注重内部数据安全的企业用户。用户与LLM的互动，以及上传的文档，都可能被服务提供商收集用于模型的微调和优化。
2.1.2 模型性能与成本 服务提供商为了平衡成本和性能，可能会使用不同规模的LLM。较小的模型（如7B或13B参数）虽然可以减少计算资源消耗，提高响应速度，但其推理能力可能不足以处理复杂的查询或生成高质量的文本。用户在选择服务时，可能难以获悉所使用的模型规模和性能，导致实际应用中的效果与预期存在差异。这种不透明性可能会影响用户的使用体验和满意度。
2.1.3 内容完整性 针对长文档的处理，存在一个问题是LLM是否能够完整地获取和理解整个文档内容。由于技术限制，一些服务可能只会处理文档的一部分内容，如仅分析前几百个词。这种处理方式可能会导致LLM遗漏关键信息，从而影响到生成内容的准确性和相关性。用户可能无法了解其提交的内容是否被完整处理，进而对结果的可靠性产生疑问。
2.1.4 检索增强的生成模型（RAG）策略 RAG的切割方式和回调策略直接影响LLM的效果，特别是在处理需要广泛知识检索的查询时。不同的切割方法和回调策略决定了LLM访问和整合信息的方式，从而影响到最终生成的答案的准确性和完整性。如果这些策略没有恰当选择或优化，LLM可能无法看到或利用相关的信息来生成最佳的回答。用户通常无法控制或知晓这些内部处理细节，这增加了结果不确定性。
2.2 适用场景 本地化大模型运行，适用于以下的场景：
2.2.1 对数据敏感 发送给大模型的数据，属于企业内部的、机密不宜外传的数据，或者对于目标设定、日记撰写、财务管理、情感交流等个人化领域时的个人数据中包含的能反映个人高度敏感的数据。这些类型的数据一旦被泄露，可能会给用户造成不可挽回的伤害。在这样的背景下，本地开源LLMs的应用就显得尤为重要和必要。
2.2.2 业务场景涉及多重信息加工、多任务 在多任务和多重信息加工领域，涉及到的操作和处理逻辑非常复杂，尤其是在电脑上进行的活动。这些活动不仅仅是简单的执行命令，更多的是涉及到对用户意图的判断、数据之间的传输和交互，以及如何根据当前的上下文来做出响应。这里面涉及到的Token消耗主要是因为这些操作需要大量的计算资源来处理和响应用户的需求。
在这个过程中，每一个步骤所需的系统提示（System Prompt）、上下文对话的逻辑处理等，都需要根据具体情况进行个性化和差异化的设计。这种情况下的“千人千面”，是指系统必须能够根据每个用户的具体需求和上下文来提供定制化的服务。这与基于推荐算法的“千人千面”有着本质的差异。本质上的差异在于：
处理的动态性与静态性： 多任务和多重信息加工领域的处理是动态的，依赖于当前的上下文和用户的即时需求，而基于推荐算法的处理更多是静态的，依赖于用户的历史数据。个性化程度： 虽然两者都追求“千人千面”，但多任务处理更加注重在特定情境下对用户需求的精准响应，推荐算法更多是依据历史数据或者类似用户的数据进行的一般性预测。交互性： 多任务处理涉及到与用户的实时交互，而推荐算法则更多是一种单向的内容推送。 请注意，这个本质的差异决定了本地LLMs是解决多重信息加工甚至多任务的唯一解决办法，但它有可能是一个闭源LLM。
2.2.3 大容量、高频的数据请求 如果我们需要分析和处理大量的文档、对于历史遗漏的各类日志需要进行智能分析与预测时，与大模型的每一次交互，需要的较长的上下文长度（可能动辄数十万字符）。而线上大模型服务大都提供最大32000个字符（大约10，666个汉字）长度来说，远远不够。
在有限的、昂贵的大模型推理计算资源的情况下，在线LLM服务对于用户的请求，往往采用排队的方式来处理用户的请求，以控制和降低其运营成本。这无法满足一些企业内部大量的业务请求的需求。
2.2.4 需要低护栏的大模型 在当前的技术环境中，线上LLM在提供服务的同时，不得不面对各种法律法规和伦理道德的约束。这些约束往往通过增设“护栏”来实施，目的是为了防止模型生成不当内容，如误导信息、侵犯隐私、散播仇恨言论等。然而，这些护栏在一定程度上限制了LLM的功能和知识的完整使用，尤其是在需要较高自由度的应用场景中，如角色扮演、创意写作等。在这些场景下，内容的过滤和限制可能会阻碍创意的发挥和用户体验的深化。
在此背景下，本地部署的LLMs提供了一种解决方案。通过本地部署，用户可以根据自己的需求和责任范围，调整内容过滤的标准，既能规避法律风险，又能保留更高的创意自由度和个性化服务。这种灵活性在某些业务场景中尤为重要，能够为用户提供更加丰富和深入的互动体验。
三、部署和运行本地大模型的方法 有多个软件或工具可以帮助我们部署和运行本地大模型。比如LM Studio、llamafile、GPT4All、Ollama等。这里我们介绍其中的一种：Ollama。
3.1 安装Ollama Ollama 是一个开源的、基于LLama.cpp的轻量级、可扩展的框架，用于在本地构建和运行语言模型。我们可以访问官网，查看和下载Ollama。
其开源地址：https://github.com/ollama/ollama
图1
Mac版本的Ollama是压缩包，解压并放入应用程序中。启动Ollama的过程，是将Ollama运行时路径加入到系统的环境变量的过程，当我们点击完成按钮时，已经可以在终端中使用Ollama命令:
图2
在控制台中执行：ollama run 模型名称，将会启动指定名称的模型。图2是运行名称为：ollama的模型，当然并没有这个模型，因此会提示文件并不存在。
Ollama支持很多的模型本地化运行，可以访问 library 来查看支持的模型列表，这里有一个简表：
ModelParametersSizeDownloadLlama 27B3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b21a03391cb3b9932083307b237b438/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45e9c59037d914ed99c5af3bf002f081/" rel="bookmark">
			值得收藏！2024年人工智能顶级会议投稿信息汇总（机器学习领域）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人工智能是指组建一个这样的机器或系统，它能够实现数据的感知，并基于感知的数据进行预测或决策，实现类似人脑的功能。具体而言，人工智能希望通过传感器实现人的看、听、闻、触等知觉信息的采集，并基于采集到的信息进行预测或者决策。人工智能在现代社会中发挥着极其重要的作用，学界一致认为人工智能是推动新工业革命的核心技术。世界各国都推出了国家层面的战略计划来抢占人工智能的技术高地，以便在新的技术浪潮中占据有利位置，保证本国的发展处于技术链的顶端。近年来，不管是国家层面还是研究层面，对人工智能的关注度越来越高，人工智能的学习和研究者不断增加。人工智能是一个快速迭代的领域，各种新的理论和技术层出不穷，发展日新月异。参加人工智能领域的顶级会议和阅读顶级会议上的论文是获取人工智能最新理论和技术最主要的手段之一。为方便读者获取人工智能顶级会议的相关信息以及投稿顶级会议论文，本公众号近期将对2024年人工智能几个主要领域的顶级会议信息进行汇总，具体将按照大数据、数据挖掘、机器学习、计算机视觉、智能交通等领域，每个领域推出一篇文章，欢迎读者朋友们阅读、转发和收藏。
机器学习是人工智能的核心，是使计算机具有智能的根本途径。机器学习通过计算机模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。本文首先对机器学习领域内的顶级会议进行了介绍，以便读者了解会议主题、截稿日期、举办时间及地点等关键信息。接下来，对这些会议信息汇总成了表格，做到一目了然，为读者投稿会议论文提供方便。本文中关于各大顶级会议的图片均来自会议官网。由于会议组委会可能会对会议安排做出调整，因此会议的相关信息可能会有变化，请读者投稿或者参会时以会议官网提供的最新信息为准。本文作者为许东舟，审校为李杨和邱雪。
一. 会议介绍 1. NeurIPS（神经信息处理系统大会） 投稿截止日期：2024年5月22日
录用通知日期：2024年9月25日
会议时间/地点：2024年12月9日至15日，温哥华，加拿大
会议链接：https://nips.cc/Conferences/2024
NeurIPS（Conference on Neural Information Processing Systems），自1987年以来每年举办一次，专注于机器学习和计算神经科学的交叉领域。该会议是人工智能与机器学习界的顶尖盛会，涵盖了广泛的主题，包括但不限于深度学习、强化学习、概率图模型、学习理论、认知科学和神经科学等众多主题。
2. AAAI（人工智能协会年会）
投稿截止日期：2023年8月15日
录用通知日期：2023年12月9日
会议时间/地点：2024年2月20日至27日，温哥华，加拿大
会议链接：https://aaai.org/aaai-conference/
AAAI（Association for the Advancement of Artificial Intelligence Conference）由美国人工智能协会主办。该会议自80年代初以来，一直是展示人工智能最新科研成果与进展的核心舞台。该会议涵盖了人工智能领域的广泛主题，包括但不限于机器学习、计算机视觉、自然语言处理、机器人技术等多个领域。会议旨在促进学者、研究人员和行业从业者之间的交流与合作，推动AI技术的发展和应用。
3. ICML（国际机器学习大会）
投稿截止日期：2024年2月1日
录用通知日期：2024年5月1日
会议时间/地点：2024年7月21日至27日，维也纳，奥地利
会议链接：https://icml.cc/Conferences/2024
ICML（International Conference on Machine Learning）是全球顶尖的机器学习会议之一。通常每年举行一次，旨在汇集机器学习领域的研究人员、学者和行业专家共同探讨机器学习理论、算法、以及应用的最新进展和未来趋势。会议涵盖了监督学习、无监督学习、半监督学习、深度学习、强化学习、大模型、迁移学习、概率图模型、持续学习、多模态学习、可解释学习等广泛的主题，同时各种机器学习方法在自然语言处理、计算机视觉、生物信息学等领域的应用也是该会议关注的重点。
4. IJCAI（国际人工智能联合会议）
投稿截止日期：2024年1月17日
录用通知日期：2024年4月16日
会议时间/地点：2024年8月3日至9日，济州岛，韩国
会议链接：https://ijcai24.org/
IJCAI（International Joint Conference on Artificial Intelligence）自1969年首次举办以来，已经成为了人工智能领域展示最新研究成果和技术创新的国际性盛会。该会议由国际人工智能联合会组织，覆盖了人工智能领域的广泛主题，不仅包括机器学习、计算机视觉、自然语言处理、机器人学等核心领域，还涵盖知识表示、逻辑推理、社会影响、法律问题等跨学科主题。会议鼓励跨领域融合，旨在解决复杂问题，推动人工智能技术的健康发展和社会应用。
5. AAMAS（自治代理和多智能体系统国际会议）
摘要提交日期：2023年10月2日
投稿截止日期：2023年10月9日
录用通知日期：2023年12月20日
会议时间/地点：2024年5月6日至10日，新西兰
会议链接：https://www.aamas2024-conference.auckland.ac.nz/
AAMAS是智能体与多智能体系统领域规模最大、最具影响力的会议之一。会议旨在将智能体技术各个领域的研究人员和从业者聚集在一起，并为自主智能体和多智能体系统的理论和实践研究提供一个国际平台。
6. ACL（自然语言处理与计算语言学协会年会）
投稿截止日期：2024年2月15日
录用通知日期：2024年5月15日
会议时间/地点：2024年8月11日至16日，曼谷，泰国
会议链接：https://2024.aclweb.org/
ACL（Association for Computational Linguistics）是自然语言处理和计算语言学领域的顶级国际会议，致力于促进这一学科的理论与实践的发展。会议主题涵盖自然语言处理的广泛内容，包括但不限于语言理解、文本生成、机器翻译、语音识别和生成、信息提取等。ACL强调创新算法、模型开发，以及对自然语言处理应用的深入探索。此外，ACL还重视实际应用与理论研究之间的联系，鼓励将自然语言处理技术应用于教育、医疗、金融等多个领域，以解决实际问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45e9c59037d914ed99c5af3bf002f081/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e2899df765517d6e7319dbebf623a4e/" rel="bookmark">
			Kali——密码攻击——Hashcat工具使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍：本文展示了密码存储原理及通过Kali使用Hashcat工具进行密码攻击的流程（也可以在windows系统中下载metasploit工具进行相关操作），工具详细教程可在Sangfor学习平台获取临时免费课程进行学习。
挂个链接：深信服产业教育中心
一.密码存储
1.明文存储
以普通文本等明文的方式保存数据（账号密码等）的存储方式，以数据库为例，虽然对用户而言很方便，但是一旦被黑客攻击后脱库，信息就完全泄露给黑客了，安全性极低。
2.加密存储
加密存储即字面意思，存储使用加密算法加密后的数据信息。加密算法分为对称加密算法和非对称加密算法，常用为对称加密算法，加密算法的原理是通过一个系统密钥对用户信息进行加密，但是这个系统密钥也是问题所在，如果系统密钥泄露，黑客能够通过系统密钥解密用户的信息。
3.Hash存储
Hash存储是利用单项散列（杂乱拼凑）函数对用户信息进行运算的，得到的hash值（指纹）存储在数据库中。较加密存储的好处是不需要再保管系统密钥，而且攻击者无法通过hash值逆向推算用户加密的数据信息。
Hash函数的特性，以 H(x)=h 关系式为例：
①固定长度的输出，函数H(x)的输入可以是任意长度，但是h的输出是固定长度的，即将任意长度的输入消息映射成一个固定长度的较短的哈希值
②单向性：已知x，要算出h比较容易，但是已知h，要逆向推算出H(x)是不可行的，个人认为这个和上面的输入输出有关。
③弱碰撞自由性：已知x，要找出y(y≠x)然后使得H(y)=H(x)是不可能的，个人认为和上面第一点的输入输出有关（这或许就是杂乱拼凑的含义关键）
④强碰撞自由性：任意选出两个x和y，使得H(y)=H(x)在计算上是不可行的
强弱碰撞自由性的区别：二者并非矛盾，弱碰撞自由性的意思是给定一个值x，在满足H(x)=H(y)的条件下想要找到另外一个y是不可能的，而强碰撞自由性的意思是要找到任意两个x和y去满足H(x)=H(y)也是不可能的。
常见的hash函数算法：
MD5
SHA系列（SHA-1，SHA-224，SHA-256等等）
二.密码攻击
概念：获取目标数据信息加密后的hash值或者密文，然后使用方法进行解密获取明文的过程。
攻击（破解）方式：
1.暴力攻击（Brute Force Attack）：尝试对所有可能的密钥组合进行相同的hash运算，并将计算结果与与目标密钥的hash值进行对比，若相同则破解成功，这个方式的缺点是花费时间实在过长。
2.字典攻击（Dictionary Attack）：提前构建一个"明文-密文"对应的数据库（类似于字典那种的），获取到密文后直接通过字典查找相关明文。这个方式在使用时时间比暴力攻击快很多，但是缺点是需要花费空间去存储这个字典（实际字典列表都比较长）
3.彩虹表攻击（Rainbow Table Attack）：在字典攻击的基础上改进，以时间换空间，因为彩虹表攻击是根据目标的hash值来与彩虹表中存储的hash值比较，而字典攻击则是比较字符串（明文-密文）来进行比较。
防御方式——hash加盐法
字典攻击和彩虹表攻击之所以有效，是因为每一个密钥都是使用一样的运算方式来进行hash运算的，意思是使用同一个密钥的两个用户，他们的hash运算方式是一样的，密钥hash值也一定属于一类，破解一个就能破解另外一个
加盐法的思路是给hash值再加一个随机的前缀或后缀，增加hash值的复杂度，降低使用相同密钥的用户hash值被同时破解的可能性。加盐后相同密钥运算出的hash值每次也都是不同的值。
hash加盐法密钥加密存储和对比过程
Hashcat工具介绍
Hash作为目前常用的密码恢复工具之一，现在作为免费软件发布。支持多种常用的操作系统和散列算法，如MD4,MD5,SHA,Microsoft LM等等，此外还支持多种运算核心（CPU，GPU这些）。
Hashcat使用流程
1.Kali中启动Hashcat
2.hash常用选项参数：
（1）-a //指定破解模式
①-a 0 //Straight（字典破解）
②-a 1 //Combination（组合破解）
③-a 3 //Brute-force（掩码暴力破解）
④-a 6 //Hybrid Wordlist+Mask（混合式，字典加掩码破解）
注：这里的掩码指的是hashcat的掩码字符集，具体情况如下：
（2）-m //指定加密类型
①-m 900 //MD4
②-m 0 //MD5
③-m 100 //SHA1
④-m 1300 //SHA2-224
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e2899df765517d6e7319dbebf623a4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c0e078edc4f45acfb75ad8ec2eb5915/" rel="bookmark">
			FPN和PAN的内容及区别（修改版1.2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FPN和PAN都是用于解决在目标检测中特征金字塔网络(FPN)在多尺度检测任务上的不足的方法。下面分别详细介绍一下它们的原理和区别。 FPN FPN全称Feature Pyramid Network，是由FAIR在2017年提出的一种处理多尺度问题的方法。FPN的主要思路是通过构建金字塔式的特征图来提取不同尺度下的目标特征，进而提高检测精度。
FPN的构建方式是从高分辨率的特征图开始向下采样，同时从低分辨率的特征图开始向上采样，将它们连接起来形成金字塔。在这个过程中，每一层特征图的信息都会与上下相邻层的特征图融合，这样可以使得高层特征图中的目标信息得以保留，同时低层特征图中的背景信息也可以被高层特征图所补充。经过这样的处理，FPN可以提高模型在多尺度检测任务上的精度，同时还可以在不影响检测速度的情况下提高检测 速度 精度。（原版有错误，此处进行修改）
FPN的主要思想是在图像的不同层次上构建特征金字塔，以便能够捕获不同尺度的物体。
FPN的核心是特征融合，其基本步骤如下：
输入图像经过卷积神经网络，得到一系列特征图，每个特征图对应网络的一层。对于 较浅 较深 的特征图，进行上采样操作，使其尺寸与 较深 较浅 的特征图相同。这里的上采样可以使用插值等方法进行。（原版有错误，此处进行修改）将上采样后的 较浅 较深 特征图与 较深 较浅 特征图进行融合，这里采用的是加法操作。（原版有错误，此处进行修改）对融合后的特征图进行卷积，进一步融合信息。重复步骤2~4，直到所有特征图都进行了融合操作。最终得到的特征金字塔包含多个尺度的特征图，可用于物体检测和分割等任务。
如上图中的d所示。 FPN的融合过程 在FPN中，浅层特征图和深层特征图的融合是通过上采样（up-sampling）和下采样（down-sampling）完成的。具体来说，FPN将深层特征图分解为一系列分辨率更低但语义更高的特征图，并将这些特征图与对应的上采样浅层特征图进行加和融合，最终得到多尺度的特征图。融合的具体过程如下：
自下而上生成金字塔：FPN首先采用ResNet等网络作为骨干网络，自下而上生成一系列特征图，每个特征图的分辨率比上一层低，但语义更高。
自上而下进行特征融合：FPN然后从自下而上生成的特征图序列的顶部（即 最高 最低 分辨率的特征图）开始，通过上采样将其分辨率加倍，然后将结果与该特征图序列中分辨率较低但语义更高的下一层特征图进行加和，从而获得一组新的特征图。FPN将该过程称为“特征上采样（feature up-sampling）”。（原版有错误，此处进行修改）
横向连接进行特征融合：接下来，FPN将新生成的高分辨率特征图（上采样后的图）与 与之相对应的浅层特征图进行加和，从而生成新的特征图。这一过程称为“特征横向连接（feature lateral connection）”，可以有效地将低分辨率特征图中的语义信息传递到高分辨率特征图中。
重复步骤2和3：FPN在步骤2和3中重复使用相同的操作，从而生成多尺度特征图金字塔。在该金字塔中，每个特征图都与不同分辨率的输入图像区域相对应，这使得FPN可以同时对不同尺度的目标进行检测。
总体来说，FPN通过上下采样和横向连接操作实现了浅层和深层特征图的融合，从而提高了检测器对不同尺度目标的检测能力。与PAN不同，FPN使用了上采样操作，这使得FPN生成的特征图具有更高的分辨率，从而能够更好地保留目标的细节信息。
FPN的优点在于能够自然地融合不同尺度的特征图，提高目标检测和分割的准确性。FPN的缺点在于计算量较大，需要耗费较长时间进行训练和推断。
PAN PAN全称Path Aggregation Network，是由Megvii在2018年提出的一种处理多尺度问题的方法。
PAN（Path Aggregation Network）是一个用于图像语义分割的深度神经网络架构。PAN的主要思路是通过聚合来自不同层级的特征图，使得每个特征图中的信息都可以被充分利用，从而提高检测精度。与FPN类似，PAN也是一种金字塔式的特征提取网络，但是它采用的是自下而上的特征传播方式。
PAN的构建方式是从低分辨率的特征图开始向上采样，同时从高分辨率的特征图开始向下采样，将它们连接起来形成一条路径。在这个过程中，每一层特征图的信息都会与上下相邻层的特征图融合，但与FPN不同的是，PAN会将不同层级的特征图融合后的结果进行 加和 级联 ，而不是 级联 加和。这样可以避免在 级联 加和 过程中信息的损失，同时还可以保留更多的细节信息，从而提高检测精度。（原版有错误，此处进行修改）
在PAN中，网络的主干部分通常采用ResNet等常用的卷积神经网络结构。在主干网络的后半部分，PAN引入了一个自下而上的侧边分支，用于将低分辨率的特征图传递到高分辨率的层中。这个侧边分支与主干网络是平行的，由一系列卷积和上采样（即反卷积）操作组成，从而将低分辨率的特征图上采样到与高分辨率的特征图相同的分辨率。
在将不同分辨率的特征图进行融合时，PAN采用了一种类似于FPN的方法，但稍有不同。具体而言，PAN中首先将低分辨率的特征图进行上采样，然后将其与高分辨率的特征图进行拼接，得到一个更加丰富的特征图。接着，对这个特征图进行卷积操作，以得到最终的特征表示。
与FPN相比，PAN中自下而上的特征传播方式更为高效，可以在更少的计算资源下实现更好的语义分割效果。同时，PAN中的特征融合方式也具有一定的优势，能够更好地保留低分辨率特征图中的细节信息，从而提高分割的准确性。
如图所示，b区域是PAN多出的一条自底向上的路径。
区别 FPN和PAN的主要区别在于特征融合方式不同，而且PAN比FPN多了一条自底向上的路径。FPN采用 级联 加和 的方式进行特征融合，会在融合过程中丢失一部分细节信息，因此对于需要高精度检测的场景，可能表现不如PAN。而PAN采用 加和 级联 的方式进行特征融合，可以保留更多的细节信息，但同时也会增加计算量。
参考及图片来自 版权声明：本文为博主原创文章，遵循 CC 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c0e078edc4f45acfb75ad8ec2eb5915/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2450dc5d7e7e7c11093f31d6abcdca1e/" rel="bookmark">
			小狗伪原创在哪，小狗AI仿写智能写作词典
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数字时代，内容创作已成为我们生活中不可或缺的一部分。然而，对于许多创作者来说，创意枯竭和重复内容的问题常常令人困扰。这时，一款名为“小狗伪原创”的智能写作工具应运而生，为创作者们带来了全新的写作体验。
小狗伪原创基于百度智能大脑和NLP自然语言处理技术，能够将已有的文章转换成全新的原创内容。这一特点使得创作者在面临创意瓶颈时，能够快速获得新的灵感和思路。同时，通过避免抄袭和重复内容，小狗伪原创还能提升文章的质量和可读性。
那么，如何找到并使用小狗伪原创呢？其实，寻找小狗伪原创的过程并不复杂。只需在搜索引擎中输入“小狗伪原创”或者访问相关的技术网站，你便能轻松找到这款工具。一旦你找到了小狗伪原创，注册并登录后，便可以开始使用它的各项功能。
小狗伪原创的操作界面简洁直观，即便是不熟悉技术的创作者也能轻松上手。在输入需要转换的文章后，小狗伪原创会迅速进行分析和处理，生成一篇全新的原创文章。你可以根据需要对生成的文章进行进一步的修改和完善，以满足你的创作需求。
值得一提的是，小狗伪原创的NLP技术使得它能够理解文章的语义和上下文关系，从而生成更加准确、自然的原创内容。这意味着你不再需要担心生成的文章会偏离原意或出现语义不通顺的情况。
总之，小狗伪原创作为一款智能写作工具，为创作者们提供了一个全新的选择。它不仅能够帮助解决创意枯竭和重复内容的问题，还能提升文章的质量和可读性。如果你正在寻找一款能够辅助你创作的工具，不妨试试小狗伪原创，相信它会给你带来全新的创作体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6feb42ae83a88a3489e05f383a2e085a/" rel="bookmark">
			UR六自由度机械臂运动学正解、逆解及轨迹规划附带python和C源码&#43;webots仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UR六自由度机械臂运动学正解、逆解及轨迹规划附带python和C源码+webots仿真 (一) 准型DH参数建立坐标系(二) 运动学分析1. 运动学正解分析2. 运动学逆解分析 (三) 轨迹规划(四)源码 前段时间做了两种类型的六轴机械臂，分别是UR型和PUMA型六轴机械臂。实践过程中，在运动学分析和轨迹规划中遇到了很多的坑。比如，运动学正、逆解的起始位姿和自己想要的不一样；逆解的时候遇到奇异解或者解不出来的解应该怎么避免等等；本文会对以上情况做一个总结。
后续我还会写关于如何以STM32F407为核心板，通过运动学正、逆解和轨迹规划来控制UR型和PUMA型六轴机械臂完成作业任务。有舵机版本和步进电机版本。
本文是以标准型DH法建立坐标系，若想了解改进型DH法建立坐标系，可以看我另一篇文章：六轴机械臂运动学正、逆解及轨迹规划带源码
(一) 准型DH参数建立坐标系 图1 机械臂起始位置图 图2 机械臂正视图 标准型DH建立坐标系方法：
z轴：与旋转轴共线。
x轴：Xi轴同时垂直于Zi轴和Zi-1轴。（x0可以任意选方向）
y轴：使用右手定则确定。（大拇指指向x轴、中指指向z轴，食指的指向为y轴方向）
标准型DH参数确定方法：
标准型 DH 参数表：
注：该表是以图 2 确定的 DH 参数。 θ \theta θ列代表着，第二关节、第四关节顺时针旋转 90°(以图 1 视角往里看顺时针旋转 90°)，可以转换成图 1 所示姿态。
重点(建议先看后面的运动学正解和逆解，然后在返回来看)：
求解运动学正解时，当给的各个关节角度分别为(0°,0°,0°,0°,0°,0°)时，求出的位姿对应的是图 1 的位姿。也就是说，通过标准 DH 参数法建立的坐标系，用运动学正解求解出的起始位姿为图 1 的位姿。如果想要转换成图 2 的位姿，则需要给各个关节角度分别为(0,-90,0,-90,0,0)。运动学逆解求出的角度值，也是基于图 1 起始位姿的角度值。比如，当你输入位姿:(-270.0, -100.59, 84.0, 1.5707963, -0.0, 0.0)时，运动学逆解求出的角度值为：(0°,0°,0°,0°,0°,0°)；当你输入位姿:(0.0, -100.59, 504.0, -1.5707963, -0.0, 3.1415927)时，运动学逆解求出的角度值为：(0°,-90°,0°,-90°,0°,0°);
总结：当你在实际项目中时，肯定使用的是图 2 所示的起始位姿。那么需要转换 一 下 起 始 位 姿 。 当 求 解 运 动 学 正 解 时 ， 输 入 格 式(th1,th2-90°,th3,th4-90°,th5,th6)；th1 到 th6 为我们想要机械臂以图 2 的起始位姿旋转的角度值。当求解运动学逆解时，输入格式不变(x,y,z,gama,beta,alpha)，输出时需要在求得的第二角度和第四角度上分别加上 90°。那么最终得到的角度值是以图 2 为起始位姿的角度值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6feb42ae83a88a3489e05f383a2e085a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f0441421bf31b4749fcdba95fc8da1f/" rel="bookmark">
			探索数据结构：深入了解顺序表的奥秘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨✨ 欢迎大家来到贝蒂大讲堂✨✨
🎈🎈养成好习惯，先赞后看哦~🎈🎈
所属专栏：数据结构与算法
贝蒂的主页：Betty’s blog
1. 什么是顺序表 顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，它与数组非常类似，但是相比于数组顺序表有一个非常明显的优点——可以动态内存增长空间大小
2. 顺序表的功能 顺序表可以大致包含以下几个功能：
初始化顺序表中的数据。
打印顺序表中的数据。
对顺序表进行尾插(末尾插入数据)。
对顺序表进行尾删(末尾删除数据)。
对顺序表进行头插(开头插入数据)。
对顺序表进行头删(开头删除数据)。
对顺序表就像查找数据。
对顺序表数据进行修改。
任意位置的删除和插入数据。
销毁顺序表。
3. 顺序表的定义 定义顺序表我们首先需要一个动态内存开辟的空间，当前数据的个数(size)，以及方便扩容的容量大小(capacity)。
typedef int SLDataType; //类型重命名，方便后续修改类型 #define N 4 //初始化空间大小 typedef struct SeqList { SLDataType* a; //指向动态开辟的数组 size_t size; //有效数据个数 size_t capacity; //容量大小 }SeqList; 4. 功能的具体实现 4.1 初始化顺序表 (1) 代码实现 初始化顺序表时我们可以先开辟四个空间，之后不够再进行扩容。
void SeqListInit(SeqList* p) { assert(p); //断言 p-&gt;a =(SLDataType*)malloc(N*sizeof(SLDataType)); //初始顺序表为四个空间 if (p-&gt;a== NULL) { perror("malloc fail:"); return ; } p-&gt;size = 0; //初始数据个数为0 p-&gt;capacity = 4; //初始空间容量为4 } (2) 复杂度分析 时间复杂度：由于没有其他未知数的引入，所以所需时间是个常数，也就是O(1)。空间复杂度：动态开辟N个空间，所以空间复杂度为O(N)。 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f0441421bf31b4749fcdba95fc8da1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/399dae0c055d332541432d6a02df42aa/" rel="bookmark">
			kafka 可视化工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kafka可视化工具 随着科技发展，中间件也百花齐放。平时我们用的redis，我就会通过redisInsight-v2 来查询数据，mysql就会使用goland-ide插件来查询，都挺方便。但是kafka可视化工具就找了半天，最后还是觉得redpandadata/console这款web ui工具比较好用，尤其对于团队来说，一次安装，全员使用，就不需要每个人都安装一遍了。废话少说，直接上图
平时我们几乎都是查询topics 和 consumer 比较多，选择topics选项卡，右边就会显示kafka当前所拥有的topic，要查看某个 topic里面的消息，直接点击相应topic就能进到相应页面。非常方便，目前支持 创建topic，按照最新50条查询topic 消息。删除topic，删除消费者组，查看消费者组，查询消息所属partition等等。几乎涵盖平常我们使用的所有功能。
安装方式：我们目前是使用docker部署，直接上脚本
docker run -d --name redpandaui -p 8080:8080 -e KAFKA_BROKERS=172.17.0.2:19092,172.17.0.2:29092,172.17.0.2:39092 redpandadata/console:latest 其中 KAFKA_BROKERS 就是我们部署的kafka 集群地址，如果不是集群，直接填 boostrap server地址就行。 安装后通过访问 localhost:8080就能看到kafka的控制面板了，十分方便，赶紧去试试吧。good luck
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e6d513304f8f865aec0382ebe75b14c/" rel="bookmark">
			Spring Boot 3项目集成Swagger3教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot 3项目集成Swagger3教程 🌟 前言 欢迎来到我的小天地，这里是我记录技术点滴、分享学习心得的地方。📚
🛠️ 技能清单 编程语言：Java、C、C++、Python、Go、前端技术：Jquery、Vue.js、React、uni-app、EchartsUI设计: Element-ui、Antd、Color-ui后端技术：Spring Boot、Mybatis-plus、Swagger移动开发：Android操作系统：Windows、Linux开发框架：RuoYi、微信小程序开发工具：VSCode、IDEA、Eclipse、WebStorm、HbuildX、Navicat、Xshell、Android Studio、Postman数据库技术：MySQL、Redis、SQL Server版本控制：Git Swagger是一个用于设计、构建、记录和使用RESTful web服务的开源软件框架。Swagger 3（OpenAPI 3.0）提供了更加强大和灵活的API文档生成能力。本教程将指导您如何在Spring Boot 3项目中集成Swagger3，并使用Knife4j作为UI界面。
1. 添加依赖 首先，您需要在项目的pom.xml文件中添加Swagger3的依赖。同时，为了确保依赖能够正确下载，您可以添加阿里云的Maven镜像仓库。
&lt;!--swagger3--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-openapi3-jakarta-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;4.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;repositories&gt; &lt;!--阿里云镜像--&gt; &lt;repository&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; 2. 配置Swagger 在Spring Boot项目中创建一个配置类SwaggerConfig，并添加Swagger的配置信息。
import io.swagger.v3.oas.models.ExternalDocumentation; import io.swagger.v3.oas.models.OpenAPI; import io.swagger.v3.oas.models.info.Contact; import io.swagger.v3.oas.models.info.Info; import io.swagger.v3.oas.models.info.License; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class SwaggerConfig { @Bean public OpenAPI springShopOpenAPI() { return new OpenAPI() .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e6d513304f8f865aec0382ebe75b14c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87a3dd8bc9e1092a10e453e737734cd8/" rel="bookmark">
			coqui-ai/TTS 安装使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Coqui AI的TTS是一款开源深度学习文本转语音工具，以高质量、多语言合成著称。它提供超过1100种语言的预训练模型库，能够轻松集成到各种应用中，并允许用户通过简单API进行个性化声音训练与微调。其技术亮点包括但不限于低资源适应性（如YourTTS模型可处理有限或零样本数据），实时流式传输功能（支持200毫秒级延迟）以及强大的跨语言克隆能力。
安装：
pip install TTS 根据提示配置环境，比如Microsoft C++ Build Tools，安装完成可以进行语音生成: 示例：
import torch from TTS.api import TTS # Get device device = "cuda" if torch.cuda.is_available() else "cpu" # List available 🐸TTS models print(TTS().list_models()) # Init TTS tts = TTS("tts_models/multilingual/multi-dataset/xtts_v2").to(device) # Run TTS # ❗ Since this model is multi-lingual voice cloning model, we must set the target speaker_wav and language # Text to speech list of amplitude values as output wav = tts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87a3dd8bc9e1092a10e453e737734cd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1be68f299dee73620c2ba74a203e064c/" rel="bookmark">
			快速搭建Python（Django）&#43;Vue环境并实现页面登录注册功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 创建vue项目及环境搭建1. 创建vue项目2. 配置axios3. 创建vue组件login和register4. 设置并引用路由vue-router5. 完成login，register组件代码6. 完成App.vue的代码 二. 创建django项目及环境搭建1. 创建django项目2.配置mysql数据库3. 创建应用app4.创建模型model5. 安装rest_framework组件6. 创建视图代码6. 路由配置7. 跨域设置 三. 启动并验证项目 一. 创建vue项目及环境搭建 1. 创建vue项目 选择一个要存放代码位置，使用cmd进入该位置，然后输入npm init vue@lastest创建vue项目然后输入项目名称，其余都选择NO创建好项目之后，使用cd命令进入创建好项目的目录执行npm install命令即可创建好一个vue项目 vue项目的启动命令为npm run dev
使用VsCode打开创建的项目，删除一些默认页面的东西
2. 配置axios 我们发送http使用axios发送请求，所以在main.js中全局引入axios，并设置一些配置信息
使用axios之前，需要先安装axios，打开终端使用npm install axios命令进行下载
下载完后在main.js中进行全局引用和配置，此时App.vue中的代码如下所示
import { createApp } from 'vue' import App from './App.vue' import axios from 'axios' const app = createApp(App) //axios发送http请求的目标地址的基础路径 axios.defaults.baseURL = "http://localhost:8000" app.config.globalProperties.$axios = axios app.mount('#app') 在别的组件中可以使用this.$axios来获取配置好的axios
3. 创建vue组件login和register 在components目录下创建登录及注册两个vue文件，login.vue和register.vue
4. 设置并引用路由vue-router 先在终端使用npm install vue-router@4命令安装vue-router
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1be68f299dee73620c2ba74a203e064c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a96c24027246689a9aca08a61bf01abd/" rel="bookmark">
			【AI绘画】Stable Diffusion学习——自用大模型分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Checkpoint 模型存放路径：stable-diffusion-webui/models/Stable-diffusion
majicMIX realistic 麦橘写实 写实系的人像大模型，一种能够渲染出具有神秘或幻想色彩的真实场景的效果，出图很稳定。我经常使用这个模型来生成一些真实的人像图片
下载地址：civitai.com/models/43331
XXMix_9realistic_v4.0 拥有很好的光影效果的模型作品，真人和2.5D的出图效果都很好，可以根据关键词进行变种，可以创造属于自己的风格化图片。
下载地址：civitai.com/models/47274
GhostMix 二次元模型，一款很适合新手入门的模型，画风与其他lora模型的兼容性是最好的，2D-3D都可以兼容。出图很厉害的，目前是C站模型榜一
下载地址：civitai.com/models/36520
MeinaMix 这是一个人物风格比较偏可爱，二次元的模型。出图也是很稳定的。
下载地址：civitai.com/models/7240
ReV Animated 写实偏艺术性的一款模型，可生成的图片范围极广，风景、人物动物皆可，对提示词的反馈也很丰富。适用于动漫人物或场景的 2.5D 或 3D 绘制模型。
下载地址：civitai.com/models/7371
AWPainting 这是一款提高了画面光效、人物动作多样性的模型，让人物五官更鲜明和具有辨识度，适用性比较广，直出效果好，像插画、二次元、2D绘画都能出图。
下载地址：civitai.com/models/84476
AbyssOrangeMix2 俗称深渊橘或橘子模型，全能且出色的典型二次元插画风模型，类似油画的艺术风格和可爱的动漫风格。可以生成逼真纹理的插图。
下载地址：civitai.com/models/4437
Dark Sushi Mix 大颗寿司Mix 独有暗色调风格的厚涂插画模型。它全现绘制出的画面质感与TMND-Mix会有些相似，但少了几分精致感，多了一点漫画特质，整体色调偏阴郁，明暗对比强烈，富有独特的艺术美感，配合合适的提示词可以呈现出非常高水准且有欣赏价值的画面。
下载地址：civitai.com/models/24779
Flat-2D Animerge 这是一些基于随机动漫和基于卡通的模型的融合，以实现某种卡通化的动漫风格，与更常见的超详细动漫模型相比，更类似于你在动漫中实际看到的内容。
下载地址：civitai.com/models/35960
注意：模型下载地址需要科学上网哟~
以上是本次分享全部内容。
非常感谢您阅读本篇博客文章。希望这篇文章能够为您提供有价值的信息，并帮助您解决问题或增长知识。如果您对文章内容有任何问题、建议或反馈。同时，也欢迎您继续关注我的博客，获取更多有趣、实用的内容。
期待与您在下一篇文章再次见面。谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e1e6ed285d2d392431da4a111326d75/" rel="bookmark">
			Frida实战：Java、Native、SO层面的Hook与主动调用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 Frida是一款强大的动态代码插桩工具，支持对Android和iOS应用进行实时调试和注入。本文将通过实例详细解析如何在Frida中实现对Java层、Native层（JNI）以及.so库内函数的Hook与主动调用。
一、Hook Java层函数 首先，我们展示如何使用Frida Hook Java层的方法：
Javascript
// 引入Frida的Java API
Java.perform(function () {
// 获取待Hook的目标类
var targetClass = Java.use(‘com.example.target.ClassName’);
// 定义要Hook的方法 targetClass.methodToHook.implementation = function (...args) { console.log("成功Hook到Java方法: " + this.toString()); console.log("方法参数: ", args); // 调用原始方法 var originalResult = this.methodToHook.apply(this, args); // 在原始方法执行后添加自定义逻辑 console.log("方法返回值: ", originalResult); return originalResult; }; });
二、Hook Native层（JNI）函数 接下来，我们演示如何Hook JNI/Native层的函数：
Javascript
// 获取目标so库模块
var libtarget = Module.findExportByName(‘libnative.so’, ‘native_function’);
// 定义Hook逻辑
Interceptor.attach(libtarget, {
onEnter: function (args) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e1e6ed285d2d392431da4a111326d75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/647fe561661a8c9ee549ba6d4688288b/" rel="bookmark">
			Android Studio Plugin [id: ‘com.android.application‘, version: ‘8.2.2‘, apply: false] was not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Build file 'D:\AndroidProject\HelloWordle\build.gradle.kts' line: 2
Plugin [id: 'com.android.application', version: '8.2.2', apply: false] was not found in any of the following sources:
* Try: &gt; Run with --info or --debug option to get more log output. &gt; Run with --scan to get full insights. &gt; Get more help at https://help.gradle.org.
* Exception is: org.gradle.api.plugins.UnknownPluginException: Plugin [id: 'com.android.application', version: '8.2.2', apply: false] was not found in any of the following sources:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/647fe561661a8c9ee549ba6d4688288b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55e3227df56e52081cbe30897ff9f52e/" rel="bookmark">
			java计算日期相差天数的4种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法1：long值相减（推荐）
public static void main(String[] args) { DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); try { Date startDate = dateFormat.parse("2024-03-01 10:00:00");//开始时间 Date endDate = dateFormat.parse("2024-03-02 14:00:00");//结束时间 long msNum = endDate.getTime()-startDate.getTime();//时间戳相差的毫秒数 long dayNum = msNum/(24*60*60*1000)//除以一天的毫秒数，得到相差天数 System.out.println("相差天数为："+ dayNum); } catch (ParseException e) { e.printStackTrace(); } } 方法2：
public static void main(String[] args) { DateFormat dft = new SimpleDateFormat("yyyy-MM-dd"); try { Date star = dft.parse("2020-02-03");//开始时间 Date endDay=dft.parse("2025-03-02");//结束时间 Date nextDay=star; int i=0; while(nextDay.before(endDay)){//当明天不在结束时间之前是终止循环 Calendar cld = Calendar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55e3227df56e52081cbe30897ff9f52e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18a2c3d429c8785db3f4d5737a57886e/" rel="bookmark">
			怎样通过小红书AI绘画赚钱？AI艺术创收日入2900
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今年最热门的技术莫过于人工智能（AI），公认最强通用大模型为ChatGpt。此外，许多面向垂直领域的AI也相继问世，如绘画AI Midjourney、PPT制作AI Tome以及写作AI Notion等。
随着AI热潮的不断高涨，AI生成文本、图片、视频的应用遍地开花。门槛不高、花样颇多的小红书，成了AI刷脸的“集中营”。
最近，我也使用NotionAI模仿小红书风格进行了一篇文章的创作，节省了很多人工成本。
所以，我想分享一个小红书上的AI绘画项目。
前段时间，我在小红书上看到了一个做AI绘画的账号，其作品都是美女图。我点进去一看，这似乎就是图片漫改玩法，只不过这个账号使用了AI效果模板。
但是，这种虚拟项目基本上是零成本的，除了时间成本之外。然而，这个账号的作品都是AI生成的，极具吸引力。
然而，这个账号并不仅仅是吸引人们点击查看作品。该账号的个人介绍中写着支持AI定制，于是我私信了解并加了他的微信，询问了一下价格。
他的收费标准大致如下：如果你提供单人图片，他可以帮你制作成AI风格的图，每张收费29元。
我想，这也太暴利了吧。毕竟，使用软件生成一张AI图只需要20秒钟，他一天做10张就可以赚很多钱，甚至比正常工作还要赚得多。
一天如果有10个客户，一个客户10张，那么一天就是10x10x29=2900元
怎样运营小红书AI绘画项目？ 小红书账号注册和养号环节 在项目早期，需要进行单号操作。在后期，需要使用多个账号，每个账号使用单独的设备和卡。
新账号不应该直接发布内容，因为它们没有影响力。最好养护这些账号一周左右，每天花半小时浏览内容并学习AI相关知识，以模拟正常用户行为。
制作发布素材的方式 尽量避免使用其他人的图片，以免被认为是侵权行为。虽然Midjourney功能强大，但是相对比较复杂。因此，建议使用另一个将操作简化的APP——无界AI。
该APP是国内领先的APP，可安心使用。使用该APP，可以使用其他人的咒语，点击一键同款即可生成图片。
如果不喜欢生成的图片，可以继续生成，直到满意为止。需要注意的是，由于使用AI技术，每张生成的图片都是原创，有些咒语参数不稳定，有时生成出来的图片很难看。
因此，需要多测试，将比较稳定的咒语和参数保存下来。
如何将流量引导到私域？ 也就是将流量导入微信，需要倒推。可以复制同行的个人介绍，然后伪装成客户给同行发送私信。根据同行的回复内容，给客户回复。可以甚至添加同行的微信号，查看其朋友圈的包装方式，并直接模仿。
如何处理订单和服务客户？ 处理订单和服务客户非常简单。使用该APP有两种方法：
第一种是一键生成图片，将客户发送的图片保存到手机上，上传后，选择照改漫即可。
第二种方法是使用之前收藏的咒语和参数，将客户发送的图片作为参考图上传，生成的图片就和客户发送的图片一致了。生成后，保存并发送给客户。
由于是使用AI技术生成图片，不要将平台上的流量视为傻瓜，每次生成的图都不同，质量也有好有坏。
我们需要挑选高质量的图片进行发布，每组发布3-5张图片，特别是小红书的封面图非常重要，直接影响到点击率。
小红书的文案可以直接参考同行，并通过更改几个字来适应不同的场景。还可以使用NotionAI生成小红书风格的文案。
关于AI技术储备 可能大家都想学习AI技术,也想通过这项技能真正赚到钱，但是不知道该如何开始学习，因为网上的资料太多太杂乱了，如果不能系统的学习就相当于是白学。为了让大家少走弯路，少碰壁，这里我直接把全套AI入门资料、操作变现玩法都打包整理好，希望能够真正帮助到大家。
朋友们如果需要可以微信扫描下方二维码免费领取【保证100%免费】
现在收入上来后，生活彻底变了样，点外卖，网购，再也不用被食品、商品的价格所困扰，想吃啥，想买啥通通入手，主打的就是一个自在享受。
我当时入门用到的AI全套教程给大家整理好放在下面了，如果你现在也因为钱，穷被瞧不起，过不上好的生活，强烈建议你去学习一下，真的能帮你少走不少弯路，早点上岸赚钱~ 朋友们如果需要可以微信扫描下方二维码免费领取【保证100%免费】
在可预见的未来，随着AI大范围在职场推广，使用门槛降低，部分还在做重复工作的打工人会不可避免地被取代。
这也是为什么身边越来越多人都在学AI。
负责任地说，这是AI离普通人超近的一次。它——
很简单： 只要你有一个浏览器，登录一个网页，会打字、会聊微信就能够直接使用。
很实用： 任何上班族，无论你的工作涉及文字、图片、数字，或是办公软件全家桶，它都能成为你的高效助理。
很聪明： AI如同一个六边形战士，当你有个绝妙点子，它能随时点亮技能树，用编程、写作、绘画技能把你的想法落地。
随着人工智能的推广，具备AI技能的人将更容易适应未来岗位需求，成为早期吃到红利的稀缺人才。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11288ceae09af81d676498f1f40707c5/" rel="bookmark">
			【AIGC调研系列】embeding模型有哪些，各有什么优势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在AIGC中，Embedding模型是一种将文本数据转换为多维向量数组的技术，这些向量可以代表任何事物，如文本、音乐、视频等[2]。有几种不同的Embedding模型，它们各有其优势和应用领域。
Word2vec：这是一种经典的嵌入模型，通过学习单词之间的长距离依赖关系来生成向量。它的优势在于能够有效地捕捉到词语之间的关系，使得模型能够理解和处理复杂的文本结构[4][5]。众安Embedding模型：在中文通用FAQ数据集上，众安Embedding模型表现出色，尽管优势已不如以前那么大[3]。这表明该模型在中文数据集上具有较好的性能。Nomic Embed：这是首个开源、开放数据、开放权重、开放训练代码、完全可复现和可审核的嵌入模型。它的上下文长度为8192，显示出在特定场景下的高效性[18]。OpenAI Embedding Models：OpenAI推出了一系列新型嵌入模型，包括更小、高效的text-embedding-3-small模型和更大、更强大的text-embedding-3-large模型。这些模型具有更低的定价，适用于表示自然语言或代码等内容中的概念[21]。 每种Embedding模型都有其独特的优势，例如Word2vec擅长处理复杂的文本结构，而众安Embedding模型在中文数据集上表现优异。Nomic Embed则以其开源和可复现的特性受到开发者的青睐。OpenAI的嵌入模型则提供了更多样化的模型选择，满足不同应用场景的需求。
Embedding模型在处理中文数据时的具体优势和挑战是什么？ 语义理解能力：Embedding模型通过词向量来表示文本，能够捕捉到词汇之间的语义联系，相比之下，基于关键词的检索往往关注字面匹配，可能忽略了词语之间的语义联系[24]。这一点在搜索引擎、构建私有知识问答系统、内容推荐系统等应用中尤为重要[27]。容错性：基于Embedding的方法能够理解词汇之间的关系，从而提高了模型的容错性[24]。在面对错误或不完整的数据时，Embedding模型能够更好地保持其准确性和可靠性。支持中文：一些Embedding模型，如BGE，对中文数据的支持效果较好，是中文embedding模型中为数不多的优质选择[28]。这表明在中文数据处理方面，Embedding模型具有较强的应用潜力。 然而，Embedding模型在处理中文数据时也面临着挑战：
性能差异：尽管有些模型在中文处理上有优势，但不同模型的性能可能存在显著差异。例如，text2vec在STS-B测试集中的效果优势下降，与MiniLM效果相近[23]。这意味着在选择Embedding模型时，需要考虑到不同模型的性能表现。模型部署和优化：虽然有些模型已经开源并方便本地私有化部署[26]，但在实际应用中，如何有效地部署和优化这些模型，以适应特定的业务需求，仍然是一个挑战。特定领域的适用性：特定领域的专有模型通常比通用模型表现更好，尤其是当模型的参数量较小时[29]。这提示我们在处理特定任务时，可能需要考虑使用专门针对该任务的Embedding模型，而不是通用的Embedding模型。 Embedding模型在处理中文数据时的优势在于其强大的语义理解能力、高容错性以及对中文数据的良好支持。然而，选择合适的模型、有效部署和优化模型以及根据特定任务选择专有模型等挑战，也是处理中文数据过程中需要注意的问题。
Word2vec与其他Embedding模型（如Nomic Embed和OpenAI Embedding Models）在性能上的比较研究有哪些？ 模型架构和训练方式的差异：Word2vec和其他模型如Bert、GPT-3等，虽然都利用了单词的周边信息，但它们在使用周边信息的方式、模型架构以及训练方式上存在显著差异。这些差异导致了对单词的表征效果有所不同[32]。例如，Word2vec模型结构相对简单，主要通过连续词袋模型（CBOW）和Skip-gram模型来处理输入数据，以降低模型复杂度并在大规模数据上进行训练[38][39]。而OpenAI的文本嵌入模型，如OpenAI的text embedding 002，通常基于更复杂的深度学习模型[38]。性能的具体比较：尽管没有直接的性能比较结果被明确提及，但是从现有的研究中可以推断出不同模型的性能比较。例如，有研究对比了GPT-3、Bert、GloVe与Word2vec在性能上的差异[37]。此外，OpenAI公布的embedding endpoint也是基于神经网络模型，将文本和代码转换为向量表示，嵌入到高维空间中[33]。这表明OpenAI的文本嵌入模型在技术实现上可能更为先进。应用场景的差异：Word2vec因其简单的模型结构和高效的训练方法，特别适合于需要大规模处理能力的应用场景，如文本分类、情感分析等[34]。而OpenAI的文本嵌入模型则更侧重于链接大模型与外部知识，适用于需要处理复杂语义信息和跨领域知识的应用场景[37]。 Word2vec与其他Embedding模型在性能上的比较研究显示了各自的优势和局限性。Word2vec以其简单高效的特点，在特定的应用场景下表现出色；而OpenAI的文本嵌入模型则在技术实现和应用范围上展现出更多的灵活性和复杂性。
如何优化Embedding模型以提高其在特定领域的应用效果？ 领域特定模型训练：针对特定领域（如医疗、法律）训练Embedding模型，以提高在特定上下文中的准确性[42]。这意味着在训练Embedding模型时，需要考虑到特定领域的特定需求和特点，以确保模型能够更好地适应这些领域。基于组合的方法优化：不应局限于使用q和r两个矩阵，而是可以采用q，r，z，k等多个矩阵的组合方式来优化embedding层。这种方法虽然能降低embedding的参数量，但可能会显著影响模型的性能[41]。因此，选择合适的矩阵组合方式对于模型的优化至关重要。利用开源模型资源：参考全球权威Embedding评测榜单上排名靠前的开源模型，如数元灵开源的Embedding模型，可以为AI Native应用开发提供强大的支持[43]。开源资源通常经过了广泛的应用验证，能够有效提高模型的应用效果。优化算法的选择：在广告/推荐领域，可以使用针对性的优化算法，如FTRL（Fine-tuning with Regularization），这种方法适用于对高维稀疏模型进行训练[44]。此外，Deep Hash Embedding (DHE)也是一种有效的优化方法，特别是当字典大小过大时，DHE能够有效压缩Embedding[45]。fine-tuning技术应用：通过使用特定领域的标注数据，对模型的权重进行微调，可以使模型更好地理解和处理特定领域的文本数据[46]。这种技术的应用可以显著提升模型在特定领域中的表现。稀疏特征的优化表示：对于推荐系统中存在海量稀疏特征的问题，可以通过优化表示方法来解决。例如，通过手工测试来寻找好的Embedding大小，或者采用其他稀疏特征Embedding的优化方法[49]。RAG和微调技术的结合使用：在提升大语言模型性能的过程中，检索增强生成（RAG）和微调（Fine-tuning）两种方法都有其优势。根据微软的指南，在建设特定领域的应用时，可以根据具体情况选择更高效的方法[50]。 优化Embedding模型的关键在于深入理解特定领域的需求，合理选择和组合优化方法，以及利用开源资源和先进的技术手段。通过这些方法，可以有效提高Embedding模型在特定领域的应用效果。
Embedding模型在自然语言处理以外的应用案例有哪些？ Embedding模型在自然语言处理（NLP）之外的应用案例主要包括计算机视觉（CV）领域。Embedding模型能够将高维度的数据转化为低维度的向量空间，这一特性使得它在处理图像数据时表现出色[52]。例如，在计算机视觉中，Embedding模型可以用于图像分类、目标检测、图像分割等任务中。通过将图像中的特征映射到低维度的向量空间，Embedding模型能够捕捉到图像的深层信息，从而提高这些任务的性能[53]。
此外，Embedding模型在其他领域的应用也逐渐增多，尽管文献中没有直接提及具体的应用案例，但根据其在自然语言处理和计算机视觉中的应用背景，我们可以推断出Embedding模型在图像识别、视频分析等领域也有潜在的应用价值。例如，在图像识别领域，Embedding模型可以用于训练模型，以识别和分类不同类型的图像。在视频分析中，Embedding模型可以用于理解和分析视频内容，如动作识别、情感分析等[54]。
虽然文献中没有直接列出Embedding模型在除自然语言处理外的其他应用案例，但根据其在自然语言处理和计算机视觉中的应用背景，我们可以合理推测Embedding模型在图像识别、视频分析等领域也有广泛的应用潜力。
最新的Embedding模型技术发展趋势是什么？ 多阶段训练过程的引入：BGE M3-Embedding采用了多阶段训练过程，结合自动编码和弱监督对比学习，这种方式不仅可以提高模型的性能，还能避免预训练方式之间的冲突，预示着未来Embedding模型技术可能会发展出更多创新的训练方式[59]。模型大小的优化：OpenAI推出的text-embedding-3-small模型和text-embedding-3-large模型，分别代表了更小且高效以及更大且更强大的文本嵌入模型，这表明了在嵌入模型设计上追求性能和效率的平衡[60]。技术和成本的权衡：OpenAI新模型使用的嵌入技术允许开发人员在使用嵌入时权衡使用嵌入的性能和成本，通过在dimensions API参数中传递嵌入而不丢失其概念，这种方法有助于开发者更灵活地应用嵌入技术[61]。多模态模型的发展：GPT-4作为GPT系列中的最新版本，支持图像和文本类型的输入，这是一个重要的发展趋势，标志着Embedding模型技术正在向支持更广泛输入类型（如图像）的方向发展[64]。开源和复现的重要性：Nomic Embed模型的推出，作为首个开源、开放数据、开放权重、开放训练代码的嵌入模型，强调了开源和复现在技术发展中的重要性，这对于推动技术的普及和创新具有积极作用[67][68]。 最新的Embedding模型技术发展趋势是向着多阶段训练、模型大小优化、技术与成本的权衡、多模态支持以及开源和复现的方向发展，这些趋势共同推动了Embedding模型技术的进步和应用范围的扩大。
参考资料
[1]. 【AIGC】Embedding与LLM：token长度限制困局下 - 博客园
[2]. 【AIGC】All you need is Embedding？Token长度困境下的泛长文本LLM应用 - 知乎
[3]. 优雅！比OpenAI更认真的文本嵌入模型 - 稀土掘金
[4]. AIGC｜Embeddings入门详解！手把手带你训练 - 融·项目管理
[5]. AIGC｜Embeddings入门详解!手把手带你训练 - 知乎
[6]. 大模型应用实践：AIGC探索之旅 - 网易
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11288ceae09af81d676498f1f40707c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d086a3696d3b898cef0a06e76835e81f/" rel="bookmark">
			mac python下载安装教程,python在mac上怎么下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要介绍了mac python下载安装教程，具有一定借鉴价值，需要的朋友可以参考下。希望大家阅读完这篇文章后大有收获，下面让小编带着大家一起了解一下。
Mac 安装 Python2、Python3 。
零、基础准备 官网 https://www.python.org/下载入口 https://www.python.org/downloads/https://www.python.org/downloads/macos/ 一、安装包下载及安装 安装包下载的页面路径是：官网&gt;&gt;&gt; Downloads&gt;&gt;&gt; macOS
其他平台根据请自己的实际情况选择
安装包下载的页面路径也可以是：官网&gt;&gt;&gt; Downloads(点击)
进入到版本选择页面
最上面是最新的 Release 版本，分别是2.x的最新版本和3.x的最新版python怎么画拱形。
可以下载最新的 Release 版本进行安装，也可以通过搜索选择自己想要的版本进行安装。
通过搜索找到「2.7.16」
通过搜索找到「3.9.9」
强烈推荐下载最新的 Release 版进行安装
点击对应的链接分别下载即可(下载的过程中注意操作系统的架构和位数)。
👆下载「2.7.18」
👆下载「3.10.6」
👆下载好的安装包
使用下载好的安装包一直「下一步」即可安装对应版本的 python。
二、安装确认 1、Python2 查看版本号 $ python -V Python 2.7.18 帮助命令 $ python -h usage: /Library/Frameworks/Python.framework/Versions/2.7/Resources/Python.app/Contents/MacOS/Python [option] ... [-c cmd | -m mod | file | -] [arg] ... Options and arguments (and corresponding environment variables): -b : issue warnings about comparing bytearray with unicode (-bb: issue errors) -B : don't write .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d086a3696d3b898cef0a06e76835e81f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdd19265cc5f411b00d4337cc251e7e7/" rel="bookmark">
			PyCharm安装GitHub Copilot（最好用的AI编程插件之一，高校认证免费使用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 GitHub Copilot简介PyCharm安装Copilot教程 GitHub Copilot简介 GitHub Copilot 是由 GitHub 和 OpenAI 共同开发的一款人工智能辅助编程工具。它是一个基于机器学习的代码编写插件，旨在为开发人员提供即时的代码建议和自动补全功能。
GitHub Copilot 使用了大规模的开源代码库进行训练，并利用自然语言处理和深度学习技术来理解开发人员在编写代码时的上下文和意图。它可以在开发过程中根据代码的上下文和注释，为用户提供实时的代码片段、函数和类的建议，同时提供自动补全、重构和错误检查等功能。
GitHub Copilot 的主要功能和特点：
代码补全：Copilot 可以根据上下文为您提供实时的代码补全建议，节省编写代码的时间和精力。
代码片段：Copilot 可以根据您的代码需求生成包括函数、类和方法等代码片段，使您能够更快速地构建功能。
上下文感知：Copilot 能够理解代码的上下文和意图，根据您正在编写的代码自动生成合适的建议。
多语言支持：Copilot 支持多种编程语言，包括 Python、JavaScript、TypeScript、Go、Ruby 等，使其适用于各种开发环境。
错误检查：Copilot 可以帮助您检测代码中的常见错误，并提供修复建议，提高代码的质量和可靠性。
重构支持：Copilot 可以帮助您重构代码，提供重命名、提取函数和变量等功能，提升代码的可读性和可维护性。
文档和注释：Copilot 可以为您生成函数和类的文档注释，减少编写文档的工作量。
自定义模板：Copilot 支持自定义代码模板，可以根据您的开发习惯和团队规范进行个性化配置。
PyCharm安装Copilot教程 打开PyCharm → \rightarrow →设置 → \rightarrow →插件 → \rightarrow →搜索copilot → \rightarrow →安装GitHub Copilot： 安装完成后 → \rightarrow →重启PyCharm → \rightarrow →弹出窗口提示需要绑定GitHub账户 → \rightarrow →复制窗口中的8位口令密码 → \rightarrow →在弹出的网页界面粘贴口令密码 → \rightarrow →成功绑定GitHub账户： 测试插件效果：如下图所示，我只输入了if __name__ == "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdd19265cc5f411b00d4337cc251e7e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9091a2d8fe5311adf2028c3991d31ac5/" rel="bookmark">
			图解KMP算法，带你彻底吃透KMP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模式串匹配——KMP算法 KMP算法一直是一个比较难以理解的算法，本篇文章主要根据《大话数据结构》中关于KMP算法的讲解，结合自己的思考，对于KMP算法进行一个比较详细的解释。
由于博主本人水平有限，难免会出现一些错误。如果发现文章中存在错误敬请批评指正，感谢您的阅读。
字符串模式匹配介绍 相信学习过数据结构与算法的同学一定不会对字符串感到陌生，字符串的逻辑结构与线性表很类似，不同之处是字符串中的元素都是字符。对于字符串这一数据结构，寻找字符串中子串的位置是最重要的操作之一，查找字串位置的操作通常称为串的模式匹配。而KMP算法就是一种字符串模式匹配算法，在介绍KMP算法之前，我们首先了解以下朴素的模式匹配算法是怎样进行的。
朴素的模式匹配算法 假设我们的主串S=“goodgoogle”，子串T=“google”，我们需要在主串中找到子串的位置，比较朴素的想法是用两个指针(指针其实也就是下标i,j)分别指向主串和子串，如果两个指针指向的元素相同则指针后移，不相同则需要回退指针(主串指针回退到上次匹配首位的下一个位置，子串指针回退到开头位置)，重复进行上述操作直到主串指针指向主串末尾，即如下所示：
(1) 从主串S的第一位开始，S与T的前三位都匹配成功，第四位匹配失败，此时将主串的指针退回到第二位，子串的指针退回子串开始，即从S[1]开始重新匹配。
(2) 主串S从第二位开始于子串T匹配，第一步就匹配失败，将主串指针指向第三位S[2]，子串指针指向开头，继续匹配。
(3) 同步骤二，第一步就匹配失败，将主串指针移动到第四位S[3]，子串指针指向开头，继续匹配。
(4) 还是第一步就匹配失败，将主串指针移动到第五位S[4]，子串指针指向开头，继续匹配。
(5) 到步骤5终于第一步能够匹配上，从S[4]开始指针依次向后移动，六个字母全部匹配上，匹配成功！
根据上面的步骤，我们可以得出朴素模式匹配算法的代码如下所示：
int find_sub_string(string s, string t) { int i = 0, j = 0;	//初始化两个指针 while(i&lt;s.size() &amp;&amp; j&lt;t.size()){ if(s[i] == t[j]){ i++;	//如果两个指针指向的字符相等 j++;	//则将两个指针向后移动 } else{ i = i - j + 1;	//匹配失败，i退回到上次匹配首位的下一位 j = 0;	//j退回到子串首位 } } if(j&gt;=t.size()){	//j走到子串末尾说明匹配成功 return i - j;	//匹配成功返回主串中子串出现的第一位 } else return -1;	//匹配失败，返回-1 } 既然是朴素(暴力)解法，那必然存在时间复杂度的问题，我们不妨分析以下上述算法的时间复杂度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9091a2d8fe5311adf2028c3991d31ac5/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/45/">«</a>
	<span class="pagination__item pagination__item--current">46/71</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/47/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>