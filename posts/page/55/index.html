<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd683cc762101934718eb9bcdbdfa886/" rel="bookmark">
			VsCode 配置Copilot的详细步骤与示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、 GitHub Copilot Chat 账号申请
1.1 前往 GitHub 网站（https://github.com/）并点击 "Sign up" 进行注册。
1.2 申请 GitHub Copilot Chat
二、VsCode 配置 Copilot
2.1 安装 VsCode 编辑器
2.2 安装 Copilot 插件
2.3 配置GitHub Copilot: Api Key
2.4 使用 Copilot 辅助编程
一、 GitHub Copilot Chat 账号申请 1.1 前往 GitHub 网站（https://github.com/）并点击 "Sign up" 进行注册。 1.2 申请 GitHub Copilot Chat 注册 GitHub 账号后，登录访问 GitHub Copilot Chat 官方网站 https://copilot.github.com/chat/
，然后点击 "Request Access"，申请 GitHub Copilot Chat 的访问权限
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd683cc762101934718eb9bcdbdfa886/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b90f39f14d2b4f83edb98591954d270/" rel="bookmark">
			IDEA中在Java项目中添加Web模块 与配置tomcat服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现有项目添加直接走第二步
生成普通新项目 给项目添加框架支持 勾选 Web Application 选项, 点击OK 得到项目目录结构 , 出现web目录结构, 且web目录文件夹出现小蓝点
web或webapp 没有出现小蓝点 说明web配置没有出现或是手动构建的目录结构 , 在IDE关闭或者迁移项目时会出现
这时web模块是无法运行的
解决 打开 Project Stucture
选中web模块, 配置Deployment Descriptor 为 web.xml 文件的路径
配置 Web Resource Directories 为 web或webapp目录, 即小蓝点所在目录
这样 小蓝点就恢复了
配置tomcat服务器 springboot中是自动将项目塞进了tomcat服务器直接运行, 但Javaweb中还是需要一些配置
首先确保本机安装了tomcat服务器
https://tomcat.apache.org/download-80.cgi
解压到自定义目录即可
Add Configuration 中 “+” tomcat local
初次使用需要添加tomcat所在目录
具体配置 Deployement 就是你要部署的war包, 开发选择 exploded的war包, 这个包是随着代码改变重新编译生成的war包
Application context 为应用上下文 , 简单说就是项目资源访问路径上会加上这个context
要访问项目下的1.html 就需要 localhost:8080/xxxxxxx/1.html , 所以一般这类配置为 / 就可以
但默认这里是配置成war包名, 需要做出修改
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b90f39f14d2b4f83edb98591954d270/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db1bcae770ff674aaba0739062668825/" rel="bookmark">
			免费分享一套微信小程序扫码点餐(订餐)系统(uni-app&#43;SpringBoot后端&#43;Vue管理端技术实现) ，帅呆了~~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是java1234_小锋老师，看到一个不错的微信小程序扫码点餐(订餐)系统(uni-app+SpringBoot后端+Vue管理端技术实现) ，分享下哈。
项目视频演示 【免费】微信小程序扫码点餐(订餐)系统(uni-app+SpringBoot后端+Vue管理端技术实现) Java毕业设计，非常好的源码_哔哩哔哩_bilibili【免费】微信小程序扫码点餐(订餐)系统(uni-app+SpringBoot后端+Vue管理端技术实现) Java毕业设计，非常好的源码项目来自互联网，免费开源分享，严禁商业。更多毕业设源码：http://www.java1234.com/a/bysj/javaweb/, 视频播放量 158、弹幕量 0、点赞数 7、投硬币枚数 0、收藏人数 6、转发人数 1, 视频作者 java1234官方, 作者简介 公众号：java1234 微信：java9266，相关视频：实战springboot+CAS单点登录系统，2024版 PyQt6 Python桌面开发 视频教程(无废话版) 玩命更新中~，【免费】基于springboot的进销存(仓库)管理系统 Java毕业设计，【免费】Springboot+Vue校园二手交易平台系统 毕业设计 Java毕业设计，【免费】Springboot+Vue停车场管理系统 Java毕业设计，【小程序毕业设计·大作业】微信小程序开发_项目实例_食疗坊_安心食疗，【免费】springboot+vue医院管理系统 Java毕业设计，【Java实战项目】基于jsp+servlet的图书借阅管理系统-Java项目/Java毕业设计（附源码 数据库），【Java项目实战】基于Jsp+Servlet做出《学生学籍管理系统》（附源码+论文+课件资料）_毕业设计_Java实战项目_Java课设，微信小程序（java后端无废话版）视频教程https://www.bilibili.com/video/BV17C4y1v7Cz/
项目介绍 随着当前社会人们的生活节奏越来越快，人们对生活效率的追求也越来越高，以往的传统的点餐方式已不能满足人们的需要，首先有些小型饭馆是需要顾客排队点餐，然后安排专人在台前记录，这样不仅造成时间上的浪费，还浪费人力，有些大型餐厅是当顾客入座后，安排服务员前去点餐，但这样有时候顾客爆满，也容易导致服务员忙不过来，效率低下。
对此，微信点餐小程序的应用就很关键，近几年微信小程序兴起，利用微信公众平台，顾客可以快速地浏览菜品，另外，在餐桌上贴好对应的桌号，顾客扫码即可进行点餐，还可以进行备注留言，无需服务员服务，不仅给顾客带来良好的用餐体验，还让餐厅的工作流程变得简单，同时还提高了餐厅的工作效率。
因此根据餐饮市场需求开发一个在安卓系统和苹果系统，都可以使用的手机微信跨平台点餐小程序，主要实现餐厅内点餐功能，同时实现商家的菜品以及店铺管理功能。本文介绍了该系统的研究目的，国内外发展状况，需求分析以及数据库设计和具体功能的设计与实现。经测试基本实现了设计目标，可以进一步进行推广应用。
系统展示 部分代码 package com.java1234.controller.admin; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import com.java1234.constant.SystemConstant; import com.java1234.entity.Admin; import com.java1234.entity.R; import com.java1234.service.IAdminService; import com.java1234.util.JwtUtils; import com.java1234.util.StringUtil; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; import java.util.HashMap; import java.util.Map; /** * 管理员Controller * @author java1234_小锋 * @site www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db1bcae770ff674aaba0739062668825/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0db056f6d860901fc1e2f6f4b0b94b8/" rel="bookmark">
			web网页端使用webSocket实现语音通话功能(SpringBoot&#43;VUE)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 最近在写一个web项目，需要实现web客户端之间的语音通话，期望能够借助webSocket全双工通信的方式来实现，但是网上没有发现可以正确使用的代码。网上能找到的一个代码使用之后只能听到“嘀嘀嘀”的杂音
解决方案：使用Json来传递数据代替原有的二进制输入输出流
技术栈：VUE3、SpingBoot、WebSocket
Java后端代码 pom.xml
配置Maven所需的jar包
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; WebSocketConfig.java
webSocket配置类
package com.shu.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.socket.server.standard.ServerEndpointExporter; @Configuration public class WebSocketConfig { /** * 注入ServerEndpointExporter， * 这个bean会自动注册使用了@ServerEndpoint注解声明的Websocket endpoint */ @Bean public ServerEndpointExporter serverEndpointExporter() { return new ServerEndpointExporter(); } } WebSocketAudioServer.java
webSocket实现类，其中roomId是语音聊天室的id，userId是发送语音的用户id
所以前端请求加入webSocket时候的请求样例应该是：ws://localhost:8080/audio/1/123这个请求中1是roomId，123是userId，这里建议使用ws，一般来说ws对于http，wss对应https
package com.shu.socket; import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Component; import jakarta.websocket.OnClose; import jakarta.websocket.OnError; import jakarta.websocket.OnMessage; import jakarta.websocket.OnOpen; import jakarta.websocket.Session; import jakarta.websocket.server.PathParam; import jakarta.websocket.server.ServerEndpoint; import java.io.BufferedInputStream; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0db056f6d860901fc1e2f6f4b0b94b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/196fce141dd2b312f339647af59a6578/" rel="bookmark">
			JAVA中while循环的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JAVA循环语句 while循环1. 什么是while循环2. while循环的语句3.while循环的适用场景以及优势4. 注意事项 while循环 1. 什么是while循环 while循环是一种在编程中常见的控制流语句，它允许代码在特定条件下（通常是一个布尔表达式）重复执行一段代码。其基本思想是：只要给定的条件为真，就会不断执行循环体内的代码。
通过使用循环语句，可以避免编写大量重复的代码，并提供了更高效和灵活的方式来处理需要重复执行的任务。
循环语句通常由三个主要组成部分组成：
初始化部分：在while循环的开头，可以进行一些变量的初始化操作。这部分通常用于设置循环变量或其他需要在循环开始前准备的条件。循环条件：这是while循环的关键部分，它是一个布尔表达式。只要该条件为真，循环就会持续执行。迭代部分：在每次循环迭代中执行的代码块。这是循环的主体部分，其中包含了需要重复执行的操作。 while循环的执行过程如下：
首先，会检查条件是否为真。如果为真，则执行循环体中的代码。
执行完循环体后，再次检查条件。如果仍然为真，则再次执行循环体。
重复这个过程，直到条件变为假。
当条件为假时，循环结束，程序继续执行接下来的代码。
2. while循环的语句 下面是一个简单的示例，演示了如何使用 while 循环打印数字 1到 10的过程：
public class PracticeInClass { public static void main(String[]args){ int i=1;//设置初始值 while(i&lt;=10){// 循环条件 System.out.println(i); //循环操作 i=i+1;//更新初始值 } } } 在上述代码中，我们先定义了一个整数变量 i并将其初始化为1。
然后，在 while 循环中，设置了条件表达式 i&lt; = 10，表示只要 i 小于等于10 ，就会一直执行循环所写代码。
循环操作打印当前的数字，并通过语句i=i+1使i 递增，以确保在每次循环后更行迭代我们所设置的初始值
当i的值超过10时，条件表达式将为假，则跳出循环。运行上述代码，代码的输出结果为:
需要注意的是，在使用while循环时，要确保循环内部的代码能够改变循环条件，或者在循环内使用break语句来终止循环，否则可能会导致无限循环。
3.while循环的适用场景以及优势 适用场景：
不确定循环次数：当循环次数无法事先确定，或者需要根据某些条件来决定是否继续循环时，while循环非常适用。等待事件发生：可以使用while循环等待某个条件或事件的发生。例如，等待用户输入、等待网络连接成功等。迭代操作：在需要反复执行某个操作，直到达到特定条件时，while循环是一个常用的选择。 总的来说，while循环是 Java 中一种灵活且常用的循环语句，适用于许多不同的场景，尤其是在循环次数不确定或需要根据条件来控制循环的情况下。
while循环的优势：
灵活性：while循环可以在每次循环开始前检查循环条件，因此可以在循环体内部根据条件动态地决定是否继续循环。这提供了更大的灵活性。简洁性：与其他循环语句（如for循环）相比，while循环的语法更加简洁，适用于简单的循环需求。适应性：while循环适用于各种循环场景，无论是固定循环次数还是不确定的循环次数。 4. 注意事项 在 Java 中使用while循环时，有一些注意事项可以帮助你编写更可靠和高效的代码。以下是一些常见的注意事项：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/196fce141dd2b312f339647af59a6578/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18be2a94f04203dfe9fd61890e2c1c30/" rel="bookmark">
			Zookeeper 实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Zookeeper 和Spring Cloud相结合解决分布式锁、服务注册与发现、配置管理 1、Zookeeper 详细介绍 Zookeeper 是一个开源的分布式协调服务，它起源于 Google 的 Chubby 项目，并成为 Hadoop 分布式系统的基础组件。Zookeeper 提供了一组简单的原语集，分布式应用程序可以基于这些原语实现同步服务、配置维护和命名服务等。
Zookeeper 主要角色是协调器（Controller）和客户端（Client）。协调器负责管理分布式应用的逻辑，客户端则用于与协调器进行交互。在分布式应用中，通常需要一个主控节点（Controller）来管理其他物理分布的子进程。Zookeeper 提供了通用的分布式锁服务，以协调分布式应用的执行。
Zookeeper 具有以下特点：
简单：Zookeeper 的设计遵循简单性原则，易于理解和使用。
富有表现力：Zookeeper 提供了一种灵活的客户端 API，允许开发者根据需要实现自定义操作。
高可用性：Zookeeper 支持集群部署，可以自动发现故障节点并重新选举控制器，确保系统正常运行。
松耦合交互方式：Zookeeper 采用事件驱动机制，各组件之间通过消息传递进行通信，便于扩展和集成。
资源库：Zookeeper 存储和管理分布式应用的配置、状态等信息，便于应用程序的开发和维护。
Zookeeper 的客户端主要通过 Java 语言编写，以下是一个简单的 Zookeeper 客户端示例：
import org.apache.zookeeper.*; public class ZookeeperClient { private static ZooKeeper zooKeeper; static { try { // 创建 ZooKeeper 实例 zooKeeper = new ZooKeeper("127.0.0.1:2181", 5000, new Watcher() { @Override public void process(WatchedEvent event) { System.out.println("事件：" + event); } }); } catch (Exception e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18be2a94f04203dfe9fd61890e2c1c30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42cd8db7ae2a221af97aea083eea365c/" rel="bookmark">
			全网最全Midjourney以图生图的详细教程 内有6种案例 小白必收藏！！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手把手教你入门绘图超强的AI绘画程序，用户只需要输入一段图片的文字描述，即可生成精美的绘画。给大家带来了全新保姆级教程资料包（文末可获取）
基础介绍 本篇文章，将介绍如何利用Midjourney完成图生图的方式，简而言之，就是以我们上传的图片为基础，再结合一些关键词，如风格，结构，颜色重新生成图片。本次会以一些案例为中心手把手的教学，争取让大家一学就会！
准备工作 1、科学上网，能登录Midjourney。
2、图片准备（最好清晰显示五官的图片）。
垫图步骤 获取图片链接
方法1：
1、点击输入框左侧的+号图标，然后点击上传文件。
2、在文件夹选择你想要垫的图片，点击打开。
3、可以看见被选中图片出现在框内，这个时候点击一下回车发送
4、图片发送之后，右键图片，选择复制链接，这样就得到了图片链接
方法2：
1、在别处复制你想要垫的图片，点击输入框，按ctrl+v粘贴图片。
2、点击回车发送，右键图片，复制图片链接。
使用图片链接
1、在/imagine命令的prompt框中输入图片链接
垫图可以用一张图片为基础垫图，也可以用多张图片进行垫图，注意每张图片的权重都是一样的，如果你垫了两张图就是每张图50%的权重，如果垫了四张图就是每张图25%的权重。
如果要垫多张图片，记得要在图片链接之间打一个空格。
2、输入描述词
复制完图片链接后，一定要打一个空格再输入描述词
3、输入参数（也可以不输）
输入完描述词后，可以在后面输入参数，注意也要打一个空格隔开，比如你想要的图片尺寸等等，输入完参数之后点击回车键发送，就可以生成图片了。
这里给大家介绍一个参数iw，其他参数将后期单独介绍。
格式：–iw 0.5~2
iw参数的意义是对上传图片图片的参考程度，iw值越高，就越像原图，对原图的参考越大，反之亦然。
原图：
生成图片：
垫图案例 案例1：
以这张女生图片垫图，用niji5模型生成新的图片。
prompt:
https://s.mj.run/h84Xh2GHYdM a beautiful girl --q 2 --niji 5 --s 750
生成图片：
整体构图和原图还是比较相似的，因为niji模型是漫画风格，所以人物都变成了漫画风。在原有基础上增加了一些改动。
案例2
用一张女生的图片，加一张风景图片垫图生成新的图片。
prompt：
https://s.mj.run/h84Xh2GHYdM https://s.mj.run/p6lXZHN6fK4 --q 2 --niji
5 --s 750
生成图片：
最终的成品图保留了第一张图的构图，采用了第二张图是色彩，整体效果还可以，当然还有优化空间。
案例3
用一张小狗的图片，和一张草原风景图垫图生成新的图片
原图：
prompt：
https://s.mj.run/CJqurC2M9QE https://s.mj.run/aE31qvuVg6c A lovely dog
is on the grassland --iw 2 --q 2 --v 5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42cd8db7ae2a221af97aea083eea365c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9a83a02b9a1f6d6f63b50f3434cdef6/" rel="bookmark">
			java.lang.IllegalStateException: Unable to find a @SpringBootConfiguration, you need to use @Context
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述 在运行单元测试报错：
java.lang.IllegalStateException: Unable to find a @SpringBootConfiguration, you need to use @ContextConfiguration or @SpringBootTest(classes=...) with your test
原因分析： 1. 没有启动类
2. 没有加载到启动类 -无法找到@SpringBootConfiguration
3. 测试类包名，调整到和启动类一致即可。
解决方案： 1. 在@SpringBootTest添加启动类，配置启动类 2. 添加@ContextConfiguration注解，配置启动类 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70e634301ebca3d80b4f1814b6929826/" rel="bookmark">
			Mac上安装 Node.js 的版本管理工具 n，以及 n 使用，的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 最近刚更换 Mac 本进行项目的开发，刚上手 Mac 本还不是很熟练，需要安装 Node.js 的包管理工具
在 Windows 上我是实用的 nvm 来管理的 Node 版本，但是我尝试下载 Nvm ，发现下载安装后的 Nvm 无法使用，提示 “This is not the package you are looking for: please go to http://nvm.sh”。同事告诉我在Mac 需要实用 n 这个工具
于是就去网上查了一下，发现千遍一律的都是让你使用 Homebrew 来安装，但是我的 Mac 本安装了 Homebrew 后依旧无法下载这个管理工具，大致错误提示是 “Failed to connect to raw.githubusercontent.com port 443: Connection refused” 后来经过一番操作，发现其实安装 n 完全不需要使用 Homebrew 呀。完全可以使用 npm 去安装，合并要弄的这么麻烦
一、首先先去 node 官网随便下载一个 node 安装在自己电脑上，这一步的目的是让你的电脑上有 npm 可用
二、然后再 通过 npm 去安装 n 这个工具，命令如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70e634301ebca3d80b4f1814b6929826/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cc29e1e2b967f5078755d3d5b350a23/" rel="bookmark">
			【Python脚本】Python自动大麦网抢票，准点原价秒杀演唱会门票，拒绝黄牛交易！从我做起！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了帮助大家在激烈的抢票竞争中获得更大的成功机会，本文将介绍抢票软件的实现原理以及我所了解的一些抢票方式。
但是，请不要过度将希望寄托于抢票软件，它有时也不灵，经过我的验证，即使你用到了抢票软件，也不一定能抢到票。
票务平台会经常调整反爬策略打击爬虫行为，如果希望抢票软件保持较高的成功率，是需要开发者针对票务平台的打击策略作出逻辑调整，这个成本是很高的，所以你能随手获得的抢票软件很大概率是抢不到票的或者说是不安全的。
在调研过程发现一个有意思的点 “黄牛的票从来不是抢来的”。相关规定，面向市场公开销售的营业性演出门票数量，不得低于核准观众数量的70%。 而剩下的那 30%，即非公开销售的票，则是黄牛票的主要来源，也叫渠道票。这里面涉及主办方对热门票和冷门票的售票策略，黄牛在这链条中扮演着重要的角色，只要演唱会门票的二级市场不会消失，黄牛就永远不会消失，对于市场本身来说，愿意花更多钱买黄牛票的人，一定是更有需求的人，黄牛不过是市场调节的人格化。
一、分析购票过程 现在无论是买火车票、飞机票、演唱会票基本都是使用电子支付网上购票，之后得到一张电子票凭证，进场前打印纸质票或者闸机核销票据二维码进场，那么我们从用户角度看下，一次完整的购票过程是什么样。
用户的购票流程：
首先用户登录 票务 APP 搜索爱豆的门票，点击查看门票详情，然后选择场次和票档。等待抢票倒计时，才能进入到下一个页面；.倒计时结束后，开抢按钮被点亮，用户进入下一步选择观演人，确认信息后选择付款方式提交订单；如果手速足够快、运气足够好，抢到了票就会唤起所选的支付方式 APP 提示付款；如果没有抢到则会提示拥堵，跳转到票档选择页面。下面，我将这个图补充一下，思考下哪些步骤是用户可以提高出票成功率的关键时间节点： 很显然，用户在倒计时之前看不到的页面就是竞争手速的关键时机，当这个开抢按钮被倒计时点亮的一瞬间，要以最快的速度点击到达隐藏页面，然后选中观演人，通常使用默认的支付方式，最后提交订单。一旦订单被提交成功，就说明锁定了席位抢到了票。如果用户在规定的时间内未付款，该席位会重新流入票池，捡漏的人就可以抢到。到这里，我们知道了购票流程和提高抢票成功率的突破口，人的手速肯定没有机器快，接下来介绍下两种常用的技术抢票方案。
二、Selenium 模拟浏览器操作 在使用 Chrome 浏览器，用户可以使用鼠标滑动、按键点击以及键盘输入，作为信号输入设备向浏览器传达指令，浏览器收到指令后执行渲染。这里提到的 Selenium WebDriver 是对浏览器提供的原生 API 进行封装，使用这套 API 可以操控浏览器的开启、关闭，打开网页，操作界面元素，控制 Cookie。简单说就是，可以通过写代码的方式来自动实现用户鼠标和键盘信号的输入。这么一来，可以做的事就非常多了。
下面是一个简单脚本，它首先打开 chrome 浏览器输入 google 的网址，等待 5 秒，浏览器网页打开后，找到输入框输入 ”ChromeDriver“，然后模拟点击搜索按钮，就能看到浏览器上搜索的结果。
import time from selenium import webdriver from selenium.webdriver.common.by import By browser.get("https://www.google.com") time.sleep(5) # 查找元素 search_box = browser.find_element(By.NAME, 'q') # 模拟按键输入 search_box.send_keys('ChromeDriver') # 搜索框模拟回车 search_box.submit() time.sleep(5) # 关闭所有窗口 browser.quit() 回到抢票的主题上来，我们可以使用这种技术能力，写一个 Python 脚本，在本地机器上执行起来。脚本内容是在指定的时间打开浏览器，打开票务网页，然后自动模拟用户选择观影人然后自动提交订单。（在这里我原本很想做一个演示视频，理解起来更直观，奈何时间精力有限，这里就不详细介绍 Selenium WebDriver 开发环境配置，感兴趣的可以继续深挖）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cc29e1e2b967f5078755d3d5b350a23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0a46bcb42669d27035783d7ea021dee/" rel="bookmark">
			全网最全stable diffusion图生图教程！！！小白必收藏！！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手把手教你入门绘图超强的AI绘画程序Stable Diffusion，用户只需要输入一段图片的文字描述，即可生成精美的绘画。给大家带来了全新Stable Diffusion保姆级教程资料包（文末可获取）
图生图功能初识 1.1 传统意义上的喂参考图
我们都知道，模型在运算时是根据我们提供的提示内容来确定绘图方向，如果没有提示信息，模型只能根据此前的学习经验来自行发挥。在之前的文生图篇，我们介绍了如何通过提示词来控制图像内容，但想要实现准确的出图效果，只靠简短的提示词是很难满足实际需求的。
AI绘画的随机性导致我们使用大段的提示词来精确描述我们想要的画面内容，但毕竟文字能承载的信息量有限，即使我们写了一大段咒语，模型也未必能准确理解，不排除有时候还会出现前后语义冲突的情况。其实这个过程就像甲方给我们明确设计方向，除了重复沟通想要的画面内容外，有没有什么比口述更高效的沟通方式呢？这个时候，有经验的甲方会先去找几张目标风格的竞品图，让我们直接按照参考图的感觉走。
【感觉】这个词听起来似乎虚无缥缈，但在AI绘画领域是有实际道理的，因为图像能承载的信息要比文字多得多。以上面这张图为例，如果用提示词描述，可能写上几百字都难以向模型解释清楚画面的内容，但图生图不同，模型会自动从参考图上提取像素信息，并将其作为特征向量准确映射到最终的绘图结果上，通过这样的方式能最大程度还原参考图中的提示信息，实现更稳定准确的出图效果。
因此，传统意义上的图生图就是将提示词和参考图中的图像信息进行综合考虑并进行绘图的过程。
1.2 真正强大的图像重绘
当然，如果仅仅是喂图功能，Stable Diffusion的图生图板块并不值得我们单独花一篇文章来讲解，它的真正价值在于提供了丰富的操作工具将图像可控性提升到了新的层次。
我们先来回顾下平时使用文生图进行AI绘画的过程：编写提示词进行绘图，然后根据出图结果再不断优化提示词和各类参数进行抽奖，最终得到一张比较满意的图片。而图生图则是直接根据现有图片进行优化调整，因此图生图的操作过程可以简单理解成省去了前期文生图的抽奖过程，直接在现有图像约束的基础上进行的二次重绘。
需要注意的是，配合参考图进行图生图的过程是需要将参考图先逆向推导为潜空间的数据，再和提示词综合考虑绘制成图像。因此相比没有逆向推导过程的文生图，图生图的绘制会占用更多的系统资源，根据这个原理，我们也就能理解使用参考图的尺寸越大，在逆向推导的过程中消耗的资源也会越多。
在Stable Diffusion中，我们可以通过蒙版和局部重绘等功能来控制只对图像特定部分的区域进行重绘，并设置各类参数来控制重绘的效果。此外通过选择不同的绘图模型和调整图像尺寸，我们也能甚至还能实现画风转换、图像无损放大等更多玩法。相较于其他AI绘画工具，Stable Diffusion中的图生图并非单纯的喂参考图，而是可以在现有图片的基础上通过人工干预来实现更加稳定可控的图像重绘。
图生图工具解析 在WebUI的功能导航栏中选择图生图模块，我们可以看到它的页面布局和文生图基本类似，同样有提示词输入框、操作按钮和参数设置项，不同的是这里多了提示词反推、支持上传图片的二级功能模块和对应的参数设置项。
2.1 提示词反推
先来看提示词反推的功能：即根据提供的图片自动反推出匹配的文本关键词，也就是我们俗称的图生文功能。WebUI这里提供了Clip反推和DeepBooru反推2种反推操作，其区别在于：
Clip反推：推导出的文本倾向于自然语言的描述方式，即完整的描述短句，该功能的特点是可以描述出画面中对象间的关系
DeepBooru反推：推导结果更多的是单词或短句，比较类似我们平时书写提示词的方式，该功能更倾向于描述对象特征
不难看出，通过Clip和DeepBooru反推的提示词中包含不少错误标签，需要人工进行二次筛选。其实，WebUI在图生图模块内置提示词反推是为了在上传图片后可直接获取相应的参考关键词，以便后面更好的通过提示词来控制重绘图像内容。但实际上我们平时反推提示词时更常使用的是秋叶整合包中自带的Tagger插件，该插件除了生成的提示词准确度和稳定更高，还提供了关键词分析和排名展示，属于Stable Diffusion的必备插件之一。
在Stable Diffusion中有非常多类似的开源插件可以有效提升绘图效率，但不属于本篇文章重点，这里就不过多介绍了。
2.2 二级工具栏概览
在图生图模块中为我们内置了许多二级工具栏，很多朋友看到这样可能会担心学习起来很复杂。但其实这里每款工具其实都是在上一个工具基础上进行的衍生，比如涂鸦和局部重绘是在原生图生图基础上增加了手绘和蒙版，而涂鸦重绘又是这2款工具的结合。系统来看，所有的二级工具都是围绕图像重绘、手绘涂鸦和蒙版选区这3个基础功能所进行的重组，而WebUI作者是为了方便我们使用将实际操作场景进行了细分。
上图中整理了不同工具的简介和差异对比，下面针对每款工具和相关参数为大家进行详细介绍。
2.3 图生图工具
这部分的操作和文生图基本相同，区别在于支持额外上传参考图并增加了几项图生图专属的参数。下面介绍几项影响图生图效果的重要参数，这也是所有二级模块都需要用到的参数，其中和文生图模块中相同的参数这里就不再赘述了，大家可以回顾下【文生图篇】的相关内容。
2.3.1 重绘幅度
重绘幅度可以说是图生图中最重要的参数，它的功能有点类似Midjourney中的iw参数。前面介绍图生图的原理是在原图基础上绘制一张新的图片，而重绘幅度就是用来控制在原图基础上重绘的发散性程度，数值越高，说明模型重绘过程中更加自由，绘制结果和原参考图的差异性越大，生成的图像也就更倾向于模型自身的绘图风格。
可以看到当重绘幅度过高时，绘制的图像内容和原图基本就很难进行关联了，因此我们通常将重绘幅度的数值控制在0.4～0.8之间，这样既能维持参考图的控图效果，又能保证重绘后不会发生太强烈的变化。但从重绘幅度角度来看图像可操作的范围并不大，该参数的更多场景是配合其他功能项进行灵活调节，在下面的内容中我会配合各类工具进行详细介绍。
2.3.2 重绘尺寸
故名思义，该参数用于设置重绘后的图像尺寸，可以分为直接设置图像宽高和设置图像缩放倍数2种调节方式。
默认情况下重绘尺寸会自动带入当前参考图的宽高数值，而当我们拖动尺寸滑块时，可以直观的在参考图上预览重绘后的图像范围。
2.3.3 缩放模式
很多时候我们的参考图和重绘后的图片尺寸并不一致，而缩放模式就是用来选择采用何种变形方式来处理图像。这里虽然提供了4个按钮，但是可以分为2类场景来使用。一种是图像长宽比发生变化时使用，这里提供了3种我们常见的处理方式：拉伸、裁剪、填充（由于汉译插件不同，在名称上存在一定差异）。另一种是图像长宽比例不变时使用，多数情况下用于图像等比放大。
换句话说，如果重绘后的图像尺寸和原图完全一样，这几种缩放模式使用起来并没有区别。
下面我们来挨个介绍不同缩放模式的效果差异。首先是拉伸模式（仅调整大小），它的效果是将原图直接变形拉伸至新设定的尺寸。在下面的图中可以看到，在重绘幅度参数设置为0时，图像被直接变形拉伸为正方形，而随着提升重绘幅度，变形效果逐渐得到缓解，但同样也会导致和原图差异过大。
第二种裁剪模式（即裁剪后缩放）是根据新设定图像的长宽比，对原参考图的内容进行裁切。重绘后尺寸由矩形变为正方形，上下部分内容被裁切，这里的重绘幅度参数不会对图像的长宽比例产生影响。
第三个填充模式（缩放后填充空白）的效果根据新设定的长宽比例，将原图缺失的部分进行绘制填充。比如当图像从原图的512768重绘为768768时，下图的效果就是向左右填充了新的背景内容，且随着重绘幅度数值越大，填充部分和原图的融合效果越好。
最后一种缩放模式叫调整大小（潜空间放大），有的地方也叫直接缩放，该功能主要用于对图像进行等比放大，实现“小图转大图”的效果。当然如果重绘尺寸比例和原图比例不一致，则默认会采用拉伸的方式进行处理，但由于是反馈到潜空间中进行运算，因此图像出现了模糊变形的效果。
相较于单纯增加分辨率的放大做法，图生图中使用调整大小模式有重绘幅度参数可供调节，少量的重绘幅度可以为原图增加更多细节。
当然添加重绘幅度的弊端是不可避免的会导致图像发生改变，想要实现更好的效果还有更多定制插件可以实现低显存绘制高清大图，此处先按下不表。
对于调整大小功能的潜空间放大算法，我们可以在设置-放大-图生图放大算法中进行切换，选择之后记得保存设置并重启webUI界面。
综合使用场景来看，除非是需要对图像进行画布拓展，否则多数情况下还是建议先将参考图裁剪到目标比例再导入图生图中使用，这样的出图效果会更加可控。
下面我们再来看看图生图模块下的其他二级工具及参数，由于汉化差异，二级工具的名称可能不同，比如涂鸦重绘有的翻译插件下也被称作有色蒙版重绘。
2.4 涂鸦工具
再来看看第二个涂鸦工具，涂鸦工具的参数项和图生图完全相同，唯一区别是上传图像后右上角多了画笔工具，支持我们对图像进行涂抹。涂鸦工具相当于增加了我们传统的手绘过程，在图片上涂抹色块后再进行全图范围的图生图，同时配合提示词可以实现更加多样的重绘效果。
其中画笔支持调整调整笔触大小和切换颜色，自带的吸色工具也可以进行全屏幕范围内的取色。
在这几个操作工具中，返回上一步的按钮目前还存在bug，有时候并不会逐步撤回而是将整个涂鸦笔触全部清空。并且由于不知名原因，上传的图片有时候会出现报错或失效等情况，需要删除当前图片后重新上传才能。
涂鸦工具的操作很简单，使用画笔在图像上涂抹颜色后点击生成，Stable Diffusion会将手绘后的图像进行整体重绘，同时控制重绘幅度和增加描述关键词可以实现非常神奇的融图效果。在下图中可以看到女孩的衣服会根据涂鸦部分重绘成紫色的运动服，当重绘幅度设置为0.5左右时达到比较自然的融合效果。
需要注意的是通过涂鸦工具来重绘图像时，由于重绘幅度的影响，画面中未被涂鸦的部分也会发生变化，因此涂鸦工具是针对画面整体进行重绘。
由于鼠标涂鸦的绘制效果不够准确，而且涂抹的颜色不支持透明度等细节调整，因此涂鸦工具平时使用并不多，一般都是导入PS中进行细致的绘制操作，这里就不做过多赘述了。
2.5 局部重绘工具
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0a46bcb42669d27035783d7ea021dee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84569b41098ac95537526ae2b314bba4/" rel="bookmark">
			使用mysql查询当天、近一周、近一个月及近一年的数据以及各种报表查询sql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.mysql查询当天的数据 1
select * from table where to_days(时间字段) = to_days(now());
2.mysql查询昨天的数据 1
select * from table where to_days(now( ) ) - to_days( 时间字段名) &lt;= 1
3.mysql查询近一个月的数据 1
SELECT * FROM table WHERE date(时间字段) &gt;= DATE_SUB(CURDATE(),INTERVAL 1 MONTH)//查询近一个月
SELECT * FROM table WHERE date(时间字段) &gt;= DATE_SUB(CURDATE(),INTERVAL 1 YEAR) //查询近一年
SELECT * FROM table WHERE date(时间字段) &gt;= DATE_SUB(CURDATE(),INTERVAL 7 DAY) //查询近七天
4.mysql查询本月的数据 1
select * from table where DATE_FORMAT(时间字段, '%Y%m' ) = DATE_FORMAT( CURDATE( ) , '%Y%m' )
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84569b41098ac95537526ae2b314bba4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a276115f4d95407173286b051e93abb/" rel="bookmark">
			如何在 Linux 命令行中运行 Python 脚本？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 是一种高级编程语言，被广泛应用于数据科学、机器学习、Web 开发等领域。在 Linux 操作系统中，Python 是一个默认安装的解释器，用户可以通过命令行界面（CLI）来运行 Python 脚本。
在本文中，我们将详细介绍如何在 Linux 命令行中运行 Python 脚本。我们将讨论以下主题：
Python 解释器在 Linux 中的位置创建 Python 脚本运行 Python 脚本添加参数和选项将输出重定向到文件常见问题和解决方法 Python 解释器在 Linux 中的位置 在 Linux 中，Python 解释器通常安装在 /usr/bin/python 或 /usr/bin/python3 目录下。如果您不确定 Python 解释器的位置，可以在命令行中运行以下命令：
which python 这将显示 Python 解释器的完整路径。如果您安装了多个版本的 Python 解释器，可以使用 python3 命令来指定使用 Python 3.x 版本的解释器。
创建 Python 脚本 创建 Python 脚本非常简单。在 Linux 命令行中，您可以使用任何文本编辑器来创建一个新的 Python 脚本文件。例如，使用 nano 命令来创建一个名为 hello.py 的 Python 脚本：
nano hello.py 这将打开 nano 编辑器，并在其中创建一个新文件 hello.py。您可以在该文件中编写 Python 代码。例如，以下是一个简单的 Python 脚本，它将打印一条消息：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a276115f4d95407173286b051e93abb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/340ec90fc23efd626f3682b25509e60e/" rel="bookmark">
			硬盘检测软件 SMART Utility mac功能特色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SMART Utility for mac是一款苹果电脑上磁盘诊断工具，能够自动检测磁盘的状态和错误情况，分析并提供错误报告,以直观的界面让用户可明确地知道自己的磁盘状况。SMART Utility 支持普通硬盘HDD和固态硬盘SSD，能够显示出详细的磁盘信息，包括驱动模型、容量、开机时间、温度、错误数等。
SMART Utility for mac功能特色
- 显示所有支持的内部驱动器及其分区以及一些外部驱动器（如果安装了可选的SAT SMART驱动程序）
- 在主窗口中显示重要信息，如驱动器型号，容量，通电时间，温度，坏扇区数，和错误计数和类型
- 显示易于阅读整体SMART状态与颜色编码的文本
- 在单独的窗口中显示更详细的信息，包括功能，所有可用的属性和过去五个错误
- 显示信息使用低声通知服务（如果安装）和电子邮件通知（如果已配置）
- 在菜单栏中显示信息
- 支持在后台扫描
- 支持运行硬盘驱动器的内置测试，并显示测试结果- 支持扫描OS X软件RAID驱动器以及许多RAID机箱和卡（包括SeriTek驱动器）中的驱动器
- 支持将所有信息记录到日志文件以进行验证SMART数据
- 支持自定义故障前算法，仅包括提醒新的坏扇区和错误计数
- 支持保存驱动器报告，以备以后查看
- 支持打印驱动器报告
- 支持HDD和SSD
软件安装地址：SMART Utility for mac (硬盘检测软件) 3.2.7中文版
Windows软件下载：Hard Disk Sentinel(硬盘检测工具)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/802371013c0cd8ee33f2a72150e5be52/" rel="bookmark">
			通过NextChat(ChatGPT-Next-Web)低成本给自己或客户部署GPT程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在国内，用着别人的GPT总归不爽，一是担心稳定性，二是还可能被广告打扰。Github上超人气项目NextChat提供了私有化部署GPT的最佳实践方案，帮助你低成本完成GPT的私人所有。
注意：本文仅针对需要部署项目的读者来展开，实际本站&gt;&gt;提供的GPT程序完全可以满足大家平时使用GPT的需要，无需自行搭建。
学习如何使用NextChat程序建议阅读文章：《ChatGPT操作指南（蛋壳部署）》
什么是NextChat（ChatGPT-Next-Web） NextChat（又名ChatGPT-Next-Web，以下简称NextChat）是一个面向用户的GPT类应用程序，用户可以通过这个程序与GPT进行交互。目前市面上已出现很多GPT类应用程序，除了本文重点介绍的NextChat以外，还有OpenAI官方GPT（含Plus）、LobeChat、ChuanhuChatGPT、chatgpt-web-midjourney-proxy、ChatBox、gpt_academic、ChatGPT-Web等，其余项目均可前往Github作者仓库进行进一步研究使用。该项目在Github已经斩获55.6kstar，当之无愧的GPT程序NO.1，并且据悉目前该项目已被收购，商业价值潜力巨大。
NextChat官方介绍：
一键免费部署你的跨平台私人 ChatGPT 应用, 支持 GPT3, GPT4 &amp; Gemini Pro 模型。
NextChat主要功能：
在 1 分钟内使用 Vercel 免费一键部署提供体积极小（~5MB）的跨平台客户端（Linux/Windows/MacOS）, 下载地址完整的 Markdown 支持：LaTex 公式、Mermaid 流程图、代码高亮等等精心设计的 UI，响应式设计，支持深色模式，支持 PWA极快的首屏加载速度（~100kb），支持流式响应隐私安全，所有数据保存在用户浏览器本地预制角色功能（面具），方便地创建、分享和调试你的个性化对话海量的内置 prompt 列表，来自中文提示词&gt;&gt;和英文提示词&gt;&gt;自动压缩上下文聊天记录，在节省 Token 的同时支持超长对话多国语言支持：English, 简体中文, 繁体中文, 日本語, Español, Italiano, Türkçe, Deutsch, Tiếng Việt, Русский, Čeština, 한국어, Indonesia拥有自己的域名？好上加好，绑定后即可在任何地方无障碍快速访问 为什么选择NextChat作为GPT程序 本站主要使用的稳定GPT程序就是NextChat，目前有三个入口在使用该程序，分别为：
ChatGPT-3.5&gt;&gt;ChatGPT-4.0-Turbo&gt;&gt;ChatGPT-3.5联网版&gt;&gt; 为什么选择它，综合NextChat主要功能介绍的那11条内容以及长期使用此程序的一点心得，本人认为选择NextChat理由就8个字：
交互丝滑界面精美 当你用的多了，时间久了，你就知道不卡顿的程序，其丝滑的交互体验对你是多么重要，加上恰到好处的界面UI设计，可以“精致而优雅”的保持和GPT的交流热情，其体验甚至超过官方提供的网页端交互程序。目前看来，尚没有任何其他GPT程序能与之匹敌，这就是为什么使用NextChat的核心理由所在。
部署NextChat程序的两种方式 作者在项目ReadMe中列出了许多部署方式，有兴趣的可以选择适合自己的进行尝试，本文重点介绍最实用的两种方式，可视化本地安装（Windows为例）和可视化远程部署（Vercel部署）。两种方式分别准备条件和特点如下：
本地安装：一台Windows电脑即可，0成本且无需设置；只能当前设备使用，其他人或其他设备使用需重新安装程序。适用于不愿意折腾，仅简单自用的场景。远程部署：一个域名，通过域名访问可多人共享，可自定义配置；部署稍复杂，有一点域名的成本（约80元/年）。适用于多人使用或者分享给客户使用的场景。 以上两种方案都无需自备服务器，Vercel的存在使得部署成本大大节约了。
方式一：本地安装 进入项目程序版本发布界面，下载对应的exe程序并安装。
安装完成后，点开设置并修改以下两个参数：
替换接口地址：将原地址替换为https://api.gptacg.com输入API-Key（7 * 24小时购买地址&gt;&gt;，如需人工咨询也可加微信ACG508，因市面上提供的API-Key很难分辨模型真假，稳定性也比较差，很难找到靠谱渠道。所以我们踩过坑以后自建团队搭建了专线渠道，专门用于打造高质量低价格的API-Key供应，一方面自用，另一方面共享给有需要的人。目前已支持接入10+月用量在1w刀以上的企业）添加自定义模型：gpt-4-all,dalle-3 至此本地安装设置完成，可新建聊天并开始使用。
方法二：Vercel部署 注意：此方法在安装部署环节可能需要借助魔法，同时需准备一个域名。
什么是Vercel?
相信经常使用Github的人一定对Vercel不陌生，这里不做专业解释，你只需要知道Vercel充当了一台云服务器的作用就可以了，它可以让你在Github上的代码运行起来，从而变成一个可以访问的网站。
什么是域名？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/802371013c0cd8ee33f2a72150e5be52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5816172cc4cff2382b827ac143e8952/" rel="bookmark">
			在Ubuntu22.04上部署Stable Diffusion
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在AI绘画软件领域Stable-Diffusion（简称SD）在开源领域绝对是不二之选，他的插件方式可以让此软件具有更多的功能，开发者社群为此提供了大量免费高质量的外接预训练模型（fine-tune）和插件，并持续维护更新。在第三方插件和模型的加持下，SD拥有更加丰富的个性化功能，使用者可以生成更贴近需求的图片，甚至在 AI 视频特效、AI音乐生成等领域。
Stable-Diffusion学习有一定的难度，上手比较困难，但他在对绘画的精细控制方面非常灵活，对于专业AI绘画方面，他对画质的控制更高。接下来我用Ubuntu22.04和Nvidia P40搭建一套Stable-Diffusion服务器。
有关Ubuntu22.04和Nvidia P40的安装，请参照前面几章的介绍。这里就省劣了这些配置我们直接进入SD配置和部署。
一：准备安装环境
1、安装Anaconda，并创建虚拟环境。
conda create -n sd python=3.10 conda activate sd 2、安装pytorch
#先要进入虚拟环境 conda activate sd #安装pytorch pip3 install torch torchvision torchaudio 二：安装Stable Diffusion
1、克隆仓库
git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git cd stable-diffusion-webui 2、安装相关依赖
#安装tb-nightly python -m pip install tb-nightly -i https://mirrors.aliyun.com/pypi/simple #安装相关依赖 pip install -r requirements_versions.txt pip install -r requirements.txt 3、修改web的绑定IP
vim webui.py #找到下面这几行 #app, local_url, share_url = shared.demo.launch( #share=cmd_opts.share, #server_name=initialize_util.gradio_server_name(), #修改为： #将shared.demo.launch()第一行改为 share=True， server_name="192.168.29.198",#注意IP上的双引号，IP灵活根据自己服务器的IP设置 4、下载模型并拷贝
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5816172cc4cff2382b827ac143e8952/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87af2e709b497a8cab7327f36fabf231/" rel="bookmark">
			Java国密加密SM2代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java国密加密SM2代码 文章目录 Java国密加密SM2代码前言一、SM2是什么？二、使用步骤 1、引入Maven库2、密码工具类3、安全工具类4、SM2工具类5、SM2工具实用类后续更新SM3国密 前言
提示：使用国密算法的意义：
随着金融安全上升到国家安全高度，近年来国家有关机关和监管机构站在国家安全和长远战略的高度提出了推动国密算法应用实施、加强行业安全可控的要求。摆脱对国外技术和产品的过度依赖，建设行业网络安全环境，增强我国行业信息系统的“安全可控”能力显得尤为必要和迫切。
————————————————
提示：以下是本篇文章正文内容，下面案例可供参考
一、SM2是什么？ SM2算法是一种更先进安全的算法，在我们国家商用密码体系中被用来替换RSA算法。
二、使用步骤 1、引入Maven库 代码如下（示例）：
&lt;!--国密--&gt; &lt;dependency&gt; &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt; &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt; &lt;version&gt;1.56&lt;/version&gt; &lt;/dependency&gt; 2、密码工具类 代码如下（示例）： /** * @author weis * @version 1.0.0 * @ClassName spring-cloud.com.boot.cloud.sm.Cipher.java * @Description 密码工具类 * @createTime 2018年10月28日 14:29:00 */ public class Cipher { private int ct; private ECPoint p2; private Sm3Digest sm3keybase; private Sm3Digest sm3c3; private byte key[]; private byte keyOff; public Cipher() { this.ct = 1; this.key = new byte[32]; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87af2e709b497a8cab7327f36fabf231/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abdc41a8181b0212dd1fe574dac672de/" rel="bookmark">
			Spring Cloud Gateway整合Sentinel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日升时奋斗，日落时自省 目录
1、实现整合
1.1、添加框架依赖
1.2、设置配置文件
1.3、设置限流和熔断规则
1.3.1、限流配置
Route ID限流配置
API限流配置
1.3.2、熔断配置
2、实现原理
先前Sentinel针对是业务微服务，没有整合Sentinel到Spring Cloud Gateway
Spring Cloud Gateway 默认是有限流功能的，但限流功能比较简单，所以咱们今天要实现的是 Spring Cloud Gateway 整合 Spring Cloud AlibabaSentinel 实现限流和熔断功能，这种方式也是目前生成环境主流的限流和熔断的实现方法。
1、实现整合 Gateway整合Sentinel总共分为以下4步：
（1）添加框架依赖
（2）设置配置文件
（3）配置拦截规则
（4）验证效果
接下来，我们一步一步来实现
1.1、添加框架依赖 需要框架依赖有3个：gateway、sentinel和sentinel-gateway（Sentinel对接Gateway的适配框架，Sentinel1.6新增模块），如下配置所示：
&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-sentinel-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; 1.2、设置配置文件 在application中设置sentinel控制台的地址，以及限流之后的响应信息：
spring: cloud: gateway: routes: - id: userservice uri: http://localhost:9090 predicates: - Path=/user/** sentinel: transport: dashboard: localhost:18086 scg: fallback: mode: response response-status: 200 response-body: '{"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abdc41a8181b0212dd1fe574dac672de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10eb266304191dc90cf281d54255959a/" rel="bookmark">
			ruoyi前端vue项目启动问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我这里拉取的ruoyi的blog的源码，启动前端项目报错
&gt; ruoyi@3.8.0 dev
&gt; set NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; vue-cli-service serve --open
node: --openssl-legacy-provider is not allowed in NODE_OPTIONS
解决：把package.json文件里的配置按照下面修改一下
"scripts": { "dev": "set NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; vue-cli-service serve --open", "build:prod": "vue-cli-service build", "build:stage": "vue-cli-service build --mode staging", "preview": "node build/index.js --preview", "lint": "eslint --ext .js,.vue src" }, //改成 "scripts": { "dev": "vue-cli-service serve --open", "build:prod": "vue-cli-service build", "build:stage": "vue-cli-service build --mode staging", "preview": "node build/index.js --preview", "lint": "eslint --ext .js,.vue src"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10eb266304191dc90cf281d54255959a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18c55cea7c8437f58138840c1ae72aef/" rel="bookmark">
			Python在金融大数据分析中的AI应用实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💂 个人网站:【 海拥】【神级代码资源网站】【办公神器】🤟 基于Web端打造的：👉轻量化工具创作平台💅 想寻找共同学习交流的小伙伴，请点击【全栈技术交流群】 随着人工智能时代的到来，Python作为一种功能强大的编程语言，在金融领域的大数据分析中扮演着日益重要的角色。本文将探讨Python在金融领域的应用，重点介绍其在大数据分析方面的实际应用案例，涉及股票市场分析、投资组合优化、风险管理等方面，并提供相关的代码示例。
引言 随着金融市场数据规模的不断增长，金融机构和投资者们越来越依赖于大数据分析和人工智能技术来做出更准确、更智能的决策。Python作为一种高效且易于学习的编程语言，以其丰富的库和工具成为金融大数据分析的首选工具。
1. Python在股票市场分析中的应用 在这部分，我们将深入研究如何使用Python来获取、处理和分析股票市场数据。我们将介绍如何使用第三方库（如Pandas、Numpy、Matplotlib等）来下载股票数据，进行可视化分析，甚至是构建简单的股票预测模型。
# 代码示例：获取股票数据并可视化 import pandas as pd import yfinance as yf import matplotlib.pyplot as plt # 下载股票数据 data = yf.download('AAPL', start='2020-01-01', end='2021-01-01') # 绘制股票走势图 plt.figure(figsize=(10, 6)) plt.plot(data['Close'], label='AAPL') plt.title('AAPL Stock Price') plt.xlabel('Date') plt.ylabel('Price') plt.legend() plt.show() 2. 投资组合优化 我们将探讨如何使用Python对投资组合进行优化。通过数学建模和优化技术，我们可以创建一个有效的投资组合，以最大化收益并控制风险。
# 代码示例：投资组合优化 import numpy as np from scipy.optimize import minimize # 假设我们有一些资产的收益率数据 returns = np.random.rand(4) weights = np.random.rand(4) def portfolio_return(weights, returns): return np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18c55cea7c8437f58138840c1ae72aef/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/54/">«</a>
	<span class="pagination__item pagination__item--current">55/71</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/56/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>