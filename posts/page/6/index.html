<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/743871afea9bcbb8d2c55a2ca687f0ec/" rel="bookmark">
			封装了一个iOS中间放大的collectionView layout
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图如下所示
原理：就是首先确定一个放大和缩小系数和原大小对应的基准位置，然后根据距离每个布局属性到视图中心的距离和基准点到中心的距离的差距/基准点到中心的距离， 计算出每个布局属性的缩放系数
下面是代码
// // LBHorizontalCenterLayout.m // LBHorizontalCenterLayout // // Created by mac on 2024/5/24. // #import "LBHorizontalCenterLayout.h" @interface LBHorizontalCenterLayout () @property (nonatomic, assign) NSInteger index; @end @implementation LBHorizontalCenterLayout - (NSArray&lt;__kindof UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect { NSArray *array = [super layoutAttributesForElementsInRect:rect]; array = [self getCopyOfAttributes:array]; //屏幕中线 CGFloat centerX = self.collectionView.contentOffset.x + self.collectionView.bounds.size.width/2.0f; //刷新cell 缩放 for (UICollectionViewLayoutAttributes *attributes in array) { if (self.scrollDirection == UICollectionViewScrollDirectionHorizontal) { //分四种情况，以44 的item为基准，68和35 对应系数分别是1.56 和 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/743871afea9bcbb8d2c55a2ca687f0ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b298967d51212e873e5448cd0d372f7a/" rel="bookmark">
			世界上首位AI程序员诞生，AI将成为人类的对手吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3月13日，世界上第一位AI程序员Devin诞生，不仅能自主学习新技术，自己改Bug，甚至还能训练和微调自己的AI模型，表现已然远超GPT-4等“顶流选手”。
AI的学习速度如此之快，人类的教育能否跟上“机器学习”的速度？AI将成为人类的“对手”还是“搭档”？AI将如何改变产业？对此，复旦大学管理学院信息管理与商业智能系教授王有为提出了自己的看法。
AI时代人才需要新定义
AI技术的发展会改变教育行业，基础教育和人才选拔模式将受到冲击。目前主流的人才选拔形式是进行各种科目的考试。在美国的法学院入学考试中，GPT的考试成绩已经超过了大部分人。
考试的初衷是筛选出优秀的人才，如果AI的能力已经达到甚至超过大部分通过考试的人类的水平，按现有方式筛选出来的人才在职场又有何竞争优势？
王有为说，应该重新去思考优秀人才的定义和选拔标准，事实上，相比记忆力和准确计算的能力，现代社会更缺乏的是知识的综合运用能力，以及提出创意和创新的能力。
例如，在生成式AI技术的加持下，只需要为全国水平最高的教师制作一个虚拟人，就能让所有学生进入“同一课堂”并接受最高水平的基础课教育，甚至可以让虚拟人为每个同学提供个性化的知识辅导（一人千面）。这样一来，省下来的师资就可以投入到需要启发式教育、个性化教学、创新思维的课程中去，而这才是当今高校中稀缺的师资力量。
同时，AI也会对文科和理工科的科研工作带来重大影响。在文科领域，生成式AI对现有的生产关系带来哪些冲击，AI又将如何影响组织结构、管理方式和业务流程，传统的管理学理论在通用人工智能技术环境下是否仍然适用，这些都是值得探索的研究方向。
在理工科领域，生成式AI能够为人类提供解决问题的新思路，虽然这些思路是否可行仍然需要让人类专家去验证和判断。通过人机协作，以前无法解决的科学难题或将迎来突破的机会。
短期来看，AI技术的发展会让某些行业会受到负面影响；长期来看，生成式AI是新质生产力的代表，全人类将整体受益。当技术日新月异，没有人可以“一招鲜吃遍天”。就像马车时代过去以后不再需要马车夫一样，一些职业不可避免会被淘汰。取得本科或者硕士学位不应该是教育的终点，终身教育才是常态。
人类或将为AI“做担保”
王有为说，大部分的B2C企业会受到生成式AI的影响，口碑传播和广告营销的方式都会发生很大变化。B2C行业很大一部分成本来自人和人的沟通，比如产品设计、产品开发、广告营销、售后服务等，每个环节都需要人类员工做大量的工作。
有了生成式AI之后出现了一些新的交互模式。一件商品从生产到流通，每一个环节都可以借助AI来降低沟通成本。例如，顾客购物后会评价商品和服务的质量，营销人员需要在各种渠道（如货架电商、直播和短视频平台、内容平台等）上制作和分发“千人千面”的广告。不管是顾客还是企业员工，都可以使用生成式AI来再造内容的生产和传播过程。
这其中不可避免会受很大影响的是口碑的内容和传播方式。AI可以用于生成真实评价，也可以生成虚假评价来恶意攻击竞争对手。在鱼龙混杂的信息海洋中，将来可能需要对发布的信息内容进行标注，或者建立一种新的信息审核制度。例如，经由人工核实的内容可以标记为“经过人工审核”。有了生成式AI以后，在真假难辨的网络环境中提供信息的真实性认证将对人们做出明智的决策起到积极作用。
王有为提出，在未来，更多的内容是通过人与AI的协作生成。不管生成结果究竟属于“人造”还是“AI造”，最后可能都需要归因到一个人类主体，发布内容都需要一个“担保人”。同时，个人和企业都要对自己发布的信息负责，使用AI生成与事实不符的虚假信息应该受到相应的惩罚。
如何学习大模型 AI ？ 由于新岗位的生产效率，要优于被取代岗位的生产效率，所以实际上整个社会的生产效率是提升的。
但是具体到个人，只能说是：
“最先掌握AI的人，将会比较晚掌握AI的人有竞争优势”。
这句话，放在计算机、互联网、移动互联网的开局时期，都是一样的道理。
我在一线互联网企业工作十余年里，指导过不少同行后辈。帮助很多人得到了学习和成长。
我意识到有很多经验和知识值得分享给大家，也可以通过我们的能力和经验解答大家在人工智能学习中的很多困惑，所以在工作繁忙的情况下还是坚持各种整理和分享。但苦于知识传播途径有限，很多互联网行业朋友无法获得正确的资料得到学习提升，故此将并将重要的AI大模型资料包括AI大模型入门学习思维导图、精品AI大模型学习书籍手册、视频教程、实战学习等录播视频免费分享出来。
第一阶段（10天）：初阶应用 该阶段让大家对大模型 AI有一个最前沿的认识，对大模型 AI 的理解超过 95% 的人，可以在相关讨论时发表高级、不跟风、又接地气的见解，别人只会和 AI 聊天，而你能调教 AI，并能用代码将大模型和业务衔接。
大模型 AI 能干什么？大模型是怎样获得「智能」的？用好 AI 的核心心法大模型应用业务架构大模型应用技术架构代码示例：向 GPT-3.5 灌入新知识提示工程的意义和核心思想Prompt 典型构成指令调优方法论思维链和思维树Prompt 攻击和防范… 第二阶段（30天）：高阶应用 该阶段我们正式进入大模型 AI 进阶实战学习，学会构造私有知识库，扩展 AI 的能力。快速开发一个完整的基于 agent 对话机器人。掌握功能最强的大模型开发框架，抓住最新的技术进展，适合 Python 和 JavaScript 程序员。
为什么要做 RAG搭建一个简单的 ChatPDF检索的基础概念什么是向量表示（Embeddings）向量数据库与向量检索基于向量检索的 RAG搭建 RAG 系统的扩展知识混合检索与 RAG-Fusion 简介向量模型本地部署… 第三阶段（30天）：模型训练 恭喜你，如果学到这里，你基本可以找到一份大模型 AI相关的工作，自己也能训练 GPT 了！通过微调，训练自己的垂直大模型，能独立训练开源多模态大模型，掌握更多技术方案。
到此为止，大概2个月的时间。你已经成为了一名“AI小子”。那么你还想往下探索吗？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b298967d51212e873e5448cd0d372f7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d178dcf7a4d3ac8ac685d9c384243e8c/" rel="bookmark">
			一个普通双非女生的秋招之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是小布丁。
先简单地做个自我介绍：
我今年本科毕业于某双非院校（属于那种没什么人听说过的小学校），学的是计算机专业，英语四级水平（没办法，六级确实没过）。我本科时期走的是后端这条路，主攻语言C++，系统学习过操作系统，计算机网络，MySql，Redis，算法也刷了600+，造化弄人，秋招后走向了客户端这条“不归路”。公司还够得上中厂，薪资也够我在一线苟活。一直想写篇帖子来记录秋招经历，希望能帮到新手小伙伴们～
实习Part
想了想还是把实习经历放着了，因为这段实习经历确实对我的秋招帮助很大。去年五月份我找到了人生第一份实习，是北京的一个小公司，说是后端吧其实也就写写脚本，打包打包软件，干的东西都很杂，不过优点就是不卷，晚上加班都能用来调休，而且还有人手把手带着，有啥解决不了领导就来帮着干（感谢领导）。
秋招Start
七月份开始备战秋招，公司也没啥事，经常带薪学习，有空了就背背八股刷刷题，除了时不时有些焦虑还挺舒服的。就这样时间慢慢来到九月份，都说金九银十，月初我就开始酷酷投简历，什么boss，官网，大公司小公司逮住就投。结果嘛，就有点不忍直视了，具体可以分为以下这几种情况：1.压根不叼你：代表司（腾讯、华为、字节）（是我不够好，公司嘎嘎好，没有谴责任何公司的意思🙏）2. 做完笔试石沉大海：代表司（百度、小米、去哪儿、携程等等）3. 笔试通过面试没过（蓝色光标、若干小公司）可以说我大部分的九十月份就是在这种折磨中度过的，晚上经常失眠push我室友提问知识点。
峰回路转
直到十月末，我现在的公司发起面试，我记得很清楚，一共三面，每面都要手撕算法题，每个算法题我都在leetcode上刷过很多遍了，当时就感觉我又行了！八股也没有难住我（八股这块推荐小林coding 阿秀的校招笔记），最薄弱的项目也没有深问，所以整个面试过程还算顺利，后来也是顺利拿到了offer。
后续一些公司发起面试也没去，没有什么远大的志向，有个不错的公司苟着也挺好。十一月份签三方，才感觉我的秋招彻底落下帷幕，心也安定下来了。
总结Part
秋招给我最大的感触就是：一定要早准备，很多人知道这个事情的时候都来不及了，所以一定要掌握好信息差。还有就是要坚持，努力把握好每一次机会，坚持才有希望，不要想着自己学历不够好准备不充分就放弃，多去投递多去尝试，相信总有岗位是属于自己的！
最后再自我介绍一下，我是小布丁，在一家互联网中厂做程序员，有一个公众号：码农小家园，会分享自己的生活和热爱，还有和互联网相关的趣事，欢迎大家来玩哦～
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c756dba9cda2d2b3caba6fb1e36aa50/" rel="bookmark">
			深入理解Java的垃圾回收机制（GC）实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入理解Java的垃圾回收机制（GC）实现原理 Java的垃圾回收机制（Garbage Collection, GC）是其内存管理的核心功能之一。通过GC，Java自动管理对象的生命周期，回收不再使用的对象所占的内存空间。本文将详细探讨GC的实现原理、不同算法的细节以及其在JVM中的应用。
1. 垃圾回收的基本原理 垃圾回收的主要任务是识别和回收不再使用的对象。GC的基本工作过程包括：
标记阶段：标记所有存活的对象。清除阶段：回收所有未标记的对象。压缩阶段（可选）：整理内存碎片。 2. 垃圾回收算法 2.1 标记-清除（Mark-Sweep）算法 标记-清除算法是最基本的垃圾回收算法，分为两个阶段：
标记阶段：从根集合（GC Roots）开始，递归标记所有可达的对象。清除阶段：遍历整个堆，回收未标记的对象。 标记-清除算法的主要缺点是清除后会产生内存碎片。
// 标记阶段 void mark(Object obj) { if (obj == null || obj.isMarked()) return; obj.mark(); for (Object child : obj.getChildren()) { mark(child); } } // 清除阶段 void sweep() { for (Object obj : heap) { if (!obj.isMarked()) { heap.remove(obj); } else { obj.unmark(); } } } 2.2 复制（Copying）算法 复制算法将内存分为两个区域，每次只使用其中一个区域。当活动区域用完时，将存活的对象复制到另一块区域，然后清空当前区域。
a. 复制阶段：将所有存活的对象从使用的区域复制到空闲区域。b. 交换区域：清空当前区域，并交换使用和空闲区域的角色。 复制算法的主要优点是没有内存碎片，缺点是需要双倍的内存空间。
void copy() { for (Object obj : fromSpace) { if (obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c756dba9cda2d2b3caba6fb1e36aa50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c822a9161d729255a0ff7ca371b18c63/" rel="bookmark">
			Django模板层——模板引擎配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 作为Web 框架，Django 需要一种很便利的方法以动态地生成HTML。最常见的做法是使用模板。
模板包含所需HTML 输出的静态部分，以及一些特殊的语法，描述如何将动态内容插入。
模板引擎配置 模板引擎使用该TEMPLATES设置进行配置。这是一个配置列表，每个引擎一个。
默认值为空。在 settings.py由所产生的startproject命令定义一个更有用的值：
在做下面模板配置的同时，也要在项目的根目录下创建一个templates目录
# 项目目录下的settings.py配置文件添加TEMPLATES中的DIRS配置 TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR,'templates')], 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9f69f51525c7cdb37a9296e52f9b16f/" rel="bookmark">
			基于GA遗传优化的CNN-LSTM的时间序列回归预测matlab仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.算法运行效果图预览
2.算法运行软件版本
3.部分核心程序
4.算法理论概述
4.1 遗传算法（GA）原理
4.2 GA优化CNN-LSTM步骤
5.算法完整程序工程
1.算法运行效果图预览 2.算法运行软件版本 matlab2022a
3.部分核心程序 .................................................................. figure plot(Error2,'linewidth',2); grid on xlabel('迭代次数'); ylabel('遗传算法优化过程'); legend('Average fitness'); [V,I] = min(JJ); X = phen1(I,:); LR = X(1); numHiddenUnits1 = floor(X(2))+1;% 定义隐藏层中LSTM单元的数量 numHiddenUnits2 = floor(X(3))+1;% 定义隐藏层中LSTM单元的数量 %CNN-GRU-ATT layers = func_model2(Dim,numHiddenUnits1,numHiddenUnits2); %训练 [Net,INFO] = trainNetwork(Nsp_train2, NTsp_train, layers, options); IT =[1:length(INFO.TrainingLoss)]; Accuracy=INFO.TrainingRMSE; figure; plot(IT(1:1:end),Accuracy(1:1:end)); xlabel('epoch'); ylabel('RMSE'); %数据预测 Dpre1 = predict(Net, Nsp_train2); Dpre2 = predict(Net, Nsp_test2); %归一化还原 T_sim1=Dpre1*Vmax2; T_sim2=Dpre2*Vmax2; %网络结构 analyzeNetwork(Net) figure subplot(211); plot(1: Num1, Tat_train,'-bs',.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9f69f51525c7cdb37a9296e52f9b16f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f731b3d6052520488ff54c239aa4070e/" rel="bookmark">
			esp32-idf 开发踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象 直接使用原始命令编译idf.py build 但是提示idf 版本错误
卸载旧版本
编译出错build 问题 然后删除编译文件后，重新编译，还是出错
解决方法1 最后发现是因为项目所在文件夹有中文目录，把项目迁移到英文目录后，重新编译，结果如下
解决方法2 清空历史编译生成文件，然后重新编译
头文件报红 解决方案：参考 第九个目录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a50f5777eff1619d65136c95276a7fe/" rel="bookmark">
			如果有多个文件夹，怎么快速获得文件夹的名字呢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 上一篇写到怎么批量建立文件夹，那么怎么获取批量文件夹的名字呢？ 一、啊这，这真是一个好问题二、这个得用Python（文本末尾有打包程序，点击链接运行就可以了）（1）首先建立一个py文件（2）在VScode中打开编辑这些代码：（3）开始运行，这不就出来了？直接粘贴复制到Xmind，一下子就出来了。 三、还好我贴心，给大家打包好了程序，在微信公众号里回复“获取文件夹名字”就可以。四、原我们，都有可以自由支配的时间。 一、啊这，这真是一个好问题 客户把产品图片重新整理了一下发给我，然后让我把这个架构梳理出来，这……，这要是一个个复制粘贴名字得到啥时候了。
二、这个得用Python（文本末尾有打包程序，点击链接运行就可以了） （1）首先建立一个py文件 （2）在VScode中打开编辑这些代码： import os def list_folders(directory): folders = [folder for folder in os.listdir(directory) if os.path.isdir(os.path.join(directory, folder))] return folders def write_to_file(items, filename): with open(filename, 'w') as f: for item in items: f.write("%s\n" % item) if __name__ == "__main__": current_directory = os.getcwd() folders = list_folders(current_directory) write_to_file(folders, "folders.txt") （3）开始运行，这不就出来了？直接粘贴复制到Xmind，一下子就出来了。 三、还好我贴心，给大家打包好了程序，在微信公众号里回复“获取文件夹名字”就可以。 最后放上公众号二维码
四、原我们，都有可以自由支配的时间。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e598040eece8dd264210501293df6d0/" rel="bookmark">
			五分钟”手撕“图书管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
图书馆管理系统需要结合JavaSE的绝大部分知识，是一个很好的训练项目。
为了让大家更加方便的查阅与学习，我把代码放开头，供大家查询。
还有对代码的分析，我将以类为单位分开讲解。
目录
全部代码 Main类 User类 BookList类 Book类 NormalUser类 全部代码 /*一共有三个包*/ //User包 //User.java package user; import Book.BookList; import Operation.IOparetion; public abstract class User { protected String name; protected IOparetion[] iOparetions; public User(String name) { this.name = name; } public abstract int menu(); public void doIOparetion(int chioce, BookList bookList){ this.iOparetions[chioce].work(bookList); } } //User包 //NormalUser.java package user; import Operation.*; import java.util.Scanner; public class NormalUser extends User{ public NormalUser(String name) { super(name); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e598040eece8dd264210501293df6d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8347b1722b23b960fd43f580d06b795e/" rel="bookmark">
			string类的介绍与使用【C&#43;&#43;】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		string类 前言一、为什么学习string类C语言中的字符串示例 二、标准库中的string类string类string类的常用接口说明string类对象的常见构造string类对象的容量操作string的接口测试及使用string类对象的访问及遍历操作下标和方括号遍历范围for遍历迭代器遍历相同的代码，在不同的编译器有不同的空间 string类对象的修改操作string类非成员函数vs和g++下string结构的说明示例例一例二例三例四例五其他 三、string类的模拟实现经典的string类问题浅拷贝深拷贝传统版写法的String类现代版写法的String类 写时拷贝string类的模拟实现 四、扩展文章sortvs编译器string的扩容总结扩容优化留存空间 g++编译器string的扩容capacity（）reserve()resize（）shrink_to_fitatinserterasenpos解决c++默认遇到空格和换行就结束的问题getline()循环 to_stringstoi 前言 推荐一个网站给想要了解或者学习人工智能知识的读者，这个网站里内容讲解通俗易懂且风趣幽默，对我帮助很大。我想与大家分享这个宝藏网站，请点击下方链接查看。
https://www.captainbed.cn/f1
string 类是编程语言中用于表示和操作字符串的基本数据类型或类。它提供了一系列方法和操作，允许开发者对字符串进行创建、修改、查找、比较、转换等。string 类通常具有不可变性，意味着一旦创建了字符串对象，其内容就不能被修改，但可以创建新的字符串对象来表示修改后的内容。这种特性有助于在多线程环境中保持数据的安全性。string 类还提供了各种构造函数、操作符重载和格式化功能，使字符串操作更加灵活和高效。
在C++中，string类函数的长度范围可以是非法的，但不建议用。
一、为什么学习string类 C语言中的字符串 C语言中，字符串是以'\0'结尾的一些字符的集合，为了操作方便，C标准库中提供了一些str系列的库函数，但是这些库函数与字符串是分离开的，不太符合OOP的思想，而且底层空间需要用户自己管理，稍不留神可能还会越界访问。
示例 把字符串转换成整数
字符串相加
在OJ中，有关字符串的题目基本以string类的形式出现，而且在常规工作中，为了简单、方便、快捷，基本都使用string类，很少有人去使用C库中的字符串操作函数。
二、标准库中的string类 string类 string类的文档介绍
字符串是表示字符序列的类标准的字符串类提供了对此类对象的支持，其接口类似于标准字符容器的接口，但添加了专门用于操作单字节字符字符串的设计特性。string类是使用char(即作为它的字符类型，使用它的默认char_traits和分配器类型(关于模板的更多信息，请参阅basic_string)。string类是basic_string模板类的一个实例，它使用char来实例化basic_string模板类，并用char_traits和allocator作为basic_string的默认参数(根于更多的模板信息请参考basic_string)。注意，这个类独立于所使用的编码来处理字节:如果用来处理多字节或变长字符(如UTF-8)的序列，这个类的所有成员(如长度或大小)以及它的迭代器，将仍然按照字节(而不是实际编码的字符)来操作。 总结
string是表示字符串的字符串类该类的接口与常规容器的接口基本相同，再添加了一些专门用来操作string的常规操作。string在底层实际是：basic_string模板类的别名t typedef basic_string&lt;char, char_traits, allocator&gt; string; 不能操作多字节或者变长字符的序列。 在使用string类时，必须包含#include头文件以及using namespace std;
string类的常用接口说明 string类对象的常见构造 函数名称（constructor）功能说明string()构造空的string类对象，即空字符串string(const char* s)用C-string来构造string类对象string(size_t n, char c)string类对象中包含n个字符cstring(const string&amp;s)拷贝构造函数 void Teststring() { string s1; // 构造空的string类对象s1 string s2("hello bit"); // 用C格式字符串构造string类对象s2 string s3(s2); // 拷贝构造s3 } string类对象的容量操作 函数名称功能说明size返回字符串有效字符长度length返回字符串有效字符长度capacity返回空间总大小empty检测字符串释放为空串，是返回true，否则返回falseclear清空有效字符reserve为字符串预留空间**resize将有效字符的个数该成n个，多出的空间用字符c填充 在C++中，string类有两个成员函数size()和length()，它们都用于返回字符串的长度，但它们之间没有区别，可以互换使用。这是因为C++标准库中的string类是基于字符数组实现的，它们都返回的是存储在string对象中的字符个数。因此，在C++中，size()和length()函数可以互相替代使用，没有区别。
string的接口测试及使用 #define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt; using namespace std; #include &lt;string&gt; // 测试string容量相关的接口 // size/clear/resize void Teststring1() { // 注意：string类对象支持直接用cin和cout进行输入和输出 string s("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8347b1722b23b960fd43f580d06b795e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d62a4d11c82436ccb94d6f8417f3fcd3/" rel="bookmark">
			Java方法的重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java方法的重载 前言一、为什么要有重载代码示例问题 代码示例 二、重载的使用代码示例 三、重载的规则针对同一个类代码示例 前言 推荐一个网站给想要了解或者学习人工智能知识的读者，这个网站里内容讲解通俗易懂且风趣幽默，对我帮助很大。我想与大家分享这个宝藏网站，请点击下方链接查看。
https://www.captainbed.cn/f1
Java方法的重载是指同一个类中可以有多个同名方法，但这些方法的参数列表（参数类型、参数个数或参数顺序）必须不同，以便在调用时能够根据参数列表区分具体调用哪个方法。
有些时候我们需要用一个函数同时兼容多种参数的情况, 我们就可以使用到方法重载.
一、为什么要有重载 Java中的重载（overloading）指的是可以在同一个类中定义多个方法，这些方法具有相同的名称但参数类型、参数个数或参数顺序不同。重载的目的是为了提高代码的可读性、可维护性和灵活性。
以下是Java中使用重载的几个主要原因：
方便使用：重载可以让程序员使用同一个方法名来执行不同的操作，这样可以减少方法名的数量，使代码更简洁清晰。例如，可以定义一个名为print的方法，使其能够接受不同类型的参数并打印出对应的结果。
灵活性：重载允许在不改变方法名称的情况下，根据需要适应不同的参数类型或参数个数。这样可以提供更多的使用选项，并满足不同场景下的需求。
可读性：重载方法可以使代码更易读。通过方法名的相似性和参数的类型或个数来区分方法，可以使代码更加易于理解和调用。
代码复用：使用重载可以在不同的方法中复用相似的代码逻辑。当多个方法执行类似的操作时，可以将这些共享的代码放到一个方法中，并通过重载来处理不同的参数类型。
需要注意的是，重载仅仅根据方法的参数类型、个数、顺序来判断调用哪个方法，与方法的返回类型无关。因此，如果仅通过返回类型的不同来区分方法，是无法实现重载的。
代码示例 class Main { public static void main(String[] args) { int a = 10; int b = 20; int ret = add(a, b); System.out.println("ret = " + ret); double a2 = 10.5; double b2 = 20.5; double ret2 = add(a2, b2); System.out.println("ret2 = " + ret2); } public static int add(int x, int y) { return x + y; } } 问题 由于参数类型不匹配, 所以不能直接使用现有的 add 方法.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d62a4d11c82436ccb94d6f8417f3fcd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97a82de0c0aaccc3860b8e442103f0d9/" rel="bookmark">
			C&#43;&#43;小游戏 合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生化危机 #include&lt;conio.h&gt; #include&lt;string.h&gt; #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;windows.h&gt; #include&lt;time.h&gt; #include&lt;direct.h&gt; int n,round,gold=0; bool f1,f2,f3,dead=false,PC_64Bit; char str[4]; struct node1 { int hp; int maxhp; int exp; int atk; int def; int food; }steve; struct node2 { int hp; int maxhp; int atk; int def; int exp; int lev; int poisonous_atk; int poisonous_round; int Self_detonate_atk; bool nodie; bool poisonous; bool Self_detonate; }zombie; void help() { system("cls"); getchar(); MessageBox(NULL,TEXT("1.下回合如果僵尸攻击你,则你不会收到中毒伤害,只会收到主伤害\n2.你不会对僵尸造成伤害\n按任意键继续"),TEXT("防毒技能"),MB_ICONINFORMATION); system("cls"); return; } struct Quickly { int Quick_speed; int Quick_round; int Quick_zombie; }Quick; void SetColor(unsigned short ForeColor,unsigned short BackGroundColor) { HANDLE hCon=GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hCon,(ForeColor%16)|(BackGroundColor%16*16)); } void ERR_1() { MessageBox(NULL,TEXT("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97a82de0c0aaccc3860b8e442103f0d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/033f9d3563e0abf097975e2c763ffde9/" rel="bookmark">
			【考研数据结构知识点详解及整理——C语言描述】第一章算法和算法评价
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		25计算机考研，数据结构知识点整理（内容借鉴了王道408＋数据结构教材），还会不断完善所整理的内容，后续的内容也会不断更新（可以关注），若有错误和不足欢迎各位朋友指出! 目录
一.算法的基本概念 1.算法定义
2.算法的特性
3.算法设计的要求
二.算法性能评价 1.性能评价
2.算法的时间性能分析
2.1时间复杂度
3.算法的空间性能分析
3.1空间复杂度
一.算法的基本概念 1.算法定义 算法(Algorithm)是对特定问题求解步驶骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。
2.算法的特性 此外，一个算法还具具有下列五个重要特性:
1)有穷性。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。2)确定性。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出，无二义性。3)可行性。算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。4)输入。一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。4)输出。一个算法有零个或多个输出，这些输出是与输入有着某种特定关系的量 最基本的是有限性、确定性和可行性这三个特性。
3.算法设计的要求 通常，设计一个“好”的算法应考虑达到以下目标:
1)正确性。算法应能够正确地解决求解问题。2)可读性。算法应具有良好的可读性，从帮助人们理解，3)健壮性。算法能对输入的非法数据做H反应或处理，而不会产生莫名其妙的输出。4)高效率与低存储量需求。效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间，这两者都与问更的规模有关。 二.算法性能评价 1.性能评价 算法性能度量主要是从时间复杂度和空间复杂度描述。
2.算法的时间性能分析 2.1时间复杂度 （1）一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记为T(n)，它是该算法问题规模n的函数，时间复杂度主要分析 T(n)的数量级。算法中基本运算(最深层循环中的语句)的频度与T(n)同数量级，因此通常将算法中基本运算的执行次数的数量级作为该算法的时间复杂度。于是，算法的时间复杂度记为T(n)= O(f(n))
式中，0的含义是 T(n)的数量级，其严格的数学定义是：若(n)和n)是定义在正整数集合上的两个函数，则存在正常数C和 n0，使得当 n≥n0时，都满足 0≤ T(n)&lt; Cf(n)。
（2）算法的时间复杂度不仅依赖于问题的规模n，也取决于待输入数据的性质(如输入数据元素的初始状态)。例如，在数组A[0...n-1]中，查找给定值k的算法大致如下:
(1)i=n-1; (2)while(i&gt;=0&amp;&amp;(A[i]!=k)) (3) i--; (4)return i; 该算法中语句3(基本运算)的频度不仅与问题规模n有关，而且与下列因素有关:
① 若A中没有与k相等的元素，则语句3的频度f(n)=n。
②若A的最后一个元素等于k，则语句3的频度f(n)是常数 0。
最坏时间复杂度是指在最坏情况下，算法的时间复杂度。平均时间复杂度是指所有可能输入实例在等概率出现的情况下，算法的期望运行时间。最好时间复杂度是指在最好情况下，算法的时间复杂度。 一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长在分析一个程序的时间复杂性时，有以下两条规则:
1)加法规则:T(n)=T1(n)+T2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))
2)乘法规则:T(n)=T1(n)xT2(n)=O(f(n))xO(g(n))=O(f(n)xg(n))
例如，设 a{}、b{}、c{}三个语句块的时间复杂度分别为 O(1)、0(n)、O(n)，则
① a{ b{ } c{ } } //时间复杂度为O(n方),满足加法规则 ② a{ b{ c{ } } } //时间复杂度为O(n的3次方)，满足乘法规则 渐近时间复杂度为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/033f9d3563e0abf097975e2c763ffde9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bca0364443a938d27f0ee689e06200a9/" rel="bookmark">
			民国漫画杂志《时代漫画》第16期.PDF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时代漫画16.PDF: https://url03.ctfile.com/f/1779803-1248612470-6a05f0?p=9586 (访问密码: 9586)
《时代漫画》的杂志在1934年诞生了，截止1937年6月战争来临被迫停刊共发行了39期。
ps:资源来源网络！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1b17ede53b08e6c5706d526f770a02f/" rel="bookmark">
			民国漫画杂志《时代漫画》第13期.PDF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时代漫画13.PDF: https://url03.ctfile.com/f/1779803-1247458360-14efab?p=9586 (访问密码: 9586)
《时代漫画》的杂志在1934年诞生了，截止1937年6月战争来临被迫停刊共发行了39期。
ps:资源来源网络！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/769981bc8d8fd1a9cc19d84b179f70de/" rel="bookmark">
			【数据结构|C语言版】栈和队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言1. 栈1.1 栈的概念和性质1.2 顺序栈1.3 链栈1.4 共享栈 2. 队列2.1 队列的概念和性质2.2 循环队列2.3 链式队列2.4 双端队列 3. 例题精选3.1 有效的括号3.2 用队列实现栈2.4 用栈实现队列3.4 设计循环队列3.5 参考答案 结语 #include&lt;GUIQU.h&gt;
int main {
上期回顾: 【数据结构|C语言版】算法效率和复杂度分析
个人主页：C_GUIQU
归属专栏：【数据结构（C语言版）学习】
return 一键三连;
}
前言 各位小伙伴大家好！上次小编给大家讲解了数据结构中的重要基础：算法效率和复杂度分析，接下来我们讲解一下栈和队列！
【知识框架】
1. 栈 1.1 栈的概念和性质 栈（Stack）是一种基本的数据结构，它遵循后进先出（Last In, First Out, LIFO）的原则。这意味着最后一个被添加到栈中的元素将会是第一个被移除的元素。这个特性使得栈在解决特定类型的问题时非常有用，比如内存管理、函数调用、表达式求值等场景。
【基本概念】
栈顶（Top）与栈底（Bottom）：
栈顶是进行元素插入（称为“压栈”）和删除（称为“弹栈”）操作的位置。栈底则是栈的另一端，通常不进行直接操作。 操作：
push 或 add：向栈顶添加一个元素。pop 或 remove：从栈顶移除一个元素，并可选择返回该元素。peek 或 top：查看但不移除栈顶的元素。is_empty：检查栈是否为空。size：返回栈中元素的数量。 实现方式：
栈可以用数组或链表来实现。数组实现较为简单，但可能需要预先分配较大的空间或动态调整数组大小；链表实现则更灵活，插入和删除操作的时间复杂度都为O(1)。 【性质】
线性结构：栈是一种线性数据结构，尽管元素之间的逻辑关系不是顺序的，但它们在内存中可以是连续存储的。
受限访问：只能访问栈顶的元素，不能直接访问中间或底部的元素，这与队列（遵循先进先出，FIFO原则）或数组等其他线性结构不同。
动态大小：栈的大小会随着元素的压栈和弹栈而动态变化。
应用场景：
函数调用堆栈：每当调用一个函数时，相关信息（如局部变量、返回地址）会被压入一个特殊的栈中，当函数返回时，这些信息会被逐一弹出。表达式求值与解析：如计算数学表达式或处理编程语言的语法结构时，栈可以用来保存运算符和操作数，便于按照正确的顺序进行计算。回溯算法：在解决迷宫、括号匹配等问题时，栈可以用来存储路径或状态，以便在遇到死胡同时回退到上一步。 【实例说明】
假设我们要计算一个简单的后缀表达式（如 3 4 + 5 *），使用栈的操作流程如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/769981bc8d8fd1a9cc19d84b179f70de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4355551de75686b9b2686a3e366018a/" rel="bookmark">
			一款颜值颇高的虚拟列表！差点就被埋没了，终于还是被我挖出来了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是晓衡！
今天，推荐一款颇有颜值的虚拟列表组件，不然真的被埋没就可惜了！
我们先来看下效果：
感觉怎么样？还不错吧！
为什么说这个资源差点被埋没呢？因为个朋友找到晓衡询问，有没优化过的 ScrollView 能支持 grid 的？
很多人都知道，引擎自带的 ScrollView 功能有限，特别是新手，要将它玩转还真的不太容易。可能用跑是跑起来了，但那体验却是各种糟心，很容易被老板、用户骂娘。
这位朋友问对人了，因为上周我才在 Cocos Store 上发现上面这个虚拟列表(XY)，体验了一下效果很是 nice！
我立即在Store上一搜过起来，居然没找出来。
我连续使用了ScrollView、View、Scroll 这三个搜索词都不行。
可我当时一下子记不得它叫什么名字了，只好打开资源列表，一页一页地翻。
我硬是找了五六分钟才找到，还好我记得它的图标，有点带治愈卡通风格，很容易识别。
不过，这里需要提醒大家，一定要善用 Cocos Store 后台商品编辑中的关键字功能，看下面这张图：
其实作者还是有心的，写有这么多关键词，可唯独少了ScrollView。用户也可以根据应用场景，多尝试几个关键词。
下面，我们再来看看这款 ScrollView 虚拟列表到底有些什么不同？
功能特点 首先要赞一下虚拟列表(XY)支持2.x\3.x引擎，以下是主要功能点：
支持分页模式
支持动态节点大小
支持瀑布流布局
支持同列表下多种节点类型
支持分区布局模式
支持列表嵌套
支持旋转木马布局样式
提供 3D 画廊布局思路
业务清晰，高度可扩展性，注释详细，彻底搞懂工作原理
自定义: 布局业务完全分离，支持自定义列表的布局排列方式
自定义: 提供实时修改节点变换的方法，目前支持实时调整自定义节点的 偏移，缩放，旋转，层级，透明度
使用方法 下面是作者提供的使用方法步骤：
创建一个新节点
给节点挂载 YXCollectionView 组件
确定列表内一共需要展示多少条内容
this.collectionView.numberOfItems = () =&gt; this.testData.length通过 YXCollectionView 组件注册列表上需要显示的节点，可多次注册，支持同列表不同类型的节点，确保 identifier 唯一就好
this.collectionView.register(`custom identifier`, () =&gt; instantiate(this.cellPrefab))根据实际数据，返回对应的已经注册过的节点，可通过 indexPath 区分数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4355551de75686b9b2686a3e366018a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/613aa154c2e202c04dd0c1110e1a23a1/" rel="bookmark">
			JetLinks物联网平台初步使用——TCP接入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于上一篇，完整的搭建了前后端整个系统，可以在windows 7完美的运行使用。 目录
1、创建网络组件
2、创建协议管理
3、创建网关
​4、创建产品
​5、创建设备
6、模拟对接
1、创建网络组件 进入平台后（用户名密码都是admin）在“运维管理-网络组件”中，先新增一个组件，这个组件就是配置TCP服务器的基本信息。
公网ip就是本服务器（电脑）的ip，后面模拟串口的时候要用这个ip和端口号连接测试。
2、创建协议管理 配置下协议管理，上传官方给的demo协议。
从官网JetLinks物联网基础平台/jetlinks-official-protocol下载代码，后面对接调试的时候会用到。
在这个代码文件中，在package中已经为我们提供了可用的协议jar包，需要通过这个协议包，报文数据需按平台的格式来发送。
所以在协议管理，上传本地的jar包即可。
3、创建网关 协议配置好后，就开始做一个接入网关，因为网关可以接很多个设备，设备连接就需要对接到属于自己的总部（网关）按照步骤继续下一步
4、创建产品 建立产品，毕竟设备有很多，是要统一归类的，产品下很多设备，所以先把产品给建立起来，ID留空随机生成。
点击“启用”后，再配置下“接入方式”
这个secureKey调试的时候要用到，随意设置即可，我这里设置为123456
顺便把“物模型”给配置下，后面创建设备绑定这个产品的时候就不要一个个去配置了。
5、创建设备 创建设备的时候要注意两点：
第一点：ID可以自己设备，也可以留空，系统会自动生成id，这个id很重要，后面对接调试的时候要用到。
第二点：所属产品要确认好，因为绑定了产品，就要用那个产品的网关及组件。
点击“启用”后，可以看到这个设备的详情信息了。
6、模拟对接 打开下载好的“jetlinks-official-protocol”代码，找到如图所示的运行文件“BinaryMessageTypeTest.java”
把设备id以及secureKey复制到代码 testOnline方法中。
运行testOnline，就能得到模拟设备的登录报文。
打开串口助手，把要填的TCP连接信息都配置好后，复制上面的登录报文。
能正常收到反馈数据，说明模拟连接平台正常。
在平台也看到了设备正常上线了。
接下来是模拟发送数据，利用这个testReport方法。
ID和上面一样，同一个设备id，标识符要对应好，我这里设置的是“x”,前面创建这个设备的产品，创建的标识符也是“x”.
运行“testReport”,生成了数据报文。
复制这段报文，在串口处发送。
平台也正常收到了数据，完美结束！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d50a42539c71ac5216192acce873392/" rel="bookmark">
			数据库-MySQL 实战项目——书店图书进销存管理系统数据库设计与实现（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 该项目非常适合MySQL入门学习的小伙伴，博主提供了源码、数据和一些查询语句，供大家学习和参考，代码和表设计有什么不恰当还请各位大佬多多指点。
所需环境 MySQL可视化工具：navicat； 数据库：MySql 5.7/8.0等版本均可； 需求： 1:每个书店有多家供应商，每家供应商给多个书店供货。
2:每个书店聘用多名员工，每个员工只属于一个书店每个书店存放多本图书，多本图书存放在一家书店。
4: 每本图书可以被任何会员购买，一名会员可以购买任意一本图书。
备注： 书店包含下列属性: 编号，地址，书店名字，老板电话；
员工包含下列属性: 身份证，名字，性别，年龄;
图书包含下列属性: 编号，书名，价格，库存量;
会员包含下列属性: 编号，姓名，电话，积分；
关于某供应商给书店供货要描述供货日期;
关于书店聘用员工要描述聘用日期:
关于会员购买图书需要描述购买数量;
关于书店存放图书需要描述存放位置。
二、E-R图 三、关系模式 供应商:(供应商编号,供应商地址,供应商联系人，供应商联系电话,供应商名字，供应商备注)。
书店：(书店编号，书店地址，书店名字，书店老板电话)
员工：(身份证，员工名字，员工性别，员工年龄，书店编号，聘用时期）
图书：(图书编号，书名，价格，库存量，书店编号，存放位置)
会员:(会员编号，会员姓名，会员电话，积分)。
供应信息:(供应商编号，书店编号，供应时间)
购买信息:(会员编号，图书编号，购买数量)
备注： 下划线为主键，红色字为外键；
四、数据表的设计 表1 供应商 字段
数据类型
长度
备注
供应商编号
varchar
50
主键
供应商地址
varchar
50
供应商联系人
varchar
50
供应商联系电话
varchar
50
供应商名字
varchar
50
Not null
供应商备注
varchar
50
表2 书店 字段
数据类型
长度
备注
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d50a42539c71ac5216192acce873392/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c821b638990ed870bd3b815c5ffe33e/" rel="bookmark">
			音视频--音频实时传输
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 编解码 1.1 音频编解码原理 参考：https://blog.csdn.net/qq_42233059/article/details/134628085
(1) 编码
音频编码的基本原理是利用声学特性和听觉心理学原理对音频信号进行压缩。具体过程包括以下几个步骤：
采样：将连续的模拟音频信号转换为离散的数字信号，即进行采样操作。量化：将采样后的信号进行量化，将连续的信号值映射为离散的取值，以减小数据量。压缩编码：对量化后的信号进行编码，将信号表示为更紧凑的形式。编码方法包括预测编码、变换编码和熵编码等。打包：将编码后的数据组织为数据包，便于传输和存储。 (2) 解码
音频解码的过程则是编码过程的逆过程，包括解包、解码、反量化和重构等步骤。解码后的信号经过数字模拟转换，即可恢复为模拟音频信号，下面是音频解码的主要步骤和原理：
解包（Demultiplexing）：音频解码器首先需要对编码后的音频数据进行解包。编码过程中，音频数据可能被分割成多个包或帧，并与其他相关的信息（如采样率、比特率、声道数等）一起打包在一起。解包阶段的任务是从数据流中提取出音频数据和相关信息。
解码（Decoding）：解码是音频解码的核心步骤。在这一步骤中，音频编码器使用特定的解码算法将压缩的音频数据转换回原始的数字音频信号。解码算法根据编码过程中使用的压缩算法和编码参数，对压缩后的数据进行逆操作，还原出原始的频域或时域表示。
反量化（Dequantization）：在编码过程中，音频信号的频域或时域表示经过了量化操作，即将连续的信号值转换为离散的数值。在解码阶段，需要对量化后的数据进行反量化操作，将离散的数值恢复为连续的近似值。反量化过程使用与编码过程相反的量化表或算法，将离散的数据重新映射到原始的数值范围内。
重构（Synthesis）：重构是将解码和反量化后的数据转换为模拟音频信号的过程。根据音频编码的特性和算法，重构阶段可能涉及滤波、插值和合成等操作。这些操作的目标是将解码后的数据转换为与原始音频尽可能接近的模拟信号。
数字模拟转换（Digital-to-Analog Conversion）：解码和重构后的音频数据仍然是数字形式的，需要进行数字模拟转换（DAC）以将其转换为模拟音频信号。DAC将离散的数字样本转换为连续的模拟信号，以便在扬声器或耳机等音频播放设备上播放。
通过以上步骤，音频解码器能够逆向操作，从压缩的音频数据中还原出高质量的模拟音频信号。解码的过程需要根据所采用的音频编码标准和算法进行相应的解析和计算，以确保解码后的音频质量和准确性。
1.2 实时音频传输常用编解码格式 PCMA、PCMU、Opus等
1.3 OPUS编解码 1.3.1 Opus特性 Opus在实时音频传输中的抗弱网能力比较优秀，但是需要开启RTCP的支持。
Opus编解码器具有以下显著特性，使其在多种应用场景中表现出色，尤其是在实时通信和流媒体领域：
广泛的比特率支持：Opus可以在极低到极高的比特率范围内工作，从6kb/s至510kb/s，这使得它既适合低带宽的语音通话，也适合高质量的音乐传输。动态调整编码参数：Opus采用自适应编码算法，能够根据音频信号的内容和网络条件动态调整编码参数，包括比特率和复杂度，以优化压缩效率和音质。多采样率支持：支持从窄带（8kHz）到全频带（48kHz）的采样率，适应不同质量需求和网络环境。低延迟：Opus设计用于低延迟传输，其默认延迟仅为22.5毫秒，非常适合实时交互式通信，如VoIP、在线游戏和视频会议。带内前向纠错（FEC）：内置前向纠错功能可以在不增加额外带宽需求的情况下提高包丢失网络中的音频质量。静音检测与丢弃（DTX）：在没有声音输入时减少不必要的数据传输，进一步节省带宽。包丢失隐藏（PLC）：即使在网络丢包的情况下也能提供连续的音频体验，通过算法预测丢失的数据来减少中断感。开源免费：Opus是完全开源的，并且不受专利限制，适用于各种应用场景，无需支付许可费用。兼容性和标准化：Opus被标准化为RFC 6716，得到广泛的支持，包括WebRTC标准的一部分，以及多种操作系统和音频软件。融合编码技术：结合了Skype的SILK（擅长语音编码）和Xiph.Org的CELT（擅长音乐编码）的优点，使得Opus在不同类型的音频内容上都能表现良好。 这些特性共同构成了Opus编解码器的强大性能，使其在众多音频编解码方案中脱颖而出，尤其是在对延迟敏感和网络条件多变的环境中。
1.3.2 Opus使用 可以基于libopus开源库实现原始音频数据的Opus编解码操作
2. 音频质量提升 实时音频的传输中为了提升音频质量，一般要对音频做特殊处理：降噪、回声消除、自动增益（3A算法）。通过编解码器自身的的算法特性可以实现上述内容。但是也有专门的库来帮助实现对音频质量的提升。speexdsp库可以对声音数据中的高频声音和低频声音进行抑制，并进行降噪。同时speexdsp也提供了3A算法对音频增益。
2.1 speexdsp实现降噪 参考：https://avmedia.0voice.com/?id=54262
下面是使用speexdsp库抑制声音数据中的高频声音、低频声音并进行降噪的示例代码，假设采样率为44100Hz。
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;speex/speex_preprocess.h&gt; #define FRAME_SIZE 1024 int main() { // 创建Speex预处理器 SpeexPreprocessState *preprocess_state; preprocess_state = speex_preprocess_state_init(FRAME_SIZE, 44100); // 根据实际采样率调整 // 设置预处理参数，包括高频抑制、低频抑制和降噪 int enabled = 1; speex_preprocess_ctl(preprocess_state, SPEEX_PREPROCESS_SET_DENOISE, &amp;enabled); speex_preprocess_ctl(preprocess_state, SPEEX_PREPROCESS_SET_AGC, &amp;enabled); speex_preprocess_ctl(preprocess_state, SPEEX_PREPROCESS_SET_DEREVERB, &amp;enabled); // 打开输入文件和输出文件 FILE *input_file, *output_file; input_file = fopen("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c821b638990ed870bd3b815c5ffe33e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/5/">«</a>
	<span class="pagination__item pagination__item--current">6/71</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/7/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>