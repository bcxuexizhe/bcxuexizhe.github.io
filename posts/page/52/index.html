<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dca0eb6b96f893837d43d4d25040133f/" rel="bookmark">
			PostgreSQL（十一）coalesce() 函数的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、定义 COALESCE 是 PostgreSQL 以及许多其他 SQL 数据库系统中的一种 内置函数，用于返回第一个非空（NOT NULL）的表达式或值。当多个字段或表达式可能为空时，它可以非常有用。
基本语法：
COALESCE(column1, column2, ..., columnN) COALESCE 函数会从左至右检查其参数列表中的每个参数，如果遇到的第一个参数不是 NULL，则返回该参数的值。如果所有参数都是 NULL，则 COALESCE 将返回 NULL。
二、使用示例 例如，在一个员工表（t_employee）中，你有一个中文名（chinese_name）字段和一个英文名字段（english_name），你想获取表中的中文名，但是如果中文名为空，则使用英文名。
我们可以用下面这段 SQL 实现：
SELECT COALESCE(chinese_name, english_name) AS name FROM t_employee; 在这个例子中，对于每一行数据，如果 chinese_name 不是 NULL，那么就返回它的值；如果是 NULL，则返回 english_name 的值。
整理完毕，完结撒花~ 🌻
参考地址：
1.postgresql 中的COALESCE()函数使用小技巧，https://blog.csdn.net/djrm11/article/details/118210363
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0169d88a23848751d3e6b431da573981/" rel="bookmark">
			利用Nginx搭建自己的rtmp服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天的文章大疆机场开发五（直播功能和遇到的问题）中讲到，机场直播支持rtmp直播，如果我没有rtmp地址怎么办？这篇文章讲一下如何部署一个自己的rtmp服务器，nginx资源已上传，已配置好，可直接运用。
一、下载Nginx及响应模块
首先，去官方下载Nginx，还需要下载nginx-rtmp-module模块，将模块复制到Nginx的文件夹下面如图。
二、修改config文件
修改conf文件夹下面的conf文件，可复制里面的nginx.conf重命名，也可直接修改。
#user nobody; # multiple workers works ! worker_processes 2; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 8192; # max value 32768, nginx recycling connections+registry optimization = # this.value * 20 = max concurrent connections currently tested with one worker # C1000K should be possible depending there is enough ram/cpu power # multi_accept on; } rtmp { server { listen 1935;#监听端口,若被占用,可以更改 chunk_size 4000;#上传flv文件块儿的大小 application live { #创建一个叫live的应用 live on;#开启live的应用 allow publish 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0169d88a23848751d3e6b431da573981/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1052d3d0abb4dbc1c9fff77622f7f87/" rel="bookmark">
			微信支付对接：vue前端调起支付时，提示error ‘WeixinJSBridge‘ is not defined，已解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题现象 最近做项目，接到一个移动端微信支付的需求，说实话，之前对接过很多与微信相关的需求，但做支付还是第一次，所以在这个过程中也遇到了很多问题，着实有点烧脑，但最终还是顺利的解决了，这中间也积累了一些经验，后面抽时间一一写来供有缘人参考。
今天主要说的问题是微信支付对接：jsapi下单成功之后，前端vue调起支付，运行时提示error ‘WeixinJSBridge‘ is not defined
前端调起支付代码如下：
运行npm run serve时，提示error 'WeixinJSBridge' is not defined，使得我们无法调试也无法发布，无法验证功能。究竟改如何解决？
运行npm run serve报错如下：
二、问题原因 WeixinJSBridge需在微信内置浏览器中使用，在运行npm run serve时，eslint会校验我们的代码书写规范，所以才出现此错误提示。
三、解决办法 eslint校验代码书写规则方便了我们写代码的规范性，那对于这种情况我们可以通过设置让它跳过该校验，具体如下：
/* eslint-disable */ console.log('这里的代码不会被eslint规则校验'); /* eslint-enable */ 例：
四、eslint更多设置方式 当然eslint还有很多其他的设置规则，感兴趣的可以看看
1.整个文件忽略 // 在文件顶部设置 /* eslint-disable */ 2.某一区块忽略 /* eslint-disable */ console.log('这里的代码不会被eslint规则校验'); /* eslint-enable */ 3.某一区块的部分规则忽略 /* eslint-disable no-alert, no-console */ alert('忽略alert'); console.log('忽略console'); /* eslint-enable no-alert, no-console */ 4.某行忽略 alert('忽略行'); // eslint-disable-line or // eslint-disable-next-line alert('忽略行'); 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1052d3d0abb4dbc1c9fff77622f7f87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/518a7d188683916295abd849453752f9/" rel="bookmark">
			【C&#43;&#43;入门到精通】智能指针 shared_ptr循环引用 | weak_ptr 简介及C&#43;&#43;模拟实现 [ C&#43;&#43;入门 ]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读导航 引言一、std::shared_ptr的循环引用1. 概念2. 示例分析 二、std::weak_ptr1. 简介2. weak_ptr模板类提供的成员方法3. 使用示例（1）weak_ptr指针的创建（2）完整示例（解决上面循环引用问题） 4. C++模拟实现 温馨提示 引言 欢迎阅读本系列文章的第二篇，我们将继续探讨与 shared_ptr 相关的主题。上一篇文章我们介绍了 shared_ptr 的强大功能，但也提到了它可能面临的一个问题 —— 循环引用。当两个或多个对象之间相互持有 shared_ptr 的引用时，就会形成循环引用，导致这些对象无法被正确释放，从而引发内存泄漏。
在本文中，我们将深入讨论循环引用问题，并引入另一个智能指针类——weak_ptr。weak_ptr 是 shared_ptr 的伙伴，它可以帮助我们解决循环引用问题，并且不会增加引用计数，以避免对象无法释放的情况。
通过学习 shared_ptr 和 weak_ptr 的组合使用，我们将能够更好地管理动态分配的对象，避免内存泄漏，并提高代码的健壮性和可维护性。敬请期待本文的剖析和示例，希望能给您带来更深入的了解和实践经验。
一、std::shared_ptr的循环引用 1. 概念 当使用 std::shared_ptr 时，循环引用是一种常见的问题。循环引用指的是两个或多个对象彼此持有 shared_ptr 的引用，形成一个环状依赖关系。这种情况下，即使没有外部引用指向这些对象，它们的引用计数也无法降为零，从而导致内存泄漏。
循环引用可能会导致内存泄漏的发生，因为每个对象都会持有对其他对象的引用，导致它们的引用计数无法归零。当没有外部引用指向这些对象时，它们的析构函数不会被调用，从而导致资源无法正确释放。
2. 示例分析 首先我们来看一段代码，这段代码就明显存在着循环引用。
struct ListNode { int _data; shared_ptr&lt;ListNode&gt; _prev; shared_ptr&lt;ListNode&gt; _next; ~ListNode(){ cout &lt;&lt; "~ListNode()" &lt;&lt; endl; } }; int main() { shared_ptr&lt;ListNode&gt; node1(new ListNode); shared_ptr&lt;ListNode&gt; node2(new ListNode); cout &lt;&lt; node1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/518a7d188683916295abd849453752f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49e69b8574dae735f93d4d560cdd3649/" rel="bookmark">
			RabbitMQ详解与实战(绝对足够惊喜)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是RabbitMQ RabbitMQ 是一个开源的消息队列中间件，它实现了高度可靠、灵活和可扩展的消息传递模型。它基于 AMQP（高级消息队列协议）来进行消息的传输和交互。
以下是 RabbitMQ 的一些重要组成部分和特性的详细介绍：
消息队列：RabbitMQ 使用消息队列来存储和传递消息。消息队列通过先进先出（FIFO）的方式处理消息，允许生产者将消息发送到队列，然后消费者从队列中接收这些消息。
生产者：生产者是发送消息到 RabbitMQ 交换机的应用程序。生产者将消息发布到特定的交换机，并且可以选择将消息发送到特定的队列或交换机。
交换机：交换机是 RabbitMQ 接收生产者消息并路由到相应队列的组件。它根据指定的规则（路由键）将消息发送到一个或多个绑定的队列。
队列：队列是 RabbitMQ 中消息的目的地。生产者通过交换机将消息发送到队列，而消费者从队列中接收消息以进行处理。
消费者：消费者是从 RabbitMQ 队列中获取消息并对其进行处理的应用程序。消费者订阅一个或多个队列，并接收队列中的消息。
路由：RabbitMQ 使用路由机制将消息从交换机路由到队列。这是通过在交换机和队列之间建立绑定关系，并使用路由键来匹配消息。
ACK 机制：RabbitMQ 提供了 ACK（确认）机制，确保消息被正确处理。一旦消费者接收到并处理了消息，它可以发送一个 ACK 给 RabbitMQ，告知消息已被处理。如果消费者在处理消息过程中发生故障或崩溃，RabbitMQ 将重新传递未确认的消息给其他消费者。
可靠性：RabbitMQ 提供了可靠的消息传递机制。使用持久化（durable）队列和消息可以确保即使在发生故障或重启后，消息也不会丢失。
可扩展性：RabbitMQ 支持分布式部署和多节点集群，可以通过添加更多的节点来提高消息处理能力和容错性。
插件系统：RabbitMQ 提供了丰富的插件系统，允许用户根据自己的需求扩展和定制功能，例如通过 SSL 加密传输、使用不同的身份验证方式等。
总结：RabbitMQ 是一个功能强大的消息队列中间件，它提供了高度可靠、灵活和可扩展的消息传递模型。通过使用生产者、交换机、队列和消费者，开发人员可以构建可靠的分布式系统，实现异步通信和解耦应用程序的组件。
RabbitMQ与Kafka的区别 RabbitMQ 和 Kafka 都是流行的消息队列系统，它们在设计和用途上有一些区别。以下是 RabbitMQ 和 Kafka 之间的主要区别：
数据处理模型： RabbitMQ：RabbitMQ 是一个传统的消息队列中间件，采用的是面向消息的数据处理模型。它接收、存储和转发消息，并使用AMQP等协议提供可靠的消息传递机制。Kafka：Kafka 是一个高吞吐量的分布式流数据平台，采用发布-订阅模型。它以持久化并分区的方式存储消息，并支持批量读写，适用于大规模实时数据流处理场景。 数据保留时间： RabbitMQ：RabbitMQ 默认情况下不会保留消息，即使消费者没有接收到消息，也不会在消息队列中保留太长时间。Kafka：Kafka 保留所有的消息，并根据配置的时间保留策略（例如时间段或消息大小）决定消息在存储中的保留时间。 功能特性： RabbitMQ：RabbitMQ 提供高级消息队列协议（AMQP）的完整实现，并且支持多种交换机类型、消息确认、消息持久化、消息优先级等功能。它还有广泛的插件生态系统可供扩展。Kafka：Kafka 提供高吞吐量的消息传递，保证消息的可靠性和持久化存储。它支持流处理功能，具有日志存储和批量消费的特点。 扩展性和可靠性： RabbitMQ：RabbitMQ 以队列为基本单位，并使用内存来管理消息，在高负载情况下可能会出现性能瓶颈。Kafka：Kafka 具有良好的水平伸缩性，可以通过添加更多的节点来提高吞吐量和容错性。它使用磁盘文件存储消息，可以大规模地处理海 RabbitMQ与Kafka的各自适用场景 RabbitMQ适用场景：
可靠性：RabbitMQ强调消息的可靠性传递，支持事务和持久化等机制，适用于需要确保每条消息都能被准确处理的场景。它适合于任务队列、工作流、订单处理等需要精确控制消息交付和顺序的应用。灵活的路由：RabbitMQ提供了灵活的路由机制，通过交换机和绑定规则将消息路由到特定的队列，适合处理复杂的消息路由需求。多语言支持：RabbitMQ提供了多种客户端库，支持多种编程语言，便于不同语言环境下的开发和集成。 Kafka适用场景：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49e69b8574dae735f93d4d560cdd3649/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94601647a8d0869c48b7f263313ad672/" rel="bookmark">
			前端input输入框，@input事件输入中文触发两次——解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述 这个问题可能是因为在使用中文输入法输入时，当你还在输入过程中（还未选择和确定最终的汉字词组）就会触发input事件，也就是说在你输入拼音的过程中就已经触发了input事件，等你选择了正确的汉字之后，又会再次触发input事件。这样就会造成在中文输入过程中，input事件触发两次的现象。
解决办法 方式一：
比较有效的解决办法是使用compositionstart和compositionend这两个事件来限制input事件的触发。
compositionstart事件在你开始一个新的复合输入，即开始输入拼音时就会触发。compositionend事件在你结束复合输入，即你选择了正确的汉字并将其输入到文本框后触发。 你可以在compositionstart事件开始时设定一个标志位，然后在input事件中先判断这个标志位，如果标志位为真（表示正在进行复合输入，即拼音输入过程中），则不处理input事件，等到compositionend事件发生时（表示完成了拼音输入，已经确定了要输入的汉字），再处理input事件。这样就可以避免在输入中文时input事件被连续触发两次的问题。
案例如下：
//首先，我们设置一个全局变量isTypingPinyin用来判断当前是否在进行拼音输入。 let isTypingPinyin = false; //然后，我们可以在input标签的compositionstart和compositionend事件上进行监听，以便知道什么时候开始和结束拼音输入。 document.getElementById('myInput').addEventListener('compositionstart', () =&gt; { //在compositionstart事件触发时，即在拼音输入开始时，我们把isTypingPinyin设置为true； isTypingPinyin = true; }); document.getElementById('myInput').addEventListener('compositionend', () =&gt; { //在compositionend事件触发时，即在拼音输入结束时，我们把isTypingPinyin设置为false。 isTypingPinyin = false; }); //最后，我们可以在input标签的input事件上做一次判断，如果isTypingPinyin为true，即当前正在进行拼音输入，那么就不处理这次input事件；如果isTypingPinyin为false，那么就说明输入已经结束，可以处理这次input事件。 document.getElementById('myInput').addEventListener('input', () =&gt; { if (!isTypingPinyin) { // Handle the input event console.log('文本已更新'); } }); 这样一来，我们就能确保在拼音输入过程中，input事件只在输入完成后被触发一次。
方式二：
方式二是我自己想出的办法，实测也可以解决，原理也比较简单
input(e) { if(e){ var _this = this; setTimeout(() =&gt; { if(_this.flag){ _this.flag=false;//在data中设置全局变量flag console.log(e);	} }, 200) } }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86bf8e2868100745dd88fcd697654d10/" rel="bookmark">
			AI Earth运用Landsat数据反演地表温度（LST）【附代码！】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI Earth平台简介 AI Earth地球科学云平台是阿里巴巴达摩院基于深度学习、计算机视觉、地理空间分析等方向上的技术积累，结合阿里云算力支撑，提供无门槛、界面化的遥感、气象等多源对地观测数据云计算分析服务。AI Earth是继航天宏图的PIE-Studio、商汤科技的SensEarth出现的国产遥感云计算平台。
用户可以通过阿里云账号直接登录，也可以注册审核进入平台。点击直接进入AI Earth
数据检索和功能简介 AI Earth数据集非常丰富，常用的Landsat、Sentinel、MODIS等遥感数据，还有诸多地形、社会经济、生物气候数据。进入平台后，点击数据检索即可进行数据检索。
通过选择数据类型，检索区域（可以通过行政区选择、圈画区域、自己导入研究区，注意导入文件格式必须是压缩包.zip），选择时间区间和云量即可检索所需数据。
AI Earth平台处理分析有两种模式选择开发者模式和工具箱模式。工具箱模式将诸多常用遥感手段集中到单一工具中，通过输入数据和处理手段即可完成，运算可批处理，工作效率非常高。开发者模式通过云计算平台进行工作。
基于AI Earth地表温度反演 直接上代码，内核Python3。
初始化环境 import aie ​ aie.Authenticate() aie.Initialize() 计算资源初始化中，请等待... 计算资源初始化完成. Landsat-8 数据检索 指定区域、时间、云量检索 Landsat-8 ，并对数据进行去云处理。 region = aie.FeatureCollection('China_Province') \ .filter(aie.Filter.eq('province', '新疆维吾尔自治区')) #选取研究区 dataset = aie.ImageCollection('LANDSAT_LC08_C02_T1_L2') \ #选取数据源 .filterBounds(region) \ .filterDate('2020-07-01', '2020-08-31') \ #设定时间范围 .filter(aie.Filter.lte('eo:cloud_cover', 10.0)) #云量限定 ​ print(dataset.size().getInfo()) ​ image = dataset.median() map = aie.Map( center=image.getCenter(), height=800, zoom=7 ) rgb_params = { 'bands': ['SR_B4', 'SR_B3', 'SR_B2'], 'min': 8000, 'max': 13000 } map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86bf8e2868100745dd88fcd697654d10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b96e31f5fb6a60aeb1fb8313e45d565/" rel="bookmark">
			C&#43;&#43;与人工智能：深度学习与C&#43;&#43;实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景介绍 C++与人工智能：深度学习与C++实践
1. 背景介绍 随着计算机技术的不断发展，人工智能(AI)已经成为了现代科技的重要领域之一。深度学习(Deep Learning)是人工智能的一个重要分支，它通过模拟人类大脑中的神经网络来学习和解决复杂问题。C++是一种高性能、高效的编程语言，在计算机视觉、自然语言处理、机器学习等领域具有广泛的应用。本文将从C++与深度学习的关联、核心算法原理、最佳实践、应用场景、工具和资源推荐以及未来发展趋势等多个方面进行深入探讨。
2. 核心概念与联系 C++与深度学习之间的联系主要体现在C++作为深度学习框架和库的开发语言，以及C++在深度学习算法的优化和加速方面的应用。深度学习框架如TensorFlow、PyTorch等都支持C++编程，并且C++版本的框架在性能和速度上有很大优势。此外，C++还可以用于优化和加速深度学习算法，例如通过C++编写的CUDA库来加速深度学习模型的训练和推理。
3. 核心算法原理和具体操作步骤以及数学模型公式详细讲解 深度学习的核心算法原理主要包括前向传播、反向传播、梯度下降等。在C++中，这些算法的具体实现需要掌握C++的数学计算和线程并行编程等技能。
3.1 前向传播 前向传播是深度学习中的一种计算方法，用于计算神经网络的输出。给定输入向量x，通过神经网络的各个层次，可以得到输出向量y。前向传播的公式为：
$$ y = f(Wx + b) $$
其中，$W$ 是权重矩阵，$x$ 是输入向量，$b$ 是偏置向量，$f$ 是激活函数。
3.2 反向传播 反向传播是深度学习中的一种优化算法，用于计算神经网络的梯度。通过反向传播算法，可以得到每个权重和偏置的梯度，从而进行参数更新。反向传播的公式为：
$$ \frac{\partial L}{\partial W} = \frac{\partial L}{\partial y} \cdot \frac{\partial y}{\partial W} $$
$$ \frac{\partial L}{\partial b} = \frac{\partial L}{\partial y} \cdot \frac{\partial y}{\partial b} $$
其中，$L$ 是损失函数，$y$ 是输出向量。
3.3 梯度下降 梯度下降是深度学习中的一种优化算法，用于更新神经网络的参数。通过梯度下降算法，可以使神经网络的损失函数逐渐减小，从而使模型的性能得到提高。梯度下降的公式为：
$$ W = W - \alpha \frac{\partial L}{\partial W} $$
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b96e31f5fb6a60aeb1fb8313e45d565/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90a7ff144c67131f7e68e7138ece2830/" rel="bookmark">
			python实现问卷星自动填写（详细版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 相信大家在写论文、作业的同时，想必大家被问卷填写的人数给难倒，尤其是低三下四求别人填写的时候，如果大家是像我这种平时不社交那一定是苦中苦了。那么有没有一种工具让我们实现自动化呢，答案是有的！在编程语言选择的同时，大家知道最易上手的，那莫过于我们大家都熟知的python语言了。那么接下来就让大家通过python实现大家心目中（ps:废话可直接跳过）
一、安装环境 1.1 、selenium和pyautogui库 1.1.1 这里需要安装selenium库，此库作用是帮我们爬取网站信息和需要处理的页面。
1.1.2 还需要安装pyautogui库，此库作用为模拟我们真人填写。
我们将直接使用清华镜像网站安装
pip install pyautogui -i https://pypi.tuna.tsinghua.edu.cn/simple pip install selenium -i https://pypi.tuna.tsinghua.edu.cn/simple 1.2 、驱动文件 1.2.1 执行本次程序需要在谷歌安装驱动文件（如未安装谷歌浏览器，请先下载谷歌浏览器下载链接），在下载驱动之前我们还需要去查找谷歌对应版本，步骤如下。
首先打开设置
然后点击关于chrome即可看到版本号
下面我们就可以下载谷歌驱动了（下载链接），找到对应的版本号进行下载，如果没找到对应的版本号，那么需要一个比较近的下载即可。假如你的版本号为103.0.5060.44，那么应该下载对应版本103.0.5060.53。（尽量把浏览器更新到近几月的版本，这样更全面。）
下载完成是一个压缩包，将压缩包解压后是一个.exe文件，将文件放进谷歌浏览器文件中，大家可以跟我放相同的文件中，如图所示。
二、代码如下 2.1、导入所需库 这里我们将所有需要的库全部导入
from selenium.webdriver.common.by import By # 没有selenium库的(请在所用的环境下pip install selenium) from selenium import webdriver #selenium库 import random # 用于产生随机数 import time # 用于延时 import pyautogui # 用于模拟人手 2.2、验证信息 这里我们设置模拟人手滚动页面加延时，最后进行验证。
def gundong(driver, distance): #延时+屏幕滚动 js = "var q=document.documentElement.scrollTop=" + str(distance) #下拉像素(800是基于最顶端测算的距离) driver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90a7ff144c67131f7e68e7138ece2830/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/981581a3dcb3596c8b71ef4623dca572/" rel="bookmark">
			python的一些知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 安装pandas 重新学习python 的开始从这个开始，
python 安装 Windows embeddable package (64-bit) Windows installer (64-bit) 有什么区别？
Windows embeddable package (64-bit)：这是一个嵌入式安装包，适用于需要将 Python 集成到其他应用程序或项目中的情况。它不包含图形界面的安装程序，只提供了 Python 解释器和必要的库文件。你可以将它作为一个独立的库来使用，或者将其复制到你的项目中。这个包相对较小，适合用于开发环境或嵌入式设备。
Windows installer (64-bit)：这是一个完整的安装程序，包含了 Python 解释器、标准库和其他一些附加组件。它提供了一个图形化的安装界面，可以让用户选择安装的组件，并自动配置系统路径等设置。这个安装程序更适合用于普通用户或需要在整个系统中使用 Python 的场景。(一般选这儿)
综上所述，如果你只需要将 Python 集成到其他项目中，或者希望手动管理 Python 环境，那么可以选择 Windows embeddable package (64-bit)；如果你需要一个完整的 Python 安装程序，并希望通过图形界面进行安装和配置，那么可以选择 Windows installer (64-bit)。
通过 pip install pandas 一直报错 ，折腾了一两个小时
pip install pandas 有runtime超时提醒，并且一直安装不成功。 中间还有这种报错问题 ，关掉代理即可。
最后使用方法 cmd的cd命令进入该路径 +镜像路径
查找文件的所在路径，使用cmd的cd命令进入该路径,输入命令
pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple+包名进行安装即可。
安装完之后可以使用命令python -m pip list命令查询是否已经成功的安装了你想要的库
下载pycharm 下载地址：pycharm下载地址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/981581a3dcb3596c8b71ef4623dca572/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a3088a5645d9166f777cb4f7a698ddf/" rel="bookmark">
			JSON-handle工具安装及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 介绍下载安装简单操作 介绍 JSON-Handle 是一款非常好用的用于操作json的浏览器插件，对于开发人员和测试人员来说是一款很好用的工具，如果你还没有用过，请赶紧下载安装吧，下面是安装过程和具体使用。
下载安装 点击下载JSON-Handle
360浏览器安装
打开360浏览器 -&gt; 将下载好的JSON-handle_0.6.1.crx拖到浏览器中 -&gt; 然后点击添加,如下图所示
安装好后，在右上角会有一个新图标JH，点击JH图标就可以打开了
打开后的界面
Chrome 浏览器安装
打开Chrome 浏览器 - &gt; 在地址栏输入 chrome://extensions/ -&gt;将下载的 .crx 插件包拖放到打开的页面中
点击添加扩展程序
点击箭头所指的图标，打开扩展程序，即可看到JSON-handle,点击JSON-handle即可打开其界面
简单操作 进入JSON-handle界面后，将要查看的json串粘贴到文本框中后，点击ok
点击上图红框位置，出现操作界面
上图中的1处：
copy:复制选中的结点
deURI:对uri解码;
deBase64:对base64的文本解码;
aLine:将选中的结点去掉换行符.
上图中的2处：
+Expand all:将左边的json全部展开;
Collapse all:将左边的json全部收缩;
Expand node:将文本框中的结点展开;
scroll to node：将划块置到最上面。
上图中的3处：
show value:显示值;
show img：没有搞明白;
show array length：显示数据长度
show ico:显示值的数据类型.
当结点的值为url时，在1处会显示 Link链接，点击会打开对应的网页，如下图所示：
在上图右下角处，有个齿轮状的图标，点击它即可打开设置面板
在打开的面板中可以对JSON-handle作相应的设置，包括字体，样式等，大家自行去探索吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a59e3387d3b48b1d6870a32f9dbdc92a/" rel="bookmark">
			uniapp前端从零开始搭建一套mqtt服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搭建mqtt服务器 参考：【MQTT】| 搭建——在云服务器上搭建MQTT服务器_mqtt服务器搭建-CSDN博客
如果服务器执行命令出现“Error: Failed to synchronize cache for repo ‘AppStream‘”的问题
解决方法：https://www.jianshu.com/p/a95e9d6d22e9
uniapp 使用MQTT连接服务器 npm install mqtt@3.0.0 npm install uuid 使用npm引入3.0.0版本的，最新版会有点小问题，uuid用来生成clientId唯一标识，用同一个标识的话会把其他相同标识的客户端踢下线
uniapp demo，直接拿来就能用 u-popup是uview-ui的弹窗组件uView 2.0 - 全面兼容 nvue 的 uni-app 生态框架 - uni-app UI 框架
mqtt的js文件mqtt (v5.0.5) - A library for the MQTT protocol | BootCDN - Bootstrap 中文网开源项目免费 CDN 加速服务 创建一个mqtt.js文件复制进去就好
真机调试mqtt5会报错，改用mqtt3
&lt;template&gt; &lt;view class="content"&gt; &lt;button type="default" v-if="!client||!client.connected" @click="connect"&gt;连接&lt;/button&gt; &lt;button type="default" v-if="client&amp;&amp;client.connected" @click="end"&gt;断开&lt;/button&gt; &lt;button type="default" v-if="!subscribeStatus" @click="subscribe"&gt;订阅&lt;/button&gt; &lt;button type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a59e3387d3b48b1d6870a32f9dbdc92a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ce4cbd023bb6b171b10a1807a543805/" rel="bookmark">
			【idea插件开发】idea插件访问浏览器web地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 以往在eclipse上面开发插件，有兴致想尝试Idea上玩一下插件开发。想要在idea上面访问web地址
概要 记录在idea上面访问web地址
正文 1、点击File-&gt;New-&gt;Project… 选择IntelliJ Platform Plugin
2、点击下一步后，输入Project Name，然后点击完成
3、新建Factory
package com.demo.view; import com.intellij.openapi.project.Project; import com.intellij.openapi.wm.ToolWindow; import com.intellij.openapi.wm.ToolWindowFactory; import com.intellij.ui.content.Content; import com.intellij.ui.content.ContentManager; import javafx.application.Platform; import javafx.embed.swing.JFXPanel; import javafx.scene.Scene; import javafx.scene.web.WebView; import org.jetbrains.annotations.NotNull; import javax.swing.*; /** * @author twilight * @since V1.0 */ public class MyToolWindowFactory implements ToolWindowFactory { @Override public void createToolWindowContent( @NotNull Project project, @NotNull ToolWindow toolWindow) { ContentManager contentManager = toolWindow.getContentManager(); JFXPanel jfxPanel = new JFXPanel(); jfxPanel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ce4cbd023bb6b171b10a1807a543805/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/898af3d33a7526e7ef048efde274ba5b/" rel="bookmark">
			SQL 注入漏洞原理以及修复方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		漏洞名称 ：SQL注入 、SQL盲注
漏洞描述：所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意）的SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。 造成SQL注入漏洞原因有两个：一个是没有对输入的数据进行过滤（过滤输入），还有一个是没有对发送到数据库的数据进行转义（转义输出）。
检测条件 ：
1、 Web业务运行正常
2、 被测网站具有交互功能模块，涉及到参数提交等等。
3、 例如待测目标URL，假设为http://www.exmaple.com/page.xxx
4、 待测目标存在参数输入，假设为name=value
检测方法：
一、 通过web漏洞扫描工具进行对网站爬虫后得到的所有链接进行检测，或者手工判断是否存在注入点，一旦确认存在漏洞，可利用自动化工具sqlmap去尝试注入。几种常见的判断方法：
1、 数字型。测试方法：
http://host/test.php?id=100 and 1=1 返回成功
http://host/test.php?id=100 and 1=2 返回失败
2、 字符型。测试方法：
http://host/test.php?name=rainman ’ and ‘1’=‘1 返回成功
http://host/test.php?name=rainman ’ and ‘1’=‘2 返回失败
3、 搜索型。搜索型注入：简单的判断搜索型注入漏洞存在不存在的办法是：
3.1）先搜索（'），如果出错，说明 90%存在这个漏洞。
3.2)然后搜索（%），如果正常返回，说明 95%有洞了。
3.3)然后再搜索一个关键字，比如（2006）吧，正常返回所有 2006 相关的信息。
3.4)再搜索（2006%'and 1=1 and '%'='）和（2006%'and 1=2 and '%'='）
4、 绕过验证（常见的为管理登陆）也称万能密码
(1) 用户名输入： ‘ or 1=1 or ‘ 密码：任意
(2)Admin’ - -（或‘ or 1=1 or ‘ - -）(admin or 1=1 --) (MS SQL)(直接输入用户名，不进行密码验证)(3)用户名输入：admin 密码输入：’ or ‘1’=’1 也可以
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/898af3d33a7526e7ef048efde274ba5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8afe54f64251de4d056d6682b671d34f/" rel="bookmark">
			【MySQL】表的内外连接和视图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内外连接 一、表的内外连接1. 内连接2. 外连接（1）左外连接（2）右外连接 3. 练习 二、视图1. 视图的使用2. 视图规则和限制 一、表的内外连接 表的连接分为内连和外连。
1. 内连接 内连接实际上就是利用 where 子句对两种表形成的笛卡尔积进行筛选，我们前面学习的查询都是内连接，也是在开发过程中使用的最多的连接查询。
语法：
select 字段 from 表1 inner join 表2 on 连接条件 and 其他条件; 例如：
显示 JAMES 的名字和部门名称 用前面的写法直接用笛卡尔积：
select ename, dname from emp, dept where emp.deptno=dept.deptno and ename='JAMES'; 用标准的内连接写法：
select ename, dname from emp -&gt; inner join dept -&gt; on emp.deptno = dept.deptno -&gt; and ename = 'JAMES'; 2. 外连接 外连接分为左外连接和右外连接。
（1）左外连接 如果联合查询，左侧的表完全显示，我们就称作是左外连接。
语法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8afe54f64251de4d056d6682b671d34f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2158de4705a27a4f061034aa78be2b2/" rel="bookmark">
			RabbitMQ---延迟消息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMQ---延迟消息 延迟消息：生产者发送消息时指定一个时间，消费者不会立刻收到消息，而是在指定时间后才收到消息。
延迟任务：设置在一定时间之后才执行的任务。
延迟消息有以下三种实现方案：
死信交换机延迟消息插件 一、延迟队列 TTL
TTL 全称 Time To Live（存活时间/过期时间）。 当消息到达存活时间后，还没有被消费，会被自动清除。 RabbitMQ可以对消息设置过期时间，也可以对整个队列（Queue）设置过期时间。 死信交换机
成为死信（dead letter）的条件：
消费者使用basic.reject或 basic.nack声明消费失败，并且消息的requeue参数设置为false（消费者拒接消费消息，并且不重回队列；）消息是一个过期消息(达到了队列或消息本身设置的过期时间)，超时无人消费队列消息堆积已满，最早的消息可能成为死信 如果队列通过dead-letter-exchange属性指定了一个交换机，那么该队列中的死信就会投递到这个交换机中。这个交换机称为死信交换机(Dead Letter Exchange，简称DLX）。
1、声明延迟队列 package com.itheima.consumer.config; import org.springframework.amqp.core.*; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.security.auth.login.CredentialNotFoundException; @Configuration public class DlxExchangeConfiguration { /** * 声明 TTL 队列 * 1. 指定消息的 TTL * 2. 指定死信交换机 * 3. 指定死信交换机的 RoutingKey */ @Bean public Queue ttlQueue() { return QueueBuilder .durable("ttl.queue") // 指定队列的名称 //.ttl(10000) // 指定 TTL 为 10 秒,这里可设置过期时间，但我这里测试在发送消息时设置过期时间 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2158de4705a27a4f061034aa78be2b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f70e76a18b53d44c9ca93422a10c93d4/" rel="bookmark">
			新版Android Studio Logcat 筛选日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载了新版的Android Studio，android-studio-2022.3.1.21-mac_arm，记录一下新版本AS的logcat过滤日志条件
1. 按照包名过滤 1.1 过滤当前包名的日志 package:mine 1.2 过滤其他包名日志 package:com.example.firstemptyapplication 2. 按照日志等级过滤 在控制台输入
level:info 就可以筛选所有info级别的日志
3. 按照Tag过滤 3.1 筛选单个tag 比如想筛选MainActivity的所有日志
tag:MainActivity 那么在控制台可以看到所有MainActivity的日志
3.2 筛选多个tag的日志 可以通过空格 隔开对应的tag，如下所示
tag:MainActivity tag:SecondActivity 4. 按照关键字过滤 比如我要筛选带有onResume的日志，那么就在logcat输入如下字样
message: onResume 5. 组合过滤 比如自己想过滤某个包名 + 某个信息的，如下所示：过滤当前包名，且过滤onResume关键字
package:mine message: onResume 6. 正则表达式过滤 // 只有这些字段支持正则表达式：tag、package、message、line
// 正则表达式匹配通过在字段名称中附加 ~ 来表示。
例如 tag~:MainActivity.*
7. 时间过滤 // age是过滤最近时间段内的日志，s 表示秒，m 表示分钟，h 表示小时，d 表示天。
// 下面的例子是过滤过去 1 分钟内记录的消息。
age:1m
8. 反向过滤 // 过滤不想看的日志
// 否定的表示方式是在字段名称前面加上 -
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f70e76a18b53d44c9ca93422a10c93d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bd7e1ebf376c19aa6d583aebdf7c989/" rel="bookmark">
			SQL详细的日期时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、字符串转换和日期常用的函数
1.getdate函数:获取系统当前日期时间
2.cast函数：cast('20023-12-06' as datetime) 3.convert函数：convert(varchar(100),getdate(),120)
4.dateadd函数：向指定日期加上一段时间，返回新的值，例如：dateadd(day,3,getdate()) --返回系统日期增加三天后的日期
5.datediff函数：计算开始日期和结束日期之间的差值，例如：datediff(day，'2023-12-6',getdate()) --返回2023年12月6号与系统日期相差多少天
6.datepart函数和datename函数：两者在为weekday类型参数时返回结果不同，其余返回结果相同，但返回数据类型不相同
datepart：返回代表指定日期的指定日期部分的整数，例如：datepart(day,getdate()) --返回当前系统日期的天数（int）
datename：返回返回代表指定日期的指定日期部分的字符串，例datename(weekday,getdate()) --返回当前系统日期是星期几（nvarchar）
7.year() ,month(),day()函数：返回指定日期的年月日的整数（int）
二.SQL日期格式转换
SELECT CONVERT(varchar(100), GETDATE(), 0) --&gt; 12 08 2023 16:17PM
SELECT CONVERT(varchar(100), GETDATE(), 1) --&gt; 12/08/23
SELECT CONVERT(varchar(100), GETDATE(), 2) --&gt; 23.12.08
SELECT CONVERT(varchar(100), GETDATE(), 3) --&gt; 08/12/23
SELECT CONVERT(varchar(100), GETDATE(), 4) --&gt; 08.12.23
SELECT CONVERT(varchar(100), GETDATE(), 5) --&gt; 08-12-23
SELECT CONVERT(varchar(100), GETDATE(), 6) --&gt; 08 12 23
SELECT CONVERT(varchar(100), GETDATE(), 7) --&gt; 12 08, 23
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bd7e1ebf376c19aa6d583aebdf7c989/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a054da9c3703225dcc26206173d4a40/" rel="bookmark">
			Mac查看Python安装路径和版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📌 夕月不识向南意，我与东风皆多情。
每次重搭环境或python版本装多了,乱死了,升级版本,配置环境变量,查看路径,好麻烦,今天整理记录下
个人博客: www.xmylog.com
Mac查看Python安装路径和版本 Mac 系统自带 python 路径为: /System/Library/Frameworks/Python.framework/Versions 这里可能会有多个 python 版本，里面 Current 存放系统当前 python 版本， 进入 Current/bin， 在终端输入 ./python --version 即可查看系统当前 python 版本。 注：若使用 python --version 命令是查看用户当前 python 版本而不是系统 python 版本 系统 pip 安装的第三方库的安装路径 ： /System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python 自己另行安装的 python 路径为： /Library/Frameworks/Python.framework/Versions/3.x pip 安装的第三方库的安装路径 ： Library/Frameworks/Python.framework/Versions/3.x/lib/python3.x/site-packages HomeBrew 安装 python 路径： /usr/local/Cellar/python 里面存放HomeBrew所安装版本， 进入2.7.13/bin， 在终端输入./python --version 即可查看用户当前使用的python版本。 如果使用brew工具正确安装python的情况下，用户当前python版本会是新安装的python 系统命令默认路径在: usr/bin 在该目录下执行 ./python --version 会得到系统的 python 版本信息，我的执行结果是：Python 2.7.10 用户命令默认路径在: /usr/local/bin //（ brew 安装的命令默认在这个路径下） 在该目录下执行 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a054da9c3703225dcc26206173d4a40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31b50e1a868009dd3b6c227d38e78113/" rel="bookmark">
			AIGC笔记--特征线性调制（FiLM）层的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1--特征线性调制层的作用
2--特征线性调制层的实现
3--论文实例
1--特征线性调制层的作用 特征线性调制（Feature-wise Linear Modulation，FiLM）层是一种神经网络模块，它可以用来实现特征的条件调整。FiLM层的主要功能是对输入特征进行缩放（scaling）和偏移（shifting），并且这个缩放和偏移是可以学习的。
FiLM层的工作原理如下：给定一个输入特征x，FiLM层首先通过一个全连接层或其他形式的网络结构生成两个参数γ和β，然后对输入特征进行缩放和偏移，即y = γ * x + β。这里，γ和β是与输入特征x同样大小的向量，它们决定了对输入特征的缩放和偏移程度。
FiLM层的主要作用是实现特征的条件调整，使得模型可以根据特定的条件（例如来自其他模态的信息）来调整特征的表示。这种机制在许多任务中都很有用，例如在图像生成任务中，FiLM层可以用来根据文本描述来调整生成的图像特征；在视频理解任务中，FiLM层可以用来根据音频信息来调整视频特征。
总的来说，FiLM层是一种强大的特征调整工具，它可以帮助模型更好地利用条件信息，从而提高模型的性能。
2--特征线性调制层的实现 import torch import torch.nn as nn class FiLM(nn.Module): def __init__(self, input_dim, condition_dim): super(FiLM, self).__init__() # 全连接层，用于生成γ和β参数 self.fc_gamma = nn.Linear(condition_dim, input_dim) self.fc_beta = nn.Linear(condition_dim, input_dim) def forward(self, x, condition): # 根据条件特征获取缩放scale参数和移位参数shift，即计算γ和β参数 gamma = self.fc_gamma(condition) beta = self.fc_beta(condition) # 对输入特征x进行缩放和偏移，实现条件特征调整输入特征 y = gamma * x + beta return y if __name__ == "__main__": input_dim = 64 # 输入特征 condition_dim = 128 # 条件特征 # 创建一个FiLM层实例 film_layer = FiLM(input_dim, condition_dim) # 初始化输入特征x和条件特征condition x = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31b50e1a868009dd3b6c227d38e78113/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/51/">«</a>
	<span class="pagination__item pagination__item--current">52/71</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/53/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>