<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47961b7aa4d6a6aad686141b1934f99d/" rel="bookmark">
			2024年第十五届蓝桥杯研究生组题目总结（Java、Python、C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024年十五届蓝桥杯研究生组 今年的题较去年难度降低了很多，题量也少了2道。
Q1 劲舞团 读文件，找到最长的满足条件的子数组的长度
答案是：9
BufferedReader，fopen，open
Q2 召唤数学精灵 找规律，周期是100，对给的数据，除以100，最后再加2，因为还有2个没算。
答案是：40480826628086
Q3 封闭图形个数 签到题
自定义排序规则 + 模拟
把每个数字的封闭图像个数先用数组存储起来，比如cnt[8] = 2
Java定义一个类型Node，创建数组，sort指定排序规则
C++，创建结构体，传入排序规则函数cmp
Q4 商品处理 差分+前缀和 10分
差分统计所有操作后的最终情况，此外维护一个数组，用来存储最终结果是个数是1的数，再进行请前缀和，最后只需要O（1）查询[l,r]中1的个数
Q5 砍柴 题意：两人按照最优策略轮流操作一个数字x ，每次操作可以选择一个小于等于 的质数 ，并将 x变为x-p ，问最终谁先手必胜。共有T次询问。X是 1e5,T是1e4
博弈论，推出一种必败就是必胜，应该是sg函数
预处理1e5的质数
预处理1e5的sg函数：N * N * (ln n)
最后O（1）查询
暴力枚举的代码 15*0.2 = 3分
这个解法可能不能全部通过，但是大部分数据能过
1~x 中满足小于等于X的质数的个数：x/ln x Q6 回文串 是否能加上一些lqb使得变成一个回文串 就像个模拟贪心 15分
Q7 最大异或点 求最大异或值的2个不相邻点 。
字典树处理所有节点，Trie维护所有值，枚举到每个节点，就把相邻的从字典树删除，进行查询，最后再加上
Q8 植物生命力 求所有子树中 ，满足整除关系的父子节点对的个数。条件是：父节点比子节点大，并且不能被子节点整除。
每个节点的值都是唯一的，值域是1~1e5,这应该是突破口
暴力20*0.3=6分
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa4ce8c55ef926012a84ce9873c70237/" rel="bookmark">
			自定义数据集使用llama_factory微调模型并导入ollama
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文所有操作均在linux系统下完成
llama_factory安装 参考github的安装命令
git clone https://github.com/hiyouga/LLaMA-Factory.git conda create -n llama_factory python=3.10 conda activate llama_factory cd LLaMA-Factory pip install -e .[metrics] llama_factory运行 参考github，使用以下命令启动LLaMA Factory web页面：（web ui界面只支持单卡运行，如需多卡微调请参考github相关部分）
此外可以选择模型下载源，这里推荐国内用户使用魔搭社区下载渠道。
export CUDA_VISIBLE_DEVICES=0 # `set CUDA_VISIBLE_DEVICES=0` for Windows export USE_MODELSCOPE_HUB=1 # 使用魔搭社区下载渠道 python src/train_web.py # or python -m llmtuner.webui.interface 成功启动后会进入web操作界面：
微调数据集准备 首先按照alpaca格式准备训练数据，格式范例如下：
[ { "instruction": "你好", "input": "", "output": "您好，我是XX大模型，一个由XXX开发的 AI 助手，很高兴认识您。请问我能为您做些什么？" }, { "instruction": "你好", "input": "", "output": "您好，我是XX大模型，一个由XXX打造的人工智能助手，请问有什么可以帮助您的吗？" } ] 其中，instruction和input可以都填充进内容，如把问题作为input，把“回答问题这一要求”作为instruction。据说这种指令微调数据集的格式效果比较好。
准备数据之后，应上传所用到的数据集至项目路径下data文件夹。同时需要将新数据集在dataset_info.json下进行登记注册。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa4ce8c55ef926012a84ce9873c70237/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ee2d3fe2d451083fb3b3c74904951cb/" rel="bookmark">
			【数据结构】第三节：单链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本篇要求掌握的C语言基础知识：指针、结构体
目录
前言 单链表
概念
对比链表和顺序表
创建链表
实现单链表
准备工作
打印链表
创建节点并初始化
尾插
二级指针的调用
尾插代码 头插
尾删
头删
查找（返回节点） 在指定位置(pos)之前插入数据
在指定位置(pos)之后插入数据
删除pos节点
删除pos之后的节点 销毁链表
单链表 概念 链表是⼀种物理存储结构上⾮连续、⾮顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的 。
对比链表和顺序表 顺序表：
1) 占用一大片连续内存空间
2) 不需要额外空间存储逻辑关系，总空间需求最少
4) 可顺序访问，支持随机访问
5) 在C语言中，通过数组实现
6) 数据元素的插入和删除操作通过移动元素完成
链表：
1) 不要求占用连续内存空间
2) 不仅要存储数据，还要存储数据之间的关系，故总空间需求较大
3) 通过指针反映逻辑关系
4) 逻辑连续，物理可不连续
5) 只可顺序访问，不支持随机访问
6) 存在标记：头指针
7) 数据元素的插入和删除操作通过修改指针完成：定位插入点/删除点的直接前驱/后
从上文可以得知与顺序表不同的是，链表⾥的每节"⻋厢"都是独⽴申请下来的空间，我们称之为“结点/节点” ，节点的组成主要有两个部分：当前节点要保存的数据和保存下⼀个节点的地址（指针变量）。 创建链表 //创建节点 typedef int SLTDataType; typedef struct SLNode { SLTDataType data;//数据域 struct SLNode* next;//指针域 }SLTNode; //创建节点 SLTNode* node1 = (SLTNode*)malloc(sizeof(SLTNode)); node1-&gt;data = 1; SLTNode* node2 = (SLTNode*)malloc(sizeof(SLTNode)); node2-&gt;data = 2; SLTNode* node3 = (SLTNode*)malloc(sizeof(SLTNode)); node3-&gt;data = 3; SLTNode* node4 = (SLTNode*)malloc(sizeof(SLTNode)); node4-&gt;data = 4; //链接节点 node1-&gt;next = node2; node2-&gt;next = node3; node3-&gt;next = node4; node4-&gt;next = NULL;//尾指针置空 其中数据域用于存放数据，指针域用于存放下一个结点的地址。上面的链表是手动创建节点，只是为了展示链表的形成，后续创建和链接单链表可以通过函数实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ee2d3fe2d451083fb3b3c74904951cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5b70fd50186c714eb798baa46099ff4/" rel="bookmark">
			python matplotlib绘制 3D图像专题 （三维柱状图、曲面图、散点图、曲线图合集）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先自我介绍一下，小编浙江大学毕业，去过华为、字节跳动等大厂，目前阿里P7
深知大多数程序员，想要提升技能，往往是自己摸索成长，但自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年最新Python全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，涵盖了95%以上Python知识点，真正体系化！
由于文件比较多，这里只是将部分目录截图出来，全套包含大厂面经、学习笔记、源码讲义、实战项目、大纲路线、讲解视频，并且后续会持续更新
如果你需要这些资料，可以添加V获取：vip1024c （备注Python）
正文 ʚʕ̯•͡˔•̯᷅ʔɞʚʕ̯•͡˔•̯᷅ʔɞʚʕ̯•͡˔•̯᷅ʔɞʚʕ̯•͡˔•̯᷅ʔɞʚʕ̯•͡˔•̯᷅ʔɞʚʕ̯•͡˔•̯᷅ʔɞʚʕ̯•͡˔•̯᷅ʔɞʚʕ̯•͡˔•̯᷅ʔɞʚʕ̯•͡˔•̯᷅ʔɞʚʕ̯•͡˔•̯᷅ʔɞ
大家好，我是侯小啾！
今天分享的内容是，如何使用python matplotlib绘制绘制出一系列酷炫的3D图像。基础的部分我在该系列的其他的blog中已经有所涉及，这里就主要通过代码示例快速传达有效信息啦。
1. 绘制3D柱状图
=================================================================================
绘制3D柱状图使用的是axes3d.bar()方法。
可能跟我们中学学的有一点不同的是，其语法如下：
bar(left, height, zs=0, zdir=‘z’, *args, **kwargs)
其中left表示指向侧边的轴，zs表示指向我们的方向的轴，height即表示高度的轴。这三者都需要是一维的序列对象。
在调用相关方法的时候，比如设置轴标签，还有一点需要区分的是，left对应的是y轴，zs对应的是x轴。（意思就是说，比如使用plt.xticks()方法，操作的是zs；而使用plt.yticks()方法则操作的是left轴。height对应着z轴。）
一段完整的代码示例如下：
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d.axes3d import Axes3D
import numpy as np
plt.rcParams[‘axes.unicode_minus’] = False
plt.rcParams[‘axes.facecolor’] = ‘#cc00ff’
plt.rcParams[‘font.sans-serif’] = [‘STKAITI’]
创建画布 fig = plt.figure()
创建3D坐标系 axes3d = Axes3D(fig)
zs = range(5)
left = np.arange(0, 10)
height = np.array([])
for i in range(len(zs)):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5b70fd50186c714eb798baa46099ff4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f56889428690a921acfabb310544db4/" rel="bookmark">
			Stable Diffusion教程：LoRA模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LoRA模型是一种微调模型，它不能独立生成图片，常常用作大模型的补充，用来生成某种特定主体或者风格的图片。
下载模型 在模型下载网站，如果模型是LoRA模型，网站会特别标识出来。以 liblib.ai为例：
模型左上角会有一个模型类型的标记，CHECKPOINT代表大模型，LORA代表这是一个LoRA模型。
点击进入模型详情之后，我们可以看到它的一些介绍，以及下载按钮。注意看下图我标出来的这几个地方：
1、下载按钮：点击即可下载，可能需要先登陆。LoRA模型文件一般不大，几十M到几百M不等。
2、基础算法：LoRA模型适配的大模型版本，常见的就是 1.5 和 XL。如果是 1.5，那么搭配的大模型也需要是 1.5 的模型，而不能是 XL 的模型。大模型的算法版本我们也可以在模型的详情页面上找到。
3、触发词：在提示词中包含这些词可以在生成图片中强调LoRA模型提供的独特主体或风格，这些触发词有时候不是必须的，但是建议写到提示词中，以稳定出图效果。
4、模型发布者提供的一些LoRA模型的使用说明。
5、模型发布者提供的使用当前LoRA模型生图的参数，包括提示词、采样器、采样步数、随机种子等等，使用完全一致的生图参数可以生成完全一样的图片。
在页面的下方还有其它爱好者使用这个模型的一些返图，以及图片对应的生成参数，你可以直接拿来主义。
使用模型 安装模型 我们需要把下载的模型放到 Stable Diffusion WebUI 的 LoRA 模型的文件夹下边。
&lt;stable-diffusion-webui&gt;/models/Lora 注意替换 为你的 SD WebUI 安装目录，然后重启 Stable Diffusion WebUI。
如果部署成功，我们可以在“文生图”或者“图生图”页面的“低秩微调模型(LoRA)”中看到刚刚上传的模型。
使用模型 使用模型就是在提示词中引用模型，格式是：
lora:模型的名字:模型的权重
模型的名字和模型的文件名不一定相同，我们可以在“低秩微调模型(LoRA)”中点击这个模型，WebUI就会自动在提示词中增加对这个模型的引用。
模型的权重越高生成图片时越贴近模型提供的主体或者风格，权重的取值范围是：0-1。
以下是不同权重时的效果展示：
生成图片时可以同时使用多个LoRA模型，最终效果会综合多个模型的风格。
训练LoRA模型 LoRA模型训练成本不高，往往只需要几十张图片就能训练出比较好的效果，广泛用于在生成图片时强化特定事物，比如某个高级脸、某种穿搭风格、某种绘画风格等等，经常用来做模特换衣、插画生产等，比较方便普通用户试玩。
写在最后 感兴趣的小伙伴，赠送全套AIGC学习资料，包含AI绘画、AI人工智能等前沿科技教程和软件工具，具体看这里。
​
AIGC技术的未来发展前景广阔，随着人工智能技术的不断发展，AIGC技术也将不断提高。未来，AIGC技术将在游戏和计算领域得到更广泛的应用，使游戏和计算系统具有更高效、更智能、更灵活的特性。同时，AIGC技术也将与人工智能技术紧密结合，在更多的领域得到广泛应用，对程序员来说影响至关重要。未来，AIGC技术将继续得到提高，同时也将与人工智能技术紧密结合，在更多的领域得到广泛应用。
一、AIGC所有方向的学习路线
AIGC所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照下面的知识点去找对应的学习资源，保证自己学得较为全面。
二、AIGC必备工具
工具都帮大家整理好了，安装就可直接上手！
三、最新AIGC学习笔记
当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
四、AIGC视频教程合集
观看全面零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
五、实战案例
纸上得来终觉浅，要学会跟着视频一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94f5708bd606104aeb39fab36c653ae1/" rel="bookmark">
			Stable Diffusion【ControlNet】：使用InstantID插件实现人物角色一致性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好， 今天我们来看看在Stable Diffusion的ControlNet插件中InstantID模型的使用。（文末附资料）
一. InstantID介绍
InstantID 使用 InsightFace 从参考人脸中检测、裁剪和提取人脸embedding 。然后embedding与 IP-Adapter一起使用来控制图像生成。这部分与 IP-Adapter Face ID 非常相似。不过，它还使用 ControlNet 检测并修复多个面部标志（眼睛、鼻子和嘴巴）。
结合使用IP-Adapter Face ID 和 ControlNet，可以高保真度地复制我们提供的参考图像，从而最终实现人物角色的一致性。
注意：InstantID需要使用SDXL大模型，目前还没有Stable Diffusion 1.5对应的版本。
二. InstantID插件的安装
首先将controlnet升级到最新的版本，最好是在V1.1.440版本及以上。
下载InstantID的IP-adapter模型。
下载地址：https://huggingface.co/InstantX/InstantID/blob/main/ip-adapter.bin
将下载的文件重命名为ip-adapter_instant_id_sdxl.bin。
下载 InstantID ControlNet模型。
下载地址：https://huggingface.co/InstantX/InstantID/blob/main
/ControlNetModel/diffusion_pytorch_model.safetensors
将下载的文件重命名为control_instant_id_sdxl.safetensors。
将上面下载下来的2个文件都放在stable-diffusion-webui &gt; models &gt; ControlNet文件夹目录下。具体情况大家可以按照自己的目录来。
然后重启我们的SD工具，可以看到在控制选项中多了一个Instant_ID选项，表示InstantID安装好了。
三. InstantID插件在SD 1.5中的使用
使用InstantID模型时需要注意一些事项：
大模型只能使用SDXL大模型
提示词引导系数 (CFG Scale)要比通常设置的参数值低（3-5）
需要使用2个ControlNet作为InstantID
减少两个ControlNet的控制权重（Control Weights）和引导终止时机（Ending Control Steps）
下面我们来具体体验一下InstantID插件的使用。
【第一步】：大模型的选择
这里我们使用Dreamshaper SDXL Turbo大模型。VAE大模型选择None。
【第二步】：提示词的编写
正向提示词：
Prompt：watercolors portrait of a woman (happy laughing:1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94f5708bd606104aeb39fab36c653ae1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bff4bd310a892a11c188eb64f7f46b1/" rel="bookmark">
			从UUID到替代方案：探索Java中唯一ID生成的多种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hi，我是程序员王也，一个资深Java开发工程师，平时十分热衷于技术副业变现和各种搞钱项目的程序员~，如果你也是，可以一起交流交流。
今天我们来聊聊UUID。
UUID的基本知识 UUID（Universally Unique Identifier）是一个128位长的数字，用于在分布式系统中唯一标识信息。它由两部分组成：一个32位的段和一个96位的段，通过特定的算法生成，以确保在全球范围内的唯一性。
UUID的结构和版本类型
UUID的标准格式由32个十六进制数字组成，以连字符分为五组，形式为8-4-4-4-12，例如：123e4567-e89b-12d3-a456-426614174000。每个部分都有特定的含义，其中前8位（第一段）是多播或单播地址，接下来的两个4位（第二和第三段）表示时间戳，最后的12位（第四段和第五段）是节点标识符。
Java中的UUID类提供了几种不同的方法来生成UUID，每种方法对应不同的版本。版本1基于时间和节点标识符，版本2（DCE Security UUID）基于域名和时间，版本3和5基于名称空间和名称的散列值，版本4完全随机生成。
// 示例：生成版本1的UUID（基于时间） UUID uuid1 = new UUID(0, System.currentTimeMillis()); System.out.println("Version 1 UUID: " + uuid1); // 示例：生成版本4的UUID（随机） UUID uuid4 = UUID.randomUUID(); System.out.println("Version 4 UUID: " + uuid4); 在这个例子中，我们使用UUID类的构造函数生成了一个版本1的UUID和一个版本4的UUID。
不同版本UUID的特点和生成方式
不同版本的UUID有不同的生成算法和用途。例如，版本1的UUID依赖于系统时间，因此可能存在重复的风险，尤其是在高并发的环境下。而版本4的UUID则完全随机生成，提供了更高的唯一性保证。
// 示例：生成版本3的UUID（基于名称的散列值） String name = "example.com"; UUID uuid3 = UUID.nameUUIDFromBytes(name.getBytes(StandardCharsets.UTF_8)); System.out.println("Version 3 UUID: " + uuid3); 在这个例子中，我们使用nameUUIDFromBytes方法根据一个字符串名称生成了一个版本3的UUID。
UUID的标准化组织和规范
UUID遵循RFC 4122标准，由IETF（Internet Engineering Task Force）定义。这个标准详细描述了UUID的结构、版本、以及生成算法。
// 示例：根据RFC 4122生成UUID // 通常不需要手动实现，java.util.UUID类已提供了标准的实现 在实际应用中，我们通常不需要手动实现UUID的生成，因为java.util.UUID类已经提供了符合标准的实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bff4bd310a892a11c188eb64f7f46b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/614aa71619cae44bc7b6d87c4eafd041/" rel="bookmark">
			A*（A-star）算法 定义&#43;特性&#43;原理&#43;公式&#43;Python示例代码（带详细注释）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言定义特性基本原理及公式推导基本原理公式推导 实现步骤与代码实现实现步骤Python代码代码说明代码运行结果 应用案例优化和挑战挑战优化 结论 引言 A*算法由Peter Hart, Nils Nilsson和Bertram Raphael在1968年提出，是解决路径搜索问题的一种启发式算法。它用于在图中找到从起始节点到目标节点的最短路径，并广泛应用于游戏设计、机器人导航等领域。
定义 A*（A-star）算法是一种在图中寻找从初始节点到目标节点最短路径的启发式搜索算法。它结合了Dijkstra算法的确保性（保证找到一条最短路径）和贪心算法的高效性（快速找到目标）。A* 算法通过评估函数 f ( n ) = g ( n ) + h ( n ) f(n) = g(n) + h(n) f(n)=g(n)+h(n) 来工作，其中 g ( n ) g(n) g(n) 是从起始点到任何顶点 n n n 的实际成本，而 h ( n ) h(n) h(n) 是从顶点 n n n 到目标的估计最低成本，通常用启发式函数来计算，这个函数需要事先设计来反映实际的地形或环境特征。理想情况下， h ( n ) h(n) h(n) 应该不会高估实际的成本，这种情况下，A* 算法保证找到一条最低成本路径。算法的性能和准确性高度依赖于启发式函数的选择。在实际应用中，A* 算法广泛应用于各类路径规划问题，如机器人导航、地图定位服务和游戏中的AI路径寻找等场景。通过适当选择和调整启发式函数，A* 算法能够在复杂的环境中有效地寻找最短路径，同时保持计算上的可行性和效率。
特性 A* 算法具有以下显著特性：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/614aa71619cae44bc7b6d87c4eafd041/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ee032041ccaeca4a077a4a2c10b83ac/" rel="bookmark">
			HBuilder X运行项目到微信开发者工具调试和发布Uniapp小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载和安装 HBuilderX hbuilder首页：https://www.dcloud.io/hbuilderx.html
下载hbuilder编辑器,选择对应的系统,Windows和mac正式版即可,下载后免安装直接点击即可使用。
打开HBuilder之后，它会要求你注册一个用户，然后才可以使用。
第一次使用必须注册用户，登录才可以，这是它的硬性要求。按照官方的说法，HBuilder不单单希望只是一个工具，而是把工具和社区联系起来，所以才要求用户注册。
2.申请微信小程序 官网地址：https://open.weixin.qq.com/home
注册一下小程序，完善资料拿到
AppID(小程序ID)
AppSecret(小程序密钥）
3.配置并验证开发者身份 在 HBuilderX 中，需要完善mainifest.json中的基本配置:
Dcloud的应用AppID：
这个需要注册dcloud才可以获取，注册后点击重新获取就可以。
然后发行前还需要完成dcloud的信息，管理控制台地址：
https://dev.dcloud.net.cn/pages/app/list
微信appid
4.配置运行微信开发者工具 下载微信开发者工具：
https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html
下载稳定版：
下载完成后点击安装：
5.HBuilder X配置微信开发者工具位置 点击“工具-设置-运行配置-微信小程序运行配置”
6.设置微信开发者工具 配置完HBuilder X还需要配置微信开发者工具
打开微信小程序打开服务端口
设置-安全设置-安全-打开服务端口：
7.运行小程序 回到HBuilder X
点击“运行→运行到小程序模拟器→微信开发者工具”
将当前 uniapp 项目编译之后，自动运行到微信开发者工具中，从而方便查看项目效果与调试，微信开发者工具会自动弹出来一个新窗口,可能没登录需要扫码登录微信开发者工具，微信开发者工具加载uniapp项目可能需要一段时间：
8.使用微信开发者工具调试： 使用模拟器进行预览 微信开发者工具内置了小程序的模拟器，可以实时预览小程序的运行效果。在代码编辑界面，点击“预览”按钮，就可以在模拟器中看到小程序的界面。模拟器支持多种设备和屏幕尺寸，还可以模拟网络状态、地理位置等环境条件。
使用真机调试 除了模拟器，微信开发者工具还支持真机调试。在代码编辑界面，点击“真机调试”按钮，可以将小程序的预览版发送到微信客户端，然后在真机上进行调试。真机调试可以更准确地反映小程序在实际环境中的表现。
9.使用微信开发者工具发布： 上传和发布小程序 开发完成后，可以将小程序上传到微信公众平台。在微信开发者工具中，点击“上传”按钮，输入版本号和项目描述，就可以将小程序的代码上传到服务器。
10.提交审核 在微信公众平台的管理后台，提交小程序的审核申请。审核通过后，就可以在管理后台操作发布小程序，用户就可以在微信中搜索或扫码访问小程序了。
在微信公众平台中，进入“小程序管理”-&gt;“版本管理”，点击“提交审核”按钮，填写相关信息，并提交审核申请。
审核通过后，即可发布上线小程序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/296bad02ef8ef9b6fa47532e405745f0/" rel="bookmark">
			数据结构之单链表的相关知识点及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：数据结构
目录
链表的概念及结构
链表与顺序表的区别与优劣势
链表的分类
单链表的实现
单链表中增加节点 单链表中尾插数据 打印单链表中节点的数据 单链表中头插数据 单链表中查找数据 单链表中尾删数据 单链表中头删数据 单链表中在指定位置之前插入数据 单链表中在指定位置之后插入数据
单链表中删除pos节点的位置
单链表中删除pos节点之后的位置 销毁链表 单链表源码
数据结构之顺序表的相关知识点及应用-CSDN博客
在前文顺序表中，我们学习了什么是线性表，以及线性表中的顺序表，最后我们也是实现了顺序表。接下来，就开始学习线性表的另一种——链表。
链表的概念及结构 概念：链表是一种物理存储结构上非连续、非顺序的，逻辑结构上是连续的。而数据中元素的逻辑顺序是通过链表中的指针链接次序实现的。也就是通过指针链接起来，是线性的。
链表的结构跟火车车厢是类似的，当人少或者非节假日时车次的车厢会相应减少，当人多或者节假日时车次的车厢会额外增加。只需要将火车的某节车厢去掉或者加上，不会影响其他车厢，每节车厢都是独立存在的，且每节车厢都有车门。想象一下，假设每节车厢的车门都是被锁上的，需要不同的钥匙才能解锁，每次只能携带一把钥匙的情况下如何从车头走到车尾？ 最简单的做法：每节车厢里都放一把下一节车厢的钥匙。下面就是火车和链表的具体图示：
与顺序表不同的是，链表里的每节“车厢”都是独立申请下来的空间，我们称之为“结点/节点” 。节点的组成主要有两个部分：当前节点要保存的数据和保存下一个节点的地址（指针变量）。 图中指针变量 plist 保存的是第一个节点的地址，我们称 plist 此时指向第一个节点，如果我们希望plist指向第二个节点时，只需要把plist保存的内容修改为0x0012FFA0。 为什么还需要指针变量来保存下一个节点的位置？ 因为链表中每个节点都是独立申请的（即需要插入数据时才去申请一块节点的空间），我们需要通过指针变量来保存下一个节点位置才能从当前节点找到下一个节点。 结合前面学到的结构体知识，我们可以给出每个节点对应的结构体代码： 假设当前保存的节点为整型：
struct SListNode { int data; //节点想保存的数据 struct SListNode* next; //指向下一个节点的指针 }; 当我们想要保存一个整型数据时，实际是向操作系统申请了一块内存，这个内存不仅要保存整型数 据，也需要保存下一个节点的地址（当下一个节点为空时，即该节点为最后一个节点时，保存的地址为空）。 当我们想要从第一个节点走到最后一个节点时，只需要在前一个节点拿到下一个节点的地址（下一个节点的钥匙）就可以了。
链表与顺序表的区别与优劣势 顺序表的优势：顺序表可以随机访问其中的元素，而链表不可以。就是因为顺序表的底层是数组，而数组是可以通过下标达到随机访问的目的。而链表只能通过指针去遍历访问。
链表的优势：插入或者删除数据时，不需要移动其它元素；不需要开辟过多的空间，按需所给，即用多少，给多少，不会浪费空间。
链表的分类 链表根据：是否带头，单双向，是否循环，分为八大类。
重点有两个：单链表和双链表。
单链表：不带头单向不循环链表；双链表：带头双向循环链表。
头指的是头节点，也叫做哨兵位。头节点中存放的是无效信息，只是一个哨兵的作用。
注意：头节点在单链表中不存在，只是为了更好的理解，才引用了这个。
单向是指：
双向是指：
从前一个节点指向后一个节点（例如：1-&gt;2）的指针被称为后继指针。
从后一个节点指向前一个节点（例如：2-&gt;1）的指针被称为前驱指针。
循环是指链表是否成环。
单链表的实现 接下来，我们就开始用单链表实现对数据的增加，查找，删除。
在创建单链表之前，要做一些提前准备。创建3个文件：SList.h SList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/296bad02ef8ef9b6fa47532e405745f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d53b1026c3b76ee2caaaf16c6ab189e3/" rel="bookmark">
			Java fastJson的maven配置以及下载使用方法及相关文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FastJson 是一个由阿里巴巴开发的高性能 JSON 处理库，广泛应用于 Java 应用程序中，用于序列化和反序列化 JSON 数据。在 Java 项目中使用 FastJson，通常会通过 Maven 来管理依赖。下面我将为您介绍如何在 Maven 项目中配置 FastJson，以及如何下载和使用它。
}
参考文档：Java fastJson的maven配置以及下载使用方法及相关文档-CJavaPy
Maven 配置 要在 Maven 项目中使用 FastJson，您需要在项目的 pom.xml 文件中添加 FastJson 的依赖。以下是 FastJson 的 Maven 依赖配置：
&lt;dependencies&gt;
&lt;dependency&gt;
&lt;groupId&gt;com.alibaba&lt;/groupId&gt;
&lt;artifactId&gt;fastjson&lt;/artifactId&gt;
&lt;version&gt;1.2.83&lt;/version&gt; &lt;!-- 请使用最新版本 --&gt;
&lt;/dependency&gt;
&lt;/dependencies&gt;
请注意检查 FastJson 的最新版本号，以确保使用的是最新的稳定版本。版本号可以在 Maven 中央仓库（https://mvnrepository.com/artifact/com.alibaba/fastjson）查找。
下载和使用 FastJson 一旦添加了 Maven 依赖，Maven 会自动处理下载和依赖管理。在代码中使用 FastJson 进行 JSON 的序列化和反序列化操作非常简单。以下是基本的使用示例：
序列化（将 Java 对象转换为 JSON 字符串） import com.alibaba.fastjson.JSON;
public class Main {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d53b1026c3b76ee2caaaf16c6ab189e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5ac6d564c148f0868f71e18d0ec80a9/" rel="bookmark">
			【前端】为什么postman可以请求成功，并且GET请求没有问题，但是POST访问却是403？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		向后端发起GET请求成功了，POST请求却发生了403，然而再尝试Postman发送POST请求却能成功，为什么？记录一下整体过程 问题与结论解决过程 为什么GET请求可以？为什么Postman请求可以？ 问题与结论 今天和后端联调，发现了一个问题，发起的get请求没有问题，post请求都被拦截了，403forbidden，后端觉得是前端配置问题，于是用 postman发送了请求，并且成功了，这是为什么呢？
先说结论确定了前端的配置没有问题后，查看了后端代码与历史修改记录（曾经是没问题的），发现后端修改了一行代码导致的，config.addAllowedOrigin("*")，据后端所说，他们是重写了cors的拦截策略，因为安全性，所以删除了这行代码。
问题结论：没有允许非同origin下的请求
但是该行代码，同时引起了我的思考，为什么postman可以？为什么同样的GET请求可以，但是POST请求不可以？
解决过程 首先，判断并非是前端跨域问题。
在Webpack中设置反向代理通常是为了解决开发环境中的跨域请求问题。可以使用webpack-dev-server的反向代理功能来实现。且前端若配置失败，浏览器返回的错误是这样的。
于是应该是后端做了什么相关的策略。后端当时使用postman，发现并无问题。
因为之前项目是没问题的，所以去查了修改记录，所以发现是为了安全考虑，少了那一行代码。
贴上修改后的代码
import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.cors.CorsConfiguration; import org.springframework.web.cors.UrlBasedCorsConfigurationSource; import org.springframework.web.filter.CorsFilter; @Configuration public class CorsConfig { @Bean public CorsFilter corsFilter(){ //1.添加CORS配置信息 CorsConfiguration config = new CorsConfiguration(); //1) 允许的域,不要写*，否则cookie就无法使用了 // config.addAllowedOrigin("*"); //这里填写请求的前端服务器 config.addAllowedOriginPattern("*"); //2) 是否发送Cookie信息 config.setAllowCredentials(true); //3) 允许的请求方式 config.addAllowedMethod("OPTIONS"); config.addAllowedMethod("HEAD"); config.addAllowedMethod("GET"); config.addAllowedMethod("PUT"); config.addAllowedMethod("POST"); config.addAllowedMethod("DELETE"); config.addAllowedMethod("PATCH"); //4) 允许的头信息 config.addAllowedHeader("*"); //2.添加映射路径，我们拦截一切请求 UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource(); configSource.registerCorsConfiguration("/**", config); //3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5ac6d564c148f0868f71e18d0ec80a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eab294e3d993465d4650bf7dcc56db6/" rel="bookmark">
			[Mysql] 群晖7.21 部署MySQL数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		群晖7.21 部署MySQL数据库 群晖部署MySQL数据库过程记录
docker-compose方式搭建 mysql
前言： 我在使用群晖的container Manager（群晖7.x及以前的版本为docker） 搭建Mysql 数据库时遇到很多问题，各种报错。
正常来讲，简单container Manager图形交互界面动动鼠标就能搭建好的
具体可以参考这篇教程：
群晖NAS中使用Docker安装MySQL数据库、
但我跟着教程步骤，初始化运行后总是失败，mysql 容器闪退
其中有这样的error log：
mysqld.sock 文件不存在
分析及查询网上分享解决方案都试过了，却没有得到解决。
参考解决方案：
黑群晖里面docker安装mysql8报错处理
快速解决Can 't connect to local MySQL server through socket '/tmp/mysql.sock '(2) "; 我尝试解决，浪费了5个多小时的生命却失败了
没有办法，只能用到我为数不多的命令行终端部署技能使用docker-compose 来搭建
以下是总结的步骤： 搭建前准备 安装docker我就不细说了，我们只需要提前准备好docker-compose.yaml文件，及安装的文件夹。
准备映射目录
在共享文件夹的docker文件夹中新建mysql文件夹，在mysql文件夹新建mysql、mysqlBacker文件夹，并放入我们提前写好的docker-compose.yaml文件
docker-compose.yaml文件内容： version: "3" services: mysql: image: mysql:8.1.0 container_name: mysql-test #容器名称，自定义更改 restart: on-failure:3 networks: mysql_default: command: - --default-authentication-plugin=caching_sha2_password - --character-set-server=utf8mb4 - --collation-server=utf8mb4_general_ci - --explicit_defaults_for_timestamp=true volumes: - ./mysql:/var/lib/mysql - .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6eab294e3d993465d4650bf7dcc56db6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/656450051a017dd0da594762c0250262/" rel="bookmark">
			如何升级node.js版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		升级Node.js可以通过多种方式来完成，以下是四种常见的方法：
方法一：使用Node.js官方安装程序 访问Node.js的官方网站，下载对应你操作系统的最新版本安装程序。通常，你可以
https://nodejs.org/en/download
找到你需要的版本，比如:v18.20.2LTS
双击打开下载的安装程序，并按照安装向导的指示进行安装。如果你已经安装了Node.js，安装程序通常会提供一个“Upgrade”选项，选择这个选项可以自动升级到最新版本。
方法二：使用nvm（Node Version Manager） 如果你使用的是Unix系统（如Linux或macOS），可以使用nvm来管理多个Node.js版本。
首先，你需要安装nvm。这通常可以通过在终端中运行一些命令来完成。安装完成后，nvm将允许你安装、使用和管理不同版本的Node.js。使用nvm install &lt;version&gt;命令来安装你想要的新版本Node.js，其中&lt;version&gt;是你想要安装的版本号。例如，nvm install 16.13.0将安装Node.js的16.13.0版本。使用nvm use &lt;version&gt;命令来切换到新安装的版本。例如，nvm use 16.13.0将使用你刚刚安装的16.13.0版本。你可以使用node -v命令来验证是否已成功更新到新版本。 方法三：使用包管理器 如果你使用的是npm（Node Package Manager）或Yarn等包管理器，它们可能也提供了更新Node.js的功能。具体步骤取决于你使用的包管理器，你可以查阅相关文档或在线资源来了解如何使用包管理器来更新Node.js。
方法四：使用命令行 如果你熟悉命令行操作，也可以通过命令行来更新Node.js。这通常涉及到下载新的Node.js版本，然后解压并替换旧的版本。这种方法相对复杂，需要一定的技术知识，因此不建议初学者使用。
无论你选择哪种方法，都建议在升级Node.js之前备份你的代码和项目，以防万一出现任何问题。同时，也要注意检查你的项目依赖是否与新版本的Node.js兼容，以避免升级后出现运行错误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/818a8931bfea646efeb12f3c219de524/" rel="bookmark">
			适用于Android的30种最佳免费黑客应用程序和工具_droidsheep
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本文中，我们将列出前30个Android黑客工具，以帮助完成网络和渗透测试任务。
CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享
适用于Android的30种最佳免费黑客应用程序和工具
NMap for Andr oid（NetworkMapper）
Network Mapper是知名Nmap扫描仪的非官方Android前端。前端将帮助您下载和安装Nmap以及使用它。
Nmap将帮助您发现主机，协议，开放端口，服务及其在网络上的配置和漏洞。
CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享
FaceNiff
图片来源：Faceniff
FaceNiff是一个Android应用程序，它使您可以通过手机所连接的WiFi嗅探和拦截Web会话配置文件。（必填）
AndroidRAT
AndroidRAT是适用于Android设备的Android 远程管理工具。
AnDOSid
AnDOSid是斯科特·赫伯特（Scott Herbert）开发的一款Android工具，可用于从手机发起DoS攻击。
SSHDroid – Android安全壳
SSHDroid应用程序使您可以从PC连接到设备并执行命令（例如“ terminal”和“ adb shell”）或编辑文件（通过SFTP，WinSCP，Cyber​​duck等）。
Hackode
Hackode：黑客工具箱是一款用于渗透测试人员，道德黑客，IT管理员和网络安全专业人员的应用程序，可以执行不同的任务，例如侦察，扫描执行的漏洞利用等。
WhatsApp嗅探器
WhatsApp Sniffer Android应用程序允许Android用户从使用相同WiFi的手机接收来自WhatsApp应用程序的短信
Evil Operator
使用Evil Operator，您可以将两个朋友连接到电话交谈中，使他们以为自己互相呼叫！然后，您可以记录通话，并通过社交媒体和云服务与朋友共享记录。限制：每天只允许一个免费电话！Evil Operator允许您与PrankDial应用共享令牌。
APK检查器
APKinspector是一款功能强大的GUI工具，可供分析人员分析Android应用程序。
Kill Wi-Fi
Kill Wi-Fi应用程序会使同一网络中的其他设备认为您的设备是路由器。因此，他们将尝试通过您连接到Internet。WifiKill然后断开这些其他设备的连接。
Droidsheep
DroidSheep是由Andreas Koch开发的android Mitm工具，用于无线网络中的安全性分析。这是一个会话劫持工具，使黑客可以通过无线网络捕获会话cookie。
dSploit
dSploit是为Android操作系统开发的渗透测试套件。自2014年起，DSploit与zANTI合并。
zANTI™
zANTI™是一种移动渗透测试工具套件，可让安全管理人员按一下按钮即可评估网络的风险级别。这种易于使用的移动工具包使IT安全管理员可以模拟高级攻击者，以识别他们在野外使用的恶意技术来破坏公司网络。
Shark For Roo
Shark For Root是Wireshark的安卓版本，专为安全专家和黑客设计。它基本上是在WiFi，3G和网络共享模式下工作的流量嗅探器。该应用程序基于tcpdump，可与tcpdump命令行选项一起使用。享受这个出色的Android应用程序。
ZipSigner
ZipSigner应用程序允许您使用自己的私钥或四个内置证书（媒体，平台，共享，测试键）之一通过Android设备对update.zip文件，APK或JAR文件进行签名。所有输出都是自动zip对齐的ZipSigner可以与现有密钥库一起使用，或者您可以创建密钥库，密钥和自签名证书。
Wi-Fi查找器
不必担心在线或离线找到免费或付费公共Wi-Fi热点的Wi-Fi互联网连接Wi-Fi Finder提供了您周围各种Wi-Fi热点的详细地图，在寻找开放无线网络时会非常有用。
适用于Android的SSLStrip
适用于Android的SSLStrip是由Moxie Marlinspike创建的流行的SSLStrip（一种Python工具）的移植。SSLStrip 透明地劫持网络上的HTTP流量SSLStrip允许HTTPS流量被强制使用HTTP SSL剥离攻击在执行MITM攻击时非常有用。
USB Cleaver
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/818a8931bfea646efeb12f3c219de524/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a6c3b746a24eaffeacb53a945d87cd0/" rel="bookmark">
			mysql中主键索引和联合索引的原理解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql中主键索引和联合索引的原理解析 一、主键索引二、什么是联合索引? 对应的B+树是如何生成的?1、建立索引方式2、什么是最左前缀原则?3、回表4、为什么要遵守最左前缀原则才能利用到索引?5、什么是覆盖索引?6、索引扫描底层原理7、order by为什么会导致索引消失？8、有哪些情况会导致索引失效?9、索引设计原则1、选择合适的列作为索引2、避免使用过多的索引 三、InnoDB 与MyISAM 的区别 一、主键索引 主键索引：按照主键数据从小到大按照从左到右进行排序，叶节点只存储数据区；
接着将上面的页生成出来，页只存储索引和指针，指针指向数据域，当通过主键查找数据时，从B+树的头部开始寻址数据、读取数据。
上面为索引页
下面为数据页
查询select * from table where a=6，会从上到下走法，找索引
查询select * from table where a&lt;6，会从上到下走法，找索引；
原因：先找a=6是走索引的，找到a=6数据后，将左边的数据全部返回即可。
为了方便把前面数据给你采用双向指针
查询select * from table where b=6，会从左到右走法，全表扫描，因为b未有命中索引。
二、什么是联合索引? 对应的B+树是如何生成的? 联合索引：将数据库表中多个字段组成一个索引。bcd联合索引；bcd三个字段进行排序
1、建立索引方式 create index idx_t1_bcd on t1(b,c,d);bcd三个字段进行排序
2、什么是最左前缀原则? 复合索引，也叫联合索引，用户可以在多个列上建立索引,这种索引叫做复合索引。
当我们创建一个组合索引的时候，如(k1,k2,k3)，相当于创建了(k1)、
(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。
select * from table where k1=A and k2=B and k3=C 3、回表 select * from t1 where b=1 and c=1 and d=1执行逻辑：
通过联合索引找到一条数据的3个字段，但是select * 查找多个字段，所以需要存储主键字段，通过主键字段去主键索引里面找到完整的这条数据，并将这条数据返回。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a6c3b746a24eaffeacb53a945d87cd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9941b431559d5a638e7e61cece50d448/" rel="bookmark">
			Flink数据流动全观察：代理技术实现细节记录与分析（附完整源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 01 前言02 背景调研03 Agent实现Flink流动数据的监听3.1 Agent的源码实现3.2 Flink sdk集成Agent jar 04 验证05 文末 01 前言 本文源码已上传至Github：https://github.com/ylw-github/flink-agent
在当今数据驱动的时代，Apache Flink 以其卓越的有状态计算能力和对有界及无界数据流的高效处理而广受欢迎。Flink主要用来 “处理” 数据的，但其本身并不 “存储” 数据。但很多时候，用户更期待的是 “可以看到一个Flink任务里面的真实数据是怎么流动的，流动的内容有什么？
例如“Kafka实时同步到Mysql的flink作业” ：在程序持续运行的过程中，用户期望看到实时同步有哪些数据、具体的数据内容，或可能会出现把这些数据实时写到第三方的日志系统这种需求。很遗憾，Flink并不支持该功能，也没有相应的API或提供相关的hook实现，目前只能够通过Metrics去查看数据流动的数量以及速率这些统计信息。
因此，博主本文主要分享的是：探索在不修改Flink源码的前提下，如何通过代理技术捕捉并记录数据流动的每一个细节？
02 背景调研 在寻找解决方案的过程中，博主发现了一些开源项目，如纯钧（原名：FlinkX），它提供了一些值得借鉴的思路。特别是关于脏数据管理的实现，具体的文档地址：《拓展功能@脏数据插件设计》
为何要提到这一块呢？博主是想参考Chunjun是在哪里获取到脏数据？如何获取脏数据的具体内容的？以便找到监听的入口。
通过一系列的代码review，发现Chunjun是在每个Connector里面去采集脏数据的，且Connector都需要经过二次开发，只有使用它们的Connector才能取脏数据（如下图）。显然，这是不满足本文的需求的，我期望的是：在不改变Flink的源码前提下，做到通用Connector的监听，且可以通过简单的方式就能获取到这些流动数据的内容了。
因此，博主想到了通过代理的方式去获取Flink流动的数据，类似于阿里开源的Arthas框架实现，博主也写过相关的源码分析，有兴趣的同学可以看看：《Arthas使用与源码分析》。
Ok，直接进入本文的主题，下面展示详细的实现。
03 Agent实现Flink流动数据的监听 一个Flink程序的运行，会依赖到一个或多个Connector（连接器），而这些连接器分为Source（主要用于读）和Sink（主要用于写），那么如果要监听到Flink作业流动的数据，我们这里可以简单尝试去查看支持Sink的Connector(例如：flink-connector-jdbc)，看看 是否有实现一个公共的接口，然后对这个接口做监听，即可“读取”写入前的数据 ? 。
再次经过一系列的代码review，博主发现基本所有的sink相关的Connector都继承了“org.apache.flink.api.common.io.OutputFormat”这个接口类，而这个接口类里面有个核心的方法（writeRecord），我们可以从这个方法作为监听的入口：
public interface OutputFormat&lt;IT&gt; extends Serializable { ..... /** * Adds a record to the output. * * &lt;p&gt;When this method is called, the output format it guaranteed to be opened.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9941b431559d5a638e7e61cece50d448/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e8abbc6e1d3c442ca36f921bedb316f/" rel="bookmark">
			ChatGPT在日常生活与工作中的应用，以及Hulu AI 的探索之旅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGPT在日常生活与工作中的应用，以及Hulu AI 的探索之旅 💬ChatGPT 的多面应用💬Hulu AI：一个AI工具聚合平台的探索平台优势为何选择Hulu AI？珍稀优惠 💬结束语 在数字化快速发展的当下，人工智能技术已经成为我们不可或缺的一部分。特别是在信息过载的时代，AI 如 ChatGPT 等工具能够帮助我们更高效地处理信息，提升生活和工作质量。本文旨在探讨 ChatGPT 在不同领域的实用性，以及介绍一个集成了多种AI工具的平台——Hulu AI，它可能是你接下来想要探索的AI世界的入口。
💬ChatGPT 的多面应用 ChatGPT 作为一种先进的语言处理工具，其应用范围广泛：
教育辅导：ChatGPT 能够提供作业帮助、语言学习支持，以及模拟考试场景训练等。编程辅助：对于软件开发者，ChatGPT 能够提供代码示例、调试帮助以及技术文档编辑等服务。内容创作：无论是撰写博客、文章还是社交媒体帖子，ChatGPT 都能提供初稿，甚至给出编辑建议，大幅提升内容创作效率。日常咨询：从天气预报到专业知识咨询，ChatGPT 都能提供即时的信息服务。 💬Hulu AI：一个AI工具聚合平台的探索 对于那些热衷于探索AI应用、希望将AI技术更好融入工作和生活中的朋友们，Hulu AI 无疑是值得一看的平台。Hulu AI 集成了市面上众多常用的大模型，包括 ChatGPT4.0、Midjourney、Dall·E3、文心一言4.0、Gemini，覆盖了 AI对话、AI写作和AI绘画三大刚需场景。
平台优势 多模型集成：满足不同的AI应用需求，无需切换多个平台。高性价比：Hulu AI 提供年卡服务，目前278元可享两年使用权限，性价比高。稳定可靠：已有数万用户验证，运行稳定。 为何选择Hulu AI？ 首先，便利性和性价比是选择它的强大理由。若你的需求覆盖了AI对话、写作和绘画等不同场景，通过一个平台即可一站式解决多个需求，省去了账号多、费时费力的困扰。其次，平台目前在采取前期冲用户量的措施，价格上更具吸引力。实际上，减少了接口对接、充值和账号封锁等一系列技术或管理问题的疑虑，对于多数人而言，这是一大福音。 珍稀优惠 🔥目前，Hulu AI 提供最后 80 个优惠名额，限时3天278元可以享用两年的服务。如果你有AI工具使用的需求，这无疑是一个不容错过的机会。即便只是出于好奇，平台也提供免费体验机会
在线体验地址：https://h5.cxyhub.com/
而且，添加小助手【备注hacker】还能领取一份最新的【AI变现案例资料库】 对于有意探索AI变现路径的朋友来说，这是一份宝贵的资源。
💬结束语 无论你是AI技术的狂热爱好者，还是希望通过AI技术优化自己的工作与生活的实用主义者，Hulu AI 都值得一试。它不仅涵盖了目前市场上颇受欢迎的AI应用模型，还以高性价比和稳定性吸引了广大用户。在AI技术不断演化的时代，让我们一起探索未知、释放潜力，并有效利用这些工具提升我们的生活质量。
欢迎各位监督，共同见证 ChatGPT 和 Hulu AI 的成长与进步！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/761c1d69addaa9ac5c56294f910d8a8f/" rel="bookmark">
			人工智能热点跟踪：CVPR 2024热门研究领域分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图 1 由CVPR 2024论文列表高频词生成的词云
IEEE/CVF Computer Vision and Pattern Recognition Conference（CVPR）是计算机视觉和模式识别领域的顶级学术会议之一，每年举办一次，与ICCV和ECCV并称为计算机视觉领域的三大顶级会议。CVPR 2024的会议时间为2024年6月17日至6月21日，会议地点为美国华盛顿州西雅图。根据4月5日CVPR官方发布的结果，会议今年收到了11532篇有效论文提交，有2719篇被接收，整体接收率约为 23.6%。本文将对CVPR2024的录用论文进行可视化分析，为读者跟踪人工智能的研究热点提供一些有价值的参考。本文作者为黄星宇，审校为陆新颖和许东舟。
会议相关链接：https://cvpr.thecvf.com/
一、一图看懂CVPR（2017-2024）发展趋势 图 2 CVPR（2017-2024）发展趋势
由图2可以看出CVPR近年来的发展趋势。近年来，CVPR的投稿数量逐年攀升，平均每年增加1000-2000篇左右，体现了人们对CVPR会议的看重，以及计算机视觉领域的迅猛发展。同时，论文的接收量也随着投稿量的上升在增加，总体的接收率维持的比较稳定，尽管个别年份会有波动，也体现了会议并没有因为投稿量的增多而降低论文质量。总的来说，CVPR随着计算机视觉领域的发展还会变的更加火热，继续展现其在领域内的权威性。
二、CVPR 2024热点追踪 接下来，对CVPR 2024里出现的高频关键词进行更详细的讨论和分析（个人理解，仅供参考）：
图 3 热门研究方向
2.1 扩散模型（Diffusion Models） 基本概念：扩散模型是一种深度学习框架，被用于生成模型的研究中，尤其是用于创建逼真的合成图像。这类模型通过引入随机噪声到数据中，然后学习逆向这个过程以生成清晰图像，它们在改进图像质量和生成新图像方面显示出了巨大的潜力。
示例论文：DEADiff: An Efficient Stylization Diffusion Model with Disentangled Representations
全文下载：https://arxiv.org/abs/2403.06951
2.2 3D 基本概念：在计算机视觉领域，3D视觉关注的是从图像和视频中理解和重建三维世界。这包括通过技术如立体视觉、深度感测、光场摄影和结构光扫描等来获取物体和场景的三维结构信息。3D计算机视觉使得机器不仅能识别和分类图像中的对象，还能估计它们在真实世界中的尺寸、形状、位置和姿态。这种技术在自动驾驶汽车、机器人导航、增强现实、虚拟现实以及自动化3D模型创建等众多应用中至关重要。
示例论文：Deformable 3D Gaussians for High-Fidelity Monocular Dynamic Scene Reconstruction
全文下载：https://arxiv.org/abs/2309.13101
2.3 神经辐射场（NeRF） 基本概念：NeRF（Neural Radiance Fields）是一种用于3D场景重建和渲染的深度学习框架，它通过对光线在空间中的行为进行建模来创建高质量的3D图像。NeRF工作原理是利用神经网络来预测在场景的任何给定位置沿任意方向的光线的颜色和密度，通过大量的2D图像训练，网络能够生成新的视角下的3D场景的连续视图，从而实现复杂场景和光照效果的逼真渲染。
示例论文：PIE-NeRF: Physics-based Interactive Elastodynamics with NeRF
全文下载：https://arxiv.org/abs/2311.13099
2.4 大语言模型（LLM） 基本概念：大语言模型（Large Language Model, LLM）是基于深度学习的、训练于大规模文本数据集上的模型，旨在理解和生成人类语言。通过利用数十亿甚至数万亿的参数，这些模型能够捕捉语言的复杂性、多样性以及微妙的语境差异。LLM如GPT（Generative Pre-trained Transformer，GPT）和BERT（Bidirectional Encoder Representations from Transformers，BERT）通过预训练和微调的策略，学会执行多种语言任务，比如文本生成、翻译、摘要、问答和情感分析等。这些模型的关键优势在于其能够根据给定的输入文本生成连贯、相关且多样的输出，推动了自然语言处理技术的发展。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/761c1d69addaa9ac5c56294f910d8a8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2b9e6e519018235b5dac5cfd426cc59/" rel="bookmark">
			uniapp 小程序实现微信授权登录（前端和后端）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：https://blog.csdn.net/weixin_43835425/article/details/131147690
掘金地址：https://juejin.cn/post/7290371873547583548
1.前端：通过 uni.getUserProfile 和 uni.login 来实现
1.主要流程：先通过 uni.getUserProfile授权获取用户名称和头像等信息 在调用 uni.login 获取微信登录需要的临时code
2. 前端代码：
async onLogin() { //获取用户信息 （头像和名称） const [, userProfile] = await uni.getUserProfile({ desc: "获取用户信息", lang: "zh_CN", }); if (userProfile) { //调用微信登录接口获取临时code const [, loginInfo] = await uni.login({ provider: "weixin" }); if (loginInfo) { // 登录临时code const { code } = loginInfo; const {userInfo: { avatarUrl, nickName }} = userProfile; // 组装后端接口需要的数据 const params = {code, avatarUrl, userName: nickName}; // 调用登录接口 const { data } = await wxLogin(params); uni.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2b9e6e519018235b5dac5cfd426cc59/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/35/">«</a>
	<span class="pagination__item pagination__item--current">36/71</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/37/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>