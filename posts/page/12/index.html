<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/968ac2cb8f3f53f93383c0402badf2c8/" rel="bookmark">
			RegExp 魔法阵与 Cookie 记忆宫殿：JavaScript 中的秘密宝藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页：学习前端的小z
个人专栏：JavaScript 精粹
本专栏旨在分享记录每日学习的前端知识和学习笔记的归纳总结，欢迎大家在评论区交流讨论！
RegExp正则表达式
文章目录 🔆RegExp 🎲1 什么是正则表达式 🎲2 创建正则表达式 💟2.1 直接量 💟2.2 new RegExp 🎲3 正则表达式用法及区别 💟3.1 String中正则表达式方法 💟3.2 RegExp对象的方法 🎲4 修饰符 🎲5 pattern 模式 💟5.1 基本匹配 💟5.2 [] 💟5.3 元字符(`转义字符`) 💟5.4 量词 💟5.5 贪婪 惰性 💟5.6 子组(子表达式) 🎲6 常用正则 🔆Cookie 🎲1 访问cookie 🎲2 存储cookie 🎲3 设置cookie过期时间 🎲4 cookie封装 🔆RegExp 🎲1 什么是正则表达式 正则表达式是描述字符模式的对象。
正则表达式用于对字符串模式匹配及检索替换，是对字符串执行模式匹配的强大工具。
而String和RegExp都定义了使用正则表达式进行强大的模式匹配和文本检索与替换的函数。
正则表达式主要用来验证客户端的输入数据。可以节约大量的服务器端的系统资源，并且提供更好的用户体验。
🎲2 创建正则表达式 💟2.1 直接量 语法：Reg = /pattern/modifiers;
var Reg = /box/gi; 💟2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/968ac2cb8f3f53f93383c0402badf2c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14a79ea92ed4e647381c0f977981c792/" rel="bookmark">
			SpringBootWeb 篇-深入了解 Mybatis 概念、数据库连接池、环境配置和 Lombok 工具包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥博客主页： 【小扳_-CSDN博客】
❤感谢大家点赞👍收藏⭐评论✍
文件目录
1.0 Mybatis 概述
2.0 数据库连接池
2.1 数据库连接池的主要作用包括
2.2 如何切换数据库连接池？
3.0 配置环境
4.0 Lombok 工具包
4.1 如何导入到项目中呢？
5.0 application 属性文件数据库连接的信息与 pom XML文件的依赖
1.0 Mybatis 概述 MyBatis 是一个持久层框架，它简化了数据库操作和 SQL 语句的处理。MyBatis 通过 XML 或注解的方式配置 SQL 语句，将 Java 对象和数据库表进行映射，提供了一种方便的方式来进行数据库操作。
MyBatis 是基于 JDBC 的持久层框架，它封装了 JDBC 的操作，简化了数据库访问的过程。
Mybatis 与 JDBC 的关系：
1）SQL 语句处理：JDBC 需要在 Java 代码中编写 SQL 语句并进行参数设置，而 MyBatis 可以通过 XML 或注解的方式配置 SQL 语句，将 SQL 语句与 Java 代码分离，提高了代码的可维护性和可读性。
2）数据库连接管理：JDBC 需要手动管理数据库连接的打开和关闭，而 MyBatis 可以通过配置文件自动管理数据库连接的打开和关闭，减少了开发人员的工作量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14a79ea92ed4e647381c0f977981c792/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b6b0d27170e55f254e5c5a2da1bf265/" rel="bookmark">
			前端框架选择指南：React vs Vue vs Angular
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选择前端框架时，React、Vue 和 Angular 都是流行的选择，各有优缺点。我们可以从各个维度进行比较和选择：
React 核心理念： 组件化开发，专注于视图层。学习曲线： 相对平缓，因为重点在于JSX和组件逻辑。生态系统： 极为丰富，有大量的第三方库和工具。性能： 使用虚拟DOM，优化性能。模板语法： 使用JSX，更接近JavaScript语法。状态管理： 常见的解决方案如Redux、MobX。适合： 中大型项目，特别是已有JavaScript基础的团队。 Vue 核心理念： 更简洁，易于上手，全面的解决方案。学习曲线： 较低，文档详细，易于理解。生态系统： 快速增长，拥有广泛的支持。性能： 使用虚拟DOM和优化策略。模板语法： 有自己的模板系统，易于阅读。状态管理： 内置Vuex，提供完整状态管理。适合： 中小型项目，快速原型和开发，或者需要快速上手的团队。 Angular 核心理念： 全栈框架，提供MVC架构。学习曲线： 较陡峭，因为涵盖更多概念和工具。生态系统： 完整且强大，由Google支持。性能： 使用变更检测，可以配置优化。模板语法： 自己的模板系统，支持双向数据绑定。状态管理： 提供NgRx等库进行状态管理。适合： 大型企业级项目，需要严格结构和规范的团队。 开发效率 React: 需要手动处理状态管理和路由，但有丰富的第三方库可供选择，如Redux、React Router等。Vue: 提供了完整的CLI工具，内置状态管理和路由管理，使得开发更快捷。Angular: 提供完整的解决方案，包括CLI工具，但学习曲线较陡峭。 性能优化 React: 通过虚拟DOM和shouldComponentUpdate、PureComponent等优化性能。Vue: 有类似的优化机制，如组件缓存、计算属性缓存等。Angular: 提供Change Detection策略优化，如OnPush。 社区和生态系统 React: 庞大的社区，大量的开源库，如Material-UI、Ant Design等。Vue: 社区活跃，有许多优秀的UI库，如Element UI、Vuetify等。Angular: 社区相对较小，但由Google支持，有Angular Material等官方UI库。 扩展性和可维护性 React: 组件化设计，易于拆分和复用，但需要良好的架构设计。Vue: 也强调组件化，但更注重开箱即用的完整解决方案，易于维护。Angular: 严格的架构和模块化，适合大型项目，但过度复杂可能导致学习成本增加。 企业支持 React: Facebook的开源项目，广泛应用于各种公司。Vue: 个人项目，但已被许多大公司采用，如阿里巴巴。Angular: Google的产品，常见于企业级应用。 学习曲线 React: 需要理解JSX和React Hooks，但基础JavaScript知识足够。Vue: 简单易学，文档清晰，适合初学者。Angular: 包含更多概念，如依赖注入、指令等，学习曲线较陡。 框架的可移植性 React: 由于其组件化和JSX的灵活性，React组件可以很容易地与其他库和框架集成，如Gatsby、Next.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b6b0d27170e55f254e5c5a2da1bf265/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78c017752056c8b240a5202e6a8857d6/" rel="bookmark">
			两个双指针 的 “他“和“ 她“会相遇么？ —— “双指针“算法 （Java版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇会加入个人的所谓鱼式疯言
❤️❤️❤️鱼式疯言:❤️❤️❤️此疯言非彼疯言
而是理解过并总结出来通俗易懂的大白话,
小编会尽可能的在每个概念后插入鱼式疯言,帮助大家理解的.
🤭🤭🤭可能说的不是那么严谨.但小编初心是能让更多人能接受我们这个概念 ！！！
前言 因为小编最近在学习算法， 每次学习新知识，都会有新的体会和心得，就会和小伙伴们一起分享， 今天 带来我们 算法 首篇 ————“双指针” 算法 💥💥💥
这时就会有小伙伴问了，我们的"双指针"算法 不是在 “题海寻offer” 专题中讲解过么 ？ 为啥还要重复学习呢 🤔 🤔 🤔
是的， 但这次小编带来的是更重点更详细并且更系统以算法的角度一步一步讲解我们的 “双指针” 算法 💖 💖 💖
目录 双指针算法初识
双指针算法的运用
双指针算法的总结
一. 双指针初识 1. 双指针算法的认识 首先小编在这里得区别一个概念
这里我们提及的 双“指针” 的指针 并不是我们学过 C语言 的 定义 int * p = &amp;a 那个指针 ，
这里我们用的指针其实就是一个 变量
我们通过 变量 来指向一个元素 然后不断移动来影响数据的一个单纯的 变量
而 双指针 就是定义两个变量来 影响数据
2. 双指针算法的种类 常见的双指针有两种形式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78c017752056c8b240a5202e6a8857d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e028063732aac5b3167c664fba5d2f3/" rel="bookmark">
			3D透视图模型转模型变形？---模大狮模型网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3D建模是数字艺术和设计领域中的重要技术，它可以为我们带来丰富多彩的视觉体验和创意表达。在本文中，我们将探讨一个引人注目的话题：3D透视图中模型转换是否会导致变形?通过深入探讨这个问题，我们希望能够帮助您更好地理解在3D建模中如何处理透视图中的模型转换，以及如何避免可能出现的变形效果。
一、3D透视图中的模型转换
在3D建模环境中，透视图是一种用于呈现三维场景的技术，它可以使观察者感受到深度和立体感。当我们对透视图中的模型进行转换时，比如平移、旋转或缩放，模型的外观和形状可能会发生变化。这种变化可能会被人们误解为模型的变形效果。
二、如何避免变形效果
为了避免在3D透视图中出现模型的变形效果，我们可以采取一些技巧和方法。首先，确保在进行模型转换之前，模型的比例和比例尺是正确的。这可以通过对模型进行测量和比例调整来实现。其次，合理使用透视摄像机的参数，例如视场角和远近裁剪平面，以保持模型的形状和外观不变。最后，选择合适的转换工具和方式，根据具体情况进行调整，避免过度变形。
三、模型转换的优势和应用
透视图中的模型转换在游戏开发、动画制作和建筑可视化等领域中具有广泛的应用。通过合理和精确地进行模型转换，设计师可以创造出更具吸引力和真实感的场景和动画效果。透视图中的模型转换也可以帮助观众更好地理解和感受虚拟世界，增加沉浸感和交互性。
通过对3D透视图中模型转换是否会导致变形的探讨，我们了解到了一些避免变形效果的方法和技巧，以及3D模型转换在各个领域中的应用和优势。如果您在3D建模项目中需要进行模型转换，不妨尝试以上提到的方法，以确保模型转换的准确性和稳定性，创造出令人惊叹的视觉效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afb06539bdc429a539bf395636a7b415/" rel="bookmark">
			JVM-调优之-高内存占用问题排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排查思路 1）检查jvm内存的分配情况
2）检查jvm的gc情况
3） 找出占用量比较大的对象
第一步：jmap -heap PID 查看jvm内存使用情况
jmap -heap 2525
可以看到老年代年轻代等其他内存区域内存使用率百分比
第二步：jstat -gc PID 查看GC的情况
jstat -gc 2525
jstat -gcutil 2525 1000 1000m打印一次gc情况
YGC : YG GC的次数
YGCT：YG GC的平均时间
FGC： FULL GC的次数
FGCT：FULL GC的平均时间
发现FULL GC的次数在疯狂增长，而且FULL GC的平均时间也会增长，这就是CPU100%的原因，因为CPU一直在尝试垃圾回收
第三步： jmap -histo:live +进程id|more 命令，找出堆中占用量比较大的存活的对象
注意：一般不通过直接采用jmap dump 命令导出系统日志，因为dump操作长时间，很耗cpu资源，一般建议通过 jvm参数配置，在发生oom时，自动dump生成系统jvm快照文件，然后结合mat工具进行分析。
-XX:+HeapDumpOnOutOfMemoryError
#生成堆文件地址： -XX:HeapDumpPath=/home/liuke/jvmlogs/ 其实可以直接生成dump文件，下载下来，到idea中分析：
一般第三步不建议用，直接用第四步
第四步：下载dump文件，分析内存告警
1：找到Java服务： jps 或者 ps -ef | grep java
2：生成dump 文件：jmap -dump:file=/tmp/dump.bin 1
3：压缩dump文件 tar -zcvf dump.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afb06539bdc429a539bf395636a7b415/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6811f5581a230b5327042f25f9125976/" rel="bookmark">
			视频标注已上线，支持视频分类、多目标检测｜ModelWhale 版本更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		春光作序，万物和鸣，ModelWhale 带来新一轮的版本更新，期待为大家带来更优质的使用体验。
本次更新，ModelWhale 正式上线视频标注功能，支持视频分类、多目标检测的标注方法（视频格式：.mp4, .avi）。数据标注可以将“原始数据”处理为“结构化数据”，以便更好应用在数据分析、模型训练等多个场景。
以多目标检测为例：
视频标注时，业务人员在右侧标签栏选择 Label 后，在视频画面中框选想要标记的目标。我们会为已框出的目标自动在后续帧内生成插值，降低人工标注量。同时，也支持用户对自动生成的标注进行手动调整。视频处理上，业务人员还可以通过调整 fps 降低原视频的播放帧率，减少重复帧。 审核通过的标注结果，可以点击「生成数据集」导出为平台数据集，供后续处理使用。结果数据集中：
标注结果与原视频的对应关系可通过“annotation_map.csv”查看；任务所使用的 Label 集记录于“label_map.csv”中；标注结果则以 json 格式记录于“video_name_annotation.json”中。 Tips：ModelWhale 也支持图像标注、文本标注，均支持使用算法模型辅助标注，欢迎体验。
（1）视频标注：多目标检测（团队版✓）
（2）视频标注：视频分类（团队版✓）
除视频标注外，本次更新中 ModelWhale 还进行了下述功能迭代：
新增 支持“模型服务”、“知识库” 发布到门户申请（团队版✓ ）新增 元数据字段格式、选项配置（团队版✓ ）新增 侧边栏模块更名、外链配置（团队版✓ ）优化 分析项目创建（专业版✓ 团队版✓ ）优化 Notebook、Canvas、IDE 新手引导（基础版✓ 专业版✓ 团队版✓ ） 新增 支持 Canvas 内快捷编辑文件（专业版✓ 团队版✓ ） 01 新增 支持“模型服务应用”、“知识库” 发布到门户申请（团队版✓ ） 数据开放、成果共享可以发挥它更大的价值。ModelWhale 提供数据科学研究工具的同时，还为每个团队提供了“独立门户”，作为内容分享窗口，连接外部伙伴。除了管理员可以将组织内的精选内容公开到门户外，现在也支持组织成员自主申请公开，实现门户内容的快速搭建：科研人员根据平台规范完善内容描述，经平台运营管理人员审核申请，即可将将内容发布至平台门户。
下述是个 ModelWhale 模型服务 Demo：
（1）模型服务应用：申请发布到门户 2）知识库：申请发布到门户 02 新增 元数据字段格式、选项配置（团队版✓ ） ModelWhale 提供数据文档描述管理功能，通过元数据对数据的分发、展示、使用进行规范管理。元数据现已支持更多格式，数据作者可以自行选择“选项”或自定义输入“数值”、“日期”、“文本”以更充分、更完善地描述自己的数据资产。
（1）数据文档 （2）字段管理 03 新增 侧边栏模块更名、外链配置（团队版✓ ） 平台众多功能模块均支持由客户自定义其名称，将其修改为更符合自身场景的名词。同时考虑到用户业务流程未必均在 ModelWhale 平台完成，侧边栏现已支持配置“外部链接”，供用户便捷跳转至第三方平台/工具。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6811f5581a230b5327042f25f9125976/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f51d1a797895e1921fbf0936bbbf2e8d/" rel="bookmark">
			第13章 Python建模库介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下内容参考自https://github.com/iamseancheney/python_for_data_analysis_2nd_chinese_version/blob/master/%E7%AC%AC05%E7%AB%A0%20pandas%E5%85%A5%E9%97%A8.md
《利用Python进行数据分析·第2版》
用以学习和记录。
本书中，我已经介绍了Python数据分析的编程基础。因为数据分析师和科学家总是在数据规整和准备上花费大量时间，这本书的重点在于掌握这些功能。
开发模型选用什么库取决于应用本身。许多统计问题可以用简单方法解决，比如普通的最小二乘回归，其它问题可能需要复杂的机器学习方法。幸运的是，Python已经成为了运用这些分析方法的语言之一，因此读完此书，你可以探索许多工具。
本章中，我会回顾一些pandas的特点，在你胶着于pandas数据规整和模型拟合和评分时，它们可能派上用场。然后我会简短介绍两个流行的建模工具，statsmodels和scikit-learn。这二者每个都值得再写一本书，我就不做全面的介绍，而是建议你学习两个项目的线上文档和其它基于Python的数据科学、统计和机器学习的书籍。
pandas与模型代码的接口 模型开发的通常工作流是使用pandas进行数据加载和清洗，然后切换到建模库进行建模。开发模型的重要一环是机器学习中的“特征工程”。它可以描述从原始数据集中提取信息的任何数据转换或分析，这些数据集可能在建模中有用。本书中学习的数据聚合和GroupBy工具常用于特征工程中。
优秀的特征工程超出了本书的范围，我会尽量直白地介绍一些用于数据操作和建模切换的方法。
pandas与其它分析库通常是靠NumPy的数组联系起来的。将DataFrame转换为NumPy数组，可以使用.values属性：
In [10]: import pandas as pd In [11]: import numpy as np In [12]: data = pd.DataFrame({ ....: 'x0': [1, 2, 3, 4, 5], ....: 'x1': [0.01, -0.01, 0.25, -4.1, 0.], ....: 'y': [-1.5, 0., 3.6, 1.3, -2.]}) In [13]: data Out[13]: x0 x1 y 0 1 0.01 -1.5 1 2 -0.01 0.0 2 3 0.25 3.6 3 4 -4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f51d1a797895e1921fbf0936bbbf2e8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d9339a67f65d37854f88420dbc2bbd7/" rel="bookmark">
			【测试SQLite】测试SQLite支持的SQL语句分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试SQLite支持的SQL语句分类 为了全面测试SQLite支持的SQL语句，需要设计一个包含多种类型的表结构，并编写各种SQL语句来测试这些功能。目前按照以下分类进行测试：
数据定义语言（DDL）数据操作语言（DML）数据控制语言（DCL）事务控制语言（TCL）查询语言（QL） 1.表结构设计 我们将创建一个简单的数据库，包含三个表：users、products和orders，以及一个关联表order_items。
-- 创建用户表 CREATE TABLE users ( id INTEGER PRIMARY KEY AUTOINCREMENT, -- 主键，自增长 username TEXT NOT NULL UNIQUE, -- 用户名，不为空且唯一 password TEXT NOT NULL, -- 密码，不为空 email TEXT NOT NULL UNIQUE, -- 电子邮件，不为空且唯一 created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP -- 创建时间，默认为当前时间戳 ); -- 创建产品表 CREATE TABLE products ( id INTEGER PRIMARY KEY AUTOINCREMENT, -- 主键，自增长 name TEXT NOT NULL, -- 产品名称，不为空 description TEXT, -- 产品描述 price REAL NOT NULL, -- 价格，不为空 stock INTEGER NOT NULL, -- 库存，不为空 created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP -- 创建时间，默认为当前时间戳 ); -- 创建订单表 CREATE TABLE orders ( id INTEGER PRIMARY KEY AUTOINCREMENT, -- 主键，自增长 user_id INTEGER NOT NULL, -- 用户ID，不为空 total REAL NOT NULL, -- 总价，不为空 created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- 创建时间，默认为当前时间戳 FOREIGN KEY (user_id) REFERENCES users (id) -- 外键，引用用户表的ID ); -- 创建订单项目表 CREATE TABLE order_items ( order_id INTEGER NOT NULL, -- 订单ID，不为空 product_id INTEGER NOT NULL, -- 产品ID，不为空 quantity INTEGER NOT NULL, -- 数量，不为空 price REAL NOT NULL, -- 价格，不为空 PRIMARY KEY (order_id, product_id), -- 主键，由订单ID和产品ID组成的复合主键 FOREIGN KEY (order_id) REFERENCES orders (id), -- 外键，引用订单表的ID FOREIGN KEY (product_id) REFERENCES products (id) -- 外键，引用产品表的ID ); 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d9339a67f65d37854f88420dbc2bbd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1f6a55546ba960809591977ab7743e1/" rel="bookmark">
			Linux 进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 冯诺依曼体系 操作系统为什么要有操作系统系统调用和库函数概念进程的组成如何理解进程动态运行系统调用接口和用户操作接口 进程PCBPIDPCB和PIDgetpid()getppid()获取父进程pid`fork()` 创建进程父子进程为什么要创建子进程/proc 目录内查看进程文件夹chdir()改变进程的工作目录 进程状态查看进程状态R运行状态S睡眠状态D磁盘休眠状态t状态T停止状态X死亡状态Z僵尸状态危害杀死僵尸进程 孤儿进程杀死进程并发和并行阻塞态挂起态CPU内的寄存器挂起态CPU内的寄存器 冯诺依曼体系 任何计算机系统都包含一个基本的程序集合，称为操作系统(OS)
笼统的理解，操作系统包括：内核（进程管理，内存管理，文件管理，驱动管理）其他程序（例如函数库， shell程序等等） 操作系统 为什么要有操作系统 操作系统对下&lt;手段&gt;进行软硬件管理工作，对上层提供良好（稳定、安全、高效）的运行环境&lt;目的&gt;。
系统调用和库函数概念 在开发角度，操作系统对外会表现为一个整体，但是会暴露自己的部分接口，供上层开发使用，这部分由操作系统提供的接口，叫做系统调用。
系统调用在使用上，功能比较基础，对用户的要求相对也比较高，所以，有心的开发者可以对部分系统调用进行适度封装，从而形成库，有了库，就很有利于更
层用户或者开发者进行二次开发。
进程的组成 一个进程内包括 内核task_struct结构体+程序的代码和数据
如何理解进程动态运行 只要我们的进程task_struct，将来在不同的队列中，进程就可以访问不同的资源
系统调用接口和用户操作接口 系统调用接口是操作系统提供给用户程序的接口，用于请求操作系统内核提供的服务和功能。
用户操作接口是用户程序提供给用户自身或其他用户程序的接口，用于实现用户程序的功能和交互。
进程 PCB 定义：PCB是操作系统中用于管理和维护进程信息的数据结构。每个进程都有对应的 PCB，用于存储进程的状态、优先级、程序计数器、内存分配情况、打开文件列表等信息。作用：PCB用于跟踪和管理进程的运行状态，操作系统通过维护 PCB 来管理进程的调度、资源分配和状态转换。内容：PCB 包含了进程的所有关键信息，如进程标识符（PID）、程序计数器、寄存器状态、内存分配情况、打开文件列表等。存储位置：每个进程的 PCB 存储在操作系统内核的进程表中，操作系统通过访问 PCB 来管理进程。 PID 定义：PID是操作系统中用于标识和区分不同进程的唯一标识符。每个进程都有一个对应的 PID，用于在系统中唯一标识该进程。作用：PID用于操作系统识别和管理不同的进程，通过 PID 可以查找对应进程的 PCB，并对进程进行操作和控制。分配方式：PID 是由操作系统在创建进程时分配的，通常是一个唯一的整数值。使用方式：进程通过 PID 可以获取自身的信息，也可以通过 PID 与其他进程进行通信和协作。 PCB和PID PCB是操作系统中用于管理进程信息的数据结构，包含了进程的所有关键信息。
PID是用于表示不同进程的唯一标识符，用于操作系统识别和管理进程。
getpid() ​ 头文件是unistd.h
#include &lt;iostream&gt; #include &lt;unistd.h&gt; int main() { pid_t pid = getpid(); std::cout &lt;&lt; "PID: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1f6a55546ba960809591977ab7743e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6085c3faccab5d98e5fe2a528b826cea/" rel="bookmark">
			24-LINUX-UDP网络连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一UDP协议特点 TCP 协议提供的是：面向连接、可靠的、字节流服务。使用 TCP 协议通信的双发必须 先建立连接，然后才能开始数据的读写。双方都必须为该连接分配必要的内核资源，以管理 连接的状态和连接上数据的传输。TCP 连接是全双工的，双方的数据可以通过一个连接进行 读写。完成数据交换之后，通信双方都必须断开连接以释放系统资源。 使用 tcpdump 可以抓包观察 TCP 连接的建立与关闭。该命令需要管理员权限，格式如 下(假设两个测试用的主机 IP 地址为 192.168.43.214 和 192.168.43.160 ) ： 三次握手发生在客户端执行 connect()的时候，该方法返回成功，则说明三次握手已建立。 二.编程流程 socket()用来创建套接字，使用 udp 协议时，选择数据报服务 SOCK_DGRAM。sendto() 用来发送数据，由于 UDP 是无连接的，每次发送数据都需要指定对端的地址（IP 和端 口）。recvfrom()接收数据，每次都需要传给该方法一个地址结构来存放发送端的地址。 recvfrom()可以接收所有客户端发送给当前应用程序的数据，并不是只能接收某一个客 户端的数据。 UDP数据报服务中，发送端每一次执行写操作，UDP模块就将其封装成一个UDP数据报并发送，接收端必须及时对每一个数据包进行读操作，否侧就会丢包。如果用户没有足够的缓冲区来读取UDP数据报，数据报会被截断，下一次读取直接读取下一个数据报。 三示例代码 udp_ser.c #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; #include&lt;unistd.h&gt; #include&lt;sys/socket.h&gt; #include&lt;netinet/in.h&gt; #include&lt;arpa/inet.h&gt; int main() { int sockfd = socket(AF_INET,SOCK_DGRAM,0); if(sockfd ==-1) { exit(1); } struct sockaddr_in saddr,caddr; memset(&amp;saddr,0,sizeof(saddr)); saddr.sin_family =AF_INET; saddr.sin_port =htons(6000); saddr.sin_addr.s_addr =inet_addr("127.0.0.1"); int res = bind(sockfd,(struct sockaddr*)&amp;saddr,sizeof(saddr)); if(res == -1) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6085c3faccab5d98e5fe2a528b826cea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89030e3909ff25cba90e1a394c689d92/" rel="bookmark">
			Java多态（如果想知道Java中有关多多态的知识点，那么只看这一篇就足够了！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：多态是面向对象编程中的一个重要概念，它允许我们在不同的对象上调用相同的方法，但根据对象的不同，可以产生不同的行为。在 Java 中，多态性是一个强大的特性，它有助于代码的可扩展性和可维护性。
✨✨✨这里是秋刀鱼不做梦的BLOG
✨✨✨想要了解更多内容可以访问我的主页秋刀鱼不做梦-CSDN博客
先让我们看一下本篇文章的大致内容：
目录
1.向上转型+向下转型
（1）向上转型
（2）向下转型
补充：instanceof
2.方法重写
3.静态绑定+动态绑定
（1）静态绑定
（2）动态绑定
4.多态
为了更好地理解多态，我们需要掌握以下核心概念：（先进行了解即可）
方法重写（Override）： 子类可以提供对父类中已有方法的新实现。在子类中重新定义一个与父类中方法名、参数列表和返回类型相同的方法，从而覆盖（重写）了父类中的方法。
向上转型（Upcasting）： 可以将子类的对象引用赋给父类类型的变量，这被称为向上转型。这样做可以让我们在父类引用上调用子类的方法，从而实现多态性。
动态绑定（Dynamic Binding）： 运行时多态性的关键概念之一。它意味着方法的调用是在程序运行时根据对象的实际类型来确定的，而不是在编译时。
instanceof 运算符： 用于检查一个对象是否是特定类的实例。它可以帮助我们在运行时确定对象的类型，从而进行适当的操作。 为了理解学习多态，让我们先学习一下这些核心知识，接下来我们将一一学习它们。
1.向上转型+向下转型 先来让我们认识一下什么是向上转型和向下转型。
（1）向上转型 向上转型（Upcasting）： 将子类的对象引用赋给父类类型的变量，这被称为向上转型。其作用为可以让我们在父类引用上调用子类的方法，从而实现多态性。
了解完了什么是向上转型之后，让我们看一个向上转型的例子来进一步理解：
//父类Animal class Animal { void makeSound() { System.out.println("The animal makes a sound"); } } //子类Dog class Dog extends Animal { @Override void makeSound() { System.out.println("The dog barks"); } } public class Test { public static void main(String[] args) { // 创建一个Dog对象 Dog myDog = new Dog(); // 向上转型：将Dog对象赋值给Animal引用 Animal myAnimal = myDog; // 这就是向上转型 } } 在这个例子中，我们有一个Animal类和一个Dog类，其中Dog是Animal的子类。在main方法中，我们创建了一个Dog对象，并将其赋值给一个Animal类型的引用myAnimal，这就是向上转型的一个例子。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89030e3909ff25cba90e1a394c689d92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96d58439de32fcb95c812ba4c0ad1f06/" rel="bookmark">
			寻找峰值 ---- 二分查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目链接
题目:
分析:
因为题目中要找的是任意一个峰值即可, 所以和&lt;山脉数组的峰值索引&gt;这道题差不多因为峰值左右都小于峰值, 所以具有"二段性", 可以使用二分查找算法如果nums[mid] &lt; nums[mid + 1], mid一定不是峰值, 所以left = mid + 1如果nums[mid] &gt; nums[mid + 1], mid可能是峰值, 所以right = mid因此匹配二分查找算法的模版二, mid = left +(right - left) /2唯一与&lt;山脉数组的峰值索引&gt;这道题不同的是, &lt;山脉数组的峰值索引&gt;数组中只有一个峰值, 而这道题我们用二分查找找的是最接近中间的峰值, 说明不是只有严格的有序才能用二分查找 代码:
class Solution { public int findPeakElement(int[] nums) { int left = 0; int right = nums.length-1; while(left &lt; right){ int mid = left +(right - left) /2; if(nums[mid] &gt; nums[mid + 1]) right = mid; else left = mid + 1; } return left; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b053d07fda2cd772189426567730da2/" rel="bookmark">
			【JavaWeb】Day83.Maven高级——分模块设计与开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分模块设计与开发 介绍 所谓分模块设计，顾名思义指的就是我们在设计一个 Java 项目的时候，将一个 Java 项目拆分成多个模块进行开发。
1). 未分模块设计的问题
如果项目不分模块，也就意味着所有的业务代码是不是都写在这一个 Java 项目当中。随着这个项目的业务扩张，项目当中的业务功能可能会越来越多。
假如我们开发的是一个大型的电商项目，里面可能就包括了商品模块的功能、搜索模块的功能、购物车模块、订单模块、用户中心等等。这些所有的业务代码我们都在一个 Java 项目当中编写。这个项目组至少几十号甚至几百号开发人员，这些开发人员全部操作这一个 Java 项目。此时大家就会发现我们项目管理和维护起来将会非常的困难。而且假如在我们的项目当中，我们自己定义了一些通用的工具类以及通用的组件，而公司还有其他的项目组，其他项目组也想使用我们所封装的这些组件和工具类，其实是非常不方便的。因为 Java 项目当中包含了当前项目的所有业务代码，所以就造成了这里面所封装的一些组件会难以复用。
总结起来，主要两点问题：不方便项目的维护和管理、项目中的通用组件难以复用
2). 分模块设计
分模块设计我们在进行项目设计阶段，就可以将一个大的项目拆分成若干个模块，每一个模块都是独立的。
比如可以将商品的相关功能放在商品模块当中，搜索的相关业务功能都封装在搜索模块当中。而为了组件的复用，我们也可以将项目当中的实体类、工具类以及我们定义的通用的组件都单独的抽取到一个模块当中。
如果当前这个模块，比如订单模块需要用到这些实体类以及工具类或者这些通用组件，此时直接在订单模块当中引入工具类的坐标就可以了。这样就将一个项目拆分成了若干个模块，这就是分模块设计。
模块设计之后，如果我们需要用到另外一个模块的功能，我们直接依赖模块就可以了。比如商品模块、搜索模块、购物车订单模块都需要依赖于通用组件当中封装的一些工具类，只需要引入通用组件的坐标就可以了。
分模块设计就是将项目按照功能/结构拆分成若干个子模块，方便项目的管理维护、拓展，也方便模块键的相互调用、资源共享。
实践 分模块设计
将pojo包下的实体类，抽取到一个maven模块中 tlias-pojo将utils包下的工具类，抽取到一个maven模块中 tlias-utils其他的业务代码，放在tlias-web-management这个模块中，在该模块中需要用到实体类pojo、工具类utils，直接引入对应的依赖即可。 注意：分模块开发需要先针对模块功能进行设计，再进行编码。不会先将工程开发完毕，然后进行拆分。
实现 1. 创建maven模块 tlias-pojo，存放实体类
A. 创建一个正常的Maven模块，模块名tlias-pojo
B. 然后在tlias-pojo中创建一个包 com.itheima.pojo C. 将项目 tlias-web-management 中的pojo包下的实体类，复制到tlias-pojo模块中
D. 在 tlias-pojo 模块的pom.xml文件中引入依赖
``xml &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;/dependency&gt; &lt;/depend ``xml &lt;dependency&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;tlias-pojo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; 2. 创建Maven模块 tlias-utils，存放相关工具类
A. 创建一个正常的Maven模块，模块名tlias-utils
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b053d07fda2cd772189426567730da2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9c565e566643c89d9a71b3410b724f5/" rel="bookmark">
			现代前端工程化实践：Git、Husky、Commitlint与PNPM的协同作战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 Git Husky 与 Commitlint 是两个在 Git 工作流程中非常实用的工具，它们可以帮助团队维护代码质量和提交规范。Husky 是一个 Git 钩子管理器，允许你在仓库级别方便地配置钩子脚本；而 Commitlint 则是用来规范 Git 提交信息的工具，确保每次提交都遵循一定的格式标准。下面是一个关于如何使用这两个工具的简明教程，以及如何进行基本配置。
使用 Husky 和 Commitlit 的版本 "husky": "^9.0.11", "@commitlint/cli": "^19.3.0", "@commitlint/config-conventional": "^19.2.2", 安装 Husky 和 Commitlint 首先，你需要在项目中安装 Husky 和 Commitlint，以及 Commitlint 的一个预设规则库（如 @commitlint/config-conventional）来定义提交信息的格式规范。
npm install --save-dev husky @commitlint/cli @commitlint/config-conventional 配置 Husky 接下来，配置 Husky 以便在 git commit 命令执行前自动运行 Commitlint 检查。
init 命令简化了项目中的 husky 设置。它会在 .husky/ 中创建 pre-commit 脚本，并更新 package.json 中的 prepare 脚本。随后可根据你的工作流进行修改。
pnpm exec husky init 执行后的效果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9c565e566643c89d9a71b3410b724f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec72d79da53985df989eb2a251804bc6/" rel="bookmark">
			【OpenCV】图形绘制与填充
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍了绘制、填充图像的API。也介绍了RNG类用来生成随机数。相关API：
line()
rectangle()
circle()
ellipse()
putText()
代码：
#include "iostream" #include "opencv2/opencv.hpp" using namespace std; using namespace cv; int main(int argc, char *argv) { //【画布（图片）、窗口创建】 Mat canvas = Mat::zeros(Size(512, 512), CV_8UC3); namedWindow("canvas", WINDOW_AUTOSIZE); //【相关绘制API]】 //线段 line(canvas, Point(10, 10), Point(400, 400), Scalar(0, 255, 255), 1, LINE_8);	//API（画布，点，点，色彩，线粗，渲染方式），渲染方式是枚举值，LINE_AA可以实现抗锯齿效果。 //矩形 Rect rect(100, 100, 200, 200);	//（起始点位置，宽高）宽高不可为负值 rectangle(canvas, rect, Scalar(255, 0, 0), 1, LINE_8);	//API //圆形 circle(canvas, Point(256, 256), 100, Scalar(0, 255, 0), 1, 8);	//API(画布，圆心，半径，色彩，线粗，渲染方式) //椭圆 RotatedRect rrt;	//通过这个对象设置一些矩形数据 rrt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec72d79da53985df989eb2a251804bc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3a0cdb3f4e00a1ba1508cd35fd0263e/" rel="bookmark">
			《MySQL怎样运行的》-从一条记录说起-InnoDB记录存储结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们都知道MySQL是用来存储数据的，那你有没有的疑问，他是怎么存储的，它实际上是在使用储存引擎，那如果有人问你MySQL的储存引擎有哪些你该怎么说呢，主要是有InnoDB，MyISAM还有MEMORY，后面两种在这里没有过多叙述，我们就来细说一下InnoDB这个储存引擎，我们知道数据存储在硬盘和磁盘里，如果我们想要在数据库里面拿出来，那我们还需不需要和云盘和磁盘打交道，但是这样太慢了，所以InnoDB就创建了页，将数据划分为若干个页，用页来磁盘与内存之间交互的基本单位。页的大小一般为16kb。
InnoDB行列式 他有很多种格式，COMPACT，REDUNDANT，DYNAMIC，COMPRESSED
我们今天来详细说一种COMPACT格式，虽然说各有不同，但是在原理上是大致相同的
上图就是COMPACT格式，他有变长字段长度列表，NULL值列表，记录头信息，还有记录的真实数据
1.记录的额外信息 也就是变长字段长度列表，和NULL值列表，记录头信息
变长字段长度列表 我们知道在MySQL中存在一些能够变长的数据类型，比如VARCHAR(),VARBINARY()等等，我们把拥有这些数据类型的列称之为变长字段。但是这些数据类型的字节数是不固定的，所以变长字段要存储的字节数也是不确定的，所以我们在这个变长字段长度列表中，还要存储这些数据类型的字节数，以防止突如其来的东西把MySQL给搞蒙
所以我们要存储两种东西
a.是真正的数据内容
b.是该数据所占据的字节数
另外该数据所占据的字节数是存放在变长字段长度列表的头部，各变长字段的真是数据的字节数排放的顺序是按逆序排放，逆序排放，逆序排放，重要的事情说三遍~
另外我其实还有个疑问就是，在这个变长字段长度列表中用多少字节来记录这些数据所占据的字节数？
其实是1字节或者2字节~ 听我给你解释~
下面我们需要用几个字母来表示含义W，M，L：
1.我们字符集用来表示一个字符需要的字节为W
2.我们在VARCHAR()最多存储的字符一共有M个，所有字节数为W*M
3.但是实际上存储的字符串是L个字节
如果W*M&lt;=255，则用一个字节来表示
若W*M&gt;255分为两种情况
L&lt;=127则用1个字节
L&gt;127则用2个字节
NULL值列表 对于这个部分，大家可能看见就知道他是用来干啥的，其实就是存放NULL的列
但是这个地方也是有些同学的难点所在~
其实就是在存放NULL值是是会有一个二进制位的值
如果该值位1是，就代表该列的值为NULL
如果该值为0是，就代表该列的值不为NULL
占1个字节，但是当表中的所有列都定义为NOT NULL时就会没有NULL值列表，会节省1个字节空间
记录头信息 它是由固定的五个字节组成的，40个二进制位，不同的位有不同的意义
这一部分说实话有点多，说几个比较重要的
delete_mask: 删除标志位，很重要。若此标志位为1，代表这条记录已经被删除了。min_mask: B+树非叶子节点中，索引记录的中最小记录。后面讲到索引的时候再说。n_owned: 分组里面包含的记录总数，分组后面再说。heap_no: 后面再说。record_type: 很重要，记录的类型（0-普通用户记录，1-索引记录，2-Infimum, 3-Supremum）next_record: 指针，指向下一条记录，很重要。 然后就是
MySQL为每个记录默认添加的列 row_id：这个列并不是必备的，占用空间为6个字节，行ID，唯一标识一条记录
trx_id：这个列是必备的，占用空间为6个字节，事务ID
roll_pointer：这个列是必备的，占用空间为7个字节，回滚指针
这就是这一章的内容并不是很难，下一个我们来说一下第五章InnoDB数据页结构~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fa6ff9fc5ac9b156499520a553b4375/" rel="bookmark">
			字节携港大南大升级 LLaVA-NeXT：借 LLaMA-3 和 Qwen-1.5 脱胎换骨，轻松追平 GPT-4V
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文 | 王启隆
出品 | 《新程序员》编辑部
2023 年，威斯康星大学麦迪逊分校、微软研究院和哥伦比亚大学的研究人员共同开发的 LLaVA 首次亮相，彼时它被视为一个端到端训练的大型多模态模型，展现了在视觉与语言融合领域的潜力。今年 1 月 30 日，LLaVA 的后续版本 LLaVA-NeXT 推出，它利用了当时最强的 LLM——Yi-34B，进一步增强了多模态理解、OCR（光学字符识别）和世界知识等方面的能力，甚至在一些基准测试上与 Gemini-Pro 和 GPT-V 相媲美。
在全世界默默等待 GPT-5 消息的这几个月里，开源社区出现了 LLaMA-3 和 Qwen-1.5 等语言能力更为强大的模型，阿里的 Qwen 更是在昨天发布了 2.5 版本，剑指 GPT-4。因此，LLaVA-NeXT 的研究团队开始思考一个问题：随着新型强力语言模型的诞生，开源 LLM 和私有 LLM 之间的性能差距正在缩小。当这些更强大的 LLM 被用于增强多模态模型时，是否也会促成开源多模态模型与私有多模态模型之间差距的缩小？
思来想去不如直接动手，LLaVA-NeXT 今日正式升级，研究团队直接用上了 LLaMA-3（8B）和 Qwen-1.5（72B &amp; 110B）为 LLaVA-NeXT 提升多模态能力，最大可达模型规模的 3 倍。这使得多模态模型能够展示从 LLM 继承的更好的视觉世界知识和逻辑推理能力。
代码链接：https://github.com/LLaVA-VL/LLaVA-NeXT
此外，新版本的 LLaVA-NeXT 针对更丰富的现实场景优化视觉对话功能，满足多样应用需求。为了检验在复杂环境下的多模态能力进步，作者们搜集并开发了新评估数据集 LLaVA-Bench（Wilder），它承袭了 LLaVA-Bench (in-the-wild) 的精神，深入探究日常生活中的视觉对话，并大幅增加了数据量以进行全面评估。
开源数据集链接：https://huggingface.co/datasets/liuhaotian/llava-bench-in-the-wild
为清晰体现“换了个 LLM”对多模态性能提升的贡献，本次升级沿用了 LLaVA-NeXT 的原训练方案，保持了该系列模型的简约设计和数据利用效率。最大的 1100 亿参数版本仅需在 128 台 H800 服务器上运行 18 小时即可完成训练。目前最新版 LLaVA-NeXT 的代码、数据和模型都将向公众开放。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fa6ff9fc5ac9b156499520a553b4375/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3e01fd8c7aa837c20ef4ecef6a9f1b3/" rel="bookmark">
			【Rust】——使用线程同时运行代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💻博主现有专栏：
C51单片机（STC89C516），c语言，c++，离散数学，算法设计与分析，数据结构，Python，Java基础，MySQL，linux，基于HTML5的网页设计及应用，Rust（官方文档重点总结），jQuery，前端vue.js，Javaweb开发，Python机器学习等
🥏主页链接：
Y小夜-CSDN博客
目录
🎯使用soawn创建新线程
🎯使用join等待所有线程结束
🎯将move闭包与线程一同使用
在大部分现代操作系统中，已执行程序的代码在一个 进程（process）中运行，操作系统则会负责管理多个进程。在程序内部，也可以拥有多个同时运行的独立部分。这些运行这些独立部分的功能被称为 线程（threads）。例如，web 服务器可以有多个线程以便可以同时响应多个请求。
将程序中的计算拆分进多个线程可以改善性能，因为程序可以同时进行多个任务，不过这也会增加复杂性。因为线程是同时运行的，所以无法预先保证不同线程中的代码的执行顺序。这会导致诸如此类的问题：
竞态条件（Race conditions），多个线程以不一致的顺序访问数据或资源死锁（Deadlocks），两个线程相互等待对方，这会阻止两者继续运行只会发生在特定情况且难以稳定重现和修复的 bug Rust 尝试减轻使用线程的负面影响。不过在多线程上下文中编程仍需格外小心，同时其所要求的代码结构也不同于运行于单线程的程序。
编程语言有一些不同的方法来实现线程，而且很多操作系统提供了创建新线程的 API。Rust 标准库使用 1:1 线程实现，这代表程序的每一个语言级线程使用一个系统线程。有一些 crate 实现了其他有着不同于 1:1 模型取舍的线程模型。
🎯使用soawn创建新线程 为了创建一个新线程，需要调用 thread::spawn 函数并传递一个闭包，并在其中包含希望在新线程运行的代码。示例 16-1 中的例子在主线程打印了一些文本而另一些文本则由新线程打印：
use std::thread; use std::time::Duration; fn main() { thread::spawn(|| { for i in 1..10 { println!("hi number {} from the spawned thread!", i); thread::sleep(Duration::from_millis(1)); } }); for i in 1..5 { println!("hi number {} from the main thread!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3e01fd8c7aa837c20ef4ecef6a9f1b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b7f8fd0dd55227fa58f88ba6804cb8f/" rel="bookmark">
			山脉数组的峰顶索引 ---- 二分查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接
题目:
分析:
我们很明显, 可以从峰值位置将数组分成两段, 具有"二段性", 所以可以用二分查找因为arr是山峰数组, 不存在相等的情况如果arr[mid] &gt; arr[mid + 1], 说明mid的位置可能是峰值, 移动right = mid如果arr[mid] &lt; arr[mid + 1], 说明mid的位置一定不是峰值, 移动left = mid + 1所以可以匹配二分查找中的模版二, 此时,mid = left + (right - left) /2因为没有等于的情况, 所以模版三也适用:如果arr[mid] &gt; arr[mid - 1], 说明mid的位置可能是峰值, 移动left = mid如果arr[mid] &lt; arr[mid - 1], 说明mid的位置一定不是峰值, 移动right = mid - 1所以可以匹配二分查找中的模版三, 此时,mid = left + (right - left + 1) /2 代码:
class Solution { public int peakIndexInMountainArray(int[] arr) { int left = 1; int right = arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b7f8fd0dd55227fa58f88ba6804cb8f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/11/">«</a>
	<span class="pagination__item pagination__item--current">12/71</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/13/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>