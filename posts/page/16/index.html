<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10de4526aafbfefcbf36f123b3d0d4bb/" rel="bookmark">
			【数据结构】双向循环链表专题解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现自己既定的目标，必须能耐得住寂寞单干。💓💓💓
目录
•✨说在前面
🍋知识点一：双向链表的结构
• 🌰1."哨兵位"节点
• 🌰2.双向带头循环链表的结构
🍋知识点二：双向带头循环链表
• 🌰1. 动态申请节点 • 🌰2. 双向链表的初始化
• 🌰3. 双向链表元素的打印
• 🌰4. 双向链表头部插入数据
• 🌰5. 双向链表尾部插入数据
• 🌰6. 指定位置pos之后插入数据
• 🌰7.双向链表头部删除元素
• 🌰8.双向链表尾部删除元素
• 🌰9.删除指定位置pos节点
• 🌰10.双向链表的查找
• 🌰10.双向链表的销毁
• ✨SumUp结语
•✨说在前面 亲爱的读者们大家好！💖💖💖，我们又见面了，之前我们学习了顺序表后，又紧接着给大家讲解了链表中最典型的单向不循环链表，也是最常用的一种。但正所谓我们学习应该面面俱到，有了之前的学习基础，再学习双向链表实际上是非常简单的。
如果你没有准备好的话，可以再复习一下单链表以及单链表相关LeetCode的OJ题。
👇👇👇
💘💘💘知识连线时刻（直接点击即可）
🎉🎉🎉复习回顾🎉🎉🎉
【数据结构】单链表专题详细分析
博主主页传送门：愿天垂怜的博客
🍋知识点一：双向链表的结构 • 🌰1."哨兵位"节点 哨兵位指的是链表中指向链表第一个节点的节点，哨兵位不存储任何有效元素，只是在那里放哨的，顾称为哨兵位节点。
注意：
这里的"带头"跟前面我们说的"链表中的第一个有效节点"是两个概念，实际单链表的头结点不是第一个有效节点，而是哨兵位节点。
"哨兵位"存在的意义：
遍历循环链表避免死循环。
具体带头比不带头有什么优势可以看我上一篇文章中的合并有序链表。
LeetCode/NowCoder-链表经典算法OJ练习1
• 🌰2.双向带头循环链表的结构 结构如下：
由于"哨兵位"节点的存在，我们再实现这样的链表时可以省去一些内容：
🎉插入操作时，不需要检查是否在头部插入，因为哨兵节点作为头结点，总是存在。
🎉删除操作时，不需要处理删除的是否是头节点的情况，因为哨兵节点不会被删除。
🎉简化了代码，因为不需要为头节点和普通节点编写不同的处理逻辑。
类比单链表的结构，可以定义出节点数据为整型的双向带头循环链表节点：
typedef int LTDataType; typedef struct ListNode { LTDataType data; struct ListNode* prev;//指向前一个节点 struct ListNode* next;//指向后一个节点 }LTNode; 🍋知识点二：双向带头循环链表 • 🌰1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10de4526aafbfefcbf36f123b3d0d4bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f958eb286cc11e0ce5b32dab61e86f6/" rel="bookmark">
			Android 5.0 ~ 14访问Android/data(obb)目录的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知，安卓每次出新版本的时候都会收紧权限，存储权限也不例外。虽说官方的意思是为了保护隐私安全，但这些改动着实令开发者和用户感到头疼，尤其是Android/data、Android/obb目录的访问。毕竟用户更难操作，开发者也要费力适配。那么今天就来探索下怎么适配这些变更点吧。
不同安卓版本存储权限差异 1、Android 6.0 之前 应用只需要在 AndroidManifest.xml 下声明以下权限即可自动获取存储权限： &lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; 2、Android 6.0 起 从Android 6.0开始，除了以上操作以外，还需要在代码中动态申请权限。
// 检查是否有存储权限 boolean granted = context.checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED; // 在activity中请求存储权限 requestPermissions(new String[] { Manifest.permission.WRITE_EXTERNAL_STORAGE }, 0); 3、Android 10 Android 10 开始引入了沙盒机制，应用在 sdcard 中默认只能读写私有目录（即/sdcard/Android/data/[应用包名]/），其他目录即便执行前面的操作也无法读写。除非在 AndroidManifest.xml 下声明以下属性：
&lt;application ... android:requestLegacyExternalStorage="true"&gt; 这样的话就会暂时停用沙盒机制，正常读写/sdcard下文件。
4、Android 11 Android 11开始，且应用的目标版本在30及以上，以上的操作也无法再读写sdcard目录。需要声明以下权限：
&lt;uses-permission android:name="android.permission.MANAGE_EXTERNAL_STORAGE" /&gt; 再动态申请权限：
// 检查是否有存储权限 boolean granted = Environment.isExternalStorageManager(); // 在activity中请求存储权限 Intent intent = new Intent(Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f958eb286cc11e0ce5b32dab61e86f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16826c97b47e4f5a24c0b66b629f9c86/" rel="bookmark">
			[JAVASE] 类和对象(二) -- 封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 封装
1.1 面向对象的三大法宝
1.2 封装的基本定义与实现
二. 包
2.1 包的定义
2.2 包的作用
2.3 包的使用 2.3.1 导入类
2.3.2 导入静态方法
三. static 关键字 (重要)
3.1 static 的使用 (代码例子)
3.1.1
3.1.2 3.1.3 3.1.4 四. 总结 一. 封装 1.1 面向对象的三大法宝 1.2 封装的基本定义与实现 封装: 将类内部的实现细节隐藏起来, 对外提供一些公开的接口.
封装是通过 private 权限修饰符 来实现的.
private修饰的成员只能在当前类中被访问.
代码实现:
二. 包 2.1 包的定义 包(package) 就是文件夹, 一个个类就是文件
2.2 包的作用 a. 更好的管理,组织类
b. 避免类名重复
2.3 包的使用 2.3.1 导入类 * 是通配符.
2.3.2 导入静态方法 三.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16826c97b47e4f5a24c0b66b629f9c86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cd18245b38acb4398c5f4adde6234ac/" rel="bookmark">
			[JAVASE] 类和对象(一) - 类和对象的基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.类的基本定义
1.1 类与对象
1.2 类的定义
二. 类的实例化
2.1 创建引用
三. 类中成员的访问
3.1 基本实现
3.2 this引用
四. 构造与初始化
4.1 初始化
4.2 构造方法
五. 总结
一.类的基本定义 1.1 类与对象 类对应着对象 1.2 类的定义 二. 类的实例化 2.1 创建引用 stu1: 指向对象的引用
new: 关键字,在堆中开辟空间
Student(): 调用Student类的构造方法,初始化成员变量
三. 类中成员的访问 3.1 基本实现 类中成员的访问通过 . 号来实现
3.2 this引用 this引用: 代表的是当前对象的引用
在传参时,作为第一个隐藏的参数传递 四. 构造与初始化 4.1 初始化 初始化的是成员变量
4.2 构造方法 构造方法也是用来初始化成员变量的
构造方法可以发生重载
五. 总结 1. 类的基本定义和实例化
2. 访问类中的成员
3. 类中成员变量的初始化
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/133ccca38dbb70ba8de7d76ef6d3b640/" rel="bookmark">
			HiveSQL题——炸裂函数(explode/posexplode)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、炸裂函数的知识点
1.1 炸裂函数
explode posexplode
1.2 lateral view 侧写视图
二、实际案例
2.1 每个学生及其成绩
0 问题描述
1 数据准备
2 数据分析
3 小结
2.2 日期交叉问题
0 问题描述
1 数据准备
2 数据分析
3 小结
2.3 用户消费金额
0 问题描述
1 数据准备
2 数据分析
3 小结
一、炸裂函数的知识点 炸裂函数（一行变多行）本质属于UDTF函数（接收一行数据，输出一行或者多行数据）。
1.1 炸裂函数 explode (1)explode(array&lt;T&gt; a) --&gt; explode针对数组进行炸裂 语法：lateral view explode(split(a,',')) tmp as new_column 返回值：string 说明:按照分隔符切割字符串，并将数组中内容炸裂成多行字符串 举例：select student_score from test lateral view explode(split(student_score,',')) tmp as item; 输出结果为： student_score item [a,b,c] =&gt; a b c (2)explode(map&lt;k,v&gt; m) --&gt; explode针对map键值对进行炸裂 举例：select explode(map('a',1,'b',2,'c',3)) as (key,value); 输出结果为： 得到 key value {a:1,b:2,c:3} =&gt; a 1 b 2 c 3 posexplode posexplode和explode之间的区别：posexplode除了返回数据，还会返回该值的下角标。 (1)posexplode(array&lt;T&gt; a) 语法：lateral view posexploed(split(a,',')) tmp as pos,item 返回值：string 说明:按照分隔符切割字符串，并将数组中内容炸裂成多行字符串(炸裂具备下角标 0,1,2,3) 举例1：select posexplode (array('a','b','c')) as pos,item; 输出结果为： pos item [a,b,c] =&gt; 0 a 1 b 2 c --------------------------------- 举例2：对student_name进行炸裂，同时也对student_score进行炸裂，且需要保证炸裂后，学生和成绩一一对应，不能错乱。 lateral view posexplode(split(student_name,',')) tmp1 as student_name_index,student_name lateral view posexplode(split(student_score,',')) tmp2 as student_score_index,student_score where student_name_index = student_score_index; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/133ccca38dbb70ba8de7d76ef6d3b640/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfe48ca4aeb35797a06dc0f787da2158/" rel="bookmark">
			【Golang】gopsutil包常用监控资源信息API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Golang】gopsutil包常用监控资源信息API 大家好 我是寸铁👊
总结了一篇【Golang】gopsutil包常用监控资源信息API✨
喜欢的小伙伴可以点点关注 💝
前言 本文涵盖了最常用的系统资源监控函数，可以直接拿函数进行调用，非常方便
先安装gopsutil包 go get -u `github.com/shirou/gopsutil` 或者导入后用go mod引入 go mod tidy CPU 获取Cpu相关的全部信息 // 获取Cpu相关的全部信息 func getCpuAllInfo() { cpuInfo, _ := cpu.Info() fmt.Println("返回cpu的具体信息:", cpuInfo) } 返回cpu执行不同操作所花费的时间 // 返回cpu执行不同操作所花费的时间 func getCpuCountsTimes() { cpuCounts, _ := cpu.Times(false) fmt.Println("返回cpu执行不同操作所花费的时间 工作种类:", cpuCounts) //TimesStat 包含 CPU 执行不同操作所花费的时间 工作种类。时间单位以秒为单位。它基于 linux /proc/stat 文件。 } 返回CPU的使用率 // 返回CPU的使用率 func getCpuPercent() { cpuPercent, _ := cpu.Percent(time.Second, false) fmt.Println("返回cpu的使用率:", cpuPercent) } 内存 获取物理内存和交换区内存信息 // 获取物理内存和交换区内存信息 func getVirtualMemory() { m1, _ := mem.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfe48ca4aeb35797a06dc0f787da2158/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0c0708480da7ce6420d7c43888e0601/" rel="bookmark">
			【Java笔记】第6章：数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言1. 数组概括2. 数组的内存3. 数组扩容4. 二维数组5. 数组的排序结语 #include&lt;GUIQU.h&gt;
int main {
上期回顾:【Java笔记】第5章：函数
个人主页：C_GUIQU
归属专栏：【Java学习】
return 一键三连;
}
前言 各位小伙伴大家好！上期小编给大家讲解了Java中的函数，接下来讲讲数组！
1. 数组概括 在Java中，数组是一种用于存储多个相同类型数据的集合。数组在内存中占据连续的空间，每个元素都可以通过索引来访问。
【数组的概念】
索引（或下标）：Java中的数组索引从0开始，这意味着第一个元素的索引是0，第二个元素的索引是1，依此类推。长度：数组的长度是数组中元素的数量，这个信息可以通过数组的length属性获得。元素：数组中的单个数据项称为元素，每个元素都可以通过其索引来访问。多维数组：Java支持多维数组，即数组的数组。例如，一个二维数组可以看作是一行行的数组。 【数组的性质】
类型安全：Java数组是类型安全的，这意味着一个数组只能包含特定类型的元素。例如，一个int类型的数组只能包含int类型的元素。固定长度：在Java中，一旦数组被创建，其长度就固定不变。如果需要改变数组的长度，必须创建一个新的数组并将原数组的内容复制过去。连续内存分配：Java数组中的所有元素都存储在连续的内存块中，这有助于提高访问效率。默认初始化：Java中的数组在创建时会自动初始化。例如，整型数组默认初始化为0，对象数组默认初始化为null。遍历和访问：可以使用for循环、while循环或do-while循环遍历数组元素。也可以通过索引直接访问数组中的特定元素。 【创建数组】
在Java中，可以使用以下方式创建数组：
// 创建一个包含10个整数的数组 int[] numbers = new int[10]; // 创建一个并初始化一个字符串数组 String[] names = {"Alice", "Bob", "Charlie"}; // 创建一个二维数组 int[][] matrix = new int[3][4]; 【访问和修改数组元素】
// 访问第一个元素 int firstElement = numbers[0]; // 修改第三个元素 numbers[2] = 50; // 输出数组长度 System.out.println("数组长度：" + numbers.length); 【 数组操作】
Java提供了Arrays类，该类包含了许多用于操作数组的静态方法，如排序、搜索、填充和复制等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0c0708480da7ce6420d7c43888e0601/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f6b0c6cd9d2345a14edb03cae0c40b1/" rel="bookmark">
			C#结合JS实现HtmlTable动态添加行并保存到数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
需求
效果视频演示
范例运行环境
准备数据源
数据表设计
UI及表结构Json配置
Json数据包提交配置
设计实现
前端UI
Javascript 脚本
Jquery引用
C# 服务端操作 小结
需求 在 Web 应用项目中，实现一对多录入的数据管理功能是一项常见的应用。因此可以实现一个相对轻量化的设计实现表格的录入，为保证功能的可用性、界面友好性，总体的需求如下：
1、数据网格可以动态的添加行，行可以提供输入框、选择框的控件进行录入。
2、数据网格可以删除选中的行。
3、数据网格可以上下移动选中的行重新进行排序。
4、可以实现数据的有效性验证功能（如必填写、位数限制、类型限制等）。
5、需要对输入的文字过滤和屏蔽HTML标记等危险内容。
6、添加新行前判断已有行的有效性，对于未校验通过的暂不允许添加新行。
7、对于修改中的、保存时的、保存后的状态有一定的相关提示信息。
8、数据保存实现动态无刷新。
效果视频演示 为实现需求会使用到用C# 编写服务端Web 静态方法，Jquery 实现 Ajax 无刷新技术并调用服务器方法，Json 存储数据表格需要的配置，客户端大部分设计使用 Javascript 实现。实现的效果演示视频如下：
动态添加 HtmlTable 行并保存到数据库
范例运行环境 操作系统： Windows Server 2019 DataCenter
数据库：Microsoft SQL Server 2016
.net版本： .netFramework4.0 或以上
开发工具及相关技术：VS2019 C# 、Jquery 、Json、Javascript
准备数据源 数据表设计 我们在 MS SQL Server 创建 att_jypx（教育培训经历表），其结构如下表：
序号字段名类型说明1ciduniqueidentifier行唯一标识，唯一键2xmbhvarchar(20)外键父项，指项目编号3sfzhnvarchar(18)外键父项，指身份证号4nf1nvarchar(4)起始年份5yf1nvarchar(2)起始月份6nf2nvarchar(4)截止年份7yf2nvarchar(2)截止月份8xxmcnvarchar(100)学校名称9zynvarchar(50)所学专业10xlnvarchar(10)学历11byzlbnvarchar(50)毕业证类别12xhint排序号 执行如下 创建表的 SQL 语句：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f6b0c6cd9d2345a14edb03cae0c40b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f240cdcc95c62cf70f6549302c87f3cf/" rel="bookmark">
			计算机网络学习小结_概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机网络的作用 21世纪特点：数字化，网络化，信息化。其中网络指三个网络：电信网络、有线电视网络和计算机网络，其中计算机网络发展比较快。随着技术发展，出现了电信网络和有线电视网络融入计算机网络的技术，使三种网络可以融合。上个世纪90年代以来，以因特网为代表的计算机网络技术得到了飞速发展，已从最开始的教育网络演变为商业网络
计算机向用户提供最重要两个功能：1连通性 2共享
因特网概述 网络的网络 因特网起源于美国，现已发展为世界最大的国际性计算机互联网
网络概念：由若干节点和连接节点之间的链路组成。节点可以是计算机，集线器，交换机或路由器等。网络的网络也可以通过路由器连接起来，因此互联网是网络的网络，网络把许多计算机连接在一起，因特网把许多网络连接在一起
因特网发展三个阶段 第一阶段：从单个网络ARPANET向互联网发展的阶段。
第二阶段：构成了三级结构的因特网。NSFNET是一个三级网络：主干网，地区网，校园网（或企业网），网络使用量急剧扩大，政府机构无力维持其运转，转交私人机构运作，同时开始收费
第三阶段：形成多层次的ISP结构的因特网。NSFNET逐渐被若干商用因特网主干网替代，政府机构不在负责因特网运营。此时提供因特网的运营商叫ISP（Internet Service Provider），比如移动，联通，电信是我国的ISP
ISP可以从因特网管理机构申请到很多IP地址
ISP分类：根据ISP大小和量级可分为：主干ISP（专门大公司），地区ISP，本地ISP（本地因特网服务公司或企业或大学等）
IXP：Internet Exchange Point，因特网交换局点。主机之间通信最早通过ISP转发，但ISP也是一个网络，流量大时会有时间和流量开销，IXP作用是直接让两个主机相连，不需要第三个网络进行转发。有了IXP后，主机间通信不需要经过上层ISP，直接在主机间的高速链路传递就行
因特网标准化工作 因特网协会：ISOC，Internet Society，因特网在1992美国不管理后，由该组织进行替代的全面管理，ISOC下有一个组织叫IAB
因特网体系结构委员会：IAB，Internet Architecture Board，负责管理因特网所有协议开发，其下又有两个工程部：IETF（因特网工程部），IRTF（因特网研究部）
因特网工程部：IETF，Internet Engineering Task Force，主要进行协议的开发和标准化
因特网研究部：IRTF，Internet Research Task Force，主要对一些协议进行研究和探索
RFC：是因特网发布的一种形式，翻译过来叫请求评论，Request For Comments，当旧的RFC更新成新的RFC时，其RFC编号也会更新，同时旧的RFC编号废弃
因特网协议指定经历4个阶段：因特网草案（还不是RFC文档）、建议标准（此阶段开始就变为RFC文档，只有到了建议标准阶段，才可以以RFC形式发布）、草案标准、因特网标准
因特网组成 组成：边缘部分（用户直接接触和使用）和核心部分（由大量路由器和网络连接边缘部分组成）
因特网边缘部分 网络边缘主机间通信一般可分为客户端-服务端方式（C/S)和对等方式（P2P）
CS 对等连接P2P 和cs相比，对等连接的双方不区分谁是client谁是server，既可以充当client也可以充当server
因特网核心部分 网络中一种主要作用的东西是路由器，功能是实现分组交换
电路交换 老式有线电话即用了电路交换，其过程可分为：请求连接（物理链路动态分配）-&gt; 通话 -&gt; 释放连接
在通话期间，呼叫方和被呼叫方完全占用分配的物理链路资源。当电路交换交换计算机数据时，效率较低，因为完全占用物理资源和请求通话会消耗大量资源，占用期间别人无法使用占用的物理资源
分组交换 以报文格式传输数据，通过主机和交换机传输，相比于电路交换，省去了请求和释放连接的开销，不完全占用链路，只占用其在路由器传输时的最短一条的部分资源，整块数据被分为若干个报文，分组交换传输是以报文为最小单位
报文交换 和分组交换类似，只是以整个报文为单位收发。由于路由器完整接受报文后才开始报文转发，相比于分组交换耗时些
计算机网络性能 性能指标 速率 带宽 原指某个信号具有的频率带宽，单位为hz，计算机网络中带宽指同心县率最大传输数据能力，单位和速率一致
吞吐量 某个时间范围内传输的数据量
时延 发送时延 也叫传输时延，主机从开始发数据到数据发送完的时间
传播时延 数据在链路上传输的耗时
处理时延 排队时延 时延带宽积 链路容纳的数据量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f240cdcc95c62cf70f6549302c87f3cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c75c2c97bec00f7d935b95e8c7cb8390/" rel="bookmark">
			【面试干货】DFS、BFS 算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【面试干货】DFS、BFS 算法 1、实现思想2、代码实现 💖The Begin💖点点关注，收藏不迷路💖 1、实现思想 通过递归或队列方式依次访问图中的节点，并使用辅助数组记录已访问节点，以实现遍历整个图的目的。实现深度优先搜索和广度优先搜索两种遍历算法。
DFS通过递归地深入图中的每个分支，直到无法再继续深入为止，然后回溯到上一个分支；
而BFS则通过逐层访问图中的节点，从起始节点开始向外扩展，直到访问到所有可达节点。
在实现中，DFS使用递归方式遍历节点，而BFS则利用队列实现节点的逐层访问。通过辅助数组记录已经访问的节点，避免重复访问，并最终完成整个图的遍历。
2、代码实现 package csdn; public class GraphTraversal { // 定义类GraphTraversal static int[][] graph = new int[][]{{0, 1, 1, 0, 0, 0}, // 定义邻接矩阵表示的图，每行代表一个顶点的相邻顶点情况 {0, 0, 0, 1, 0, 0}, {0, 0, 0, 1, 1, 0}, {0, 0, 0, 0, 0, 1}, {0, 0, 0, 0, 0, 1}, {0, 0, 0, 0, 0, 0}}; static int[] help = new int[graph.length]; // 用来记录已经遍历过的元素 // DFS(深度优先遍历) public static void dfsTraversing(int node, int[][] graph) { // 定义DFS遍历方法，参数为起始节点和图的邻接矩阵 help[node] = 1; // 标记当前节点已经遍历过 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c75c2c97bec00f7d935b95e8c7cb8390/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9239cf1ae45cacbdceeac96ccf1e630/" rel="bookmark">
			【设计模式】JAVA Design Patterns——Arrange/Act/Assert（安排/执行/断言模式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔍目的 安排/执行/断言（AAA）是组织单元测试的一种模式。
将测试分为三个步骤：
安排：执行测试所需的设置和初始化。执行：采取测试所需的行动。断言：验证测试结果。 🔍解释 这种模式有几个明显的好处。 它在测试的设置，操作和结果之间建立了清晰的分隔。 这种结构使代码更易于阅读和理解。 如果按顺序排列步骤并格式化代码以将它们分开，则可以扫描测试并快速了解其功能。
当您编写测试时，它还会强制执行一定程度的纪律。 您必须清楚地考虑您的测试将执行的三个步骤。 由于您已经有了大纲，因此可以使同时编写测试变得更加自然。
真实世界例子 为一个编写全面而清晰的单元测试套件
通俗描述 安排/执行/断言是一种测试模式，将测试分为三个清晰的步骤以方便维护。
维基百科 安排/执行/断言是用于在单元测试方法中排列和格式化代码的模式。 程序示例 创建单元测试的Cash类
public class Cash { private int amount; Cash(int amount) { this.amount = amount; } void plus(int addend) { amount += addend; } boolean minus(int subtrahend) { if (amount &gt;= subtrahend) { amount -= subtrahend; return true; } else { return false; } } int count() { return amount; } } 根据安排/ 执行 / 断言模式编写单元测试（注意每个单元测试的步骤是分开的清晰的）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9239cf1ae45cacbdceeac96ccf1e630/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/704ed3bd2ce5548ebad37323e434cf50/" rel="bookmark">
			【MySQL】数据库基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思维导图 学习目标 这一篇博客，我们来进行学习数据库的基础，认识一下数据库，了解数据库的本质，架构，学会数据库的基本使用，学习存储引擎。
一、MySQL登录 1.1 数据库登录选项 -h：指明登录部署了mysql的服务主机-P：指明我们要访问的端口号-u：指明登录用户-p：指明需要输入的密码 1.2 一些细节 目前是免密登录，后面必须设置密码。密码输入的时候是不会显示的。 二、什么是数据库？ 2.1 简要介绍一下mysql和mysqld mysql是数据库服务的客户端mysqld是数据库服务的服务器端mysql本质，是基于 C(mysql)S(mysqld)模式的一种网络服务 2.2 对外提供存储服务 2.2.1 数据库的本质 MySQL是一套提供数据存取服务的网络程序，数据库一般指的是：在磁盘或者内存中存储特定结构组织的数据——将来在我们的磁盘中存储的数据库方案，数据库服务mysqld
数据库本质上是对数据内容存储的一套解决方案，给其字段和要求，数据库返回结果。
2.2.2 文件保存数据有一下几个缺点： 文件的安全性问题文件不利于数据的查询和管理文件不利于存储海量数据文件在程序管理中不方便一般的文件缺失提供了数据的存储功能，但是文件并没有提供非常好的数据内容管理能力（用户角度） 2.3 数据库的存储介质：磁盘和内存 2.4 来见一见数据库 使用MySQL来进行创建一个数据库，在数据库中建立一个表结构，插入一些数据，对比一下MySQL在Linux中如何进行表现？？
建立数据库，本质就是Linux的一个目录，如图：在数据库内建立表，本质就是在Linux中创建对应的文件即可！！数据库本质其实也是文件，只不过这些文件并不由程序员直接操作，而是由数据库帮我们进行操作。 三、在Linux中建立一个数据库 第一步：建立一个数据库：create database XXXXX
第二步： 选择数据库：use XXXXXXX
第三步：建立一个表结构：create table student{ id int, name varchar(32), gender varchar(2) };
create table student( -&gt; id int, -&gt; name varchar(32), -&gt; gender varchar(2) -&gt; ); 第四步，将数据插入建立的表中：insert into student (id, name, gender) values(1, 'XXX', 'XXX');
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/704ed3bd2ce5548ebad37323e434cf50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21cd6df35a702568ce02b90e085b2e75/" rel="bookmark">
			没有阻塞为什么partition of创建子分区很慢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		create table… partition of语句慢分析 2024-05-16 22:02:59.063 CST,"user1","dblzl",125889,"30.88.79.3:37423",66461213.1ebc1,2,"authentication",2024-05-16 22:02:59 CST,34/41364668,0,LOG,00000,"connection authorized: user=user1 database=dblzl",,,,,,,,,"","client backend" 2024-05-16 22:02:59.079 CST,"user1","dblzl",125889,"30.88.79.3:37423",66461213.1ebc1,3,"idle",2024-05-16 22:02:59 CST,34/41364669,0,LOG,00000,"statement: -- a86fae372f73414bbe1af18213a47beb /*a86fae372f73414bbe1af18213a47beb */ create table if not exists table1_partition_p2406 partition of table1 for values from ('2024-06-01 00:00:00') to ('2024-07-01 00:00:00'); ",,,,,,,,,"","client backend" ... 2024-05-16 22:38:28.555 CST,"user1","dblzl",125889,"30.88.79.3:37423",66461213.1ebc1,4,"CREATE TABLE",2024-05-16 22:02:59 CST,34/0,0,LOG,00000,"duration: 2129483.549 ms",,,,,,,,,"","client backend" user1这个用户在22:02:59连接进入数据库后，立即就执行了一个create table.. partition of..的语句，直到22:38:28才跑完。中间的日志忽略了，一大堆会话阻塞信息，阻塞源均是125889这个会话。
被阻塞的会话类似如下：
process 33569 still waiting for RowExclusiveLock on relation 53733 of database 17073 after 1000.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21cd6df35a702568ce02b90e085b2e75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b77aa59fd1eb310b4eba9af414c07de2/" rel="bookmark">
			位1的个数-力扣
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 答案 class Solution { public int hammingWeight(int n) { int a = 0; for(int i =0;i&lt;32;i++){ if((n &amp; (1&lt;&lt;i))!=0){ a++; } } return a; } } 解析 遍历32位二进制位，然后和1相与看其是否是1，统计个数即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45dda9a3937c208b98b7017fbae24a94/" rel="bookmark">
			AI大模型探索之路-训练篇24：ChatGLM3微调实战-多卡方案微调步骤详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列篇章💥 AI大模型探索之路-训练篇1：大语言模型微调基础认知
AI大模型探索之路-训练篇2：大语言模型预训练基础认知
AI大模型探索之路-训练篇3：大语言模型全景解读
AI大模型探索之路-训练篇4：大语言模型训练数据集概览
AI大模型探索之路-训练篇5：大语言模型预训练数据准备-词元化
AI大模型探索之路-训练篇6：大语言模型预训练数据准备-预处理
AI大模型探索之路-训练篇7：大语言模型Transformer库之HuggingFace介绍
AI大模型探索之路-训练篇8：大语言模型Transformer库-预训练流程编码体验
AI大模型探索之路-训练篇9：大语言模型Transformer库-Pipeline组件实践
AI大模型探索之路-训练篇10：大语言模型Transformer库-Tokenizer组件实践
AI大模型探索之路-训练篇11：大语言模型Transformer库-Model组件实践
AI大模型探索之路-训练篇12：语言模型Transformer库-Datasets组件实践
AI大模型探索之路-训练篇13：大语言模型Transformer库-Evaluate组件实践
AI大模型探索之路-训练篇14：大语言模型Transformer库-Trainer组件实践
AI大模型探索之路-训练篇15：大语言模型预训练之全量参数微调
AI大模型探索之路-训练篇16：大语言模型预训练-微调技术之LoRA
AI大模型探索之路-训练篇17：大语言模型预训练-微调技术之QLoRA
AI大模型探索之路-训练篇18：大语言模型预训练-微调技术之Prompt Tuning
AI大模型探索之路-训练篇19：大语言模型预训练-微调技术之Prefix Tuning
AI大模型探索之路-训练篇20：大语言模型预训练-常见微调技术对比
AI大模型探索之路-训练篇21：Llama2微调实战-LoRA技术微调步骤详解
AI大模型探索之路-训练篇22： ChatGLM3微调实战-从原理到应用的LoRA技术全解
AI大模型探索之路-训练篇23：ChatGLM3微调实战-基于P-Tuning V2技术的实践指南
目录 系列篇章💥前言一、分布式模型训练二、数据并行三、模型并行1、流水线并行（inter-layer）2、张量并行（intra-layer） 四、3D并行五、DeepSpeed1、第一篇论文：ZeRO-DP2、第二篇论文：ZeRO-Offload3、第三篇论文：ZeRO-Infinity4、DeepSpeed总结 六、资源不够怎么办？1、微调量化版本2、多卡微调3、DeepSpeed方案 七、多卡+DeepSpeed微调实战1、服务器资源准备2、多卡微调3、deepspeed配置文件4、微调效果验证 八、多卡部署遇到的问题总结参考 前言 在现代自然语言处理（NLP）任务中，随着模型规模的扩大和训练数据的增多，单张GPU的显存已经无法满足大模型的训练需求。为了充分利用多张GPU进行并行训练，我们需要了解不同的并行策略。本文将详细介绍ChatGLM3微调实战中的多卡方案及其步骤。
一、分布式模型训练 1、显存效率：当模型参数量超出单张GPU显存容量
• 即使目前显存最大的 GPU 也放不下这些大模型的模型参数。
• 例如：面对拥有175B参数量的GPT-3模型，即使是目前最大显存的NVIDIA A100 80GB GPU也难以容纳。该模型的参数需要占用约700GB的显存，加上参数梯度和Adam优化器状态，总共需要约2.8TB的显存空间。
2、计算效率：训练数据量多，模型参数量大，计算量大，单机训练时间久
• 即使我们能将大模型放在一张 GPU 上，训练大模型需要的海量计算操作需要耗费很长时间。例如：用英伟达A100 显卡训练 175B 参数量的 GPT-3 模型，可能需要长达288年的时间
二、数据并行 数据并行是分布式训练模型中最直观的并行策略。在数据并行中，训练数据集被分割成多个子集，每个GPU分配到一个子集，并独立地计算梯度和更新权重。所有的GPU都有模型参数的完整副本，但在每个训练步骤中，它们处理不同的数据。为了同步各个GPU间的训练状态，通常在每步梯度计算之后进行梯度的汇总（AllReduce操作），以确保所有GPU上的模型参数得到一致的更新。
数据并行的优点在于其相对简单，易于实现，并且可以快速开始使用。然而，它的主要缺点是对显存的需求随着模型大小的线性增长；每张GPU都需要存储整个模型的状态。此外，当GPU数量很多时，通信开销可能成为瓶颈。
三、模型并行 模型并行涉及到将一个模型的不同部分分布到不同的计算资源上，从而允许单个GPU不需要持有整个模型的状态。这在大型模型无法装载到单个GPU显存中时特别有用。模型并行有两种主要形式：流水线并行和张量并行。
1、流水线并行（inter-layer） 流水线并行按照层的维度划分模型，不同层分布在不同的GPU上。例如，如果我们有4个GPU，我们可以将模型的前25%层放在第一个GPU上，接下来的25%层放在第二个GPU上，以此类推。这种策略可以减少任何单个GPU上的内存压力，但可能会引入延迟，因为一个GPU在继续其计算之前可能需要等待来自其他GPU的数据。
2、张量并行（intra-layer） 张量并行是在单个层内部进行并行化，将层的计算分摊到多个GPU上。对于每一层，输入特征图（input feature maps）可以被切分到各个GPU上，每个GPU只计算一部分特征图的相应部分。这样可以减少单个层操作所需的内存，并允许更大的模型或更大的批量在有限的硬件资源下进行训练。
四、3D并行 3D并行是一个更为高级的策略，结合了数据并行、流水线并行和张量并行。通过这种方式，模型的不同层组（layer groups）分布到不同的GPU上，同时每个层组内部采用张量并行，而整个数据集则分割成多个子集以实现数据并行。3D并行能够更充分地利用硬件资源，允许在数百甚至数千个GPU上训练极其庞大的模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45dda9a3937c208b98b7017fbae24a94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5c24ec8c04bed8453ae178134144ca2/" rel="bookmark">
			【数据结构】链表与LinkedList
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一篇文章中我们介绍了ArrayList使用方法，并进行了简单的模拟实现，但通过分析我们发现其不方便进行插入和删除操作，因为要移动数组元素，最坏情况下时间复杂度会达到O(n)效率比较低，因此ArrayList不适合做任意位置插入和删除比较多的场景。因此：java集合中又引入了LinkedList，即链表结构。
一、什么是链表 概念：链表是一种物理存储结构上非连续存储结构，数据元素的逻辑顺序是通过链表中的引用链接次序实现的 。
注意： 链式结构是在逻辑上连续，但在物理上不一定连续。
实际中链表的结构非常多样，以下情况组合起来就有 8 种链表结构： 1. 单向或者双向 2. 带头或者不带头 3. 循环或者非循环 虽然有这么多的链表的结构，但是我们重点掌握两种 : 无头单向非循环链表 ： 结构简单 ，一般不会单独用来存数据。实际中更多是作为 其他数据结构的子结构 ，如 哈希桶、图的邻接表等等。 无头双向链表 ：在 Java 的集合框架库中 LinkedList 底层实现就是无头双向循环链表。 二、MyLinkedList实现 1、IList接口 public interface IList { //头插法 void addFirst(int data); //尾插法 void addLast(int data); //任意位置插入,第一个数据节点为0号下标 void addIndex(int index,int data); //查找是否包含关键字key是否在单链表当中 boolean contains(int key); //删除第一次出现关键字为key的节点 void remove(int key); //删除所有值为key的节点 void removeAllKey(int key); //得到单链表的长度 int size(); void clear(); void display(); } 2、MyLinkList实现 1、基础结构
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5c24ec8c04bed8453ae178134144ca2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/310889d727ef3555de7efce22a9ef997/" rel="bookmark">
			【SQL国际标准】ISO/IEC 9075:2023 系列SQL的国际标准详情
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🌊1. 前言
🌊2. ISO/IEC 9075:2023 系列SQL的国际标准详情
🌊1. 前言 ISO（国际标准化组织，International Organization for Standardization）是一个独立的、非政府间的国际组织，其宗旨是制定和发布国际标准，为企业和消费者设立了统一的基准。成立于1947年，总部设在瑞士日内瓦，ISO的成员包括来自各国的国家标准化机构，目前有165个成员。
ISO标准覆盖了广泛的行业和领域，包括但不限于：
制造业：如质量管理标准（ISO 9001）
信息技术：如信息安全管理标准（ISO/IEC 27001）
环境管理：如环境管理体系标准（ISO 14001）
医疗设备：如医疗设备质量管理标准（ISO 13485）
食品安全：如食品安全管理体系标准（ISO 22000）
ISO 官网传送门：ISO - International Organization for Standardization
🌊2. ISO/IEC 9075:2023 系列SQL的国际标准详情 提到SQL国际标准，通常认为是 ISO/IEC 9075。ISO/IEC 9075由多个部分组成，最新版本算是2023版。
ISO/IEC 9075-1:2023
Information technology — Database languages SQL
Part 1: Framework (SQL/Framework)
主要介绍 ISO/IEC 9075 系列其他部分中使用的概念框架，用于指定 SQL 的语法以及 SQL 实现以该语言处理语句的结果。
此外还定义了 ISO/IEC 9075 系列其他部分中使用的术语和符号。
ISO/IEC 9075-2:2023
Information technology — Database languages SQL
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/310889d727ef3555de7efce22a9ef997/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2d4bb97559da1b9d366652eba2a79bd/" rel="bookmark">
			VMware centos7下通过idea实现Hadoop MapReduce经典案例之一的TopN案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：案例需求
现假设有数据文件num.txt，现要求使用MapReduce技术提取上述文本中最大的5个数据，并最终将结果汇总到一个文件中。先设置MapReduce分区为1，即ReduceTask个数一定只有一个。我们需要提取TopN，即全局的前N条数据，不管中间有几个Map、Reduce，最终只能有一个用来汇总数据。在Map阶段，使用TreeMap数据结构保存TopN的数据，TreeMap默认会根据其键的自然顺序进行排序，也可根据创建映射时提供的 Comparator进行排序，其firstKey()方法用于返回当前集合最小值的键。在Reduce阶段，将Map阶段输出数据进行汇总，选出其中的TopN数据，即可满足需求。这里需要注意的是，TreeMap默认采取正序排列，需求是提取5个最大的数据，因此要重写Comparator类的排序方法进行倒序排序。
二：案例实施
​第一步：下载idea以及需要的工具，可以参考Centos7安装并使用IntelliJ IDEA这篇文章。注意下载Linux版本。
​
第二步：下载并安装完idea，先启动Hadoop，使用命令：start-all.sh 启动完成后使用jps查看Hadoop集群是否启动成功。启动Hadoop成功后启动idea。
第三步：在虚拟机上创建文本文件
1.expor目录下创建topn目录，输入命令：mkdir /export/topn 2.在topn目录下创建num.txt文件，输入命令：touch /export/topn/num.txt 3输入命令：vim /export/topn/num.txt 向num.txt文件添加如下内容：
10 3 8 7 6 5 1 2 9 4
11 12 17 14 15 20 19 18 13 16
4上传文件到HDFS指定目录 （1）创建/topn/input目录，输入命令：hdfs dfs -mkdir -p /topn/input （2）将文本文件num.txt，上传到HDFS的/topn/input目录，输入命令：hdfs dfs -put /export/topn/num.txt /topn/input （3）在hadoop webui查看文件是否上传成功。 注意：这时候你要查看是否可以下载到本机，如果不可以下载的话，参考我另一篇文章。 三：Map阶段实现 使用IntelliJ开发工具创建Maven项目TopN，并且新建net.hw.mr包，在该路径下编写自定义Mapper类TopNMapper，主要用于将文件中的每行数据进行切割提取，并把数据保存到TreeMap中，判断TreeMap是否大于5，如果大于5就需要移除最小的数据。TreeMap保存了当前文件最大5条数据后，再输出到Reduce阶段。
（1）创建Maven项目：TopN
1.在idea左上角新建项目。包名：net.army.mr配置好如下图，单击【Create】按钮
2.删除【Main】主类：右击【Main】类，单击【Delete】 3.添加相关依赖，在pom.xml文件里添加hadoop和junit依赖，添加内容如下： &lt;dependencies&gt; &lt;!--hadoop客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;version&gt;3.3.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--单元测试框架--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 4 刷新本地的maven仓库，如果没有下载，会自动下载依赖到本地：单击【Maven】，单击【刷新】按钮 （这个过程需要idea自己下载，过程可能有点慢，耐心等待） 5创建日志属性文件 （1）在resources目录里创建log4j.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2d4bb97559da1b9d366652eba2a79bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b7d6083145377d0cb9d0993115b1246/" rel="bookmark">
			Vue3, PC端swagger适配以视频为背景，兼容视频点击播放和滑动切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图 Swagger Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。
总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法、参数和模型紧密集成到服务器端的代码，允许 API 来始终保持同步。Swagger 让部署管理和使用功能强大的 API 从未如此简单。
关键点 在swiper-slide中使用一个遮罩层，让用户滑动的时候实际是在遮罩层上滑动，而不是视频上，解决了视频的点击事件和swiper-slide滑动事件的冲突，然后在自定义遮罩层的点击播放\暂停逻辑实现。
引入插件 &lt;script lang="ts"&gt; import { Swiper, SwiperSlide } from 'swiper/vue'; import { Pagination, EffectCoverflow } from 'swiper/modules'; import 'swiper/css'; import 'swiper/css/pagination'; import 'swiper/css/effect-coverflow'; &lt;/script&gt; html &lt;swiper :modules="modules" :centered-slides="true" :slides-per-view="'auto'" :space-between="50" loop :pagination="{ clickable: true }" @transition-end="onTransitionEnd" class="swiper-video" &gt; &lt;swiper-slide class="slide" v-for="item in videos" :key="item.id" :prevent-clicks="false" &gt; &lt;div class="video-box"&gt; &lt;video :src="item.url" controls :id="'swiper-video-' + item.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b7d6083145377d0cb9d0993115b1246/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/582db5a16482490576ebc3356a6e5c40/" rel="bookmark">
			Python筑基之旅-搭建Python开发环境及库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、搭建Python开发环境
二、如何安装插件及第三方库？
三、Python中有哪些常用内置标准库？
四、 Python各发展方向主要库有哪些？
五、理解几个重要的概念
六、推荐专栏/主页：
1、Python函数之旅：Functions
2、Python算法之旅：Algorithms
3、个人主页：神奇夜光杯-CSDN博客
一、搭建Python开发环境 1、开发环境：
1-1、PyCharm版本：pycharm-community-2024.1.1(下载地址：Download PyCharm: The Python IDE for data science and web development by JetBrains)
1-2、Python版本：Python 3.11.8(下载地址：Python Releases for Windows | Python.org)
若有不知道系统状态的，请在电脑桌面找到“我的电脑”或“此电脑”图标(根据Windows版本，会有差异)，用鼠标右键单击，选择属性：
2、安装操作：
2-1、安装PyCharm
找到上面下载的pycharm-community-2024.1.1安装程序(注：我的在E:\360Downloads\下面，请根据自己下载路径查找)，如下图：
双击“pycharm-community-2024.1.1.exe”，开始安装：
按选“下一步(N)”按钮：
(我的安装路径：E:\Program Files\JetBrains\PyCharm Community Edition 2024.1.1，切勿装在C盘中) 按选“下一步(N)”按钮：
按选“下一步(N)”按钮：
按选“安装(I)”按钮：
点击“完成(F)”按钮即可。
2-2、安装Python
找到上面下载的python-3.11.8-amd64安装程序(注：我的在E:\360Downloads\下面，请根据自己下载路径查找)，如下图：
双击“python-3.11.8-amd64.exe”，开始安装：
单击“Cutomize installation” ，进入以下界面：
按选“Next”按钮：
按选“Install”按钮：
单击“Close”按钮即可完成安装。
3、配置环境：
在电脑桌面，找到“PyCharm Community Edition 2024.1.1”图标，鼠标双击启动软件：
在左上角的主菜单栏，找到File(快捷键：Alt+F)，即文件，如下图所示(注：不习惯英文的，可以先做汉化处理，方法在后面)：
单击Settings(直接按T)后，进入Settings界面，如下：
单击“Show All...”，进入Python Interpreters界面：
单击“+”后，进入Add Python Interpreter界面：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/582db5a16482490576ebc3356a6e5c40/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/15/">«</a>
	<span class="pagination__item pagination__item--current">16/71</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/17/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>