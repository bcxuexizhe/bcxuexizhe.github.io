<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3023d84cce761d4900ad36b078447a52/" rel="bookmark">
			Linux完整版命令大全（十三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git(gnu interactive tools)
功能说明：文字模式下的文件管理员。 语　法：git
补充说明：git是用来管理文件的程序，它十分类似DOS下的Norton Commander，具有互动式操作界面。它的操作方法和Norton Commander几乎一样，略诉如下： F1 ：执行info指令，查询指令相关信息，会要求您输入欲查询的名称。 F2 ：执行cat指令，列出文件内容。 F3 ：执行gitview指令，观看文件内容。 F4 ：执行vi指令，编辑文件内容。 F5 ：执行cp指令，复制文件或目录，会要求您输入目标文件或目录。 F6 ：执行mv指令，移动文件或目录，或是更改其名称，会要求您输入目标文件或目录。 F7 ：执行mkdir指令，建立目录。 F8 ：执行rm指令，删除文件或目录。 F9 ：执行make指令，批处理执行指令或编译程序时，会要求您输入相关命令。 F10 ：离开git文件管理员。
gitview(gnu interactie tools viewer)
功能说明：Hex/ASCII的看文件程序。 语　法：gitview [-bchilv][文件] 补充说明：gitview指令可用于观看文件的内容，它会同时显示十六进制和ASCII格式的字码。 参　数：
-b 单色模式，不使用ANSI控制码显示彩色。 -c 彩色模式，使用ANSI控制码显示色彩。 -h 在线帮助。 -i 显示存放gitview程序的所在位置。 -l 不使用先前的显示字符。 -v 显示版本信息。
ln(link)
功能说明：连接文件或目录。 语　法：ln [-bdfinsv][-S &lt;字尾备份字符串&gt;][-V &lt;备份方式&gt;][--help][--version][源文件或目录][目标文件或目录] 或 ln [-bdfinsv][-S &lt;字尾备份字符串&gt;][-V &lt;备份方式&gt;][--help][--version][源文件或目录...][目的目录] 补充说明：ln指令用在连接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。 参　数：
-b或--backup 删除，覆盖目标文件之前的备份。 -d或-F或--directory 建立目录的硬连接。 -f或--force 强行建立文件或目录的连接，不论文件或目录是否存在。 -i或--interactive 覆盖既有文件之前先询问用户。 -n或--no-dereference 把符号连接的目的目录视为一般文件。 -s或--symbolic 对源文件建立符号连接，而非硬连接。 -S&lt;字尾备份字符串&gt;或--suffix=&lt;字尾备份字符串&gt; 用"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3023d84cce761d4900ad36b078447a52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2596fbea8238398982aed74281792309/" rel="bookmark">
			AI大模型在测试中的深度应用与实践案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 示例项目背景2. 环境准备3. 代码实现3.1. 自动生成测试用例3.2. 自动化测试脚本3.3. 性能测试3.4. 结果分析 4. 进一步深入4.1. 集成CI/CD管道4.1.1 Jenkins示例 4.2. 详细的负载测试和性能监控4.2.1 Locust示例 4.3. 测试结果分析与报告 5. 进一步集成和优化5.1. 完善测试用例生成和管理5.1.1 配置文件管理测试用例 5.2. 高级性能监控和分析5.2.1 使用Grafana和Prometheus进行性能监控5.2.2 使用Jaeger进行分布式跟踪 5.3. 持续反馈与改进5.3.1 生成测试报告并通知 6. 总结 1. 示例项目背景 我们有一个简单的电商平台，主要功能包括用户注册、登录、商品搜索、加入购物车、下单和支付。我们将使用大模型来自动生成测试用例，并进行一些基本的测试结果分析。
2. 环境准备 首先，我们需要安装OpenAI的API客户端和其他必要的库：
pip install openai pip install pytest pip install requests 3. 代码实现 3.1. 自动生成测试用例 使用GPT-4自动生成测试用例，涵盖主要功能。
import openai # 设置API密钥 openai.api_key = "YOUR_API_KEY" def generate_test_cases(prompt): response = openai.Completion.create( engine="text-davinci-003", prompt=prompt, max_tokens=500 ) return response.choices[0].text.strip() # 定义测试用例生成的提示 prompt = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2596fbea8238398982aed74281792309/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c849b3405aa79189a30f78b953394f5b/" rel="bookmark">
			技术速递｜使用 C# 集合表达式重构代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：David Pine
排版：Alan Wang
本文是系列文章的第二篇，该系列文章涵盖了探索 C# 12功能的各种重构场景。在这篇文章中，我们将了解如何使用集合表达式重构代码，我们将学习集合初始化器、各种表达式用法、支持的集合目标类型和 spread 语法。该系列的进展情况如下：
使用主构造函数重构 C# 代码使用集合表达式重构 C# 代码（本文）通过为任何类型添加别名来重构您的 C# 代码重构您的 C# 代码以使用默认 lambda 参数 这些功能延续了我们的旅程，使我们的代码更具可读性和可维护性，并且被认为是开发人员应该了解的“日常 C#”功能。
集合表达式 C# 12 引入了集合表达式，它为许多不同的集合类型提供简单且一致的语法。当使用集合表达式初始化集合时，编译器生成的代码在功能上与使用集合初始化项等效。该功能强调一致性，同时允许编译器优化低级的 C#。当然，每个团队都可以决定采用哪些新功能，如果您愿意，您可以尝试并引入这种新语法，因为之前所有初始化集合的方法都将继续工作。
对于集合表达式，元素出现在左括号 [ 和右括号 ] 之间的内联元素序列。继续阅读以了解有关集合表达式如何工作的更多信息。
初始化 C# 提供了许多语法来初始化不同的集合。集合表达式取代了所有这些，所以让我们先来看看初始化整数数组的不同方法，如下所示：
var numbers1 = new int[3] { 1, 2, 3 }; var numbers2 = new int[] { 1, 2, 3 }; var numbers3 = new[] { 1, 2, 3 }; int[] numbers4 = { 1, 2, 3 }; 这四个版本在功能上都是等效的，并且编译器为每个版本生成相同的代码。最后一个示例类似于新的集合表达式语法。如果您眯起眼睛，将花括号 { 和 } 想象为方括号 [ 和 ]，然后您就会读到新的集合表达式语法了。集合表达式不使用花括号，这是为了避免与现有语法产生歧义，特别是用 { } 来表示模式中的任何非空。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c849b3405aa79189a30f78b953394f5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ddc214b905154c6d8f4bc5cf5aac512/" rel="bookmark">
			【WEB前端2024】开源智体世界：乔布斯3D纪念馆-第30课-门的移动动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【WEB前端2024】开源智体世界：乔布斯3D纪念馆-第30课-门的移动动画 使用dtns.network德塔世界（开源的智体世界引擎），策划和设计《乔布斯超大型的开源3D纪念馆》的系列教程。dtns.network是一款主要由JavaScript编写的智体世界引擎（内嵌了three.js编辑器的定制版-支持以第一视角游览3D场馆），可以在浏览器和node.js、deno、electron上运行，它是一个跨平台的软件，支持多个操作系统使用！
下面分为几步介绍，如何基于dtns.network智体世界引擎如何实现乔布斯3D纪念馆的碟状总部的3D门组件的移动动画。这是首次实现的较为复杂的长动画效果。通过使用pop.sleep指令，结合3D组件的位置移动api，可以实现复杂的长时间动画。
长时动画特效，可以在3D场馆中，实现各种丰富的场景应用。例如3D教材，3D游戏、3D展厅、互动动画、互动教学、互动特效等。可以极大程度上丰富3D智体轻应用的用户体验效果，使之更具备真实感和沉浸感，让用户更容易沉浸在互动特效里。
第一步：打开头榜页面，找到3D纪念馆xverse轻应用 第二步：点击右上角…进入头榜编辑器 第三步：点击正面的“编辑xverse轻应用源码”，进入3D场馆编辑器 注：点击3D门组件，在右侧属性面板找到脚本-编辑按钮。
第四步：点击右侧的属性面板下方的脚本-编辑，进入poplang智体编程语言的脚本编辑器，使用时间函数pop.sleep实现长时3D动画特效 注：将pop.func.define定义的onclickx函数，修改为onclick（恢复3D门组件的点击事件，使得点击事件激活门的移动动画特效）。使用pop.sleep 1000实现1秒后3D门组件的位置发生一次位移（先右移），再在Y轴上加上3的偏移，连续上移2次——最终到达目标位置。如需更复杂的3D位移特效，可参考“快速游览全图”一文，亦是使用了pop.sleep实现了长时动画特效——只不过改变的是玩家位置、玩家视角。
第五步：点击顶部菜单“文件”推送头榜（作品），将此3D纪念馆分享给其他用户 第六步：将新的头榜标题设置为“3D纪念馆-门的移动动画”，点击右上角确认完成头榜发布 第七步：找到刚发布的xverse轻应用头榜，点击进入3D场景游览器 第八步：进入3D轻应用后，点击门3D组件，体验3D组件动画特效 注：点击圆圈位置的门3D组件。
第九步：点击门组件、激活了门的移动 我们从上图看到了门的位移，原来的位置上会出现一个点击事件带来的3D黄绿色3D方框（标注门原来点击事件发生的位置）
等待1-2秒后，最终门上移（2秒分2次完成上移，每次上移3），效果如下
通过上述9步，我们成功完成了《乔布斯3D纪念馆》的飞碟形态的3D纪念馆的门的3D组件的长时位移动画特效。通过这个动画特效，我们很容易地理解了在3D场景里面，实现一个3D组件的移动，将带来全新的沉浸式的互动体验，这个与2D的动画特效、电影情节、游戏完全不一样。具备着类似真实世界一样的沉浸感、画面感，大大增强了用户的感观体验、互动体验。从而带来全新的3D动画特效体验。
注：dtns.network德塔世界（开源的智体世界引擎）是在github和gitee上开源的项目！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15a1bd457047c66e139797016020deea/" rel="bookmark">
			AIGC技术的探讨
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 AIGC（人工智能生成内容）技术是利用人工智能自动生产内容的一种方式，它在多个领域中的应用不断扩展，同时也带来了伦理和风险问题的考量。
二、技术应用 AIGC技术在各个领域的应用情况广泛，从文本生成到图像和音频的创造，再到视频内容的制作。例如，AIGC技术可以用于生成新闻文章、社交媒体内容、虚拟助手的对话，甚至是艺术作品。AIGC技术的应用预示着未来社会将更加依赖于智能系统来生成和管理内容：
工作方式的改变：随着AIGC技术的发展，许多传统的内容创作工作可能会被自动化，从而改变人类的工作方式。
信息消费的变革：个性化和即时生成的内容将改变人们消费信息的习惯，可能会加剧信息过载的问题。
创意表达的新机遇：AIGC技术将为创意表达提供新的工具和平台，促进文化多样性的发展。
在未来社会，AIGC技术有望进一步推动教育、娱乐和商业等领域的发展，同时也可能改变内容消费的方式。
三、伦理与风险 AIGC技术可能带来的伦理和风险问题包括数据安全、隐私保护、道德风险等。例如，AIGC模型的训练依赖于大量数据，这些数据可能包含敏感信息，存在被滥用的风险。此外，AIGC生成的内容可能会被用于虚假新闻发布或网络诈骗，对社会造成不良影响。为了应对这些问题，可以考虑以下几个措施：
建立数据保护法规：确保用户数据的安全和隐私，限制数据的不当使用。
内容真实性验证：开发技术和标准来验证内容的来源和真实性，防止虚假信息的传播。
明确知识产权指导原则：制定关于AIGC生成内容的知识产权法规，保护创作者和用户的权益。
因此，需要加强对AIGC技术的监管和管理，确保其应用不违反伦理规范和法律法规。
四、未来展望 AIGC技术的未来发展前景广阔，预计将在算法和结构的优化上取得更多进展。
随着技术的成熟，AIGC有可能在个性化教育、智能医疗、自动化创作等领域发挥更大的作用：
应用拓展：随着技术的进步，AIGC技术将在更多领域得到应用，如智能家居、个性化营销、自动化客服等，提供更加智能和便捷的服务。
交互体验的革新：AIGC技术将使得虚拟助手和聊天机器人更加智能，能够提供更自然和丰富的交互体验。
创新的商业模式：AIGC技术可能会催生新的商业模式和服务，如基于用户数据生成的个性化内容订阅服务。
然而，这也将对个人和社会带来新的挑战，如就业市场的变化、知识产权的保护等。所以，未来的发展需要在创新和规范之间找到平衡，确保技术的积极影响。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b087913ce62e29f127eb5e5f39956a7/" rel="bookmark">
			多线程理论及操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【一】什么是线程 在传统操作系统中，每个进程有一个地址空间，而且默认就有一个控制线程
线程顾名思义，就是一条流水线工作的过程
一条流水线必须属于一个车间，一个车间的工作过程是一个进程
车间负责把资源整合到一起，是一个资源单位，而一个车间内至少有一个流水线
流水线的工作需要电源，电源就相当于cpu
所以进程只是用来把资源集中到一起（进程只是一个资源单位，或者说资源集合），而线程才是cpu上的执行单位。
多线程（即多个控制线程）的概念是在一个进程中存在多个控制线程，多个控制线程共享该进程的地址空间，相当于一个车间内有多条流水线，都共用一个车间的资源。
例如
北京地铁与上海地铁是不同的进程，而北京地铁里的13号线是一个线程，北京地铁所有的线路共享北京地铁所有的资源，比如所有的乘客可以被所有线路拉。
【1】示例： 进程
资源单位
线程
执行单位
将操作系统比喻成大的工厂
进程相当于工厂里面的车间
线程相当于车间里面的流水线
【2】小结 每一个进程必定自带一个线程
进程：资源单位
起一个进程仅仅只是 在内存空间中开辟出一块独立的空间
线程：执行单位
真正被CPU执行的其实是进程里面的线程
线程指的就是代码的执行过程，执行代码中所需要使用到的资源都找所在的进程索要
进程和线程都是虚拟单位，只是为了我们更加方便的描述问题
【二】线程的创建开销 【1】创建进程的开销要远大于线程 如果我们的软件是一个工厂
该工厂有多条流水线
流水线工作需要电源
电源只有一个即cpu（单核cpu）
一个车间就是一个进程
一个车间至少一条流水线（一个进程至少一个线程）
创建一个进程
就是创建一个车间（申请空间，在该空间内建至少一条流水线）
而建线程
就只是在一个车间内造一条流水线
无需申请空间，所以创建开销小
【2】进程之间是竞争关系，线程之间是协作关系 车间直接是竞争/抢电源的关系，竞争
不同的进程直接是竞争关系
不同的程序员写的程序运行的迅雷抢占其他进程的网速
360把其他进程当做病毒干死
一个车间的不同流水线式协同工作的关系
同一个进程的线程之间是合作关系，是同一个程序写的程序内开启动
迅雷内的线程是合作关系，不会自己干自己
【三】线程和进程的区别 Threads share the address space of the process that created it; processes have their own address space.
线程共享创建它的进程的地址空间； 进程具有自己的地址空间。
Threads have direct access to the data segment of its process; processes have their own copy of the data segment of the parent process.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b087913ce62e29f127eb5e5f39956a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99301fb57504c8af4397cf4c6258dc45/" rel="bookmark">
			【学习记录】服务器转发使用tensorboard
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景 代码在服务器上运行，想使用tensorboard查看训练的过程。
但是服务器上不能直接访问地址，所以要转发端口到本地，从而在本地网页中能够打开tensorboard。
参考：https://zhuanlan.zhihu.com/p/680596384
这时我们需要建立本地服务器与远程服务器的通信，将tensorboard的映射端口与本地端口连接起来，如下所示：
ssh -L 本地端口:127.0.0.1:TensorBoard端口 用户名@服务器的IP地址 -p 服务器登录端口 本地端口：查看 tensorboard 结果时，在浏览器中输入地址时的端口号
TensorBoard端口：运行Tensorboard时指定的端口（默认为6006）
服务器登陆端口：登录服务器时指定的端口（默认为22）
#本地终端登陆远程服务器 ssh -L 10086:127.0.0.1:6060 work@221.122.128.92 -p 20 #远程服务器中找到tensorboard所在目录并运行 tensorboard --logdir=lightning_logs --port 6006 #在本地浏览器中输入如下地址即可查看tensorboard结果 http://127.0.0.1:10086 步骤： 具体实现： 1.cmd打开本地命令行 执行命令，并输入服务器上的密码：
ssh -L 20086:127.0.0.1:6060 root@172.23.253.103 -p9723 20086 是本地指定的端口，用于本地打开tensorboard。
http://localhost:20086/ 此时相当于本地的127.0.0.1:6060 ，已经与服务器上的端口绑定了。
2.服务器上启动tensorboard tensorboard --logdir=work_dir/CULane/20240526_231058_lr_5e-02_b_32/ --port 6060 这里要注意绑定端口
3. 本地打开tensorboard 本地浏览器打开：
http://localhost:20086 即可显示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f65a676c1d0437e2ff83dda2e4f7a91/" rel="bookmark">
			网络编程 —— Http进度条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种下载带进度的方法 string url = "https://nodejs.org/dist/v20.10.0/node-v20.10.0-x64.msi";
1使用getASync获取服务器响应数据 参数1请求的路径，
参数2 HttpCompletionOption.ResponseHeadersRead 请求完成时候等待请求带什么程度才代表请求成功
ResponseHeadersRead 读取到响应头的时候算是请求完成， 响应头有个字段可以获取资源大小
ResponseContentRead 读取到整个响应内容算是请求完成
HttpResponseMessage res = await new HttpClient().GetAsync(url,HttpCompletionOption.ResponseHeadersRead); 2 获取url的文件名称 string fileName = Path.GetFileName(url); 3 将响应数据读取带stream对象中 Stream stream = await res.Content.ReadAsStreamAsync(); 4 记录响应数据的总大小 在响应头里面有一个ContentLength字段获取响应大小也就是下载的总大小 long all = res.Content.Headers.ContentLength ?? 0; 6 定义一个字节数组 字节数组容量是8KB的大小 byte[] bytes = new byte[1024*8]; 从数据流读取到字节数组，并且从0开始读取，到字节数组被容纳完为止
返回值是整型的，代表是读取的位置
stream.Read(bytes, 0, bytes.Length); int nowReadCount = 0; //当前读取的位置 如果读取的位置不为0，证明还有数据，还得再次读取数据
while((nowReadCount = stream.Read(bytes, 0, bytes.Length))!=0) { // 读取数据 //b把当前读取的数据写入本地 fs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f65a676c1d0437e2ff83dda2e4f7a91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4177b46787bf3009afa345e780007de4/" rel="bookmark">
			【Java继承】（超级详细！！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Java继承】（超级详细！！！） 1、 继承的概念2 、继承的语法3、 父类成员访问3.1 子类中访问父类的成员变量3.2 子类中访问父类的成员方法 4、 super关键字5 、子类的构造方法6、 继承关系上的执行顺序7、protected 关键字8、继承方式9、final 关键词 1、 继承的概念 继承机制：是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加新功能，这样产生新的类，称派生类。继承呈现了面向对象程序设计的层次结构， 体现了由简单到复杂的认知过程。继承主要解决的问题是：共性的抽取，实现代码复用。
例如：小猫和小狗都是（有名字有年龄要吃饭）的动物。
上述图示中，Dog和Cat都继承了Animal类。
其中：Animal类称为父类/基类或超类，Dog和Cat可以称为Animal的子类/派生类。
继承之后，子类可以复用父类中成员，子类在实现时只需关心自己新增加的成员即可。
下面我们将学习继承的语法，利用代码实现上述继承关系！
2 、继承的语法 修饰符 class 子类名 extend 父类名(){ //... } 注意：
子类会将父类中的成员变量或者成员方法继承到子类中子类继承父类之后，必须要新添加自己特有的成员，体现出与基类的不同，否则就没有必要继承了 3、 父类成员访问 3.1 子类中访问父类的成员变量 如上图a所示：当子类和父类中同时有成员变量a时，访问的是子类的成员变量a如上图b所示：当子类没有成员变量b，而父类有成员变量b时，访问的是父类的成员变量b如上图c所示：当子类有成员变量c，父类没有成员变量c时，访问的是子类的成员变量c 注意：
成员变量访问遵循就近原则，自己有优先自己的，如果没有则向父类中找。
3.2 子类中访问父类的成员方法 如上图test1所示：子类中没有成员方法test1，父类中有成员方法test1，所以访问的是父类中的成员方法test1如上图test2所示：子类中有成员方法test2，父类中没有成员方法test2，所以访问的是子类中的成员方法test2如上图test所示：子类和父类都有成员方法test，同样遵循就近原则，访问的是子类的成员方法test 下面我们进行一个小测试，从而使我们更深入的了解该知识点。
//父类 public class Father { int a=1; int b=1; public void test1(int a){ System.out.println("父类test1,数字结果为："+a); } public void test1(){ System.out.println("父类test1,无参数"); } } //子类 public class Son extends Father{ int a=2; int c=2; public void test1() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4177b46787bf3009afa345e780007de4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dda6a43b584bd112ce758012418d511/" rel="bookmark">
			心电信号降噪方法（滤波器/移动平均/小波等，MATLAB环境）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于一个正常的、完整的心动周期，对应的心电图波形如下图所示，各个波形都对应着心脏兴奋活动的生理过程，包含P波，PR段，QRS波群，ST段，T波，U波。
（1）P波心电图中，起始的P波对应心房的兴奋过程，一个完整的心动周期起始于窦房结，P波的起始，代表窦房结将心脏兴奋传递至心房使得心房全部受到激励的过程。P波的方向及形态与兴奋在心房内的传播途径密切相关，在各个导联中，P波形态不尽一致，一般来说，P波顶部圆钝，其幅值不高于0.25mV，时限宽度在0.11s以内。
（2）QRS复合波在心电图中，QRS复合波也称为QRS波群，表征着心室除极的心脏电位变化状态，由于心室各部位受到激励顺序有先后，因此QRS复合波是代表心室几个部分兴奋过程的综合波形，是由方向向下的Q波，波形宽大且幅值较高的R波，以及波形方向向下的S波组合形成的。QRS复合波在心电图中波形最为明显，有波形宽，斜率大的特点，因此最容易被识别，常作为心电信号研究的基础，应用广泛。一般正常情况下，QRS波的时限宽度在0.06-0.10s。而在不同的导联中，Q波，R波，S波的振幅、方向不尽一致，致使QRS波形态各异。一般来说Q波振幅小于同一导联中R波的1/4~1/2。在双极肢体导联I、II、III中，R波的振幅一般不超过1.5mV，2.5mV，2.0mV。在标准导联中，S波的振幅的变化量不超过0.6mV。
（3）S-T段在QRS波群的终点到与之相继出现的T波起点中间的水平连线是S-T段，表征着从心室除极结束至缓慢复极的心电活动状态。一般来说，S-T段正常情况下其时限宽度在0.10-0.14s，接近于基线，偏移量较小，一般下移量在0.05mV以内，ST段的抬高量在不同导联中有不同范围，例如在V3导联中抬高量在0.5mV内，ST段的偏移量超过正常范围针对心肌类疾病诊断意义重大。
（4）T波在QRS波群之后出现的顶部圆钝的波形是T波，表征心室复极的状态，通常T波与其同一心动周期的QRS主波方向统一，但也存在T波倒置，双向等情况，其所占时限较长，一般为0.05-0.250s，在不同导联中其幅值也不尽相同，一般应大于与其相邻的R波幅值的1/10。
（5）Q-T间期Q-T间期是从Q波的起始点到T波的终点之间的距离，表征的是心室除极开始到复极完成的心脏活动过程。此段间期与心搏速率相关联，心率越慢，间期越长，相反则越短。一般情况下，若心率在70次/分左右，那么Q-T间期在0.32-0.44s左右，超过正常Q-T间期最高值0.03s被称为Q-T间期显著延长。
（6）U波U波出现在T波之后，是因心室复极化而形成，波形宽而低平，振幅较小，一般不超过0.05mV，时限宽度在0.02~0.04s。U波一般与T波方向相同，其振幅约在0.03mV左右，U波不一定出现在所有导联中，在胸导联中其波形较为明显。
鉴于此，采用滤波器/移动平均/小波等方法进行心电信号降噪，运行环境为MATLAB，运行代码如下：
clc clear all; close all; folderType = 'AVRT'; fileName = strcat('JS10493'); % folderType = 'AF'; % fileName = strcat('JS10361'); matFileName = strcat(fileName, '.mat'); heaFileName = strcat(fileName, '.hea'); data_path = fullfile('data/raw/', folderType, matFileName); data = load(data_path); ecg_orig = data.val(1, :); ecg_orig(isinf(ecg_orig)|isnan(ecg_orig)) = 0; fs = 125; N = length(ecg_orig); t = (0:N-1) / fs; f = (0:N-1) * (fs / N); frequencies = f(1:N/2+1); %RESAMPLE SIGNAL To 125Hz % [ecg, t] = resample_signal_125(ecg_orig, t_orig); %Assigning new parameter % fs = 125; % N = length(ecg); % f = (0:N-1) * (fs / N); %Applying high pass and low pass filters hl_filter = hpf_lpf(ecg_orig, fs); pl_filter = powerline_removal(hl_filter, fs); movSignal = moving_avg(pl_filter, 5); waveletSignal = wavelet_denoise(movSignal, 5); % Create a single figure with subplots for each signal figure; % Original ECG subplot(5, 1, 1); plot(t, ecg_orig); xlabel('Time (s)'); ylabel('Amplitude (mV)'); title('Original Signal'); % HPF + LPF Filtered subplot(5, 1, 2); plot(t, hl_filter); xlabel('Time (s)'); ylabel('Amplitude (mV)'); title('HPF + LPF Signal'); % Powerline Removal subplot(5, 1, 3); plot(t, pl_filter); xlabel('Time (s)'); ylabel('Amplitude (mV)'); title('Powerline Removal'); % Moving Average applied subplot(5, 1, 4); plot(t, movSignal); xlabel('Time (s)'); ylabel('Amplitude (mV)'); title('Moving Average Applied'); % Wavelet Denoised subplot(5, 1, 5); plot(t, waveletSignal); xlabel('Time (s)'); ylabel('Amplitude (mV)'); title('Wavelet Denoised'); out = waveletSignal; figure subplot(4, 1, 1); [Pxx,F] = periodogram(ecg_orig,[],length(ecg_orig),fs); plot(F,10*log10(Pxx)) title('Original Signal Spectrum'); xlabel('Frequency'); subplot(4, 1, 2); [Pxx_out,F_out] = periodogram(out,[],length(out),fs); plot(F,10*log10(Pxx_out)) title('Output Signal Spectrum'); xlabel('Frequency'); subplot(4, 1, 3) input_fft = fft(ecg_orig)/N; input_fft = 2 * abs(input_fft(1:N/2+1)); plot(frequencies, input_fft) title('Original Signal FFT'); xlabel('Frequency'); subplot(4, 1, 4) output_fft = fft(out)/N; output_fft = 2 * abs(output_fft(1:N/2+1)); plot(frequencies, output_fft) title('Output Signal FFT'); xlabel('Frequency'); output_folder_path = fullfile('data/processed/', folderType); if ~exist(output_folder_path, 'dir') mkdir(output_folder_path); end output_path = fullfile('data/processed/', folderType, matFileName); save(output_path, 'out'); source_file_path_hea = fullfile('data/raw/', folderType, heaFileName); destination_file_path_hea = fullfile("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dda6a43b584bd112ce758012418d511/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ac6e9b68dbdac3f6672ac86832ba4af/" rel="bookmark">
			MySQL：CRUD初阶(有图有实操)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 📑1. 数据库的操作🌤️1.1 显示当前的数据库🌤️1.2 创建数据库🌤️1.3 选中数据库🌤️1.4 删除数据库 📑2. 表的操作🌤️2.1 查看表结构🌤️2.2 创建表🌤️2.3 删除表🌤️2.4 向表中插入数据💫2.4.1 单行数据 + 全列插入💫2.4.2 多行数据 + 指定列插入 🌤️2.5 查询💫2.5.1 全列查询💫2.5.2 指定列查询💫2.5.3 查询字段为表达式💫2.5.4 别名(as)💫2.5.5 去重(distinct)💫2.5.6 排序(order by)💫2.5.7 条件查询(where)💫2.5.8 分页查询(limit)💫2.5.9 修改(Update)💫2.5.10 删除(Delete) ☁️结语 📑1. 数据库的操作 MySQL命令是不区分大小写的，为了风格统一，以下只使用小写字母。
🌤️1.1 显示当前的数据库 show databases; 示例：显示MySQL中的数据库
还记得刚开始用MySQL，总是忘记写分号…
🌤️1.2 创建数据库 create database 数据库名; 示例：创建一个test数据库
注意：MySQL 5.7 及之前版本默认的字符集是 latin1 ，MySQL 8.0 版本默认的字符集是 utf8mb4 。
🌤️1.3 选中数据库 必须先选中要使用的数据库，才可以操作数据库。
use 数据库名; 如果没选中数据库，就对数据库进行操作，就会出现报错：
选中后，才能正常使用：
🌤️1.4 删除数据库 drop database 数据库名; 使用drop删除数据库时，会把数据库中的表和数据全部删除。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ac6e9b68dbdac3f6672ac86832ba4af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/185b4e94114395cf34a7a49a73e034ce/" rel="bookmark">
			Day08：CSS 高级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标：掌握定位的作用及特点；掌握 CSS 高级技巧
一、定位 作用：灵活的改变盒子在网页中的位置
实现：
1.定位模式：position
2.边偏移：设置盒子的位置
leftrighttopbottom 水平方向偏移：left、right，垂直方向偏移：top、bottom
1、相对定位 position: relative
特点：
不脱标，占用自己原来位置显示模式特点保持不变（如：块级显示模式使用相对定位后还是块级显示模式）设置边偏移则相对自己原来位置移动 div { position: relative; top: 100px; left: 200px; }	因为相对定位不脱标，即使自己发生了偏移，还占用自己原来的位置，后面的元素没办法顶上去，会留下一片空白，所以实际开发中很少单独使用相对定位，经常配合着绝对定位一起使用。
2、绝对定位 position: absolute
使用场景：子级绝对定位，父级相对定位（子绝父相）
特点：
脱标，不占位显示模式具备行内块特点（即使是行内元素，使用了绝对定位后，设置宽高生效）设置边偏移则相对最近的，已经定位的祖先元素改变位置如果祖先元素都未定位，则相对浏览器可视区改变位置 .father { position: relative; } .father span { position: absolute; top: 0; right: 0; } 练习：使用绝对定位，实现图片在浏览器居中定位。
实现步骤：
设置元素绝对定位，没有最近的祖先元素设置定位属性，则该元素的绝对定位相对于浏览器可视窗口改变位置；水平、垂直边偏移为 50%，此时图片的左上角正好在浏览器的中心位置，需要向左、向上偏移，使图片中心移动到浏览器可视窗口的中心；子级向左、向上移动自身尺寸的一半。 量出图片尺寸，设置 margin-left: -宽度的一半，margin-top: -高度的一半。使用 transform 属性，transform 是元素位置偏移，transform: translate(-50%, -50%)。 代码如下：
&lt;head&gt; &lt;style&gt; img { /* 子级设置为绝对定位，没有父级，相对浏览器可视区域改变位置 */ position: absolute; left: 50%; top: 50%; /* 设置 margin-left: -宽度的一半，margin-top: -高度的一半 */ /* margin-left: -265px; margin-top: -127px; */ /* 方便：50% 就是自己宽高的一半 */ transform: translate(-50%, -50%); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/185b4e94114395cf34a7a49a73e034ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/021be0c1c0a60abd9964ce47d71e0541/" rel="bookmark">
			计算机网络-运输层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运输层 网络层在两个端系统之间的交付服务拓展到运行在两个不同端系统上的应用层进程之间的交付服务。
概述和运输层服务 运输层协议为运行在不同主机上的引用进程之间提供了逻辑通信功能。通过逻辑通信，运行在不同进程之间的主机好像直接连接一样。
运输层协议是在端系统而不是在服务器中实现的，在发送端，运输层将发送引用程序进程接受到的报文[运输层报文端]转换为运输层分组。实现的方法是将应用报文划分为小块，并且为每块加上一个运输层首部以生成运输层报文段。在发送端系统中，运输层将这些报文段传输给网络层，网络层对这些字段进行封装，变为网络层分组，并且向目的地发送。网络路由器作用域该数据报的网络层字段，不检查封装在该数据爆的运输层报文端的字段。在接收端，网络层从数据报中提取运输层报文段。并且为报文段向上交运输层。运输层处理接受到的报文段。使得该报文段中的数据为接受应用进程使用
运输层和网络层的关系 网络层为运输层提供最基本的数据传送服务，而运输层则在网络层的基础上提供更高层次的、更可靠的通信服务。
因特网运输层概述 应用开发人员在生成套接字的时候必须选定是udp还是tcp。将运输层分组称为报文段。也可以将tcp的运输层分组称为报文段，将udp的分组称为数据报文。将TCP和UDP的分组统称为报文段，而将数据报名称保留给网络层分组
多路复用和多路分解 网络层提供的主机到主机交付服务延伸到运行在主机上的应用程序提供进程到进程的交付服务。多路复用和多路分解服务是所有计算机网络都需要的
在目的主机，运输层从网络层接受报文段，运输层将这些报文中的数据交付给主机上运行的应用程序进程。
多路分解: 每个运输层报文段中具有几个字段，在接收端，运输层会检查这些字段，标识出接收套接字。从而将报文段定向到该套接字。将运输层报文段中的数据交付到正确的套接字的工作叫做多路分解
多路复用: 在源主机从不同的套接字中收集数据块，并为每个数据封装上首部信息，从而生成报文段。然后将报文段传递到网络层，这种工作叫做多路复用
在主机上的每个套接字能够分配一个端口号，当报文段到达主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字。然后报文段中的数据通过套接字进入其所连接的进程。如我们将看到的那样，UDP大体上是这样做的
无连接的多路复用和多路分解 一个udp是由一个二元组全面标识的，该二元组包含一个目的的ip地址和一个目的的端口号，因此，如果两个udp报文段有不同源ip地址和源端口号，但是具有相同的目的ip地址和目的端口号，那么这两个报文段通过相同的目的套接字被定向到相同的目的进程。
面向连接的多路复用和多路分解 TCP套接字和 UDP套接字之间的一个细微差别是，TCP套接字是由一个四元组(源IP地址源端口号，目的IP地址，目的端口号)来标识的。当一个TCP报文段从网络到达一台主机时，该主机使用全部4个值来将报文段定向(分解)到相应的套接字。两个具有不同源里地址或源端口号的到达TCP报文段将被定向到两个不同的套接字，除非TCP报文段携带了初始创建连接的请求。
web服务器与TCP 连接套接字与进程之间并非总是有着一一对应的关系。事实上，当今的高性能Web服务器通常只使用一个进程，但是为每个新的客户连接创建一个具有新连接套接字的新线程。(线程可被看作是一个轻量级的子进程)
如果客户与服务器使用持续HTTP，则在整条连接持续期间，客户与服务器之间经由同一个服务器套接字交换HTTP报文。然而，如果客户与服务器使用非持续HTTP，则对每一对请求/响应都创建一个新的TCP连接并在随后关闭，因此对每一对请求/响应创建一个新的套接字并在随后关闭。
无连接运输:UDP UDP报文段结构 应用层数据占用UDP报文段的数据字段。通过端口号可以使得目的主机将应用数据交给运行在目的端系统的主机中的相应进程。
长度字段指示了在udp报文段中的字节数。
UDP检验和 在数据接收端，接收端会按照相同的规则对接收端的udp数据包进行计算，得到一个新的校验和值，然后接收方会将这个新的校验和值和数据包中携带的原始校验和值进行比较，如果相等，则说明在传输过程中没有发生错误。
udp校验和只能提供一定程度的错误检测功能，并不能保证数据的可靠性传输。udp协议不存在重传机制。在使用udp协议进行数据传输的时候，需要应用层来负责处理可能出现的错误和丢包的数据包。
可靠数据连接运输原理 可靠数据传输的实现问题不仅在运输层中出现，也会在链路层以及应用层中出现。数据可以通过一条可靠的信道进行传输，借助于可靠信道，传输数据比特不会受到损坏或者丢失。
实现这种服务抽象的是可靠数据运输协议。
构造可靠数据传输协议 经完全可靠信道数据传输: rdt1.0 它主要基于完全可靠的信道进行数据传输。在这个协议中，主要有传输端和接收端两个部分。传输端等待上层传递数据，一旦收到数据，就将其打包成封包并发送出去。接收端在收到封包后，会将其解开，然后将数据发送到上层应用。
RDT1.0假设底层的信道是完全可靠的，即没有比特错误和分组丢失，数据分组会按照顺序到达。发送方和接收方都有各自的有限状态机（FSM）来控制数据的传输和接收。
经具有比特差错信造的可靠数据传输: rdt2.0 ARQ[自动重传请求协议]: 当传输介质不能保证数据的通信质量时（例如，在无线通信中），就需要采用错误控制方法来纠正传输过程中可能产生的错误。ARQ 就是一种广泛使用的错误控制方法。
差错检测: 使接收方检测到何时出现了比特差错
接收方反馈: 让接收方提供明确的反馈信息给发送方
重传: 接收方收到有差错的分组时，发送方将重传该分组文
停等协议: 发送方每发送一个数据分组后，就会进入等待状态，直到收到接收方的确认消息。如果收到 NAK 消息，发送方会重传上一个数据分组。该方法简单但效率较低，因为发送方在等待确认消息时不能发送新的数据分组。
考虑到 ACK 或 NAK 分组受损的可能性
经具有比特差错的丢包信道的可靠数据传输: rdt3.0 超时重传：为了处理数据丢失的情况，RDT3.0使用了超时重传机制。如果在预定的时间内没有收到确认信息，发送方会重新发送数据包。
状态机：RDT3.0的操作可以通过发送方和接收方的状态机来描述。状态机定义了在不同情况下应该采取的动作，比如发送数据、等待确认或者重传数据包。
流水线可靠数据传输协议 必须增加序号范围，因为每个输送中的分组(不计算重传的)必须有一个唯一的序号，而且也许有多个在输送中的未确认报文。
协议的发送方和接收方两端也许不得不缓存多个分组。发送方最低限度应当能缓冲那些已发送但没有确认的分组。接收方或许也需要缓存那些已正确接收的分组。
所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。解决流水线的差错恢复有两种基本方法是:回退N步(Go-Back-N，CBN)和选择重传(SelectiveRepeat，SR)。
回退N步 将基序号(base)定义为最早未确认分组的序号，将下一个序号(nextseqmum)定义为最小的未使用序号(即下一个待发分组的序号)，则可将序号范围分割成4段。在[0，base-1]段内的序号对应于已经发送并被确认的分组。[base，nextseqnum-1]段内对应已经发送但未被确认的分组。[nextseqnum，base+N-1]段内的序号能用于那些要被立即发送的分组，如果有数据来自上层的话。最后，大于或等于base+N的序号是不能使用的，直到当前流水线中未被确认的分组(特别是序号为base的分组)已得到确认为止。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/021be0c1c0a60abd9964ce47d71e0541/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcfbb5d92ffe66bffcb71a3091fa3490/" rel="bookmark">
			VsCode个人插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Auto Rename Tag =&gt; 同时修改标签
Rainbow Brackets =&gt; 不同层级不同括号颜色
Dracula Official =&gt; 个人比较喜欢的一款主题
Error Lens =&gt; 错误信息显示
ES7+REACT/Redux/React-Native=&gt;react开发插件
ESLINT
Indenticator=&gt;方便看结构
Prettier Formatter for Visual Studio Code =&gt; 格式化插件可以配置
sneak-mark =&gt; 标注出英文语句中的中文标点符号
待续...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20081de5b5db34735557333a3139f34d/" rel="bookmark">
			php质量工具系列之paslm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Psalm是一个静态分析工具，深入程序，尽可能多地找到与类型相关的bug
混合类型警告
Intelligent logic checks
属性初始化检查
Taint analysis
Language Server
Automatic fixes
Automatic refactoring
安装 composer global require --dev vimeo/psalm # 当使用这个方式安装时，如果psalm的依赖和项目依赖有冲突，可使用phar安装 composer global require --dev psalm/phar 注意：
linux上，需要将全局composer的可执行目录加入环境变量，目录路径一般是/tmp/composer/vendor/bin
环境变量配置
windows上，只需在环境变量path中加上composer路径，目录路径一般是
%APPDATA%\Composer\vendor\bin
初始化
./vendor/bin/psalm --init psalm扫描你的项目，评估适合项目的错误级别，并生成psalm.xml文件用于后续的扫描配置
执行 ./vendor/bin/psalm #或者扫描某个或某些文件 ./vendor/bin/psalm file1.php [file2.php...] ./vendor/bin/psalm --show-info=true 参数解释：
–show-info 显示非异常的分析结果
#针对特定问题给出psalm的解决方案，可参考其结果进行代码修复 ./vendor/bin/psalm --alter --issues=MissingReturnType --dry-run 参数解释：
–issues all 显示全部问题解决方案；其他问题type，多个间以逗号分隔，如 MissingReturnType,InvalidArgument
插件 查看可用插件列表 composer search -t psalm-plugin '.' 安装 composer global require --dev &lt;plugin-vendor/plugin-package&gt; 启用 vendor/bin/psalm-plugin enable plugin-vendor/plugin-package 禁用 vendor/bin/psalm-plugin disable plugin-vendor/plugin-package 显示已安装列表 vendor/bin/psalm-plugin show 配置 以下是我的配置，大家可以根据情况选择配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20081de5b5db34735557333a3139f34d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76235e5531cfba7ef1a9f0ddea96fe34/" rel="bookmark">
			CSS学习笔记：flex布局（弹性布局）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置flex布局 父元素添加display: flex
使用justify-content调节元素在主轴的对齐方式 给父元素添加justify-content属性，取值如下
用于调节子元素在主轴方向（水平方向）的对齐方式
使用align-items调节元素在侧轴的对齐方式 给父元素添加align-items属性，取值如下
用于调节子元素在侧轴方向（垂直方向）的对齐方式
align-self： 控制某个弹性盒子在侧轴的对齐方式 注意：align-self是给子元素添加的属性，用于单独控制该元素在侧轴的对齐方式
使用flex属性修改弹性盒子伸缩比 代码示例
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * { margin: 0; padding: 0; } .box { display: flex; height: 300px; border: 1px solid #000; } .box div { height: 300px; } .box div:nth-child(1) { width: 50px; background-color: pink; } .box div:nth-child(2) { /* 占用父级剩余尺寸的3/4 */ flex: 3; background-color: skyblue; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76235e5531cfba7ef1a9f0ddea96fe34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57f9e4f6c1248291182cf4d65914cad5/" rel="bookmark">
			【工具】JAVA请求头Headers工具随机 生成UA 解析headers为map
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【工具】JAVA请求头Headers工具随机 生成UA 解析headers为map 随机生成UA
成品
Mozilla/5.0 (Linux; Android 11; Mi 14 Build/TKQ1.221114.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/92.0.6827.294 Mobile Safari/537.36 XWEB/1220067 MMWEBSDK/20240301 MMWEBID/4001 MicroMessenger/8.0.48.2580(0x28003036) WeChat/arm64 Weixin NetType/WIFI Language/zh_CN ABI/arm64 随机生成UA用法
UA = Mozilla/5.0 (Linux; Android {Android版本}; {Android手机型号} Build/TKQ1.221114.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/{Chrome内核版本} Mobile Safari/537.36 XWEB/1220067 MMWEBSDK/20240301 MMWEBID/4001 MicroMessenger/8.0.48.2580(0x28003036) WeChat/arm64 Weixin NetType/{NetType} Language/zh_CN ABI/arm64 UA = StrUtil.format(UA, 随机Ua参数); 解析headers为map 用法 """ Host: work.weixin.qq.com sec-ch-ua: "Chromium";v="122", "Not(A:Brand";v="24", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57f9e4f6c1248291182cf4d65914cad5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4db9f006a91d92350a3a0ba3281d91cf/" rel="bookmark">
			一篇文章搞懂MySQL的分库分表，从拆分场景、目标评估、拆分方案、不停机迁移、一致性补偿等方面详细阐述MySQL数据库的分库分表方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导航：
【Java笔记+踩坑汇总】Java基础+JavaWeb+SSM+SpringBoot+SpringCloud+瑞吉外卖/黑马旅游/谷粒商城/学成在线+设计模式+面试题汇总+性能调优/架构设计+源码-CSDN博客
目录
一、分库分表基本概念
二、分库分表的场景和核心思想
三、分库分表具体步骤
3.1 分库分表的原则：能不分就不分
3.2 目标评估
3.3 表拆分
3.3.1 业务层面拆分
3.3.1.1 混合业务拆分
3.3.1.2 冷热分离
3.3.2 数据层面拆分
3.4 分表字段（sharding_key）选择
3.5 代码改造
3.6 数据迁移
3.6.1 增量同步
3.6.2 全量同步
3.7 数据一致性校验和补偿
3.8 灰度切读
3.9 停旧库、写新库
一、分库分表基本概念 只分表：
单表数据量大，读写出现瓶颈，这个表所在的库还可以支撑未来几年的增长。
只分库：
整个数据库读写出现性能瓶颈，例如数据库连接数被打满了（MySQL最大连接数默认150），或者并发量太大导致单个数据库已经无法满足日常的读写需求，就需要将整个库拆开。
分库分表：
单表数据量大，所在库也出现性能瓶颈，就要既分库又分表。
垂直拆分：
把字段分开。例如spu表的pic字段特别长，建议把这个pic字段拆到另一个表（同库b不同库。
水平拆分：
把记录分开。例如表数据量到达百万，我们拆成四张20万的表。
二、分库分表的场景和核心思想 一般情况下，单表数据量到达千万级别，就可以考虑分库分表了。
具体是否需要分库分表还是要看具体的业务场景，例如流水表、记录表，数据量非常容易到达千万级、亿万级，需要在设计数据库表的阶段就进行分表，还有一些表虽然数据量只有几百万，但字段非常多，而且有很多text、blog格式的字段，查询性能也会很慢，可以考虑分库分表。
数据量增长情况数据表类型优化核心思想数据量为千万级，是一个相对稳定的数据量状态表能不拆就不拆读需求水平扩展数据量为千万级，可能达到亿级或者更高流水表业务拆分，面向分布式存储设计数据量为千万级，可能达到亿级或者更高流水表设计数据统计需求存储的分布式扩展数据量为千万级，不应该有这么多的数据配置表小而简，避免大一统 三、分库分表具体步骤 3.1 分库分表的原则：能不分就不分 1.优先MySQL调优，能不分就不分。
数据量能稳定在千万级，近几年不会到达亿级，其实是不用着急拆的，先尝试MySQL调优，优化读写性能。只有在MySQL调优已经无法解决慢查询问题时，才可以考虑分库分表。
MySQL调优：
【MySQL调优】如何进行MySQL调优？一篇文章就够了！-CSDN博客
2.分片数量尽量少。
分片尽量均匀分布在多个 DataHost 上，因为一个查询 SQL 跨分片越多，则总体性能越差，虽然要好于所有数据在一个分片的结果，只在必要的时候进行扩容，增加分片数量。
3.不要一个事务里跨越多个分片查询
尽量不要在一个事务中的 SQL 跨越多个分片，分布式事务一直是个不好处理的问题。
3.2 目标评估 评估需要拆分成几个库、几个表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4db9f006a91d92350a3a0ba3281d91cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c62a55aef227bdd30f51280b223f4f1b/" rel="bookmark">
			【机器学习结合AI绘画工具】——开启艺术创作的新纪元
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、AI绘画工具的发展历程
二、AI绘画工具的技术原理
实例说明
三、AI绘画工具在艺术创作中的应用
实例网站
四、AI绘画工具的影响与未来展望
结论
机器学习和人工智能（AI）在过去的十年里取得了显著的进展。特别是在艺术创作领域，AI绘画工具的出现为艺术家和设计师提供了新的创作方式和可能性。这些工具利用深度学习算法，能够自动生成或辅助创作高质量的艺术作品。
一、AI绘画工具的发展历程 AI绘画工具的发展可以追溯到数十年前的计算机艺术实验。但真正的突破发生在近年来，得益于深度学习和神经网络技术的进步，AI绘画工具从简单的图像处理发展到能够自主创作出风格各异的艺术作品。
早期实验：最初的计算机艺术尝试主要集中在图形生成和图像处理上，利用算法生成简单的几何图形和抽象艺术。这一阶段的作品多是基于数学函数和几何原理的视觉表现。神经网络的引入：随着神经网络和深度学习技术的成熟，AI开始能够识别和学习艺术作品中的复杂模式，模拟不同艺术家的风格。此时的AI工具主要依赖于卷积神经网络（CNNs），能够从大量图像中提取特征。生成对抗网络（GANs）：GANs的出现使AI绘画工具能够生成高质量的图像，甚至在没有明确指令的情况下创作出独特的艺术作品。GANs的引入不仅提升了图像生成的质量，还丰富了AI创作的多样性。 二、AI绘画工具的技术原理 AI绘画工具主要依赖于深度学习和神经网络，尤其是生成对抗网络（GANs）和变分自动编码器（VAEs）。这些技术使得AI能够理解、模仿并创造复杂的艺术作品。
生成对抗网络（GANs）：GANs由生成器和判别器两个部分组成。生成器负责创建图像，而判别器则评估这些图像的真实性。两者通过不断的对抗训练，使得生成器能够创造出愈加逼真的图像。 生成器：通过接受随机噪声作为输入，生成器生成假图像。其目标是生成的图像能够欺骗判别器，使其认为是真实图像。判别器：判别器接收真实图像和生成器生成的假图像，通过训练学习区分两者，并输出一个真实度评分。对抗训练：生成器和判别器在训练过程中相互对抗，不断提高各自的能力。最终，生成器生成的图像几乎无法被判别器分辨为假图像。 变分自动编码器（VAEs）：VAEs通过编码和解码过程，从输入数据中学习潜在的特征表示，进而生成新的图像。与GANs不同，VAEs的主要优势在于其生成图像的连续性和潜在空间的可解释性。 编码器：将输入图像编码为一个潜在表示（latent representation），即一个低维的特征向量。解码器：将潜在表示解码为新的图像，通过优化重建误差，使得生成的图像与输入图像尽可能相似。变分方法：引入了概率模型，通过对潜在表示的正则化，增强模型的生成能力和稳定性。 实例说明 以下是使用Python和TensorFlow构建简单GAN的示例代码：
import tensorflow as tf from tensorflow.keras.layers import Dense, Reshape, Flatten, Conv2D, Conv2DTranspose, LeakyReLU, Dropout from tensorflow.keras.models import Sequential import numpy as np import matplotlib.pyplot as plt # 生成器模型 def build_generator(): model = Sequential() model.add(Dense(256, input_dim=100)) model.add(LeakyReLU(alpha=0.2)) model.add(Dense(512)) model.add(LeakyReLU(alpha=0.2)) model.add(Dense(1024)) model.add(LeakyReLU(alpha=0.2)) model.add(Dense(28 * 28 * 1, activation='tanh')) model.add(Reshape((28, 28, 1))) return model # 判别器模型 def build_discriminator(): model = Sequential() model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c62a55aef227bdd30f51280b223f4f1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f587e22fab3d7959fc419be54624585/" rel="bookmark">
			【机器学习】Python中的决策树算法探索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页: 鑫宝Code
🔥热门专栏: 闲话杂谈｜ 炫酷HTML | JavaScript基础 ​💫个人格言: "如无必要，勿增实体" 文章目录 Python中的决策树算法探索引言1. 决策树基础理论1.1 算法概述1.2 构建过程 2. Python中实现决策树的库介绍2.1 Scikit-Learn2.2 XGBoost &amp; LightGBM 3. 实战案例分析3.1 数据准备与预处理3.2 模型构建与训练3.3 预测与评估 4. 模型评估与调优方法4.1 评估指标4.2 调优策略 5. 局限性与未来展望5.1 局限性5.2 未来展望 结语 Python中的决策树算法探索 引言 决策树作为机器学习中的一种基础且强大的算法，因其易于理解和实现、能够处理分类和回归任务的特性而广受欢迎。本文旨在深入浅出地介绍决策树算法的基本原理，并通过Python编程语言实践其应用，帮助读者掌握如何利用Python构建及优化决策树模型。本文预计分为以下几个部分：决策树基础理论、Python中实现决策树的库介绍、实战案例分析、模型评估与调优方法，以及决策树算法的局限性与未来展望。
1. 决策树基础理论 1.1 算法概述 决策树是一种树形结构，其中每个内部节点表示一个特征上的测试，每个分支代表一个测试结果，而每个叶节点则代表一种类别或输出值。通过一系列的特征判断，决策树从根到某个叶节点的路径就对应了一个实例的分类或回归预测。
1.2 构建过程 特征选择：信息增益、基尼不纯度等指标用于衡量特征的重要性。树的生成：递归地选择最优特征进行分割，直到满足停止条件（如节点纯净度达到阈值、达到最大深度等）。剪枝：为防止过拟合，通过预剪枝和后剪枝减少树的复杂度。 2. Python中实现决策树的库介绍 2.1 Scikit-Learn Scikit-Learn是Python中最广泛使用的机器学习库之一，提供了简单易用的API来实现决策树算法。主要类包括DecisionTreeClassifier用于分类任务，DecisionTreeRegressor用于回归任务。
2.2 XGBoost &amp; LightGBM XGBoost和LightGBM是两个高级的梯度提升框架，它们虽不是直接的决策树库，但通过集成多棵决策树实现了更强大的学习能力。这些库特别适合大规模数据集和高维度特征空间。
3. 实战案例分析 3.1 数据准备与预处理 以经典的Iris数据集为例，首先导入必要的库并加载数据：
import pandas as pd from sklearn.datasets import load_iris from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f587e22fab3d7959fc419be54624585/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/2/">«</a>
	<span class="pagination__item pagination__item--current">3/71</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/4/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>