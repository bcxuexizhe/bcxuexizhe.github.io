<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/583a6d0743e76dbb18e03f8eadd68d1b/" rel="bookmark">
			【链表】：链表的带环问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎁个人主页：我们的五年
🔍系列专栏：数据结构
🌷追光的人，终会万丈光芒
前言：
链表的带环问题在链表中是一类比较难的问题，它对我们的思维有一个比较高的要求，但是这一类问题分析起来也是很有趣的，下面我就给大家讲一下链表的带环问题，并且带上几个例题进行分析。
喜欢的铁子们可以点点关注，感谢大家的支持。
🏝1.链表的分类： ●根据链表，单向，双向，带头，不带头，循环，不循环，可以把链表分成八种。虽然说有八种链表，但是常用的只有：不带头单向不循环链表，带头双向循环链表。
●但是今天我们要看的是不带头单向不循环，但是内部带环的问题。
🏝2.判断链表是否带环？ 【LeetCode】第141题-链接：https://leetcode.cn/problems/linked-list-cycle/description/
🏜问题描述： 🏜实现代码： /**
* Definition for singly-linked list.
* struct ListNode {
* int val;
* struct ListNode *next;
* };
*/
typedef struct ListNode ListNode;
bool hasCycle(struct ListNode *head) {
ListNode* fast=head;
ListNode* slow=head;
while(fast&amp;&amp;fast-&gt;next)
{
fast=fast-&gt;next-&gt;next;
slow=slow-&gt;next;
if(fast==slow)
return true;
}
return false;
}
🏜问题分析： 1.快慢指针都从头开始走，慢指针一次走一步，快指针一次走两步。
2.当fast进环的时候，slow还在环外。
3.当slow金环的时候，fast在环中的某个位置。也就是说，fast和slow差了N个位置，当fast和slow都进环的时候，就变成了追击问题。
4.slow每次走一步，fast每次走两步，也就是fast去追slow，把slow看成静止的，fast就一次往前面走一步，所以fast一定可以追上slow。
🏝3.如果fast一次走三步，slow一次走一步，一定可以追上吗？ 这里先给出答案：一定可以追上！
当slow刚刚进环的时候，fast在环的某个位置，此时fast开始追击slow，还是把slow看成静止的，fast每次往相对于slow追击两步。
开始时，slow与fast相差N
1.当N为偶数时：
因为每次fast走三步，slow走一步。也就是N每次-2。因为N为偶数，所以是一定可以追上的。
2.当N为奇数，环的周长为C为奇数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/583a6d0743e76dbb18e03f8eadd68d1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b80b7614400090840c4f0fb32fcaa964/" rel="bookmark">
			Angular进阶-NVM管理Node.js实现不同版本Angular环境切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、NVM介绍 1. NVM简介 Node Version Manager（NVM）是一个用于管理多个Node.js版本的工具。它允许用户在同一台机器上安装和使用多个Node.js版本，非常适合需要同时进行多个项目的开发者。NVM是开源的，支持MacOS、Windows和Linux操作系统。
2. NVM原理 NVM通过修改PATH环境变量，控制不同命令行会话中使用的Node.js版本。它不需要管理员权限，可以在用户的主目录中安装Node.js版本，并将它们隔离开来。通过执行简单的命令，用户可以选择正在使用的Node.js版本，这使得在不同版本之间切换变得非常简单。
3. NVM的优势 版本管理灵活：允许在同一系统中安装多个Node.js版本，并能轻松切换。环境隔离：每个Node.js版本都在用户空间内独立安装，不会互相影响。无需管理员权限：用户可以在其主目录下安装和维护Node.js版本，无需管理员权限。支持自动切换：通过.nvmrc文件自动切换项目所需的Node.js版本。 二、常用Node.js版本对照 1. Node.js和Vue版本对照表 Vue.js 版本推荐 Node.js 版本兼容 TypeScript 版本Vue 3.xNode.js 12 或更高TypeScript 3.9 或更高Vue 2.6Node.js 10 或更高TypeScript 3.5 或更高Vue 2.5Node.js 10TypeScript 2.6 或更高Vue 2.4 及以下Node.js 8TypeScript 不推荐 注意：
Vue 3.x 被完全重写以支持 TypeScript，建议使用 TypeScript 3.9 或更高版本。Vue 2.5 引入了对 TypeScript 的改进支持，推荐至少使用 TypeScript 2.6。较早的 Vue.js 版本（2.4 及以下）并没有针对 TypeScript 提供优化支持，在这些版本中使用 TypeScript 需要额外的配置，不推荐。 2. Node.js和Angular版本对照表 Angular作为一个更为严格的框架，其版本通常要求较新的Node.js版本。以下是Angular版本与Node.js版本的推荐对照表：
Angular 版本推荐 Node.js 版本兼容 TypeScript 版本Angular 17.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b80b7614400090840c4f0fb32fcaa964/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/047cfa4448b03692f9c8955ad9b23c83/" rel="bookmark">
			Python-VBA函数之旅-open函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、open函数的常见应用场景
二、open函数使用注意事项
三、如何用好open函数？
1、open函数：
1-1、Python：
1-2、VBA：
2、推荐阅读：
个人主页：神奇夜光杯-CSDN博客 一、open函数的常见应用场景 open函数在Python中是一个非常重要的内置函数，用于打开文件以便进行读取、写入或追加等操作，常见的应用场景有：
1、读取文件内容：当你需要从一个文件中读取数据(如文本、配置、日志等)时，你可以使用 open()函数以只读模式('r')打开文件，并使用文件对象的 read()、readline()或readlines()方法来读取内容。
2、写入文件内容：如果你需要将数据写入一个文件(如生成报告、保存配置、记录日志等)，你可以使用open()函数以写入模式('w')或追加模式('a')打开文件，并使用文件对象的write()方法来写入内容。
3、处理二进制文件：对于需要处理图像、音频、视频等二进制文件时，你可以使用'b'标志来以二进制模式打开文件，这允许你读取和写入原始的字节数据。
4、逐行读取文件：当文件非常大或你只需要逐行处理文件时，可以使用readline()方法逐行读取文件，这可以减少内存使用并提高性能。
5、文件搜索和替换：你可以使用open()函数读取文件内容，然后使用字符串操作或正则表达式来搜索和替换文本，完成修改后，可以将新内容写回到原始文件或新文件中。
6、配置和数据存储：配置文件(如INI文件、JSON文件或YAML文件)和数据文件(如CSV文件)经常使用open()函数进行读取和写入，这些文件通常包含应用程序的配置信息或用户数据。
7、文件复制和移动：虽然open()函数本身不直接支持文件复制和移动，但你可以使用它结合其他文件操作函数(如shutil.copy()或os.rename())来实现这些功能。
8、文件锁定和并发访问：在多线程或多进程环境中，你可能需要锁定文件以防止并发访问导致的冲突。虽然Python标准库没有直接提供文件锁定机制，但你可以使用第三方库(如`fcntl`在Unix系统上)或操作系统特定的命令来实现文件锁定。
9、临时文件处理：使用open()函数与`tempfile`模块结合可以创建和管理临时文件，这对于需要临时存储数据的场景(如数据处理、文件转换等)非常有用。
10、与标准输入/输出交互：虽然不直接通过open()函数实现，但你可以使用文件对象与Python的标准输入(`sys.stdin`)和标准输出(`sys.stdout`)进行交互，这些文件对象与常规文件对象类似，允许你以类似的方式读取和写入数据。
11、文件备份与恢复：你可以使用open()函数来读取原始文件的内容，并将其写入另一个文件以创建备份；同样地，你也可以从备份文件中读取内容并将其写入原始文件以恢复数据。
12、文件加密和解密：在处理敏感数据时，加密是一个重要的安全措施。你可以使用open()函数来读取未加密的文件，使用加密算法对其进行加密，并将加密后的数据写入另一个文件；类似地，你也可以读取加密的文件，使用解密算法恢复原始数据，并将其写入一个新文件。
13、文件传输：在网络编程中，你可能需要从一个服务器读取文件并将其写入到另一个服务器，或者从一个文件读取数据并通过网络发送，open()函数可以用于这些场景中的文件读取和写入操作。
14、文本处理和数据分析：使用open()函数读取大量文本数据(如日志文件、文档等)，并使用Python的文本处理库(如正则表达式、NLTK等)进行分析；也可以结合数据科学库(如Pandas、NumPy等)进行更高级的数据处理和分析。
15、文件映射：对于非常大的文件，你可能希望将它们映射到内存中以便更高效地访问，虽然这不是open()函数直接提供的功能，但你可以使用`mmap`模块来映射已打开的文件。
16、监视文件变化：虽然这通常不是open()函数直接提供的功能，但你可以结合其他库(如`watchdog`)来监视文件系统的变化，包括新文件的创建、文件的修改或删除等。
17、网络文件和特殊设备： open()函数不仅限于处理本地文件系统上的文件，在某些情况下，你可以使用它来访问网络上的文件(如使用`ftplib`或`smbclient`等库)或特殊设备(如串口设备、数据库连接等)，这通常涉及到将设备或网络连接抽象为文件描述符或文件对象，并使用open()函数或类似机制进行访问。
总之，由于open()函数的灵活性和强大性，其在Python编程中几乎无处不在，几乎任何涉及文件操作的场景都会使用到它。
二、open函数使用注意事项 在使用Python的open()函数处理文件时，为了确保代码的正确性、安全性和性能，需注意以下事项：
1、文件路径和名称：确保文件路径和名称是正确的，并且指向了有效的文件；使用原始字符串(在字符串前加上`r`)来处理包含反斜杠(`\`)的Windows路径，以避免转义字符的问题。
2、文件打开模式：仔细选择正确的文件打开模式(如'r'、'w'、'a'、'b'等)，错误的模式可能导致数据丢失或无法访问文件；当你需要在读取和写入之间切换时，使用'r+'、'w+'或'a+'模式。
3、文件关闭：使用`with`语句来自动关闭文件，即使发生异常也是如此，这可以避免资源泄露和潜在的安全风险；避免在`with`语句之外打开文件并忘记关闭它。
4、异常处理：当处理文件时，应准备好捕获并处理可能出现的异常，如`FileNotFoundError`、`PermissionError`等；使用`try-except`块来捕获和处理这些异常。
5、编码问题：在读取或写入文本文件时，确保指定了正确的字符编码(如'utf-8')，错误的编码可能导致乱码或解码错误；如果不确定文件的编码，可以尝试使用`chardet`等库来检测文件的编码。
6、二进制文件：当处理二进制文件时(如图像、音频、视频等)，应使用二进制模式(在模式字符串后添加'b')；避免在二进制模式下读取或写入文本数据，这可能导致数据损坏或不可读。
7、文件锁定和并发：在并发环境中，多个进程或线程可能同时访问同一个文件，为了避免数据竞争和不一致，可以考虑使用文件锁定机制；注意，Python标准库并没有直接提供文件锁定的功能，但你可以使用第三方库(如`fcntl`在Unix系统上)来实现。
8、文件大小和内存使用：在处理大文件时，避免一次性读取整个文件到内存中，使用逐行读取、块读取或其他内存友好的方法；考虑使用生成器或迭代器来逐步处理文件内容，以减少内存使用。
9、权限和安全性：确保你有足够的权限来读取或写入文件，如果文件受到保护或具有特定的权限设置，你可能需要额外的权限或认证；避免在代码中硬编码敏感信息(如密码、密钥等)，特别是当这些信息与文件访问相关时。
10、备份和恢复：在修改或删除文件之前，考虑先备份原始文件，这可以防止意外数据丢失或损坏；确保你有一种机制来恢复意外删除或修改的文件。
总之，只有牢记这些注意事项，你才能更安全、更有效地使用Python的open()函数来处理文件。
三、如何用好open函数？ 要用好Python中的open()函数，请遵循一下建议：
1、始终使用`with`语句：使用`with`语句可以确保文件在操作完成后被正确关闭，即使发生异常也是如此，这是处理文件时的最佳实践。
2、明确指定文件打开模式：根据你要进行的操作(读取、写入、追加、二进制等)明确指定文件打开模式。
3、异常处理：使用`try-except`块来处理可能出现的异常，如FileNotFoundError、PermissionError等。
4、编码问题：当读取或写入文本文件时，确保指定正确的字符编码，对于大多数情况，建议使用UTF-8编码。
5、避免硬编码：避免在代码中硬编码文件路径、文件名或打开模式，将这些值放在配置文件、环境变量或命令行参数中，以便更容易地修改它们。
6、二进制文件处理：当处理二进制文件时，使用二进制模式(在模式字符串后添加'b')。
7、文件读写效率：对于大文件，避免一次性读取整个文件到内存中，使用逐行读取、块读取或其他内存友好的方法；写入大文件时，可以考虑使用write()方法的缓冲区(如果未指定，则使用默认的缓冲区大小)，或者调用flush()方法来手动刷新缓冲区。
8、文件锁定：在并发环境中，如果需要确保文件访问的原子性，可以考虑使用文件锁定机制，但是请注意，Python标准库并不直接提供跨平台的文件锁定机制，你可能需要使用第三方库。
9、安全性：避免在代码中硬编码敏感信息，如密码或密钥；如果你的应用程序需要处理来自不受信任来源的文件，请确保对它们进行适当的验证和清理，以防止安全漏洞(如目录遍历攻击)。
10、备份和版本控制：在修改或删除重要文件之前，始终备份原始文件；使用版本控制系统(如Git)来跟踪和管理文件的变化，以便在需要时可以轻松地回滚到以前的版本。
11、代码可读性和可维护性：使用有意义的变量名来代表文件对象；注释你的代码，解释你正在做什么以及为什么这样做；遵循一致的代码风和最佳实践，以提高代码的可读性和可维护性。
总之，通过遵循这些最佳实践和建议，你可以更好地利用Python中的open()函数来处理文件，并确保你的代码是健壮、安全和易于维护的。
1、open函数： 1-1、Python： # 1.函数：open # 2.功能：用于打开文件，返回一个文件读写对象，然后对文件进行相应读写操作 # 3.语法：open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) # 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/047cfa4448b03692f9c8955ad9b23c83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45928ea0c7fb643f997c0b0f83d91afa/" rel="bookmark">
			微调llama 3 — PEFT微调和全量微调
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. llama 3 微调基础 1.1 llama 3 简介 官方blog
llama 3 目前有两个版本：8B版和70B版。8B版本拥有8.03B参数，其尺寸较小，可以在消费者硬件上本地运行。
meta-llama/Meta-Llama-3-8Bmeta-llama/Meta-Llama-3-70B超过400B个参数的第三个版本目前仍在训练中…… Llama 3与Llama 2具有相同的架构，但词汇表要大得多，包含128k entries，而Llama 2只有32k entries，根据Meta的说法，词汇表的扩展显著提高了模型表现。Llama 3的预训练数据包含5%的高质量非英语数据。注意：Meta在model card中仍然提到Llama 3更适合用于英语任务。
另一方面，词汇表的扩展意味着token embeddings需要更多的数据才能被训练的更准确。Meta在15T tokens上训练Llama 3。相比之下，Llama 2只在2T tokens上训练，Google Gemma在6T tokens训练，这在当时似乎已经很多了。
模型的性能表现如下图所示：
1.2 llama 3 8b Fully Fine-tuning内存占用分析 Fully Fine-tuning an LLM需要更新其所有参数，这种微调需要大量的内存。
模型需要被完全加载到 GPU 内存中此外，通常用于微调 LLMs 的优化器 AdamW 会为模型中的每个参数创建并存储 2 个参数在 GPU 内存中并且我们还需要存储在微调过程中创建的张量，即激活值，以便在反向传播过程中用于更新模型参数的梯度。 对Llama 3 8B进行微调，例如，批量大小为8，序列长度为512，将消耗128.87GB的显存。注意：这个内存消耗是一个估计值，没有考虑任何的优化，比如梯度检查点和张量并行。
modelloading the modeloptimizer statesactivationstotalllama 3 8b14.96GB59.83GB54.08GB128.87GB （估算大型语言模型（LLM）内存消耗的计算方法）
幸运的是，我们可以很容易地减少这三种参数的内存消耗：
Optimizer states：默认情况下，AdamW 的参数为 float32，每项占用 4 字节。AdamW-8bit 是另一种不错的选择，它将参数量化为 8 位，即减少了内存消耗从 59.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45928ea0c7fb643f997c0b0f83d91afa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b705657fca673fdfa92fd2600e5d478e/" rel="bookmark">
			（二十一）springboot实战——Spring AI劲爆来袭
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本节内容是关于Spring生态新发布的Spring AI的介绍，Spring AI 是一个面向人工智能工程的应用框架。其目标是将 Spring 生态系统的设计原则，如可移植性和模块化设计，应用到人工智能领域，并推广使用普通的Java对象（POJOs）作为构建应用程序的基础。其官方文档地址如下：
Spring AI
目前其集成了主流的Chat Models（聊天模型）、Text-to-image Models（文生图模型）、Transcription (audio to text) Models（语音转文本模型）、Embedding Models（嵌入式模型）、Vector Databases（向量数据库模型）。通过引入spring-ai-openai-spring-boot-starter启动器，就可以很方便的调用各种ai客户端工具，例如openai、Ollama等文本模型。本节内容以open ai 调用为例。
正文 ①项目工程版本，低版本springboot不支持此功能
版本说明 JDKJDK17springboot3.2.5spring-ai-openai-spring-boot-starter0.8.1 ②使用springboot初始化向导创建一个springboot项目
③引入pom时可能存在无法引入pom依赖的情况，这是因为在maven中心仓库还没有发布此启动器，我们需要配置spring仓库下载springai相关的启动器，本地如果使用了阿里云的maven仓库也需要屏蔽掉
④ 在application.properties中配置OpenAI的相关参数
⑤创建一个open ai请求，用于测试open ai的功能
package com.yundi.atp.controller; import org.springframework.ai.openai.OpenAiChatClient; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import java.util.Map; @RestController public class OpenAiController { @Autowired private OpenAiChatClient openAiChatClient; @GetMapping("/ai/generate") public Map generate(@RequestParam(value = "message", defaultValue = "你叫什么名字？") String message) { return Map.of("generation", openAiChatClient.call(message)); } } ⑥测试open ai chat会话模型，注意，这里需要开启魔法，需要能够访问open ai的地址,集成一个web客户端就能实现自己的chat ai聊天室
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b705657fca673fdfa92fd2600e5d478e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f6868ad2d5b0d9605c32fe18ae427a5/" rel="bookmark">
			数据结构（C）：玩转顺序表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍺0.前言
🎷1.线性表
🎸2.顺序表
📀动态顺序表的实现
💿初始化
💿检查容量是否满了，进行扩容
💿插入：头插和尾插
💿删除：头删和尾删
💿查找
💿销毁
💿打印
💿在某处插入和删除
💎6.结束语
🍺0.前言 言C之言，聊C之识，以C会友，共向远方。各位博友的各位你们好啊，这里是持续分享数据结构知识的小赵同学，今天要分享的数据结构知识是顺序表，在这一章，小赵将会向大家展开聊聊顺序表。✊
🎷1.线性表 线性表 （ linear list ） 是 n 个具有相同特性的数据元素的有限序列。 线性表是一种在实际中广泛使 用的数据结构， 常见的线性表：顺序表、链表、栈、队列、字符串... 线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的， 线性表在物理上存储时，通常以数组和链式结构的形式存储。 也就是说我们今天要谈的顺序表就属于我们的线性表。
🎸2.顺序表 顺序表是用一段 物理地址连续 的存储单元依次存储数据元素的线性结构，一般情况下采用数组存 储。在数组上完成数据的增删查改。 顺序表一般可以分为： 1. 静态顺序表：使用定长数组存储元素。 2.动态顺序表：使用动态开辟的数组存储。 好了下面我们来看看究竟怎么样才是一个顺序表，其实很简单，小赵在这里给各位画个图
怎么样它的样子是不是非常的眼熟，没错我们的线性表其实就是我们的数组。那为什么有静态和动态之分呢？因为一个可以不断增长自己的内存，一个则是固定容量，那该如何实现呢？下面小赵将会带着大家去实现顺序表。
因为静态顺序表其实和动态的线性表差距不大，而且静态顺序表本身也并不常用（开大了浪费，开小了，不够），所以小赵在这里主要带着大家去实现我们的动态顺序表。
📀动态顺序表的实现 那么动态的顺序表该如何实现呢？在这里为了方便我们在后续知道什么时候该进行扩大我们的数组，我们就用我们的结构体去实现我们的线性动态表。
typedef int SeqDataType; struct Seqlist { SeqDataType* a;//指向动态开辟的数组 int size;//顺序表已存元素个数 int capacity;//顺序表容量 }; 那么这样当我们的size 等于我们的capacity的时候我们就可以对我们的数组进行扩容了。
那么对于我们的顺序表，光有这个是不够的，还要具备增删查改，初始化等等功能，下面带着大家一一来实现
💿初始化： 首先是初始化的操作
typedef struct Seqlist SL; void InitSeq(SL* psl) { assert(psl);//防止传入空指针 psl-&gt;a = NULL; psl-&gt;capacity = 0; psl-&gt;size = 0; } 💿检查容量是否满了，进行扩容 void SLCheckcapacity(SL* psl) { assert(psl); if (psl-&gt;capacity == psl-&gt;size) { int newcapacity = (psl-&gt;capacity==0?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f6868ad2d5b0d9605c32fe18ae427a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ede190f5a3af277873ca310bc8b341f/" rel="bookmark">
			只需三步，本地打造自己的AI个人专属知识库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 本文会手把手教你如何部署本地大模型以及搭建个人知识库，使用到的工具和软件有
OllamaOpen WebUIDockerAnythingLLM 本文主要分享三点
如何用Ollama在本地运行大模型使用现代Web UI和本地大模型"聊天"如何打造完全本地化的知识库：Local RAG 读完本文，你会学习到
如何使用最好用的软件Ollama部署本地大模型通过搭建本地的聊天软件，了解ChatGPT的信息是如何流转的RAG的概念以及所用到的一些核心技术如何通过AnythingLLM这款软件搭建完全本地化的数据库 二、ollama的安装以及大模型下载 2.1 安装ollama 官方下载地址：ollama.com/download
当安ollama之后，我们可以通过访问如下链接来判断ollama是否安装成功
arduino 复制代码 http://127.0.0.1:11434/ 2.2 使用ollama运行本地大模型 当安装完成ollama之后，我们就可以在命令行中运行如下命令既可以
arduino 复制代码 ollama run [model name] 其中[model name]就是你想运行的本地大模型的名称，如果你不知道应该选择哪个模型，可以通过model library进行查看。这里我们选择llama2大模型：llama2
考虑到我机器的配置以及不同版本的内存要求，我这里选择7b参数的模型
当我们运行大模型的时候，ollama会自动帮我们下载大模型到我们本地。
三、通过Open WebUI使用大模型 在默认的情况下，我们需要在终端中跟大模型进行交互，但是这种方法太古老了。就跟我们基本不会使用终端命令跟Mysql打交道，而是使用Navcat等客户端和Mysql进行交互。大模型也有其交互客户端，这就是Open WebUI
3.1 安装Open WebUI Open WebUI是github上的一个开源项目，这里我们参考其官方文档进行下载和安装。
在安装之前，我们需要先安装Docker，安装说明如下： 如果是Win或者Mac系统，参考文档：Docker Desktop release notes：
注意：要下载跟自己的电脑系统适配的版本例如目前的最新版本的Docker仅支持Mac OS12.0以后的系统 如果Linux系统，请自己上网找教程（日常都可以使用Linux系统了，安装Docker小Case！）
在官方文档中我们会看到两种安装Open WebUI的方式： ollama和open webui一起安装仅仅安装open webui 由于我们已经安装了ollama，因此我们只需要安装open webui即可，复制如下命令：
kotlin 复制代码 docker run -d -p 3000:8080 --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ede190f5a3af277873ca310bc8b341f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5acdeb2950bb8bacf31dcb7f38726b9e/" rel="bookmark">
			2024年大数据最全《大数据时代：生活、工作与思维的大变革》：看(2)，2024年最新讲的太清楚了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上学习资料一大堆，但如果学到的知识不成体系，遇到问题时只是浅尝辄止，不再深入研究，那么很难做到真正的技术提升。
需要这份系统化资料的朋友，可以戳这里获取
一个人可以走的很快，但一群人才能走的更远！不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！
这种说法表明了一种新的认知世界的方式，是一种新的趋势，努力达到全量的确可以让我们抓到了更多的细节，让我们摆脱传统统计分析学的束缚，就好比以前预测美国总统大选，采用的是民意抽样统计，而如今已经可以对于社区用户所有言论的判断来更精准的预测。
但是，现实世界很残酷，大多数领域你其实无法拿到全量的数据，或者，如果你要拿到全量的数据，代价极其巨大，因此，大多数时候，我们用的大数据仍是局部的小数据，没有所谓“样本=总体”的条件，传统的以抽样来理解这个世界的方式仍然有效，机器学习与统计学作为一种认知世界的方法也将持续有效，前期的AlphaGo与李世石的人机大战。AlphaGo只能用采样的方式获得有限的棋局进行深度学习就是例证，因为你不可能拿到全部的样本或者甚至是足够的样本，因为这个数量比全宇宙的原子还多。
当然，对于国际象棋和中国象棋上，全量的数据已经使得传统胜负的玄妙缺失了意义，因此，可以这么大胆推测，当某个领域具备“样本=总体”的时候，就是该领域被大数据替换的时刻。
三、“不是精确性，而是混杂性”，没能力但不能否定精确性的价值 作者表达了这样一个观点，执迷于精确性是信息时代和模拟时代的产物。只有5%的数据是结构化且能适用于传统数据库的。如果不接受混乱，剩下95%的非结构化数据都无法被利用，只有接受不精确性，我们才能打开一扇从未涉足的世界的窗户，大数据的简单算法比小数据的复杂算法更有效。
传统数据处理追求“精确度”，这种思维方式适用于掌握“小数据量”的情况，因为需要分析的数据很少，所以我们必须尽可能精准地量化我们的记录。大数据纷繁多样，优劣掺杂，分布广泛。拥有了大数据， 我们不再需要对一个现象刨根究底，只要掌握大体的发展方向即可，适当忽略微观层面上的精确度会让我们在宏观层面拥有更好的洞察力。
这段话说得没错，但我认为大数据的复杂算法对于认识这个世界更为重要，对于精准性的把握始终是我们的目标，只是因为我们现在的算法太弱了，无法驾驭大数据，才提简单的算法。
比如，在工业界一直有个很流行的观点：在大数据条件下，简单的机器学习模型会比复杂模型更加有效。例如，在很多的大数据应用中，最简单的线性模型得到大量使用。而最近深度学习的惊人进展，促使我们也许到了要重新思考这个观点的时候。简而言之，在大数据情况下，也许只有比较复杂的模型，或者说表达能力强的模型，才能充分发掘海量数据中蕴藏的丰富信息。运用更强大的深度模型，也许我们能从大数据中发掘出更多有价值的信息和知识。
为了理解为什么大数据需要深度模型，先举一个例子。语音识别已经是一个大数据的机器学习问题，在其声学建模部分，通常面临的是十亿到千亿级别的训练样本。在Google的一个语音识别实验中，发现训练后的DNN对训练样本和测试样本的预测误差基本相当。这是非常违反常识的，因为通常模型在训练样本上的预测误差会显著小于测试样本。因此，只有一个解释，就是由于大数据里含有丰富的信息维度，即便是DNN这样的高容量复杂模型也是处于欠拟合的状态，更不必说传统的GMM声学模型了。所以从这个例子中我们看出，大数据需要复杂深度学习，毫无疑问AlphGo也必定是欠拟合的。
四、“不是因果关系，而是相关关系”，追求真理是我们永恒的目标 作者提出了这样一个观点，寻找因果关系是人类长久以来的习惯。即使确定因果关系很困难而且用途不大，人类还是习惯性地寻找缘由。在大数据时代，我们无须再紧盯事物之间的因果关系，不再把分析建立在早已设立的假设的基础之上。而应该寻找事物之间的相关关系，让大数据告诉我们“是什么”而不是“为什么”。
一方面，应该承认基于大数据的相关关系是我们认识世界和改造世界的新的方式，从应用科学的角度讲，降低对于因果关系的追求可以让大数据创造更大的价值。
另一方面，当前阶段由于我们对于世界的认知太少，人类在有限的时间内不可能找到“终极真理”，大量的规律通过大数据暴露出了蛛丝马迹，即所谓的相关关系，但其本质上仍是因果关系的体现，因此两者并不冲突。一个解决当前问题，是近，一个解决长期问题，是远，两者相辅相成，无所谓谁替代谁。从社会角度来讲，企业可以致力于大数据相关关系来创造更多的商机，而因果关系仍然是基础研究需要追求的东西，不能说人类物质上满足了，就不去追求更为本原的东西。
同时，大数据方法也可以发现因果关系。2014年，美国国防高级研究计划局启动其“大机理”项目。目的是发展可以发现隐藏在大数据中因果模型。典型“大机理”例子就是，1854年的伦敦地图显示爆发霍乱和污染的公共水泵之间的联系。该发现推翻了当时认为疾病是通过空气传播的认识。大机理包含在巨大的、零碎的、有时相互矛盾的文献和数据库中，所以，没有任何一个人可以理解该如此复杂的系统，所以必须依靠计算机。
DARPA办公室最初使用“大机理”工具来研究导致细胞癌变的复杂分子之间的相互作用。该方法包括使用电脑扫描癌症类论文，来获取癌症路径的有关数据。获取的数据片段可以组成”前所未有规模和精度”的完整路径，以此来确定传递路径如何互动。最后，自动工具可以帮助确定因果关系，该因果关系可用来开发潜在治疗癌症的方法。科恩说：“分子生物学和癌症文献强调机理，论文描述蛋白质如何影响其它蛋白质的表达，这些影响如何产生生物效果。电脑应该可以被用来分析这些癌症类论文中的因果关系。”通过强调因果模型和解释，大机理将成为科学的未来。
五、“小数据的问题，大数据就能解决”，大数据并没有解决小数据问题 大数据体现了4V特征，但我们现在碰到的数据仍是主要是小数据，我们应该抱着务实的态度去解决小数据的问题，小数据的问题并不会由于大数据的产生而自动解决。
统计学家们花了200多年，总结出认知数据过程中的种种陷阱，这些陷阱并没有被填平，比如采样，大数据中有大量的小数据问题，这些问题不会随着数据量的增大而消失，要注意数据（样本）的偏差，比如Google的流感预测为什么近3年失败，因为其随机性实际不够，比如媒体对于流感流行的报道会增加与流感相关的词汇的搜索次数，进而影响Google的预测，对谷歌大肆炒作的流感跟踪系统的研究结果发现，该系统多年来一直高估美国的流感病例。这项失败凸显了依赖大数据技术的危险性。
“谷歌在2008年推出的流感趋势系统监测全美的网络搜索，寻找与流感相关的词语，比如“咳嗽”和“发烧”等。它利用这些搜索来提前9个星期预测可能与流感相关的就医量。在过去3年，该系统一直高估与流感相关的就医量，在这类数据最有用的流感季节高峰期尤其预测不准确。在2012/2013流感季节，它预测的就医量是美国疾控中心（CDC）最终记录结果的两倍；在2011/2012流感季节，它高估了逾50%。”
六、发人深省的彩蛋观点，关于啤酒和尿布有点雷 （1）数据化，而不是数字化
所谓的数字化指的是把模拟数据转换成用0和1表示的二进制码，而数据化是指把现象转变成可制表分析的量化形式的过程，举个例子，我们扫描实体书成为电子书，如果保存形式是图片，这个只能叫作数字化，而我们通过字符识别软件进行了文本解析，图像就变成了数据化文本，两者有本质的不同，万物只有数据化后，才可以被量化，我们才能通过量化后的数据创造更多的价值。美国政府在提数据开放的时候，强调了开放的数据必须是可以有机读的，就是这个意思，一个PDF的信息量跟一个WORD的信息量显然是不一样的。
（2）应用为王，不要迷信技术
目前各类企业都在建设大数据中心，但成本其实很大，当前的新的信息技术层出不穷，不断冒出新概念，新名词，大数据技术其实还在不停的发展，现阶段，应该充分考虑成本因素，抱着应用为先的态度，技术始终要为应用服务，我们应该致力于用技术解决业务问题，而不是被潮流技术牵着鼻子走。不用迷信Google等技术公司的创新，有的放矢的借鉴，BAT做得足够好，不要去贬低这些公司的技术创新性，不要用Google的AlphGo去鄙视百度的人工智能，应用始终为王，百度发明的人工智能输入实际应用意义可能远大于AlphaGo。
（3）隐私问题，不是那么简单
告知与许可也许已经是世界各地执行隐私政策的基本法则，但这个法则有问题，大数据时代，很多数据在收集时并无意用于其它用途，但最终往往是二次开发利用创造了价值，公司无法告知用户尚未想到的用途，而个人也无法同意这种尚是未知的用途。如果谷歌要使用检测词预测流感的话，必须征得数亿用户的同意，就算没有技术障碍，有哪个公司能负担得起。
同样，所谓的匿名化在小数据时代的确可以，但是随着数据量和种类的增多，大数据促进了数据内容的交叉检验。
政府在未来制定相关法规的时候，应该充分尊重事实，也许提前预防永远无法解决大数据应用和隐私问题。
（4）大数据的驱动效应
大家所说的大数据是沙里淘金，大海捞针，导致人们总是渴望从大数据挖掘出意想不到的“价值”。实际上大数据更大的价值是带动有关的科研和产业，提高个行业通过数据分析解决困难问题和增值的能力，大数据价值体现在它的驱动效益。
所谓的“啤酒与尿布”的数据挖掘经典案例，其实是Teradata公司的一位经理编造出来的“故事”，历史上并没有发生过，这个天雷滚滚啊。
网上学习资料一大堆，但如果学到的知识不成体系，遇到问题时只是浅尝辄止，不再深入研究，那么很难做到真正的技术提升。
需要这份系统化资料的朋友，可以戳这里获取
一个人可以走的很快，但一群人才能走的更远！不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！
545628)**
一个人可以走的很快，但一群人才能走的更远！不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb9d6fdedec2e10228f7c56cdb0e5e37/" rel="bookmark">
			数据结构：栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一 栈的基本概念
1.栈的定义：
二 栈的顺序存储结构
1.栈的存储结构：
2.栈的所有接口：
3.栈的初始化：
4.栈顶指针初值为-1或者0的区别：
5.栈的销毁：
6.入栈：
7.出栈：
8.获取栈顶元素：
9.获取有效数据个数:
10：判断栈是否为空:
11.打印栈:
三 栈的链式存储结构
1.栈的存储结构：
3.栈的所有接口：
4.栈的初始化：
5.栈的销毁：
6.入栈：
7.出栈：
8.获取栈顶元素：
9.获取有效数据个数：
10.判断栈是否为空：
四 顺序存储和链式存储实现栈的优缺点比较
1.顺序存储（基于数组的栈）：
2.链式存储（基于链表的栈）：
五 总结
一 栈的基本概念 1.栈的定义： 栈(Stack)是只允许在一端进行插入或删除操作的线性表。首先栈是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作。
栈顶(Top) 线性表允许进行插入删除的那一端
栈底(Bottom) 固定的，不允许进行插入和删除的另一端。
空栈 不含任何元素。
二 栈的顺序存储结构 1.栈的存储结构： typedef int STDataType; typedef struct Stack { STDataType* a; int top; int capacity; }ST; 2.栈的所有接口： //栈的初始化、销毁 void STInit(ST* ps); void STDestroy(ST* ps); //栈的入栈、出栈 void STPush(ST* ps, STDataType x); void STPop(ST* ps); //获取栈顶元素、有效数据个数 STDataType STTop(ST* ps); int STSize(ST* ps); //判断栈是否为空 bool STEmpty(ST* ps); 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb9d6fdedec2e10228f7c56cdb0e5e37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e13cd9cd03d9efc125296f4d206cea9d/" rel="bookmark">
			C语言之数据结构之栈和队列的运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 用队列实现栈1.1 思路讲解1.2 代码实现 2. 用栈实现队列1.1 思路讲解1.2 代码实现 总结 •͈ᴗ•͈ 个人主页：御翮
•͈ᴗ•͈ 个人专栏：C语言数据结构
•͈ᴗ•͈ 欢迎大家关注和订阅!!!
1. 用队列实现栈 题目描述：
请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。
实现 MyStack 类：
void push(int x) 将元素 x 压入栈顶。int pop() 移除并返回栈顶元素。int top() 返回栈顶元素。boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。 注意：
你只能使用队列的标准操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。 示例：
输入：
[“MyStack”, “push”, “push”, “top”, “pop”, “empty”]
[ [ ], [1], [2], [ ], [ ], [ ] ]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e13cd9cd03d9efc125296f4d206cea9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f87498d8b81166758e52ddcc80b74433/" rel="bookmark">
			【python的魅力】：教你如何用几行代码实现文本语音识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言一、运行效果二、文本转换为语音2.1 使用pyttsx32.2 使用SAPI实现文本转换语音2.3 使用 SpeechLib实现文本转换语音 三、语音转换为文本3.1 使用 PocketSphinx实现语音转换文本 引言 语音识别技术，也被称为自动语音识别，目标是以电脑自动将人类的语音内容转换为相应的文字和文字转换为语音。
一、运行效果 Python语音识别
二、文本转换为语音 2.1 使用pyttsx3 pyttsx3 是一个流行的 Python 第三方库，用于实现文本到语音（TTS）的转换。这个库支持多种操作系统，包括 Windows、Linux 和 macOS，并且可以在没有互联网连接的情况下工作，因为它使用的是计算机上安装的本地语音引擎。
主要特点：
跨平台：可以在不同的操作系统上运行。离线工作：不依赖于互联网连接。多种语音和语言：支持多种语音和语言选项。自定义设置：允许用户调整语速、音量和语调等参数。简单易用：具有直观的 API，易于集成和使用。 安装：
pip install pyttsx3 -i https://pypi.tuna.tsinghua.edu.cn/simple some-package
【示例】：使用 pyttsx3 实现文本转换语音
import pyttsx3 as pyttsx engine = pyttsx.init() # 初始化引擎 engine.say('独断万古荒天帝, 唯负罪州火桑女') # 添加文本到语音队列 engine.runAndWait() # 开始语音输出 2.2 使用SAPI实现文本转换语音 在 python 中，你也可以使用 SAPI 来做文本到语音的转换。
在Python中，win32com库是一个用于与Windows操作系统中的COM（Component Object Model）组件进行交互的模块。win32com.client模块提供了一种使用COM自动化的Python接口。通过win32com.client.Dispatch方法，可以访问和控制支持COM自动化的任何Windows应用程序或服务。
对于SAPI（Speech Application Programming Interface），可以通过win32com库来访问其功能，从而实现文本到语音（TTS）和语音识别。
【示例】：使用 SAPI 实现文本转换语音
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f87498d8b81166758e52ddcc80b74433/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3181b037997c72d557f46feb5326df9b/" rel="bookmark">
			【数据结构】第四讲：双向链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、链表的分类
二、双向链表的结构及实现
1.带头双向链表的结构
2.创建节点
3.初始化
4.尾插
5.打印
6.头插
7.尾删
8.头删
9.在pos位置之后插入数据
10.删除pos节点
11.查找
12.销毁
个人主页：深情秋刀鱼@-CSDN博客
数据结构专栏：数据结构与算法
循环链表这个轮回的思想很有意思。它强调了不管你今生是贫是富，如果持续行善积德，下辈子就会好过，反之就会遭到报应。
就像每个人的人生一样，欲收获就得付出代价。双向链表既然是比单链表多了如可以反向遍历查找的数据结构，那么也就要付出一些小的代价。
一、链表的分类 链表的结构复杂多样，总计有如下八种形式。
虽然有这么多的链表的结构，但是我们实际中最常⽤还是两种结构： 单链表 和 双向带头循环链表。 1. ⽆头单向⾮循环链表：结构简单，⼀般不会单独⽤来存数据。实际中更多是作为其他数据结 构的⼦结构，如哈希桶、图的邻接表等等。另外这种结构在笔试⾯试中出现很多。 2. 带头双向循环链表：结构最复杂，⼀般⽤在单独存储数据。实际中使⽤的链表数据结构，都 是带头双向循环链表。另外这个结构虽然结构复杂，但是使⽤代码实现以 后会发现结构会带 来很多优势，实现反⽽简单了。 二、双向链表的结构及实现 1.带头双向链表的结构 对于带头和不带头，在学习单链表是我们将其理解为链表的头节点（链表的第一个节点），这种称呼很不严谨，在本节中的带头和不带头指的是在该链表中书否含有哨兵结点，哨兵结点在双向链表中是名副其实的头节点，哨兵节点内不存储任何有效的数据，他的唯一作用是防止在遍历链表时进入死循环。
//双向链表的定义 typedef int LTDataType; //定义双向链表的节点 typedef struct ListNode { LTDataType data;//数据域 struct ListNode* next;//指向后继节点的指针 struct ListNode* prev;//指向前驱节点的指针 }ListNode; 2.创建节点 ListNode* LTbuyNode(LTDataType x) { ListNode* newNode = (ListNode*)malloc(sizeof(ListNode)); if (newNode == NULL) { perror("malloc fail!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3181b037997c72d557f46feb5326df9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e72d6491d0c830e24cf037c1a223db35/" rel="bookmark">
			【C语言视角】数据结构之~二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：总所周知~数据结构的二叉树对于初学者来说是一个十分难理解的知识点。接下来，请阅读本人对二叉树拙劣的理解~
目录
1.二叉树概念及结构 和性质 二叉树的结构 二叉树的存储结构
2.二叉树顺序结构
3.二叉树链式结构的实现
二叉树层序遍历
1.二叉树概念及结构 和性质 1.1二叉树的概念 二叉树(Binary Tree)：是n(n≥0)个结点的有限集合，该集合或者为空集(称为空二叉树)，或者由一个根结点和两颗互不相交的、分别称为根结点的左子树和右子树的二叉树组成。
总而言之 满足以下两个条件的树就是二叉树：
1、本身是有序树；
2、树中包含的各个结点的度不能超过 2，即只能是 0、1 或者 2；
1.2二叉树的结构 由上图可得：
1. 二叉树不存在度大于2的结点 2. 二叉树的子树有左右之分，次序不能颠倒，因此二叉树是有序树 注意：对于任意的二叉树都是由以下几种情况复合而成的： 1.3二叉树的性质 1：在二叉树的第i层上最多有2^(i-1)个结点（i≥1）。
第一层是根结点，只有一个，所以2(1-1）=20=1。 第二层有两个，2(2-1)=21=2。 第三层有四个，2(3-1)=22=4。 第四层有八个，2(4-1)=2^3=8。
2：深度为k的二叉树至多有2^k-1个结点（k≥1）。
注意这里一定要看清楚，是2k后再减去1，而不是2(k-1)。以前很多同学不能完全理解，这样去记忆，就容易把性质2与性质1给弄混淆了。 深度为k意思就是有k层的二叉树，我们先来看看简单的。 如果有一层，至多1=21-1个结点。 如果有二层，至多1+2=3=22-1个结点。 如果有三层，至多1+2+4=7=23-1个结点。 如果有四层，至多1+2+4+8=15=2^4-1个结点。
3：对任何一棵二叉树，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。
终端结点数其实就是叶子结点数，而一棵二叉树，除了叶子结点外，剩下的就是度为1或2的结点数了，我们设n1为度是1的结点数。则树T结点总数n=n0+n1+n2
终端结点数其实就是叶子结点数，而一棵二叉树，除了叶子结点外，剩下的就是度为1或2的结点数了，我们设n1为度是1的结点数。则树T结点总数n=n0+n1+n2 。
4：具有n个结点的完全二叉树的深度为|log（2^n）+1| (向下取整)。
由满二叉树的定义我们可以知道，深度为k的满二叉树的结点数n一定是2k-1。因为这是最多的结点个数。那么对于n=2k-1倒推得到满二叉树的深度为k=log2(n＋1)，比如结点数为15的满二叉树，深度为4。
5：如果对一棵有n个结点的完全二叉树（其深度为|log（2^n）+1|）的结点按层序编号（从第一层到第层，每层从左到右），对任一结点i（1&lt;=i&lt;=n），有
1．如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点。
2．如果2i&gt;n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i。
3．如果2i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2i+1
二叉树的存储结构 二叉树一般可以使用两种结构存储，一种顺序结构，一种链式结构。 1. 顺序存储 顺序结构存储就是使用数组来存储，一般使用数组只适合表示完全二叉树，因为不是完全二叉树会有空 间的浪费。而现实中使用中只有堆才会使用数组来存储，关于堆我们后面的章节会专门讲解。二叉树顺 序存储在物理上是一个数组，在逻辑上是一颗二叉树。 2. 链式存储 二叉树的链式存储结构是指，用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。 通常的方法是 链表中每个结点由三个域组成，数据域和左右指针域，左右指针分别用来给出该结点左孩子和右孩子所 在的链结点的存储地址 。链式结构又分为二叉链和三叉链，当前我们学习中一般都是二叉链，后面课程 学到高阶数据结构如红黑树等会用到三叉链。 2.二叉树顺序结构 普通的二叉树是不适合用数组来存储的，因为可能会存在大量的空间浪费。而完全二叉树更适合使用顺序结 构存储。现实中我们通常把堆( 一种二叉树 ) 使用顺序结构的 数组 来存储，需要注意的是这里的堆和操作系统 虚拟进程地址空间中的堆是两回事，一个是数据结构，一个是操作系统中管理内存的一块区域分段。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e72d6491d0c830e24cf037c1a223db35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff35ea70cda1caebeb0b2ab7ffea590e/" rel="bookmark">
			Spark01 —— Spark基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Spark01 —— Spark基础一、为什么选择Spark？1.1 MapReduce编程模型的局限性1.2 Spark与MR的区别1.3 版本1.4 优势1.5 Spark其他知识1、多种运行模式2、技术栈3、spark-shell：Spark自带的交互式工具4、Spark服务 二、Spark的基础配置三、Spark实例Spark WordCount 四、Spark运行架构运行架构架构核心组件SparkContext 五、Spark分区分区过程RDDRDD的相关概念RDD创建方式RDD分区RDD与DAG Spark Shuffle再分区 六、Spark算子转换算子 七、Spark优化数据的本地化读取 八、拓展数据处理提取指标 基本思路： Spark01 —— Spark基础 一、为什么选择Spark？ 1.1 MapReduce编程模型的局限性 1、繁杂：只有Map和Reduce两个操作，复杂的逻辑需要大量的样板代码2、处理效率低： 2.1、Map中间结果写磁盘，Reduce写HDFS，多个Map通过HDFS交换数据2.2、任务调度与启动开销大 3、不适合迭代处理、交互式处理和流式处理 1.2 Spark与MR的区别 Spark是类似Hadoop MapReduce的通用【并行】框架(仿照MR的计算流程)
1、Job中间输出结果可以保存在内存，不再需要读写HDFS 1.1、内存不够也可以写盘 2、比MapReduce平均快10倍以上 1.3 版本 20141.020162.x20203.x 1.4 优势 1、速度快
基于内存数据处理，比MR快100个数量级以上（逻辑回归算法测试）
基于硬盘数据处理，比MR快10个数量级以上
为了容灾，会将少量核心数据进行持久化。即在计算过程中，会将检查点的数据写入磁盘中，当数据计算失败时，可以基于检查点数据进行恢复。
2、易用性
支持Java、【Scala】、【Python：pyspark】、R语言（主流使用Scala，pyspark存在缺陷：只能在单机上计算，对单机内存和算力的要求过高）交互式shell方便开发测试 3、通用性
一栈式解决方案： 批处理：将数据分批次加载到内存中进行计算交互式查询实时流处理（微批处理）图计算机器学习 1.5 Spark其他知识 1、多种运行模式 YARN ✔、Mesos、EC2、Kubernetes、Standalone、Local[*]
​ Local[*]：在本地模式下运行，且尝试使用所有可用的核心。
2、技术栈 Spark Core：核心组件，分布式计算引擎 RDD
Spark SQL：高性能的基于Hadoop的SQL解决方案
Spark Streaming：可以实现高吞吐量、具备容错机制的准实时流处理系统
Spark GraphX：分布式图处理框架
Spark MLlib：构建在Spark上的分布式机器学习库
3、spark-shell：Spark自带的交互式工具 local：spark-shell --master local[*]alone：spark-shell --master spark://MASTERHOST:7077yarn ：spark-shell --master yarn（需要先启用Hadoop） 4、Spark服务 Master：Cluster ManagerWorker：Worker Node 二、Spark的基础配置 Spark在IDEA工程中的基础配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff35ea70cda1caebeb0b2ab7ffea590e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe5e235c56d328cd12690bc07ec6d873/" rel="bookmark">
			收藏！2024 年最具潜力 44 个顶级开源项目，涵盖 11 类 AI 学习框架、平台_序列大数据的智能计算 开源项目(3)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ⅷ、自动建模（32-35）
Ⅸ、IDEs系统（36-38）
Ⅹ、平台（39-41）
Ⅺ、评分推理系统（42-43）
I . 适用于经典机器学习的工具 一、SciKit-learn star 39.2k fork 19.2k
scikit-learn 是一种强大的基于 Python 语言的机器学习算法库（https://scikit-learn.org/stable/）。其中，包含了算法预处理，模型参数择优，回归与分类等算法，官方文档包含了每一种算法的例子，代码简洁优美，可视化了每一种算法结果，即能学习 python，也是帮助开发者更好理解机器学习算法的便利工具。
尤其在监督学习部分，Scikit-learn 提供了广义线性模型、支持向量机、最近邻算法、高斯过程、朴素贝叶斯、决策树和集成方法等算法教程，同时还介绍了特征选择、随即梯度下降算法、线性与二次判别分析等在监督学习中非常重要的概念；而在半监督学习中的标签传播算法和无监督学习中的聚类与降维算法方面，也有非常多的教程。
GitHub 地址：
https://github.com/scikit-learn/scikit-learn
二、XGBoost star 18.3k fork 7.3k
xgboost 的全称是 eXtreme Gradient Boosting，它在 Gradient Boosting 框架下实现了 c++机器学习算法。
XGBoost 最大的特点在于，它能够自动利用 CPU 的多线程进行并行，同时在算法上加以改进提高了精度。它是经过优化的分布式梯度提升库，可扩展性强，高效、灵活且可移植。
GitHub 地址：
https://github.com/dmlc/xgboost
三、Accord.NET star 3.7k fork 1.7k
Accord.NET Framework 是一个.NET 机器学习框架，结合了完全用 C＃编写的音频和图像处理库（http://accord-framework.net/）。
它可用于构建生产级计算机视觉、计算机试听、信号处理和统计应用程序甚至用于商业用途的完整框架，并为.NET 的应用程序提供了统计分析、机器学习、图像处理、计算机视觉相关的算法。
GitHub 地址：
https://github.com/accord-net/framework
II . 适用于深度学习的工具 TensorFlow 2019 年相关数据
四、TensorFlow star 141k fork 79.8k
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe5e235c56d328cd12690bc07ec6d873/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3733884adf901a914bc45a45a53021a5/" rel="bookmark">
			Oracle23ai来了，23爱，全能、超级巨兽...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📢📢📢📣📣📣
作者：IT邦德
中国DBA联盟(ACDU)成员，10余年DBA工作经验，
Oracle、PostgreSQL ACE
CSDN博客专家及B站知名UP主，全网粉丝10万+
擅长主流Oracle、MySQL、PG、高斯及Greenplum备份恢复，
安装迁移，性能优化、故障应急处理
文章目录 📣 前言📣 1.Oracle 23ai来了📣 2.改变规则的创新✨ 2.1 AI 向量搜索✨ 2.2 SQL 简单化✨ 2.3 JSON 关系二元性✨ 2.4 分片多副本✨ 2.5 缓存数据 3.安装体验✨ 3.1 安装包下载✨ 3.2 yum安装依赖✨ 3.3 rpm包安装✨ 3.4 环境变量 4.Oracle的发展史5.总结 📣 前言 Oracle23c改名为Oracle23ai，也意味着Oracle数据库正式从Cloud进入AI时代
📣 1.Oracle 23ai来了 北京时间 2024年5月3日凌晨，Oracle Database 23ai 正式发布！Oracle23c改名为Oracle23ai，也意味着Oracle数据库正式从Cloud进入AI时代.
自从OpenAI推出了全新的对话式通用人工智能工具——ChatGPT，ChatGPT 表现出了非常惊艳的语言理解、生成、知识推理能力，ChatGPT 的横空出世拉开了大语言模型产业和生成式AI产业蓬勃发展的序幕.
📣 2.改变规则的创新 Oracle Database 23ai 专注于三个关键领域。
1.AI for Data
2.数据开发
3.数据关键任务
Oracle23ai版本是一个超级巨兽，简单总结下：
1.AI能力：内置向量数据库，模型数据处理，内置的机器学习算法持续增强
2.JSON能力增强，比MongoDB更强
3.图数据处理能力增强
4.Oracle才是真正的缓存服务，比Redis更强
5.谁再说Orale没有分布式，开始支持分片多副本了
6.SQL易用性，向MySQL、PostgreSQL靠齐
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3733884adf901a914bc45a45a53021a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85f3ab249baf887f287fcae5692237c2/" rel="bookmark">
			AIGC实战——MuseGAN详解与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AIGC实战——MuseGAN详解与实现 0. 前言1. MuseGAN1.1 Bach Chorale 数据集1.2 MuseGAN 生成器1.3 MuseGAN 判别器 2. MuseGAN 分析小结系列链接 0. 前言 在基于 Transfromer 生成音乐一节，我们可以看到可视化的乐谱类似于一幅图像，因此，我们可以利用图像生成方法替代序列生成技术生成音乐。可以将音乐生成视为一个图像生成问题，这意味着可以不使用 Transformer，而是应用在图像生成问题中表现出色的基于卷积的技术，例如生成对抗网络 (Generative Adversarial Network, GAN)。本节中，我们将解决多声部音乐生成的问题，并探讨如何使用基于 GAN 架构创建多声部音乐。
1. MuseGAN MuseGAN 通过一种新颖的生成对抗网络 (Generative Adversarial Network, GAN) 框架来训练模型生成复调、多轨和多小节的音乐。此外，通过将生成器的输人噪声向量划分职责，实现对音乐的时域以及声部等高级特征进行精细控制。为了训练 MuseGAN，我们将使用 Bach Chorale 数据集。
1.1 Bach Chorale 数据集 首先需要下载用于训练 MuseGAN 的 MIDI 文件，使用 Bach Chorale 数据集的四个声部(声部也称为音轨，tracks)，下载后将 MIDI 文件保存到本地的 ./data 文件夹中。
数据集每个时间步 (timesteps) 由四个数字组成，分别是四个声部中每个声部 MIDI 音符的音高。在此数据集中，一个时间步等于一个 16 分音符。例如，在 4 个四分音(四拍)拍子的一个小节中，有 16 个时间步。数据集会自动分为训练集、验证集和测试集，使用训练集来训练 MuseGAN。
首先，我们需要将数据转换成正确的形状以供 GAN 使用，我们将生成两小节的音乐，所以只提取每个声部的前两小节。每小节由 16 个时间步组成，4 个声部有 84 个音高。因此，转换后的数据形状如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85f3ab249baf887f287fcae5692237c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f9797f1c31a3de7e122d47c8f9ab0b9/" rel="bookmark">
			50个前端实战项目之04：隐藏的搜索小组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是宝哥。
今天讲50个前端实战项目之04：隐藏的搜索小组件。
源码下载地址
https://github.com/bradtraversy/50projects50days/tree/master/hidden-search
前端实战项目系列正在更新：04/50
01：可展开卡片
02：进度条
03：旋转导航动画
04：隐藏的搜索小组件
项目介绍 本项目演示了一个简洁实用的隐藏式搜索小部件。点击搜索按钮后，搜索栏会展开，并输入框自动获得焦点，方便用户输入搜索内容。
效果预览 在线预览(文末点击原文链接可直达）：
https://qdkfweb.cn/50projects50days/hidden-search/
实现方法 HTML 结构中定义搜索栏的布局，包括输入框和按钮。
CSS 样式定义搜索栏的初始外观、展开后的外观以及按钮的移动效果。
JavaScript 代码监听按钮的点击事件，并根据 active 类的状态控制搜索栏的展开/收起，并设置输入框的焦点。
核心代码 HTML 结构 .search 容器包含搜索栏的输入框和按钮。
.input 输入框用于输入搜索内容。
.btn 按钮用于展开或收起搜索栏。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous" /&gt; &lt;link rel="stylesheet" href="style.css" /&gt; &lt;title&gt;Hidden Search&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="search"&gt; &lt;input type="text" class="input" placeholder="Search..."&gt; &lt;button class="btn"&gt; &lt;i class="fas fa-search"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f9797f1c31a3de7e122d47c8f9ab0b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c5bde7cb86c8ebbc8d506d31dd7c4cd/" rel="bookmark">
			初始Java篇（JavaSE基础语法）（7）抽象类和接口（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：JavaSE
目录
抽象类 抽象类的概念： 抽象类语法
抽象类特性 抽象类的作用
接口 接口的概念：
语法规则
接口使用
接口特性
抽象类 抽象类的概念： 在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。
例如：有一个Animal类其中只有一个bark方法，但是没有具体实现逻辑，那么我们就把这个类称为抽象类。如下图所示：
​
至于为什么可以这样设计呢？因为Animal是动物类，但是又不是一个具体的动物，因此其内部的bark方法就无法具体实现。如果是狗类的话，就可以汪汪汪，如果是猫类的话，就可以喵喵喵。
像这种没有实际工作的方法, 我们可以把它设计成一个 抽象方法(abstract method), 包含抽象方法的类我们称为 抽象类(abstract class)
抽象类语法 在Java中，一个类如果被 abstract 修饰就称为抽象类，抽象类中被 abstract 修饰的方法称为抽象方法，抽象方法不用给出具体的方法体。
// 抽象类的定义格式 // 访问限定修饰符 abstract class 类名 public abstract class Test { //…… } // 抽象方法的定义格式 // abstract 访问限定修饰符 返回值 方法名（参数列表） abstract public void bark() { //…… } 抽象类特性 1. 抽象类不能直接实例化对象。
​
2. 抽象方法不能是 private 的 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c5bde7cb86c8ebbc8d506d31dd7c4cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f82902ab0ee4f119f9bbdb0d9a43e7b8/" rel="bookmark">
			JavaEE 初阶篇-深入了解 Junit 单元测试框架和 Java 中的反射机制（使用反射做一个简易版框架）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥博客主页： 【小扳_-CSDN博客】
❤感谢大家点赞👍收藏⭐评论✍
文章目录
1.0 Junit 单元测试框架概述
1.1 使用 Junit 框架进行测试业务代码
1.2 Junit 单元测试框架的常用注解（Junit 4.xxx 版本）
2.0 反射概述
2.1 获取 Class 对象的三种方式
2.2 获取类的构造器并对其进行操作
2.3 获取类的成员变量
2.4 获取类的成员方法
3.0 使用反射做一个简易版的框架
1.0 Junit 单元测试框架概述 可以用来对方法进行测试，它是第三方公司开源出来的（很多开发工具已经集成了 Junit 框架，比如 IDEA）
优点：
1）可以灵活的编写测试代码，可以针对某个方法执行测试，也支持一键完成对全部方法的自动化测试，且各自独立。
2）不需要程序员去分析测试结果，会自动生成测试报告出来。
具体步骤：
1）将 Junit 框架的 jar 包导入到项目中（注意：IDEA 集成了 Junit 框架，不需要我们手动导入）
2）为需要测试的业务类，定义对应的测试类，并为每个方法，编写对应的测试方法（测试方法必须：公共、无参、无返回值）
3）测试方法上必须声明 @Test 注解，然后在测试方法中，编写代码调用被测试的业务方法进行测试。其实就是列出实际例子进行测试。
4）开始测试：选中测试方法，右键选择 “Junit 运行”，如果测试通过则是绿色；如果测试失败，则是红色。
1.1 使用 Junit 框架进行测试业务代码 举个例子：
业务代码：
//这是项目的业务代码 public class ProjectBusiness { //项目业务一:获取字符串的长度 public static void printLength(String str){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f82902ab0ee4f119f9bbdb0d9a43e7b8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/25/">«</a>
	<span class="pagination__item pagination__item--current">26/71</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/27/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>