<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e86298d5461d6c5e5996cd58845da915/" rel="bookmark">
			外卖推荐|基于SSM＋vue的外卖推荐系统的设计与实现(源码&#43;数据库&#43;文档)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		外卖推荐系统
目录
基于SSM＋vue的外卖推荐系统的设计与实现
一、前言
二、系统设计
三、系统功能设计 1系统功能模块
2 管理员功能模块
3 商家功能模块
4 用户功能模块
四、数据库设计
五、核心代码 六、论文参考
七、最新计算机毕设选题推荐
八、源码获取：
博主介绍：✌️大厂码农|毕设布道师，阿里云开发社区乘风者计划专家博主，CSDN平台Java领域优质创作者，专注于大学生项目实战开发、讲解和毕业答疑辅导。✌️
主要项目：小程序、SpringBoot、SSM、Vue、Html、Jsp、Nodejs等设计与开发。
🍅文末获取源码联系🍅
基于SSM＋vue的外卖推荐系统的设计与实现 一、前言 首先,论文一开始便是清楚的论述了系统的研究内容。其次,剖析系统需求分析,弄明白“做什么”,分析包括业务分析和业务流程的分析以及用例分析,更进一步明确系统的需求。然后在明白了系统的需求基础上需要进一步地设计系统,主要包罗软件架构模式、整体功能模块、数据库设计。本项目软件架构选择B/S模式,总体功能模块运用自顶向下的分层思想。再然后就是实现系统并进行代码编写实现功能。论文的最后章节总结一下自己完成本论文和开发本项目的心得和总结。通过外卖系推荐统将会使外卖各个方面的工作效率带来实质性的提升。
关键字：外卖推荐系统 B/S模式 软件架构
二、系统设计 系统功能结构如图
三、系统功能设计 1系统功能模块 外卖推荐系统，在系统首页可以查看首页，菜单列表，最新资讯，个人中心，后台管理，购物车等内容，如图5-1所示。
图5-1系统首页界面图
2 管理员功能模块 管理员进入系统，在登录页面根据要求填写用户名和密码，选择角色等信息，点击登录进行登录操作，如图5-4所示。
图5-4管理员登录界面图
3 商家功能模块 商家登录进入外卖推荐系统可以对首页，个人中心，菜单列表管理，订单管理等功能进行相应操作，如图5-12所示。
图5-12商家功能界面图
4 用户功能模块 用户登录进入外卖推荐系统可以对首页，个人中心，我的收藏管理，订单管理等功能进行相应操作，如图5-15所示。
图5-15用户功能界面图
四、数据库设计 商家注册实体图如图4-2所示：
图4-2商家注册实体图
数据库表的设计，如下表：
表4-1：菜系分类
字段名称
类型
长度
字段说明
主键
默认值
id
bigint
主键
主键
addtime
timestamp
创建时间
CURRENT_TIMESTAMP
caixifenlei
varchar
200
菜系分类
五、核心代码 package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e86298d5461d6c5e5996cd58845da915/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1640b3205a35708dea85224e534805b/" rel="bookmark">
			Android14 SystemUI修复进入桌面后虚拟按键图标从黑色过渡到白色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 在Android14系统rom产品开发中，一些SystemUI的系统定制化开发，在对设备进入桌面后出现虚拟按键图标颜色从浅色系（黑色）过渡到深色系（白色），每每进入桌面会复现这种情况，这并不是我们好兄弟想要看到的。
（注：虚拟按键深色系是图标为白色高亮，浅色系是图标为黑色）
原因分析： 此情景是由于Android14 SystemUI 的锁屏页面添加了虚拟按键，并且通过代码分析，此处虚拟按键默认主题与Lancher3里面的抽屉主题相一致，即系统主题，都为浅色系。然而我们桌面的虚拟按键主题为深色系，进而导致我们好兄弟解锁进入桌面时出现桌面虚拟按键图标会从黑色过渡到白色。
经过测试，我们在设置里进入显示（Display），通过设置深色主题（Dark theme），此时Launcher3抽屉变成深色主题，虚拟按键图标为白色高亮，锁屏页面虚拟按键也为深色主题，图标为白色高亮。再次解锁进入桌面则不会复现虚拟按键图标颜色从黑色过渡到白色。
我只想出两种修改方法，当然我的好兄弟有千百种想法，只是不想去实现罢了，所以在此我为好兄弟实现一下。
1.修改StatusBarKeyguardViewManager.java，只需注释几行代码即可解决 /frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java 2.修改锁屏界面主题为深色主题，与桌面主题相一致就行，不过这么修改的缺陷就是锁屏界面的主题将被写死，之后要是有相关的修改会造成一定的冲突，还是不太推荐好兄弟去实现的。所以我就不实现了，你们就看第一种方法就行，简单易懂好实现。 解决方案： 1.修改StatusBarKeyguardViewManager.java里面的onStartedWakingUp()，这段代码的主要功能是在唤醒过程中，启用通知阴影的动画，并在导航栏中执行一个淡入动画。这样的动画效果可以提供更好的用户体验，使得导航栏的出现更加自然和流畅。同时，启用通知阴影的动画也能更好地引起用户的注意，提高用户体验。我们只需注释掉其中对导航栏的所有视图执行淡入动画即可。 源码：
修改后： 2. 修改StatusBarKeyguardViewManager.java里面的onStartedGoingToSleep()，这段代码的主要功能是在休眠前禁用通知阴影的动画，并在导航栏中执行一个淡出动画。这样的动画效果可以提供更好的用户体验，使得导航栏的消失更加自然和流畅。同时，禁用通知阴影的动画也能避免在休眠过程中产生不必要的动画效果，提高用户体验。同上，我们只需要注释掉其中对导航栏的所有视图执行淡入动画即可。 源码：
修改后：
3. 修改StatusBarKeyguardViewManager.java的mMakeNavigationBarVisibleRunnable里的run()方法。这段代码的主要功能是在后台线程中执行一个任务，将导航栏可见。这样的设计可以避免在主线程中执行这个任务，避免阻塞主线程，从而提高应用程序的性能和响应能力。同时，将导航栏显示出来也能提供更好的用户体验，使得用户能够更好地使用应用程序。只需注释掉run里面实现的代码。 源码：
修改后：
4. 修改StatusBarKeyguardViewManager.java里的updateNavigationBarVisibility()。这段代码主要用于更新导航栏的可见性，当 navBarVisible 为 true 时，将导航栏显示出来，当 navBarVisible 为 false 时，将导航栏隐藏。同时，这段代码还考虑了在显示导航栏时的延迟时间，以及在隐藏导航栏时的移除已经安排在队列中的任务，提高了应用程序的性能和可靠性。其实说到最后，我们的目的就是要把导航栏隐藏，这里也是最关键一处修改，保留导航隐藏的代码即可。 源码：
修改后：
总结： 按上面一步一步的修改即可修复好虚拟按键的bug，只不过看个人需求去，好兄弟你要是有更好实现方法也可以在评论区发出自己的见解。 最后，这里是来自至大学到工作练习两年半的个人代码生，我喜欢摸鱼，带薪拉屎，写bug。制作不易，欢迎各位的借鉴。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bb5a9a11e08c3703efbb5119a57f550/" rel="bookmark">
			C# 结合 JavaScript 对 Web 控件进行数据输入验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
关于数据验证
范例运行环境
验证设计
JavaScript 方法
设计
实现
调用示例
C# 方法
设计
实现
调用示例
小结
关于数据验证 在 Web 应用的录入界面，数据验证是一项重要的实现功能，数据验证是指确认 Web 控件输入或选择的数据，是否满足数据表数据约束，是否满足应用程序所需要数据约束规则。建立数据库约束可以满足数据验证的应用，但在实际的应用中，我们建议还是在更新信息到数据库前，在应用中执行数据验证，这样可减少错误录入，减少应用程序与数据库之间频繁通信造成的服务器压力。通过有效的数据验证，可以确认写入数据表中的数据是有效且符合预期的。本文我们将介绍如何通过C# 后端及JavaScript 前端对 Web 控件进行数据输入有效性的验证。
范例运行环境 操作系统： Windows Server 2019 DataCenter
.net版本： .netFramework4.7.1 或以上
开发工具：VS2019 C#
验证设计 通过对 Web 服务器控件捆绑自定义属性 checkSchema="" 和 cName=""，将自定义的校验类型和中文提示进行赋值，即可完成验证的设置，可实现的校验类型如下图所示：
多个数据校验类型请用“|”进行分隔，如下设计举例：
示例 1：不能为空且必须为日期型数据
&lt;asp:TextBox id="x1" checkSchema="notnull|date" cName="出生日期" runat="server" /&gt; 示例 2：必须为身份证号
&lt;asp:TextBox id="x1" checkSchema="idcard" runat="server" /&gt; 示例3：必须输入4位的一个整型数 &lt;asp:TextBox id="x1" checkSchema="mustlen4|int" runat="server" /&gt; JavaScript 方法 设计 在前端客户端，使用 JavaScript 方法 simplecheck 进行数据验证，验证通过反回 true，否则为 false，其参数说明如下表：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bb5a9a11e08c3703efbb5119a57f550/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e31953c30bcb88a7d20b0b5415a01ce/" rel="bookmark">
			VScode代码片段自动转图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：在VScode编辑器中，编辑html、vue等文件时，特定代码片段（'token/xxx’等）自动转图标显示，按住“ctrl+鼠标左键”还可跳转“https://icones.js.org/collections”，个人感觉干扰代码编写，强迫症受不了。
比如：
关闭流程：
1、打开设置
2、搜索iconify: Annotations，取消勾选
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51315b7bf7a13724ad80f66e295d7773/" rel="bookmark">
			C--贪吃蛇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
简单的准备工作
蛇的节点
开始前 void GameStart(pSnake ps)
void WelcomeToGame()
void CreateMap()
void InitSnake(pSnake ps)
void CreateFood(pSnake ps)
游戏进行 void GameRun(pSnake ps)
int NextIsFood(pSnakeNode psn, pSnake ps)
void NoFood(pSnakeNode psn, pSnake ps)
void SnakeMove(pSnake ps)
游戏结束 void GameEnd(pSnake ps)
源码
test.c
snake.h
snake.cpp
总结
前言 贪吃蛇游戏是一个耳熟能详的小游戏,本次我们讲解他的简单的实现,需要掌握基本的API知识(http://t.csdnimg.cn/uHH6y),简单的C语言知识和基本的数据结构链表
简单的准备工作 效果展示 屏幕录制 2024-05-16 092902
蛇的节点 在游戏运⾏的过程中，蛇每次吃⼀个⻝物，蛇的⾝体就会变⻓⼀节，如果我们使⽤链表存储蛇的信 息，那么蛇的每⼀节其实就是链表的每个节点。每个节点只要记录好蛇⾝节点在地图上的坐标就⾏， 所以蛇节点结构如下：
typedef struct SnakeNode { int x; int y; struct SnakeNode* next; }SnakeNode, * pSnakeNode; 但是这样不好维护这一条蛇,要管理整条贪吃蛇，我们再封装⼀个Snake的结构来维护整条贪吃蛇
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51315b7bf7a13724ad80f66e295d7773/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79a4eaae2a6b9c46dac23605294fcc49/" rel="bookmark">
			【高阶数据结构(四)】图的最短路径问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💓博主CSDN主页:杭电码农-NEO💓
⏩专栏分类:高阶数据结构专栏⏪
🚚代码仓库:NEO的学习日记🚚
🌹关注我🫵带你学习更多数据结构
🔝🔝
高阶数据结构 1. 前言2. 单源最短路径问题3. dijkstra算法讲解4. bellman-Ford算法讲解5. 多源最短路径问题6. Floyd-Warshall算法讲解7. 总结 1. 前言 关于图论,无非就是最小生成树问题和最短路径问题. 对于最短路径问题来说, 分为单源最短路径和多源最短路径, 并且图中的权值是否有负数, 对应能使用的算法也不同
本章重点:
本篇文章着重讲解图的单源最短路径之Dijkstra算法和bellman-Ford算法.以及多源最短路径之Floyd-wars hall算法. 文章会着重讲解这些算法的思路, 代码实现部分要靠大家的理解能力了
2. 单源最短路径问题 所谓的单源最短路径,也就是从图中任意一点出发, 到图中每个节点的最短路径,也就是最小的权值和
对于单源最短路径的求解. 我们一般使用输出型参数. 用两个数组来表示最短路径的权值以及最短路径的路径.
//存储任意点到图中其他点的最短路径的权值 vector&lt;W&gt;&amp; dist //记录srci-&gt;其他顶点最短路径父顶点数组 vector&lt;int&gt;&amp; parentPath 第一个数组很好理解. 图中的顶点会简化成为数组中的元素. 所以dist数组中的dist[i]=j.代表顶点i到srci的最短路径的权值. 不好理解的是第二个数组. 它存储的是最短路径的父顶点. 什么意思呢? 请看下图:
3. dijkstra算法讲解 针对一个带权有向图G，将所有结点分为两组S和Q，S是已经确定最短路径的结点集合，在初始时为空（初始时就可以将源节点s放入，毕竟源节点到自己的代价是0），Q 为其余未确定最短路径的结点集合，每次从Q 中找出一个起点到该结点代价最小的结点u ，将u 从Q 中移出，并放入S 中，对u 的每一个相邻结点v 进行松弛操作。
松弛即对每一个相邻结点v ，判断源节点s到结点u 的代价与u 到v 的代价之和是否比原来s 到v 的代价更小，若代价比原来小则要将s 到v 的代价更新为s 到u 与u 到v 的代价之和，否则维持原样。如此一直循环直至集合Q 为空，即所有节点都已经查找过一遍并确定了最短路径，至于一些起点到达不了的结点在算法循环后其代价仍为初始设定的值，不发生变化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79a4eaae2a6b9c46dac23605294fcc49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/833802b9a5d2a072f3796e01357d14c1/" rel="bookmark">
			AI Agent - 7大认知框架全解析与代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出品丨咖哥 AI 作者｜黄佳
AI Agent，最近火得一塌糊涂。
Sam Altman 曾这样描述未来的AI Agent：“今天的AI模型是它们将会是的最‘笨’状态，未来只会越来越聪明！” 吴恩达在AI Ascent 2024会议上也不吝赞美：“这是AI发展的黄金时代，生成式AI和AI Agent将彻底改变我们工作的方式！”。这些业界领袖的话让人感受到未来AI与人类生活、工作的深度融合正在加速到来。
Agent之所以能成为Agent，是因为它具有了判断的能力，因而能够做成决策。那么它的判断能力是从哪里得到的，是从海量的人类语言中提炼出来的智慧。因为我们人类的自然语料中指定了场景A中应该这样做，场景B中应该那样做。因此大语言模型也就能够做出判断。这就是大语言模型成为Agent的基础。
一个可爱的Agent
不过，愿景虽好，现实并不理想。公众号“产品二姐”的一篇文章就指出——Agent开发者坦白，大家正在窘境中前行。Agent的开发现状是既没有什么有体系的理论指导，有没有什么优秀的范例来启发并模仿。
那么，在大模型应用开发时代，大家都在讨论的Agent到底应该如何设计实现。本文作者黄佳（代表作：GPT图解，动手做AI Agent）将以干货的方式，全面解析 7 大认知框架的设计模式和实现方式。
Agent认知框架的4种设计模式
吴恩达教授在红杉资本的人工智能峰会(AI Ascent)上谈到了自己对于AI Agent认知框架设计模式的四种分类，包括反思、工具使用、规划、多智能体协作。
吴恩达教授提出的Agent认知框架的4种设计模式
这四种基本的思维框架设计模式分别是：
反思（Reflection）：Agent通过交互学习和反思来优化决策。
工具使用（Tool use）：Agent 在这个模式下能调用多种工具来完成任务
规划（Planning）：在规划模式中，Agent 需要规划出一系列行动步骤来达到目标。
多Agent协作（Multiagent collaboration）：涉及多个Agent之间的协作。
Agent认知框架的技术架构
OpenAI公司的安全系统主管Lilian Weng也提出了一个由大模型驱动的自主Agent系统的架构，其中包含规划（Planning）、记忆（Memory）、工具（Tools）、执行（Action）四大要素。
在这个架构中，Agent位于中心位置，它通过协同各种组件来处理复杂的任务和决策过程。
规划：Agent需要具备规划（同时也包含决策）能力，以有效地执行复杂任务。这涉及子目标的分解（Subgoal decomposition）、连续的思考（即思维链，Chain of thoughts）、自我反思和批评（Self-critics），以及对过去行动的反思（Reflection）。
记忆: 包含了短期记忆和长期记忆两部分。短期记忆与上下文学习有关，属于提示工程的一部分，而长期记忆涉及信息的长时间保留和检索，通常是通过利用外部向量存储和快速检索。
工具：这包括了Agent可能调用的各种工具，如日历、计算器、代码解释器和搜索功能，以及其他可能的工具。由于大模型一旦完成预训练，其内部能力和知识边界基本固定下来，而且难以拓展，那么这些工具显得异常重要。它们扩展了Agent的能力，使其能够执行超出其核心功能的任务。
执行（或称行动）：Agent基于规划和记忆来执行具体的行动。这可能包括与外部世界互动，或者通过工具的调用来完成一个动作（任务）。
围绕着这个架构，一系列的Agent认知框架开始落地。接下来，我们将重点介绍几种具有代表性的Agent认知框架设计模式及其实现思路。
7种Agent认知框架的具体实现
下面，我们就来说一说主流的7种Agent认知框架的基本思想，并简明扼要的阐述如何具体实现这些框架。
框架 1 思维链（Chain of Thought）
在Agent认知框架领域，开一代风气之先的就是Chain-of-Thought Prompting这篇论文，这篇论文的出现甚至是早于ChatGPT。
在大模型推理能力普遍较弱的时代，这篇论文通过引入连贯的思考过程来引导模型进行更深入的逻辑推理，极大地提高了模型处理复杂问题的能力。这种方法不仅优化了模型的推理过程，还改善了输出的可解释性，使得模型的决策过程对于用户来说更加透明和易于理解。
论文中的Chain of Thought简称CoT，即思维链，是指在解决问题过程中形成的一系列逻辑思考步骤。在AI领域，尤其是在自然语言处理和机器理解任务中，CoT方法通过模拟人类的思考过程来提高模型的理解和推理能力。通过明确展示解决问题的逻辑步骤，CoT有助于增强模型的透明度和可解释性。
Chain-of-Thought论文中的思维链示例
其实，我们设计Agent时，需要参照的就是其方法论中的思想精华，参悟了思想，我们就可以通过精心设计的提示工程模板，来实现CoT框架。
举例来说，假设我们需要建立一个模型，用于评估个人的信用等级。这是一个典型的金融服务场景，其中涉及多个变量和逻辑判断。
在CoT框架下，我们可以设计以下提示，以帮助AI模型通过逻辑推理来评估信用等级：
考虑到申请人的以下信息：
- 年龄：35岁
- 年收入：$50,000
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/833802b9a5d2a072f3796e01357d14c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27db273527d7847ca85141394351791e/" rel="bookmark">
			基于大数据爬虫技术的图书推荐系统与可视化平台设计和实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌全网粉丝40W+,csdn特邀作者、博客专家、CSDN新星计划导师、Java领域优质创作者,博客之星、掘金/华为云/阿里云/InfoQ等平台优质作者、专注于Java技术领域和学生毕业项目实战,高校老师/讲师/同行交流合作✌
主要内容：SpringBoot、Vue、SSM、HLMT、Jsp、PHP、Nodejs、Python、爬虫、数据可视化、小程序、安卓app、大数据、物联网、机器学习等设计与开发。
🍅文末获取源码联系🍅
👇🏻 精彩专栏推荐订阅👇🏻 不然下次找不到哟
2022-2024年最全的计算机软件毕业设计选题大全：1000个热门选题推荐✅
Java项目精品实战案例《100套》
Java微信小程序项目实战《100套》
感兴趣的可以先收藏起来，还有大家在毕设选题，项目以及论文编写等相关问题都可以给我留言咨询，希望帮助更多的人
目录
一、前言介绍：
二、功能设计：
三、功能实现：
四、库表设计：
五、关键代码：
六、论文参考：
七、其他案例： 八、推荐项目：
九、源码获取：
一、前言介绍： 随着信息技术的飞速发展，特别是互联网和移动通信技术的普及，数字化阅读逐渐成为人们获取知识和信息的重要方式。在这样的背景下，电子图书以其便捷性和丰富性受到了广泛欢迎。随着电子图书市场的不断扩大，书籍的种类和数量也在急剧增加，这为用户挑选书籍带来了挑战。为了解决信息过载的问题，个性化推荐系统应运而生，并逐渐成为在线阅读平台不可或缺的一部分。基于用户历史行为数据进行推荐的协同过滤算法尤为流行。处理庞大的用户群体和海量的图书数据需要强大的计算能力，传统的单机计算模式已无法满足需求。Hadoop作为一个开源的分布式计算平台，以其高容错性、高扩展性和对大数据处理的优秀能力，成为大数据分析的首选工具。因此，利用Hadoop来构建电子图书推荐系统，不仅可以有效处理和分析大规模数据集，提升推荐质量，还能保证系统的可扩展性和稳定性。
基于Hadoop的豆瓣电子图书推荐系统的研究与实现能够为用户提供更加精准和个性化的阅读推荐，从而优化用户体验，提高用户满意度和平台黏性。通过分析用户的历史阅读行为和偏好，系统可以发现用户的阅读模式，进而推荐更符合个人兴趣的书籍，帮助用户节省筛选时间，增强阅读效率。对于电子图书平台来说，一个高效的推荐系统可以促进更多优质内容的分发，增加用户流量和书籍销量，从而带动平台的经济效益。该系统的建立还有助于推动数据挖掘和机器学习技术在实际应用中的发展，为相关领域提供宝贵的实践经验和研究成果。最后，随着数据处理技术的不断进步，该研究还可以为未来电子图书推荐系统的改进提供理论基础和技术支持，具有长远的研究和应用价值。
二、功能设计： 系统的功能设计是整个系统的运行基础，是一个把设计需求替换成以计算机系统的形式表示出来。通过对豆瓣电子图书推荐系统的调查、分析和研究，得出了该系统的总体规划，这是开发设计系统的初步核心。如下图所示：
爬虫数据集展示：
三、功能实现： 当人们打开系统的网址后，首先看到的就是首页界面。在这里，人们能够看到系统的导航条，通过导航条导航进入各功能展示页面进行操作。系统首页界面如图5-1所示：
在注册流程中，用户在Vue前端填写必要信息（如用户名、密码等）并提交。前端将这些信息通过HTTP请求发送到Java后端。后端处理这些信息，检查用户名是否唯一，并将新用户数据存入MySQL数据库。完成后，后端向前端发送注册成功的确认，前端随后通知用户完成注册。这个过程实现了新用户的数据收集、验证和存储。注册页面如图5-2所示：
图5-2注册详细页面
豆瓣高分：在豆瓣高分页面的输入栏中输入书名、作者、出版社和标签进行查询，可以查看到豆瓣高分详细信息，并进行评论或收藏操作；豆瓣高分页面如图5-3所示：
图5-3豆瓣高分详细页面
个人中心：在个人中心页面可以对个人中心、修改密码、我的发布、我的收藏等进行详细操作；如图5-4所示：
在登录流程中，用户首先在Vue前端界面输入用户名和密码。这些信息通过HTTP请求发送到Java后端。后端接收请求，通过与MySQL数据库交互验证用户凭证。如果认证成功，后端会返回给前端，允许用户访问系统。这个过程涵盖了从用户输入到系统验证和响应的全过程。如图5-5所示。 用户管理功能在视图层（view层）进行交互，比如点击“查询、添加或删除”按钮或填写用户信息表单。这些用户表单动作被视图层捕获并作为请求发送给相应的控制器层（controller层）。控制器接收到这些请求后，调用服务层（service层）以执行相关的业务逻辑，例如验证输入数据的有效性和与数据库的交互。服务层处理完这些逻辑后，进一步与数据访问对象层（DAO层）交互，后者负责具体的数据操作如查看、修改或删除用户信息，并将操作结果返回给控制器。最终，控制器根据这些结果更新视图层，以便用户功能可以看到最新的信息或相应的操作反馈。如图5-7所示：
图5-7用户管理界面
豆瓣高分管理功能在视图层（view层）进行交互，比如点击“查询、添加、删除或爬取数据”按钮或填写豆瓣高分信息表单。这些豆瓣高分表单动作被视图层捕获并作为请求发送给相应的控制器层（controller层）。控制器接收到这些请求后，调用服务层（service层）以执行相关的业务逻辑，例如验证输入数据的有效性和与数据库的交互。服务层处理完这些逻辑后，进一步与数据访问对象层（DAO层）交互，后者负责具体的数据操作如查看、修改、查看评论或删除豆瓣高分信息，并将操作结果返回给控制器。最终，控制器根据这些结果更新视图层，以便豆瓣高分功能可以看到最新的信息或相应的操作反馈。如图5-8所示：
图5-8豆瓣高分管理界面
管理员进行爬取数据后，点击主页面右上角的看板，可以查看到系统简介、书名、作者统计、价格统计、出版社、评分统计、豆瓣高分总数、豆瓣高分信息等实时的分析图进行可视化管理；如图5-9所示：
图5-9看板界面
四、库表设计： 表4-11：豆瓣高分
字段名称
类型
长度
字段说明
主键
默认值
id
bigint
主键
主键
addtime
timestamp
创建时间
bookname
varchar
200
书名
author
varchar
200
作者
cover
longtext
4294967295
封面
laiyuan
varchar
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27db273527d7847ca85141394351791e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06e5d1e5c457f27c5583695852db67ec/" rel="bookmark">
			Navicat和MySQL的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载 Navicat
Navicat 官网：www.navicat.com.cn/
在产品中可以看到很多的产品，点击免费试用 Navicat Premium 即可，是一套多连数据库开发工具，其他的只能连接单一类型数据库
点击试用
选择系统直接下载
二、安装 Navicat
安装很简单，只需要选择安装路径即可安装
三、激活 Navicat
1. 获取注册机
链接：https://pan.baidu.com/s/1x4P2fX3cDT1c59Rw3a352Q?pwd=lgqy 提取码：lgqy
2. 使用注册机
注意：关闭网络，关闭所有杀毒软件，WIN10/11 系统需关闭 Windows Defender 的实时保护
下载成功之后使用管理员身份打开注册机
2.1、设置安装路径，点击 Patch
出现提示，点击是
2.2、生成许可证
在 KeyGen 中选择软件，版本，语言后，点击 Generate，生成许可证
同时打开 Navicat Premium，点击注册
将生成的许可证复制到下图位置
2.3、手动激活
点击激活后，会出现服务器不可用提示，点击手动激活
1. 点击手动激活之后，只会出现激活码，将激活码复制到 Request Code 框中
2. 点击 Generate Activation Code，会在 Activation Code 框中生成激活码
3. 将 Activation Code 框中的激活码复制到左边的激活码框中，点击激活
点击激活之后成功会出现永久许可证标识
进入 Navicat 软件，点击帮助→关于，查看激活信息
通过Navicat连接到MySql数据库 1、点击连接，选择MySQL
2、自定义连接名，输入MySQL的登录密码，3306是MySQL默认的端口号
如果出现以下报错，说明你没在电脑服务里面打开MySQL服务
点开电脑服务，将MySQL80设置为自动，如果没有找到，证明你没有成功安装MySQL,接下来就是安装MySQL教程。
MySQL的下载和配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06e5d1e5c457f27c5583695852db67ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea017d5557f0cef02f16d46776e66520/" rel="bookmark">
			【LeetCode例232】【C语言】用栈实现队列~动画超详细解读!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 技术需求 了解并实现栈和队列,熟悉栈和队列的基本逻辑
这里挂上链接&lt;队列&gt; &lt;栈&gt;
1 题目介绍 1.1 看题 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作**（push、pop、peek、empty）**：
实现 MyQueue 类：
void push(int x) 将元素 x 推到队列的末尾int pop() 从队列的开头移除并返回元素int peek() 返回队列开头的元素boolean empty() 如果队列为空，返回 true ；否则，返回 false 说明：
你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 这里挂上题目链接: 232.用栈实现队列
1.2 分析 这道题目其实就是让我们用栈的基本功能以及函数实现队列的基本功能及函数
myQueueCreate - 创建MyQueuemyQueuePush - MyQueue入队myQueuePop - MyQueue出队myQueuePeek - MyQueue取队头myQueueEmpty - MyQueue判空myQueueFree - myQueue释放 比较重要的一点就是我们使用C实现,所以我们需要先手搓一遍栈的函数才能写这道题(当然完全理解过栈和队列的话CV一下也不是不行(doge))
2 解题思路 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea017d5557f0cef02f16d46776e66520/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/847e9caf048bf695d1039851d7f1ec44/" rel="bookmark">
			50个kafka常见面试题及答案，撸完阿里P7见(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java面试核心知识点笔记
其中囊括了JVM、锁、并发、Java反射、Spring原理、微服务、Zookeeper、数据库、数据结构等大量知识点。
Java中高级面试高频考点整理
最后分享Java进阶学习及面试必备的视频教学
本文已被CODING开源项目：【一线大厂Java面试题解析+核心总结学习笔记+最新讲解视频+实战项目源码】收录
需要这份系统化的资料的朋友，可以点击这里获取
HW/LEO这两个都是指最后一条的下一条的位置而不是指最后一条的位置。
LSO:Last Stable Offset 对未完成的事务而言，LSO 的值等于事务中第一条消息的位置(firstUnstableOffset)，对已完成的事务而言，它的值同 HW 相同
LW:Low Watermark 低水位, 代表 AR 集合中最小的 logStartOffset 值
4. Kafka中是怎么体现消息顺序性的？
kafka每个partition中的消息在写入时都是有序的，消费时，每个partition只能被每一个group中的一个消费者消费，保证了消费时也是有序的。
整个topic不保证有序。如果为了保证topic整个有序，那么将partition调整为1.
5. Kafka中的分区器、序列化器、拦截器是否了解？它们之间的处理顺序是什么？
拦截器-&gt;序列化器-&gt;分区器
6. Kafka生产者客户端的整体结构是什么样子的？
7. Kafka生产者客户端中使用了几个线程来处理？分别是什么？
2个，主线程和Sender线程。主线程负责创建消息，然后通过分区器、序列化器、拦截器作用之后缓存到累加器RecordAccumulator中。Sender线程负责将RecordAccumulator中消息发送到kafka中.
9. Kafka的旧版Scala的消费者客户端的设计有什么缺陷？
10. “消费组中的消费者个数如果超过topic的分区，那么就会有消费者消费不到数据”这句话是否正确？如果不正确，那么有没有什么hack的手段？
不正确，通过自定义分区分配策略，可以将一个consumer指定消费所有partition。
11. 消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset+1?
offset+1
12. 有哪些情形会造成重复消费？
消费者消费后没有commit offset(程序崩溃/强行kill/消费耗时/自动提交偏移情况下unscrible)
13. 那些情景下会造成消息漏消费？
消费者没有处理完消息 提交offset(自动提交偏移 未处理情况下程序异常结束)
14. KafkaConsumer是非线程安全的，那么怎么样实现多线程消费？
1.在每个线程中新建一个KafkaConsumer
2.单线程创建KafkaConsumer，多个处理线程处理消息（难点在于是否要考虑消息顺序性，offset的提交方式）
15. 简述消费者与消费组之间的关系
消费者从属与消费组，消费偏移以消费组为单位。每个消费组可以独立消费主题的所有数据，同一消费组内消费者共同消费主题数据，每个分区只能被同一消费组内一个消费者消费。
16. 当你使用kafka-topics.sh创建（删除）了一个topic之后，Kafka背后会执行什么逻辑？
创建:在zk上/brokers/topics/下节点 kafkabroker会监听节点变化创建主题
删除:调用脚本删除topic会在zk上将topic设置待删除标志，kafka后台有定时的线程会扫描所有需要删除的topic进行删除
17. topic的分区数可不可以增加？如果可以怎么增加？如果不可以，那又是为什么？
可以
18. topic的分区数可不可以减少？如果可以怎么减少？如果不可以，那又是为什么？
不可以
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/847e9caf048bf695d1039851d7f1ec44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b89f1a911d2ab1683d8793742096bd3/" rel="bookmark">
			Java的类和对象（一）—— 初始类和对象，this关键字，构造方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 从这篇文章开始，我们就进入到了JavaSE的核心部分。这篇文章是Java类和对象的第一篇，主要介绍类和对象的概念，this关键字以及构造方法~~
什么是类？什么是对象？ 学过C语言的老铁们，可以类比struct自定义一个结构体，类就类似结构体，对象就类似使用结构体关键字来创建结构体变量（结构体普通变量，结构体指针，结构体数组），但是类里面可以定义方法（也就是C语言中的函数）
没有学过C语言的老铁们，可以这样理解，假设你是一个建筑工程师，类就是你画出来的建筑图纸，而对象就是用图纸实际建造出来的房子，图纸就是用来描述这个房子具体的细节（长，宽，高，材料等等）
类是用来对一个实体(对象)来进行描述的，主要描述该实体(对象)具有哪些属性(外观尺寸等)，哪些功能(用来干啥)，描述完成后计算机就可以识别了。
类的创建 我们可以使用 class 关键字来定义一个类
一个类里面包含字段/属性/成员变量，也可以包含成员方法~~
class 类名{
字段、属性、成员变量;（定义在类里面，方法外面）
成员方法；
}
下面我们来定义一个学生类：
class Student{ //字段、属性、成员变量 public String name; public int age; public String stuNum; //成员方法 public void sleep(){ System.out.println(name + "睡觉"); } public void haveClass(){ System.out.println(name + "上课"); } public void doHomework(){ System.out.println(name + "做作业"); } } 对象的实例化 什么是对象的实例化，简单来说就是创建一个对象，我们需要使用类名和 new 关键字来进行创建~~
创建格式：
类名 对象 = new 类名()
代码示例：
Student student1 = new Student(); 对象的使用 我们可以通过对象来访问对象里面的成员变量和成员方法~~
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b89f1a911d2ab1683d8793742096bd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cce18451f9c118345a0f59a464104ac/" rel="bookmark">
			AI大模型探索之路-训练篇23：ChatGLM3微调实战-基于P-Tuning V2技术的实践指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列篇章💥 AI大模型探索之路-训练篇1：大语言模型微调基础认知
AI大模型探索之路-训练篇2：大语言模型预训练基础认知
AI大模型探索之路-训练篇3：大语言模型全景解读
AI大模型探索之路-训练篇4：大语言模型训练数据集概览
AI大模型探索之路-训练篇5：大语言模型预训练数据准备-词元化
AI大模型探索之路-训练篇6：大语言模型预训练数据准备-预处理
AI大模型探索之路-训练篇7：大语言模型Transformer库之HuggingFace介绍
AI大模型探索之路-训练篇8：大语言模型Transformer库-预训练流程编码体验
AI大模型探索之路-训练篇9：大语言模型Transformer库-Pipeline组件实践
AI大模型探索之路-训练篇10：大语言模型Transformer库-Tokenizer组件实践
AI大模型探索之路-训练篇11：大语言模型Transformer库-Model组件实践
AI大模型探索之路-训练篇12：语言模型Transformer库-Datasets组件实践
AI大模型探索之路-训练篇13：大语言模型Transformer库-Evaluate组件实践
AI大模型探索之路-训练篇14：大语言模型Transformer库-Trainer组件实践
AI大模型探索之路-训练篇15：大语言模型预训练之全量参数微调
AI大模型探索之路-训练篇16：大语言模型预训练-微调技术之LoRA
AI大模型探索之路-训练篇17：大语言模型预训练-微调技术之QLoRA
AI大模型探索之路-训练篇18：大语言模型预训练-微调技术之Prompt Tuning
AI大模型探索之路-训练篇19：大语言模型预训练-微调技术之Prefix Tuning
AI大模型探索之路-训练篇20：大语言模型预训练-常见微调技术对比
AI大模型探索之路-训练篇21：Llama2微调实战-LoRA技术微调步骤详解
AI大模型探索之路-训练篇22： ChatGLM3微调实战-从原理到应用的LoRA技术全解
目录 系列篇章💥前言一、服务器资源准备二、下载ChatGLM3工程1、下载工程2、安装相关依赖1）使用conda创建微调的虚拟环境2）安装ChatGLM3依赖3）安装微调依赖 三、下载ChatGLM3模型1、安装git-lfs2、执行：git lfs install3、下载模型（模型权重相关文件）4、检查权重文件 四、下载数据集1、数据集下载2、数据格式转化3、数据格式检查 五、微调脚本说明1、脚本说明（finetune_demo）2、配置说明 六、模型微调1、模型微调2、从保存点进行微调 七、推理验证1、修改模型地址2、开始模型推理 总结 前言 在人工智能的广阔领域里，大语言模型（LLMs）的微调技术扮演着至关重要的角色。它不仅为模型注入了适应特定任务的能力，而且还是通往专业领域的关键。本文旨在深入探讨基于P-Tuning V2技术的ChatGLM3微调流程，这是一种将因果语言模型与对话优化相结合的优秀实践，我们希望借此引领读者深入了解大模型微调的内涵。
在上文中，我们详细介绍了基于LoRA技术微调ChatGLM3的操作过程。而本文将重点展示基于P-Tuning V2技术的微调过程。我们将采用GLM官方在github上提供的微调脚本进行高效微调，向大家展示一种更为简单便捷的微调方法。
一、服务器资源准备 首先，服务器资源准备是微调工作的基础。根据官方提供的显存占用说明，我们需配置相应数量的显卡资源。P-TuningV2微调所需的显存相对较少，仅需1张显卡即可展开工作。
以下是官方提供的显存的占用情况说明：
1)SFT 全量微调: 4张显卡平均分配，每张显卡占用 48346MiB 显存。
2)P-TuningV2 微调: 1张显卡，占用 18426MiB 显存。
3)LORA 微调: 1张显卡，占用 14082MiB 显存。
请注意，该结果仅供参考，对于不同的参数，显存占用可能会有所不同。请结合你的硬件情况进行调整。
二、下载ChatGLM3工程 接下来，克隆ChatGLM3工程并安装相关依赖，这一系列动作将构建起我们微调工作的基本环境。
1、下载工程 从github地址中下在ChatGLM3工程，工程中包含了很多测试的demo样例，包括微调样例
git clone https://github.com/THUDM/ChatGLM3.git 2、安装相关依赖 1）使用conda创建微调的虚拟环境 #创建虚拟环境 conda create -n ChatGLM3-6b-finetunning python=3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cce18451f9c118345a0f59a464104ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0efa465621956dea74ac432b3199882/" rel="bookmark">
			【C&#43;&#43;】：模板初阶和STL简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一，泛型编程二，函数模板2.1 函数模板概念2.2 函数模板格式2.3 函数模板的原理2.4 函数模板的实例化2.5 模板参数的匹配原则 三，类模板3.1 类模板的定义格式3.2 类模板的实例化 四，STL简介（了解）4.1 什么是STL4.2 STL的版本4.3 STL的六大组件 一，泛型编程 在C语言中如何实现一个通用的交换函数呢？
void Swap(int&amp; left, int&amp; right) { int temp = left; left = right; right = temp; } void Swap(double&amp; left, double&amp; right) { double temp = left; left = right; right = temp; } 使用函数重载虽然可以实现，但是有一下几个不好的地方：
1.重载的函数仅仅是类型不同，代码复用率比较低，只要有新类型出现时，就需要用户自己增加对应的函数。
2.代码的可维护性比较低，一个出错可能所有的重载均出错。
那能否告诉编译器一个模子，让编译器根据不同的类型利用该模子来生成代码呢？
泛型编程：编写与类型无关的通用代码，是代码复用的一种手段。模板是泛型编程的基础。
二，函数模板 2.1 函数模板概念 函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生函数的特定
类型版本。
2.2 函数模板格式 template&lt;typename T1, typename T2,......,typename Tn&gt; 返回值类型 函数名(参数列表){} 使用方法如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0efa465621956dea74ac432b3199882/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c03f9f03fbfb15cc52480aff23dfc8f/" rel="bookmark">
			粒子系统技术在AI去衣应用中的创新探索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言：
随着计算机视觉和人工智能技术的飞速发展，AI去衣技术逐渐走进公众视野。这一技术以其独特的应用前景和技术挑战引起了广泛的关注。在实现衣物去除的同时保持图像质量的关键技术之一，便是粒子系统技术。本文将深入探讨粒子系统技术在AI去衣中的作用，以及它如何推动该领域的发展。
一、粒子系统技术概述
粒子系统技术是一种模拟复杂物体运动的计算方法，它通过生成大量微小的粒子并赋予它们特定的属性（如位置、速度、颜色等），来模拟烟雾、火焰、水流等不规则物体的运动效果。在计算机图形学中，粒子系统被广泛应用于视觉效果的模拟和渲染。而在AI去衣应用中，粒子系统技术主要用于模拟衣物的动态变化和去除过程，确保在去除衣物的同时，能够保留皮肤的质感和细节。
二、AI去衣技术原理
AI去衣技术通常依赖于深度学习模型，尤其是生成对抗网络（GANs）。这些模型通过训练大量带有衣物和相应无衣物的图像对，学习如何从穿着衣服的图像中生成逼真的无衣物图像。在这个过程中，粒子系统技术发挥着至关重要的作用。
三、粒子系统技术在AI去衣中的作用
动态模拟：粒子系统技术能够模拟衣物的动态变化过程，包括衣物在不同姿态和动作下的形状变化。这对于生成逼真的无衣物图像至关重要。
碰撞检测：粒子系统可以处理衣物与人体之间的碰撞检测，确保在去除衣物的过程中不会出现穿透或重叠的现象。
细节保持：通过粒子系统的精细控制，可以在去除衣物的过程中更好地保留皮肤的细节和质感。
四、粒子系统技术的挑战与优化
尽管粒子系统技术在AI去衣中扮演着重要角色，但它也面临着一些挑战。例如，大量的粒子计算需要较高的计算资源，可能导致性能瓶颈。此外，复杂的衣物运动对粒子系统的模拟精度提出了更高的要求。为了克服这些挑战，研究人员正在开发更高效的粒子生成和更新算法，并利用硬件加速技术来提升处理速度。
五、未来展望
随着粒子系统技术的不断进步和AI算法的优化，AI去衣应用的效果将越来越逼真，应用场景也将更加广泛。从电影制作到虚拟现实，再到在线购物试衣，AI去衣技术都有巨大的潜力。同时，我们也应该注意到这项技术可能带来的伦理和社会问题，确保其应用在合法和道德的范围内。
亲自试一把ai逆天的去依功能吧
下载链接:
https://pan.baidu.com/s/14U126tEZLi_LLh57wEZjpg?pwd=9999
提取码：9999
解压密码：ai_gongju
结语：
粒子系统技术在AI去衣应用中的作用不可小觑，它不仅提高了图像处理的效率和质量，还为AI去衣技术的发展提供了坚实的基础。随着技术的不断进步，我们有理由相信，粒子系统技术将在AI去衣领域发挥更大的作用，推动相关应用向更高的水平发展。同时，我们也期待这一技术在尊重隐私和道德的前提下，为人类社会带来更多的便利和创新。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ddd8a6d9c1249f9ea98c6ad177aa902/" rel="bookmark">
			【C&#43;&#43;】异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 概念 异常是一种处理错误的方式，当一个函数发现自己无法处理的错误时就可以抛出异常，让函数的 直接或间接的调用者处理这个错误
代码举例
#include&lt;iostream&gt; using namespace std; int division(int x,int y) { if (y == 0) { throw "除0错误"; } return x / y; } int main() { try { int x, y; cin &gt;&gt; x &gt;&gt; y; division(x, y); } catch (const char* e) { cout &lt;&lt; e &lt;&lt; endl; } return 0; } 运行结果：
注：
throw: 当问题出现时，程序会抛出一个异常，这是通过使用 throw 关键字来完成的
catch: 在您想要处理问题的地方，通过异常处理程序捕获异常.catch 关键字用于捕获异
常，可以有多个catch进行捕获
try: try 块中的代码标识将被激活的特定异常,它后面通常跟着一个或多个 catch 块
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ddd8a6d9c1249f9ea98c6ad177aa902/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bf200b0db08d020c3953be175010049/" rel="bookmark">
			【大数据】计算引擎MapReduce
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.概述
1.1.前言
1.2.大数据要怎么计算？
1.3.什么是MapReduce？
2.架构
3.工作流程
4.shuffle
4.1.map过程
4.2.reduce过程
1.概述 1.1.前言 本文是作者大数据系列专栏的其中一篇，专栏地址：
https://blog.csdn.net/joker_zjn/category_12631789.html?spm=1001.2014.3001.5482
本文将会聊一下计算引擎MapRedduce，深入浅出快速过一遍MapReduce的核心概念和原理，不涉及具体操作，具体操作将会在下文聊。
1.2.大数据要怎么计算？ 大数据集的数据是海量的，动辄几十上百TB，为了能将其存下来都是采用的分布式存储，将整个数据集分散到多个节点上去。要对其做统计之类的计算时，肯定不能数据向计算靠拢，将数据全部读到一个跑计算任务的节点上来进行计算，只能计算向数据靠拢，将计算任务放到存储数据的各个节点上去。并行的对整个大数据集进行计算，最后汇总成一个结果。
1.3.什么是MapReduce？ 上面描述的过程要做的工作还是很多的，管理并行的计算任务，将任务分发到各个节点上去，最后还要汇总结果，手动编码实现整个管理过程的话还是很复杂的。mapreduce作为一个并行编程框架，帮我们屏蔽掉了这一系列实现细节，让开发人员可以借助API专注的进行计算逻辑的编写。
mapreduce分为两阶段：map、reduce。
map阶段会将计算任务分发到各个数据存储节点上去跑任务，实现对大数据集的并发处理。
reduce阶段会汇总map阶段各节点上计算任务算出来的结果，聚合成最终的结果。
上述过程不难发现，mapreduce就是个主从架构的：
master节点负责总的调度、slave节点负责具体跑任务。
master：集群内有一个master服务器、也是作业追踪器JobTracker、负责整个作业的调度和处理。
slave：集群内有多个slave服务器，也是执行具体任务的TaskTracker、负责完成具体的任务。
以一个分词统计的mapreduce为例：
2.架构 Client端将任务发给JobTracker，JobTracker负责监控Job的健康状况，控制TaskTracker。JobTracker通过心跳的方式和各个TaskTracker保持联络，TaskTracker将自身的资源使用情况、任务执行进度等信息告知JobTracker。Task Scheduler负责任务的分发规则，决定最终将任务分发给谁。
TaskTracker如何衡量自身的资源使用情况？
tasktracker会将自身所在的机器的内存、CPU等资源视为一个整体，然后将其划分为一份份的slot，根据执行job需要的资源的不同，分为两种slot，map的slot和reduce的slot。taskTracker上报的资源使用情况就是自身两类slot的使用情况。
task分为两种：map task、reduce task，对应着各自执行的是map函数、reduce函数。
3.工作流程 以下是大致过程：
由于大数据集在存储的时候是分片开来，分布式存储的，所以对于map而言，输入就是数据分片。
注意1：
mapreduce处理的并不一定是单个数据，很可能处理的是整个大数据集，所以mapreduce面对的文件的分片数是不固定的，毕竟每一份文件的大小都不一样，分片数肯定不一样。所以map和分片之间不是一一对应的关系，不是说当前处理的文件有多少个分片就有多少个map，上面只是一个逻辑过程，后面会说map和分片的关系。
注意2：
map和reduce不一定是在一台机器上完成的。如果数据分片所在的服务器是台tasktracker并且有map solt可用，那么map肯定是在那台机器上完成的。如果那台机器不是台tasktracker或者没有map solt可用，那么会选择离那台机器最近的满足可做map任务的机器来处理map任务。也就是说一般map是和数据集呆在一起的（隔得近我们也可理解为趋近于本地），但是reduce可能是被分配到其它机器上完成的，因为reduce阶段需要传输的数据量已经不大了，输入只是个中间结果而已，这时候距离不是问题，效率是核心，谁算的快（reduce slot多）谁来。
以下是详细过程：
将文件读出来
将文件切割一下（split）
map运算（该有几个map任务？）
算出中间结果（shuffle）
reduce运算
算出最终结果
该有几个map任务？map和分片的数量是一致的吗？map和分片之间是一一对应的吗？
答案是：不是。
开多少map是不固定的，取决于有多少资源（map solt），所以才有了split这一步，split这一步会将数据进行切分，切出来的再交给各个map。每个map只专注于处理自己的要负责的split，这也避免了并发带来的数据安全问题。
4.shuffle 有没有发现mapreduce，map其实很简单，reduce也很简单，但是这个算出中间结果（shuffle）这一步有点绕。接下来我们详细拆解map和reduce和过程看看它是如何完成shuffle的。
4.1.map过程 以下展示的仅仅是一个map过程：
HDFS中的数据集输入，为了加速，对输入数据split，分为多个map来并发处理，一个map一个split。处理结果存在缓存中，溢写到磁盘上。溢写的时候进行分区、排序、合并，其中合并很重要：
合并：
4.2.reduce过程 一个reduce接收的输入是来自多个map的，所以首先是将多个map传过来的结果归并起，再交给reduce来使用。下面是完整过程：
假设来自多个map的数据合起来的数据集是：
先进行排序：
进行归并：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f333e95e29cc1fe42d6e193bf73b9007/" rel="bookmark">
			【C语言】C语言零基础纯干货教学（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页~
这一篇是前面基础内容的概括，我之前写过几篇，不过因为写的不太好让我删掉了，现在来补上这个缺口，本篇内容适合工科非计算机专业的以后不想从事与计算机有关方向的同学的期末考试
据我了解，非科班学生C语言只会学到函数以及和函数的递归，后续的指针等等的内容不会继续学习，本篇博文旨在教非科班学生一篇通过期末考试
C语言入门 一、C语言常见概念1、C语言是什么2、main函数3、printf以及库函数4、C语言关键字5、字符和ASCII编码6、字符串和转义字符7、语句和语句分类（1）空语句（2）表达式语句（3）函数调用语句（4）复合语句（5）控制语句①条件判断语句②循环执行语句③转向语句 8、注释（1）注释的形式① /**/ 型② // 型 （2）注意事项 二、数据类型和变量1、数据类型（1）字符型char（2）整形int（3）浮点型float、double 2、各种数据类型的长度（1）sizeof操作符（2）数据类型长度（3）sizeof中表达式不计算 2、变量（1）变量的创建（2）变量的分类①全局变量②局部变量 3、算数操作符4、赋值操作符 =（1）连续赋值（2）复合赋值符 5、单目操作符++ 、 -- 6、scanf 和 printf的使用（1）printf①基本用法②占位符③定制输出格式限定宽度：限定小数位数输出部分字符串 （2）scanf①基本用法②scanf的返回值③占位符 一、C语言常见概念 1、C语言是什么 C语言是一种计算机语言，人们通过计算机语言来给机器下达指令，它生成的文件为.c文件，通过链接和编译生成可执行程序.exe
后缀为.h的称为头文件，后缀为.c的称为源文件
2、main函数 每个C语言程序不管有几行代码，都是从main函数开始执行的，main函数是程序的入口，也被称为主函数main前面的int是整形，与最终的return 0相呼应
这里在老的版本中，main的前边是void，后来因为这个使用方法有问题就不再使用了，我们要记住的是：一个程序中，以下代码是必须存在的
int main() { return 0; } 3、printf以及库函数 printf("Hello World"); printf函数是打印函数，它可以实现信息在屏幕上的打印
它是一个库函数，可以打印不同的数据
int n = 100; printf("%d\n", n); //打印整型 printf("%c\n", 'q'); //打印字符 printf("%lf\n", 3.14);//打印双精度浮点型 printf的具体使用方法我们拿来与scanf一起讲解，这里我们主要想引出库函数的概念：
库函数就是将函数封装入库，供用户使用的一种方式
一个系列的库函数一般会生命在一个头文件当中，当你想要使用它时需要包含相应的头文件
比如我们写一个完整的Hello World程序
#include &lt;stdio.h&gt;//头文件 int main() { printf("Hello World");//printf是库函数,需要包含头文件stdio.h return 0; } 4、C语言关键字 C语言有一些关键字例如：int if return for while等等，每个关键字都有特殊的意义，是保留给C语言使用的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f333e95e29cc1fe42d6e193bf73b9007/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9ace32a72dc96c3f4cd3527a0d63503/" rel="bookmark">
			【AI智能体】零代码构建AI应用，全网都在喊话歌手谁能应战，一键AI制作歌手信息查询应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到《小5讲堂》
这是《文心智能体平台》系列文章，每篇文章将以博主理解的角度展开讲解。
温馨提示：博主能力有限，理解水平有限，若有不对之处望指正！
目录 文心智能体大赛背景创建应用平台地址快速构建【基础配置】头像【基础配置】名称【基础配置】简介【基础配置】指令【基础配置】开场白【基础配置】引导示例【高级配置】知识库 预览与调优文心大模型默认预览效果 智能体优化指令优化 推荐文章 智能体体验【歌手信息查询】：https://mbd.baidu.com/ma/s/Qps2yjBi
文心智能体大赛 报名地址：https://agents.baidu.com/center
智能体技术的快速发展，进一步激发了各行业开发者对其实际应用及用户需求的深入探索。为激发开发者的创意潜能，文心智能体平台(AgentBuilder)发起文心智能体大赛。
本赛季赛题将采用征集制，鼓励开发者积极提出赛题设想，设计出具有实际应用价值的智能体。
背景 近日，《歌手2024》掀全网热议，韩红等多名歌手“请战”。
网友也在线喊话各大知名歌手驰援那姐“战长沙”。
起因是最多一期节目排名出来，首发歌手那英、海来阿木、二手玫瑰、杨丞琳、汪苏泷、Chanté Moore（美国）、摩洛哥裔北非女歌手Faouzia一一亮相。
最终，在首场表演中获得前三名的歌手分别是Chanté Moore、Faouzia和那英。
本篇文章就通过零代码构建一个AI应用，一键查看信息快速了解歌手。
创建应用 平台地址 文心智能体平台地址：https://agents.baidu.com/
想象即实现，我觉得更接近大众化的AI应用构建平台，快来体验吧
快速构建 对于新手而言通过快速构建智能体是非常不错的方法，比如直接输入名称、设定两项即可自动完成相关信息配置。
如果你是老选手了，那么可以直接通过跳过操作，直接开始编辑相关信息。
名称：歌手信息查询
设定：你是一名歌手信息查询助手，能够通过歌手名称快速查询歌手详细信息
【基础配置】头像 会自动生成一张头像图片，当然也可以自己上传一张图片，或者对生成的图片不满足，还可以继续点击AI生成再次推荐一张图片。
建议比例1:1 / 支持格式png、jpg、jpeg、webp
【基础配置】名称 歌手信息查询
名称长度在20个字以内。
有时候，前面已经给应用填写了一个应用名称，但是快速创建的时候，它还是会自动推荐一个更加合适的应用名称，也可以改成自己想要的名字。
【基础配置】简介 快速查询歌手信息
简介长度在50个字以内。
【基础配置】指令 博主非常喜欢这个指令示例，一名了然
默认根据前面设定描述的自动生成的指令，
因为是Markdown格式，所以我把这个指令信息放到代码块，这样能够保持原样格式不变
### 角色与目标 **歌手信息查询助手**，你的主要任务是帮助用户通过歌手名称快速查询到歌手的详细信息。 ### 指导原则 1. **准确性**：确保提供的歌手信息是准确和最新的。 2. **效率性**：用户查询时，应迅速响应并提供相关信息。 3. **详尽性**：提供的信息应包括歌手的基本资料、代表作品、获奖情况等。 ### 限制 * 你不能提供关于歌手私人生活的详细信息或八卦新闻。 * 如果遇到不确定或未知的信息，请声明不知道而不是提供可能错误的信息。 ### 澄清 * 你的回答范围应仅限于公开可查的歌手信息和他们的职业成就。 * 你不应提供对歌手的主观评价或偏见。 ### 个性化 作为歌手信息查询助手，你应展现出对音乐的热爱和对歌手信息的熟悉。你总是乐于分享有趣的音乐知识和歌手背后的故事，使得查询过程更加有趣和富有信息量。 【基础配置】开场白 该描述将在欢迎气泡内作为智能体开场白展示给用户。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9ace32a72dc96c3f4cd3527a0d63503/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfad77a1cd7de4b76b3e9166e2b9d4c4/" rel="bookmark">
			【千帆AppBuidler】零代码构建AI人工智能应用，全网都在喊话歌手谁能应战，一键AI制作歌手信息查询应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到《小5讲堂》
这是《千帆平台》系列文章，每篇文章将以博主理解的角度展开讲解。
温馨提示：博主能力有限，理解水平有限，若有不对之处望指正！
目录 背景创建应用平台地址随机生成快速创建应用头像应用名称应用描述角色指令【能力扩展】组件【能力扩展】知识库【能力扩展】开场白【能力扩展】推荐问【能力扩展】追问 预览与调试大模型默认回答效果 应用优化角色指令优化组件优化知识库优化我的组件 推荐文章 背景 近日，《歌手2024》掀全网热议，韩红等多名歌手“请战”。
网友也在线喊话各大知名歌手驰援那姐“战长沙”。
起因是最多一期节目排名出来，首发歌手那英、海来阿木、二手玫瑰、杨丞琳、汪苏泷、Chanté Moore（美国）、摩洛哥裔北非女歌手Faouzia一一亮相。
最终，在首场表演中获得前三名的歌手分别是Chanté Moore、Faouzia和那英。
本篇文章就通过零代码构建一个AI应用，一键查看信息快速了解歌手。
创建应用 平台地址 百度智能云千帆AppBuilder平台地址：https://console.bce.baidu.com/ai_apaas/dialogHome
随机生成 如果你不知道要创建一个什么AI应用，那么可以尝试使用随机生成。
这样也是一种快速入门的方式方法。
快速创建 这里提供了AI生成配置信息的输入文本框，
只需要在文本框输入你的描述信息即可自动快速创建，比如
温馨提示：生成结果将覆盖当前的配置内容，请确认是否继续生成
应用头像 AI会默认推荐一张头像图片，也可以点击AI生成自动推荐一张新的头像图片，或者上传一张本地图片。
应用名称 通过上面AI生成的应用信息，会自动推荐一个应用名称【歌手小助手】，也可以自己修改目标名臣。
博主这里修改为【歌手信息查询小助手】
名称仅支持中文/英文/数字/下划线/英文点，50个字以内
应用描述 名称仅支持中文/英文/数字/下划线/英文点，50个字以内，请描述你的应用，该描述将在应用发布后固定展示。
博主这里直接使用AI推荐的描述，也可以自己优化描述。
快速查询歌手信息，提供音乐发现服务
角色指令 通过角色指令（Instruction）功能，你能够精确设定Agent应用的作用范围。包括指定应用将扮演的角色、能够使用的组件以及输出结果的格式与风格。此外，你还可以规定应用不得执行哪些操作等。
因为是Markdown格式，所以我把这个指令信息放到代码块，这样能够保持原样格式不变，一下是默认生成的角色指令：
# 角色任务 作为歌手信息查询助手，你的任务是快速响应用户查询请求，根据提供的歌手名称，迅速检索并返回该歌手的详细信息。这包括歌手的生平信息、代表作品、音乐风格、获奖记录等。你需要保持高效且准确的工作方式，确保用户能够快速获取所需信息。 # 工具能力 1. 歌手信息数据库：你需要拥有一个全面的歌手信息数据库，涵盖各个时期的歌手和他们的详细信息。 2. 搜索功能：你需要具备高效的搜索算法，能够根据用户输入的歌手名称快速定位并检索相关信息。 3. 信息准确性：确保提供的歌手信息准确无误，以维护用户的信任。 # 要求与限制 1. 响应速度：对于用户的查询请求，你需要尽快给出回应，提高用户满意度。 2. 信息完整性：提供的歌手信息应尽可能全面，包括歌手的职业生涯、音乐作品、荣誉成就等方面。 3. 避免广告和推广：在提供信息的过程中，应避免任何形式的广告和推广行为，保持信息的纯粹性和客观性。 4. 隐私保护：在收集、存储和使用歌手信息时，要遵守相关的隐私保护法规，确保用户信息的安全。 【能力扩展】组件 添加组件可以使应用具备更多能力。为保证应用效果，建议添加数目不超过4个
博主这里暂时不使用组件，感兴趣的小伙伴可以添加自带的组件，甚至可以自定义组件。
还能点击AI添加，会根据你的角色等描述智能推荐。
【能力扩展】知识库 博主这里也没有使用到知识库，感兴趣的’可以尝试体验下。
比如，可以上传一个文本文档信息
AI应用会优先查询匹配知识库里的内容，匹配到信息后会使用知识库里的内容进行优化输出。
Chanté Moore，艺名Chante Moore，是一位知名的的美国节奏蓝调及灵魂乐女歌手。她在90年代初期开始她的音乐生涯，以其强大的嗓音和情感深沉的歌曲而闻名。 代表作品： 她的代表作品包括多首深受欢迎的单曲，如“Love's Taken Over”和“It's Alright”。她的音乐风格深受灵魂乐、节奏蓝调和流行乐的影响，为听众带来了许多经典之作。 获奖情况： Chanté Moore在她的职业生涯中获得了一些音乐奖项的认可，包括多项音乐大奖的提名。她的音乐作品不仅在排行榜上取得了不俗的成绩，还赢得了众多乐迷的喜爱。 总的来说，Chanté Moore以其独特的音乐风格和深情的嗓音，在音乐界留下了深刻的印记。希望这些信息能帮到你！ 【能力扩展】开场白 默认推荐的开场白
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfad77a1cd7de4b76b3e9166e2b9d4c4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/17/">«</a>
	<span class="pagination__item pagination__item--current">18/71</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/19/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>