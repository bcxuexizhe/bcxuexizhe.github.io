<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3c3a6c85307dc5421947c72c80f6870/" rel="bookmark">
			基于Python和Neo4j搭建知识图谱医药问答系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、启动Neo4j
二、安装py2neo库
三、Python连接Neo4j
四、Pycharm中搭建医药知识图谱
1、读取文件
2、建立节点
3、创建知识图谱中心疾病的节点
4、创建知识图谱实体节点类型
5、创建实体关系边
6、创建实体关联边
7、导出数据
8、运行程序
9、运行结果
五、Pycharm中实现自动问答系统
1、模型初始化
2、问答主函数
3、运行程序
4、运行结果
六、其他（问答子函数）
1、问句类型分类脚本
2、问句解析脚本 3、问答程序脚本 总结
前言 本案例用Pycharm编写Python程序操作Neo4j搭建知识图谱医药问答系统实战练习
本案例借鉴刘焕勇老师个人项目
一、启动Neo4j 如何启动Neo4j，请参考此教程
运行项目前，先清空Neo4j数据库
MATCH (n) DETACH DELETE n
二、安装py2neo库 代码学习参考py2neo官网文档
pip install py2neo
三、Python连接Neo4j 链接Neo4j的地址为："bolt://localhost:7687"
在本章中最开始的部分已经更改用户名默认为neo4j，密码在本章中最开始的部分已经更改
import json import os from py2neo import Graph, Node class MedicalGraph: def __init__(self): cur_dir = '/'.join(os.path.abspath(__file__).split('/')[:-1]) self.data_path = os.path.join(cur_dir, 'data/medical.json') self.g = Graph("bolt://localhost:7687", auth=("neo4j", "tang2001")) 注意：build_medicalgraph.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3c3a6c85307dc5421947c72c80f6870/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/124489eab87437f3a4a41ceac8f9b389/" rel="bookmark">
			头歌 算法 实验七 动态规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1关：数塔问题 300
任务要求参考答案评论9 任务描述相关知识编程要求解题思路：测试说明 任务描述 本关任务：编写用动态规划解决数塔问题。
相关知识 为了完成本关任务，你需要掌握：动态规划。
编程要求 求上图从顶层到顶层的一个路径，使路径上的数字和最大。要求输出最大的数字和max和数值和最大的路径。
解题思路： 原始信息有层数和数塔中的数据，层数用一个整型变量n存储，数塔中的数据用二维数组data，存储成如下的下三角阵:
912 1510 6 82 18 9 519 7 10 4 16 必需用二维数组d存储各阶段的决策结果。二维数组d的存储内容如下：
d[n][j]=data[n][j]， j=1,2,……,n；d[i][j]=max(d[i+1][j]，d[i+1][j+1])+data[i][j]， i=n-1,n-2,……1，j=1,2,……,i 最后d[1][1]存储的就是问题的结果。
测试说明 平台会对你编写的代码进行测试：
测试输入：
5912 1510 6 82 18 9 519 7 10 4 16 输出示例：
max=59数值和最大的路径是：9-&gt;12-&gt;10-&gt;18-&gt;10 开始你的任务吧，祝你成功！
#include &lt;stdio.h&gt; int main(){ int a[50][50][4],i,j,n; // printf("Please input the number of rows:\n"); // scanf("%d",&amp;n); n = 5; i=1; a[1][1][1]=9; a[2][1][1]=12, a[2][2][1]=15; a[3][1][1]=10, a[3][2][1]=6, a[3][3][1]=8; a[4][1][1]=2, a[4][2][1]=18, a[4][3][1]=9, a[4][4][1]=5; a[5][1][1]=19, a[5][2][1]=7, a[5][3][1]=10, a[5][4][1]=4, a[5][5][1]=16; for(i=1;i&lt;=n;i++) for(j=1; j&lt;=i; j++) { a[i][j][2]=a[i][j][1]; a[i][j][3]=0; } for(i=n-1; i&gt;=1; i--) for(j=1; j&lt;=i; j++) if(a[i+1][j][2]&gt;a[i+1][j+1][2]) { a[i][j][2] = a[i][j][2] + a[i+1][j][2]; a[i][j][3] = 0; } else { a[i][j][2] = a[i][j][2] + a[i+1][j+1][2]; a[i][j][3] = 1; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/124489eab87437f3a4a41ceac8f9b389/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e8233227c5b38d61e3d2bf4606b4d74/" rel="bookmark">
			Java中List排序的3种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们程序的编写中，有时候我们需要在 Java 程序中对 List 集合进行排序操作。比如获取所有用户的列表，但列表默认是以用户编号从小到大进行排序的，而我们的系统需要按照用户的年龄从大到小进行排序，这个时候，我们就需要对 List 集合进行自定义排序操作了。
List 排序的常见方法有以下 3 种：
使用 Comparable 进行排序；
使用 Comparator 进行排序；
如果是 JDK 8 以上的环境，也可以使用 Stream 流进行排序。
下面我们分别来看各种排序方法的具体实现。
1.使用 Comparable 排序 创建一个包含了用户列表的 List 集合，并按用户的年龄从大到小进行排序，具体实现代码如下：
import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import java.util.ArrayList; import java.util.Collections; import java.util.List; public class ListSortExample { public static void main(String[] args) { // 创建并初始化 List List&lt;Person&gt; list = new ArrayList&lt;Person&gt;() {{ add(new Person(1, 30, "张三")); add(new Person(2, 20, "李四")); add(new Person(3, 40, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e8233227c5b38d61e3d2bf4606b4d74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f39c440981861f92a3e8bb3d5b7a43bb/" rel="bookmark">
			10个实用的Python编程实例，助你快速掌握Python技巧！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一门简洁易学且强大的编程语言，Python广泛应用于各个领域。本文将向大家介绍10个实用的Python编程实例，通过详细的实例代码帮助读者快速掌握Python的基础知识和常用技巧。
1. 计算阶乘
def factorial(n): if n == 0: return 1 else: return n * factorial(n-1) num = 5 result = factorial(num) print(f"The factorial of {num} is {result}") 2. 判断素数
def is_prime(n): if n &lt;= 1: return False for i in range(2, int(n/2)+1): if n % i == 0: return False return True num = 17 if is_prime(num): print(f"{num} is a prime number") else: print(f"{num} is not a prime number"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f39c440981861f92a3e8bb3d5b7a43bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40d10598314e39fe5e2fd92acc7ddf8c/" rel="bookmark">
			AGI和AIGC傻傻分不清楚，一篇文章带你get
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Look！👀我们的大模型商业化落地产品📖更多AI资讯请👉🏾关注Free三天集训营助教在线为您火热答疑👩🏼‍🏫 什么是 AGI(人工通用智能)?
AGI 是 Artificial General Intelligence 的缩写，中文翻译为“通用人工智能”，该术语指的是机器能够完成人类能够完成的任何智力任务的能力。
与狭义的人工智能(ANI)不同，狭义的人工智能是为特定领域或问题而设计的，而AGI旨在 实现一般的认知能力，能够适应任何情况或目标。AGI是人工智能研究的最终目标之一，也 是科幻小说和未来研究的一个共同主题。
AGI 也被称为强人工智能(Strong AI)或全人工智能(Full AI)。然而，这些术语可能有不 同的含义或意义，取决于上下文或来源。例如，一些研究人员可能用强人工智能来表示具有 意识或知觉的机器，而其他人则可能与 AGI 交替使用。
AIGC和AGI？
AGI与AIGC（Artificial Intelligence Generated Content，人工智能生成内容）有显著区别。AIGC指的是利用AI技术，尤其是机器学习和深度学习模型，自动生成内容，如文本、图像、音乐或视频。AIGC通常专注于特定的创作任务，而不具备AGI的广泛智能和通用学习能力。
在谈论AGI时，人工智能 和 机器学习领域国际上最权威的学者之一DeepLearning.AI创始人吴恩达认为，尽管AGI是一个激动人心的概念，但我们目前对实现真正的AGI还有很长的路要走。他强调，现有的AI技术，尽管在特定任务上表现出色，但仍然缺乏通用性和灵活性。吴恩达提倡实用主义的观点，专注于利用当前的AI技术解决实际问题，同时对于未来AI的发展保持开放和审慎的态度。他认为，AGI的研究是有价值的，但也强调在达到真正的AGI之前，还需要解决许多基础和实际的问题。
AGI 的能力
AGI 的定义和标准并没有一个普遍的共识，因为不同领域和学科对人类智能的构成可能有不同的观点。然而，一些通常与 AGI 相关的常⻅能力包括:
在不确定的情况下进行推理、规划和问题解决 代表和使用常识性知识从数据和经验中学习用自然语言进行交流 整合多种技能以实现共同目标 创造力、想象力和自主性
到今天为止，还没有真正的 AGI 系统存在，哪怕是诸如Chat GPT和文心一言，也不清楚何时或如何实现。一些专家认为，AGI 是可能的和不可避免的，而另一些专家则对其可行性和可取性持怀疑或悲观态度。AGI的发 展带来了许多技术、伦理和社会挑战，需要研究人员、政策制定者和整个社会共同解决。
关于AIGC和AGI的解读，我们近屿智能OJAC推出的《AIGC星辰大海：大模型工程师和产品专家深度训练营》就是学习这部分知识的最好选择。我们的课程是一场结合了线上与线下的双轨合流式学习体验。
别人教您使用AIGC产品，例如ChatGPT和MidJourney，我们教您增量预训练，精调大模型，和创造属于自己的AI产品!
您是否想利用AIGC为您打破职业与薪资的天花板？您是否想成为那个在行业里脱颖而出的AI专家？我们的培训计划，将是您实现这些梦想的起点。
让我带您了解一下近屿智能OJAC如何帮您开启AI的大门。
首先，为了让零基础的您也能轻松上手，我们特别设计了“Python强化双周学”这个先修课程。在两周的时间里，我们将通过在线强化学习，把大模型相关的Python编程技术娓娓道来。就算您现在对编程一窍不通，也不要担心，我们会带您一步步走进编程的世界。
然后，是我们的“AIGC星辰大海：大模型工程师与AIGC产品经理启航班”。这个课程包含6节精彩的直播课，不仅能让您深入了解ChatGPT等大模型的奥秘，还会带您领略至少20个来自全球的成功AIGC产品案例。想象一下，未来您同样有机会利用这些先进技术打造出热门AI产品！
更深层次的学习，则在“AIGC星辰大海：大模型工程师和产品专家深度训练营”中进行。这个深度训练营覆盖了从理论基础到实际操作的全过程，让您不仅学会理论，更能将知识应用到实际项目中。如果您想要深挖大模型的秘密？这里就是您的实验室！
如果您选择加入我们的OJAC标准会员，我们的"AI职场导航"项目，还将为您提供量身定制的职业机会，这些职位来自于我们广泛的行业网络，包括初创企业、中型企业以及全球知名公司。我们会根据您的技能、经验和职业发展愿景，为您筛选合适的机会。此外，我们也提供简历修改建议、面试准备指导和职业规划咨询，帮助您在竞争激烈的市场中脱颖而出。
同时您也可以享受到未来景观AI讲座暨每月技术洞见”系列讲座，获得最新的技术洞见。这不仅是一个学习的机会，更是一个与行业顶尖大咖直接交流的平台。
以下是我们大模型工程师和产品专家深度训练营的课程内容：
除此之外，现在报名我们即将开班的第六期AIGC星辰大海大模型工程师和产品经理训练营，您将可以参与到以下三个创新实战项目中的任意一个，这些项目不仅能够锻炼您的实战能力，还能让您在AIGC领域脱颖而出。
项目1:企业级知识问答GPT
这个项目将教您如何打造一个智能机器人，它能够接入企业内部的知识库，如技术文档、HR政策、销售指南等。您将学会如何使其具备强大的自然语言处理能力，进行复杂查询的理解和精确答案的提供。此外，该项目还包括教您如何让机器人保持对话上下文、支持多语言交流，并具备反馈学习机制，以不断提升服务质量。
项目2:行业级AI Agent
在这个项目中，您将学习如何为特定行业定制化AI Agent。您将被指导如何让它理解行业专有术语和工作流程，并训练它自动执行任务，如预约设置、数据输入和报告生成。这个项目不仅帮助您构建一个决策支持系统，还教您如何进行用户行为预测和性能监控与优化。
项目3:论文翻译
如果您对语言学习和学术研究有浓厚兴趣，这个项目将是您的理想选择。您将探索如何实现从英语到中文或其他目标语言的精准学术翻译，确保保留学术文献的深层含义。本项目还包括学术格式定制、专业词汇精确匹配以及广泛语言选项的训练，最后通过翻译效果评价系统，您将能够持续提升翻译质量。
无论您选择哪个项目，都将是您职业生涯中不可多得的实战经历。
我们诚邀您继续与我们携手前行。在未来的职业道路上，让我们共同探索AI的更多奥秘，共创辉煌。如果您还有任何疑问或者想要深入了解更多课程内容，请随时联系我们。我们期待着与您共同开启下一阶段的AI探索之旅。
加入我们的“AIGC星辰大海”训练营，让我们一起在AI的世界里创造不凡！立刻加入我们，开启您的AI大模型旅程，将梦想转变为现实。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b8759e2392ce43b9fb4ac2efea056da/" rel="bookmark">
			大数据开发之电商数仓（hadoop、flume、hive、hdfs、zookeeper、kafka）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第 1 章：数据仓库 1.1 数据仓库概述 1.1.1 数据仓库概念 1、数据仓库概念：
为企业制定决策，提供数据支持的集合。通过对数据仓库中数据的分析，可以帮助企业，改进业务流程、控制成本，提高产品质量。
数据仓库并不是数据的最终目的地，而是为数据最终的目的地做好准备，这些准备包括对数据的：清洗、转义、分类、重组、合并、拆分、统计等。
2、数据仓库的数据通常包括：业务数据、用户行为数据和爬虫数据等
3、业务系统数据库（关系型数据库中）
1）业务数据：主要指的是各行业在处理事务过程中产生的业务数据
2）产生：用户在电商网站中登录、下单、支付等过程中，需要和网站后台数据库进行增删改查交互，产生的数据
3）存储：都是存储到关系型数据库（如：mysql、oracle）中。
4、用户行为数据（日志文件log）
1）用户行为数据：用户在使用产品过程中，通过埋点与客户端产品交互所产生的数据，并发往日志服务器进行保存。
2）存储：用户数据通常存储在日志文件中。
5、爬虫数据：通过技术手段获取其它公司网站的数据。
1.1.2 数据仓库示意图 数据仓库（data warehouse），为企业指定决策，提供数据支持的。可以帮助企业，改进业务流程、提高产品质量等。
数据仓库，并不是数据的最终目的地，而是为数据最终的目的地做好准备。这些准备包括对数据的：备份、清洗、聚合、统计等。
1、报表系统：对存储的数据做数据统计分析
2、用户画像：即用户信息标签化，是基于数据挖掘的用户特征提取即需求深度挖掘，是大数据时代围绕“以用户为中心”开展的个性化服务。标签化的模型是从用户社交属性、生活习惯、消费行为等信息中抽象出来的产物，是用户“特征标签”的几个。
3、推荐系统：通过对用户的历史行为、用户兴趣偏好来经过推荐算法计算分析，然后产生用户可能感兴趣的项目列表。推荐系统可以更精准的理解用户需求，对用户进行聚类、打标签，推荐用户感兴趣的商品，帮助用户快速找到需要的商品，同时放大需求、增加流量入口、提高商品销售的有效转化率。
4、机器学习：利用机器学习算法模型基于大数据集进行数据挖掘，发现和利用数据价值。
1.2 数仓项目搭建概述 1.2.1 项目需求分析 1、数据需求：用户分析日志log、业务数据db
2、采集需求：日志采集系统（flume）、业务数据同步系统（Maxwell，datax）
3、数据仓库建模：维度建模
4、数据分析：对设备、会员、商品、地区、活动等电商核心主题进行统计，统计的报表指标接近100个。
5、即席查询：用户在使用系统时，根据自己当时的需求定义的查询，通常使用即席查询工具。
6、集群监控：对集群性能进行监控，发生异常及时报警。
7、元数据管理：存储所有表对象的详细信息，通过元数据管理有助于开发人员理解管理数据。
8、数据质量监控：数据质量是数据分析和数据挖掘结果有效性和准确性的基础。数据的导入导出是否完整、一致等问题。一般使用数据质量监控工具完成。
1.2.2 项目框架 思考：项目技术如何选型？
1、技术选型
考虑的因素：数据量的大小、业务需求、行业经验、技术成熟度、开发维护成本、总成本预算
技术选型
数据采集传输：Flume、kafka、datax，maxwell，sqoop，logstash
数据存储：mysql、hdfs、hbase、redis、mongodb
数据计算：hive、spark、flink、storm、tez
数据查询：presto、kylin、impala、druid、clickhouse、doris
数据可视化：superset、echarts、quickbi、datav
任务调度、dolphinscheduler、azkabanoozie、airflow
集群监控：zabbix、prometheus
元数据管理：atlas
权限管理：ranger、sentry
2、系统流程设计
思考：框架版本如何选择？
3、框架版本选型
1）框架选型
(1)如何选择apache/cdh/hdp版本？
apache：运维麻烦，组件间兼容性需要自己调研。（大厂使用）
cdh：国内使用最多的版本，开始收费
hdp：开源，可以进行二次开发，但没cdh稳定，国内很少使用
（2）云服务选择
阿里云的emr、maxcompute、dataworks
亚马逊云emr
腾讯云emr
华为云emr
2）apache框架版本选型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b8759e2392ce43b9fb4ac2efea056da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2f9d31e9d028c64daadf495e08d88b6/" rel="bookmark">
			Zookeeper的性能测试与评估实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景介绍 1. 背景介绍 Apache Zookeeper是一个开源的分布式协调服务，用于构建分布式应用程序。它提供了一组原子性的基本服务，如集群管理、配置管理、同步、组管理等。Zookeeper的性能对于分布式应用程序的稳定性和可靠性至关重要。因此，在实际应用中，我们需要对Zookeeper的性能进行测试和评估。
本文将从以下几个方面进行深入探讨：
核心概念与联系核心算法原理和具体操作步骤数学模型公式详细讲解具体最佳实践：代码实例和详细解释说明实际应用场景工具和资源推荐总结：未来发展趋势与挑战附录：常见问题与解答 2. 核心概念与联系 在进行Zookeeper的性能测试与评估之前，我们需要了解一下其核心概念和联系。
2.1 Zookeeper的基本组件 Zookeeper的主要组件包括：
ZooKeeper服务器：Zookeeper集群由多个服务器组成，每个服务器称为ZooKeeper服务器。服务器之间通过网络进行通信，共同提供Zookeeper服务。ZooKeeper客户端：Zookeeper客户端是应用程序与Zookeeper服务器通信的接口。客户端可以是Java、C、C++、Python等多种语言的实现。ZNode：ZNode是Zookeeper中的一种数据结构，类似于文件系统中的文件和目录。ZNode可以存储数据、配置信息等。Watcher：Watcher是Zookeeper客户端与服务器之间通信的一种机制，用于通知客户端数据变化。 2.2 Zookeeper的一致性模型 Zookeeper采用半同步一致(Semi-Synchronous Replication，SSR)模型来实现数据一致性。在这个模型中，当客户端向Zookeeper服务器写入数据时，服务器会先将数据写入本地磁盘，然后通过网络发送给其他服务器。当其他服务器接收到数据后，会将数据写入本地磁盘，并通知发送方服务器写入成功。当发送方服务器收到通知后，才会将写入操作标记为成功。
半同步一致性模型可以确保数据的一致性，同时也能尽可能地减少延迟。
3. 核心算法原理和具体操作步骤 Zookeeper的性能测试与评估主要涉及以下几个方面：
吞吐量测试：测试Zookeeper服务器在单位时间内可以处理的请求数量。延迟测试：测试Zookeeper服务器处理请求的平均延迟时间。可用性测试：测试Zookeeper服务器的可用性，即在给定时间内服务器可以正常工作的概率。 3.1 吞吐量测试 吞吐量测试的目的是测试Zookeeper服务器在单位时间内可以处理的请求数量。通常情况下，我们可以使用压力测试工具(如Apache JMeter、Gatling等)进行吞吐量测试。
具体操作步骤如下：
准备压力测试工具和测试场景。启动Zookeeper服务器集群。使用压力测试工具模拟大量客户端请求，并记录请求处理情况。分析测试结果，得出Zookeeper服务器的吞吐量。 3.2 延迟测试 延迟测试的目的是测试Zookeeper服务器处理请求的平均延迟时间。通常情况下，我们可以使用性能测试工具(如Apache Abalone、ZKPerf等)进行延迟测试。
具体操作步骤如下：
准备性能测试工具和测试场景。启动Zookeeper服务器集群。使用性能测试工具测量Zookeeper服务器处理请求的延迟时间，并记录结果。分析测试结果，得出Zookeeper服务器的平均延迟时间。 3.3 可用性测试 可用性测试的目的是测试Zookeeper服务器的可用性，即在给定时间内服务器可以正常工作的概率。通常情况下，我们可以使用故障测试工具(如Apache ZKFault、ZooKeeperFaultInjection等)进行可用性测试。
具体操作步骤如下：
准备故障测试工具和测试场景。启动Zookeeper服务器集群。使用故障测试工具模拟服务器故障，并记录服务器可用性情况。分析测试结果，得出Zookeeper服务器的可用性。 4. 数学模型公式详细讲解 在进行Zookeeper的性能测试与评估时，我们可以使用一些数学模型来描述Zookeeper服务器的性能指标。以下是一些常见的数学模型公式：
吞吐量(Throughput)：吞吐量是指单位时间内处理的请求数量。公式为：
$$ Throughput = \frac{Number\ of\ requests}{Time} $$
延迟(Latency)：延迟是指请求处理的平均时间。公式为：
$$ Latency = \frac{Total\ delay}{Number\ of\ requests} $$
可用性(Availability)：可用性是指在给定时间内服务器可以正常工作的概率。公式为：
$$ Availability = \frac{Uptime}{Total\ time} $$
5. 具体最佳实践：代码实例和详细解释说明 在进行Zookeeper的性能测试与评估时，我们可以参考以下代码实例和详细解释说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2f9d31e9d028c64daadf495e08d88b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4d1fe148c39dc4ed51b7ce5c6459c98/" rel="bookmark">
			前端环境搭建——node（保姆级）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录：
Step1：下载系统对应安装包
Step2：安装 node 程序
Step3：配置系统环境变量path
Step4：更改依赖下载配置
Step1：百度进入 node 官网，根据自己电脑系统下载对应 node 安装包（如果已经有安装包可以跳到 Step2）
① 百度输入 nodejs，进入中文官网
② 不建议下载最新版，可能会在运行时出现某些问题，可以点击“其他版本”下载历史稳定版
③ 点击父级目录查看更多下载选项
④ 下载系统对应的安装包到本地
Step2：安装 node 程序
① 下载完成后，双击安装包，开始安装，使用默认配置安装一直点next即可，安装路径默认在C:\Program Files下，建议自定义修改（避免占用过多系统盘空间）
② 自定义修改安装路径，而后点击next
③ 下图根据本身的需要进行，我选择了默认Node.js runtime，而后Next
Node.js runtime ：表示运行环境
npm package manager：表示npm包管理器
online documentation shortcuts ：在线文档快捷方式
Add to PATH：添加到环境变量
④ 以下图框中所示，我没有选中，而是直接next
⑤ 点击Install，进行安装
⑥ 点击finish，完成安装
Step3：配置系统环境变量path
① 在 node 程序安装目录下新建两个文件夹【node_global】和【node_cache】
② 配置依赖下载目录和缓存目录（执行的时候建议使用管理员权限打开CMD，否则有可能会提示权限不够报错）
打开cmd命令窗口，输入npm config set prefix “你的路径\node_global”
npm config set cache “你的路径\node_cache” ③ 配置全局环境变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4d1fe148c39dc4ed51b7ce5c6459c98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86f5c54994c50b955597c3b1c8acf89b/" rel="bookmark">
			如何在Mac上安装PHP环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前置环境：HomeBrew
# Homebrew 是 Mac 上最好的包管理器之一，可以用于安装各种开源软件。从 Terminal（终端）执行以下命令安装 Homebrew： /usr/bin/ruby -e $(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 一、安装php7.2 # 安装必要的扩展 以下命令安装了 Mcrypt、Opcache、Redis、Xdebug 和 Yaml 五个扩展。可以根据具体需求选择安装其他扩展。 brew install php70-mcrypt php70-opcache php70-redis php70-xdebug php70-yaml # 安装 PHP 版本 # brew install php # 执行这个命令将会安装 Homebrew 中最新版本的 PHP # 如果需要安装其他版本的 PHP 可以使用以下命令进行查找： brew search php # 然后可以根据需要安装特定版本的 PHP，例如安装 PHP 7.2 版本： brew install php@7.2 二、配置 PHP cd /etc sudo nano php.ini # 在这个文件中可以修改一些 PHP 配置，例如文件上传大小限制、时区等。一些常用的设置如下： # 内容BEGIN upload_max_filesize = 2M post_max_size = 8M date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86f5c54994c50b955597c3b1c8acf89b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9dce9bcc2196ab4b7921bc8b969d020/" rel="bookmark">
			【机器学习 | 异常检测】孤立森林（isolation Forest）iForest 算法理论讲解及 Python 实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、原理二、具体流程2.1 训练森林2.2 首先要明确几个相关概念2.3 异常分数2.4 检测过程 三、优缺点3.1 优点3.2 缺点 四、代码实战4.1 准备数据4.2 模型4.3 可视化边缘 一、原理 孤立森林（Isolation Forest，简称 iForest）是一种无监督学习算法，用于识别异常值。
其基本原理可以概括为一句话：异常数据由于数量较少且与正常数据差异较大，因此在被隔离时需要较少的步骤。
有两个假设：
异常的值是非常少的（如果异常值很多，可能被识别为正常的）异常值与其他值的差异较大（这点也可以引出主要是全局上都为异常的异常，局部小异常可能发现不了，因为差异并不大） 二、具体流程 2.1 训练森林 子采样: 首先从整个数据集中随机抽取一定数量的样本来为构建树做准备。这些抽样的子集大小通常远小于原始数据集的大小，这样可以限制树的大小，并且减少计算复杂度。构建孤立树 (iTrees): 对于每个子采样集，算法构建一棵孤立树。构建孤立树的过程是递归的。在每个节点，算法随机选择一个特征，并在该特征的最大值和最小值之间随机选择一个分割值。然后，数据根据这个分割值将样本分到左子树或右子树（这里其实就是简单的将样本中特征小于这个分割点的样本分到左边，其次分到右边）。这个过程的结束条件：树达到限定的高度， 节点中的样本数量到一定的数目，或者所有样本的所选特征值都是同一个值。森林构建: 重复1-2构建完特定数量的孤立树，集合为孤立森林。 2.2 首先要明确几个相关概念 路径长度（ h ( x ) h(x) h(x)）: 指样本通过该孤立树构建阶段的特征选择方式，从树的根节点到达该样本被孤立的节点（被孤立就是意味着这个样本最终到达的树的叶子节点）所需要的边数。平均路径长度 E ( h ( x ) ) E(h(x)) E(h(x)): 该样本在森林中所有树的路径长度的平均值。树的平均路径长度：
c ( n ) = 2 H ( n − 1 ) − 2 ( n − 1 ) n c(n)=2H(n-1)-\frac{2(n-1)}{n} c(n)=2H(n−1)−n2(n−1)​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9dce9bcc2196ab4b7921bc8b969d020/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a07394b3bf32ee658927d47bd9c1129a/" rel="bookmark">
			【数据库】Navicat Premium 15安装与激活
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PS：安装过程中一定要断网！！断网！！断网！！
1 安装 1.1 点击下一步 1.2 许可证选择“我同意”，点击下一步 1.3 选择安装文件夹，可以点击浏览，自定义安装路径，点击下一步 1.4 创建快捷方式位置，保持默认，点击下一步 1.5 勾选创建桌面图标，点击下一步 1.6 点击“安装” 1.7 进行安装 1.8 点击完成 1.9 右键“以管理员身份运行” 2 激活 PS:（1）确保Navicat Premium程序已关闭。（2）注册机来源于DeltaFoX（GitHub）。杀毒软件会将其认定为病毒，下载之后会产生找不到该注册机的问题，解决方式是关闭杀毒软件或将本注册机加入杀毒软件白名单。
2.1 启动注册机Navicat Keygen Patch 2.2 查看Patch条目的选择项 1) Patch ====&gt; 勾选Backup，Host ====&gt; 应用选择Navicat v15
2.3 点击Patch按钮 出现 navicat.exe - x64 -&gt; Cracked! 提示表示已破解！
2.4 请选择以下参数，参数正确后，选择Generate 2) License, Product and Language ====&gt; License为Enterprise，Products为Premium，Languages为Simplified Chinese（即简体中文，其它语言版本如英文版请选择English）
3) Resale License ====&gt; Resale Version为Site license
4) - Keygen / Offline Activation ====&gt; Your Name和Your Organization可以任意填写或者默认 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a07394b3bf32ee658927d47bd9c1129a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6d661359bede91d65b5f515c61fee8f/" rel="bookmark">
			python七种数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 python数据类型主要分为以下七大类：
Numbers（数字） Boolean（布尔） String（字符串） List（列表） Tuple（元组） Dictionary（字典） Set（集合）
Python 的七个标准数据类型中：
不可变数据类型（4 个）：Number（数字）、Boolean（布尔）、String（字符串）、Tuple（元组）； 可变数据类型（3 个）：List（列表）、Dictionary（字典）、Set（集合）。
可变数据类型的内容可以随着函数的执行发生变化，而不可变数据类型的则不行。
问：如何判断一个变量的类型？
答：①使用type(变量名称)方法，返回变量的数据类型②isinstance(变量名称，数据类型)，只能返回True或False(真的还是假的)
1.数字类型（Numbers） 数值类型就是我们日常生活中的数字
python的数字类型包括：
int（长整型） float（浮点型） complex（复数）
# 整型int,浮点型float a=1 b=1.1 print(a,b,type(a),type(b),isinstance(a,int)) #输出结果为 #1 1.1 &lt;class 'int'&gt; &lt;class 'float'&gt; True 2.布尔类型（Boolean） 布尔类型是与逻辑相关一种数据类型，只有两个值：True(真)与False(假)
其中布尔类型值可以相加，但一旦相加，类型就会转换为int类型
# 2.布尔型Boolean c=True d=False d=c+d print(type(c),type(d),d) #输出结果 #&lt;class 'bool'&gt; &lt;class 'int'&gt; 1 3.字符串类型（String） 在Python变量定义中，如果其赋值的内容是通过单引号或双引号引起来的内容就是字符串str类型。
字符串操作：
1.字符串索引
a[i]代表字符串a第i+1个位置的索引，a[-1]代表字符串a最后一个位置的索引
2.字符串截取
s=a[i:j],其中i,j可以不写，表示从位置i开始到位置j结束，其中截取的字符串不包括位置j
3.字符串拼接：“+”
4.字符串复用：“*“
# 3.字符串str f='我是小高' g=',你呢' print(f[0],f[-1],f[:3],f[1:-1],f+g,f*3) # 我 高 我是小 是小 我是小高,你呢 我是小高我是小高我是小高 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6d661359bede91d65b5f515c61fee8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b3dac8ab1ba551321be36ccfd1f78aa/" rel="bookmark">
			Mac 出现zsh: command not found: pnpm解决方法：环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		把 bash shell 中.bash_profile 全部环境变量加入zsh shell里就好了
1、open .zshrc 将下面环境变量加入到最后面：
source ~/.bash_profile 2、source .bash_profile 3、source .zshrc 更新配置 4、touch .bash_profile 创建.bash_profile 5、mkdir ~/.npm-global（若已有文件则无需创建）
6、npm config set prefix '~/.npm-global' 7、open .bash_profile 将下列语句插入到文件最后保存：
export PATH=~/.npm-global/bin:${PATH} 7、source .bash_profile 更新配置 最后解决了该问题：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ca0214a1a6888edd47b1c0400629bea/" rel="bookmark">
			AIGC内容分享(六十三)：AIGC在文旅行业的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
智能导游：AIGC助力游客深度体验
虚拟现实旅游：打破时空限制
文化创意产品：为文旅产业增值
智能内容生成：提升文旅企业运营效率
个性化营销：精准触达潜在客户
总结
本文将探讨AIGC在文旅行业的应用场景，以及它如何为游客提供沉浸式体验，推动文旅产业数字化转型，实现线上线下融合，提升行业竞争力，助力文旅产业转型升级。
智能导游：AIGC助力游客深度体验 AIGC技术可以帮助文旅企业开发智能导游应用，为游客提供个性化的游览路线推荐。通过分析游客的兴趣、偏好和历史行为，智能导游应用可以为游客推荐最适合他们的游览路线。这样，游客可以在有限的时间内更高效地游览景点，并获得更好的旅游体验。
在景点讲解方面，通过智能导游应用，游客可以随时随地了解景点的历史、文化、艺术等方面的信息。这种讲解方式不仅生动有趣，而且可以根据游客的需求和兴趣进行调整，提供更加个性化的服务。
在游戏互动方面，通过将景点与游戏相结合，游客可以在游览过程中参与各种有趣的游戏和挑战，增加旅游的趣味性和互动性。这种互动方式可以激发游客的兴趣和好奇心，让他们更加投入地了解景点和文化。
虚拟现实旅游：打破时空限制 AIGC技术可以生成逼真的虚拟现实场景，为游客提供一种全新的文旅体验方式。通过虚拟现实技术，游客可以在家中就能“实地”游览世界各地的景点，这种体验方式打破了时空限制，让文旅体验更加丰富多样。
虚拟现实技术可以提供身临其境的游览体验。通过模拟真实的景点环境和景观，虚拟现实技术可以让游客仿佛置身于现场，感受到景点的真实氛围和气息。这种沉浸式的体验方式可以让游客更加深入地了解景点背后的故事和文化内涵，提升旅游的趣味性和教育性。
虚拟现实技术还可以为游客提供个性化的游览体验。游客可以根据自己的兴趣和需求，选择不同的虚拟现实场景和游览路线，实现个性化的旅游体验。这种个性化的体验方式可以满足不同游客的需求，提高旅游的满意度和舒适度。
文化创意产品：为文旅产业增值 数字艺术品是一种具有艺术性和独特性的虚拟商品，可以为文旅企业带来可观的收入。数字艺术品可以结合景点、文化元素等设计出具有创意和独特性的作品，吸引游客的购买欲望。数字艺术品的销售可以成为文旅企业新的收入来源，同时也可以为游客提供独特的纪念品。
虚拟角色也是一种具有潜力的文化创意产品。通过结合景点和文化元素设计出具有特色的虚拟角色，可以为游客提供更加沉浸式的旅游体验。虚拟角色可以作为旅游纪念品销售给游客，同时也可以用于景点的宣传和推广，提高文旅企业的知名度和影响力。
此外，AIGC技术还可以应用于文化创意产品的设计和制作过程中。通过利用人工智能技术，可以对景点、文化元素等进行分析和挖掘，为设计人员提供更多的创意灵感。同时，利用计算机图形学等技术，可以制作出更加逼真、生动的虚拟艺术品和虚拟角色，提高产品的质量和吸引力。
智能内容生成：提升文旅企业运营效率 AIGC技术可以帮助文旅企业自动生成宣传资料。通过利用人工智能技术，可以对景点、文化元素等进行分析和挖掘，生成具有吸引力和独特性的宣传资料。这种自动生成的方式可以大大降低人力成本，提高文旅企业的运营效率。
AIGC技术还可以帮助文旅企业自动生成攻略和游记。通过利用自然语言处理技术，可以对游客的旅游行为和偏好进行分析，生成具有针对性和实用性的攻略和游记。这种自动生成的方式可以为游客提供更加个性化的旅游体验，同时也可以为文旅企业提供更加精准的市场推广和营销策略。
此外，高质量的内容是吸引更多游客的关键。通过AIGC技术生成的宣传资料、攻略、游记等内容，可以更加生动、形象地展示景点和文化元素，提高游客的兴趣和参与度。
个性化营销：精准触达潜在客户 通过AIGC技术，文旅企业可以收集游客的行为数据，包括浏览记录、购买记录、搜索记录等。这些数据可以用于分析游客的偏好、兴趣和需求，从而为游客提供更加个性化的产品推荐。例如，根据游客的浏览记录和购买记录，可以推荐相关的旅游线路、景点、酒店等产品，提高游客的满意度和忠诚度。
AIGC技术还可以帮助文旅企业进行精准营销。通过对游客行为数据的分析，可以了解游客的需求和偏好，从而制定更加精准的营销策略。例如，针对不同年龄段、性别、地域的游客，可以制定不同的营销策略，提高营销效果和转化率。
此外，AIGC技术还可以帮助文旅企业进行智能客服和客户关系管理。通过分析游客的咨询记录和反馈意见，可以及时了解游客的需求和问题，提供更加优质的服务。同时，利用人工智能技术，可以自动回复游客的咨询和投诉，提高服务效率和质量。
总结 AIGC在文旅行业的应用，不仅为游客带来了沉浸式的体验，同时也为文旅企业创造了新的商业模式和增长点。随着AIGC技术的不断发展，我们可以期待未来文旅行业将迎来更多的创新和变革。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/921356c96563c5f68f3cdfb0324c19c5/" rel="bookmark">
			如何在Linux上安装Stable Diffusion WebUI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stable Diffusion WebUI是一个基于AUTOMATIC1111的stable-diffusion-webui仓库的项目，允许用户通过web界面轻松地生成AI驱动的图像。本文将指导您在Linux系统上完成Stable Diffusion WebUI的安装过程。
准备工作 在安装Stable Diffusion WebUI之前，请确保您的Linux系统满足以下要求：
操作系统：基于Debian的Linux发行版，如Ubuntu或Debian。Python版本：Python 3.6或更高版本。足够的磁盘空间：至少1GB的空间用于安装和运行。内存要求：至少2GB可用内存。 安装步骤 1. 安装必要的软件和库 打开终端，并安装必要的依赖：
sudo apt update sudo apt install wget git python3 python3-venv libgl1 libglib2.0-0 2. 克隆Stable Diffusion WebUI仓库 使用 Git 克隆 AUTOMATIC1111 的 stable-diffusion-webui 仓库：
git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git cd stable-diffusion-webui 3. 设置Python虚拟环境 创建并激活一个 Python 虚拟环境：
python3 -m venv venv source venv/bin/activate 4. 安装Python依赖 在虚拟环境中安装所需的Python依赖：
pip install -r requirements.txt 5. 运行Web UI 一旦所有依赖项安装完毕，您可以启动 Web UI：
python launch.py 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/921356c96563c5f68f3cdfb0324c19c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6a60d3baa69ce240cd4c4171bdc6109/" rel="bookmark">
			java 读取word内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接到一个任务，要读取doc文件的内容。解析里面的内容，进行一个处理和返回。
读取doc: 看了
很多文章，基本都是：
import org.apache.poi.hwpf.HWPFDocument; import org.apache.poi.hwpf.extractor.WordExtractor; import java.io.File; import java.io.FileInputStream; import java.io.IOException; public class WordImportUtils { public static String readWordFile(String path) { File file = new File(path); FileInputStream fileInputStream = null; try { fileInputStream = new FileInputStream((file.getAbsolutePath())); HWPFDocument document = new HWPFDocument(fileInputStream); WordExtractor extractor = new WordExtractor(document); return extractor.getText();//此处还有很多别的方法可以使用 } catch (IOException e) { e.printStackTrace(); } finally { if(fileInputStream != null){ try { fileInputStream.close(); }catch (Exception e){ e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6a60d3baa69ce240cd4c4171bdc6109/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d500dd2cc898a1923f2256cd31e40f3/" rel="bookmark">
			c&#43;&#43; 字符串去除指定的字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C++中，想从一个字符串中移除特定的字符，可以使用 std::string 的成员函数操作字符串，或利用算法库中的 std::remove 或 std::remove_if 函数，欢迎大家补充说明！！！ 选择哪一种取决于你的具体应用场景和性能要求。通常，使用 std::remove 或 std::remove_if 与 erase 结合会是一种高效且简洁的方式。 使用 std::string 的 erase 和 find 方法 循环查找并擦除特定字符，逐个字符地搜索并移除字符
#include &lt;iostream&gt; #include &lt;string&gt; int main() { std::string str = "Hello, World!"; char char_to_remove = 'l'; size_t pos; while ((pos = str.find(char_to_remove)) != std::string::npos) { str.erase(pos, 1); } std::cout &lt;&lt; str &lt;&lt; std::endl; // 输出: Heo, Word! return 0; } 使用 std::remove 算法和 erase std::remove 函数可以用来移除指定的字符，并返回一个新的“逻辑”结束位置。实际的字符串内容没有改变，但所有需要保留的字符已经被移动到字符串的开始位置，其后是需要移除的字符。之后，你可以使用 erase 来擦除尾部不需要的字符。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d500dd2cc898a1923f2256cd31e40f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d938a478e2b107d5a2f7cd91253137c/" rel="bookmark">
			python 爬虫 m3u8 视频文件 加密解密 整合mp4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、完整代码二、视频分析1. 认识m3u8文件2. 获取密钥，构建解密器3. 下载ts文件4. 合并ts文件为mp4 三、总结 一、完整代码 完整代码如下：
import requests from multiprocessing import Pool import re import os from tqdm import tqdm from Crypto.Cipher import AES # 创建临时文件夹 dirs = 'ts_list_need_to_merge/' os.makedirs(dirs, exist_ok=True) headers = { 'Accept': '*/*', 'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6', 'Connection': 'keep-alive', 'Origin': 'http://www.kpd510.me', 'Referer': 'http://www.kpd510.me/', 'Sec-Fetch-Dest': 'empty', 'Sec-Fetch-Mode': 'cors', 'Sec-Fetch-Site': 'cross-site', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69', 'sec-ch-ua': '"Chromium";v="116", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d938a478e2b107d5a2f7cd91253137c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb03b8e3a5da959f217bcf5704d52d47/" rel="bookmark">
			Python 发微信：实现自动化沟通的利器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言：
在当今信息爆炸的时代，微信已经成为人们日常生活中不可或缺的沟通工具。然而，手动发送微信消息往往耗时耗力，尤其是在需要频繁发送消息的场景下。为了提高工作效率和便利性，我们可以利用 Python 编程语言来实现自动发送微信消息的功能。本文将介绍如何使用 Python 发微信，包括相关库的介绍、代码实现以及实际应用案例。
一、相关库的介绍
在 Python 中，有许多第三方库可以帮助我们实现微信的自动化操作。其中最常用的是 itchat 和 wechaty 两个库。itchat 是一个基于微信网页版协议的 Python 库，可以实现与微信的交互，包括登录、获取联系人、发送消息等功能。而 wechaty 则是一个基于微信机器人框架的开源项目，可以实现更加灵活和强大的微信自动化功能。
二、itchat 库的使用
安装 itchat 库
首先，我们需要使用 pip 命令来安装 itchat 库。在命令行中输入以下命令即可完成安装： pip install itchat 登录微信
在使用 itchat 库之前，我们需要先登录微信账号。可以通过以下代码实现登录： import itchat itchat.auto_login(hotReload=True) 获取联系人
通过 itchat 库，我们可以获取微信中的联系人列表。以下是获取联系人的代码示例： import itchat itchat.auto_login(hotReload=True) contacts = itchat.get_contacts() print(contacts) 发送消息
使用 itchat 库，我们可以发送文本消息、图片消息、语音消息等多种类型的消息。以下是发送文本消息的代码示例： import itchat itchat.auto_login(hotReload=True) itchat.send('Hello, World!', toUserName='filehelper') 三、wechaty 库的使用
安装 wechaty 库
wechaty 是一个基于 Node.js 的开源项目，因此我们需要先安装 Node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb03b8e3a5da959f217bcf5704d52d47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dca0f869bcce528d7a7770cbf323cd58/" rel="bookmark">
			Javascript 下载方法分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、引言
JavaScript是一种广泛使用的编程语言，用于增强网页交互性和动态功能。然而，有时我们需要将JavaScript代码下载并部署到本地服务器或离线环境中。本文将分享一些常用的JavaScript下载方法。
二、直接下载JavaScript文件
手动下载：在浏览器中打开包含JavaScript文件的网页，右键单击网页空白处，选择“查看网页源代码”或“检查元素”，找到JavaScript文件的URL，然后手动下载该文件到本地。使用开发者工具：打开网页，按下F12键打开开发者工具，切换到“Network”选项卡，刷新页面以加载所有资源，然后找到JavaScript文件，右键单击并选择“Save”或“Download”。 三、使用Git克隆项目
GitHub是一个流行的代码托管平台，许多开源项目都在这里托管和协作。它提供了版本控制、代码审查、分支管理等工具，使得开发者可以轻松地协作和分享他们的代码。
对于JavaScript项目来说，GitHub提供了许多便利的功能，例如可以轻松地创建和推送代码到公共或私有的存储库，与他人协作和分享代码，使用版本控制系统进行代码管理和跟踪更改等。此外，许多JavaScript工具和库都在GitHub上托管、发布和更新。
许多JavaScript项目都在GitHub上托管和托管，你可以使用Git来克隆这些项目到本地。以下是步骤：
打开终端或命令提示符。输入“git clone [项目URL]”，其中[项目URL]是你要克隆的JavaScript项目的GitHub URL。按Enter键执行命令，Git将下载整个项目到本地。在项目的根目录下，你可以找到所有的JavaScript文件。 四、使用npm包管理器
Node Package Manager（NPM）是一个用于Node.js的包管理和分发工具，它已经成为非官方的发布Node模块（包）的标准。NPM允许开发者轻松地下载、安装和管理Node.js的第三方模块，这些模块可以用于扩展和构建应用程序的功能。
NPM提供了命令行界面（CLI），通过这个CLI可以执行各种包管理任务，例如安装、更新、卸载等。它还提供了丰富的功能，如版本控制、依赖管理、私有包管理和发布等。
NPM的安装通常与Node.js一起进行，因此大多数Node.js应用程序都使用NPM来管理其依赖项。NPM使得开发者可以轻松地共享和分发他们自己的Node.js包，并从全球范围内获取数百万个开源包。
如果你需要下载并使用npm（Node Package Manager）包管理器管理的JavaScript库或框架，你可以按照以下步骤进行：
打开终端或命令提示符。输入“npm install [包名]”，其中[包名]是你想要安装的JavaScript库或框架的名称。按Enter键执行命令，npm将自动下载并安装该库或框架及其依赖项。安装完成后，你可以在项目的node_modules文件夹中找到该库或框架的JavaScript文件。 在下载JavaScript文件时，需要注意以下几个问题：
版权问题：确保你有权下载和使用该JavaScript文件。如果该文件是开源的，你应该仔细阅读许可协议，并遵守其使用条款。如果该文件是受版权保护的，你可能需要获得版权所有者的许可才能下载和使用。安全性问题：在下载JavaScript文件之前，确保它来自可信的来源。恶意代码可能会被插入到JavaScript文件中，如果你不小心下载并使用它，可能会导致安全漏洞或数据泄露。版本问题：如果你需要特定版本的JavaScript文件，确保你下载的版本与你的项目或应用程序的要求相匹配。不同版本的JavaScript文件可能会有不同的API和功能，因此在使用之前应该仔细检查版本信息。完整性问题：确保下载的JavaScript文件是完整的，没有被截断或损坏。如果文件不完整，可能会导致代码无法正常运行或出现错误。依赖问题：如果JavaScript文件依赖于其他库或框架，确保你也下载并安装了这些依赖项。否则，可能会导致代码无法正常运行或出现错误。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/52/">«</a>
	<span class="pagination__item pagination__item--current">53/71</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/54/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>