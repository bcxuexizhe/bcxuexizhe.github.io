<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c83e92d6846f3ddce0282f06302cae3b/" rel="bookmark">
			docker安装并使用国内源（Linux、Windows、macOS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows系统安装Docker并配置国内源 安装 Docker Desktop：
访问Docker官网（https://www.docker.com/products/docker-desktop）下载适用于Windows的Docker Desktop安装包并安装。 配置国内镜像源：
在Docker Desktop中点击顶部菜单栏的“ whale icon -&gt; Preferences -&gt; Daemon”（Windows旧版本可能是“Settings”）。在"Daemon"标签页下的“Advanced”区域中找到“Registry mirrors”选项。输入国内镜像源，例如阿里云：{ "registry-mirrors": ["https://docker.mirrors.ustc.edu.cn"] } 保存设置并重启Docker Desktop服务使配置生效。 MacOS系统安装Docker并配置国内源 安装 Docker Desktop：
访问Docker官网下载适用于Mac的Docker Desktop安装包并安装。 配置国内镜像源：
在Docker Desktop中点击顶部菜单栏的“ whale icon -&gt; Preferences…”。在"Daemon"标签页下的“Advanced”区域中找到“Registry mirrors”选项。输入国内镜像源，如阿里云：{ "registry-mirrors": ["https://docker.mirrors.ustc.edu.cn"] } 保存设置并重启Docker服务使配置生效。 Linux系统（以Ubuntu为例）安装Docker并配置国内源 安装Docker CE：
# 更新apt软件包索引 sudo apt-get update # 安装所需的包以允许apt通过HTTPS使用存储库 sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common # 添加Docker的GPG key curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - # 添加Docker的APT仓库 sudo add-apt-repository "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c83e92d6846f3ddce0282f06302cae3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5ca4b78054940973fc5725c1f1fde86/" rel="bookmark">
			利用学生认证部署 copilot-gpt4-service 白嫖 gpt-4.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		过年期间在公众号 HelloGitHub 上看到了一个项目 copilot-gpt4-service，可以将 GitHub Copilot 转成 ChatGPT 的服务。
这么一个转换的好处是， GitHub 可以通过学生认证免费试用，转换成 ChatGPT 后就可以免费使用 GPT-4 了。
下面记录一下本地部署自己的 copilot-gpt4-service 服务过程。
申请 Copilot 申请 GitHub 的学生认证，参考这篇指南，在这里使用学校邮箱和学生卡即可认证，我的学生卡在学校放着，用照片也可以。不过要注意的是不要开启任何代理。
认证通过后右下角的提交记录会显示通过：
然后进入 GitHub，点击头像进入 settings，选择 Code, planning, and automation 下的 Copilot，设置后即可使用了。
安装并启动 copilot-gpt4-service 服务端 服务端我使用 docker 进行部署，这是最简单的，只需要按 Readme 中指示的，在终端中输入
docker run -d \ --name copilot-gpt4-service \ --restart always \ -p 8080:8080 \ aaamoon/copilot-gpt4-service:latest 即可。
获得 Copilot Token 运行提供的脚本即可，注意这个可能需要科学上网否则可能会出现网络问题。
顺利的话运行脚本后会在终端得到一个网址，点击后进行验证即可得到 Token，存起来。
下载 ChatGPT-Next-Web 客户端 我用 Readme 中提供的命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5ca4b78054940973fc5725c1f1fde86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e3f6983354c9a4f7895b337f42e40a7/" rel="bookmark">
			优雅使用前端枚举Enum，符合国标的那种！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01、什么是枚举Enum？ 枚举Enum是在多种语言中都有的一种数据类型，用于表示一组特定相关的常量数据集合，如性别（男、女）、数据状态（可用、禁用）、垂直对齐（顶端、居中、底部）、星期等。特点是数据值固定，不会变，存储和显示的内容不同。
然而在JavaScript中并没有枚举Enum类型，TypeScript算是有（本文中暂没用用TS的枚举）。在前端项目中还是会用到经常用到这类型数据的，本文就对枚举做一个通用封装，并进行尽量全局的总结。
先来看看最常用的性别：
❓你的系统中性别用的什么存储的呢？
在UI上显示为Text文字描述，如表格、单选项。
传输或存储时，一般会用一个有意义的字符编码，或者数字，两种方式都有也都可以。
如果数据量少，可以用字符编码，如M（男）、Male（男），可读性更好，就是占用空间比数字类型多。
推荐采用短整形数字表示，存储空间更小，采用一个字节的最小整形即可（值为0到255）。
针对性别的枚举值，其实是有国家标准的，国标中就是用的整数值标识。
📢参考国标：GB/T 2261.1-2003 个人基本信息分类与代码 第1部分:人的性别代码（可在线预览），早在2003年就颁布了。
SO，我们用枚举的主要目的就是处理UI、存储（编码传输）的值转换问题，兼顾显示的友好、存储的性能。在一些面向对象语言如JAVA、C#中使用体验更佳，支持枚举值的代码提示输入，避免硬编码，还可以用位运算存储多个值（算是稍微高级一点的玩法了）。
02、前端应用场景 1、表格数据绑定时，需要显示用户易懂的（中文）描述信息，用不同颜色样式区分，而后端返回的JSON数据中可能是编码值M/F，或1/2。
2、直接显示枚举值的（中文）描述信息+样式，如elementUI中的&lt;el-tag&gt;组件。
3、作为表单组件的绑定数据源，如下拉选择、单选组、复选组表单组件。
03、封装EnumFactory 3.1、EnumFactory 设计一个枚举工厂 EnumFactory（enumFactory.js），统一创建枚举所需的属性和方法：
参数enumObj为要传入的枚举基础定义：标准模式（key:{text:'',type:''}）示例：{ 1: { text: '男', type: 'priary' }, 2: { text: '女', type: 'warning' }}简写模式（key:text），会被自动转换为标准模式，示例：{ left: '左对齐', center: '居中', right: '右对齐' }**value **数据结构约定：value值部分约定text为文本描述，type为样式类别（elementUI中的状态type：success/info/warning/danger），其他可随意。
参数keyParseFunc 为key的转换函数，默认key为字符串，keyParseFunc 默认值为null（不转换），如果key为整数，则需要传入转换函数（传入JS内置parseInt即可）。
返回值继承自参数enumObj，扩展了属性 keys、values、formatter。**keys**，枚举key数组，如 [0,1,2]、["male","female","other"]。**values**，值数组，包含了key，结构[{key:'',text:'',type:''}]。**formatter**：elementUI中表格绑定枚举数据文本的formatter函数。
/** * 枚举创建工厂（构造函数），扩展枚举对象：keys、values(含key值的[{key,text,type}])、formatter。 * @param {*} enumObj 枚举值，支持标准模式{key:{text,type},}，简单模式{key:text,}（会自动转换为标准模式） * @param {*} keyParseFunc key的转换函数，默认null，如果key为整数则传 parseInt */ export default function EnumFactory(enumObj, keyParseFunc = null) { //复制（继承）enumObj Object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e3f6983354c9a4f7895b337f42e40a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8c02504bd2ed86ec363ea9a17a5fd9a/" rel="bookmark">
			全网最全！Stata16（数据分析）安装包、安装教程，以及Stata16中data frames(数据框)的使用方法~...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Table of contents
1. 软件下载
2. 软件介绍
3. 安装教程
4. 使用教程
1
软件下载/Software Download
Stata 16软件下载：
[软件名称]：Stata 16
[软件大小]：338MB
[软件语言]：中文
[系统环境]：Win7/Win8/Win10/Win11
如下免费获取
长按下方二维码关注
回复关键词：stata
回复关键词：stata
回复关键词：stata
温馨提示：分享的所有软件，均由互联网中的资源整理所得，仅限学习交流，切勿商用！
2
软件介绍/Introduce
Stata是一款集数据分析、数据管理以及绘制专业图表的整合性统计软件，它提供许许多多功能，包含线性混合模型、均衡重复反复及多项式普罗比模式，用Stata绘制的统计图形相当精美。从15.1版本开始，官方为Stata提供了简体中文语言包，大家使用起来就更加方便了。
3
安装教程/Download
1.把资源从网盘下载到电脑上面并解压，然后右键压缩包选择解压到当前文件夹；
2.双击打开刚刚解压出来的Stata 16文件夹；
3.鼠标右键以管理员身份运行SetupStata16程序；
4.点击Next；
5.先点击I accept...，然后点击Next；
6.用户名随便输入，然后点击Next；
7.选择第一项StataMP，然后点击Next；
8.点击Change修改安装路径；
9.软件默认安装在C盘，直接将C改成D即可，然后点击OK；
10.点击Next；
11.点击Next；
12.点击Install；
13.软件正在安装中，请稍等...
14.点击Finish；
15.在菜单中将刚刚安装的StataMP-16软件拖拽至桌面创建快捷方式；
16.双击打开StataMP-16软件；
17.上面两个随便填，后面的依次填写:
serial number：501609213901
code：1q5j w567 7882 xsLa 0m8v iu6j oruv wwnf 5xfr
Authorization：tojd
18.点击完成；
19.点击确定；
20.关闭这个界面；
21.点击确定；
22.返回安装包，将RunAsDate压缩包解压到当前文件夹；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8c02504bd2ed86ec363ea9a17a5fd9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0744e1bf478e80d968805c444745d7a1/" rel="bookmark">
			Python制作【大麦网】自动抢票程序_python大麦抢票
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 大麦网，是中国综合类现场娱乐票务营销平台，业务覆盖演唱会、 话剧、音乐剧、体育赛事等领域。
但是因为票数有限，还有黄牛们不能丢了饭碗，所以导致了，很多人都抢不到票
那么，今天带大家用Python来制作一个自动抢票的脚本小程序
知识点： 面向对象编程selenium 操作浏览器pickle 保存和读取Cookie实现免登陆time 做延时操作os 创建文件，判断文件是否存在 开发环境： 版 本：anaconda5.2.0（python3.6.5）编辑器：pycharm 先导入本次所需的模块 import os import time import pickle from time import sleep from selenium import webdriver 第一步，实现免登录 确定目标，设置全局变量 # 大麦网主页 damai_url = "https://www.damai.cn/" # 登录页 login_url = "https://passport.damai.cn/login?ru=https%3A%2F%2Fwww.damai.cn%2F" # 抢票目标页 target_url = 'https://detail.damai.cn/item.htm?spm=a2oeg.search_category.0.0.77f24d15RWgT4o&amp;id=654534889506&amp;clicktitle=%E5%A4%A7%E4%BC%97%E7 初始化加载 class Concert: def __init__(self): self.status = 0 # 状态,表示如今进行到何种程度 self.login_method = 1 # {0:模拟登录,1:Cookie登录}自行选择登录方式 self.driver = webdriver.Chrome(executable_path='chromedriver.exe') # 默认Chrome浏览器 登录调用设置cookie def set_cookie(self): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0744e1bf478e80d968805c444745d7a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db0cc42580ac3cf21e888c9adedc17c8/" rel="bookmark">
			五大跨平台桌面应用开发框架：Electron、Tauri、Flutter等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hello，我是贝格前端工场，本次介绍跨平台开发的框架，欢迎大家评论、点赞。
一、什么是跨平台桌面应用开发框架 跨平台桌面应用开发框架是一种工具或框架，它允许开发者使用一种统一的代码库或语言来创建能够在多个操作系统上运行的桌面应用程序。传统上，开发者需要为每个操作系统编写不同的代码，使用不同的开发工具和语言。而跨平台桌面应用开发框架通过抽象底层操作系统的差异，提供一套统一的API和工具，使开发者能够在一个代码库中编写应用程序，并将其部署到多个平台上。
跨平台桌面应用开发框架可以分为两种类型：
基于Web技术的跨平台桌面应用开发框架：这种框架使用Web前端技术，如HTML、CSS和JavaScript来构建桌面应用程序。它通常使用WebView或浏览器引擎来渲染应用程序界面，并通过桥接技术与底层操作系统进行交互。这种框架的优势是开发者可以使用熟悉的Web技术进行开发，并且应用程序可以在多个操作系统上运行。一些常见的基于Web技术的跨平台桌面应用开发框架包括Electron、NW.js等。 基于原生技术的跨平台桌面应用开发框架：这种框架使用底层操作系统的原生技术和工具来构建桌面应用程序。它通常提供了一套统一的API和工具，使开发者能够使用一种语言或代码库来编写应用程序，并将其部署到多个操作系统上。这种框架的优势是应用程序可以直接运行在操作系统的图形引擎上，具有更好的性能和用户体验。一些常见的基于原生技术的跨平台桌面应用开发框架包括Qt、wxWidgets、JavaFX等。 跨平台桌面应用开发框架可以提高开发效率，减少重复开发工作，并且可以让应用程序更快地部署到多个操作系统上。选择适合的跨平台桌面应用开发框架应该考虑项目需求、目标操作系统、开发经验和性能要求等因素。
二、五大跨平台桌面开发框架 Electron Electron是一个开源的跨平台桌面应用程序开发框架，由GitHub开发和维护。它基于Chromium和Node.js，使用Web技术（HTML、CSS和JavaScript）来构建应用程序。Electron可以将Web应用程序打包成桌面应用程序，并支持在Windows、Mac和Linux等多个平台上运行。它提供了丰富的API和工具，可以访问底层操作系统的功能，如文件系统、网络、窗口管理等。Electron适用于具有复杂交互和跨平台需求的桌面应用程序。
wxPython wxPython是一个基于Python的跨平台图形用户界面（GUI）开发框架，它使用了wxWidgets库。wxPython提供了丰富的GUI控件和功能，可以创建具有各种样式和布局的应用程序。它支持Windows、Mac和Linux等多个平台，并提供了与底层操作系统交互的API。wxPython使用Python语言编写，易于学习和使用，适合快速开发桌面应用程序。
FinClip FinClip是一个基于Flutter的跨平台应用容器，它可以将Flutter应用嵌入到其他应用中运行。FinClip提供了一套丰富的API和功能，可以与宿主应用进行交互，如获取设备信息、调用原生功能等。它支持Android和iOS平台，并提供了一套可视化的开发工具，方便开发者进行应用的调试和测试。FinClip适用于需要将Flutter应用嵌入到其他应用中的场景，如金融、电商等行业。
Tauri Tauri是一个用于构建跨平台原生应用程序的开源工具和框架。它使用Web技术（HTML、CSS和JavaScript）来构建应用程序界面，同时使用Rust语言来编写底层框架和与操作系统交互的代码。Tauri可以将应用程序打包成可执行文件，并支持在Windows、Mac和Linux等多个平台上运行。它提供了丰富的API和工具，可以访问底层操作系统的功能，如文件系统、网络、窗口管理等。Tauri适用于需要使用Web技术构建跨平台原生应用程序的场景。
Flutter Flutter是一个由Google开发的跨平台移动应用程序开发框架。它使用Dart语言编写，通过一套统一的UI框架可以在Android和iOS等多个平台上构建高性能、美观的应用程序。Flutter提供了丰富的UI控件和功能，支持响应式编程模式，具有热重载和快速开发的特点。Flutter的应用程序使用Skia引擎进行渲染，并直接运行在操作系统的图形引擎上，不依赖于WebView或浏览器。Flutter适用于需要快速构建跨平台移动应用程序的场景。
综上所述，Electron适用于构建跨平台桌面应用程序，wxPython适用于基于Python的跨平台GUI开发，FinClip适用于将Flutter应用嵌入到其他应用中，Tauri适用于构建跨平台原生应用程序，Flutter适用于构建跨平台移动应用程序。选择适合的框架应该根据项目需求、开发经验和目标平台来决定。
三、五大框架的共同点和不同点 共同点：
跨平台性：Electron、wxPython、FinClip、Tauri和Flutter都是跨平台框架，可以在多个操作系统上运行。开发效率：这些框架都提供了一套统一的API和工具，使开发者能够使用一种语言或代码库来编写应用程序，并将其部署到多个平台上，从而提高开发效率。社区支持：这些框架都有活跃的开发者社区，提供了丰富的文档、示例和插件，可以帮助开发者解决问题和加速开发过程。 不同点：
技术栈： Electron是基于Web技术的跨平台桌面应用开发框架，使用HTML、CSS和JavaScript来构建应用程序；wxPython是基于Python的跨平台桌面应用开发框架，使用Python语言和wxWidgets库来构建应用程序；FinClip是一个基于微信小程序的跨平台桌面应用开发框架，使用小程序开发技术来构建应用程序；Tauri是一个基于Web技术的跨平台桌面应用开发框架，使用Rust语言和WebView来构建应用程序；Flutter是一个基于Dart语言的跨平台桌面应用开发框架，使用Flutter框架和Dart语言来构建应用程序。 应用类型：这些框架适用于不同类型的应用程序开发。Electron和Tauri适用于构建桌面应用程序，wxPython适用于构建Python语言的桌面应用程序，FinClip适用于构建微信小程序的桌面应用程序，Flutter适用于构建跨平台的移动应用和桌面应用程序。性能和体验：由于使用不同的底层技术和工具，这些框架在性能和用户体验方面可能有所不同。一些框架如Electron和Flutter具有较好的性能和用户体验，而其他框架可能受限于底层技术的性能和限制。 选择适合的框架应该根据项目需求、目标平台、开发经验和性能要求等因素进行评估和比较。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd5561be674dd4e938a1f8b12f971dad/" rel="bookmark">
			mysql.service is not a native service, redirecting to systemd-sysv-install
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字面意思：mysql.service不是本机服务，正在重定向到systemd sysv安装
在CentOS上使用Systemd管理MySQL服务的具体步骤如下：
1、创建MySQL服务单元文件：
首先，你需要创建一个Systemd服务单元文件，以便Systemd可以管理MySQL服务。可以使用任何文本编辑器创建此文件，例如/etc/systemd/system/mysql.service
sudo vi /etc/systemd/system/mysql.service 2、编辑服务单元文件：
在编辑器中，添加以下内容到mysql.service文件中：
[Unit] Description=MySQL Database Server After=network.target [Service] Type=simple # /usr为mysql安装目录 ExecStart=/usr/bin/mysqld_safe --defaults-file=/etc/my.cnf --pid-file=/var/run/mysqld/mysqld.pid ExecReload=/bin/kill -HUP $MAINPID KillSignal=SIGTERM TimeoutSec=300 [Install] WantedBy=multi-user.target 请注意，你可能需要根据你的实际MySQL安装路径和配置文件位置进行调整。
ExecStart=/usr/bin/mysqld_safe --defaults-file=/etc/my.cnf --pid-file=/var/run/mysqld/mysqld.pid 3、重新加载Systemd管理的服务列表：
执行以下命令以重新加载Systemd管理的服务列表，使新创建的MySQL服务单元文件生效：
sudo systemctl daemon-reload 4、启动MySQL服务：
现在，你可以启动MySQL服务了：
sudo systemctl start mysql 5、设置MySQL开机自启动：
如果你希望MySQL在系统启动时自动启动，可以使用以下命令将其设置为开机自启动：
sudo systemctl enable mysql 5.1 设置MySQL启动并设置开机自启
sudo systemctl enable mysql --now 6、检查MySQL服务状态：
可以使用以下命令来检查MySQL服务的状态：
sudo systemctl status mysql 以上步骤完成后，你的MySQL服务应该已成功地由Systemd管理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fb2e7180839b6ab87d06f946fa73e46/" rel="bookmark">
			AIGC实战——生成模型简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AIGC实战——生成模型简介 0. 前言1. 生成模型2. 生成模型与判别模型的区别2.1 模型对比2.2 条件生成模型2.3 生成模型的发展2.4 生成模型与人工智能 3. 生成模型示例3.1 简单示例3.2 生成模型框架 4. 表示学习5. 生成模型与概率论6. 生成模型分类小结系列链接 0. 前言 生成式人工智能 (Generative Artificial Intelligence, GAI) 是一种人工智能方法，旨在通过学习训练数据的分布模型来生成新的、原创的数据。人工智能生成内容 (Artificial Intelligence Generated Content, AIGC) 是生成式人工智能的一个具体应用和实现方式，是指利用人工智能技术生成各种形式的内容，如文字、图像、音频和视频等。本节将介绍生成模型基本概念，首先介绍生成模型的基本概念，然后，构建用于衡量生成模型性能的框架，并介绍一些重要的核心概念。然后，介绍当前主流的生成模型技术及其分类。
1. 生成模型 生成模型 (Generative Model) 是机器学习的一个分支，通过训练模型以生成与给定数据集类似的新数据，换句话说模型通过学习训练数据的分布特征，生成与之类似但又不完全相同的新数据。
假设有一个包含猫图片的数据集，如果在该数据集上训练一个生成模型，以捕捉图像中像素之间的复杂关系。然后，我们可以利用该模型进行采样，生成原始数据集中不存在的逼真(猫)图像，如下图所示。
为了构建生成模型，我们需要一个包含许多我们要生成的实例的数据集，这被称为训练数据 (training data)，其中每一个数据点称为一个观测值 (observation)。
每个观测值由许多特征 (features) 组成，对于图像生成问题，特征通常是各个像素的像素值；对于文本生成问题，特征通常是单词或字母组合。我们的目标是构建一个模型，可以生成看起来像是使用与原始数据相同规则创建的新特征集。对于图像生成来说，这是一个非常困难的任务，不仅由于生成的图像需要具有真实世界的特征和细节，包括纹理、颜色、形状等，同时图像生成模型通常需要大量的训练数据来学习图像的特征和分布。
生成模型还必须是概率性的 (probabilistic)，而不是确定性的 (deterministic)，因为我们希望能够采样出具有不同变化的输出，而不是每次得到相同的输出，对于图像数据而言，生成的图像应该具有不同的风格、角度和变化，而不是仅仅复制训练数据中的图像。如果我们的模型仅仅是一个固定的计算，例如在训练数据集中每个像素的平均值，那么它就不是生成模型，生成模型必须包含一个影响模型生成的随机因素。
换句话说，我们假设存在某种未知的概率分布，其可以解释图像在训练数据集中存在(或不存在)的合理性。生成模型的目标是构建一个尽可能精确地模仿这个分布的模型，然后从中进行采样，生成看起来像是原始训练集中可能包含的新的、独特的样本数据。
2. 生成模型与判别模型的区别 2.1 模型对比 为了了解生成模型及其重要性，首先需要介绍判别模型。假设我们有一个绘画的数据集，其中包含莫奈与一些其他艺术家的画作。通过使用足够的数据，可以训练一个判别模型，以预测给定的画作是否由莫奈绘制。判别模型能够学到画作中的颜色、形状和纹理特征，以便判断画作是否由莫奈所绘制，对于具有莫奈画作特征的绘画，模型会相应地增加其预测权重。下图展示了判别模型的构建过程：
在构建判别模型时，训练数据中的每个观测值都有一个标签 (label)。对于二分类问题，比如上述画作鉴别器，将莫奈的画作标记为 1，非莫奈的画作标记为 0。然后，判别模型学习如何区分这两组画作，并预测新数据样本属于标签 1 的概率，即样本是由莫奈绘制的概率。
而生成模型不需要数据集带有标签，因为生成模型关注的是生成新图像，而非试图预测给定图像的标签。接下来，使用公式正式定义生成模型和判别模型。
判别模型估计 p ( y ∣ x ) p(y|x) p(y∣x)，即在给定输入 x x x 的情况下，输出 y y y 的概率。其中 y y y 是标签， x x x 是观测值生成模型估计 p ( x ) p(x) p(x)，即生成给定输入 x x x 的观测值的概率，而不考虑标签判别模型关注如何根据观测值来预测标签，而生成模型关注如何根据概率分布来生成观测值在判别模型中，可以使用逻辑回归、支持向量机等算法来构建模型。而在生成模型中，常使用生成对抗网络 (Generative Adversarial Networks, GAN) 或扩散模型等算法来生成新的观测值 总结而言，判别模型和生成模型是两种不同的机器学习方法。判别模型通过观测值预测标签，而生成模型通过学习数据分布来生成新的观测值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fb2e7180839b6ab87d06f946fa73e46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5360bc78eaa342ef655f048d036a0c04/" rel="bookmark">
			[ai笔记13] 大模型架构对比盘点：Encoder-Only、Decoder-Only、Encoder-Decoder
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到文思源想的ai空间，这是技术老兵重学ai以及成长思考的第13篇分享！
最近看完《这就是chatgpt》对于大语言模型的三种架构演进图印象颇深，今日就专题盘点一下三种大模型架构理论，同时做一个简单对比。
1 Encoder-Only架构 Encoder-Only 架构，也被称为单向架构，仅包含编码器部分。它主要适用于不需要生成序列的任务，只需要对输入进行编码和处理的单向任务场景，如文本分类、情感分析等。这种架构的代表是 BERT 相关的模型，例如 BERT、RoBERT 和 ALBERT 等。
Encoder-Only 架构的核心思想是利用神经网络对输入文本进行编码，提取其特征和语义信息，并将编码结果传递给后续的处理模块。这种架构的优点是能够更好地理解输入文本的语义和上下文信息，从而提高文本分类和情感分析等任务的准确性。缺点是它无法直接生成文本输出，因此在需要生成文本的任务中不太适用。
Encoder-Only架构的大模型有谷歌的BERT、智谱AI发布的第四代基座大语言模型GLM4等。其中，BERT是基于Encoder-Only架构的预训练语言模型。GLM4是智谱AI发布的第四代基座大语言模型，该模型在IFEval评测集上，在Prompt提示词跟随（中文）方面，GLM-4达到了GPT-4 88%的水平。
2 Decoder-Only架构 Decoder-Only 架构，也被称为生成式架构，仅包含解码器部分。它通常用于序列生成任务，如文本生成、机器翻译等。这种架构的模型适用于需要生成序列的任务，可以从输入的编码中生成相应的序列。同时，Decoder-Only 架构还有一个重要特点是可以进行无监督预训练。在预训练阶段，模型通过大量的无标注数据学习语言的统计模式和语义信息。
Decoder-Only 架构的优点是擅长创造性的写作，比如写小说或自动生成文章。它更多关注于从已有的信息（开头）扩展出新的内容。其缺点是需要大量的训练数据来提高生成文本的质量和多样性。
Decoder-Only架构的大模型的代表有GPT系列、LLaMA、OPT、BLOOM等。这类模型采用预测下一个词进行训练，常见下游任务有文本生成、问答等，因此被称为ALM（Autoregressive Language Model）。
国内采用Decoder-Only架构研发的大模型有妙想金融大模型、XVERSE-13B大模型等。其中，妙想金融大模型是东方财富旗下自主研发的金融行业大语言模型，目前已经覆盖了7B、13B、34B、66B及104B参数。而XVERSE-13B大模型是由前腾讯副总裁、腾讯AI lab创始人姚星创立的明星独角兽元象研发的，该模型支持40多种语言、8192上下文长度，在多项中英文测评中，性能超过了同尺寸（130亿参数）的LIama2、Baichuan等。
3 Encoder-Decoder架构 Encoder-Decoder 架构，也被称为序列到序列架构，同时包含编码器和解码器部分。它通常用于序列到序列（Seq2Seq）任务，如机器翻译、对话生成等。这种架构的代表是以 Google 训练出来的 T5 为代表的相关大模型。
Encoder-Decoder 架构的核心思想是利用编码器对输入序列进行编码，提取其特征和语义信息，并将编码结果传递给解码器。然后，解码器根据编码结果生成相应的输出序列。这种架构的优点是能够更好地处理输入序列和输出序列之间的关系，从而提高机器翻译和对话生成等任务的准确性。缺点是模型复杂度较高，训练时间和计算资源消耗较大。
Encoder-Decoder架构的大模型有很多，例如Google的T5模型、华为的盘古NLP大模型等。
其中，华为的盘古NLP大模型首次使用Encoder-Decoder架构，兼顾NLP大模型的理解能力和生成能力，保证了模型在不同系统中的嵌入灵活性。在下游应用中，仅需少量样本和可学习参数即可完成千亿规模大模型的快速微调和下游适配，这一模型在智能舆论以及智能营销方面都有不错的表现。
4 架构分析 以上三种架构各有优劣，其应用场景和前景也不尽相同。Encoder-Only 架构适用于文本分类和情感分析等任务，其前景主要取决于其在这些任务中的性能和准确性。Decoder-Only 架构适用于文本生成和机器翻译等任务，其前景主要取决于其生成文本的质量和多样性。Encoder-Decoder 架构适用于机器翻译和对话生成等任务，其前景主要取决于其在这些任务中的性能和准确性。
总的来说，这三种架构都有其独特的优势和应用场景，未来的发展前景也非常广阔。随着技术的不断进步和应用场景的不断拓展，这三种架构将会得到更广泛的应用和发展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4a34f71dfa88da72b143395d6136434/" rel="bookmark">
			Vue3 exceljs库实现前端导入导出Excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 需求场景 最近在开发项目时需要批量导入和导出Excel数据，在实现这个需求时，我们既可以在前端完成数据解析和文件生成工作，也可以通过前端发起导入以及导出请求后，后端实现解析文件流解析文件内容以及生成文件并提供下载链接的功能。
相较于后端处理Excel数据而言，使用前端导入导出可以提供更高的实时性，用户可以直接在浏览器中触发导出操作，无需等待后端处理。且可以在前端完成数据生成以及数据校验处理工作，大大减轻后端服务器的压力，大幅增强用户体验。
具体的技术方案选型主要看业务场景，如果对于小型数据集、实时性需求较高的导入导出操作，优先考虑前端实现。而对于大型数据集、需要业务逻辑处理、以及安全性要求高的场景，则后端处理更为合适。
技术方案 xlsx与xlsx-style组合方案：xlsx 是目前前端最常用的Excel解决方案，又叫做SheetJS，但社区版不支持修改Excel的样式，需要购买Pro版才可以，如果需要修改导出的Excel文件样式，需要结合xlsx-style库一起使用。但遗憾的是xlsx库已经两年多不更新，而xlsx-style上一个版本更是8年前发布，目前已经不再推荐使用该方案。
exceljs与file-saver方案：exceljs是一款免费开源支持导入导出Excel 操作工具，并且可以实现样式的修改以及 Excel 的高级功能，是非常值得推荐的一个处理 Excel 的库，file-saver可以实现保存文件到本地。本文以exceljs与file-saver操作xlsx格式文件为例介绍如何具体上手使用。
exceljs介绍 ExcelJS是一个用于在Node.js和浏览器中创建、读取和修改Excel文件的强大JavaScript库。它提供了丰富的功能和灵活的API，使你能够在你的应用程序中处理和操作Excel文件。
下面是一些ExcelJS库的关键特性和功能：
创建和修改Excel文件：ExcelJS允许你创建新的Excel工作簿，并在其中添加工作表、行和单元格。你可以设置单元格的值、样式、数据类型以及其他属性。读取和解析Excel文件：ExcelJS支持读取和解析现有的Excel文件。你可以将Excel文件加载到工作簿中，然后访问工作表、行和单元格的数据。导出和保存Excel文件：ExcelJS可以将工作簿保存为Excel文件，支持多种格式，如XLSX、XLS和CSV。你可以将工作簿保存到本地文件系统或将其发送到客户端以供下载。处理复杂的Excel功能：ExcelJS支持处理复杂的Excel功能，如公式、图表、数据验证、条件格式和保护工作表等。你可以根据需要设置和操作这些功能。支持自定义样式和格式：ExcelJS允许你自定义单元格、行、列和工作表的样式和格式。你可以设置字体、颜色、填充、边框、对齐方式以及数字和日期格式等。 参考文档 npm仓库地址：https://www.npmjs.com/package/exceljs
官方中文文档地址：https://github.com/exceljs/exceljs/blob/HEAD/README_zh.md
快速上手 安装依赖 exceljs用于Excel数据处理，file-sever用于保存到本地文件。
npm i exceljs npm i file-saver 导出Excel 让我们先从简单的数据导出开始，快速体验如何使用exceljs导出Excel文件，需要注意的是在浏览器环境中运行 JavaScript，浏览器的安全策略通常不允许直接访问读写本地文件系统。在这种情况下，需要通过其他方式将文件转换为buffer数据，在导出Excel时使用FileSaver.js库将缓冲区数据保存到文件中。
&lt;template&gt; &lt;el-button type="primary" @click="exportExcel"&gt;导出excel&lt;/el-button&gt; &lt;/template&gt; &lt;script setup&gt; import ExcelJS from "exceljs"; import FileSaver from "file-saver"; // 导出excel文件 const exportExcel = () =&gt; { // 创建工作簿 const workbook = new ExcelJS.Workbook(); // 添加工作表，名为sheet1 const sheet1 = workbook.addWorksheet("sheet1"); // 导出数据列表 const data = [ {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4a34f71dfa88da72b143395d6136434/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39a61dcf06343b1ee7a78426a567235b/" rel="bookmark">
			如何降低aigc查重率【解决方案】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学术研究与创作领域，AIGC查重率一直是令人头疼的问题。高查重率不仅影响作品的原创性，还可能涉及学术不端的问题。那么，如何有效降低AIGC查重率呢？本文将从七个方面为您揭秘。
一、深度理解原创性的重要性
原创性是作品的灵魂，也是降低查重率的关键。我们要深刻理解原创性的内涵，坚决抵制抄袭、剽窃等不端行为，从源头上避免高查重率的出现。
二、合理引用并标明出处
在学术文章中，合理引用他人的研究成果是必不可少的。但我们必须注意引用的方式，确保引用的内容准确无误，并在文中明确标注出处，这样既能体现学术的严谨性，又能避免不必要的查重纠纷。
三、巧妙运用修辞手法
通过比喻、拟人、夸张、排比等修辞手法，可以使文章更加生动有趣，同时也能在一定程度上降低查重率。这些修辞手法能够增加文章的独特性和可读性，使内容更加丰富多彩。
四、注重文章结构和逻辑
一个清晰合理的文章结构和逻辑，能够使读者更好地理解文章的主旨和意图。同时，这也是降低查重率的有效手段。通过合理安排段落和论点，使文章更具逻辑性，能够有效减少与其他作品的相似性。
五、合理运用同义词和近义词
在写作过程中，适当使用同义词和近义词，能够丰富文章的词汇表达，减少重复词汇的出现，从而降低查重率。这也是提升文章语言质量的重要手段。
六、使用专业工具进行查重检测
在完成文章初稿后，使用专业的AIGC查重工具进行检测，能够帮助我们发现潜在的重复内容，从而有针对性地进行修改和调整。这是降低查重率的必要步骤。
七、不断学习和提升写作能力
降低AIGC查重率不是一蹴而就的事情，它需要我们不断学习和提升写作能力。通过不断积累知识和经验，我们能够更加熟练地运用各种写作技巧和方法，从而更加有效地降低查重率。
综上所述，降低AIGC查重率需要我们从多个方面入手，包括理解原创性的重要性、合理引用并标明出处、巧妙运用修辞手法、注重文章结构和逻辑、合理运用同义词和近义词、使用专业工具进行查重检测以及不断学习和提升写作能力等。只有这样，我们才能够写出真正具有原创性和价值的作品。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b442b041fd9ff624f8f5e25218fdca92/" rel="bookmark">
			解决RabbitMQ管理页面异常/不正确的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正确的页面：有Channels、Exchanges等 异常/不正确的页面： 问题原因 我的RabbitMQ是用docker安装的，应该不会是安装的环境有问题。
而且MQ的服务确实是启动了，后端能正常使用，并且管理界面的登录页面也是能正常登录的，就是登录后的界面内容不对，所以怀疑一下是不是还要配置用户才行，然后跟着网上的教程一通乱搞也没解决。
各种排查之后都找不出问题，只能F12看一下请求和响应报文，看能不能通过报文看出什么端倪。然后登录之后发现控制台有一个报错信息。到这基本就能猜出问题所在了，但还是需要验证一下猜想。
1、换一个浏览器访问管理界面，能正常访问。
2、用原来的浏览器打开一个正常的已经部署好的RabbitMQ管理页面，能正常访问。然后在前端源代码中搜索报错的方法toLowerCase()，搜索不到。
3、在网上搜索浏览器对该方法的支持，发现谷歌浏览器的老版本确实是不支持这个方法。
结论：自己安装的RabbitMQ版本是最新的，前端的源代码有所变化。使用的谷歌浏览器版本又很低，不支持toLowerCase()方法，导致前端代码报错不能正常渲染。
解决方法 换一个浏览器或者升级当前浏览器，更麻烦一点就是安装低版本的RabbitMQ，但是还需要知道RabbitMQ在哪一个版本开始使用该方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/278187d0bf302f2f0794f480a4b8a372/" rel="bookmark">
			前端js webkitSpeechRecognition 实现语音转文字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近领导安排个新任务，就是大屏，通过语音控制大屏跳转页面。通过几天的查找，实现了这个功能。居然是前端js原生就可以实现，如此简单。我的思路就是给大屏提个称呼，通过这个称呼唤醒记录，然后记录下这句话，通过后台识别这句话中的关键字，实现页面跳转。
下面就是代码，写的不好，不喜勿喷，请多指教！
直接上代码：
&lt;template&gt;
&lt;div class="about"&gt;
&lt;h1&gt;This is an about page&lt;/h1&gt;
&lt;div&gt;
&lt;el-button&gt;默认按钮&lt;/el-button&gt;
&lt;el-button type="primary"&gt;主要按钮&lt;/el-button&gt;
&lt;el-button type="success"&gt;成功按钮&lt;/el-button&gt;
&lt;el-button type="info"&gt;信息按钮&lt;/el-button&gt;
&lt;el-button type="warning"&gt;警告按钮&lt;/el-button&gt;
&lt;/div
&lt;div&gt;
&lt;p&gt;识别结果: {{ recognitionResult }}&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
data() {
return {
recognitionResult: '',
}
},
mounted() {
if ('webkitSpeechRecognition' in window) {
// 创建一个webkitSpeechRecognition实例
const recognition = new window.webkitSpeechRecognition();
recognition.lang = 'zh-CN';
recognition.start();
recognition.continuous = true;
// 给大屏起个称呼，可以是一个，也可以多个
const keywords = ['小王', '小黑'];
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/278187d0bf302f2f0794f480a4b8a372/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96e8fc18788129c3f79bd72d2c9ccf58/" rel="bookmark">
			用nginx正向代理https网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 缘起2. 部署nginx3. 测试3.1 http测试3.2 https测试4 给centos设置代理访问外网 1. 缘起 最近碰到了一个麻烦事情，就是公司的centos测试服务器放在内网环境，而且不能直接上外网，导致无法通过yum安装软件，非常捉急。
幸好，内网还是有可以可以访问外网的机器，所以就想到应该可以利用nginx搭建一个代理服务器，然后centos通过这个nginx来访问外网。当然，如果只是代理http还是很简单的，而要代理https还是需要稍费周折，因为nginx本身不能部署被代理的网站的证书，不能部署成https终结点来，因此与被代理客户端之间不能用ssl协议通讯，因此需要通过http协议中的CONNECT请求打通和外网的连接，然后客户端到nginx走明文，nginx到外网走https协议。这里需要用到ngx_http_proxy_connect_module模块来实现CONNECT的代理功能。
2. 部署nginx 步骤1： 从nginx官网下载nginx源码包。步骤2： 因为nginx原生是不支持CONNECT请求的，需要安装一个扩展插件，即ngx_http_proxy_connect_module，从github下载ngx_http_proxy_connect_module，另外还要下载一个nginx内核补丁。步骤3： 解压nginx源码包，进入nginx源码目录，创建modules目录（mkdir modules)。步骤4： 将ngx_http_proxy_connect_module源码目录放到modules目录中。步骤5： 将nginx内核补丁放到nginx源码目录，姑且名字叫p1.patch步骤6： 在nginx源码目录，执行以下命令给nginx内核打上补丁： patch -p 1 &lt; p1.patch 步骤7：编译nginx，这里假设nginx安装到/opt/nginx目录中（在编译前确认pcre、zlib、openssl的库是否已经正常安装），编译命令如下： ./configure --prefix=/opt/nginx --with-http_ssl_module -add-module=./modules/ngx_http_proxy_connect_module make &amp; make install 步骤8：配置nginx
配置文件如下： #user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96e8fc18788129c3f79bd72d2c9ccf58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df57a3a5bdebcbb27c798b3304122e6a/" rel="bookmark">
			【UE5】【插件】【WebUI】内置浏览器插件WebUI简易使用笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前的项目中为了提高效率，避免使用UE功能不完善的UMG系统，使用了WebUI插件，在UI中内嵌浏览器来展示网页。用Vue框架配合插件制作网页还是比UMG要快很多的，毕竟UE的UI制作插件比较少。
一. UE蓝图 首先在UMG中创建一个新UI，拉一个新的面板，然后在里面加一个WebInterface组件。
之后就可以使用蓝图节点来设定默认网页了，一般常用的是LoadFile或者LoadHTML来调用项目中Content文件夹或Content/HTML文件夹中的项目和文件。如果前端项目并没有在UE项目中，就可以使用LoadURL来通过网络访问网页。
点击变量WebInterface，可以看到有如下几种事件：
这里最基本的用法就是OnInterfaceEvent，添加之后是这样的：
这个name就是前端网页调用我们UE函数时传递过来的函数名，Data就是一起传递来的JsonValue数据。Callback比较复杂，暂且按下不表。
我们可以添加一个Switch节点，区分一下具体的函数名，然后为每个函数名创建一个匹配的事件。下面的PrintEvent是接收并打印传递来的JsonValue。
这里有个知识点，就是JsonValue想转换成string，不可以用下面截图中的这个节点，因为下面的是转换单个值为string的，如果你是复杂结构，必须使用我在上图中使用的Stringigy，否则报错。
再写一个键盘事件，来测试调用前端函数：
这边暂且结束，接下来写一个前端测试网页。
二. 前端代码 在前端页面里的代码块中，需要添加一段脚本的源代码：
这份源代码主要是用于定义全局ue4()帮助函数，该函数注册具有可选超时期限的临时回调函数。如果不添加这份代码，无法进行UE与Web之间的通信。
接下来是前端具体函数的代码，我这里使用的是Vue框架，以下是一个简单的页面，包含一个按钮以及一个输入框：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;红色按钮示例&lt;/title&gt; &lt;style&gt; .button { background-color: red; color: white; padding: 10px 20px; border-radius: 5px; border: none; cursor: pointer; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;button id="test" class="button" @click="handleClick"&gt;点击我&lt;/button&gt; &lt;br&gt; &lt;label for="inputField"&gt;输入文本：&lt;/label&gt; &lt;input type="text" id="inputField" v-model="inputField"&gt; &lt;br&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 这里是相关的逻辑, 主要的函数都在这里写了：
&lt;script&gt; new Vue({ el: '#app', data: { inputField: '', }, methods: { handleClick() { //调用ue5中当前WebInterface的OnInterfaceEvent事件，附带Name为test ue5("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df57a3a5bdebcbb27c798b3304122e6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/534b0ed31181d5f33b9ead019a319e4f/" rel="bookmark">
			番外篇 Vue和Django 前后端交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习了一段时间的django和vue，对于前后端开发有了一个初步的了解，这里记录一下编写的流程和思路，主要是为了后面如果遗忘从哪里开始操作做一个起步引导作用
一、Django后端 参考下前面django的文档https://moziang.blog.csdn.net/article/details/130720709
1、安装django环境 //配置清华镜像源 pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple pip config set global.trusted-host pypi.tuna.tsinghua.edu.cn //安装django pip install django==4.2.1 //创建项目paas django-admin startproject PAAS //登录PAAS目录 cd PAAS //创建应用 python manage.py startapp app_demo1 python manage.py startapp app_demo2 目录结构
2、项目添加应用模块 vi test1\PAAS\PAAS\settings.py
INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'app_demo1', #添加 #'app_demo2' ] ALLOWED_HOSTS = ['*'] #允许所有请求访问 在理想中我们需要维护一个大的平台项目，也就是paas平台，而app_demo1 和app_demo2 就是我们这个平台下负责某个功能的模块，这种模块可能有多个，为了区分他们不同模块对外提供的功能，我们首先要做的就是设置路由(urls)，app_demo2我这里演示不用，先注释了
3、添加主路由转发到模块路由 PAAS/PAAS/urls.py
from django.contrib import admin from django.urls import path, include urlpatterns = [ path('admin/', admin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/534b0ed31181d5f33b9ead019a319e4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d55e95f20ae0b7fa17df93e14fada099/" rel="bookmark">
			【监控】Spring Boot&#43;Prometheus&#43;Grafana实现可视化监控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.概述
2.spring actuator
3.Prometheus
3.1.介绍
3.2.使用
1.client端的配置
2.server端的配置
4.grafana
5.留个尾巴
1.概述 本文是博主JAVA监控技术系列的第四篇，前面已经聊过了JMX、Spring actuator等技术，本文我们就将依托于Spring actuator+监控组件prometheus+数据可视化组件grafana来实现对Spring Boot应用的可视化监控。
关于Spring actuator的相关内容，可移步：
Spring Boot 监控_springboot 监控-CSDN博客
【监控】spring actuator源码速读-CSDN博客
2.spring actuator Spring actuator是spring体系中自带的监控组件，用来监测应用本身以及所处环境等内容。前文已经详细介绍过了，自处就不再重复和展开了。
依赖：
&lt;dependency&gt;
&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;version&gt;&lt;/version&gt;
&lt;/dependency&gt;
配置：
management:
endpoints:
web:
exposure:
include: "*"
看一下效果：
以上这些指标都是actuator自带的，要适配Prometheus的数据采集格式的话需要引入promethus的适配层。ok，接下来我们讲一下Prometheus。
3.Prometheus 3.1.介绍 先看看整个prometheus的架构：
看起来很复杂对吧？其实并不复杂，最核心的就是Prometheus Server，其内置一个时序数据库，用来存采集上来的监控指标。然后就是Prometheus提供了很多client端，放在应用侧采集监控指标然后pull metrics（推送采集到的监控指标）个Prometheus Server。然后就是支持对接多种图形化界面如grafana来进行图形化的展示。最后就是支持各种方式的告警，如发送email等。
3.2.使用 1.client端的配置 即应用内的配置。
依赖：
&lt;!--prometheus --&gt; &lt;dependency&gt; &lt;groupId&gt;io.micrometer&lt;/groupId&gt; &lt;artifactId&gt;micrometer-registry-prometheus&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 配置：
management: endpoints: web: exposure: include: "*" endpoint: prometheus: enabled: true health: show-details: always 可以看到promethus的监控指标已经出来了：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d55e95f20ae0b7fa17df93e14fada099/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/761811fb0726d0a6aaa1e0267ad1e553/" rel="bookmark">
			Hive On Spark 报错：Failed to get a spark session: org.apache.hadoop.hive.ql.metadata.HiveException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 脚本中含有：数据装载进hive表的sql语句，在执行脚本的时候发生报错
报错信息： 原因： hive on Spark 任务，想要运行时需要申请资源的。若在一定时间内无法申请到资源，会超时退出。
解决办法： （1）最简洁、最有效的办法： 直接重启一下 hadoop集群（hdfs、yarn.....）
重新执行一下脚本，看这次是否能成功运行
（2）若方案一还是失败，则认为是yarn资源没分配够 修改hadoop的yarn-site.xml文件
添加以下内容： &lt;!--是否启动一个线程检查每个任务正使用的物理内存量，如果任务超出分配值，则直接将其杀掉，默认是true --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.pmem-check-enabled&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt; &lt;!--是否启动一个线程检查每个任务正使用的虚拟内存量，如果任务超出分配值，则直接将其杀掉，默认是true --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.vmem-check-enabled&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt; &lt;!-- yarn容器允许分配的最大最小内存 --&gt; &lt;property&gt; &lt;name&gt;yarn.scheduler.minimum-allocation-mb&lt;/name&gt; &lt;value&gt;1024&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.scheduler.maximum-allocation-mb&lt;/name&gt; &lt;value&gt;4096&lt;/value&gt; &lt;/property&gt; &lt;!-- yarn容器允许管理的物理内存大小 --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt; &lt;value&gt;4096&lt;/value&gt; &lt;/property&gt; 然后去HDFS上删除 tmp 文件：
最后再次重启hadoop集群，使得改动生效即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b02f0a9445c2957c002ce986dee7d5cf/" rel="bookmark">
			论文ai率怎么降，其实不难
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		降低论文AI检测率：全面解析与策略探讨
在学术领域中，随着人工智能技术的飞速发展，论文AI检测已成为确保学术诚信的重要手段。然而，过高的AI检测率往往给学者带来了不少困惑，如何合理降低论文AI检测率成为了亟待解决的问题。本文将从七个方面深入探讨降低论文AI检测率的策略。
一、理解AI检测机制
首先，我们需要深入理解AI检测机制的工作原理。大多数AI检测工具基于自然语言处理和机器学习技术，通过比对文献数据库中的文本内容来识别相似度。因此，了解这些工具的工作原理有助于我们规避检测风险。
二、优化语言表达
在写作时，我们应该注重语言表达的多样性和自然性。避免直接复制粘贴其他文献中的内容，而是要通过自己的理解和思考，用不同的词汇和句式来表达相同的意思。这样不仅可以降低AI检测率，还能提升论文的原创性。
三、合理使用引用
引用他人的研究成果是学术写作中不可或缺的一部分。然而，不当的引用方式往往会导致AI检测率上升。因此，我们应该合理使用引号、注释和参考文献，确保引用的规范性和准确性。
四、增加原创性分析
在论文中增加原创性的分析和观点，是降低AI检测率的有效途径。通过提出新的理论观点、分析方法或实证研究，可以展示出自己的独特见解和创新性，从而降低与他人研究的相似度。
论文AI高风险怎么降
五、注意段落结构和逻辑
良好的段落结构和逻辑能够使论文更加易于阅读和理解，同时也能降低AI检测率。我们应该合理安排段落划分，确保每个段落都有明确的主题和论述。此外，使用合适的转折词和连接词，使句子之间的衔接更加流畅。
论文AI高风险怎么降？
六、利用AI检测工具自检
在写作过程中，我们可以利用AI检测工具进行自检，以便及时发现并修改高相似度的部分。通过不断调整和优化论文内容，我们可以逐步降低AI检测率。
七、持续关注学术规范
最后，持续关注学术规范和道德准则对于降低论文AI检测率至关重要。我们应该遵循学术界的写作规范和引用要求，确保论文的合法性和合规性。同时，不断提高自己的学术素养和写作能力，为学术领域的发展做出贡献。
综上所述，降低论文AI检测率需要我们深入理解AI检测机制、优化语言表达、合理使用引用、增加原创性分析、注意段落结构和逻辑、利用AI检测工具自检以及持续关注学术规范。通过综合运用这些策略，我们可以有效地降低论文AI检测率，提升论文的质量和原创性。同时，我们也应该保持对学术诚信的高度重视，共同维护学术领域的健康发展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb33ccdc3918f73183b6318ad1e3836d/" rel="bookmark">
			MySQL中timestamp默认值current_timestamp默认时间和系统时间不一致问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做项目的时候遇到了这个问题，表结构如下 当前的时间
插入之后显示的时间
在写后端接口时并没有对create_time和update_time进行字段插入
因为在设计表结构时候，把这两个时间的属性设置为了timestamp类型并，设置了默认值CURRENT_TIMESTAMP，这样在对数据进行插入或修改时就可以直接默认插入当前时间。
但问题出现了，当我进行前后端联调测试的时候发现并未插入当前系统时间，问题无非就出现在前端，后端，数据库这三个方面，前端和后端均为设计这两个字段的插入操作，然后我就在navicate里面进行插入结果发现时间不一致，然后就想到了时区的问题，会不会是因为我使用navicate连接虚拟机的mysql时并未设置当前时区，然后修改为东八区之后再进行插入，解决了该问题
执行以下sql命令进行修改：
#修改全局为东八区 set global time_zone = '+8:00'; #修改当前会话 set time_zone = '+8:00'; #刷新权限 重新加载授权表并使更改生效的命令 flush privileges; 当然除了使用命令修改之外还可以再配置文件中修改，在虚拟机中找到配置文件位置进行修改保存
[mysqld] default-time_zone = '+8:00' 如果修改未生效则可以重启mysql服务
systemctl stop mysqld.service systemctl start mysqld.service 最最最重要的是，当你按上面的方法修改完前端界面时间还没修改为正确的时间，有以下问题
给前端响应的数据
idea控制台待响应数据
可以看出时间查了8个小时，这是因为JSON配置导致的，因为要返回JSON数据，这里差八个小时，在配置文件中进行下面配置即可：
spring: jackson: date-format: yyyy-MM-dd HH:mm:ss time-zone: GMT+8 当然如果不想在mysql里面进行修改这里可以使用公共字段自动填充在后端代码里面进行插入 实现思路：使用AOP切面、反射、注解进行解决
自定义注解 AutoFill，用于标识需要进行公共字段自动填充的方法 /** * 自定义注解 ， 用于标识某个方法需要进行功能字段自动填充处理 */ //指定注解位置 , 指定注解只能加在方法上面 //在这里，@Target(ElementType.METHOD) 表示被注解修饰的注解只能用于方法上 //具体来说，它告诉编译器和开发者，这个注解只能应用在方法级别的元素上，而不能应用在类、字段或其他元素上。 @Target(ElementType.METHOD) //@Retention(RetentionPolicy.RUNTIME) // 是 Java 中的一个元注解，用于指定被修饰的注解在运行时仍然可用。@Retention 注解有三个枚举值： //RetentionPolicy.RUNTIME： 注解被保留到运行时，因此可以通过反射机制在运行时获取注解信息。 // 这允许在程序运行时动态地读取和处理注解。 @Retention(RetentionPolicy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb33ccdc3918f73183b6318ad1e3836d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/47/">«</a>
	<span class="pagination__item pagination__item--current">48/71</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/49/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>