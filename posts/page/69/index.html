<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5a003ea63c5842bd70e8ad12eae31a2/" rel="bookmark">
			2023 年十大目标检测模型！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023 年十大目标检测模型！
使用深度学习革新对象检测的综合指南。
对象检测示例
“目标检测是计算机视觉中最令人兴奋和最具挑战性的问题之一，而深度学习已成为解决它的强大工具。” 对象检测是计算机视觉中的一项基本任务，涉及识别和定位图像中的对象。深度学习彻底改变了对象检测，可以更准确、更高效地检测图像和视频中的对象。到 2023 年，有几种深度学习模型在目标检测方面取得了重大进展。以下是 2023 年用于对象检测的十大深度学习模型：
1.YOLOv7
YOLOv7或 You Only Look Once version-7，是用于对象检测的最先进的深度学习模型。YOLOv7 基于原始的 YOLO 架构，但使用了更高效的主干网络和一组新的检测头。YOLOv7 可以高精度地实时检测物体，并且可以在大型数据集上进行训练。该模型也非常高效，可以在低端设备上运行。
优点：
非常快速和高效的物体检测大型数据集的高精度在低端设备上运行 缺点：
可以与小物体检测斗争需要大型数据集才能获得最佳性能 2. EfficientDet
EfficientDet是一种用于对象检测的深度学习模型，它使用高效的主干网络和一组新的检测头。EfficientDet 旨在高效准确地实时检测物体，准确度高。该模型在多个基准数据集上取得了最先进的结果，并且可以在大型数据集上进行训练。
优点：
在多个基准数据集上的最先进性能高效准确的物体检测可以在大型数据集上进行训练 缺点：
需要大量的计算资源在较小的数据集上进行训练可能具有挑战性 3. RetinaNet
RetinaNet是一种用于对象检测的深度学习模型，它使用特征金字塔网络和新的焦点损失函数。RetinaNet 旨在解决对象检测中前景和背景示例之间的不平衡问题，从而提高准确性。该模型效率高，可以在低端设备上运行，使其成为实时对象检测的热门选择。
优点：
提高物体检测的准确性高效，可以在低端设备上运行易于训练和使用 缺点：
可以与小物体检测斗争需要大量数据以获得最佳性能 4. Faster R-CNN
Faster R-CNN是一种用于对象检测的深度学习模型，它使用区域建议网络生成候选对象位置。然后该模型使用第二个网络对建议的区域进行分类并优化它们的位置。Faster R-CNN 以其高精度而著称，通常用于图像和视频中的对象检测。
优点：
高精度物体检测对图像和视频中的物体检测有效易于训练和使用 缺点：
计算量可能很大实时检测物体时可能会很慢 5. Mask R-CNN
Mask R-CNN是一种用于对象检测的深度学习模型，它扩展了 Faster R-CNN 以预测对象掩码。该模型使用第三个网络为每个检测到的对象生成像素级掩码。Mask R-CNN 以其在对象检测方面的高精度而著称，也可用于实例分割。
优点：
物体检测和实例分割的高精度可以为每个检测到的对象生成像素级掩码易于训练和使用 缺点：
计算量可能很大实时检测物体时可能会很慢 6. CenterNet
CenterNet是一种用于对象检测的深度学习模型，它使用热图来预测每个对象的中心。然后该模型使用第二个网络来预测对象的大小和方向。CenterNet 以其在目标检测方面的高精度和高效性而著称，并在多个基准数据集上取得了最先进的结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5a003ea63c5842bd70e8ad12eae31a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8023c661df18ef505ae88c2899ad6605/" rel="bookmark">
			【线激光扫描三维成像】原理介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【线激光扫描三维成像】 本文以 基于一维移动平台的线激光扫描三维成像项目为例，用通俗的语言让读者快速理解线激光扫描三维成像的原理。 文章目录 线激光扫描三维成像概念线激光扫描三维成像优点（相较于二维视觉）线激光扫描三维成像应用（简单列举）线激光扫描三维成像装置硬件选型装置搭建 线激光扫描三维成像软件实现算法列举标定原理二维图像处理原理三维点云处理原理 🕛 人的才能像挂钟一样，如果停止了摆动，就要落后了~🕛 线激光扫描三维成像概念 线激光扫描：利用线激光器扫描待测物体，相机采集待测物体表面的形变激光线（二维图片）三维成像：计算机处理形变激光线的图片，通过一些算法计算得到待测物体表面三维点云数据 综上所述，线激光扫描三维成像，就是在待测物体周围设置视觉传感器（相机+激光器），激光器投影到待测物体表面产生形变线激光，相机采集形变线激光图片，然后通过一定的算法计算得到待测物体表面的三维点云数据。 线激光扫描三维成像优点（相较于二维视觉） 以工业流水线上对外形不规则且具有随机位姿的工件抓取为例：
二维视觉缺少深度信息，而三维视觉弥补了这个缺陷。 线激光扫描三维成像应用（简单列举） 线激光扫描三维成像装置 硬件选型 对于装置的硬件选型，其实没有一个固定的选型搭配，要根据实际应用场景去挑选合适的型号。下面列举必要的配件“
PC：主要是影响速度，在算法方面无法对速度进行提升之后，只有对硬件进行提升了。相机：一般选择工业相机，主要影响精度，工业相机的优点就是长时间工作稳定性好。线激光器：投影的激光线条越细越好，因为三维成像需要提取形变线激光的中心线。一维移动部件：传送带等。因为相机和激光器是固定不动的，需要移动装置载着待测物体移动，完成扫描。 装置搭建 线激光扫描三维成像装置可以如下图这样搭建。（1）工业相机（2）线激光器（3）工业镜头（4）铝型材（5）传送带（6）光电传感器（7）机械臂 线激光扫描三维成像软件实现 算法列举 要实现物体的三维成像，主要就是利用计算机处理相机采集的待测物体表面的形变激光线，说白了，就是一个对二维图像的处理过程。
可以简单的列举如下：
标定过程：相机标定，光平面标定、扫描方向标定。如果采用多相机，还会涉及多相机联合标定。二维图像处理：激光中心线提取。当然还会涉及一些常用的图像处理算法：去噪、二值化等等。三维点云处理：点云拼接、融合。当然还会涉及一些常用的点云处理算法：去噪、采样等等。其他算法：比如传送带运动控制，相机采集控制（多相机同步采集）等等。 标定原理 标定，其实就是得到一个转换关系，通过这个转换关系可以实现二维像点到三维物点的转换。相机标定：得到像点到物点转换关系，这里的得到的物点其实是假三维，因为其高度信息还是未知的。光平面标定：得到光平面方程，可以得到其高度信息。扫描方向标定：得到相邻两条形变线激光之间的间距，用于点云的排列。多相机联合标定：得到多个视角坐标系的转换关系，可以将多视角数据统一到同一个坐标系。 二维图像处理原理 投影的激光线，在物体表面的成像其实是有一定宽度的，我们需要提取到他的中心线坐标。
常见的光条中心线提取算法有：边缘法、中心法、细化法、极值法、灰度重心法、模板法、曲线拟合法等等。
三维点云处理原理 三维点云处理，主要就是点云融合，这里可能涉及到点云的去噪、下采样、孔洞填充等处理过程。
🕛 乐观是一首激昂优美的进行曲，时刻鼓舞着你向事业的大路勇猛前进！🕛 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ced1ed964212243ed70960af1a89ccaa/" rel="bookmark">
			FastJson使用详解这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FastJson文章目录 第一章 FastJson使用详解这一篇就够了
第二章 FastJsonHttpMessageConverter 类的作用与使用详解
第三章 Jackson 使用详解
文章目录 FastJson文章目录前言一、FastJson是什么？二、使用步骤1.引入库2.序列化和反序列化Java对象3 解析JSON字符串4 使用注解控制序列化和反序列化5 配置FastJson 总结 前言 为什么使用fastJson,如何使用fastJson以及通用的配置和使用方式将在本文进行详细介绍。
一、FastJson是什么？ FastJson是一种高性能的Java JSON解析库，它采用类似于Jackson和Gson的JSON序列化和反序列化机制，但是速度更快。FastJson支持Java对象到JSON的序列化和JSON到Java对象的反序列化，同时支持对JSON字符串的高效解析。
二、使用步骤 1.引入库 首先需要将FastJson添加到项目的依赖中。可以在Maven的pom.xml文件中添加以下依赖：
&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.75&lt;/version&gt; &lt;/dependency&gt; 2.序列化和反序列化Java对象 使用FastJson将Java对象序列化为JSON字符串很简单，只需要调用FastJson提供的静态方法JSON.toJSONString()。例如：
代码如下（示例）：
User user = new User(); user.setId(1); user.setName("张三"); user.setAge(18); String jsonStr = JSON.toJSONString(user); System.out.println(jsonStr); 使用FastJson将JSON字符串反序列化为Java对象也很简单，只需要调用FastJson提供的静态方法JSON.parseObject()。例如：
String jsonStr = "{\"id\":1,\"name\":\"张三\",\"age\":18}"; User user = JSON.parseObject(jsonStr, User.class); System.out.println(user); 3 解析JSON字符串 FastJson提供了一个JSON类，可以方便地解析JSON字符串。例如：
String jsonStr = "{\"id\":1,\"name\":\"张三\",\"age\":18}"; JSONObject jsonObject = JSON.parseObject(jsonStr); int id = jsonObject.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ced1ed964212243ed70960af1a89ccaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f39af0affa93aa6f214d290a3220cc4d/" rel="bookmark">
			Java：定义一个学生类（Student），属性包括：学号，姓名，性别，年龄；方法包括：获得学号，获得姓名，获得性别，获得年龄，修改学号，修改姓名，修改性别，修改年龄。定义并创建一个学生数组对象。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义一个学生类（Student），属性包括：学号，姓名，性别，年龄；方法包括：获得学号，获得姓名，获得性别，获得年龄，修改学号，修改姓名，修改性别，修改年龄。定义并创建一个学生数组对象，长度可自定，最后在控制台输出学生信息。
package project04; class Student{ private String name; private String xh; private String xb; private int age; //类的封装 public String getname() { //姓名 return this.name; } public void setname(String name) { this.name=name; } //学号： public String getxh() { return this.xh; } public void setxh(String xh) { this.xh=xh; } //性别： public String getxb() { return this.xb; } public void setxb(String xb) { this.xb=xb; } //年龄 public int getage() { return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f39af0affa93aa6f214d290a3220cc4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75cbd7fa2f58a3634d86720e085e7294/" rel="bookmark">
			Python实现逻辑回归(Logistic Regression)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💥 项目专栏：【Python实现经典机器学习算法】附代码+原理介绍
文章目录 前言一、基于原生Python实现逻辑回归算法二、逻辑回归模型的算法原理三、算法实现3.1 导包3.2 定义随机数种子3.3 定义逻辑回归模型3.3.1 模型训练3.3.1.1 初始化参数3.3.1.2 正向传播3.3.1.3 损失函数3.3.1.4 反向传播 3.3.2 模型预测3.3.3 模型分数3.3.4 Logistic Regression模型 3.4 导入数据3.5 划分训练集、测试集3.6 模型训练3.7 打印结果3.8 可视化决策边界 完整源码 前言 👑 最近粉丝群中很多朋友私信咨询一些决策树、逻辑回归等机器学习相关的编程问题，为了能更清晰的说明，所以建立了本专栏 专门记录基于原生Python实现一些入门必学的机器学习算法，帮助广大零基础用户达到轻松入门，为了更深刻算法的基本原理，本专栏没有采用第三方库来实现（sklearn），而是采用原生Python自己复现相关算法，从而帮助新手理解算法的内部细节。
👑 本专栏适用人群：🚨🚨🚨 机器学习初学者，刚刚接触sklearn的用户群体，专栏将具体讲解如何基于原生Python来实现一些经典机器学习算法，快速让新手小白能够对机器学习算法有更深刻的理解。
👑 本专栏内包含基于原生Python从零实现经典机器学习算法，通过自复现帮助新手小白对算法有更深刻的认识，理论与实践相结合，每一篇文章都附带有 完整的代码+原理讲解。
🚨 我的项目环境：
平台：Windows11语言环境：Python 3.7编译器：Jupyter LabPandas：1.3.5Numpy：1.19.3Scipy：1.7.3Matplotlib：3.1.3 💥 项目专栏：【Python实现经典机器学习算法】附代码+原理介绍
一、基于原生Python实现逻辑回归算法 逻辑回归是一种经典机器学习分类算法，它被广泛应用于二元分类问题中，该算法的目的是预测二元输出变量（比如0和1），逻辑回归算法有很多应用，比如预测股票市场、客户购买行为、疾病诊断等等。它被广泛应用于医学、金融、社交网络、搜索引擎等各个领域。
本篇文章我们采用Python语言实现经典的机器学习算法 Logistic Regression ，作为该专栏的第一篇文章，本篇将💎 详细介绍项目的每个实现部分以及细节处理，帮助新手小白快速建立起机器学习算法训练的框架。
二、逻辑回归模型的算法原理 逻辑回归（Logistic Regression）是一种广泛使用的分类算法，它的主要思想是将输入变量的线性组合映射到0到1之间的概率，用于预测二元输出变量的概率。
以下是逻辑回归模型的算法原理：
假设我们有一个二元分类问题，需要预测一个样本属于两个类别中的哪一个。逻辑回归模型使用一个参数化函数来计算给定输入变量的输出概率。该函数称为 sigmoid 函数，它将输入变量的线性组合映射到0到1之间的值，表示预测样本属于正例的概率。sigmoid 函数的数学形式为： g ( z ) = 1 1 + e − z g(z) = \frac{1}{1 + e^{-z}} g(z)=1+e−z1​其中，z 是输入变量的线性组合，可以表示为： z = b + w 1 x 1 + w 2 x 2 + .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75cbd7fa2f58a3634d86720e085e7294/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/254de62f15bb57cfd3a477ad4efd3429/" rel="bookmark">
			MATLAB R2022b 安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB R2022b 安装教程 MathWorks 于2022年9月发布了 MATLAB 和 Simulink 产品系列的最新版本 Matlab R2022b版本 ，加入两个新产品：
Medical Imaging Toolbox — 可视化、配准、分割和标注二维及三维医学图像Simscape Battery — 设计和仿真电池和储能系统 除了新产品，Matlab R2022b 版本也对现有的产品模块做了若干更新，具体大家可以移步到MathWorks 的官网查看更新详情：
https://ww2.mathworks.cn/products/new_products/latest_features.html
1. 安装之旅 百度网盘分享地址-uzzm
第一步：下载好压缩包后，对压缩包进行装载(Mount)：
第二步：打开装载好的 DVD 驱动器，如下图所示：
第三步：在驱动器中找到 setup，单击鼠标右键以管理员身份运行：
第四步：稍后出现如下图所示的界面，点击窗口右上角的 高级选项下拉框，选择 我有文件安装密钥，之后点击下一步：
第五步：是否接受许可协议的条款，点击 是，之后点击下一步：
第六步：输入文件安装密钥，之后点击下一步：
安装密钥：
05322-36228-06991-12654-51812-34369-14072-44298-22786-36732-05503-35033-50900-29808-05166-12170-05630-02560-02687-62114-45079-42917-06281-13007-19512-18270
第七步：选择 许可证文件，点击 浏览，进入到 activate document 文件夹中，选择 license.lic 文件（大家反映许可失效，建议在安装的时候下载新的许可，评论区内有下载地址），点击下一步：
解压开我分享的 Mathworks Matlab R2022b 压缩包，再解压 activate document 压缩包，license.lic 文件就在里面
第八步：选择目标文件夹，即安装路径，这根据大家的习惯进行选择，注意安装路径必须全是英文，更改之后，点击下一步：
建议只更改盘符 即可，不建议改成其他的，否则后面破解会出现问题
第九步：选择产品，默认是全部勾选的，如果全部安装的话，会占用很大的空间，大家可以根据自己的需求去选择。如果后期要添加产品，添加的时候会麻烦点，如果磁盘空间够用，建议全部安装。选择完毕，点击下一步：
在这一步中，我们可以根据自己的需求去安装产品，具体的哪些是你需要的可以点击这个网址去查看：https://ww2.mathworks.cn/help/，这个是官方推荐的。
第十步：勾选选项，根据自己的习惯进行勾选：
第十一步：确认安装，确认完毕，点击 开始安装：
第十二步：耐心等待安装：
第十三步：产品安装完成，如下图所示，点击 关闭：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/254de62f15bb57cfd3a477ad4efd3429/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/306d5e2d6ee9477257522bcedac78813/" rel="bookmark">
			【Rabbitmq详解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 消息中间件一、何为消息中间件二、消息队列协议 消息队列持久化三、持久化 消息的分发策略-高可用高可靠四、消息分发策略五、消息分发策略的机制对比六、消息队列高可用 Rabbitmq安装七、安装Rabbitmq Rabbitmq Web界面管理授权八、启动web页面访问功能九、授权账号设置密码 Rabbitmq角色分类十、Rabbitmq角色分类 Rabbitmq组件和架构十一、AMQP十二、Rabbitmq的核心组成部分 Rabbitmq工作模式十三、Rabbitmqmq不同模式 消息中间件 一、何为消息中间件 1.概述 1.消息中间件利用可靠些传递机制进行系统和系统之间的通讯.
2.通过提供消息队列传递和消息队列排队机制,它可以在分布式系统架构上扩展进程之间的通讯.
2.消息中间件的应用场景 1.跨系统数据传递
2.数据的并发和异步处理
3.大数据分析与传递
5.分布式事务
例如:
在进行数据迁移和高并发请求的时候,此时有个10W的并发请求下单,这个时候我们就可以采用消息队列缓存中间件,先把订单数据放到消息队列中,让这批数据稳健、可靠的入库和执行。
3.常见的消息中间件 ActiveMQRabbitmqkafkaRocketmq 消息中间件的本质和设计就是一种用来接收数据、数据请求、存储数据、发送数据的过程的技术服务。
MQ消息队列:负责数据的传接收、存储和传递，所以性能要过于普通服务和技术。
二、消息队列协议 1.网络协议三要素 1.语法:语法是用户数据与控制信息的数据与格式以及数据出现的顺序
2.语义:语义是解释控制信息每个部分的意义,它规定了需要发出扫描控制信息以及完成的动作和做出什么样的响应.
3.时序:时序是对事件发生的顺序的详细说明.
①.语法:http规定了请求报文和响应报文的格式
②.语义:客户端主动发起了请求称之为请求
③.时序:一个请求对应一个响应
2.为什么消息中间件不采用http作为传输协议? 1.应为http协议的自身机制(报文头和响应报文)是比较复杂的,其中还包含了cookies和数据加密解密,状态码,响应码等,对于一个消息传递存储分法功能的协议是不需要这么复杂的功能这么多反而会拖垮性能,反之要追求高性能、简介、快速。
2.一般情况下http面对的都是短连接，在实际应用中容易中断，造成数据丢失，这样就不利于消息中间件的业务场景，因为消息中间件是一个长期获取消息的过程，出现问题和故障需要保证数据持久化，目的就是为了能更好的对数据进行存储、转发保证数据的高可用和稳健运行。
3.消息中间件采用的最常见的协议 OpenWireAMQPAMQPMQTTKafkaOpenMessage AMQP:
AMQP:全称(Advanced Message Queuing Protocol)是消息队列协议,由摩根大通集团联合其它公司共同设计,是一个提供消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计.基于该协议的客户端与消息中间件可传递消息,并不受客户端/中间件不同产品.不同的开发语言等条件的限制,Erlang语言开发,Erlang语言是基于C语言设计的语言,因此该协议性能也是十分的强悍.Erlang实现有Rabbitmq等.
AMQP协议支持Rabbitmq、Activemq
特征:
①.分布式事务支持
②.消息的持久化支持
③.高性能和高可靠的消息处理优势.
MQTT协议:
MQTT协议:(Message Queueing Telemetry Transport)消息队列是IBM开放的一个即时通讯协议,物联网架构中的重要组成部分.
特点:
1、轻量
2、结构简单
3、传输快，不支持事务
4.没有持久化设计
应用场景：
1、适用于计算能力有限
2、网络不稳定的场景
支持者：
Rabbitmq、Activemq
OpenMessage协议:
最近几年由阿里、雅虎、滴滴、Stremalio等公司共同参与发布的一款消息中间件、流处理等领域的应用开发标准。
特点：
①、结构简单
②、解析速度快
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/306d5e2d6ee9477257522bcedac78813/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3780c65128db05df2c3ef4aaab964cb2/" rel="bookmark">
			一文速学-XGBoost模型算法原理以及实现&#43;Python项目实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、XGBoost模型概述
1.发展历史
2.算法改进之处
1.损失函数
2.分裂点选择
3.剪枝策略
4.正则化
5.学习率
6.提前停止
二、XGBoost算法原理
1.初始化构造目标函数
2.目标函数变换
变换优势总结
3.将树引入目标函数
4.构建最优树(贪心算法)
三、XGBoost实战-贷款违约预测模型
1.数据背景及描述
字段表
2.数据质量校验
查看重复值：
缺失值统计
异常值分析-MAD异常值识别法：
3.特征类别处理
1.grade
2.subGrade
4.XGBoost模型训练
1.xgboost.get_config()
2.树的最大深度以及最小叶子节点样本权重
3.gamma
4.subsample 和 colsample_bytree
5.正则项
6.学习速率
前言 集成模型Boosting补完计划第三期了，之前我们已经详细描述了AdaBoost算法模型和GBDT原理以及实践。通过这两类算法就可以明白Boosting算法的核心思想以及基本的运行计算框架，余下几种Boosting算法都是在前者的算法之上改良得到，尤其是以GBDT算法为基础改进衍生出的三种Boosting算法：XGBoost、LightGBM、CatBoost。大家应该都对XGBoost算法模型熟悉但是对GBDT模型一无所知，看过之前GBDT的读者应该对GBDT模型有了一个很清楚的认知，对于理解XGBoost算法有一定的基础。
XGBoost在各种数据挖掘、预测和分类任务中取得了极高的准确率和性能。是目前应用最广泛的机器学习算法之一。可以说，XGBoost的快速发展和广泛应用，推动了机器学习算法的进一步发展和优化，为人工智能技术的普及和应用打下了坚实的基础。那么此篇文章我将尽力让大家了解并熟悉XGBoost模型算法框架，保证能够理解通畅以及推演顺利的条件之下，尽量不使用过多的数学公式和专业理论知识。以一篇文章快速了解并实现该算法，以效率最高的方式熟练使用此方法。
博主专注建模四年，参与过大大小小数十来次数学建模，理解各类模型原理以及每种模型的建模流程和各类题目分析方法。此专栏的目的就是为了让零基础快速使用各类数学模型以及代码，每一篇文章都包含实战项目以及可运行代码。博主紧跟各类数模比赛，每场数模竞赛博主都会将最新的思路和代码写进此专栏以及详细思路和完全代码。希望有需求的小伙伴不要错过笔者精心打造的专栏。
以下是整篇文章内容。
一、XGBoost模型概述 1.发展历史 2014年：XGBoost由陈天奇在《XGBoost: A Scalable Tree Boosting System》一文中首次提出。
2015年：XGBoost在Kaggle竞赛中大放异彩，成为数据科学家和机器学习工程师的首选算法之一。
2016年：XGBoost发布了C++和Python两个版本，支持更多的特征工程和模型调优功能，极大地提高了算法的效率和可扩展性。
2017年：XGBoost获得了KDD Cup 2017竞赛中的多个奖项，并且成为Spark MLlib中的重要组件。
2018年：XGBoost在Microsoft Azure ML Studio中被引入，成为Azure Machine Learning的核心组件之一。
2019年：XGBoost发布了GPU版本，可以在GPU上加速模型训练和预测，大大提高了算法的计算速度。
2020年：XGBoost被应用在各种领域，如金融、医疗、自然语言处理和图像识别等，成为机器学习领域的一个重要里程碑。
这里通过简述的发展史可以得到我们可以通过python调用此算法，而且也可以通过调用GPU提高了算法的计算速度。由此可见XGBoost算法的受欢迎程度。
2.算法改进之处 XGBoost是一种基于梯度提升决策树（Gradient Boosting Decision Tree，GBDT）的机器学习算法，旨在优化和加速GBDT的训练过程，并提高模型的准确性和泛化能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3780c65128db05df2c3ef4aaab964cb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddbb8f603307379bb5ba43e51e9be874/" rel="bookmark">
			国内外交通数据集介绍（附参数说明）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国外数据集 NGSIM数据集 NGSIM数据集采集自美国，数据集中包含两条高速公路（US-101，I-80）及两条城市道路（lankershim，peachtree）的数据，每条道路的采集时间为45min。数据集中包含包含车辆ID、时间、速度、加速度、坐标、车道等信息，数据采样间隔为0.1s，速度单位为英尺/秒。数据集因其精度高、频率高、质量高、覆盖广的特点，被广泛用于模型标定、车辆行为决策等研究。数据集中部分参数说明如下：
NGSIM数据集部分参数说明 Vehicle_ID 车辆IDFrame_ID帧时间Global_Time全局时间Local_X相对X坐标Local_Y相对Y坐标Global_X绝对X坐标Global_Y绝对Y坐标v_length车长，单位：英尺v_Width车宽，单位：英尺v_Class车辆类型，1：摩托车；2：小型车；3：大型车v_Vel车辆速度，单位：英尺/秒v_Acc车辆加速度，单位：英尺/二次方秒Lane_ID车辆所在车道IDPreceding前车ID，若没有前车，则该值为0Following后车ID，若没有后车，则该值为0Space_Headway车头间距，单位：英尺Time_Headway车头时距，单位：秒 highD数据集 highD数据集采集自德国科隆附近的六个不同地点，包含小型车和大型车两种类型车辆的数据，数据集踪迹采集时长为11.5小时，采集车辆数为110000辆，其中包含逾5000条完整的变道轨迹，需特别说明的是，highD数据集的坐标原点位于采集路段的左上方。数据集中车道类型包括2+2、3+3、3+3+1三种形式，其中2+2、3+3两种车道类型中车道ID编号见下图：
四车道车道ID编号示意 六车道车道ID编号示意 3+3+1的车道类型与六车道编号规则大体一致，车道8下方还存在车道ID为9的一条车道。
数据集总结包含60个子数据集，每个字数据集包含采集路段的航拍图、采集点数据、车辆轨迹数据。其中采集点数据给出了位置ID、时间、采集时长、车辆踪迹行驶距离、车辆数等信息，车辆轨迹数据中主要包括车辆ID、车辆坐标、速度、加速度等信息，车辆轨迹数据中部分参数说明吴如下：
highD数据集车辆轨迹数据部分参数说明 frame帧时间id车辆IDx车辆X坐标y车辆Y坐标xVelocity车辆X方向速度yVelocity车辆Y方向速度xAcceleration车辆X方向加速度yAcceleration车辆Y方向加速度dhw车头间距thw车头时距ttc碰撞时间precedingId前车ID，若没有前车，则该值为0followingId后车ID，若没有后车，则该值为0laneId车辆所在车道 国内数据集 高速公路车辆汇入、汇出轨迹数据、城市快速路车辆汇入轨迹数据 高速公路汇入数据采集自某市高速公路汇入路口，采集时间为2020年，天气阴天，道路东西走向，左侧两条主干道，匝道位于右侧，路段限速80km/h，采集时长为30分钟，合流轨迹数量62条；高速公路汇出数据采集自某市高速路汇出路口，采集时间为2020年，天气多云，道路南北走向，右侧两条主干道，匝道位于左侧，采集时长为30分钟，分流轨迹数量290条；城市快速路车辆汇入数据采集自某市城市快速路汇入路口，采集时间为2019年，天气多云，道路南北走向，左侧三条主干道，两条汇入匝道位于左侧，采集时长为23.7分钟，含合流轨迹数量175条。
三个数据集中数据构成相同，均包含说明文档、道路及车道信息说明图、轨迹数据、每条轨迹数据的统计信息、采集设备和该时间内车流统计信息。
轨迹数据中部分参数说明如下：
轨迹数据中部分参数说明 trackId交通参与物编号frameId帧时间classId交通参与物类型，1：行人；2：自行车；3：小型车；4：摩托车；6：公交车；7：货车localX交通参与物相对X坐标，单位：米localY交通参与物相对Y坐标，单位：米laneId所在车道IDxVelocityX方向速度，单位：米/秒yVelocityY方向速度，单位：米/秒xAccelerationX方向加速度，单位：米/二次方秒yAccelerationY方向加速度，单位：米/二次方秒 轨迹统计信息中部分参数说明如下：
轨迹统计信息中部分参数说明 trackId交通参与无编号InitialFrame出现帧数TotalFrame总出现帧数Distance行程距离，单位：米minVel最低速度，单位：米/秒maxVel最大速度，单位：米/秒meanVel平均速度，单位：米/秒VehicleClass交通参与物类型（person、bicycle、car、NonVehicle、bus、truck）LaneChangeNum换道次数RampVehicle是否为匝道交通参与物 采集设备和该时间内车流统计信息部分参数说明如下：
采集设备与改时间内车流统计信息部分参数说明 Date采集日期Time采集开始时间DurationTime采集时长，单位：分WeekDay是否为工作日TotalTrajectoryNumber追踪的轨迹数量TotalDistance总行程距离，单位：米TotalDriveTime总行程时间，单位：秒TotalCarNumber小型车数量TotalTruckNumber货车数量TotalPedestrianNumber行人数量TotalBusNumber公交车数量TotalNonVehicleNumber非机动车数量LaneChangeNumber交通参与物变道行为数量RampVehicleNumber交通参与物经过匝道数量 交通之眼数据集 交通之眼数据集由无人机航拍获得，车辆轨迹数据库包括车辆编号、位置坐标、车道编号、车辆长度、车辆宽度、行驶速度、车头时距、车头间距、加减速度等参数，时间精度为0.1秒，位置精度为0.01米，覆盖场景包括城市快速路航拍书局、城市交叉口航拍数据、城市快速路路侧检测数据、城市交叉口路侧检测数据等，包含六个子数据集（CKQ4/DATA SQM1/DATA SQM2/KZM5/KZM6/YTA3），交通状况包括自由流、自由流向拥堵演变、双向交织区。每个子数据集中均包括视频数据和车辆轨迹数据，部分子数据集中包含路段线形数据。车辆轨迹数据集中部分参数说明如下：
交通之眼数据集车辆轨迹部分参数说明 Vehicle ID车辆IDLane ID车辆所在车道Time(s)时间，单位：秒LongtitudePosition(meter)横向坐标，单位：米LatitudePostion(meter)纵向位置，单位：米Speed(m/s)速度，单位：米/秒Acceleration(m/s^2)加速度，单位：米/二次方秒VehicleLength(pixel)车长，单位：像素VehicleWidth(pixel)车宽，单位：像素 车辆轨迹数据以CSV格式存储，截图如下：
数据集中视频数据运行截图如下：
城市地下快速路车辆轨迹数据 数据采集自上海北横通道，使用毫米波雷达和边缘计算单元获取车辆轨迹、交通事件、交通运行状态等信息。北横通道设备安装范围全长435米，单向三车道，设计速度为60公里/小时，路段包括3个车道，车道宽度为3.2米。数据集中包含数据说明、车辆轨迹数据、路段纵断面图、路段平面线形图。车辆轨迹数据中部分参数说明如下：
车辆轨迹数据部分参数说明 GlobalID
车辆编号 ObjectClass
车辆类型，0：大货车；1：小客车 BornTime
车辆进入观测区域时间，单位：毫秒 GoneTime
车辆离开观测区域时间，单位：毫秒 Timestamp
时间戳，单位：毫秒 PositionX
车辆纵向位置，即平行道路方向距离道路起点的长度
PositionY
车辆所在车道编号，-25：上行方向最外侧车道；-15：上行方向中间车道；-5：上行方向最内侧车道 VelocityX
纵向车速，单位：米/秒 VelocityY
横向车速，单位：米/秒 AbnormalState
车辆状态，0：正常；1：蛇形行驶；2：超速；4：低速；8：急加速急减速；16：跟车过近；32：路段冲突。其余数字表示叠状态（如：5表示状态1表示4的叠加）。 成都滴滴数据 数据集中包含2016年11月的成都滴滴平台的车辆轨迹数据和车辆订单数据，字段使用中文字段，因此不再对其中的参数进行赘述，需要特别说明的是，数据类型为string，其中时间戳单位为秒，经纬度使用GCJ-02坐标系。车辆轨迹数据包含：司机ID、订单ID、时间戳、精度、维度，订单数据包含：订单ID、开始计费时间、结束计费时间、上车位置经度、上车位置维度、下车位置经度、下车位置维度。数据以TXT格式保存，以订单数据为例，数据截图见下：
需要注意的是，在对数据进行处理时，一般需要先转化为CSV文件。
济南公交数据 数据集提供了2017年6月27日济南56路公交的轨迹数据，数据采样间隔为30秒，数据集中包含数据类型（3：GPS；4：到离站；55：违规；47：DSRC检到离场；71：GPS到离场；53：开关门）、车载机编号、时间、经度、纬度、海拔、GPS速度、方向角、GPS里程等数据。数据集截图见下：
上海公交GPS数据 数据集中记录了上海公交71路的GPS行车数据，数据中包含车牌号、公交线路代码、时间、车辆上下行、经度、纬度、速度、行车方向数据，数据集中各参数说明见下表：
上海公交GPS数据参数说明 FSTR_BUSID
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddbb8f603307379bb5ba43e51e9be874/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b85ba4e78900ec85a678b713ec272506/" rel="bookmark">
			计算机操作系统实验：进程调度实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言
二、实验目的
三、实验要求
四、实验原理
五、实验过程
六、代码详解
总结
前言 计算机操作系统是管理计算机硬件和软件资源的核心软件，它负责为用户提供一个友好、高效、安全的使用环境。进程调度是操作系统的一个重要功能，它决定了进程在处理器上的执行顺序和时间，从而影响了系统的性能和用户的体验。本实验旨在通过模拟不同的进程调度算法，比较它们的优缺点，加深对操作系统原理和设计的理解和掌握。
一、开发语言及实验平台
C++/JAVA
Turbo C / Microsoft Visual Studio 6.0 / Microsoft Visual Studio .NET 2010
在本文中使用的是c语言（？），使用的平台是devc++
二、实验目的 （1）加深对进程的概念及进程调度算法的理解；
（2）在了解和掌握进程调度算法的基础上，编制进程调度算法通用程序，将调试结果显示在计算机屏幕上，并检测机算和笔算的一致性。
三、实验要求 （1）了解进程调度；
（2）理解利用进程调度算法进行调度的原理；
（3）使用某种编程语言进行算法模拟。
四、实验原理 例题：设计一个有N个进程的进程调度算法。 进程调度算法：采用最高优先数的调度算法（即把处理机分配给优先数最高的进程）。
每个进程有一个进程控制块（PCB）表示。进程控制块可以包含如下信息：进程名、优先数、到达时间、需要运行时间、已用CPU时间、进程状态等等。
进程的优先数及需要的运行时间可以事先人为的指定（也可以由随机数产生）。进程的到达时间为进程的输入的时间。进程的运行时间以时间片为单位进行计算。
每个进程的状态可以是就绪W（Wait）、运行R（Run）、或完成F（Finish）三种状态之一。就绪进程获得CPU后都只能运行一个时间片。用已占用CPU时间加1表示。
如果运行一个时间片后，进程的已占用CPU时间已达到所需要的运行时间，则撤销该进程，如果运行一个时间片后，进程的已占用CPU时间还未达到所需要的运行时间，也就是进程还需要继续运行，此时应该将进程的优先数减1（即降低一级），然后把它插入就绪队列等待CPU。
每进行一次调度程序都打印一次运行进程、就绪队列、以及各个进程的PCB，以便进行检查。
重复以上过程，直到所要的进程都完成为止。
分析:
使用固定队列与静动态优先级结合，每个优先级为0~0xFF,并且以小的数字为高优先级，大的数字为低优先级，每次皆使用循环得到最高优先级的进程并执行，然后将其动态优先级设置为最低，并将其他进程动态优先级提高，以使得每个进程都有机会运行。进程的优先级与运行时间由随机数产生。
五、实验过程 代码如下：
#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;time.h&gt; /*常量和状态定义*/ #define PRO_NUM 0x05 #define MAX_TIME 0xFF /*状态宏*/ #define WAIT 0x01 #define RUN 0x02 #define FINISH 0x03 #define ID_ERROR 0x10 #define MIN_PRIOR 0xFF //255 #define MAX_PRIOR 0x00 0 typedef unsigned int Uint32; /*进程PCB*/ struct PCB_Info { Uint32 s_id; Uint32 s_static_prior; Uint32 s_dynamic_prior; Uint32 s_start_time; Uint32 s_need_time; Uint32 s_used_time; Uint32 s_state; }; /*进程队列*/ PCB_Info g_queue[5]; Uint32 g_time = 0; /*模拟进程执行函数*/ void Simulator(); /*初始化5个进程函数*/ void Init_Process(); /*初始化进程队列函数*/ void Init_Queue(); /*创建进程函数*/ Uint32 Create_Process(Uint32 pri,Uint32 needtime); /*系统运行函数*/ void Run_Process(); /*得到最高优先级进程 ID函数*/ Uint32 Get_PriProcess(); /*进程时间片执行函数*/ void Work_Process(Uint32 id); /*改变进程状态和优先级函数*/ void Change_Process(Uint32 id); /*打印进程状态函数*/ void Print_State(); /*结束系统函数*/ void End_Process(); /*入口函数*/ int main( int argc, char *argv[ ]) { Simulator(); return 0; } void Simulator() { Init_Process(); Run_Process(); End_Process(); } void Init_Process() { int i; Uint32 id; srand( (unsigned)time( NULL ) ); Init_Queue(); for(i=0;i&lt;PRO_NUM;++i) { /*在这里修改随机数的范围，建议优先级取值为0到4之间，进程工作总时间为1到10之间*/ id=Create_Process(rand()%5, 1+rand()%10); if(id!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b85ba4e78900ec85a678b713ec272506/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f61429498f89fdee69e23adacad8a091/" rel="bookmark">
			大模型训练——PEFT与LORA介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大模型训练——PEFT与LORA介绍 0. 简介1. LORA原理介绍2. 补充资料：低显存学习方法3. PEFT对LORA的实现 0. 简介 朋友们好，我是练习NLP两年半的算法工程师常鸿宇，今天介绍一下大规模模型的轻量级训练技术LORA，以及相关模块PEFT。Parameter-Efficient Fine-Tuning (PEFT)，是huggingface开发的一个python工具，项目地址：
https://github.com/huggingface/peft
其可以很方便地实现将普通的HF模型变成用于支持轻量级fine-tune的模型，使用非常便捷，目前支持4种策略，分别是：
LoRA: LORA: LOW-RANK ADAPTATION OF LARGE LANGUAGE MODELSPrefix Tuning: Prefix-Tuning: Optimizing Continuous Prompts for Generation, P-Tuning v2: Prompt Tuning Can Be Comparable to Fine-tuning Universally Across Scales and TasksP-Tuning: GPT Understands, TooPrompt Tuning: The Power of Scale for Parameter-Efficient Prompt Tuning 今天要介绍的，是其中之一，也是最近比较热门的LORA (LOW-RANK ADAPTATION OF LARGE LANGUAGE MODELS)。
1. LORA原理介绍 LORA的论文写的比较难读懂，但是其原理其实并不复杂。简单理解一下，就是在模型的Linear层，的旁边，增加一个“旁支”，这个“旁支”的作用，就是代替原有的参数矩阵W进行训练。
结合上图，我们来直观地理解一下这个过程，输入 x x x，具有维度 d d d，举个例子，在普通的transformer模型中，这个 x x x可能是embedding的输出，也有可能是上一层transformer layer的输出，而 d d d一般就是768或者1024。按照原本的路线，它应该只走左边的部分，也就是原有的模型部分。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f61429498f89fdee69e23adacad8a091/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d1196203d68fcf4871020e11d86e107/" rel="bookmark">
			JVM（Java虚拟机）-史上最全、最详细JVM笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、JVM概述
1、1为什么要学习JVM
1、2虚拟机
1、3JVM作用
1、4JVM整体组成部分 二、JVM结构--类加载器
2、1类加载子系统
2、2类加载过程
2、2、1加载
2、2、2链接
2、2、3初始化
2、3类加载器分类
2.3.1 引导类加载器(启动类加载器 BootStrap ClassLoader)
2.3.2 扩展类加载器(Extension ClassLoader)
2.3.3 应用程序类加载器(系统类加载器 Application ClassLoader)
2.4 双亲委派机制
2.5 如何打破双亲委派机制
三、JVM运行时数据区
3、1运行时数据区组成概述
3.1.1 程序计数器（Program Counter Register）
3.1.2Java 虚拟机栈（Java Virtual Machine Stacks）
3.1.3 本地方法栈（Native Method Stack）
3.1.4Java 堆（Java Heap）
3.1.5 方法区（Methed Area）
3.2.程序计数器（Program Counter Register）
3.3.Java 虚拟机栈（Java Virtual Machine Stacks）
3.4.本地方法栈(Native Method Stack)
3.5.Java 堆内存
3.5.1Java堆内存概述
3.5.2堆内存区域划分
3.5.3 为什么分区(代)？
3.5.4 对象创建内存分配过程
3.5.5 新生区与老年区配置比例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d1196203d68fcf4871020e11d86e107/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe2376ca7bc9fde5e3346035e88da870/" rel="bookmark">
			文心一言 vs GPT-4 —— 全面横向比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文心一言 vs GPT-4 —— 全面横向比较 3月15日凌晨，OpenAI发布“迄今为止功能最强大的模型”——GPT-4。我第一时间为大家奉上了体验报告《OpenAI 发布GPT-4——全网抢先体验》。
时隔一日，3月16日下午百度发布大语言模型——文心一言。发布会上，李彦宏展示了文心一言在文学创作、商业文案创作、数理推算、中文理解、多模态生成五个使用场景中的综合能力。尽管现场演示的效果很不错，但也有网友质疑其真实性，更有网友说：“没有对比就没有伤害，是骡子是马拉出来跟GPT-4比试比试。”
刚好今天我拿到了文心一言的内测账号，我们就让文心一言和GPT-4正面PK一把，看看文心一言到底是什么水平。
文章目录 PK方法PK过程Round 1: 语义理解简单语义文言文理解孤立语理解上下文理解 Round 2: 内容创作撰写邮件撰写影评撰写软文 Round 3: 逻辑推理简单推理逻辑陷阱逻辑干扰多链条推理 Round 4: 编码能力常见算法高级算法找bug代码理解 Round 5: 数学能力常识问题年龄问题递归问题抽象问题 Round 6: 人格模拟 总结后记 PK方法 为了公平起见，我会向文心一言和ChatGPT（采用GPT-4 Model）发出同样的提问，比较二者输出的差异。比较中会优先看正确性，然后比较生成内容的自然和流畅性。由于文心一言长时间不交互，会话会自动过期刷新，为了公平，如果文心一言刷新了会话，则ChatGPT也会相应地新建一个会话。
我将从如下几个我认为重要的方面进行对比：
语义理解内容创作逻辑推理编码能力数学能力人格模拟 PK过程 Round 1: 语义理解 作为一个大语言模型，我认为最重要的能力是“语义理解”能力，也就是要能听得懂人话。这一轮PK我将问文心一言和ChatGPT一些日常常见的问题和任务，看它们回答得怎么样。
简单语义 首先，我让两个模型“列举10条人工智能未来的应用场景”，让我们看一下结果：
文心一言
GPT-4
二者都列举出了类似的人工智能的用例，并给出了进一步解释。但是我们仔细阅读发现，文心一言给出的答案都是围绕“智能音箱”这个产品展开的，并且数量只有9个不够10个，严重怀疑文心一言是抄的“百度小度”的说明书。相比之下GPT-4给出的回复则言简意赅、高屋建瓴地解释了每个用例场景下AI发挥的作用。因此这一题，GPT-4完胜文心一言。
文言文理解 汉语的精髓在文言文。文言文言简意赅，表意丰富，能否很好地理解文言文是衡量一个汉语语言模型的重要指标。下面我们看一下文心一言和GPT-4在文言文上的理解。
我分别问文心一言和GPT-4《孙子算经》上的一道题：“今有物不知其数，三三数之剩二；五五数之剩三；七七数之剩二。问物几何?”
文心一言
文心一言的回答完全没理解问题，重复了题目后给出了一个不知所谓的计算公式。我们再来看一下GPT-4的回答。
GPT-4
GPT-4很好地理解了这道题，知道这是中国古代的一道同余问题，并将题目转换成数学语言，然后给出了详细的推理计算步骤。尽管最后一步的计算出现了错误（最后一步应该是 x = 233 m o d 105 = 23 x=233 mod 105 =23 x=233mod105=23 ，而不是同余式 x ≡ 233 ( m o d 105 ) x \equiv 233 (mod 105) x≡233(mod105) 。感谢 韩灏凛ceaser 和 MyElevenEven 指出错误。)，但前面对中国剩余定理的使用是正确的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe2376ca7bc9fde5e3346035e88da870/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58067570d8c8740cf43b69890950f7af/" rel="bookmark">
			vue3 解决各场景 loading过度 ，避免白屏尴尬！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ⅰ、前言 当我们每次打卡页面，切换路由，甚至于异步组件，都会有一个等待的时间 ；为了不白屏，提高用户体验，添加一个 loading 过度动画是 非常 常见的 ；那么这几种场景我们应该把 loading 加在哪里呢 ？ 文章目录 Ⅰ、前言Ⅱ、vue3 常见过度1、 首次打开页面时 loading2、 路由切换时、异步组件 loading Ⅲ、 添加过度动画 Ⅱ、vue3 常见过度 针对以下 3 种情况 做了一下整理 👇
① 首次打开页面时；
② 路由切换时；
③ 异步组件显示时；
1、 首次打开页面时 loading 在页面首次打开的加载内容，是最容易的，通过根目录 index.html文件在 &lt;div id='app'&gt; 里添加内容，就是过度内容 &lt;body&gt; &lt;div id="app"&gt; &lt;h1&gt;加载中......&lt;/h1&gt; &lt;/div&gt; &lt;script type="module" src="/src/main.js"&gt;&lt;/script&gt; &lt;/body&gt; 当vue实例创建完成，通过.mount() 方法挂载到 id='app' 的div 里，会替换掉里的loading内容； 2、 路由切换时、异步组件 loading 路由切换过度 需要先了解一个，vue3 的内置组件 &lt;Suspense&gt;；&lt;Suspense&gt; 提供 2 个插槽 👇；#default : 一个要加载的内容 ；#fallback: 一个加载种显示的内容； &lt;Suspense&gt; &lt;template #default&gt; &lt;router-view /&gt; &lt;/template&gt; &lt;template #fallback&gt; &lt;h1&gt;加载中.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58067570d8c8740cf43b69890950f7af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c510b50694062ecbe0d1f4ba789020ed/" rel="bookmark">
			大数据开发语言Scala（一）——scala入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		累了，基础配置不想写了，直接抄了→Scala的环境搭建
这里需要注意的是，创建新项目时，不要用默认的Class类，用Object，原因看→scala中的object为什么可以直接运行
一、Scala简介 1.1 图解Scala和Java的关系 1.2 关键字说明 package： 包，等同于java中的package
object：关键字，声明一个单例对象（伴生对象）
main方法：从外部可以直接调用执行的方法
def 方法名称 ( 参数名称 : 参数类型 ) : 返回值类型 = { 方法体 }
Scala 完全面向对象，故scala去掉了Java中非面向对象的元素，如static关键字，void类型 1) static scala无static关键字,由object实现类似静态方法的功能(类名.方法名) class关键字和Java中的class关键字作用相同,用来定义一个类 2) void 对于无返回值的函数,scala定义其返回值类型为Unit类型 1.3 代码案例 package com.scala.chapter1 object Hello { def main(args: Array[String]): Unit = { println("hello scala") System.out.println("hello scala") } } 1.4 Scala语言特点 Scala是一门以Java虚拟机 (JVM）为运行环境并将面向对象和函数式编程的最佳特性结合在一起的静态类型编程语言（静态语言需要提前编译的如: Java、C、C++等，动态语言如：JS）。
1）Scala是一门多范式的编程语言，Scala支持面向对象和函数式编程。 (多范式，就是多种编程方法的意思。有面向过程、面向对象、泛型、函数式四种程序设计方法。)
2）Scala源代码 (.scala) 会被编译成Java字节码 (.class)，然后运行于JVM之上，并可以调用现有的Java类库，实现两种语言的无缝对接。
3）Scala单作为一门语言来看，非常的简洁高效
4）Scala在设计时，马丁·奥德斯基是参考了Java的设计思想，可以说Scala是源于Java，同时马丁·奥德斯基也加入了自己的思想，将函数式编程语言的特点融合到JAVA中，因此，对于学习过Java的同学,只要在学习Scala的过程中，搞清楚Scala和Java相同点和不同点，就可以快速的掌握Scala这门语言。
二、变量和数据类型 Any： 所有类型的超类（顶级类型） AnyVal： 值类型的超类 AnyRef： 引用类型的超类，对应java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c510b50694062ecbe0d1f4ba789020ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/767d39602873f69faf0b13ec7592955d/" rel="bookmark">
			如何把自有数据接入GPT大模型？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGPT引发了AI革命，大家都想探究如何让它发挥更大价值。
以它为代表的大模型并未完全掌握所有专业知识，这也正是我们创业的契机。
我们应该思考如何让AI在专业领域中释放更大的价值潜能。
就像开发者挖掘出某个鲜为人知的资源一样，我们可以开发出AI在特定领域的潜力，从而在市场上脱颖而出。
以OpenAI的API为例，让大模型支持自己专业领域的知识，有两种方式：微调模型和封装到Prompt。
一、微调（Fine-tuning）注入专业领域知识 微调是在基础大模型训练成熟之后，通过Fine-tuning模式，利用标注数据调整模型参数以适应不同任务需求。
传统的微调需要做调整损失函数、增加额外层等工作，但自2018年以来，随着预训练模型的体量不断增大，预训练模型Fine-tune所需的硬件和数据需求也在不断增长。此外，下游任务的丰富多样性使得预训练和微调阶段的设计更为复杂。
如今，像GTP-4这样的模型已经采用了一种新的训练模式，即单向语言模型预训练+zero shot prompt/Instruct，它不需要在预训练后进行任务Fine-tuning，而是通过自然语言指令来解决下游任务，这为模型的优化提供了全新的可能性。
OpenAI在GPT-4上花了6个月的时间才放出来，是为了使其更安全、更一致，而不是新的专业领域知识的注入，新专业领域知识的注入耗时非常短的，也就根据数据量，几分钟到几小时。
从OpenAI的微调文档 https://platform.openai.com/docs/guides/fine-tuning 可以看出，要准备的数据包含prompt（输入文本）和completion（输出文本）两部分：
prompt是我们给模型的输入文本，它可以是任何文本，例如一个问题、一个描述、一个开头、一个例子等。prompt的作用是告诉模型我们想要完成什么样的任务，并给出一些上下文或模式。
completion是模型根据prompt生成的输出文本，它可以是任何文本，例如一个答案、一个续写、一个列表、一段代码等。completion的作用是尽可能地满足prompt的要求，并保持语义和逻辑的连贯性。
下面是一些数据例子：
{ "prompt": "对以下商品进行夸赞：彩妆中的口红品类，卖点为颜色是正红色，能提升气色 -&gt;", "completion": " 这口红正红色太好看了，完美提升气色，日常使用特别棒\\n" } 更多的例子可以看如下链接：
GPT-for-E-Commerce/test-v1.1.jsonl at b6dd9d018dce670efd28448dbd0dde0edecb3e42 · Royce17/GPT-for-E-Commerce · GitHubfinetune-with-openai/faq.jsonl at 334a69224d7e87a92de09b0d627f616be4ffa43a · A-baoYang/finetune-with-openai · GitHub 要微调的效果好，就要使用更多高质量的示例进行Fine-tuning，我们应该如上面链接例子一样，提供至少几百个高质量的示例，而且最好由专家审查过。
二、在Prompt中带入知识 只需设计恰当的输入，就能让ChatGPT在上下文中生成有价值的答案，而无需修改模型的结构或参数。
输入问题时，还可以引入相关知识，使问题更加全面。这种方法的局限性在于每次输入的长度有限。
下面是一些例子：
例1：作为专业DBA，回答SQL相关问题 这里在输入问题时，引入了我们的数据库表结构这个专业知识。
问：
我要你扮演一个专业DBA。我将提供给你数据表结构以及我的需求，你的目标是告知我性能最优的可执行的SQL语句，并尽可能的向我解释这段SQL语句，如果有更好的优化建议也可以提出来。
我的数据表结构为:
CREATE TABLE `user` ( `id` int NOT NULL AUTO_INCREMENT, `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '名字', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='用户表'; 我的需求为：根据用户的名字查询用户的id
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/767d39602873f69faf0b13ec7592955d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed20e984e0ae6db51c0464c6dea40bb6/" rel="bookmark">
			XGBoost详解（原理篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		入门小菜鸟，希望像做笔记记录自己学的东西，也希望能帮助到同样入门的人，更希望大佬们帮忙纠错啦~侵权立删。
目录
一、XGBoost简介
二、XGBoost原理
1、基本组成元素
2、整体思路
（1）训练过程——构建XGBoost模型 （2）测试过程
3、目标函数
（1）最初的目标函数
（2）推导
4、从目标函数到特征划分准则 + 叶子节点的值的确定
（1） ​编辑 的定义
（2）引入真实的​编辑和正则化项代换
（3）求出 ​编辑 —— 定下该叶子结点的值
（4）目标函数的最优解——与信息增益的连接
（5）特征划分准则——“信息增益”
5、从目标函数到加权分位法（实现对每个特征具体的划分）
（1）引入原因
（2）“特征值重要性”的提出
（3）目标函数到平方损失
（4）特征值重要性排序函数
（5）切分点寻找
（6）计算分裂点的策略
三、XGBoost对缺失值的处理
四、XGBoost的优缺点
1、优点
（1）精度高
（2）灵活性强
（3）防止过拟合
（4）缺失值处理
（5）并行化操作
2、缺点
一、XGBoost简介 XGBoost全称为eXtreme Gradient Boosting，即极致梯度提升树。
XGBoost是Boosting算法的其中一种，Boosting算法的思想是将许多弱分类器集成在一起，形成一个强分类器（个体学习器间存在强依赖关系，必须串行生成的序列化方法）。
Note：关于Boosting算法详见博文集成学习详解_tt丫的博客-CSDN博客
XGBoost是一种提升树模型，即它将许多树模型集成在一起，形成一个很强的分类器。其中所用到的树模型则是CART回归树模型。
Note：CART回归树模型详见博文决策树详解_tt丫的博客-CSDN博客
二、XGBoost原理 1、基本组成元素 XGBoost的基本组成元素是：决策树。
这些决策树即为“弱学习器”，它们共同组成了XGBoost；
并且这些组成XGBoost的决策树之间是有先后顺序的：后一棵决策树的生成会考虑前一棵决策树的预测结果，即将前一棵决策树的偏差考虑在内，使得先前决策树做错的训练样本在后续受到更多的关注，然后基于调整后的样本分布来训练下一棵决策树。
2、整体思路 （1）训练过程——构建XGBoost模型 从目标函数出发，可以推导出“每个叶子节点应该赋予的权值”，”分裂节点后的信息增益“，以及”特征值重要性排序函数“。
与之前决策树的建立方法类似。当前决策树的建立首先根据贪心算法进行划分，通过计算目标函数增益（及上面所说的”分裂节点后的信息增益“），选择该结点使用哪个特征。
选择好哪个特征后，就要确定分左右子树的条件了（比如选择特征A，条件是A&lt;7）：为了提高算法效率（不用一个一个特征值去试），使用“加权分位法”，计算分裂点（这里由”特征值重要性排序函数“得出分裂点）。
并且对应叶子节点的权值就由上述的“每个叶子节点应该赋予的权值”给出。
不断进行上述算法，直至所有特征都被使用或者已经达到限定的层数，则完整的决策树构建完成。
（2）测试过程 将输入的特征，依次输入进XGBoost的每棵决策树。每棵决策树的相应节点都有对应的预测权值w，将“在每一棵决策树中的预测权值”全部相加，即得到最后预测结果，看谁大，谁大谁是最后的预测结果。
3、目标函数 （1）最初的目标函数 设定第 t 个决策树的目标函数公式如下：
符号定义：
n表示样本数目；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed20e984e0ae6db51c0464c6dea40bb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0950876d7bb37c0196556698c1178f93/" rel="bookmark">
			人脸识别经典网络-MTCNN（含Python源码实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人脸检测-mtcnn 本文参加新星计划人工智能赛道：https://bbs.csdn.net/topics/613989052
文章目录 人脸检测-mtcnn1. 人脸检测1.1 人脸检测概述1.2 人脸检测的难点1.3 人脸检测的应用场景 2. mtcnn2.1 mtcnn概述2.2 mtcnn的网络结构2.3 图像金字塔2.4 P-Net2.5 R-Net2.6 O-Net 3. 工程实践（基于Keras） 1. 人脸检测 1.1 人脸检测概述 人脸检测或者识别，都是根据人的脸部特征信息进行身份识别的一种生物识别术。用摄像机或摄像头采集含有人脸的图像或视频流，并自动在图像中检测和跟踪人脸，进而对检测到的人脸进行脸部识别的一系列相关技术，通常也叫做人像识别、面部识别。
1.2 人脸检测的难点 人脸识别被认为是生物特征识别领域甚至人工智能领域最困难的研究课题之一。人脸识别的难点是由于人脸作为生物特征的特点而导致的，难点主要包括以下部分：
相似性：从人脸的构造上来看，个体之间的人脸构造区别不大，甚至人脸器官的构造都很相似。这种相似性对于利用人脸进行定位是能偶提供很大的便利的，但同时对于个体的区分确实难的。易变性：抛去构造仅仅关注外形的话，人脸的外形又是十分多变的，面部表情多变，而在不同观察角度，人脸的视觉图像也相差很大，另外，人脸识别还受光照条件（例如白天和夜晚，室内和室外等）、人脸的很多遮盖物（例如口罩、墨镜、头发、胡须等）、年龄等多方面因素的影响。 在人脸识别中，第一类的变化是应该放大而作为区分个体的标准的，而第二类的变化应该消除，因为它们可以代表同一个个体。通常称第一类变化为类间变化（inter-class difference），而称第二类变化为类内变化（intra-class difference）。对于人脸，类内变化往往大于类间变化，从而使在受类内变化干扰的情况下利用类间变化区分个体变得异常困难。
1.3 人脸检测的应用场景 人脸识别主要用于身份识别。
由于视频监控正在快速普及，众多的视频监控应用迫切需要一种远距离、用户非配合状态下的快速身份识别技术，以求远距离快速确认人员身份，实现智能预警。人脸识别技术无疑是最佳的选择，采用快速人脸检测技术可以从监控视频图象中实时查找人脸，并与人脸数据库进行实时比对，从而实现快速身份识别。
人脸识别产品已广泛应用于金融、司法、军队、公安、边检、政府、航天、电力、工厂、教育、医疗及众多企事业单位等领域。随着技术的进一步成熟和社会认同度的提高，人脸识别技术将应用在更多的领域。
1、企业、住宅安全和管理。如人脸识别门禁考勤系统，人脸识别防盗门等。
2、电子护照及身份证。
3、公安、司法和刑侦。如利用人脸识别系统和网络，在全国范围内搜捕逃犯。
4、自助服务。
5、信息安全。如手机、计算机登录、电子政务和电子商务。
2. mtcnn 2.1 mtcnn概述 MTCNN，英文全称是Multi-task convolutional neural network，中文全称是多任务卷积神经网络，该神经网络将人脸区域检测与人脸关键点检测放在了一起。
从工程实践上，MTCNN是一种检测速度和准确率都很不错的算法，算法的推断流程有一定的启示作用。
2.2 mtcnn的网络结构 mtcnn从整体上划分分为P-Net、R-Net、和O-Net三层网络结构。各层的作用直观上感受如下图所示：
一次mtcnn对于局部信息的运作流程如下描述：
由原始图片和PNet生成预测的bounding boxes。输入原始图片和PNet生成的bounding box，通过RNet，生成校正后的bounding box。输入原始图片和RNet生成的bounding box，通过ONet，生成校正后的bounding box和人脸面部轮廓关键点。 当整个图片的局部信息都进行处理之后，就能得到所有的局部人脸信息，或有或无，进行校正处理后就可以得到最后的结果。
P-Net、R-Net、O-Net的网络结构如下图所示：
分析：
MTCNN主要包括三层网络，
第一层P-Net将经过卷积，池化操作后输出分类（对应像素点是否存在人脸）和回归（回归box)结果。第二层网络将第一层输出的结果使用非极大抑制（NMS）来去除高度重合的候选框，并将这些候选框放入R-Net中进行精细的操作，拒绝大量错误框，再对回归框做校正，并使用NMS去除重合框，输出分支同样两个分类和回归。最后将R-Net输出认为是人脸的候选框输入到O-Net中再一次进行精细操作，拒绝掉错误的框，此时输出分支包含三个分类：
a. 是否有人脸：2个输出；
b. 回归：回归得到的框的起始点（或中心点）的xy坐标和框的长宽，4个输出；
c. 人脸特征点定位：5个人脸特征点的xy坐标，10个输出。 三段网络都有NMS，但是所设阈值不同。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0950876d7bb37c0196556698c1178f93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d85283b1f95a4061c2385ffeddecf77/" rel="bookmark">
			VUE登录注册页面,完整vue，直接复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图：
Login.vue
&lt;template&gt; &lt;div class="container"&gt; &lt;div class="login-wrapper"&gt; &lt;div class="header"&gt;Login&lt;/div&gt; &lt;div class="form-wrapper"&gt; &lt;input type="text" name="username" placeholder="username" class="input-item"&gt; &lt;input type="password" name="password" placeholder="password" class="input-item"&gt; &lt;div class="btn"&gt;Login&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name:"Login" } &lt;/script&gt; &lt;style scoped&gt; html { height: 100%; } body { height: 100%; } .container { /* margin-top: 5%; */ height: 980px; width: 100%; background-image: linear-gradient(to right, #fbc2eb, #a6c1ee); } .login-wrapper { background-color: #fff; width: 358px; height: 588px; border-radius: 15px; padding: 0 50px; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d85283b1f95a4061c2385ffeddecf77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daf1e8fd1cab971841fe9698f2bcfc58/" rel="bookmark">
			C typedef 用法 详解（通俗易懂）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、为什么需要typedef ？
三、typedef关键字的介绍和使用
1.简介
2.使用
3.示例
eg1 :
eg2 : eg3 : 四、总结
一、前言 大家好，今天为大家带来的是typedef关键字的内容分享。本篇博文算是《C语言数据结构与算法》系列专栏的开篇之作。其实，up准备出的C语言描述的数据结构与算法也仅仅是为了将来java版本的数据结构与算法做做铺垫，毕竟up是主攻java的😂。当然，之后up大概率会出C语言描述的算法题的讲解，这下数据结构与算法也算派上用场了。
注意 : ①代码中的注释也很重要；②不要眼高手低，自己跟着过一遍才能真正有收获；③可以点击文章侧边栏或者文章前面的目录进行跳转。良工不示人以朴，所有文章都会适时补充完善。感谢阅读！
二、为什么需要typedef ？ 拿结构体为例，假设我们定义一个Student类型的结构体，如下所示 : struct Student { char name[100]; int age; char sex; double score; }; 在没有typedef的情况下，我们每定义一个"struct Student"类型的变量，都需要写一遍"struct Student"；而每次定义一个该类型对应的指针变量，都要写一遍"struct Student * "。如以下代码所示 :
# include &lt;stdio.h&gt; struct Student { char name[100]; int age; char sex; double score; }; int main (void) { struct Student stu1 = {"Cyan", 21, 'M', 425}; struct Student stu2 = {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daf1e8fd1cab971841fe9698f2bcfc58/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/68/">«</a>
	<span class="pagination__item pagination__item--current">69/71</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/70/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>