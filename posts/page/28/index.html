<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58fe9b298d08cf7a7d06b9a34b394a9b/" rel="bookmark">
			【版本控制】mac平台SVN客户端: macSvn 下载与使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mac 平台下一直没有一款像 windows 的 TortoiseSVN 全面、高效、便捷的 SVN 客户端，最近发现一款新发布的 macSvn，感觉比目前主流的 Cornerstone、Snail SVN 等要好用，直接内置了版本控制中常用的比较工具、缺陷跟踪工具，不再需要额外下载和打开其他软件。另外像 TortoiseSVN 一样无缝集成至OS，使用方便快捷，上手非常容易。
下载链接：https://macsvn.co/downloads/macSvn.dmg
官网地址：https://macsvn.co/
中文版地址：https://macsvn.co/zh-cn/
一、下载安装 在官网下载页面点击macSvn.dmg，或直接点击此链接。
完成后双击图标打开。
鼠标单击把左侧的图标拖进右侧文件夹。安装完成。 二、使用 macSvn 无缝集成至 macOS 的Finder窗口，支持使用图标徽章显示版本跟踪状态，可通过Finder窗口的上下文菜单、工具条菜单、和边栏菜单，执行所有的 svn 操作。
安装完成后Finder窗口工具条会出现 “macSvn 版本控制” 的按钮，如果没有可以右键点击工具条，执行 “自定义工具栏...”, 然后将 macSvn 版本控制 按钮拖至工具栏。
（1）设置工作目录 打开Finder窗口，点击工具条 “macSvn 版本控制” 按钮, 执行 “工作目录 / 管理工作目录 / 选择工作目录 ...” 菜单项, 然后选择你的工作目录。或者，在Finder窗口中打开工作副本，然后点击工具条 “macSvn 版本控制” 按钮, 执行 “工作目录 / 管理工作目录 / 当前工作目录” 菜单项。
也可以点击状态栏 “macSvn 版本控制” 图标，执行 “工作目录 / 添加工作目录” 菜单项，然后选择你的工作目录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58fe9b298d08cf7a7d06b9a34b394a9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/121384182e1dc6161f7d513985a2d5b2/" rel="bookmark">
			【redis】初识redis和分布式系统的基本知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		˃͈꒵˂͈꒱ write in front ꒰˃͈꒵˂͈꒱
ʕ̯•͡˔•̯᷅ʔ大家好，我是xiaoxie.希望你看完之后,有不足之处请多多谅解，让我们一起共同进步૮₍❀ᴗ͈ . ᴗ͈ აxiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客
本文由xiaoxieʕ̯•͡˔•̯᷅ʔ 原创 CSDN 如需转载还请通知˶⍤⃝˶​
个人主页：xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客
系列专栏:​ xiaoxie的redis学习系列专栏——CSDN博客●'ᴗ'σσணღ ​
我的目标:"团团等我💪( ◡̀_◡́ ҂)" ( ⸝⸝⸝›ᴥ‹⸝⸝⸝ )欢迎各位→点赞👍 + 收藏⭐️ + 留言📝​+关注（互三必回）!
一.初谈redis 1.什么是redis redis是一个开源的，基于内存存储的数据结构服务器,起初 redis 的初心是作为一个"消息中间件"(消息队列)而被创建的,但由于市场上的像 Kafka、RabbitMQ 等专业消息中间件在处理在处理大规模消息传递、消息顺序保证、以及容错能力方面表现得更为出色,redis 又因为其基于内存存储的特点,而被做为 分布式系统下的缓存服务器来被广泛使用.
2.为什么要在分布式系统下使用redis 无论是在单机环境还是分布式系统中，Redis都可以作为一个强大的缓存解决方案，提高系统的性能和可扩展性。在分布式系统中，Redis的功能特性可以得到更充分的发挥，但在单机环境下，Redis作为缓存也可以带来显著的性能提升.在学习redis之前还是有必要了解一下关于分布式系统的知识.
二.分布式系统 1.名词解释 在了解分布式系统,首先我们应该先了解关于分布式系统的名词
1.应用 / 系统 一个应用/系统 就是一个 / 组 服务器程序
2.模块 / 组件 一个应用,有很多功能,而每个独立的功能,就可以称为一个模块 / 组件
3.分布式 引入多个主机 / 服务器 协同配合完成一系列的工作,就是物理意义上的多个主机.
4.集群 引入多个主机 / 服务器 协同配合完成一系列的工作,但这个是逻辑上的多主机,你可在一台主机上,部署多个服务器,它们协同工作,如果工作量太大,也可以扩展成多个主机上的多个服务器.所以称为逻辑上的多主机集群中的“主机”或“服务器”可以是物理服务器，也可以是在同一台物理主机上运行的多个虚拟服务器或容器.
5.主 / 从 这是分布式系统中比较常见的架构
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/121384182e1dc6161f7d513985a2d5b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36227237b15179a4ef369bbf2cd33170/" rel="bookmark">
			【数据结构】链表专题2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
本篇博客继续探讨有关链表的专题，这片博客的题，提前打个预防针，有点意思哦，哈哈哈，话不多说，进入正文
💓 个人主页：小张同学zkf
⏩ 文章专栏：数据结构
若有问题 评论区见📝
🎉欢迎大家点赞👍收藏⭐文章 ​
目录
1.返回倒数第几个节点
2.链表的回文结构
3.相交链表​
1.返回倒数第几个节点 这道题跟我们上一篇博客有道题返回中间节点有点像，首先这道题时间复杂度O（1），所以我们遍历原链表只能遍历一次
那我们就继续用返回中点节点的方法，快慢指针做这道题也适用
快慢指针，如若我让快指针先走k步，走完了再让慢指针走，此刻快慢指针就差k，双指针同时遍历，直到快指针走完，此刻慢指针返回的就是倒数第k的节点，所以一定要确保俩指针要差k
代码如下： 2.链表的回文结构 这道题，我们乍一看有点难，要求时间复杂度为O（n）,空间复杂度为O（1）
我们要想证明它是个回文结构，首先我们先了解回文结构的特征，就是以中间节点为中心，这个链表的值是对陈的，那我们要证明对称，我么是不是可以先找到终点节点，再反向一下以中间节点为首的之后的节点，然后中间指针与首指针遍历判断值是否相等，如图所示，这里有人有疑问，偶数个接点还可以看，但奇数个接点那，如图所示那个三，其实，再反转时，我们没有消除第一个二指向三的指针，所以两个2此刻都指向三， 只要在遍历时发生不相等的，那就不是回文，若直到遍历完，还都是相等的，那就是回文。
所以我们就创建两个函数，其实就把我们链表1里面的反转链表和返回中间节点的代码复制过来就行，哈哈，cv工程师
那这两个函数我就不详细说了，在我的博客链表专题1里有，一个是反转链表用三指针法，一个是返回中间节点用快慢指针法
链表专题一博客链接：http://t.csdnimg.cn/zM8BB
好了整体总结一下
1.创建返回中间节点函数
2.创建反向链表函数，返回头结点
3.遍历原链表与函数返回的链表判断
代码如下： 3.相交链表 首先我们要想一点，什么是链表相交
首先看一个图 这种可不是链表的相交
这种是
也就是说链表相交，是两个线合成一个线 为什么这种不可以，因为链表一个节点怎么可能会同时指向两个节点，一个节点只能指向一个节点
所以这道题做法就清楚了
我们首先判断是否相交，若相交，其次返回相交的第一个节点
怎么判断相交那
有一个非常巧妙的方法
看俩链表是否尾结点一样，若一样，代表相交，否则不想交，我们仔细想想若俩链表合二为1，那么俩链表是不是就是同一个尾结点，所以这点很巧妙
注意：这里尾结点判断是地址判断，不是值，值的话有可能出现俩链表尾结点值一样。
所以遍历俩链表找到最后一个节点就行了。 ok,我们判断完了，若相交，来继续看看怎么返回头结点
我们用俩指针指向两链表的头部，因为相交之前，俩链表的长度不确定，我们先判断，谁长，让谁先走他们相差的部分，走完另一个指针再遍历，此刻两个指针同时向后遍历，若遍历的值相同了，就找到第一个相交的节点了
OK，我们可以用假设法来判断
什么叫假设法？
我们可以先创建一个变量来记录长的节点，另一个变量记录短的节点，然后假设长的就是第一个链表，短的就是第二个链表，再用if判断看两个变量需不需要互换，这样就不用管到底哪个链表长，哪个链表短
假设法代码如下：
判断完之后就可以，让谁先遍历差值，再一起遍历，一个一个判断是否相等就行了
这道题代码如下
结束语 链表专题2就结束了，还有几道典型的链表专题就放在下片博客说了
OK，感谢观看！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/506c7bf5b6f783238a693b33ff2569a6/" rel="bookmark">
			spring的常用注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页：五敷有你 🔥系列专栏：Spring
⛺️稳中求进，晒太阳
Spring框架注解： 给容器中注入组件 （1）包扫描+组件标注注解 @Component：
用于标识一个类作为组件（Component），可以将类交由Spring容器管理，实现组件的自动扫描、实例化、依赖注入和配置管理等功能。当类不属于其他特定层（如控制层、服务层、数据访问层）时，可以使用此注解。
@Repository：
标识一个类作为数据访问层组件（Repository），主要用于标注数据访问层或DAO组件。通过该注解，可以将类交由Spring容器管理，享受依赖注入、事务管理、AOP等功能。
@Service：
标识一个类作为服务层组件，主要用于进行业务逻辑处理。Spring容器能够自动识别并实例化服务层组件，并能够自动将请求映射到对应的服务方法进行处理。
@Controller：
标识一个类作为控制层组件（Controller），用于处理HTTP请求。Spring容器能够自动识别并实例化控制器层组件，并能够自动将请求映射到对应的控制器方法进行处理。
（2）@Bean 导入第三方包里面的注解 （3）@Import() @ImportSelector:返回需要导入的组件的全类名数组；
@ImportBeanDefinitionRegistrar:手动注册bean到容器中
注入bean的注解 @Autowired： 用于自动装配bean，可以自动将依赖的对象注入到需要该对象的bean中。这可以消除Java代码中的getter/setter方法和bean属性中的property。
@Resource ： 此注解是Java EE规范中的注解，也可以用于自动装配bean。与@Autowired不同的是，@Resource可以通过name属性指定bean的名称，如果没有指定name属性，则会默认按照bean的名称进行自动装配。
@ResponseBody： 用于将返回结果直接写入HTTP响应体中，通常与@Controller注解一起使用，将Java对象转换为JSON格式的数据返回给客户端。
@Configuration：
标识当前类是配置类，它包含了一个或多个@Bean注解的方法，这些方法会被Spring容器处理，用于生成bean定义和服务请求所需的对象。
@Bean ：
在@Configuration注解的类中，通过@Bean注解的方法可以定义并初始化Bean，然后由Spring的IOC容器来管理这些Bean。
@Scope：
用于指定bean的作用域，如"singleton"、"prototype"等。
@Lazy ：
用于延迟bean的初始化，即在第一次请求时才会进行初始化。
@PostConstruct：
在依赖注入完成后，执行初始化方法。
@PreDestroy：
在bean销毁之前执行的方法。
@Qualifier ：
与@Autowired注解配合使用，用于按照名称装配bean。
@Value：
用于为属性赋值，支持基本数据类型、String、SpEL表达式等。
@PropertySource：
加载指定路径的配置文件（如.properties文件）。
@Aspect：
用于声明一个类为切面类，切面类中可以定义通知和切点。
@Before：
前置通知，在目标方法被调用之前执行。
@After：
后置通知，在目标方法执行之后执行（无论方法是否成功完成）。
@AfterReturning：
返回通知，在目标方法正常执行完成后执行，通常可以访问到目标方法的返回值。此注解可以指定一个返回值形参名，如` @AfterReturning(pointcut = "execution(* com.example.service.*.*(..))", returning = "result")`。
@AfterThrowing：
异常通知，在目标方法抛出异常后执行。此注解可以指定一个形参名来访问抛出的异常对象，如`@AfterThrowing(pointcut = "execution(* com.example.service.*.*(..))", throwing = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/506c7bf5b6f783238a693b33ff2569a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aeefb2622384e5d4037678394e6aaa6/" rel="bookmark">
			【C&#43;&#43;航海王：追寻罗杰的编程之路】多态你了解多少？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 -&gt; 多态的概念
1.1 -&gt; 概念
2 -&gt; 多态的定义及实现
2.1 -&gt; 多态的构成条件
2.2 -&gt; 虚函数
2.3 -&gt; 虚函数的重写
2.4 -&gt; C++11 override和final
2.5 -&gt; 重载、覆盖(重写)、隐藏(重定义)的对比
3 -&gt; 抽象类
3.1 -&gt; 概念
3.2 -&gt; 接口继承和实现继承
4 -&gt; 多态的原理
4.1 -&gt; 虚函数表
4.2 -&gt; 多态的原理
4.3 -&gt; 动态绑定与静态绑定
5 -&gt; 单继承和多继承关系的虚函数表
5.1 -&gt; 单继承中的虚函数表
5.2 -&gt; 多继承中的虚函数表
1 -&gt; 多态的概念 1.1 -&gt; 概念 多态的概念：通俗来说，就是多种形态，具体点就是去完成某个行为，当不同的对象去完成时会产生不同的状态。
比方说买票这个行为，当普通人买票时，是全价票；学生买票时，是半价票；军人买票时，是优先购票。
2 -&gt; 多态的定义及实现 2.1 -&gt; 多态的构成条件 多态是在不同继承关系的类对象，去调用同一函数，产生了不同的行为。比如Student继承了Person。Person对象买票全价，Student对象买票半价。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8aeefb2622384e5d4037678394e6aaa6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50e2cee85873eeeb28c0cdaa60b6a8de/" rel="bookmark">
			AI家居设备的未来：智能家庭的下一个大步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔒目录
☂️智能家居设备的发展和AI技术的作用
❤️AI技术实现智能家居设备的自动化控制和智能化交互的依赖
AI家居设备的未来应用场景
💣智能家庭在未来的发展和应用前景 💥智能家居设备的发展和AI技术的作用 智能家居设备的发展和AI技术的作用是智能化家庭生活的重要组成部分。随着科技的不断进步，智能家居设备已经从传统的家用电器发展到拥有更智能化、自动化和个性化特性的产品。
过去几年，智能家居设备已经实现了巨大的发展，这些设备可以通过互联网连接并使用传感器、摄像头、智能控制器等技术实现自动化控制和智能化交互。这些设备包括智能灯具、智能家电、智能安防系统、智能音响、智能门锁等。
人工智能技术在智能家居领域的作用日益凸显。通过机器学习、深度学习和自然语言处理等技术，AI系统能够学习和理解用户的行为习惯、偏好和需求，从而实现智能化的控制和个性化的服务。例如，智能家居设备可以根据用户的习惯自动调节温度、光线和湿度，提高家庭能源利用效率；智能语音助手可以通过语音识别和自然语言理解与用户进行智能对话，并实现家居设备的远程控制和管理。
总的来说，智能家居设备的发展已经深刻改变了人们的生活方式和家庭管理方式，AI技术的应用将进一步推动智能家居设备的普及和发展，实现更智能、更便捷、更舒适的家居生活。
🍓AI技术实现智能家居设备的自动化控制和智能化交互的依赖 感知与感知处理：
传感器技术：智能家居设备配备各种传感器，如温度传感器、湿度传感器、光线传感器等，用于感知环境参数。图像处理技术：智能家庭安防设备通过摄像头采集图像数据，并通过图像处理技术实现人脸识别、动作检测等功能。 智能决策与控制：
机器学习算法：智能家居设备利用机器学习算法对传感器数据进行分析和学习，从而自动识别用户的习惯和行为模式。智能控制系统：基于机器学习模型和用户行为模式，智能家居设备可以自动调节温度、光线、湿度等环境参数，实现自动化控制。 自然语言处理与人机交互：
语音识别技术：智能语音助手通过语音识别技术将用户的口头指令转换为文本数据。自然语言理解技术：智能语音助手通过自然语言理解技术理解用户的意图和需求。语音合成技术：智能语音助手通过语音合成技术将计算结果或执行结果转换为语音输出，与用户进行交互。 远程控制与云端服务：
云计算技术：智能家居设备通过云端服务实现数据存储、分析和处理，实现远程监控和控制。远程通信技术：智能家居设备通过网络通信技术与互联网连接，实现远程控制和数据传输。 🤖AI家居设备的未来应用场景 智能家居中的人工智能助手：智能语音助手和人机交互
智能语音助手是智能家居中的重要组成部分，未来的发展趋势将更加强调个性化和智能化的人机交互体验。具体应用场景包括：
语音控制家居设备：用户可以通过语音指令控制智能家电、灯光、窗帘等设备，实现智能化的家居管理。
智能日程管理：语音助手可以帮助用户管理日程安排、提醒重要事项，并根据用户的行为习惯和喜好提供个性化建议。
语音娱乐和信息服务：用户可以通过语音助手获取新闻资讯、音乐播放、电影推荐等娱乐服务，并实现智能化的内容推荐和个性化推送。
智能家庭协作：语音助手可以成为家庭成员之间的智能协作平台，实现家庭成员之间的语音交流、留言传递等功能。
智能安全系统：AI监控和智能报警系统的发展
智能安全系统通过AI技术实现对家庭安全的全方位监控和智能化报警，未来的发展方向包括：
智能监控摄像头：AI技术可以识别人脸、动作和行为，实现智能监控和安全防护。
异常检测和预警：智能安全系统可以通过AI算法检测异常事件，如入侵、火灾、煤气泄漏等，及时发出预警并采取相应的安全措施。
智能化报警处理：智能安全系统可以与警报系统、手机APP等智能设备实现联动，提高报警处理的效率和及时性。
智能家庭监护：智能安全系统还可以实现对老人、儿童等弱势群体的智能监护，保障家庭成员的安全和健康。
智能环境控制：AI在能源管理、温度调节和照明控制中的应用
智能环境控制利用AI技术实现对家庭环境的智能化管理和优化，主要应用场景包括：
能源管理与节能优化：AI技术可以分析家庭能源消耗情况，制定节能方案并自动调节家电设备的使用，实现能源的智能化管理和优化。
智能温度调节：智能温控系统通过学习用户的习惯和偏好，自动调节室内温度，提高舒适度并节省能源消耗。
智能照明控制：智能照明系统可以根据光线强度和室内环境实时调节灯光亮度和色温，实现个性化的照明体验和节能效果。
环境质量监测与改善：智能环境控制系统可以实时监测室内空气质量、湿度等环境参数，并根据监测结果调节空气净化器、加湿器等设备，提高室内环境的舒适度和健康水平。
下边是智能热水器的代码逻辑
import random class WaterHeater: def __init__(self, min_temp=30, max_temp=60): self.min_temp = min_temp self.max_temp = max_temp self.current_temp = random.randint(min_temp, max_temp) def adjust_temperature(self, user_habit): if user_habit == "morning": self.current_temp = random.randint(self.max_temp - 5, self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50e2cee85873eeeb28c0cdaa60b6a8de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7ef4dd1b72177a8e10896d2bb47a30c/" rel="bookmark">
			【C&#43;&#43;】一篇文章带你深入了解stack、queue 和 priority_queue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、stack的介绍和使用1.1 stack的介绍1.2 stack的使用1.2.1.1 [stack对象的构造](https://legacy.cplusplus.com/reference/stack/stack/stack/)1.2.1.2 stack对象的容量操作1.2.1.2.1 [empty()函数](https://legacy.cplusplus.com/reference/stack/stack/empty/)1.2.1.2.2 [size()函数](https://legacy.cplusplus.com/reference/stack/stack/size/) 1.2.1.3 stack对象的增删查改及访问1.2.1.3.1 [push()函数](https://legacy.cplusplus.com/reference/stack/stack/push/)1.2.1.3.2 [pop()函数](https://legacy.cplusplus.com/reference/stack/stack/pop/)1.2.1.3.3 [top()函数](https://legacy.cplusplus.com/reference/stack/stack/top/) 1.3 stack的模拟实现1.3.1 stack中 push 和 pop 的实现1.3.2 stack中 empty 、size 和 top 的实现1.3.3 stack 实现汇总及函数测试 二、queue的介绍和使用2.1 queue的介绍2.2 queue的使用2.2.1 [queue的构造函数](https://legacy.cplusplus.com/reference/queue/queue/queue/)2.2.2 queue对象的容量操作2.2.2.1 [empty()函数](https://legacy.cplusplus.com/reference/queue/queue/empty/)2.2.2.2 [size()函数](https://legacy.cplusplus.com/reference/queue/queue/size/) 2.2.3 queue对象的增删查改及访问2.2.3.1 [push()函数](https://legacy.cplusplus.com/reference/queue/queue/push/)2.2.3.2 [pop()函数](https://legacy.cplusplus.com/reference/queue/queue/pop/)2.2.3.3 [front()函数](https://legacy.cplusplus.com/reference/queue/queue/front/)2.2.3.4 [back()函数](https://legacy.cplusplus.com/reference/queue/queue/back/) 2.3 queue的模拟实现2.3.1 queue中 push 和 pop 的实现2.3.2 queue中 empty 和 size 的实现2.3.3 queue中 front 和 back 的实现2.3.4 queue 实现汇总及函数测试 三、priority_queue的介绍和使用3.1 priority_queue的介绍3.2 priority_queue的使用3.2.1 [priority_queue的构造函数](https://legacy.cplusplus.com/reference/queue/priority_queue/priority_queue/)3.2.2 priority_queue对象的容量操作3.2.2.1 [empty()函数](https://legacy.cplusplus.com/reference/queue/priority_queue/empty/)3.2.2.2 [size()函数](https://legacy.cplusplus.com/reference/queue/priority_queue/size/) 3.2.3 priority_queue对象的增删查改及访问3.2.3.1 [push()函数](https://legacy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7ef4dd1b72177a8e10896d2bb47a30c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee4ce0be4ce0b8e0e51ce29f5a239e81/" rel="bookmark">
			【C语言】——数据在内存中的存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【C语言】——数据在内存中的存储 一、整数在内存中的存储1.1、整数的存储方式1.2、大小端字节序（1）大小端字节序的定义（2）判断大小端 1.3、整型练习 二、浮点数在内存中的存储2.1、引言2.2、浮点数的存储规则2.3、浮点数的存储过程2.4、题目解析 一、整数在内存中的存储 1.1、整数的存储方式 我们知道，整形分为有符号整形和无符号整形。对于无符号整型来说，他所有位均为数值位；而有符号整形，他的最高位代表符号位，其余位为数值位，符号位用0表示正，1表示负。
注： c h a r char char类型虽然是存储字符，但本质是存其ASCII值，因此也可以看作是整形。
注：有符号和无符号只针对整型，不包括浮点型等
在【C语言】——详原解操作符（上）中，我曾提到，整数在内存中的存储有三种方式：原码、反码、补码。下面，让我们简单回顾一下。
原码：直接将数值按他的正负数形式翻译成二进制得到的就是原码反码：源码的符号位不变，数值位按位取反即为反码补码：将反码加一，得到的就是补码 在内存中，整数的存储和运算都是以补码的形式，只有显示给用户时，才是原码的形式。
为什么呢？
在计算机系统中，数值一律用补码来表示和存储。
原因在于：使用补码，可以将数值位和符号位统一进行处理
同时，加法和减法也可以统一进行处理（CPU只有加法器），此外，源码和补码相互转换，其运算过程是相同的（两者转换都是取反，加一），不需要额外的硬件电路。
1.2、大小端字节序 （1）大小端字节序的定义 不知大家在平时调试代码时，大家有没有发现一个奇怪的现象：整型在内存中好像是倒着存的。
如图：
上图显示的是整型变量 a a a 在内存中的存储情况，按我们的习惯不应该是：00 00 00 01 吗？为什么是 01 00 00 00 呢？
上面这种存储方式叫小端字节序存储
首先，我们来看看什么是大小端。
在内存中，数据是以内存为单位进行存储的，那么，超过一个字节大小的数据的存储就不可避免的涉及到存储顺序问题，按照不同的存储顺序，我们分为大端字节序存储和小端字节序存储，下面是具体概念。
小端字节序存储：指数据的低位字节内容保存在内存中的低地址处，而数据的高字节内容保存在内存的高地址处。大端字节序存储：指数据的高位字节内容保存在内存的低地址处，而数据的低字节内容保存在内存的高地址处。 数据是大端还是小端存储并不由编译器决定，而是取决于硬件设备。
为什么会分大小端呢？
这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8 个 b i t bit bit 位，但是在 C语言 中除了 8 b i t bit bit 的 c h a r char char 之外，还有 16 b i t bit bit 的 s h o r t short short
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee4ce0be4ce0b8e0e51ce29f5a239e81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7832b7e91dad8f709eecf8bf8bc54c5b/" rel="bookmark">
			Java 【数据结构】 优先级队列（PriorityQueue）和堆（Heap）【神装】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		登神长阶
第六神装 优先级队列 PriorityQueue
第七神装 堆 Heap 目录
📔一.认识优先级队列（PriorityQueue）
📕1.概念
📖2.特点
📗二.认识堆（Heap） 📘1.概念
📙2.特点 📚三.优先级队列的模拟实现
📓1.堆的创建
📒2.建堆的时间复杂度
📃3.堆的插入和删除
📜3.1插入
📄 3.2删除
📰四.PriorityQueue接口介绍
🗞️1.基本使用
📑2.注意事项
🔖五.总结与反思
📔一.认识优先级队列（PriorityQueue） 📕1.概念 前面介绍过队列，在 Java 中，队列（Queue）是一种先进先出（FIFO）的数据结构，用于存储元素。队列在 java.util 包中有多种实现，如 LinkedList、ArrayDeque 和 PriorityQueue。只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先进先出FIFO(First In First Out) 入队列：进行插入操作的一端称为队尾（Tail/Rear） 出队列：进行删除操作的一端称为队头（Head/Front）
Java中的优先级队列（PriorityQueue）是一种数据结构，它基于优先级的概念来确定元素的顺序。在优先级队列中，元素按照优先级被逐个访问和处理，具有较高优先级的元素会被优先处理。
📖2.特点 元素的排序： 优先级队列中的元素根据其优先级进行排序。具体来说，元素必须是可比较的，或者队列需要根据给定的比较器来确定优先级。
内部实现： Java中的优先级队列通常使用堆（heap）来实现。堆是一种特殊的树形数据结构，这也是本篇博客把二者放在一起的原因，下文会做详细介绍。
插入和删除操作： 优先级队列支持插入和删除操作。插入操作将元素插入到队列中，并根据其优先级进行调整；删除操作移除并返回队列中优先级最高的元素。
访问操作： 优先级队列通常支持访问具有最高优先级的元素，但不一定支持随机访问其他元素。在Java中，可以使用 peek() 方法来访问队首元素，该方法返回队列中优先级最高的元素但不移除它。
线程安全性： Java中的优先级队列实现通常不是线程安全的。如果需要在多线程环境中使用优先级队列，可以考虑使用 PriorityBlockingQueue 类，它是 BlockingQueue 接口的一个实现，提供了线程安全的优先级队列功能。
综上所述，Java中的优先级队列是一种重要的数据结构，适用于需要按照优先级处理元素的场景，例如任务调度、事件处理等。
📗二.认识堆（Heap） 📘1.概念 Java中的堆（Heap）是一种特殊的树形数据结构，如果有一个关键码的集合K = {k0，k1， k2，…，kn-1}，把它的所有元素按完全二叉树的顺序存储方式存储 在一个一维数组中，并满足：Ki &lt;= K2i+1 且 Ki&lt;= K2i+2 (Ki &gt;= K2i+1 且 Ki &gt;= K2i+2) i = 0，1，2…，则称为小堆(或大堆)。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。 📙2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7832b7e91dad8f709eecf8bf8bc54c5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5d8d86037268a0903884e16f998e51b/" rel="bookmark">
			【MySQL精炼宝库】深度解析索引 | 事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、索引
1.1 索引(index)概念：
1.2 索引的作用：
1.3 索引的缺点：
1.4 索引的使用场景：
1.5 索引的使用：
1.6 面试题:索引底层的数据结构（核心内容）：
1.7 索引列查询(主键 | 非主键)过程：
二、事务
2.1 事务的概念：
2.2 事务操作：
2.3 面试题:事务的基本特性：
2.4 MySQL事务的隔离性：
一、索引 1.1 索引(index)概念： 索引是一种特殊的文件，包含着对数据表里所有记录的引用指针。可以对表中的一列或多列创建索引， 并指定索引的类型，各类索引有各自的数据结构实现。
注意：数组下标，目录，索引这三个是不同的术语，虽然它们的英文都是 index 但是表示的含义各不相同，希望友友们不要混淆。
本文章主要讲解MySQL中的索引及事务。
1.2 索引的作用： • 数据库中的表、数据、索引之间的关系，类似于书架上的图书、书籍内容和书籍目录的关系。
• 索引所起的作用类似书籍目录，可用于快速定位、检索数据。 • 索引对于提高数据库的性能有很大的帮助。
1.3 索引的缺点： 主要体现在下面两点：
• 索引本身要占据存储空间。
• 索引能提高查询速度，但是可能会拖慢增删改的速度（对数据进行增删改都是要同步更新索引的）。
1.4 索引的使用场景： 要考虑对数据库表的某列或某几列创建索引，需要考虑以下几点：
• 数据量较大，且经常对这些列进行条件查询（索引是用在条件查询的时候）。
• 该数据库表的插入操作，及对这些列的修改操作频率较低。 • 索引会占用额外的磁盘空间。
满足以上条件时，考虑对表中的这些字段创建索引，以提高查询效率。
相反，如果非条件查询列，或经常做插入、修改操作，或磁盘空间不足时，不考虑创建索引。
1.5 索引的使用： 创建主键约束（PRIMARY KEY）、唯一约束（UNIQUE）、外键约束（FOREIGN KEY）时，会自动创建对应列的索引。
例如下图：只需关注画红框的这几个即可，至于如何查看表中的索引，后续马上讲到。
通过sql我们能够创建索引，查看索引，删除索引。 • 查看索引
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5d8d86037268a0903884e16f998e51b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb13bfbafd743c78ec94d5539a889616/" rel="bookmark">
			python烟花代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python中，可以使用多种方式来模拟烟花效果，其中一种常见的方法是使用turtle图形库来绘制。以下是一个简单的示例，展示了如何使用turtle来创建一个烟花效果的动画：
import turtle import random # 设置屏幕和背景 screen = turtle.Screen() screen.bgcolor("black") # 创建烟花的绘制函数 def draw_firework(size, colors): for _ in range(5): # 绘制五次烟花 color = random.choice(colors) turtle.color(color) turtle.pensize(size) turtle.forward(200) turtle.right(144) turtle.right(90) turtle.forward(100) turtle.left(90) # 定义烟花的颜色 colors = ["red", "orange", "yellow", "green", "blue", "purple", "white"] # 随机选择烟花的大小和颜色 random_size = random.randint(10, 50) random_color = random.choice(colors) # 隐藏turtle并开始绘制烟花 turtle.tracer(0, 0) turtle.up() turtle.goto(0, -150) turtle.down() draw_firework(random_size, colors) # 隐藏绘制的turtle turtle.hideturtle() # 完成绘制后更新屏幕 screen.update() # 保持窗口打开直到用户关闭 screen.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb13bfbafd743c78ec94d5539a889616/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cf8f0023e5cfd9c47f4a4a541c3e92e/" rel="bookmark">
			Java项目：基于SSM框架实现的学院党员管理系统高校党员管理系统（ssm&#43;B/S架构&#43;源码&#43;数据库&#43;毕业论文&#43;开题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目简介
本项目是一套基于SSM框架实现的学院党员管理系统
包含：项目源码、数据库脚本等，该项目附带全部源码可作为毕设使用。
项目都经过严格调试，eclipse或者idea 确保可以运行！
该系统功能完善、界面美观、操作简单、功能齐全、管理便捷，具有很高的实际应用价值
二、技术实现
jdk版本：1.8 及以上
ide工具：IDEA或者eclipse
数据库: mysql5.5及以上
后端：spring+springmvc+mybatis+mysql
前端：JSP、css、jquery
三、系统功能
系统用户包括有管理员、党员、支部。
主要功能如下：
用户登录
主页
个人中心
修改密码
个人信息
党员管理
党员列表
党费登记
奖惩记录
支部管理
支部信息
基层单位
支部荣誉
支部日志管理
支部日志列表
公告管理等功能
四、页面功能 五、论文 六、数据库 一共11张表
七、源码地址 https://download.csdn.net/download/weixin_43860634/89248969
需要远程部署的同学，可以加下面的联系方式哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/706b4c89de4ff7ad6aa16f0db9040853/" rel="bookmark">
			Mac 版 安装NVM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 优质博文IT-BLOG-CN
NVM（Node Version Manager）是一个用于管理多个Node.js版本的工具。它允许开发者在同一台机器上安装和切换不同版本的Node.js，以便在不同的项目中使用不同的Node.js版本。macOS用户可以使用homebrew来安装NVM。
一、安装homebrew 在命令行之行如下代码：根据提示输入回车键即可。
/bin/bash -c "$(curl -fsSL https:/raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" 二、删除现有Node版本 如果系统之前安装了node，需要先卸载。如果还没有安装就跳过。
brew uninstall --ignore-dependencies node brew uninstall --force node 三、安装NVM 【1】更新Homebrew软件包列表并安装NVM。
brew update brew install nvm 如果出现zsh: command not found: brew错误，解决方案
【2】在home目录中为NVM创建一个文件夹。
mkdir ~/.nvm 【3】在.bash_profile文件中配置所需的环境变量。
vim ~/.bash_profile 【4】在 ~/.bash_profile（或~/.zshrc，用于macOS Catalina或更高版本）中添加如下配置。
export NVM_DIR=~/.nvm source $(brew --prefix nvm)/nvm.sh 【5】修改完配置后需要执行自动加载命令才能生效。
source ~/.bash_profile 四、安装Node.js 【1】查看可用的版本
nvm ls-remote 【2】可以使用别名，如node代表最新版本，lts代表最新的LTS版本，或者直接输入版本号等；
nvm install node ## 安装最后一个长期支持版本 nvm install 22 【3】检验node.js是否安装成功
nvm ls 【4】当然如果你安装了多个版本，可以在任何时候将任何版本设置为默认版本。
nvm use 22 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de0abe7099fecfb77aabcd64f32ea2dd/" rel="bookmark">
			【数据结构】顺序表专题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
本篇文章我们来进行有关顺序表的专题训练，让我们一起来看一下有关顺序表的算法题
💓 个人主页：小张同学zkf
⏩ 文章专栏：数据结构
📝若有问题 评论区见
🎉欢迎大家点赞👍收藏⭐文章
1.移除元素 这道题看似简单，但我们不要忘了其中有个条件限制，空间复杂度O（1），所以做这道题时，我们不能创一个新的空间，否则空间复杂度过大与题不符。
所以我们最容易想到的第一种解法，创建新的数组，遍历原数组的思路就不行了
既然不能创建新的空间，那我们就只能在原数组内更改，这里我们有第二种思路，双指针法，创建两个指针，两个指针刚开始同时指向这个数组的首元素，一个指针用来在顺序表上遍历，若与要删除目标相等则继续往后遍历，若与要删除目标不相等，则将现在所指向的值直接赋值与另一个指针指向处，然后俩指针同时向后走，重复这个过程直到指向空，最后那个没指向空的指针就是要返回的长度
代码如下
有些人在这可能有些疑惑，说指针也没用指针呀，其实数组的下标性访问，就是指针访问嘛，一个思路嘛。 2. 合并两个有序数组 第一种思路我们很容易想到的直接冒泡排序，但这个效率太低了，时间复杂度高
我们第二种思路三指针法，需要用到三个指针，l1指向下标为m处，l3指向下表为n+m-1处,l2指向第二个数组的最后一个元素处。然后l1和l2比较谁大放l3处，小的那个指针与l3向前移，重复这个过程直到l1都指向初始位置，或l2指向初始位置。
这里或许有人疑问了为什么是从后往前比较，而不是从前往后比较，我们仔细想一下若从前往后比较我们很有可能把原值覆盖，但从后往前比较就不会出现覆盖情况
这里结果就有两种情况，若l2先出循环正好有序，而且l2和l1已完全合并成一个数组，但若l1先出循环，l2还有数据没放到l1中，这里直接让l2剩余部分直接尾插到l1中就行了。 代码如下： 结束语 本篇博客列举了两道有关顺序表的算法题，算是两道经典题了，若有什么问题，可以在评论区交流，下片博客我们继续对链表专题进行补充
OK，感谢观看！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfa2cdd6c9f713259db411ddd4dc0c3e/" rel="bookmark">
			【JAVA】javadoc，如何生成标准的JAVA API文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.什么是JAVA DOC
2.标签
3.命令
1.什么是JAVA DOC 当我们写完JAVA代码，别人要调用我们的代码的时候要是没有API文档是很痛苦的，只能跟进源码去一个个的看，一个个方法的猜，并且JAVA本来就不是一个重复造轮子的游戏，一般一些常用的轮子早就已经早好了，直接拿来用就是。但是拿来用的时候往往由于API文档的缺失或者不规范，造成使用上的很多痛苦，大家在很多实际工作中经常也会遇到类似的场景：
公司多年累积下来的工具类或者提供底层能力的公共模块里面积累了很多能力，公司为了代码规范也要求我们尽量去调用这些工具类或者公共模块。但是：
没有API文档或者文档写的很烂
参数列表动不动就很长，数十个甚至几十个参数
参数列表没有注释，出现一些莫名其妙的参数，都不知道怎么传
方法名也不能见名知意
造成往往要用这些公共能力的时候甚至还要去读源码
有读源码这个时间，可能自己都重新写了一个了，而且自己写的，可能比祖传下来的那些工具类还更“清爽”一些。于是系统内越来越多工具类堆积，重复造的轮子越来越多，“屎山”越堆越高。
即使有时候我们有API文档，但是各类API文档，格式，内容都不相同，没有统一的规范，读起来其实也很慢。所以有没有一个统一的规范喃？JAVA官方其实早就想到了这个问题，在JDK1.1发布的时候就附带了JAVA DOC，支持用标签注释的方式给各个方法做好规范的说明，然后用JAVA命令一键生成可视化的HTML页面作为API。
2.标签 标签是JAVA DOC的核心，用什么标签，JAVA DOC最后就会对应生成哪些API文档内容：
@author:
/** * @author John Doe */ public class MyClass { } @version:
/** * @version 1.0.1 */ public class MyClass { } @param:
/** * Concatenates two strings. * @param string1 The first string to concatenate. * @param string2 The second string to concatenate. * @return The concatenated string.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfa2cdd6c9f713259db411ddd4dc0c3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d960ec7509814bf4e491c00c274af679/" rel="bookmark">
			搭建和配置Stable Diffusion环境，超详细的本地部署教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跃然纸上的创意、瞬息万变的想象，Stable Diffusion以AI的力量赋予您无限创作可能。在这篇详尽的本地部署教程中，我们将携手走进Stable Diffusion的世界，从零开始，一步步搭建和配置这个强大的深度学习环境。无论您是热衷于探索AI艺术的新手，还是追求技术创新的专业人士，本教程都将助您轻松掌握如何在个人电脑上实现Stable Diffusion模型的本地化运行。接下来的内容将细致入微地引导您完成环境安装、依赖配置、资源优化以及启动服务等关键步骤，让您在享受高效稳定的同时，也能充分释放想象力，畅游AI绘画的无垠天地！
1.安装显卡驱动程序 确认电脑已经安装最新版的显卡驱动程序。
1.1 NVIDIA GeForce 显卡驱动程序安装： 建议使用GeForce Experience工具：
下载与安装：访问NVIDIA官方网站（https://www.nvidia.com/zh-cn/geforce/geforce-experience/），下载并安装GeForce Experience软件。
运行与登录：打开GeForce Experience，按照提示进行注册或登录账户。
自动更新驱动：该软件会自动检测你的NVIDIA显卡型号，并提供最新版的驱动程序。只需点击“驱动程序”选项卡下的“更新”按钮，程序将自动下载并安装最新版本的驱动以及CUDA Toolkit（如果系统配置允许且需要CUDA支持的话）。
手动安装驱动：
查找驱动：直接访问NVIDIA驱动下载页面（https://www.nvidia.cn/Download/index.aspx），输入你的显卡型号和操作系统信息来找到匹配的驱动程序。下载与安装：下载适合的驱动程序后，双击运行安装文件，按照向导指示完成安装过程。 1.2 AMD Radeon 显卡驱动程序安装： 驱动自动检测与安装：
访问AMD官方网站（https://www.amd.com/zh-hans/support），点击顶部菜单中的“驱动与支持”链接。允许网站自动检测你的AMD显卡型号，或者手动选择显卡型号和操作系统版本。下载AMD提供的专用驱动安装工具，它通常可以智能识别硬件并安装合适的驱动程序。 手动选择与安装：
如果您想手动选择驱动，可在上述页面中根据显卡型号和系统信息下载相应的驱动程序安装包，然后执行安装文件以安装最新驱动。 1.3 Intel Arc 显卡驱动程序安装： 下载WHQL认证驱动：
进入Intel官方支持网站，找到针对Intel Arc系列独立显卡的WHQL认证驱动程序页面。 WHQL认证驱动下载www.intel.com.tw/content/www/tw/zh/download-center/home.html
根据显卡的具体型号以及电脑的操作系统版本，下载经过微软Windows Hardware Quality Labs测试认证的稳定驱动程序。 安装驱动程序：
下载完成后，运行下载好的驱动安装程序，按照屏幕上的提示逐步进行安装操作。 2. 安装Git（Windows系统） 2.1 下载Git 打开浏览器，访问Git官方网站：https://git-scm.com/downloads根据你的Windows版本选择合适的安装包（通常选择“64-bit Git for Windows Setup”）。 2.2 开始安装： 双击下载好的安装文件（如 Git-*.exe），启动安装向导。在安装过程中，可以选择自定义安装路径，推荐预留足够的磁盘空间。在“Choosing the default editor used by Git”部分，可以选择你常用的文本编辑器作为默认编辑器。注意选项“Adjusting your PATH environment”，通常选择“Use Git from the Windows Command Prompt”或“Use Git and optional Unix tools from the Windows Command Prompt”，以便在命令行中直接使用Git命令。检查是否勾选了创建桌面快捷方式或者添加到PATH环境变量等选项，根据个人需求配置。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d960ec7509814bf4e491c00c274af679/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b347a6b140a07db68c8a51769e72e36c/" rel="bookmark">
			C# Web控件与数据感应之 CheckBoxList 类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
关于数据感应
CheckBoxList 类
范例运行环境
数据源表设计
角色字典表
用户角色表
AutoValueDBList 方法
原理
设计
实现
调用示例
初始化数据
启动查询模式
使用保存模式
小结
关于数据感应 数据感应也即数据捆绑，是一种动态的，Web控件与数据源之间的交互，本文将继续介绍与数据库提取数据并捆绑到 CheckBoxList 类控件为例，另外同时将控件的值保存回数据库的通用方法。
CheckBoxList 类 System.Web.UI.WebControls.CheckBoxList 类是提供了一组可复选的选项集合，每个选项以true或false 表示其选中状态。其使用方法基于 ListControl 类。
更多 CheckBoxList 类的介绍请参照如下链接：
https://learn.microsoft.com/zh-cn/previous-versions/visualstudio/design-tools/expression-studio-2/cc294907(v=expression.10)
范例运行环境 操作系统： Windows Server 2019 DataCenter
.net版本： .netFramework4.7.1 或以上
开发工具：VS2019 C#
数据提取：在这里我们以MS SQL Server 2016为例
数据源表设计 我们假设要为用户添加角色权限，则需要涉及两个表：
角色字典表 表（sys_chars）用于列出可用的角色，其结构如下：
序号字段名类型说明备注1ciduniqueidentifier唯一ID用于后续方法使用2charnamenvarchar(30)角色名称 其数据示例如下：
用户角色表 表（sys_UserChars）用于存储用户的可用角色（用户ID+角色ID 唯一），其结构如下：
序号字段名类型说明备注1user_ciduniqueidentifier用户ID用户的ID值2char_ciduniqueidentifier角色名称用记所属的角色ID值 其示例数据如下：
AutoValueDBList 方法 原理 我们需要提取 sys_chars (角色字典表) 数据绑定到 CheckBoxList 控件上，用于显示可用的角色名称。绑定后通过 AutoValueDBList 方法的查询模式，从 sys_UserChars （用户角色表）提取数据并与 CheckBoxList 上的项进行比对，存在的则选中。同理，使用 AutoValueDBList 方法的保存模式，则将用户在 CheckBoxList 上的选项逐一保存到 sys_UserChars （用户角色表）里。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b347a6b140a07db68c8a51769e72e36c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bbedb0da69088cf38ec389048acc082/" rel="bookmark">
			AI大模型探索之路-训练篇8：大语言模型Transformer库-预训练流程编码体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列篇章💥 AI大模型探索之路-训练篇1：大语言模型微调基础认知
AI大模型探索之路-训练篇2：大语言模型预训练基础认知
AI大模型探索之路-训练篇3：大语言模型全景解读
AI大模型探索之路-训练篇4：大语言模型训练数据集概览
AI大模型探索之路-训练篇5：大语言模型预训练数据准备-词元化
AI大模型探索之路-训练篇6：大语言模型预训练数据准备-预处理
AI大模型探索之路-训练篇7：大语言模型Transformer库之HuggingFace介绍
目录 系列篇章💥前言案例场景准备工作1）学术加速2）安装LFS3）下载数据集(原始语料库)4）下载模型到本地 步骤1：导入相关依赖步骤2：获取数据集步骤3：构建数据集步骤4：划分数据集步骤5：创建DataLoader步骤6：创建模型及其优化器步骤7：训练与验证步骤8：模型预测总结 前言 在深入探索Transformer库及其高级组件之前，我们先手工编写一个预训练流程代码。这一过程不仅有助于理解预训练的步骤和复杂性，而且能让您体会到后续引入高级组件所带来的开发便利性。通过实践，我们将构建一个情感分类模型，该模型能够接收文本评价并预测其是正面还是负面的情感倾向。
案例场景 想象一下，我们有一个原始数据集，其中包含了酒店顾客的评价文本。我们的目标是训练一个模型，当输入类似“昨天我在酒店睡觉发现被子有一股霉味。”的评价时，模型能够预测出“差评”。
准备工作 本次仍是采用云服务器autodl调试运行
1）学术加速 source /etc/network_turbo 2）安装LFS 从 Hugging Face Hub 下载模型需要先安装Git LFS
安装git-lfs是为了确保从Hugging Face拉取模型时能够高效且完整地下载所有相关文件，尤其是那些大型的模型文件。
Ubuntu系统操作命令：
curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash
sudo apt-get install git-lfs
Centos命令参考：
curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.rpm.sh | sudo bash sudo yum install git-lfs 执行：git lfs install
3）下载数据集(原始语料库) 创建一个pretrains目录，将数据集下载到这个目录，下载到本地后可以提高执行效率
git clone https://huggingface.co/datasets/dirtycomputer/ChnSentiCorp_htl_all
注意！重要！！：下载后请记得和Huggingface上的文件对比，尤其是大文件，确保下载完整
4）下载模型到本地 git clone https://huggingface.co/hfl/rbt3
下载到本地后,从本地加载执行效率更高
注意！重要！！：下载后请记得和Huggingface上的文件对比，尤其是大文件，确保下载完整
步骤1：导入相关依赖 首先，我们需要设置Python环境，并导入必要的库
from transformers import AutoTokenizer, AutoModelForSequenceClassification 步骤2：获取数据集 获取数据集是预训练中关键一步。我们使用前面从Huggingface下载的包含酒店评价的文本数据集。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bbedb0da69088cf38ec389048acc082/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdf61e6a5333d37d05fa608ee7f8fa4e/" rel="bookmark">
			Spring boot &#43; dubbo 项目启动报错 ClassNotFoundException WebServerFactoryCustomizer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 背景 代码和包依赖等信息没做任何修改，之前项目启动没问题的，有一天项目在测试环境突然启动报错
了，生产环境可以正常启动。报错信息如下所示。
Caused by: java.lang.ClassNotFoundException: org.springframework.boot.web.server.WebServerFactoryCustomizer at java.net.URLClassLoader.findClass(URLClassLoader.java:381) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:338) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) 2 原因分析和问题解决 可能原因是该项目部署时加载到的间接依赖包有变化导致的。
通过对比测试环境和生产环境项目的安装包里面加载的依赖包，找到差异。如果测试环境多出了一
些包，则排除测试环境多余的包即可（依次排除多余的包，直到项目正常启动为止）。
具体步骤为：
（1）下载测试环境和生产环境的项目安装包（jar包等）；
（2）直接解压安装包，对比 解压文件中“\BOOT-INF\lib” 里的依赖包的差异；
（3）在idea添加 "Maven Helper"插件，通过该插件快速找到测试环境多出的包所在的项目直接依
赖包位置，并在直接依赖包中排除此多出的包。
3 扩展 在项目中引入其他包时，尽量使用 &lt;exclusions&gt; 排除间接依赖其他的包，以免后续出现包冲突或
其他异常问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02f1757e1fb8253b3c2a88350a946901/" rel="bookmark">
			Java的逻辑控制和方法的使用介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 程序的逻辑结构一共有三种：顺序结构、分支结构和循环结构。顺序结构就是按代码的顺序来执行相应的指令。这里主要讲述Java的分支结构和循环结构，由于和C语言是有相似性的，所以这里只会提及不同点和注意要点~~
注意在C语言中，非0表示真，0表示假，所以条件判断我们常常使用表达式的结果作为真假，但是在Java中我们只能使用布尔表达式来作为条件判断！！！
分支结构 if 我们要注意只能使用布尔表达式来进行条件判断，其余和C语言是一样的，大家来看一下代码案例就可以了：
public class Test { public static void main(String[] args){ int a = 10; if(a &gt; 10){ System.out.println("a &gt; 10"); } else if(a == 10){ System.out.println("a = 10"); }else{ System.out.println("a &lt; 10"); } } } 这里要注意悬垂else，else 总是和最近的 if 语句进行匹配的！！！
int x = 10; int y = 10; if (x == 10) if (y == 10) System.out.println("aaa"); else System.out.println("bbb"); 像这个代码，else 是和 if(y == 10)进行匹配的~~
switch switch的括号内只能是以下类型的表达式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02f1757e1fb8253b3c2a88350a946901/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/27/">«</a>
	<span class="pagination__item pagination__item--current">28/71</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/29/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>