<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4bce75ad38bb289079fa4918e94fe7e/" rel="bookmark">
			【AIGC】揭秘驱动AI创新的关键力量：领军者的角色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 🍓一、引言🍒二、AIGC的使命和价值观🌽 1.使命🐯2.价值观 🌳三、AIGC的核心技术驱动力🌴1.算法创新🦊2.数据驱动🌵3.开放合作 🌹四、AIGC的应用场景☘️1.智慧城市🎋2.金融服务🧬3.医疗健康⛱️4.智能制造 🎲五、AIGC的未来展望✏️1.技术创新🔮2.应用拓展🦁3.社会责任 🦊六、结语 🍓一、引言 人工智能（AI）正日益成为现代科技和社会发展的关键推动力。在这个充满机遇和挑战的时代，AIGC作为领先的人工智能公司，不仅致力于持续的技术创新，还积极推动AI的应用落地，为各行各业带来巨大的变革。本文将深入探讨AIGC作为人工智能领域的领军者，如何通过其创新的技术和应用场景，引领着人工智能的未来。
🍒二、AIGC的使命和价值观 🌽 1.使命 AIGC的使命是通过创新的人工智能技术，推动社会进步和人类福祉。他们相信人工智能的力量可以改善人们的生活，解决社会面临的重大问题，并创造出更加智能、高效和可持续发展的未来。
🐯2.价值观 AIGC坚持以客户为中心，始终保持创新进取的精神，并注重团队合作和合规经营。他们尊重每个团队成员的独特贡献，鼓励思想的多样性和开放的沟通。同时，他们秉承诚信、责任和可持续发展的价值观，致力于构建一个更加公正、开放和繁荣的社会。
🌳三、AIGC的核心技术驱动力 🌴1.算法创新 AIGC的核心技术是基于算法创新的。他们拥有一支由顶尖的算法专家和研究人员组成的团队，致力于推动人工智能算法的发展。他们在深度学习、强化学习、自然语言处理等领域取得了突破性的研究成果，并将这些成果应用于各个行业，不断提升人工智能技术的水平和效果。
🦊2.数据驱动 AIGC充分利用海量的数据资源，通过数据分析和挖掘，为算法的训练和优化提供强有力的支持。他们深知数据的重要性，通过对数据的深入理解和挖掘，能够为客户提供更准确、高效的解决方案。
🌵3.开放合作 AIGC积极开展与学术界、企业和政府的合作，倡导开放的科研环境和创新生态。他们与全球顶尖的研究机构和高校合作，共同推动人工智能技术的发展。同时，他们也与各行业的企业进行合作，共同探索人工智能在不同领域的应用，实现互利共赢。
🌹四、AIGC的应用场景 AIGC的人工智能技术已经在多个领域实现了成功应用，其中包括但不限于以下几个方面：
☘️1.智慧城市 AIGC的人工智能技术可以对城市中的大数据进行实时分析，帮助城市管理者更好地了解城市运行状态，优化交通流量、改善能源利用效率，提升城市的宜居性和可持续发展水平。
🎋2.金融服务 AIGC的人工智能技术可以应用于金融领域，帮助银行、证券公司等机构进行风险评估、投资决策和客户服务等方面的工作。通过对大量金融数据的分析和挖掘，可以提高金融机构的运营效率和风险管理水平。
🧬3.医疗健康 AIGC的人工智能技术在医疗健康领域具有广阔的应用前景。例如，基于深度学习算法的医疗影像分析系统可以辅助医生进行疾病诊断和治疗方案制定，提高医疗效果和患者生存率；又如，在健康管理方面，AIGC的人工智能技术可以根据用户的健康数据和生活习惯，提供个性化的健康管理方案，帮助人们更好地管理和改善自己的健康状况。
⛱️4.智能制造 AIGC的人工智能技术可以在制造业中实现智能化生产。通过对生产数据的实时分析和挖掘，可以实现生产过程的优化和智能调度，提高生产效率和产品质量。同时，AIGC的人工智能技术还可以应用于机器人领域，实现机器人的自主学习和智能操作，推动智能制造的发展。
🎲五、AIGC的未来展望 AIGC作为领先的人工智能公司，将继续致力于技术创新和应用推广，为人工智能的未来发展贡献力量。
✏️1.技术创新 AIGC将继续投入大量资源进行算法研究和技术创新，不断提高人工智能技术的水平和应用效果。他们将关注当前的技术热点和挑战，积极探索新的算法和方法，推动人工智能技术的突破。
🔮2.应用拓展 AIGC将加强与各行各业的合作，积极推动人工智能在更多领域的应用落地。他们将与合作伙伴共同探索人工智能在教育、文化、农业等领域的应用，为各行各业带来更多的创新和变革。
🦁3.社会责任 AIGC将始终秉持社会责任感，关注人工智能的伦理和法律问题，推动人工智能的可持续发展和社会价值的最大化。他们将积极参与相关的政策制定和社会讨论，促进人工智能发展与社会的和谐共存。
🦊六、结语 作为人工智能领域的领军者，AIGC以其创新的技术和应用场景，为推动人工智能的发展和社会进步做出了重要贡献。在未来，AIGC将继续引领人工智能的创新浪潮，为我们带来更加智能、高效和可持续的世界。让我们期待AIGC带来的人工智能的未来，让我们共同迎接人工智能的新篇章！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c660e4375cd752260df752248124b9d5/" rel="bookmark">
			15：00面试，15：08就出来了，问的问题有点变态。。。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从小厂出来，没想到在另一家公司又寄了。
到这家公司开始上班，加班是每天必不可少的，看在钱给的比较多的份上，就不太计较了。没想到8月一纸通知，所有人不准加班，加班费不仅没有了，薪资还要降40%,这下搞的饭都吃不起了。
还在有个朋友内推我去了一家互联网公司，兴冲冲见面试官，没想到一道题把我给问死了：
如果模块请求http改为了https,测试方案应该如何制定，修改?
感觉好简单的题，硬是没有答出来，早知道好好看看一大佬软件测试面试宝典了。
通过大数据总结发现，其实软件测试岗的面试都是差不多的。常问的有下面这几块知识点：
全网首发-涵盖16个技术栈 第一部分，测试理论（测试基础+需求分析+测试模型+测试计划+测试策略+测试案例等等）
第二部分，Linux（ Linux基础+Linux练习题）
第三部分，MySQL（基础知识+查询练习+万年学生表经典面试题汇总+数据库企业真题）
第四部分，Web测试
第五部分，API测试
第六部分，App测试
第七部分，管理工具
第八部分，Python基础（Python基础+编程题+集合+函数+Python特性等等）
第九部分，Selenium相关
第十部分，性能测试
第十一部分，LordRunner相关
第十二部分，计算机网络
第十三部分，组成原理
第十四部分，数据结构与算法
第十五部分，逻辑题
第十六部分，人力资源
软件测试基础 软件测试的步骤是什么?如何录制测试脚本?应该考虑进行如何测试的测试方法怎样估计测试工作量?测试设计的问题当测试过程发生错误时，有哪几种解决办法?测试执行的问题测试评估的目标如何提高测试?C/S模式的优点和缺点B/S模式的优点和缺点… Linux grep和find的区别? grep 都有哪些用法?
查看IP地址?
创建和删除一个多级目录?
在当前用户家目录中查找haha.txt文件?
如何查询出tomcat的进程并杀掉这个进程，写出linux命令?
动态查看日志文件?
查看系統硬盘空间的命令?
查看当前机器listen 的所有端口?
…
Python 统计python源代码文件中代码行数，去除注释，空行，进行输出?
python调用cmd并返回结果?
冒泡排序
1,2,3,4 这4个数字，能组成多少个互不相同的且无重复的三位数，都是多少?
请用 python 打印出 10000 以内的对称数（对称数特点：数字左右对称，如：1,2,11,121,1221 等）
给定一个整数 N，和一个 0-9 的数 K，要求返回 0-N 中数字 K 出现的次数
判断 101-200 之间有多少个素数，并输出所有的素数
一个输入三角形的函数，输入后输出是否能组成三角形，三角形类型，请用等价类- 划分法设计测试用例
…
MySQL 你用的Mysql是哪个引擎，各引擎之间有什么区别?
如何对查询命令进行优化?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c660e4375cd752260df752248124b9d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df0cb847099081296b9a856835e8b535/" rel="bookmark">
			python 庆余年2收视率数据分析与可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了对《庆余年2》的收视率进行数据分析与可视化，我们首先需要假设有一组收视率数据。由于实际数据可能无法直接获取，这里我们将使用模拟数据来演示整个过程。
以下是一个简单的步骤，展示如何使用Python（特别是pandas和matplotlib库）来分析和可视化收视率数据：
导入必要的库
python
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
生成模拟数据
假设我们有每天的收视率数据：
python
生成模拟数据 dates = pd.date_range(start=‘2023-01-01’, periods=30, freq=‘D’) # 假设从2023年1月1日开始，持续30天
ratings = np.random.rand(30) * 10 + 5 # 随机生成收视率，范围在5-15之间
创建DataFrame df = pd.DataFrame({‘Date’: dates, ‘Rating’: ratings})
df.set_index(‘Date’, inplace=True)
数据分析
分析收视率的一些基本统计信息：
python
print(df.describe())
数据可视化
使用matplotlib绘制收视率随时间变化的折线图：
python
plt.figure(figsize=(12, 6))
plt.plot(df.index, df[‘Rating’], marker=‘o’)
plt.title(‘《庆余年2》收视率变化’)
plt.xlabel(‘日期’)
plt.ylabel(‘收视率’)
plt.grid(True)
plt.show()
（可选）进一步分析
你可以计算收视率的移动平均线，以查看收视率的长期趋势。
你可以检查收视率的相关性，例如与广告量、其他电视剧的收视率等。
你可以使用seaborn等更高级的库来创建更复杂的可视化。
保存结果
如果你希望保存你的可视化结果，可以使用plt.savefig()函数。
请注意，以上只是一个简单的示例，用于演示如何使用Python进行收视率数据的分析和可视化。在实际应用中，你可能需要处理更复杂和庞大的数据集，并使用更高级的技术和工具。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/004517aca0732bad9a996d7035862afd/" rel="bookmark">
			Django--ApiView示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 代码示例 from django.contrib.auth.models import User from rest_framework import serializers from rest_framework.views import APIView from rest_framework.response import Response from rest_framework import status from .models import BookInfo class BookInfoModelSerializer(serializers.ModelSerializer): class Meta: model = BookInfo fields = '__all__' class BookListView(APIView): def get(self, request): books = BookInfo.objects.all() serializer = BookInfoModelSerializer(books, many=True) return Response(serializer.data) def post(self, request): serializer = BookInfoModelSerializer(data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data, status=status.HTTP_201_CREATED) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) class BookDetailView(APIView): def get(self, request, pk): try: book = BookInfo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/004517aca0732bad9a996d7035862afd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8945dd982beebd078add2c6140cb0dc0/" rel="bookmark">
			深度解析 Spring 源码：揭秘JDK动态代理的奥秘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、JDK动态代理简介1.1 JDK 动态代理的基本原理和使用场景1.2 Spring 如何利用动态代理实现 AOP 二、探究 Spring 中的动态代理实现2.1 深入 JdkDynamicAopProxy 类2.1.1 JdkDynamicAopProxy 类结构2.1.2 getProxy 方法的实现2.1.3 determineClassLoader 方法的实现2.1.4 newProxyInstance 方法的实现 2.2 理解 InvocationHandler 接口2.2.1 InvocationHandler 在 Spring 中的角色和使用方式2.2.2 invoke 方法的作用 2.3 解析拦截器链的处理2.3.1 深入研究 AopProxyChain 对象的构建和作用2.3.2 探讨拦截器链在 Spring AOP 中的执行顺序和机制 三、实践与应用通过对 Spring 源码的解析，学习如何编写自定义的 AOP 拦截器 一、JDK动态代理简介 1.1 JDK 动态代理的基本原理和使用场景 JDK动态代理是Java语言提供的一种实现动态代理的方式，其基本原理是利用反射机制在运行时动态生成代理类和代理对象。
基本原理：
接口定义：定义一个接口（或者是一组接口），用于描述需要被代理的行为。InvocationHandler接口：编写一个实现了InvocationHandler接口的类，该类负责实际的代理逻辑。InvocationHandler接口只有一个方法invoke(Object proxy, Method method, Object[] args)，当代理对象的方法被调用时，invoke方法会被调用，并在其中执行代理逻辑。Proxy类：使用Proxy类的newProxyInstance方法动态地创建代理对象。newProxyInstance方法接受三个参数：ClassLoader、一个接口数组和一个InvocationHandler对象。在运行时，Proxy类会动态生成一个实现了指定接口的代理类，并通过传入的InvocationHandler对象来调用实际的代理逻辑。代理对象调用：当调用代理对象的方法时，实际上是调用了InvocationHandler接口的invoke方法，该方法会根据被调用的方法和传入的参数执行相应的代理逻辑。 使用场景：
日志记录：通过代理可以在方法执行前后记录日志，实现日志记录的功能。性能监控：可以在方法执行前后记录方法的执行时间，从而进行性能监控。事务管理：在方法执行前后开启和提交事务，实现事务管理的功能。权限控制：在方法执行前进行权限验证，实现权限控制的功能。远程调用：可以通过代理在调用远程对象的方法时添加网络通信的逻辑，实现远程调用的功能。 1.2 Spring 如何利用动态代理实现 AOP Spring AOP的实现基于代理模式和装饰器模式，在目标方法执行前后或异常抛出时，通过代理对象来执行额外的逻辑，如日志记录、事务管理、权限控制等。通过配置切面和通知，可以将这些额外逻辑统一地应用到多个目标类的方法中，从而实现横切关注点的分离和复用。
在Spring AOP中，主要利用了JDK动态代理和CGLIB动态代理两种方式。
JDK动态代理（本篇）： 当被代理的目标对象实现了接口时，Spring会使用JDK动态代理。Spring AOP利用java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8945dd982beebd078add2c6140cb0dc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5185b162c7a4188154fb3a41e81ab48/" rel="bookmark">
			堆溢出bug定位调试修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近代码出了bug，堆溢出。 debug下一切正常， release时随机崩溃到某几个地方，
报错是: Critical error detected c0000374
不是完全随机崩溃，崩溃到某几个正常的地方，开始怀疑是不是这几个地方真的有什么bug,
由于使用了qt库，炸到qt函数调用最后崩溃到系统dll中，根本无法调试，最后发现了一个神器
就是 WinDbg自带的工具软件 gflags， 通过这个软件可以修改注册表让程序运行时，系统runtime分配内存时额外再前后多分配两个字节，并且填充0xfd(貌似是这个)，当程序内存发生溢出时写到
额外分配的内存时就直接终端。 gflags工具下载。这个再WindowsSDK中包含了，如果没有可以去
微软官网单独下载这个sdk安装时只安装调试工具，安装完成后的路径：
C:\Program Files (x86)\Windows Kits\10\Debuggers\x64
打开里面的gflags.exe 切换到如下图选择 Image File， 注意exe只需要
文件名不需要完整路径。 下面Debugger可以不选，我选了之后有报错，
然后用vs正常启动release来调试就可以定位到，另外如果无法定位。可以
把下面的几个Enable xxx checking都勾选试试，不过这样程序运行会变很慢，
调试完记得在注册表中删除这些设置，否则程序一直运行很慢。
注册表路径是:
HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/WindowsNT/CurrentVersion/Image File Execution Options/mytest.exe
有时间研究下Windbg这个，有非常多的调试工具有助于定位bug。
也可参考这几篇博客：
Windbg的gflags.exe -- Attach调试利器_windbg gflag 挂 exe-CSDN博客
【VS】Windbg的gflags.exe调试堆栈溢出，访问越界等问题。_vs vld 越界访问-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23c229e1a3eb8a72ca63fd2387f0bd57/" rel="bookmark">
			基于vue3速学angular
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为工作原因，需要接手新的项目，新的项目是angular框架的，自学下和vue3的区别，写篇博客记录下：
参考：https://zhuanlan.zhihu.com/p/546843290?utm_id=0
1.结构上：
vue3:一个vue文件，包括了html ts css angular：至少需要三个文件，分别写html ts css 文件写法如下：XXXXX.component.html 代码核心部分是ts文件里面的@Component，这里的功能是抛出了当前这个组件的调用名称 并且导入了html 和 css文件
@Component({ // 组件标签名称 调用名称 selector: 'xxxx-target', // 模板页面路径 templateUrl: './xxxx-target.component.html', // 样式文件路径 styleUrls: ['./xxxx-target.component.less'] }) 2.html写法上，可以看到angular写法里面有很多括号[] ()，那具体是干什么用的呢
vue写法
&lt;button v-if="isShow" class="test-button" @click="onClick" :title="buttonTitle"&gt;{{ '1111' }}&lt;/button&gt; &lt;input v-else type="text" v-model="name" /&gt; &lt;div v-for="(item,index) in cardList"&gt;&lt;/div&gt; &lt;div v-show="isShow"&gt;&lt;/div&gt; &lt;div :class="{ 'disabled': disabled, 'un-hover': true}" :style="{ color: color }"&gt;&lt;/div&gt; &lt;div&gt; &lt;slot&gt;&lt;/slot&gt; &lt;slot name="icon"&gt;&lt;/slot&gt; &lt;/div&gt; angular写法
&lt;button *ngIf="isShow" class="test-button" (click)="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23c229e1a3eb8a72ca63fd2387f0bd57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/888fb9019569fee0a0ae8ee484674aa8/" rel="bookmark">
			[JAVASE] 类和对象(五) -- 抽象类和接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 抽象类
1.1 抽象类的定义
1.2 抽象类的实现
1.3 抽象类的作用 1.4 抽象类注意事项 二. 接口 2.1 接口的定义
2.2 接口的实现
2.3 接口的作用
2.4 接口注意事项 三. 总结 一. 抽象类 1.1 抽象类的定义 如果一个类中没有包含足够的信息来描绘一个具体的对象, 那么这个类就可以被定义为抽象类. (其实就是父类)
1.2 抽象类的实现 使用 abstract 关键字 来修饰抽象类, 以及抽象方法.
1.3 抽象类的作用 a. 抽象类就是用来检查父类中的抽象方法有没有在子类中被重写.
(很多语法的出现就是用来提前发现问题的)
b. 抽象类 就是为了被继承的.
c. 抽象方法 就是为了被重写的.
1.4 抽象类的注意事项 a. 如果一个类是抽象类, 可以不必在抽象类中 实现 抽象方法.
但是,如果一个类中存在抽象方法, 那么, 这个类 必须被定义为抽象类.
b. 在抽象父类中实现了抽象方法, 那么在它的普通子类中必须重写抽象方法, 在它的抽象子类中不必重写抽象方法.
c. 抽象类不能够被实例化(因为抽象类不能够描述一个具体的对象)
d. 抽象方法需要满足重写的要求.
(抽象方法不能被 static final private 修饰,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/888fb9019569fee0a0ae8ee484674aa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/080b21d399026e0f41293220d9cdcef6/" rel="bookmark">
			ES 查询踩坑-全字段匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：name字段需要全匹配查询
name的映射
普通的must查询 GET power_engin/_search { "from": 0, "size": 10, "query": { "bool": { "must": [ { "term": { "name": { "value": "尼泊尔Bheri-1水电站（勘测）", "boost": 1 } } } ] } } } 会发现，查不到数据，因为这里会name会被分词
如果想全字段匹配
GET power_engin/_search { "from": 0, "size": 10, "query": { "bool": { "must": [ { "term": { "name.keyword": { "value": "尼泊尔Bheri-1水电站（勘测）", "boost": 1 } } } ] } } } 其实keyword就是不分词的。这里的主要问题是`name`和`name.keyword`是两个完全不同的field，前者是text，后者是keyword。拿term查询匹配name实际就是在拿term匹配text field，而text field是分过词的，所以无法匹配。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d04af24231a5ae635f0396328a5d9ed/" rel="bookmark">
			【OpenCV 基础知识 13】高斯平滑处理图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数 cvSmooth 可使用简单模糊、简单无缩放变换的模糊、中值模糊、高斯模糊、双边滤波的任何一种方法平滑图像。每一种方法都有自己的特点以及局限。 没有缩放的图像平滑仅支持单通道图像，并且支持8位到16位的转换（与cvSobel和cvLaplace相似）和32位浮点数到32位浮点数的变换格式。 简单模糊和高斯模糊支持 1- 或 3-通道， 8-比特 和 32-比特 浮点图像。这两种方法可以（in-place）方式处理图像。 中值和双向滤波工作于 1- 或 3-通道， 8-位图像，但是不能以 in-place 方式处理图像。
program cv_Smooth; {$APPTYPE CONSOLE} {$R *.res} uses System.SysUtils, ocv.highgui_c, ocv.core_c, ocv.core.types_c, ocv.imgproc_c, ocv.imgproc.types_c, uResourcePaths; const // 桁 赅痱桧觇 filename = cResourceMedia + 'cat2.jpg'; var image: PIplImage = nil; dst: PIplImage = nil; begin try // 从文件加载图像并将其分配给变量 `image` image := cvLoadImage(filename, 1); // 克隆图像，将其分配给变量 `dst` dst := cvCloneImage(image); // 打印图像文件名 Writeln('[i] image: ', filename); // 如果图像未被成功加载，终止程序 if not Assigned(image) then Halt; // 创建并显示名为 'original' 的窗口，用于显示原始图像 cvNamedWindow('original', CV_WINDOW_AUTOSIZE); // 创建并显示名为 'Smooth' 的窗口，用于显示经过平滑处理后的图像 cvNamedWindow('Smooth', CV_WINDOW_AUTOSIZE); // 对原始图像进行高斯平滑处理，结果存储在 `dst` 中 cvSmooth(image, dst, CV_GAUSSIAN, 3, 3); // cvSmooth(image, dst, CV_BLUR_NO_SCALE, 3, 3); cvShowImage('original', image); cvShowImage('Smooth', dst); cvWaitKey(0); cvReleaseImage(image); cvReleaseImage(dst); cvDestroyWindow('original'); cvDestroyWindow('Smooth'); except on E: Exception do Writeln(E.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d04af24231a5ae635f0396328a5d9ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cb1afd67c9085493e8d5c52abcbe03b/" rel="bookmark">
			开源大模型与闭源大模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 开源大模型和闭源大模型是两种常见的大模型类型，它们在以下方面存在差异：
开放性：
开源大模型：代码和模型结构是公开可用的，任何人都可以访问、修改和使用。闭源大模型：模型的代码和结构是私有的，只能由特定的组织或个人使用。 可定制性：
开源大模型：由于其开放性，用户可以根据自己的需求进行定制和修改，以适应特定的应用场景。闭源大模型：定制和修改的程度可能受到限制，因为模型的结构和实现细节可能不公开。 数据使用：
开源大模型：数据的使用通常是开放的，用户可以使用自己的数据进行训练和优化。闭源大模型：数据的使用可能受到限制，可能需要使用特定的数据集或遵循特定的使用规则。 应用场景：
开源大模型：适用于需要灵活性、可定制性和广泛应用的场景，如研究、教育、开发等。闭源大模型：适用于对性能、准确性和定制性有较高要求的场景，如企业内部应用、特定领域的解决方案等。
开源大模型的优点包括： 灵活性和可定制性，能够满足不同用户的需求。
促进技术的发展和创新，因为更多的人可以参与到模型的改进和优化中。
资源共享和协作，有利于推动整个行业的发展。
缺点可能包括：
质量和性能的不确定性，因为模型可能来自不同的来源和团队。缺乏技术支持和维护，可能需要用户自己进行调试和优化。 闭源大模型的优点包括：
性能和质量的稳定性，经过严格的测试和优化。提供专业的技术支持和维护。更好地保护知识产权和商业机密。 缺点可能是：
定制性相对较低，可能无法完全满足某些特定需求。开放性受限，可能对用户的参与和贡献有限。 应用场景方面，开源大模型适用于以下情况：
研究和开发，用于探索新的算法和技术。教育和培训，提供开放的学习资源。数据科学竞赛和项目，促进创新和竞争。 闭源大模型适用于以下情况：
企业内部应用，需要满足特定的业务需求和安全要求。对性能和准确性要求较高的场景，如金融、医疗等领域。特定领域的解决方案，如自然语言处理、计算机视觉等。 在实际应用中，选择开源大模型还是闭源大模型应根据具体需求、项目特点和团队资源来决定。有时，也可以结合使用开源和闭源模型，以充分发挥它们的优势。随着技术的发展和开放程度的提高，一些闭源大模型也可能逐渐开放或提供一定程度的定制化接口。
数据隐私 开源大模型和闭源大模型在数据隐私保护和用户数据安全方面存在一些差异。以下是对这些差异的详细讨论：
数据隐私保护的方式：
开源大模型：开源大模型的代码和数据通常是公开可用的，任何人都可以访问和审查模型的实现细节。为了保护数据隐私，开源大模型通常采用以下几种方式： 数据匿名化：在数据收集和预处理阶段，采用数据匿名化技术来隐藏敏感信息，如删除个人身份标识或使用假名代替真实姓名。数据加密：对数据进行加密，确保只有授权人员能够解密和访问数据。访问控制：实施访问控制机制，限制对数据的访问权限，只有经过授权的人员能够访问和使用数据。安全审计：进行安全审计和监控，检测和防范潜在的安全威胁和数据泄露。 闭源大模型：闭源大模型的开发者通常拥有对数据的完全控制，数据的访问和使用受到严格的限制。为了保护数据隐私，闭源大模型可能采用以下方式： 数据隔离：将数据存储在安全的环境中，与其他数据隔离开来，减少数据泄露的风险。访问权限管理：实施严格的访问权限控制，只有授权人员能够访问和使用数据。数据加密：对数据进行加密，确保数据在传输和存储过程中的安全性。安全评估和认证：进行安全评估和认证，确保模型和系统的安全性。 数据隐私保护的程度：
开源大模型：由于开源大模型的代码和数据是公开的，数据隐私保护的程度可能受到一定限制。虽然可以采取一些措施来保护数据隐私，但无法完全避免数据被潜在的攻击者获取和分析。开源大模型的开发者需要在保护数据隐私和促进模型的可访问性之间找到平衡。闭源大模型：闭源大模型的数据访问和使用受到严格的限制，数据隐私保护的程度相对较高。开发者可以采取更高级的安全措施来保护数据，确保数据不被未经授权的人员访问和使用。闭源大模型的开发者对数据的控制也带来了一些潜在的问题，如用户对数据使用的透明度和控制程度较低。 用户数据安全的考虑：
开源大模型：开源大模型的用户在使用模型时需要注意数据的安全和隐私。他们应该确保自己的数据在上传和使用过程中得到适当的保护，并且了解模型的隐私政策和数据使用条款。用户还可以采取一些措施来增强数据的安全性，如使用强密码、定期备份数据等。闭源大模型：闭源大模型的用户通常对数据的安全和隐私有更高的信心，因为数据的访问和使用受到更严格的控制。用户仍然需要关注模型的安全性和数据的备份，以防止潜在的数据丢失或泄露。 法律和合规性要求：
开源大模型：开源大模型的开发者需要遵守相关的开源许可证规定，确保在使用开源代码和数据时遵循许可协议。根据不同的地区和行业，还可能存在特定的法律和合规性要求，如数据保护法规、隐私法规等，开源大模型的开发者需要确保其模型符合这些要求。闭源大模型：闭源大模型的开发者需要建立自己的法律和合规体系，确保模型的开发和使用符合法律法规的要求。需要制定隐私政策和数据使用条款，明确用户的数据权利和义务，并采取相应的安全措施来保护用户数据。 透明度和可解释性：
开源大模型：由于开源大模型的代码是公开的，用户可以更好地理解模型的工作原理和决策过程，提高透明度和可解释性。有助于用户对模型的输出有更多的信任，并发现潜在的偏差或问题。闭源大模型：由于闭源大模型的实现细节是保密的，用户对模型的工作原理和决策过程了解较少，透明度和可解释性相对较低。可能导致用户对模型的信任度降低，特别是在涉及关键决策的应用场景中。 开源大模型和闭源大模型在数据隐私保护和用户数据安全方面存在差异。开源大模型提供了更大的灵活性和可定制性，但数据隐私保护的程度可能较低；闭源大模型提供了更高的数据隐私保护，但用户对数据的透明度和控制程度可能受限。在实际应用中，选择使用哪种类型的大模型应根据具体需求、数据的敏感性、安全要求和法律合规性等因素进行综合考虑。无论是开源大模型还是闭源大模型，都需要采取适当的安全措施来保护用户数据的安全和隐私。最终的目标是在保护数据隐私的前提下，实现大模型的广泛应用和价值。
商业应用 在商业应用领域，开源大模型和闭源大模型各有其优劣势。以下是对这两种模式的详细探讨，涵盖其在商业化过程中可能遇到的各方面问题和机会。
开源大模型 优势 透明度和可控性
开源大模型的代码和架构细节是公开的，企业可以了解其内部工作机制。透明度保障了系统的安全性，并允许企业在出现问题时迅速定位和解决问题。
成本效益
开源大模型通常可以免费使用或者成本较低，企业可以根据需要自行部署和维护。降低了初期的投入成本，而且只需为自己特定的需求付费，比如云计算资源和专门的技术支持。
创新和社区支持
开源模型通过丰富的社区贡献可以不断改进和优化，吸引全球开发者共同参与。企业可以从这些新功能和改进中受益，加速创新周期。
灵活性和定制化
企业可以根据自身的特殊需求定制模型，无需受限于供应商预设的功能。开源许可允许修改源代码，在需要特定调整和优化时尤为重要。
劣势 技术门槛
使用开源大模型通常需要具备高水平的技术能力和知识，企业需要拥有一支经验丰富的技术团队来配置、优化和维护系统。
维护和支持
与闭源模型相比，开源模型缺乏官方的长期技术支持。虽然社区提供了帮助，但在遇到复杂或重大的技术问题时，可能无法及时获得有效解决方案。
责任和风险
开源软件的安全性和可靠性并不总是得到充分验证，由于源代码公开，容易成为攻击目标。企业需要进一步进行安全审查和风险管理。
闭源大模型 优势 易用性和便捷性
闭源大模型通常打包完整，用户体验友好，有专门的技术支持和培训，降低了企业的技术门槛，企业可以更快地实现业务目标。
可靠性和稳定性
闭源大模型由专业团队开发和维护，经过严格的测试和验证，通常具有高稳定性和高可靠性，适合企业重要的生产环境。
安全与合规
闭源供应商通常提供保障性的安全措施和合规策略，有助于企业满足法律和监管要求。企业可以依赖供应商提供的安全更新和支持。
专业支持和服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cb1afd67c9085493e8d5c52abcbe03b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05812f7e2372d3851d62e166870e1b10/" rel="bookmark">
			【异常】JDK21报错NoSuchFieldError: Class com.sun.tools.javac.tree.JCTree$JCImport does not have member fie
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【异常】JDK21报错NoSuchFieldError: Class com.sun.tools.javac.tree.JCTree$JCImport does not have member fie
java: java.lang.NoSuchFieldError: Class com.sun.tools.javac.tree.JCTree$JCImport does not have member field 'com.sun.tools.javac.tree.JCTree qualid'
Class com.sun.tools.javac.tree.JCTree$JCImport does not have member field 'com.sun.tools.javac.tree.JCTree qualid'
lombok版本兼容性的问题
Maven依赖更新新版 lombok 为 1.18.30 即可
&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.30&lt;/version&gt; &lt;/dependency&gt; 如果更新完还不行, 可以试试 clean 等 清理缓存
缓存清一下, 或者新建个项目重新加载maven依赖
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2bc218199c623324767fe7395c2b716/" rel="bookmark">
			vue项目中使用json编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现效果： 借助插件json-editor-vue3实现效果如图一，如果嫌丑可以通过类名改一下样式如图二。
实现过程： 安装插件：npm install json-editor-vue3
文档链接：GitCode - 开发者的代码家园
&lt;script setup name="dataPreView"&gt; import JsonEditorVue from 'json-editor-vue3'; // 数据是否在加载中 let dataLoading = $ref(false); let dataSql = $ref(''); // json配置 const couldView = $ref(['tree', 'code', 'form', 'view', 'text']); // json修改 const updateModelValue = (val) =&gt; { console.log(val, '修改了值'); }; &lt;/script&gt; &lt;template&gt; &lt;div v-loading="dataLoading"&gt; &lt;JsonEditorVue v-model="dataSql" class="myJsonEditor" style="height: 580px" :modeList="couldView" currentMode="code" @update:model-value="updateModelValue" &gt;&lt;/JsonEditorVue&gt; &lt;/div&gt; &lt;/template&gt; &lt;style lang="less"&gt; .myJsonEditor { .jsoneditor-menu &gt; .jsoneditor-modes &gt; button, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2bc218199c623324767fe7395c2b716/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbb09e221a9f167ee74d8b9ef97457c1/" rel="bookmark">
			微信小程序自定义头部
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在对应界面的json文件，将navigationStyle属性设置为“custom”
"navigationStyle":"custom" 2. 状态栏的高度可以通过 wx.getSystemInfo() 获取。
胶囊按钮的信息可以通过 wx.getMenuButtonBoundingClientRect() 获取。
导航栏高度=状态栏高度+胶囊按钮的高度+（胶囊按钮距离顶部的距离-状态栏的高度）*2。
由于胶囊按钮是原生组件，为表现一致，其单位在各个系统都为 px，所以自定义导航栏高度的单位都必须是 px，才能完美适配。
wxml
&lt;view class="header-box"&gt; &lt;view style="height:{{capsuleHeight}}px;top:{{capsuleTop}}px" class='back'&gt; &lt;van-icon name="arrow-left" color="#333" bindtap='navBack' size="50rpx" /&gt; &lt;/view&gt; &lt;view class="nav-title" style="height:{{capsuleHeight}}px;top:{{capsuleTop}}px"&gt;物联网数据&lt;/view&gt; &lt;image src="/static/images/news.png" mode="scaleToFill"&gt;&lt;/image&gt; &lt;/view&gt; wxss:
.header-box{ width: 100%; position:relative; } .header-box image { width: 100%; } .other-box{ position: absolute; top: 370rpx; } .back{ position: absolute; left: 40rpx; display: flex; align-items: center; justify-content: center; } .nav-title{ position: absolute; left: 50%; transform: translateX(-50%); font-size: 32rpx; font-weight: bold; display: flex; align-items: center; justify-content: center; } js
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbb09e221a9f167ee74d8b9ef97457c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7d471ea8b29046bf4ad0f327eeccc42/" rel="bookmark">
			hubilder Android模拟器华为手机连接不上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		APP真机测试注意点：
1. 同一个局域网下
2. 手机连接USB模式（华为选择USB配置：音频来源） ，开发者模式
3. 实在不行重启HBuilderX再运行真机
可是卡在了“正在安装手机端HBuilder调试基座...” 就没反应了？？
后来通过【安装其他安卓模拟器】问题解决，具体见下文：
https://blog.csdn.net/cddcj/article/details/139120722
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3d58fae7c4640ba7f6c71a23d6020f8/" rel="bookmark">
			【SPIE独立出版，往届均已见刊并完成EI、SCOPUS检索 | 四川省人工智能学会主办】第四届大数据、人工智能与风险管理国际学术会议 (ICBAR 2024)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第四届大数据、人工智能与风险管理国际学术会议（ICBAR2024）将于2024年6月28-30日在中国成都隆重举行。大会由四川省人工智能学会、中国民用航空飞行学院联合主办，中国民航飞行学院计算机学院、中国民航飞行学院理学院、吉隆坡大学、AEIC学术交流中心共同协办。大会旨在为从事大数据、人工智能与风险管理科技研究的专家学者、工程技术人员、研发人员提供一个共享科研成果和前沿技术，了解学术发展趋势，拓宽研究思路，加强学术研究和探讨，促进学术成果产业化合作的平台。
大会网站：https://ais.cn/u/byyM3m （更多会议详情点击此处） ★★★
大会时间：2024年6月28-30日
大会地点：中国-成都
★截稿时间：2024年6月24日（早投稿早录用）
接受/拒稿通知：投稿后1周
主办单位：四川省人工智能学会、中国民用航空飞行学院联合
协办单位：中国民航飞行学院计算机学院、中国民航飞行学院理学院、吉隆坡大学、AEIC学术交流中心
组委会
*更多嘉宾持续邀请中…
征稿主题
1、大数据
基于大数据的科学研究、大数据处理的算法与编程技术、大数据搜索算法与系统等
2、人工智能
人工智能技术与应用、人工智能的基本理论与应用、智能化、知识化系统等
3、风险管理
风险管理、风险管理理论、方法与应用等
4、其他相关主题【click】
论文出版
会议投稿经过2-3位组委会专家严格审核后，最终所录用的论文将被ACM ICPS (ACM International Conference Proceeding Series)出版论文集，并提交至ACM Digital library，EI Compendex, Scopus检索。目前该会议论文检索非常稳定。往届会议已检索。
◆论文不得少于8页
◆会议论文模板下载→ 前往 ”资料下载“栏目下载
◆会议仅接受全英稿件。如需翻译服务，请联系会议负责人
◆会议采用在线方式进行投稿，全程由艾思科蓝进行技术支持，请点击投稿
参会方式
1、作者参会：一篇录用文章允许一名作者免费参会；
2、主讲嘉宾：申请主题演讲，由组委会审核；
3、口头演讲：申请口头报告，时间为15分钟；
4、海报展示：申请海报展示，A1尺寸；
5、听众参会：不投稿仅参会，也可申请演讲及展示。
6、报名参会：本会议由艾思科蓝支持在线报名，请点击以进行报名参会
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a89c74d94c74a5db4e1b7bd584466bc3/" rel="bookmark">
			MySQL慢SQL优化方案汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		⛰️个人主页: 蒾酒
🔥系列专栏：《mysql经验总结》
目录
写在前面
优化思路
避免查询不必要的列
分页优化
索引优化
JOIN优化
排序优化
UNION 优化
写在最后
最近发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。
点击跳转到学习网站
写在前面 本文介绍了MySQL常见的优化慢sql的手段，坚持看完相信对你有帮助。
同时欢迎订阅MySQL系列专栏，持续分享MySQL的使用经验。
优化思路 慢sql的优化无非是从两个方向着手
SQL语句本身的优化据库设计的优化 下面进行渐进式的分享一些常见优化手段
避免查询不必要的列 查询应该精准的查出需要的列，对于select * 的写法要避免，因为所有字段查出来不仅sql查询执行慢，若是直接返回给前端，大量的数据也会影响网络传输效率。
分页优化 对于数据量特别大，这时分页会比较深，查询扫描的数据量会比较大效率自然低，我们就需要进行分页优化
假设我们有一个包含大量订单记录的订单表，其中每个订单都有一个唯一的不包含业务逻辑的主键，并且我们想要查询最近一个月的订单并按照订单id从小到大进行分页显示某页。
假设出现深分页的sql如下：
select * from orders where order_date &gt;= date_sub(now(), interval 1 month) order by id limit 100000, 10; 执行此SQL时需要先扫描到100000行，然后再去取10行，但是随着扫描的记录数越多，SQL的性能就会越差，因为扫描的记录越多，MySQL需要扫描越多的数据来定位到具体的多少行，这样耗费大量的 IO 成本和时间成本。
对于解决该深分页问题通常有两种方法
1.延迟关联
先通过 where 条件提取出主键，在将该表与原数据表关联，通过主键 id 提取数据行，而不是通过原来的二级索引提取数据行
优化后sql:
select o.* from ( select id from orders where order_date &gt;= date_sub(now(), interval 1 month) order by id limit 100000, 10 ) as sub join orders as o on sub.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a89c74d94c74a5db4e1b7bd584466bc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e1e4531f9b36d7dc350b3b7eb356d5e/" rel="bookmark">
			spring boot3整合spring AI组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		⛰️个人主页: 蒾酒
🔥系列专栏：《spring boot实战》
目录
写在前面
spring ai简介
单独整合al接口
整合Spring AI组件
起步条件
​编辑
进行必要配置
写在最后 最近发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。
点击跳转到学习网站
写在前面 本文介绍了springboot开发后端服务中，AI组件(Spring AI)的整合与使用。坚持看完相信对你有帮助。
同时欢迎订阅springboot系列专栏，持续分享spring boot的使用经验。
spring ai简介 先看官网介绍：
翻译：
Spring AI 是 AI 工程的应用框架。其目标是将 Spring 生态系统设计原则（如可移植性和模块化设计）应用于 AI，并推广使用 POJO 作为 AI 领域应用程序的构建块。
翻译：
特征
跨 AI 提供商的可移植 API 支持，适用于聊天、文本到图像和嵌入模型。支持同步和流 API 选项。还支持下拉以访问特定于模型的功能。
在spring-ai组件没发布前，我们在spring boot中对接各种ai接口，由于接口规范格式的不同，我们通常每种接口都得单独去写代码去对接，最后通过实现策略模式来实现灵活切换ai接口源。这样是比较麻烦的。而spring-ai组件就是帮我们做了类似的封装，使得我们对接多种ai接口变得十分方便。
单独整合al接口 我们先来看spring boot简单整合经典的chatGPT 3.5接口
代码如下：
import cn.hutool.http.HttpRequest; import cn.hutool.json.JSONArray; import cn.hutool.json.JSONObject; import cn.hutool.json.JSONUtil; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e1e4531f9b36d7dc350b3b7eb356d5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a2975bbf394a66ebc56cf64f2267545/" rel="bookmark">
			【SpringBoot】SpringBoot中防止接口重复提交（单机环境和分布式环境）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页：哈__
期待您的关注 目录
🌼前言 🔒单机环境下防止接口重复提交
📕导入依赖
📂项目结构 🚀创建自定义注解
✈创建AOP切面 🚗创建Conotroller 💻分布式环境下防止接口重复提交
📕导入依赖
📂项目结构
🚀创建自定义注解
🚲创建key的生成工具类 🔨创建Redis工具类
🚗创建AOP切面类
🛵创建Controller 🌼前言 在Web应用开发过程中，接口重复提交问题一直是一个需要重点关注和解决的难题。无论是由于用户误操作、网络延迟导致的重复点击，还是由于恶意攻击者利用自动化工具进行接口轰炸，都可能对系统造成严重的负担，甚至导致数据不一致、服务不可用等严重后果。特别是在SpringBoot这样的现代化Java框架中，我们更需要一套行之有效的策略来防止接口重复提交。
本文将从SpringBoot应用的角度出发，探讨在单机环境和分布式环境下如何有效防止接口重复提交。单机环境虽然相对简单，但基本的防护策略同样适用于分布式环境的部署。
接下来，我们将首先分析接口重复提交的原因和危害，然后详细介绍在SpringBoot应用中可以采取的防护策略，包括前端控制、后端校验、使用令牌机制（如Token）、利用数据库的唯一约束等。对于分布式环境，我们还将探讨如何使用分布式锁、Redis等中间件来确保数据的一致性和防止接口被重复调用。
在深入解析各种防护策略的同时，我们也将结合实际案例，展示如何在SpringBoot项目中具体实现这些策略，并给出一些优化建议，以帮助读者在实际开发中更好地应用这些技术。希望通过本文的介绍，读者能够掌握在SpringBoot应用中防止接口重复提交的有效方法，为Web应用的稳定性和安全性提供坚实的保障。
🔒单机环境下防止接口重复提交 在这种单机的应用场景下，我并没有使用redis进行处理，而是使用了本地缓存机制。在用户对接口进行访问的时候，我们获取接口的一些参数信息，并且根据这些参数生成一个唯一的ID存储到缓存中，下一次在发送请求的时候，先判断这个缓存中是否有对应的ID，若有则阻拦，若没有那么就放行。
📕导入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;21.0&lt;/version&gt; &lt;/dependency&gt; 📂项目结构 🚀创建自定义注解 我们也说过了，要根据接口的一些信息来生成一个ID，在单机环境下，我定义了一个注解，这个注解里边保存着一个key作为ID，同时，在把这个注解加到接口上，那么这个接口就以这个key作为ID，在访问接口的时候，存储的也是这个ID值。
@Target(ElementType.METHOD) @Retention(value = RetentionPolicy.RUNTIME) @Documented @Inherited public @interface LockCommit { String key() default ""; } ✈创建AOP切面 为了方便之后的接口限流，同时也想把这件事情做一个模块化处理，我使用的是AOP切面，这样做可以减少代码耦合，方便维护。
看过我之前文章的朋友应该都知道我喜欢使用注解来实现AOP了，这里定义了一个pointCut()，切入点表达式是注解类型。如果你还不会AOP的话，可以来看一看我的这篇文章。【Spring】Spring中AOP的简介和基本使用，SpringBoot使用AOP-CSDN博客
此外使用了一个Cache本地缓存用于存储我们接口的ID，同时设置缓存的最大容量和内容的过期时间，在这里我设置的是5秒钟，5秒钟过后ID就会过期，这个接口就可以继续访问。 主要的就是这个环绕通知了，我先获取了调用的接口，也就是具体的方法，之后获取加在这个方法上的注解LockCommit，也就是我们上边自定义的注解。之后拿到注解内的key作为ID传入缓存中。存入之前先判断是否有这个ID，如果有就报错，没有就加入到缓存中，这个逻辑不难。
@Aspect @Component public class LockAspect { public static final Cache&lt;String,Object&gt; CACHES = CacheBuilder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a2975bbf394a66ebc56cf64f2267545/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9ed771ae5cea7ae969e685f5d3d78db/" rel="bookmark">
			关于如何创建一个可配置的 SpringBoot Web 项目的全局异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前情概要 这个问题其实困扰了我一周时间，一周都在 Google 上旅游，我要如何动态的设置 @RestControllerAdvice 里面的 basePackages 以及 baseClasses 的值呢？经过一周的时间寻求无果之后打算决定放弃的我终于找到了一些关键的线索。
当然在此也感激这篇文章：@ControllerAdvice的用法和原理探究
其实我们只要有调试源码的习惯，也能够发现这些东西，可能有时候就是差那么一点动力吧，比如我，就想直接看现成的解析，没有那么主动去调试源码，哈哈哈。
发现了关键问题之后 其实从上面这篇文章里我提取到的关键信息如下：
@Bean public HandlerExceptionResolver handlerExceptionResolver( @Qualifier("mvcContentNegotiationManager") ContentNegotiationManager contentNegotiationManager) { List&lt;HandlerExceptionResolver&gt; exceptionResolvers = new ArrayList&lt;&gt;(); configureHandlerExceptionResolvers(exceptionResolvers); if (exceptionResolvers.isEmpty()) { addDefaultHandlerExceptionResolvers(exceptionResolvers, contentNegotiationManager); } extendHandlerExceptionResolvers(exceptionResolvers); HandlerExceptionResolverComposite composite = new HandlerExceptionResolverComposite(); composite.setOrder(0); composite.setExceptionResolvers(exceptionResolvers); return composite; } PS：😓 后来我才发现这里面的 configureHandlerExceptionResolvers ，addDefaultHandlerExceptionResolvers 和extendHandlerExceptionResolvers 这三个方法是源码里面的，我还一直在找这个博主有关这两个方法的实现。
OK 回来，这里面的关键就是我需要往 Spring IOC 里面添加一个 HandlerExceptionResolverComposite ，并且设置它的处理器列表就好了。
于是我就顺着这个思路开始捣鼓，OK，下面是第一个版本的代码：
版本一 Starter 配置类(关键代码)
@Bean public HandlerExceptionResolver handlerExceptionResolver() { final HandlerExceptionResolverComposite composite = new HandlerExceptionResolverComposite(); final List&lt;HandlerExceptionResolver&gt; resolves = Collections.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9ed771ae5cea7ae969e685f5d3d78db/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/9/">«</a>
	<span class="pagination__item pagination__item--current">10/71</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/11/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>