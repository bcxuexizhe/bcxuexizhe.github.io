<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07037ddd9a417204f93398e6434d5140/" rel="bookmark">
			（2020|ICML PMLR，线性 Transformer，核函数，RNN）Transformer 是 RNN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Transformers are RNNs: Fast Autoregressive Transformers with Linear Attention
公众号：EDPJ（进 Q 交流群：922230617 或加 VX：CV_EDPJ 进 V 交流群）
目录
0. 摘要
3. 线性 Transformers
3.1. Transformer
3.2. 线性注意力机制
3.2.1. 特征映射与计算成本
3.3. 因果掩码
3.3.1. 梯度计算
3.3.2. 训练和推理
3.4. transformer 是 RNN
4. 实验
0. 摘要 Transformer 在多项任务中表现出色，但由于其对输入长度的二次复杂度，对于非常长的序列来说，速度极慢。为了解决这一限制，我们将自注意力表示为核特征映射（kernel feature maps）的线性点积，并利用矩阵乘积的结合性将复杂度从 O(N^2) 降低到 O(N)，其中 N 是序列长度。我们证明了这种表达方式允许一种迭代实现，大大加速了自回归 Transformer，并揭示了它们与递归神经网络的关系。我们的线性 Transformer 在性能上与普通 Transformer 相似，并且在非常长序列的自回归预测中速度快达 4000 倍。 3. 线性 Transformers 在本节中，我们提出了线性 Transformer。我们展示了将传统的 softmax 注意力机制改为基于特征映射的点积注意力，可以改善时间和内存复杂度，并且可以实现类似于 RNN 的线性时间序列生成模型。
3.1. Transformer 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07037ddd9a417204f93398e6434d5140/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0369de4e97085858045cb10208a09dd4/" rel="bookmark">
			《TCP/IP网络编程》（第十二章）I/O复用（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本章将讨论实现并发服务器的第二种办法，基于I/O复用的服务器端构建。
I/O复用它允许单个进程或线程同时处理多个输入/输出（I/O）操作，而无需为每个I/O操作创建一个独立的线程或进程。这种技术可以显著提高应用程序的效率和性能，特别是在需要处理大量并发连接的场景下。
1.多进程服务器端的缺点 基于进程的并发服务器在创建进程时，需要付出极大的代价，因为需要大量的运算和内存空间，而且由于每个进程具有独立的内存空间，相互间交换数据的方法也很复杂。
如果使用I/O复用技术，则可以在不创建进程的情况下同时向多个客户端进行服务。
2.基于I/O复用的服务器端 上图左边时多进程服务器端模型，右边是I/O复用服务器端模型，可以看出后者无论连接多少个客户端，提供服务的进程只有1个
3.理解select()函数 select() 函数是一种用于I/O复用的系统调用，它允许程序同时监视多个文件描述符（包括套接字），以确定哪些文件描述符已经准备好进行读取或写入操作。select() 函数在Linux系统和Windows系统中都支持，下面是以Linux系统为例，Windows系统示例放在最后。
①select()函数基本语法
//发生错误时返回-1； //发生关注的事件返回时，返回该事件的文件描述符（大于0） int select( int maxds, //设置位监视的文件描述符中最大的描述符加1。例如，如果你监视的文件描述符范围是0到5，则maxfds应该设置为6。 fd_set *readfds, //将所有关注“是否有可读数据”的文件描述符注册到fd_set，并传递其地址值 fd_set *writefds,//将所有关注“是否有可写数据”的文件描述符注册到fd_set，并传递其地址值 fd_set *exceptfds, //将所有关注“是否发生异常”的文件描述符注册到fd_set，并传递其地址值 struct timeval *timeout//设置select() 调用的超时时间，为了防止调用select()函数后，陷入无限阻塞 ); //struct timeval的结构体定义 struct timeval{ long tv_sec; //秒数 long tv_usec; //毫秒数 } ②select()函数的调用过程
select()函数的调用流程如下图所示，本文将逐步介绍
设置文件描述符： select()可以监视多个文件描述符，将需要监视的文件描述符集中为一个集合fd_set，集中时也要按照读、写、异常进行分为三类，fd_set结构如下图所示:
设置位为1则代表时监视对象，所以上图中fd1和fd3的是监视对象。在fd_set变量中用下列宏进行操作： FD_ZERO(fd_set* fdset); //将所有fd_set变量的所有位设置位0 FD_SET(int fd, fd_set* fdset); //将fd_set中指定变量的位设置为1 FD_CLR(int fd, fd_set* fdset); //将fd_set中指定变量的位设置为0 FD_ISSET(int fd, fd_set* fdset); //如果文件描述符在集合中，返回非零值；如果不在集合中，返回0。 指定监视范围： 即select() 函数中的第一个参数maxds, 要监视的文件描述符中最大的描述符加1。例如，如果你监视的文件描述符范围是0到5，则maxfds应该设置为6，因为文件描述分值是从0开始
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0369de4e97085858045cb10208a09dd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d927a25222dc5270783c434cfc5ead55/" rel="bookmark">
			module ‘plotting‘ has no attribute ‘EpisodeStats‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		plotting.py 的版本不同，可以使用下列版本
reinforcement-learning/lib/plotting.py at master · dennybritz/reinforcement-learning · GitHubImplementation of Reinforcement Learning Algorithms. Python, OpenAI Gym, Tensorflow. Exercises and Solutions to accompany Sutton's Book and David Silver's course. - reinforcement-learning/lib/plotting.py at master · dennybritz/reinforcement-learninghttps://github.com/dennybritz/reinforcement-learning/blob/master/lib/plotting.py
import matplotlib import numpy as np import pandas as pd from collections import namedtuple from matplotlib import pyplot as plt from mpl_toolkits.mplot3d import Axes3D EpisodeStats = namedtuple("Stats",["episode_lengths", "episode_rewards"]) def plot_cost_to_go_mountain_car(env, estimator, num_tiles=20): x = np.linspace(env.observation_space.low[0], env.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d927a25222dc5270783c434cfc5ead55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d89523e40d421a9882f4287fa271188/" rel="bookmark">
			源码解析之p-limit（限制异步任务并发数量）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		p-limit是一个用于限制异步任务并发数量的javascript库，可以有效地管理资源并避免系统负载过高
简单使用如下：
import pLimit from "p-limit" // 限制并发数量为2 const limit = pLimit(2) const delay = (ms) =&gt; { return new Promise(resolve =&gt; setTimeout(resolve, ms)); }; const asyncTask1 = async () =&gt; { await delay(5000) console.log("输出任务1") } const asyncTask2 = async () =&gt; { await delay(5000) console.log("输出任务2") } const asyncTask3 = async () =&gt; { await delay(5000) console.log("输出任务3") } const input = [limit(() =&gt; asyncTask1()), limit(() =&gt; asyncTask2()), limit(() =&gt; asyncTask3())] const result = await Promise.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d89523e40d421a9882f4287fa271188/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b3f528a28605cc85feb1773f5a4dbe1/" rel="bookmark">
			【Java】类和对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类和类的实例化 类就是一类对象的统称。对象就是这一类具体化的一个实例。 声明一个类就是创建一个新的数据类型，而类在 Java 中属于 引用类型 ， Java 使用关键字 class 来声明类。我们来 看以下简单的声明一个类。 基本语法： class &lt; class_name &gt; { field ; // 成员属性 method ; // 成员方法 } // 实例化对象 &lt; class_name &gt; &lt; 对象名 &gt; = new &lt; class_name &gt; (); class为定义类的关键字，ClassName为类的名字，{}中为类的主体。 类中的元素称为：成员属性。类中的函数称为：成员方法。 代码示例:
class Student{ public String name; public char sex; public int age; public void study(){ System.out.println("学习"); } public void eat(){ System.out.println("吃饭"); } } 这里我们创建了一个 Student 类，其中有成员属性：name、sex、age。和成员方法：study、eat。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b3f528a28605cc85feb1773f5a4dbe1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55eaf96310eadd940257bd896dccc609/" rel="bookmark">
			【每日刷题】Day50
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【每日刷题】Day50
🥕个人主页：开敲🍉
🔥所属专栏：每日刷题🍍
🌼文章目录🌼
1. 654. 最大二叉树 - 力扣（LeetCode）
2. 119. 杨辉三角 II - 力扣（LeetCode）
3. 735. 小行星碰撞 - 力扣（LeetCode）
1. 654. 最大二叉树 - 力扣（LeetCode） //思路：递归遍历，通过不断改变左右区间找到最大值，从而保证在最大值左边构建子树以及最大值右边构建子树。
typedef struct TreeNode TN;
TN* CreatBinaryTree(int* nums,int left,int right)
{
if(left&gt;right)//当区间不存在时，说明已经没有值能找了，直接返回NULL
return NULL;
int max = left;
for(int i = left;i&lt;=right;i++)
{
if(nums[i]&gt;nums[max])//定位当前最大值的下标，作为下一次寻找左右最大结点的区间
{
max = i;
}
}
TN* node = (TN*)malloc(sizeof(TN));
node-&gt;val = nums[max];
node-&gt;left = CreatBinaryTree(nums,left,max-1);
node-&gt;right = CreatBinaryTree(nums,max+1,right);
return node;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55eaf96310eadd940257bd896dccc609/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/681aba2dbee8d3633d79b1f003fcfd90/" rel="bookmark">
			springboot项目使用validated参数校验框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、validated是什么？
二、使用步骤
1.引入maven依赖
2.使用实现
总结
前言 当谈到Spring的参数校验功能时，@Validated注解无疑是一个重要的利器。它为我们提供了一种简单而又强大的方式来验证请求参数的合法性，保证了系统的稳定性和安全性。本文将介绍Spring Validated的基本用法以及在实际项目中的应用。
提示：以下是本篇文章正文内容，下面案例可供参考
一、validated是什么？ @Validated注解的作用和使用方法
可以用于Controller类或方法上，开启对请求参数的校验功能。通过在方法参数上使用其他校验注解（如@NotNull、@NotBlank、@Min、@Max等），对请求参数进行校验和验证，确保参数的合法性。可配合使用Spring Validation API或其他支持JSR-303规范的验证框架（如Hibernate Validator），发挥@Validated注解的最大效用。 @Validated注解的实际应用示例
编写一个用户注册接口，结合@Pattern注解对用户名和密码进行格式校验。处理校验失败时的异常情况，并返回友好的错误信息给接口调用方。 @Validated注解的注意事项和最佳实践
讨论@Validated注解在复杂校验场景下的使用技巧。如何在全局配置文件中声明验证器或配置验证规则，使得@Validated注解更加灵活地适应各种项目需求。 二、使用步骤 1.引入maven依赖 代码如下（示例）：
&lt;!-- Validation合法性校验(参数) 参数校验框架的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;/dependency&gt; 2.使用实现 代码如下 参数长度在 5 - 16位（示例）：
/** * @Description: 用户相关的控制层 * @Author: windStop * @Date: 2024/5/26 16:18 */ @RestController @RequestMapping("/user") @Validated //启用参数校验功能 public class UserController { @Autowired private UserService userService; /** * 用于注册新用户 在注册用户的时候需要先判断用户名是否存在，因为用户名不可以重复 * 这里我不打算使用给用户名添加唯一字段 * @param username 用户名 * @param password 密码 * @return 是否注册成功 */ @PostMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/681aba2dbee8d3633d79b1f003fcfd90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6350fe7fc1bbb6ec71f4cf9197026eb4/" rel="bookmark">
			Python 开心消消乐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💝💝💝欢迎莅临我的博客，很高兴能够在这里和您见面！希望您在这里可以感受到一份轻松愉快的氛围，不仅可以获得有趣的内容和知识，也可以畅所欲言、分享您的想法和见解。
推荐:「stormsha的主页」👈，持续学习，不断总结，共同进步，为了踏实，做好当下事儿~
专栏导航
Python系列: Python面试题合集，剑指大厂Git系列: Git操作技巧GO系列: 记录博主学习GO语言的笔记，该笔记专栏尽量写的试用所有入门GO语言的初学者数据库系列: 详细总结了常用数据库 mysql 技术点,以及工作中遇到的 mysql 问题等运维系列: 总结好用的命令，高效开发算法与数据结构系列: 总结数据结构和算法,不同类型针对性训练,提升编程思维 非常期待和您一起在这个小小的网络世界里共同探索、学习和成长。💝💝💝 ✨✨ 欢迎订阅本专栏 ✨✨
💖The Start💖点点关注，收藏不迷路💖 📒文章目录 效果图项目结构程序代码 完整代码：https://gitcode.com/stormsha1/games/overview
效果图 项目结构 程序代码 run.py
import sys import pygame from pygame.locals import KEYDOWN, QUIT, K_q, K_ESCAPE, MOUSEBUTTONDOWN from dissipate.level import Manager from dissipate.level_tree import LevelTreeManager from dissipate.sounds import Sounds class Game: """ 游戏主类，负责初始化和主循环 """ def __init__(self): """ 初始化游戏 """ pygame.init() pygame.mixer.init() pygame.display.set_caption('开心消消乐') # 设置游戏窗口标题 pygame.mouse.set_visible(False) # 隐藏鼠标指针 # 初始化游戏管理器和声音 self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6350fe7fc1bbb6ec71f4cf9197026eb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb35fb2587f6550b61882aee3bc1d5ad/" rel="bookmark">
			IP 分片过程及偏移量计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IP 报头中与分片相关的三个字段 1、 标识符（ ldentifier )：16 bit
该字段与 Flags 和 Fragment Offest 字段联合使用， 对较大的上层数据包进行分段（ fragment ） 操作。
路由器将一个包拆分后，所有拆分开的小包被标记相同的值，以便目的端设备能够区分哪个包属于被拆分开的包的一部分。
2、 标记（ Flags ）：3 bit
该字段第 1 位不使用。
第 2 位是 DF（ Don’t Fragment ) 位，DF 位设为 1 时表明路由器不能对该上层数据包分段。如果一个上层数据包无法在不分段的情况下进行转发，则路由器会丢弃该上层数据包并返回一个 ICMP 错误信息。
第 3 位是 MF（ More Fragments ) 位，当路由器对一个上层数据包分段，则路由器会在除了最后一个分段的 IP 报文头中将 MF 位设为 1。
3、 片偏移（ Fragment Offset )：13 bit
表示该 IP 报文在该组分片中的位置，接收端靠此来组装还原 IP 报文。
数据报分片举例 举例 1 举例 2 IPv4 vs IPv6 分段扩展头 在 IPv4 中，中间路由器对于超过接口 MTU 的数据包可以进行再分段处理，数据包在转发过程中可能被多次分段，会降低数据包的转发效率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb35fb2587f6550b61882aee3bc1d5ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25507d30d624b72beccd45e9c2f67ec7/" rel="bookmark">
			外包干了3天，技术退步明显.......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先说一下自己的情况，大专生，18年通过校招进入杭州某软件公司，干了接近4年的功能测试，今年年初，感觉自己不能够在这样下去了，长时间呆在一个舒适的环境会让一个人堕落!
而我已经在一个企业干了四年的功能测试，已经让我变得不思进取，谈了2年的女朋友也因为我的心态和工资和我分手了。
于是，我决定要改变现状，冲击下 大厂。
刚开始准备时，自己都蒙了，四年的功能测试让我的技术没有一丝的进步，提升的只有我的年龄…
没办法，我找到了我在腾讯的老哥，作为他的小老表，在他了解了我的情况后(几乎就是软件测试基础开始)，直接甩给我一个网盘，说到：“去吧，这里有你需要的所有东西，不要来找我了，我都嫌丢人!”。
盘里头是一整套软件测试面试必备文档PDF，看完之后直接给我老哥给跪了…这下面试稳了。
内容涵盖：包括测试理论、Linux基础、MySQL基础、Web测试、接口测试、App测试、管理工具、Python基础、Selenium相关、性能测试、LordRunner相关等… 质量非常高，需要的可自行领取！！
全网首发-涵盖16个技术栈 第一部分，测试理论（测试基础+需求分析+测试模型+测试计划+测试策略+测试案例等等）
第二部分，Linux（ Linux基础+Linux练习题）
第三部分，MySQL（基础知识+查询练习+万年学生表经典面试题汇总+数据库企业真题）
第四部分，Web测试
第五部分，API测试
第六部分，App测试
第七部分，管理工具
第八部分，Python基础（Python基础+编程题+集合+函数+Python特性等等）
第九部分，Selenium相关
第十部分，性能测试
第十一部分，LordRunner相关
第十二部分，计算机网络
第十三部分，组成原理
第十四部分，数据结构与算法
第十五部分，逻辑题
第十六部分，人力资源
软件测试基础 软件测试的步骤是什么?
如何录制测试脚本?
应该考虑进行如何测试的测试方法
怎样估计测试工作量?
测试设计的问题
当测试过程发生错误时，有哪几种解决办法?
测试执行的问题
测试评估的目标
如何提高测试?
C/S模式的优点和缺点
B/S模式的优点和缺点
…
Linux grep和find的区别? grep 都有哪些用法?
查看IP地址?
创建和删除一个多级目录?
在当前用户家目录中查找haha.txt文件?
如何查询出tomcat的进程并杀掉这个进程，写出linux命令?
动态查看日志文件?
查看系統硬盘空间的命令?
查看当前机器listen 的所有端口?
…
Python 统计python源代码文件中代码行数，去除注释，空行，进行输出?
python调用cmd并返回结果?
冒泡排序
1,2,3,4 这4个数字，能组成多少个互不相同的且无重复的三位数，都是多少?
请用 python 打印出 10000 以内的对称数（对称数特点：数字左右对称，如：1,2,11,121,1221 等）
给定一个整数 N，和一个 0-9 的数 K，要求返回 0-N 中数字 K 出现的次数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25507d30d624b72beccd45e9c2f67ec7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d7d5d997fd0327babfeb5c6f8bf71fb/" rel="bookmark">
			python 队列生产者消费者爬虫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当使用Python编写一个基于队列的生产者消费者爬虫时，我们通常会使用threading或multiprocessing模块来处理并发，并使用queue模块来管理数据队列。下面是一个详细的示例，该示例展示了如何使用生产者线程生成URL，消费者线程爬取这些URL的内容。
请注意，这里为了简化示例，我们将不会实际进行网页爬取，而是模拟这个过程。在实际应用中，我们可能需要使用如requests库来发送HTTP请求，并使用如BeautifulSoup或lxml来解析HTML内容。
（1）安装必要的库（如果尚未安装）
bash复制代码 ​ pip install requests beautifulsoup4 （2）示例代码
import threading import queue import time import random from urllib.parse import urljoin from bs4 import BeautifulSoup # 导入BeautifulSoup，但在此示例中不会实际使用 import requests # 导入requests，但在此示例中不会实际发送请求 # 模拟的起始URL和要爬取的网站域名 START_URL = 'http://example.com' BASE_DOMAIN = 'http://example.com' # 队列，用于在生产者和消费者之间传递URL url_queue = queue.Queue() # 生产者函数，生成并添加URL到队列中 def producer(url_queue, num_urls): print('Producer started.') urls_seen = set() urls_to_add = [START_URL] while urls_to_add and num_urls &gt; 0: current_url = urls_to_add.pop(0) if current_url not in urls_seen: urls_seen.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d7d5d997fd0327babfeb5c6f8bf71fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29a674e82d04db81258181f250171335/" rel="bookmark">
			小程序使用vant组件库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一:下载组件库 在小程序内npm下载的包
vant组件库官网:快速上手 - Vant Weapp (youzan.github.io)
1)首先有有package.json文件,没有的话则先初始化
即使通过package.json去下载包,也需要有,可以观察下载的包.
2)下载包
3)构建npm包
下载包之后存储在node_modules内,但是我们获取包是在另一个包内,因此需要构建
每一次增加包,都需要先删除上一次构建的包,然后再点击构建npm,可以不报错.
4)删除style:"v2',会开启样式隔离.
二:按需导入 在app.json上/index.json上会写以下的会安装组件.和对应的wxss.
三:使用变量定义样式 使用变量可以在小程序也可在页面.
在css内是
在选择器下定义变量,如果是变量来设置样式的,最好以--开头,便于区分.
然后需要的var(变量)会访问父组件,当前组件内的css内的这个变量的值
在vant,wxss内也是一样.
vant组件库的type="danger"内部会添加样式,样式是var(--...)上面的,我们在页面的wxss内使用,则页面使用vant,会寻找这个.但是其他页面使用的话,还是用默认的.因此在app.wxss内使用,全局的wxss会被访问的,比较权重.app.wxss会整理在一起.每个页面都能访问.
四:小程序的异步回调 如上述,success都是异步完成之后回调函数,异步回调容易逻辑乱,形成回调地狱
1.下载包 2.配置 导入包,包给wx,wxp会给导入返回promise对象,会将wx的属性都导入到wx.p内.且没有回调,返回一个promise对象.在app.js上使用,所有页面内wx.p都有.在页面js上,其他页面没有这些.
3.使用 返回的promise对象,和ajax一样使用.
五:数据共享 和behaviors不一样,behaviors是和minix差不多,是导入,但是组件之间互相不能共享.
这里数据共享类似vuex,vuex的store对象,创建的对象,会被所有的组件使用,然后能修改共享
1.安装包 并且构建
2.创建store对象 在store文件夹下的store.js文件内,导入包,使用包,创建store对象.
这样得到store对象,对象的前面写get,会使得sum变量时刻获取值,也可以设置set.
使用action(方法)将方法赋值给方法.且会记录时间等.直接修改的话,无法记录时间这种.
小程序为了简便,只使用actions来实现同步和异步,同步也在actions方法内,异步也可以写在actions内.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41ce21eb6f5086f7a1c972878d69979f/" rel="bookmark">
			平方回文数-第13届蓝桥杯选拔赛Python真题精选
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[导读]：超平老师的Scratch蓝桥杯真题解读系列在推出之后，受到了广大老师和家长的好评，非常感谢各位的认可和厚爱。作为回馈，超平老师计划推出《Python蓝桥杯真题解析100讲》，这是解读系列的第73讲。
平方回文数，本题是2021年11月27日举办的第13届蓝桥杯青少组Python编程选拔赛真题编程部分第4题。题目要求编程输出100到M之间的平方回文数的个数。
先来看看题目的要求吧。
一.题目说明 编程实现：
给定一个正整数M（100 &lt; M &lt; 2000），输出100到M之间（包含M）的平方回文数的个数。
例如：M为150，则在100到150之间的平方回文数有1个，为121，输出1。
输入描述：
输入一个正整数M
输出描述：
输出100到M之间（包含M）的平方回文数的个数
样例输入：
150
样例输出：
1
二.思路分享 这是一道经典的数论题，涉及的知识点包括回文数，循环、列表、递归算法和动态规划等。
很明显，这是典型的枚举算法，将100到M之间所有的数字挨个进行判断即可。所以这里的重点是如何判断给定数字是平方回文数。
这里有两个概念，一个是回文数，一个是平方数。
关于回文数的判断，在之前的蓝桥真题中出现过多次，实现的方法也比较多，具体可以参考《输出回文数-第11届蓝桥杯选拔赛Python真题精选》这篇文章。
对于平方数的判断，最常见的就是使用数学方法，如果一个数n是平方数，那么它的平方根一定是一个整数，比如：
100的平方根是10121的平方根是11144的平方根是12 因此我们可以先计算数出n的平方根并转成整数m，再判断m * m是否等于n，如果相等，说明n为平方数。
为了简化代码，我们可以自定义两个函数分别用于判断，然后在循环中调用函数进行判断并统计平方回文数的个数。
思路有了，接下来，我们就进入具体的编程实现环节。
三.编程实现 根据上面的思路分析，我们分3步来编写程序：
判断回文数
判断平方数
统计平方回文数
1. 判断回文数
在Python编程中，最简单的方法就是使用切片运算逆序字符串，再判断原字符串和逆序字符串是否相等。
定义函数如下：
代码非常简单，需要注意的是，n是整数，需要先转成字符串再进行处理。
2. 判断平方数
根据前面的思路分析，自定义函数如下：
代码非常简单，说明两点：
1). 在Python中，**是幂运算，可以使用 **0.5来计算算术平方根，得到的结果是浮点数，使用int()函数将其转成整型；
2). 在计算平方根的时候，也可以使用math模块中的sqrt()函数，效果一样，但需要引入math模块。
3. 统计平方回文数
有了上面定义的两个函数，接下来只需要使用循环挨个判断并统计即可，代码如下：
代码比较简单，注意一个细节，就是循环的起点和终点，根据题目的说明和样例数据，不包括100，但是包括M。
至此，整个程序就全部完成了，你可以输入不同的数字来测试效果啦。
四.总结与思考 本题代码在12行左右，涉及到的知识点包括：
循环语句；
字符串处理，重点是切片运算；
幂运算的应用；
自定义函数；
本题代码不多，难度一般，关键点有两个，一是如何判断回文数，二是如何判断平方数。
回文数是编程中的经典问题，判断的方法也比较多，在Python编程中，最简单的就是使用字符串逆序方法，尤其是切片运算，真的是太好用了，一定要熟练掌握。
和其他语言不同的是，Python提供了一个强大的幂运算符**，它用于计算一个数的幂，即底数的指数次方。
例如，𝑎𝑏表示𝑎的𝑏次幂，可以直接使用 a ** b 来表示，它不仅可以用于计算平方、立方，还可以计算平方根、立方根等，非常强大。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41ce21eb6f5086f7a1c972878d69979f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82c86f922b8e913386384a5812b288c3/" rel="bookmark">
			关于C&#43;&#43;的IO流简单总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础IO流 C++的IO以面向对象的形式实现, 同时兼容了C语言面向过程的IO方式
C++ 标准库提供了四个基本流对象：
cin：用于从标准输入（通常是键盘）读取数据。
cout：用于向标准输出（通常是控制台）写入数据。
cerr：用于向标准错误输出写入数据，通常用于报告错误。
clog：用于向标准日志输出写入数据，通常用于记录日志信息。
C++中可以通过重载流插入和流提取（std::istream、std::ostream）操作符更好的支持自定义对象的输入输出 如下：
string str; while(cin &gt;&gt; str){} 上述该种方式输入时, 首先是因为string重载了&gt;&gt;操作符, 调用了istream&amp; operator &gt;&gt; (istream&amp; is, string&amp; str)重载函数, 然后返回值调用了operator bool() 将自定义类型转换成对应的true或者false(bool类型)进行判断.
结束该进程时, 可以通过Ctrl + C直接杀死进程, 或者Ctrl + Z + 换行表示读取到了结尾即退出循环
tips1: 将自定义类型转换为内置类型时, 可以通过重载对应的explicit operator 类型(){} 函数来实现, 如operator int(){return _a}//无显式写出返回值,但是要返回对应类型的变量 ,内置类型转换为自定义类型时, 则是通过自定义类型对应的构造函数实现.
tips2: 自定义类型实现的流插入和流提取可以提供给cout/cin, ifstream/ofstream等类型的流提取和流插入函数实现多态使用, 可更方便的构造自定义类型.如
Date date; cin &gt;&gt; date; //或者是如下 ifstream ifs("date.txt");//默认打开方式是文本读的方式 ifs &gt;&gt; date;//可直接读入该date对象中 二进制读写: 在内存中是如何存储则如何写到磁盘文件(以如下模式打开文件流：ios_base::in | ios_base::binary)
优点: 读写效率高缺点 写出的内容无法读懂对于需要深浅拷贝的自定义类型无法正确拷贝(地址会改变) 文本读写: 对象数据序列化字符串写出, 读回时也是字符串, 即由二进制序列, 反序列化转成对象数据(即将字符串转为对应数据)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82c86f922b8e913386384a5812b288c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe0de5a1f30c8e12d5c4a77d04406fb9/" rel="bookmark">
			Mysql 单行转多行，把逗号分隔的字段拆分成多行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、拆分前后的数据 二、执行SQL select substring_index(substring_index(a.gzlx,',',b.help_topic_id+1),',',-1) gzlxname, a.gzlx,a.* from dt_task_zxgz_info a join mysql.help_topic b on b.help_topic_id &lt; (length(a.gzlx) - length(replace(a.gzlx,',',''))+1) 三、解释说明 1、help_topic
本身是Mysql一个帮助解释注释表，用于解释Mysql各种专有名词，由于这张表数据ID是从0顺序增加的，方便我们用于计数
2、substring_index
MySQL SUBSTRING_INDEX() 从给定字符串中返回指定数量的分隔符出现之前的子字符串。
当指定数字为正数时从最终分隔符的左侧返回子字符串，当指定数字为负数时从最终分隔符的右侧返回子字符串。
如果指定的次数大于分隔符的出现次数，则返回的子字符串将是总字符串。如果指定的数字为 0，则不会从给定的字符串中获取任何内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2e37fb81f5cd991ffcdf4d91f10a346/" rel="bookmark">
			手把手教你使用VScode&#43;ESP-IDF在ESP32上搭建web server，并作为web socket server进行数据交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备： 装好ESP-IDF插件的VScode；ESP32开发板（ESP32-S2、ESP32-S3都行）。 步骤： 打开VScode，按F1，输入Show Examples Projects后，搜索station，创建station例程。这是一个添加ssid和密码后就能连接无线网络的例程。
打开工程，修改要连接热点的SSID与PASS
点击menuconfig后搜索“websocket”，勾选“WebSocket server support”以启用web socket，保存，退出。
- 修改Max HTTP Request Header Length为2048，以保证HTTP的报头发出不报错。
编译，并烧录进ESP32开发板中，以验证基础工程的正确性。可以看到被路由器DHCP分配到的IP为192.168.31.117。
在左侧main目录下创建 web_server.c、web_server.h、web_client.html。添加这些文件到mian目录下“CMakeLists.txt”中，其中web_client.html的路径添加为EMBED_FILES，如果设计的页面有图片，图片路径也要添加其中，用空格隔开。
idf_component_register(SRCS "station_example_main.c" "web_server.c" INCLUDE_DIRS "." EMBED_FILES "web_client.html" ) 在web_client.html中随便添些HTML代码，设计了一个简单的页面，寻到web_client.html文件存放目录，双击运行。若只是在修改页面效果，可将客户端连接的地址固定，在VScode修改保存后在浏览器中按F5刷新，能直接看到最新设计效果。用JavaScript语言，创建客户端套接字“ws_client”，JavaScript代码添加在HTML代码的下方。此处设计的功能为：将从web server收到的字符串数据打印log和显示在条框中，并回发给服务器。此脚本嵌入在ESP32的flash后，在使用时，将会在被HTTP客户端请求时发出去。 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;HTTP Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Web Client.&lt;/h1&gt; &lt;p style="display: inline;"&gt;&lt;label for="textID"&gt;收到数据:&lt;/label&gt;&lt;/p&gt; &lt;input type="text" id="textID" value=""&gt; &lt;/body&gt; &lt;/html&gt; &lt;script&gt; //服务器地址 //烧录进ESP32时使用 "ws://"+window.location.host+"/ws" //调试html时直接写 "ws://192.168.31.117/ws" const ws_client = new WebSocket("ws://"+window.location.host+"/ws"); /*ws_client连接成功事件*/ ws_client.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2e37fb81f5cd991ffcdf4d91f10a346/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d0c332ae7709d7b6a01d3e731adb958/" rel="bookmark">
			MySQL8.0.35简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL 8.0.35 是 MySQL 数据库管理系统的一个具体版本，该版本包含了多种特性和改进。以下是关于 MySQL 8.0.35 的主要信息，包括其发布背景、性能提升、以及安装和配置的相关内容：
1. 发布背景 MySQL 8.0 系列自 2017 年起开始开发，并于 2018 年 7 月发布了第一个 General Availability (GA) 版本 8.0.11。截至 2024 年 5 月，MySQL 8.0 系列已经发布了多个版本，其中 8.0.35 是近期的一个稳定版本。 2. 性能提升 根据 Oracle 的一篇博客文章（发布于 2024 年 2 月），MySQL 8.0.35 的企业版相比社区版在性能方面有所提高，特别是在某些测试场景下，性能提升达到了 17% 到 25%。另外，在 2023 年 11 月的一篇知乎文章中提到，MySQL 官方在 8.0.35 版本中修复了一个 bug，这个修复导致了 Mark Callaghan 在其 benchmark 上验证到有 300% 的性能提升（即 4 倍）。 3. 安装和配置 对于 Windows 64 位系统，MySQL 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d0c332ae7709d7b6a01d3e731adb958/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/342aa88b68cde7785db77161af1a6686/" rel="bookmark">
			计算机体系结构期末快速复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言CPI，MIPS（大题1）加速比（大题2）流水线（大题3）CRAY-1向量机（大题4）Tomasulo算法（大题5）概念简答题计算机系统结构的经典定义什么是透明性计算机系统结构分类法计算机系统结构概念的实质Amdahl定律冯诺依曼结构的主要特点什么事向上（下）兼容和向前（后）兼容并行性从处理数据角度，并行性等级从低到高从执行程序的角度，并行性等级从低到高提高并行性的途径 CPU中用来存储操作数的存储单元的主要类型指令集结构分为哪三种类型在确定哪些基本功能用硬件来实现时，主要考虑哪三个因素对指令集的基本要求流水线通过时间和排空时间是什么流水线的分类按照流水线所完成的功能分类按照同一时间内各段之间的连接方式对多功能流水线做进一步的分类按照流水的级别分类按流水线是否有反馈回路分类按任务流入和流出的顺序是否相同分类 一个经典的五段流水线相关有哪三种类型流水线冲突有哪些 前言 楼主今天下午考计算机体系结构，所以快速复习顺便写了一下，里面有自己看过的比较好视频推荐，建议先看目录是否切合学校的考纲，祝各位考试不挂科~
CPI，MIPS（大题1） CPI = （每个指令的执行数量 * 每个指令的平均时钟周期数）/ 全部指令的数量
MIPS = 主频 / (CPI * 10^6)
加速比（大题2） 加速比 = 总执行时间（改进前）/ 总执行时间（改进后）
= 1/（(1 - 可改进比例) + 可改进比例/部件加速比)
= 1 / （(1 - 各部件可改进比例之和) + 各部件 可改进比例/部件加速 之和）
流水线（大题3） 推荐视频：https://www.bilibili.com/video/BV1g34y167Nu/?spm_id_from=333.999.0.0
画流水线：求吞吐率 加速比 效率消除瓶颈 ： 重复设置部件 、 细分瓶颈段 CRAY-1向量机（大题4） 推荐视频：https://www.bilibili.com/video/BV1iY411g7HJ?p=18&amp;vd_source=133ab656b1083da8fddee466829de2ad 40分钟
启动访存 1 拍 ，送加 1拍，送乘1 拍，写入1拍，其他访存，浮点加，浮点乘，看题目要求几拍
Tomasulo算法（大题5） 推荐视频;https://www.bilibili.com/video/BV1Cr4y1H7gA/?spm_id_from=333.999.0.0 40分钟
概念简答题 计算机系统结构的经典定义 程序员所看到的计算机属性，即概念性结构和功能特性
什么是透明性 在计算机技术中，把本来存在事物或属性，但从某种角度看又好像不存在的概念称为透明性
计算机系统结构分类法 Flynn分类法： SISD（单指令流单数据流），SIMD（单指令流多数据流），MISD（多指令流单数据流），MIMD（多指令流多数据流）冯氏分类法 PS:如何记忆：S是single 单 M是many 多
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/342aa88b68cde7785db77161af1a6686/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0248f98b853769c053e286da587556ea/" rel="bookmark">
			Android 性能为王时代SparseArray和HashMap一争高下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、`SparseArray` 源码分析1. **类定义和构造函数**2. **基本方法**2.1 `put(int key, E value)`2.2 `get(int key)`2.3 `delete(int key)`2.4 `removeAt(int index)`2.5 `gc()`2.6 `size()`2.7 `keyAt(int index)` 和 `valueAt(int index)` 3. **辅助方法**3.1 `binarySearch()` 二、使用示例三、详细实现分析3.1 `ContainerHelpers` 类3.2 `GrowingArrayUtils` 类 四、优缺点4.1 优点4.2 缺点 五、使用场景5.1 适用场景5.2 不适用场景 六、实际使用示例七、总结 SparseArray 是 Android 中一种高效的数据结构，用于将整数键映射到对象。它与 HashMap 类似，但为了节省内存，使用两个并行数组来存储键和值，并采用二分搜索进行查找。以下是对 SparseArray 源码的详细分析。 一、SparseArray 源码分析 1. 类定义和构造函数 SparseArray 是一个泛型类，继承自 Object。
public class SparseArray&lt;E&gt; implements Cloneable { private static final Object DELETED = new Object(); private boolean mGarbage = false; private int[] mKeys; private Object[] mValues; private int mSize; public SparseArray() { this(10); // 默认初始容量为10 } public SparseArray(int initialCapacity) { if (initialCapacity == 0) { mKeys = EmptyArray.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0248f98b853769c053e286da587556ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f61d9cd2590923fa95f55288f8530eb/" rel="bookmark">
			Stable Diffusion AI绘画：从提示词到模型出图的全景指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💂 个人网站:【 摸鱼游戏】【神级代码资源网站】【工具大全】🤟 一站式轻松构建小程序、Web网站、移动应用：👉注册地址🤟 基于Web端打造的：👉轻量化工具创作平台💅 想寻找共同学习交流，摸鱼划水的小伙伴，请点击【全栈技术交流群】 Stable Diffusion 是近年来备受关注的一种AI绘画技术，它能够根据文本提示生成高质量的图像。本文将详细介绍Stable Diffusion 的工作原理、技术架构以及如何使用该技术从提示词生成图像，并附上示例代码，帮助你更好地理解和应用这项技术。
什么是 Stable Diffusion？ Stable Diffusion 是一种基于扩散模型（Diffusion Models）的图像生成技术。扩散模型通过逐步添加和去除噪声来训练神经网络，从而生成高质量的图像。这种方法在图像生成任务中表现出色，能够根据输入的文本提示生成符合描述的图像。
Stable Diffusion 的工作原理 Stable Diffusion 的核心原理是扩散过程，它包括两个主要阶段：
正向扩散过程：将训练数据中的图像逐步添加噪声，直到图像变成纯噪声。这一过程帮助模型学习如何在不同的噪声水平下还原图像。
逆向扩散过程：训练好的模型根据输入的噪声图像逐步去除噪声，最终生成高质量的图像。在生成过程中，模型会结合输入的文本提示，生成与提示相符的图像。
Stable Diffusion 的技术架构 Stable Diffusion 的技术架构主要由以下几个部分组成：
编码器（Encoder）：将输入的文本提示编码成向量表示，作为生成图像的条件输入。
噪声预测网络（Noise Prediction Network）：基于U-Net架构，预测并去除图像中的噪声。
调度器（Scheduler）：控制扩散过程中的噪声添加和去除步骤，确保生成过程的稳定性和效果。
从提示词到模型出图的流程 以下是使用 Stable Diffusion 从提示词生成图像的完整流程：
1. 安装必要的依赖 首先，需要安装必要的Python库和 Stable Diffusion 模型的依赖项。可以使用以下命令：
pip install torch torchvision transformers diffusers 2. 加载模型和其他组件 接下来，加载预训练的 Stable Diffusion 模型和相关组件。以下是示例代码：
import torch from transformers import CLIPTextModel, CLIPTokenizer from diffusers import StableDiffusionPipeline # 加载CLIP文本编码器和分词器 tokenizer = CLIPTokenizer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f61d9cd2590923fa95f55288f8530eb/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/">«</a>
	<span class="pagination__item pagination__item--current">2/71</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/3/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>