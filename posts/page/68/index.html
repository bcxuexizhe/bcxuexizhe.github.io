<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b7f0c67d020c7fe32c4a08fd2595a94/" rel="bookmark">
			springboot基础篇(快速入门&#43;要点总结)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.springboot简介
2.springboot的优势
3.创建springboot项目
4.输出hello world
5.热部署
6.properties配置文件
7.日志框架
1.springboot简介 在开始了解Spring Boot之前，我们需要先了解一下Spring，因为Spring Boot的诞生和Spring是息息相关的，Spring Boot是Spring发展到一定程度的一个产物，但并不是Spring的替代品，Spring Boot是为了让程序员更好的使用Spring。与我们前篇文章所提到的Spring-framework同属于spring的产品，大多数人把Spring Boot称为搭建程序的脚手架。其最主要作用就是帮我们快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让我们关注于业务而非配置。
那到这里你是否会有这样的疑问，那spring呢？它和springboot有什么联系吗？
先了解一下Spring，Spring的前身是interface21，这个框架最初是为了解决EJB开发笨重臃肿的问题，为J2EE提供了另一种简单又实用的解决方案，并在2004年3月发布了Spring 1.0正式版之后，就引起了Java界广泛的关注和热评，从此Spring在Java界势如破竹迅速走红，至今无可替代。
那既然Spring已经这么优秀了，为什么还有了之后Spring Boot？
随着Spring发展的越来越火，Spring也慢慢从一个小而精的框架变成了，一个覆盖面广大而全的框架，另一方面随着新技术的发展，比如nodejs、golang、Ruby的兴起，让Spring逐渐看着笨重起来，大量繁琐的XML配置和第三方整合配置，让Spring使用者痛苦不已， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。
项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这也是件棘手的问题。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。
所以在这样的情况下，springboot就诞生了
Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。Spring Boot其实就是一个整合很多可插拔的组件（框架），内嵌了使用工具（比如内嵌了Tomcat、Jetty等），方便开发人员快速搭建和开发的一个框架。
2.springboot的优势 那么springboot有什么优势呢？总结出来以下五点：
1.快速集成框架，Spring Boot 提供了启动添加依赖的功能，用于秒级集成各种框架。
2.内置运行容器，无需配置 Tomcat 等 Web 容器，直接运行和部署程序。 3.快速部署项目，无需外部容器即可启动并运行项目。 4.可以完全抛弃繁琐的 XML，使用注解和配置的方式进行开发。 5.支持更多的监控的指标，可以更好的了解项目的运行情况。
3.创建springboot项目 了解了springboot之后，我们就开始来搭建springboot项目
Spring Boot项目创建，有两种方式：
方式一：访问网站构建项目，下载到本地导入开发工具方式二：使用IDEA（IntelliJ IDEA的简称）工具使用Spring Initializr创建初始化（推荐使用） 方式二：使用IDEA Spring Initializr创建（推荐使用）
在这里需要注意：springboot的版本对jdk的版本是有要求的，如果springboot的版本选择3以上，那么上一个步骤jdk的版本就必须选择17，否则会报错 创建完成后具体文件解释如下：
方式一：访问网站创建项目：
1.访问网址：start.spring.io/
2.配置项目信息，点击Generate Project按钮生成项目，如下图：
其中，Group表示组织标识符，对应了Java包目录的结构；Arifact表示项目标识符，对应项目名称，也就是根目录名称。
3.解压文件夹，点击IDEA File =&gt; New =&gt; Project from Existing Sources.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b7f0c67d020c7fe32c4a08fd2595a94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f03c2d46c73e6fda36d1e27bee728299/" rel="bookmark">
			RabbitMQ手动ACK与死信队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了保证消息从队列可靠的达到消费者，RabbitMQ 提供了消息确认机制（Message Acknowledgement）。
默认情况下RabbitMQ在消息发出后就立即将这条消息删除,而不管消费端是否接收到,是否处理完,导致消费端消息丢失时RabbitMQ自己又没有这条消息了。所以在实际项目中会使用手动Ack。
1、手动应答 Channel.basicAck (用于肯定确认)：RabbitMQ 已知道该消息成功被处理，可以将其丢弃了。Channel.basicNack (用于否定确认)Channel.basicReject (用于否定确认)：与 Channel.basicNack 相比少一个参数，不处理该消息了直接拒绝，可以将其丢弃了。 消费者端的配置，相关属性值改为自己的：
server.port=8082 #rabbitmq服务器ip spring.rabbitmq.host=localhost #rabbitmq的端口 spring.rabbitmq.port=5672 #用户名 spring.rabbitmq.username=lonewalker #密码 spring.rabbitmq.password=XX #配置虚拟机 spring.rabbitmq.virtual-host=demo #设置消费端手动 ack none不确认 auto自动确认 manual手动确认 spring.rabbitmq.listener.simple.acknowledge-mode=manual 修改消费代码：请勿复制使用，会卡死
package com.example.consumer.service; import com.alibaba.fastjson.JSONObject; import com.example.consumer.entity.User; import com.rabbitmq.client.Channel; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Service; import java.io.IOException; /** * @description: * @author: LoneWalker * @create: 2022-04-04 **/ @Service @Slf4j public class ConsumerService { @RabbitListener(queues ="publisher.addUser") public void addUser(String userStr,Channel channel,Message message){ long deliveryTag = message.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f03c2d46c73e6fda36d1e27bee728299/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d67be89b5d04b7cbc71525ca973174b5/" rel="bookmark">
			【头歌】数据结构-队列的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1关：循环队列
任务描述
本关任务：编写一个循环队列，实现入队、出队操作，判断队空、队满等特殊情况。
相关知识
为了完成本关任务，你需要掌握：1.循环队列定义，2.入队、出队的定义，3.队空、队满的情况。
循环队列定义
循环队列将数组存储区看成是一个首尾相接的环形区域（下图）。当数据存放到尾地址后，下一个地址就跳转到首地址。循环队列定义如下：
struct Queue{int maxSize; // 队列最大长度int *data; // 数据指针int front; // 头指针索引int rear; // 尾指针索引}; 入队出队定义
入队操作：队列未满，在队尾插入一个元素item，使得data[rear+1]=item，若超过存储空间则尾指针索引取模(rear+1)%maxSize；
出队操作：队列不空，返回队首元素值data[front]，并移除队首元素front+1，若超过存储空间则头指针索引取模(front+1)%maxSize。
队空队满情况
初始化创建空队时，令front=rear=0， 其中front指向队首元素，rear指向队尾元素的下一个元素：
当队空时：front==rear当队满时：front==rear 亦成立 因此只凭等式front==rear无法判断队空还是队满。 一个方法是少用一个元素空间，约定：队列头指针front在队尾指针rear的下一个位置上作为队列“满”状态的标志（如上图），即：
队空时： front==rear队满时： (rear+1)%maxSize==front 编程要求
本关的编程任务是补全右侧代码片段isFull、isEmpty、enQueue和deQueue中Begin至End中间的代码，具体要求如下：
在isFull中，判断队列是否为满，若满返回true并在一行打印The queue is Full，否则返回false；在isEmpty中，判断队列是否为空，若空返回true并在一行打印The queue is Empty，否则返回false；在enQueue中，实现入队操作：将元素item加入队列尾部；在deQueue中，实现出队操作：移除队列首部元素，并返回元素值。 测试说明
平台将自动编译补全后的代码，并生成若干组测试数据，接着根据程序的输出判断程序是否正确。
以下是平台的测试样例：
测试输入： 10 7 enqueue 30 enqueue 98 dequeue enqueue 96 dequeue dequeue enqueue 0 预期输出： 0 The queue is Empty
输入说明： 第一行n m分别表示循环队列大小、入队出队操作记录数量。 接下来m行，enqueue表示入队操作，后面接待入队元素；dequeue表示出队操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d67be89b5d04b7cbc71525ca973174b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2f68efc920d1103b6cb1714c46cff5c/" rel="bookmark">
			【数据结构】树的认识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个人的未来不是预测出来的，而是创造出来的。 -- 亚当·詹姆斯
目录
🍁前言：
🍀一.什么是树？
🍑二.树有什么用？ ❤️1. 数据库
🧡2. 文件系统
💛3. 编程语言
💚4. 网络
💜5. 人工智能
🍂三.树的基础知识
🌳四.树的存储结构
🍐1.双亲表示法
🍍2.孩子表示法
🍁3.孩子兄弟表示法
前言： 前面我们学习了，顺序表，链表，栈和队列，它们都是一对一的线性结构，但是往往还有一对多的情况，这就是我们今天要学习的一对多的数据结构：树（Tree）。树比前面的数据结构学起来要难一点，希望大家能够反复的学习，达到熟能生巧。
学习树的知识框架：
🍀一.什么是树？ 想到树，大家可能都会想到现实中的树，各种各样的树，就像下面这样，这是一颗很漂亮的树。
而今天我们要学习的数据结构的树是怎么样的呢？
树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
有一个特殊的结点，称为根结点，根节点没有前驱结点，除根节点外，其余结点被分成M(M&gt;0)个互不相交的集合T1、T2、……、Tm，其中每一个集合Ti(1&lt;= i &lt;= m)又是一棵结构与树类似的子树。每棵子树的根结点有且只有一个前驱，可以有0个或多个后继。因此，树是递归定义的。
这个结构就是一个树，它是不是很像现实中的树，给倒过来的。我想它之所以叫树，可能也是这个原因吧。 注意：树的子树之间不能有交集。就像下面这样：
打?的地方，子树之前发生了交集，这样是不可以的，如果这样，它就不能称作为树。
🍑二.树有什么用？ 数据结构树的应用：
数据结构是计算机科学中重要的一个分支，而树是其中一种重要且实用的数据结构之一。树是由一个根节点和若干子节点组成的一种非线性数据结构，被广泛应用于计算机领域中，特别是在算法设计和数据处理方面。下面我们将详细介绍树的应用领域。
注意:下面的树的应用都是高阶的数据结构的树，C++才会学习。
❤️1. 数据库 在数据库管理系统中，树被广泛应用于索引结构。数据库中的查找过程可以转化为在树中查找某个节点的过程。常用的树结构包括B-树、B+树和红黑树，这些结构可以高效的处理大量数据，支持高效的检索和排序。
🧡2. 文件系统 操作系统中的文件系统其实就是一种树形结构。目录和文件被视为节点，而目录之间的关系和文件之间的关系则是树的关系。基于树形结构的文件系统使得我们可以很方便地在系统中查找和管理文件。
下面就是操作系统的文件系统，它就是一种树形的结构，使用树来实现。
💛3. 编程语言 树形结构被广泛运用于编程语言中。AST（抽象语法树）就是一种常见的语法分析树，它将程序中的语句和表达式抽象成一个树形结构，在编译器中被广泛使用，可以很方便地实现代码的词法分析、语义分析和优化。此外，树也可以用于构建运行时数据结构，如二叉搜索树、Trie树、AVL树等等。 💚4. 网络 在计算机网络中，树的结构被广泛应用于路由器和交换机中。这些设备需要通过识别和分析网络中的数据包，将它们分配到不同的路由或交换机上进行处理。树的结构使得这些设备可以很方便地对不同的数据包进行分类、处理和转发。
💜5. 人工智能 在人工智能中，树也是非常重要的一种数据结构。决策树是常用的机器学习算法之一，它通过一系列的二叉树形结构对数据进行分类和判断。在处理自然语言、语音识别和图像处理等领域中，树结构也被广泛应用。
总之，数据结构树在计算机领域中有着非常广泛的应用，可以用于解决各种问题。从数据库、文件系统到编程语言、网络和人工智能等领域，都需要树这种数据结构来达到高效、快速、准确处理数据的目的。因此，学习并掌握树这种数据结构非常重要，可以帮助我们更好地理解计算机领域内的各种问题和算法。
🍂三.树的基础知识 节点的度：一个节点含有的子树的个数称为该节点的度； 如上图：A的为6。
叶节点或终端节点：度为0的节点称为叶节点； 如上图：B、C、H、I...等节点为叶节点。
非终端节点或分支节点：度不为0的节点； 如上图：D、E、F、G...等节点为分支节点。
双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 如上图：A是B的父节点。
孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；如上图：B是A的孩子节点。
兄弟节点：具有相同父节点的节点互称为兄弟节点； 如上图：B、C是兄弟节点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2f68efc920d1103b6cb1714c46cff5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b587bf385eb120bb969a4df155325a1/" rel="bookmark">
			Leetcode每日一题——“用队列实现栈”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位CSDN的uu们你们好呀，好久没有更新本专栏啦，甚是想念！！！今天，小雅兰的学习内容是用队列实现栈，下面，让我们进入Leetcode的世界吧！！！
这是小雅兰写过的栈和队列的文章，有兴趣的可以看看：
栈——“数据结构与算法”_认真学习的小雅兰.的博客-CSDN博客 队列——“数据结构与算法”_认真学习的小雅兰.的博客-CSDN博客
如图所示： 这里相当于 栈中的Push1 2 3 4这四个数据
可以使用两个队列进行导数据
如果还想再导出一个数据，那么还是同样的方法：
这里相当于栈中两次连续的Pop 如果还想Push5 6这两个数据，那么：
然后再Pop，还是一样的，这次Pop一次，Pop出的就是6啦
好的，那么我们的基本思路就是这样的啦，下面，我们开始用代码实现它吧
首先，我们用的是C语言的话，还要自己实现一个队列，直接上代码：
typedef int QDataType; // 链式结构：表示队列 typedef struct QueueNode { struct QueueNode* next; QDataType data; }QueueNode; // 队列的结构 typedef struct Queue { QueueNode* phead;//头指针 QueueNode* ptail;//尾指针 int size; }Queue; // 初始化队列 void QueueInit(Queue* pq); // 销毁队列 void QueueDestroy(Queue* pq); // 队尾入队列 void QueuePush(Queue* pq, QDataType x); // 队头出队列 void QueuePop(Queue* pq); // 获取队列头部元素 QDataType QueueFront(Queue* pq); // 获取队列队尾元素 QDataType QueueBack(Queue* pq); // 获取队列中有效元素个数 int QueueSize(Queue* pq); // 检测队列是否为空 bool QueueEmpty(Queue* pq); // 初始化队列 void QueueInit(Queue* pq) { assert(pq); pq-&gt;phead = NULL; pq-&gt;ptail = NULL; pq-&gt;size = 0; } // 销毁队列 void QueueDestroy(Queue* pq) { assert(pq); QueueNode* cur = pq-&gt;phead; while (cur !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b587bf385eb120bb969a4df155325a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8187f6a93188e0dbd3fb678469729ac9/" rel="bookmark">
			sql server导入、导出数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、导出数据库
二、导入数据库
一、导出数据库 1、连接服务器
2、选中需要导出的数据库，任务-》生成脚本
3、（跳过简介）选择该数据库中具体的某些表（如下图，选择所有当前数据库下的所有表格）
4、指定保存为文本文件
5、选择文件保存路径，以及生成的脚本文件名（此处将文件保存在了桌面名为商务网站数据库文件夹下，脚本文件名为database）
6、点击选择高级设置，在“要编写脚本的数据的类型”中选择“架构和数据”，点击确定按钮。
7、选择下一步，直到脚本保存成功。
8、脚本保存成功后如图所示，显示操作成功，点击完成即可
1、选择数据库-》新建数据库
2、在弹出以下窗口中输入新建的数据库名（不要和已有的数据库名重复）
创建好的数据库如下：
但数据库里只有一些系统自带的表，没有用户自己创建的表，当前数据库下的对象如图所示：
3、选中需要导入SQLServer中的数据库脚本文件，将其拖拽进入窗口
结果如下图所示：
其中上图波浪红线处报错的原因为：
笔者名为“database_dianshang”的数据库下已经有名为“user”的数据库对象（名为user的表）了。
4、将此处的数据库名database_dianshang”改为创建好的名为“hello”的数据库
如图所示，不再报错：
5、执行当前脚本文件，在hello数据库下生成所需的数据表
执行结果如下，显示“xx行受影响”：
6、选中hello数据库，右键选择刷新
刷新前在表下没有用户创建的表：
刷新后如下所示：
7、可查看user表的数据以及表结构是否完整
选择user表，右键“编辑前200行”，可以查看当前表中的数据如下：
选择user表，右键选择“设计”，可以查看当前表结构
8、完成sql脚本的导入
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbeb5e4612475505b034125863683bc1/" rel="bookmark">
			Open Ai 常见接口参数说明以及常见报错总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📋 个人简介 💖 作者简介：大家好，我是阿牛，全栈领域优质创作者。😜📝 个人主页：馆主阿牛🔥🎉 支持我：点赞👍+收藏⭐️+留言📝💬格言：迄今所有人生都大写着失败，但不妨碍我继续向前！🔥
目录 📋 个人简介 前言接口参数解释常见错误总结 结语 前言 很多人在群里老是问我Open Ai接口的参数以及常见的报错，其实官方都解释的很清晰了，但是还是有很多同学不懂，这里对一些重要的概念做一些总结与解释！同时将群里遇到的报错做一个汇总，希望对做相关方面的同学有帮助！
接口参数解释 curl https://api.openai.com/v1/chat/completions -H "Content-Type: application/json" -H "Authorization: Bearer $OPENAI_API_KEY" -d '{ "model": "gpt-3.5-turbo", "messages": [{"role": "user", "content": "Hello!"}] }' 上面是请求的curl形式，-d后面是要携带的主要参数。
看不懂，那看下面图片 ：
这是javascript中的fetch请求方式，在python中可用官方提供的库，也可用requests模块请求 ：
这里不再多说，主要总结参数！
{ "model": "gpt-3.5-turbo", "messages": [{"role": "user", "content": "Hello!"}], "max_tokens": 1024, "temperature": 0.5, "top_p": 1, "n": 1, "stream": false, "logprobs": null, "stop": "\n" } 1.model参数 : 使用的模型，目前大多使用gpt-3.5-turbo
2.messages : 上下文列表，请求携带上下文对话记录，用于实现上下文对话！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbeb5e4612475505b034125863683bc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1612e6e151e466e0d1dcefe30bd9a6f/" rel="bookmark">
			【生成模型】Stable Diffusion原理&#43;代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Latent space二、AutoEncoder 和 VAE1.AutoEncoder:2.VAE： 三、Diffusion扩散模型1.前向过程2.逆向过程 四、多模态 cross attention五、Stable Diffusion原理1.训练过程：ResnetBlockSpatial Transformer(Cross Attention)DownSample/UpSample 2.前向过程 六、代码解析*0.安装提示1.整体代码2.unet解析1、self.input_blocks2、middle_blocks3、self.output_blocks 总结 前言 Stable diffusion是一个基于 Latent Diffusion Models（潜在扩散模型，LDMs）的文图生成（text-to-image）模型。具体来说，得益于 Stability AI 的计算资源支持和在 LAION-5B 的一个子集数据支持训练，用于文图生成。
Latent Diffusion Models 通过在一个潜在表示空间中迭代“去噪”数据来生成图像，然后将表示结果解码为完整的图像，让文图生成能够在消费级GPU上，在10秒级别时间生成图片。目前，Stable Diffusion发布了v2版本。v1版是Latent Diffusion Models的一个具体实现，模型架构设置：自动编码器下采样因子为8，UNet大小为860M，文本编码器为CLIP ViT-L/14。官方目前提供了以下权重：
提示：以下是本篇文章正文内容，下面案例可供参考
一、Latent space 隐空间是压缩数据的一个表示。数据压缩的目的是学习数据中较重要的信息。以编码器-解码器网络为例，首先使用全卷积神经网(FCN)络学习图片特征，我们将特征提取中对数据的降维看作一种有损压缩。由于解码器需要重建(reconstruct)数据，模型必须学习如何储存所有相关信息并且忽略噪音，压缩（降维）的好处在于可以去掉多余的信息从而关注于最关键的特征。
二、AutoEncoder 和 VAE 1.AutoEncoder: (1)AE是一个预训练的自编码器，优化目标是通过 Encoder 压缩数据，再通过decoder 还原数据，使得输入输出的数据尽量相同
(2)对于图像数据，decoder 还原数据可以看做是一个生成器，由于 decoder 输入数据z属于R空间，输入z的分布无法被固定住，所以大部分生成的图片是无意义的。
2.VAE： (1)给定输入解码器的z一个分布可以解决上述问题，假设一个服从标准多元高斯分布的多维随机变量的数据集X，根据已知分布采样得到的zi，来训练decoder神经网络，从而得到多元高斯分布的均值和方差，从而成功得到一个逼近真实分布p(X)的p’(X)
(2)求解p’(X|z)的概率分布
(3)通过极大似然估计，最大化p’(X)的概率，但由于xi的维度很大，zi的维度也很大，需要准确找到与xi分布相关的zi，需要大量的采样，因此需要在encoder中引入后验分布p’(z|xi)，让xi与zi关联起来
(4)利用encoder通过假设已知数据的分布，拟合其参数，从而逼近真实的后验分布p’(z|xi),在这里假设后验分布是基于多元高斯分布，则让encoder输出分布的均值和方差
(5)总体流程
三、Diffusion扩散模型 1.前向过程 1.t 时刻的分布等于 t-1 时刻的分布+随机高斯分布的噪音，其中α是噪音的衰减值
2.任意时刻的分布 Xt ，都可以通过 X0 初始状态，以及步数计算出来：
2.逆向过程 已知 Xt，求初始状态的 X0，这里利用贝叶斯公式来预测 X0:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1612e6e151e466e0d1dcefe30bd9a6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78766c8c443066b40ed2ba6027c41aed/" rel="bookmark">
			头歌大数据——MapReduce 基础实战 答案 无解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1关：成绩统计 编程要求
使用MapReduce计算班级每个学生的最好成绩，输入文件路径为/user/test/input，请将计算后的结果输出到/user/test/output/目录下。
代码：
需要先在命令行启动HDFS
#命令行 start-dfs.sh 再在代码文件中写入以下代码
#代码文件 import java.io.IOException; import java.util.StringTokenizer; import java.io.IOException; import java.util.StringTokenizer; import org.apache.hadoop.conf.Configuration; import org.apache.hadoop.fs.Path; import org.apache.hadoop.io.*; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Job; import org.apache.hadoop.mapreduce.Mapper; import org.apache.hadoop.mapreduce.Reducer; import org.apache.hadoop.mapreduce.lib.input.FileInputFormat; import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat; import org.apache.hadoop.util.GenericOptionsParser; public class WordCount { /********** Begin **********/ //Mapper函数 public static class TokenizerMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt; { private final static IntWritable one = new IntWritable(1); private Text word = new Text(); private int maxValue = 0; public void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException { StringTokenizer itr = new StringTokenizer(value.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78766c8c443066b40ed2ba6027c41aed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/846c1b8b0573ba9c95337d94aefde6ad/" rel="bookmark">
			如何快速入门 Java？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在一线互联网公司做开发 13 年了，“精通”Java，“吊打”一众面试官，如何快速入门 Java，对我来说简直就是小儿科，相信看完后你一定能收获满满、醍醐灌顶，今年秋招拿下阿里、美团等互联网大厂的 offer。
逼装完了，我们开始。
一、劝退下 先来一张劝退型的思维导图吧，我之前根据 hollis 的成神之路手绘的。
如果看了这张图，你已经被成功劝退，那么恭喜你，你真的不用再浪费时间了，因为计算机专业现在已经是风口浪尖，如果你没有恒心，没有毅力，那不如不入门，直接去炒股，说不定还能发大财！😆
如果你没有被劝退，那么，恭喜你，年入 20 万+的工作即将摆在你的面前，当然了，如果你连 20 万都看不上，至少要 30 万，那么再次恭喜你，你是一名不可多得的天才！阿里、美团的大厂 offer 已经在来的路上了。
二、安装环境 工欲善其事必先利其器，战斗之前我们要先配备好武器。
第一，安装 JDK。 JDK 是 Java Development ToolKit 的简称，也就是 Java 开发工具包。JDK 是整个 Java 的核心，包括 Java 运行环境（Java Runtime Envirnment，简称 JRE），Java 工具（比如 javac、java、javap 等等），以及 Java 基础类库（比如 rt.jar），学习 Java 之前必须要安装。
建议入门安装 JDK8（尽管最新的正式版是 Java 17，但依然推荐 Java 8，源码容易懂）。
Windows 用户和 macOS 用户的安装手册我帮大家已经写好了，可以直接戳下面这个链接。可以图形化界面安装，也可以在命令行像黑客那样安装。
Windows和macOS下安装JDK教程：原生安装与包管理器（高级）
安装完，在终端可以敲 java -version 查看是否配置成功。
第二，安装 Intellij IDEA IntelliJ IDEA 简称 IDEA，是业界公认为最好的 Java 集成开发工具，尤其是在代码自动提示、代码重构、代码版本管理、单元测试、代码分析等方面有着亮眼的发挥。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/846c1b8b0573ba9c95337d94aefde6ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5bcc8b094a9c9af030010e972af1770/" rel="bookmark">
			【LLM】Windows本地CPU部署民间版中文羊驼模型（Chinese-LLaMA-Alpaca）踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
准备工作
Git Python3.9 Cmake
下载模型 合并模型
部署模型 前言 想必有小伙伴也想跟我一样体验下部署大语言模型, 但碍于经济实力, 不过民间上出现了大量的量化模型, 我们平民也能体验体验啦~, 该模型可以在笔记本电脑上部署, 确保你电脑至少有16G运行内存
开原地址：GitHub - ymcui/Chinese-LLaMA-Alpaca: 中文LLaMA&amp;Alpaca大语言模型+本地CPU部署 (Chinese LLaMA &amp; Alpaca LLMs)
Linux和Mac的教程在开源的仓库中有提供，当然如果你是M1的也可以参考以下文章：
https://gist.github.com/cedrickchee/e8d4cb0c4b1df6cc47ce8b18457ebde0
准备工作 最好是有代理, 不然你下载东西可能失败, 我为了下个模型花了一天时间, 痛哭~ 我们需要先在电脑上安装以下环境： GitPython3.9（使用Anaconda3创建该环境） Cmake（如果你电脑没有C和C++的编译环境还需要安装mingw） Git 下载地址：Git - Downloading Package 下载好安装包后打开, 一直点下一步安装即可... 在cmd窗口输入以下如果有版本号显示说明已经安装成功
git -v Python3.9 我这里使用Anaconda3来使用Python, Anaconda3是什么？
如果你熟悉docker, 那么你可以把docker的概念带过来, docker可以创建很多个容器, 每个容器的环境可能一样也可能不一样, Anaconda3也是一样的, 它可以创建很多个不同的Python版本, 互相不冲突, 想用哪个版本就切换到哪个版本...
Anaconda3下载地址：Anaconda | Anaconda Distribution
安装步骤参考：
等待安装好后一直点next, 直到点Finish关闭即可
在cmd窗口输入以下命令, 显示版本号则说明安装成功
conda -V 接下来我们在cmd窗口输入以下命令创建一个python3.9的环境 conda create --name py39 python=3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5bcc8b094a9c9af030010e972af1770/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e838e4227c7f209eba98e56f3459751c/" rel="bookmark">
			Elasticsearch 核心技术（十）：GEO 地理查询（geo_bounding_box、geo_distance、geo_shape）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		❤️ 博客主页：水滴技术
🚀 支持水滴：点赞👍 + 收藏⭐ + 留言💬
🌸 订阅专栏：大数据核心技术从入门到精通
文章目录 一、地理数据类型1.1、geo_point 地理点类型1.1.1、创建一个含有 geo_point 字段的索引1.1.2、通过“对象”指定 geo_point1.1.3、通过“字符串”指定 geo_point1.1.4、通过“地理哈希”指定 geo_point1.1.5、通过“数组”指定 geo_point1.1.6、通过“WKT”指定 geo_point 1.2、geo_shape 地理形状类型1.2.1、创建一个含有 geo_shape 字段的索引1.2.2、通过 Point 指定单个地理坐标1.2.3、通过 LineString 指定一条线1.2.4、通过 Polygon 指定一个多边形1.2.5、通过 MultiPoint 指定多个点1.2.6、通过 MultiLineString 指定多条线1.2.7、通过 MultiPolygon 指定多个多边形1.2.8、通过 GeometryCollection 指定地理形状的集合1.2.9、通过 envelope 指定矩形或包络线1.2.10、通过 circle 指定圆形 二、地理查询2.1、geo_bounding_box 矩形过滤2.1.1、查询矩形内的定位点（文档） 2.2、geo_distance 距离查询（圆形过滤）2.2.1、查询“附近的人”2.2.2、查询“附近的人”并按距离排序 2.3、geo_polygon 多边形查询（已过时）2.4、geo_shape 地理形状查询2.4.1、查询 intersects 相交关系2.4.2、查询 disjoint 不相交关系2.4.3、查询 within 在...之内关系2.4.4、查询 contains 包含关系 三、附录附录一：es_location_001 索引附录二：es_location_002 索引附录三：地图工具 系列文章热门专栏 大家好，我是水滴~~
地理信息查询是 Elasticsearch 的重要特性之一，其 GEO 功能主要用于地理信息的存储和搜索。本篇主要内容：介绍 Elasticsearch 的两种地理数据类型，并通过一些实例来讲述geo_bounding_box 查询、geo_distance 查询和 geo_shape 查询。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e838e4227c7f209eba98e56f3459751c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d3cea717f71206020273435367ffbe2/" rel="bookmark">
			双层优化入门(2)—基于yalmip的双层优化求解(附matlab代码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇博客介绍了双层优化的基本原理和使用KKT条件求解双层优化的方法：
双层优化入门(1)—基本原理与求解方法
这篇博客将介绍使用yalmip的双层优化问题的求解方法。
1.KKT函数 通过调用yalmip工具箱中的KKT函数，可以直接求出优化问题的KKT条件，省去自己手动写的步骤，函数用法如下：
[KKTsystem, details] = kkt(Constraint,Objective,z) 其中z表示优化变量，KKTsystem存储KKT条件的约束表达式，details是一个结构体变量，用于存储KKT条件的细节。以上一篇博客中双层优化问题的下层优化问题为例：
matlab代码： %% 目标函数和约束条件 x=sdpvar(1); y=sdpvar(1); Constraints=[-3*x+y &lt;= -3 , 3*x+y &lt;= 30]; objective=-y; [KKTsystem, details] = kkt(Constraints,objective,x); 运行结果： 将下层优化的KKT条件作为约束添加到上层优化中，就可以求出这个双层优化的结果：
%% 清空 clc clear close all warning off %% 目标函数和约束条件 x=sdpvar(1); y=sdpvar(1); Constraints_down=[-3*x+y &lt;= -3 , 3*x+y &lt;= 30]; objective_down=-y; [KKTsystem , details] = kkt(Constraints_down,objective_down,x); Constraints_up=[2*x-3*y &gt;= -12 , x+y &lt;= 14]; objective_up=-x-2*y; ops=sdpsettings('verbose', 0 , 'solver', 'gurobi'); result=optimize([KKTsystem,Constraints_up,boundingbox([Constraints_up,Constraints_down])],objective_up,ops); %% 输出模型 saveampl(KKTsystem,objective_down,'KKT_model'); %% 输出结果 disp(['最优解：x=',num2str(value(x)),',y=',num2str(value(y))]) disp(['最优函数值=',num2str(value(objective_up))]) 求解的结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d3cea717f71206020273435367ffbe2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a15b46298d4a450dce00aaece0db138/" rel="bookmark">
			如何将时间戳转化为年月日时分秒格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先获取到当前的时间戳或者需要转化为时间的时间戳
var time = new Date(时间戳); //得到Thu May 11 2023 15:22:41 GMT+0800 (中国标准时间) //这种样式的时间但是不是我们想要的所以要继续处理 然后使用getFullYear、getMonth、 getDate、getHours、getMinutes、getSeconds等方法来获取当前时间的年月日时分秒
var y=time.getFullYear();//返回年份 //getMonth方法从 Date 对象返回月份 (0 ~ 11)，返回结果需要手动加一var d = time.getDate(); // getDate方法从 Date 对象返回一个月中的某一天 (1 ~ 31) var M=time.getMonth()+1; var d=time.getDate(); var h=time.getHours(); var m = time.getMinutes(); var s = times.getSeconds(); 最后使用字符串拼接的方式得到我们想要的时间
var times = y + '-' + M + '-' + d + ' ' + h + ':' + m + ':' + s //得到这种格式2023-5-11 15:32:29 如果往后端传时间有严格要求必须是0000-00-00 00:00:00这种格式再做处理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a15b46298d4a450dce00aaece0db138/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/608560fca70429a038f2d6d27ab3f212/" rel="bookmark">
			Stable Diffusion 本地部署教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前言： 最近看Stable Diffusion开源了，据说比Disco Diffusion更快，于是从git上拉取了项目尝试本地部署了，记录分享一下过程~
这里是官网介绍：https://stability.ai/blog/stable-diffusion-public-release
2.必要前提： 科学上网。很多链接都需要用到。显卡的显存需要足够大，至于多大没看到哪有说，反正3g绝对不行 3.部署前准备： 本地化部署运行虽然很好，但是也有一些基本要求
（1）需要拥有NVIDIA显卡，GT1060起，显存4G以上。（已经不需要3080起，亲民不少）
（2）操作系统需要win10或者win11的系统。
MacOS平台本地化请见《如何在mac电脑上运行stable diffusion来做AI绘画》
（3）电脑内存16G或者以上。
（4）最好会魔法上网，否则网络波动，有些网页打不开，有时下载很慢。
（5）耐心，多尝试，多搜索。这个教程我已经重复过2次，因此很多问题基本上都踩坑并写出来了。所以请放心，能跑通的。
我的电脑配置供大家参考，Win10，I7，NVIDIA GT1050 4G，16G
生成一张20step的图大概20-30s（若使用更高性能的电脑，生成速度更快。）
4.使用的项目Stable diffusion WebUI项目 Stable diffusion大家都知道了，是当前最多人使用且效果最好的开源AI绘图软件之一，属于当红炸子鸡了。
不过，stable diffusion项目本地化的部署，是纯代码界面，使用起来对于非程序员没那么友好。
而stable diffusion webui，是基于stable diffusion 项目的可视化操作项目。
通过可视化的网页操作，更方便调试prompt，及各种参数。
同时也附加了很多功能，比如img2img功能，extra放大图片功能等等。
因此stable diffusion webui项目是很多人部署到本地的首选。
我们本教程就是以stable diffusion webui项目为例来操作的。
二、电脑环境配置 1.安装miniconda 这个是用来管理python版本的，他可以实现python的多版本切换。
下载地址：https://docs.conda.io/en/latest/miniconda.html
安装时按默认的一路next就行。
2.用管理员权限打开miniconda，输入conda -V 弹出版本号即为正确安装 3.配置库包下载环境，加快网络速度（替换下载库包地址为国内的清华镜像站） 执行下面
conda config --set show_channel_urls yes 生成.condarc 文件
在我的电脑/此电脑-C盘-users-你的账号名下用记事本打开并修改.condarc文件。（如我的路径是C:\Users\Administrator。）
把下面的内容全部复制进去，全部覆盖原内容，ctrl+s保存，关闭文件。
channels: - defaults show_channel_urls: true default_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/608560fca70429a038f2d6d27ab3f212/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aa7e408c6096bee6cd824e9201d0093/" rel="bookmark">
			LOAM、Lego-liom、Lio-sam轨迹保存，与Kitti数据集真值进行评估
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 首先需要保存轨迹，轨迹保存参考下面的代码，最好自己添加一个节点（如下图），用新节点来订阅和保存轨迹至txt文件,因为直接在算法的线程中加入此步骤我试了好像保存不了，好像是在不同线程间的参数传递格式的问题（也可能是我个人的问题）。
与Kitti数据集真值评估需要将kitti 类型轨迹转化为tum格式的轨迹，用evo转化需要下载evo源码。
(223条消息) KITTI数据集基准、转换成tum以及十个groundtruth对应图_kitti转tum_小海盗haner的博客-CSDN博客
(223条消息) 【KITTI】KITTI数据集简介（四） — 标定校准数据calib_tr_velo_to_cam_Coding的叶子的博客-CSDN博客
a_loam在节点中订阅话题/aft_mapped_to_init，如下。lego同样操作订阅话题 /aft_mapped_to_init，lio-sam要订阅lio_sam/mapping/odometry话题（或者lio_sam/mapping/odometry_incremental，这两个都行，odometry_incremental是odometry使用IMU加权过的，差别不大），这些都可以在算法的Map节点里找到。我看很多博客上对lego/lio的欧拉角进行了转化再保存，实际上它们都有自己发布的odom信息，直接订阅就可以保存了。
void path_save(nav_msgs::Odometry odomAftMapped ){ //保存轨迹，path_save是文件目录,txt文件提前建好,/home/xxx/xxx.txt, std::ofstream pose1(“path_save”, std::ios::app); pose1.setf(std::ios::scientific, std::ios::floatfield); pose1.precision(9); static double timeStart = odomAftMapped.header.stamp.toSec(); auto T1 =ros::Time().fromSec(timeStart) ; pose1&lt;&lt; odomAftMapped.header.stamp -T1&lt;&lt; " " &lt;&lt; -odomAftMapped.pose.pose.position.y &lt;&lt; " " &lt;&lt; odomAftMapped.pose.pose.position.z &lt;&lt; " " &lt;&lt; odomAftMapped.pose.pose.position.x &lt;&lt; " " &lt;&lt; odomAftMapped.pose.pose.orientation.x &lt;&lt; " " &lt;&lt; odomAftMapped.pose.pose.orientation.y &lt;&lt; " " &lt;&lt; odomAftMapped.pose.pose.orientation.z &lt;&lt; " " &lt;&lt; odomAftMapped.pose.pose.orientation.w &lt;&lt; std::endl; pose1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8aa7e408c6096bee6cd824e9201d0093/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bbf70c063e0621dda07dfa1fa2f3ae9/" rel="bookmark">
			使用Amazon SageMaker构建高质量AI作画模型Stable Diffusion
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Amazon SageMaker构建高质量AI作画模型Stable Diffusion 0. 前言1. Amazon SageMaker 与机器学习1.1 机器学习流程1.2 Amazon SageMaker 简介1.3 Amazon SageMaker 优势 2. AIGC 与 Stable Diffusion2.1 步入 AIGC 时代2.2 Stable Diffusion 介绍 3. 使用 Amazon SageMaker 创建 Stable Diffusion 模型3.1 准备工作3.2 创建 Amazon SageMaker Notebook 实例3.3 端到端体验 AIGC3.4 模型生成效果 5. Amazon SageMaker 使用体验小结云上探索实验室活动 0. 前言 近来，随着新一代 AI 大型聊天机器人 ChatGPT 火遍科技圈，人工智能生成内容( Artificial Intelligence Generated Content, AIGC )这一领域开始受到学术界、工业界甚至普通用户的广泛关注。AIGC 凭借其独特的“创造力”与人类无法企及的创作生成速度掀起了一股人工智能狂潮。但是，利用人工智能模型生成图片、视频等要用到大量数据训练模型，对于算力的要求相较于简单模型也呈指数级的提升，为了快速高效的处理数据集和构建生成模型，在云中训练和部署人工智能模型成为大多数用户和公司的首选。
最近受邀参加了亚马逊云科技的云上探索实验室活动，并基于 Amazon SageMaker 创建、部署了 Stable Diffusion 生成模型，用于生成高质量图片，在整个模型构建流程中充分体验到 Amazon SageMaker 提供的全面的机器学习工具带来的优势，能够更快速、高效地执行机器学习任务，同时还具有灵活性、扩展性和易用性等诸多优势。接下来，我们一起回顾生成模型模型构建的全部流程吧！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bbf70c063e0621dda07dfa1fa2f3ae9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f37026e1841c751ac3784bbbbf5cf7f0/" rel="bookmark">
			目录导航《100天精通Python丨快速入门到黑科技》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、100 天精通 Python 丨基础知识篇基础知识篇 —— 01、C 站最全 Python 标准库总结基础知识篇 —— 02、Python 和 Pycharm（语言特点、学习方法、工具安装）基础知识篇 —— 03、Pycharm 快捷操作和配置指南（磨刀不误砍柴工）基础知识篇 —— 04、Python 基础知识扫盲（第一个 Python 程序，13 个小知识点）基础知识篇 —— 05、7 大基础数据类型详解（变量、列表、集合、字典、元组）基础知识篇 —— 06、一千个程序员有一千套编码规范基础知识篇 —— 07、C 站最全 Python 高级库总结基础知识篇 —— 08、Python 最常用的 20 个包（按使用频率排序）西红柿正在废寝忘食，玩命更新中...... 二、100 天精通 Python 丨办公效率篇办公效率篇 —— 10、Python 自动化操作 office-excel（读写、增删改查、分组统计）办公效率篇 —— 11、Python 自动化操作 Email（发送邮件、收邮件、邮箱客户端）办公效率篇 —— 12、Python 自动化操作 office-word（word 转 pdf、转 docx、段落、表格、标题、页面、格式）办公效率篇 —— 13、探查数据库，生成质量报告（mysql、oracle）西红柿正在废寝忘食，玩命更新中...... 三、100 天精通 Python 丨黑科技篇黑科技篇 —— 20、Python 修图（滤镜、灰度、裁剪、视觉处理、图像分割、特征提取）黑科技篇 —— 21、ChatGPT、ChatGPT、ChatGPT黑科技篇 —— 22、游戏内容分析（大吉大利）黑科技篇 —— 23、千图成像，爱心加倍（程序员的浪漫）黑科技篇 —— 24、英雄属性面板分析 ① 掌握爬虫技术；②Python 数据可视化黑科技篇 —— 25、爬取评论 ＞ 结巴分词 ＞ 制作词云黑科技篇 —— 26、代理ip技术（request）西红柿正在废寝忘食，玩命更新中.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f37026e1841c751ac3784bbbbf5cf7f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e11ff46b8c4aa11866bcd3ab4f152d00/" rel="bookmark">
			web期末大作业--网页设计 HTML&#43;CSS&#43;JS（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，作品介绍
二.运用知识
三.作品详情
四.部分作品效果图
我的：​编辑 五.部分源代码
六.文件目录
七.源码
一，作品介绍 作品介绍：该作品是一个是一个关于影视作品的网页，一共有五个页面，主页，最新，排行，我的，联系我们
二.运用知识 1.HTML是超文本标记语言，是为浏览器设计的语言，用于在Web上传输信息。HTML的编写比较简单，只要记住基本的语法就可以。
2.CSS是由W3C组织制定的一种用来定义样式规则(如字体、颜色和位置)的语言，能让网页制作者有效地定制、改善网页的显示效果。
3.JavaScript是一种轻型的脚本语言，它与HTML相结合，可以增强功能，提高与用户之间的交互性。主要利用的是Java来进行编写。JSP全称Java Server Page，是由HTML语句和嵌套在其中的Java代码构成的文件，文件扩展名为jsp。浏览器访问JSP页面时，Web容器把HTML原封不动地发送给浏览器，嵌套在&lt;%&gt;之间的Java代码被解释执行，其中outprint(或println)语句输出的内容则被按顺序插入到该对&lt;%&gt;在JSP文件中的出现位置处，同HTML-同输出给浏览器。
三.作品详情 1.首页：主打影视内容的网站，有导航栏，通过导航栏可进入不同的页面，还有搜索框，可搜索自己想要寻找的内容，接着分为两部分，一部分是热播剧，一部分是电影，电影也有分类，可根据自己的爱好去选择。
2.我的：点击进去之后可以登录页面，一旁有一个跳转到注册页面的按钮，如果你没有账号，就可以点击这个按钮跳转到注册页面，跳转到注册页面后，就可以注册，注册成功后也会跳转到登录页面，注册页面旁边也有一个可以跳转到登录页面，如果你已经注册了，可以直接跳转到登录页面登录，登录成功后就可以跳转到首页。
3.联系我们：这个页面有一些表格，你可以写下自己的信息和意见，如果你对于这个网页的内容有感到不满意的地方可以填写意见，侧栏还有一些关于内容的提示。
4.最新：里面的内容是最新更新的一些影视剧，有最新的更新日期和排行在前的更新剧。
5.排行：里面是一些大家热爱的剧，根据热度排行。
四.部分作品效果图 首页：
排行： 我的： 五.部分源代码 HTML：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/css/bootstrap.min.css"&gt; &lt;script src="https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.staticfile.org/popper.js/1.15.0/umd/popper.min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="/CSS/common.css"&gt; &lt;link rel="stylesheet" href="/CSS/index.css"&gt; &lt;title&gt;主页&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;nav class="navbar navbar-expand-lg navbar-light bg-light"&gt; &lt;div class="container-fluid"&gt; &lt;a class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e11ff46b8c4aa11866bcd3ab4f152d00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2dda38f5cc4d7794e331c5d4ab29d11/" rel="bookmark">
			【数据结构】树和二叉树——堆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🍉一.树的概念及结构🍉
1.树的概念
2.树的相关术语
3.树的表示
4.树在实际中的应用
🍊二.二叉树的概念和结构🍊
1.二叉树的概念
2.特殊的二叉树
2.1.满二叉树
2..2.完全二叉树
3.二叉树的性质
4.二叉树的存储结构
4.1.顺序存储
4.2.链式存储
🍎三.堆的顺序结构和实现🍎
1.二叉树的顺序结构
2.堆的概念及结构
3.堆的实现
3.1向上调整算法
3.2向下调整算法
3.3堆的构建
3.4堆的插入
3.5堆的删除
3.6堆的初始化
3.7堆的销毁
🍏四.堆的应用🍏
1.堆排序
2.TOP-K问题
🍉一.树的概念及结构🍉 🍏1.树的概念🍏 树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
1.有一个特殊的节点，称为根节点，根节点没有前驱节点
2.除根节点外，其余节点被分为M（M&gt;0）个互不相交的集合T1,T2,T3..Tm,其中每一个集合Ti(1&lt;=i&lt;=m)又是一颗结构与树类似的子树。每颗子树的根节点有且只有一个前驱，可以有0个或多个后继
3.因此，树是递归定义的
注意：树形结构中，子树之间不能有交集，否则就不是树形结构
🍊2.树的相关术语🍊 节点的度：一个节点含有的子树的个数称为该节点的度；如上图：A的度为6，D的度为1，E的度为2，B的度为0。
叶节点或终端节点：度为0的节点称为叶节点；如上图，B,C,H,I,K,L,M,N,P,Q为叶节点。
非终端节点或分支节点：度不为0的节点；如上图：A,D,E,F,G,J为分支节点。
双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；如上图，A是B的父节点。
孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；如上图，B，C,D,E,F,G是A的孩子节点。
兄弟节点：具有相同父节点的节点互称为兄弟节点；如上图，B，C互为兄弟节点。
树的度：一棵树中，最大的节点的度称为树的度；如上图，节点的度最大为6，故树的度为6。
节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推。
树的高度或深度：树中节点的最大层次；如上图，树的高度为4。
堂兄弟节点：双亲在同一层的节点互为堂兄弟节点；如上图，H，I互为堂兄弟节点。
节点的祖先：从根到该节点所经分支上的所有节点；如上图，P的祖先为J,E,A。
子孙：以某节点为根的子树中任一节点都称为该节点的子孙；如上图，所有节点都是A的子孙。
森林：由m（m&gt;0）棵互不相交的树的集合称为森林；
🍋3.树的表示🍋 树结构相对线性表就比较复杂了，要存储表示起来就比较麻烦了 ，既要保存值域，也要保存结点和结点之间的关系，实际中树有很多种表示方式如：双亲表示法，孩子表示法、孩子双亲表示法以及孩子兄弟表示法等。我们这里就简单的了解其中最常用的 孩子兄弟表示法 孩子兄弟法即只让父节点只指向自己的一个孩子，然后被指向的孩子指向自己的兄弟节点，这样找到被指向的孩子就可以找到所有的孩子 typedef int DataType; struct Node { struct Node* _firstChild1; // 第一个孩子结点 struct Node* _pNextBrother; // 指向其下一个兄弟结点 DataType _data; // 结点中的数据域 }; 🍌4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2dda38f5cc4d7794e331c5d4ab29d11/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/67/">«</a>
	<span class="pagination__item pagination__item--current">68/71</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/69/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>