<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27f5f8ca22ced6eb090a743815560467/" rel="bookmark">
			llama-factory SFT系列教程 (一)，大模型 API 部署与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 背景简介难点 前置条件1. 大模型 api 部署下一步阅读 背景 本来今天没有计划学 llama-factory，逐步跟着github的文档走，发现这框架确实挺方便，逐渐掌握了一些。
最近想使用 SFT 微调大模型，llama-factory 是使用非常广泛的大模型微调框架；
简介 基于 llama_factory 微调 qwen/Qwen-7B，qwen/Qwen-7B-Chat
我使用的是 qwen/Qwen-7B，如果追求对话效果qwen/Qwen-7B-Chat的效果会好一点；
本系列的主要工作如下：
大模型 api 部署；直接部署开源大模型体验一下；增加自定义数据集；为实现SFT准备数据；大模型 lora 微调；原始模型 + 微调后的lora插件，完成 api 部署； 使用 llama_factory 的 API 部署有 vllm加速推理；
文章目录：
llama-factory SFT系列教程 (一)，大模型 API 部署与使用llama-factory SFT系列教程 (二)，大模型在自定义数据集 lora 训练与部署
llama-factory SFT系列教程 (三)，chatglm3-6B 命名实体识别实战
llama-factory SFT 系列教程 (四)，lora sft 微调后，使用vllm加速推理 难点 可能遇到的一些难点：
llama_factory 默认从 Huggingface下载模型，要改为从modelscope下载模型权重；
前置条件 llama_factory 装包
git clone https://github.com/hiyouga/LLaMA-Factory.git # conda create -n llama_factory python=3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27f5f8ca22ced6eb090a743815560467/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27684670a76001085a5586cc338e2431/" rel="bookmark">
			MongoDB观点：让生成式AI成为业务增长的新动能，游戏公司可以这样做
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着OpenAI的ChatGPT和谷歌的Bard AI等工具面向公众开放，人工智能（AI），特别是生成式AI成为大众关注的焦点。这种AI热潮也席卷了企业界，激发了企业对利用AI技术提高竞争力的浓厚兴趣。根据埃森哲发布的《2023年技术愿景》报告，全球的受访企业高管几乎一致（98%）认为，未来三至五年内，AI基础模型会对组织战略产生极为关键的影响。在游戏行业，很多公司早已开始积极探索并采用AI技术。
用AI，也要防AI 游戏行业已经有很多使用AI技术的案例，例如游戏AI在很多复杂对局类游戏中多次击败职业战队，AI托管等功能能够模拟玩家战力，还能跟真实玩家一起打配合等。此外，目前游戏行业在前期游戏开发的美术概念设计、人物合成配音以及后期运营中也都开始使用AI技术，毫无疑问未来将有越来越多的AI技术出现在游戏场景中。
生成式AI的迅猛发展给游戏行业带来了诸多优势，但同时也不可避免带来了一些风险。游戏公司需要确保其使用AI技术生成的内容不会受到数据安全、隐私、内容质量、道德伦理、AI幻觉（即生成的内容包含错误、虚假或无法反映真实世界的信息）的影响。这些问题可能会导致用户数据和隐私泄露、游戏中出现错误和虚假信息，甚至出现违反法律法规的内容等，从而导致降低游戏体验、误导玩家、影响企业声誉等等。
全球范围内已有一些国家和地区正在率先改进现有技术框架，并发布相关指导方针和原则，以促进AI的公平性、伦理性、问责制和透明度。2023年7月，中国发布首部生成式AI监管办法，对生成式AI服务治理提出多项规定。在总则部分，该《办法》提到，“提升生成式人工智能服务的透明度，提高生成内容的准确性和可靠性。”
在企业层面，游戏公司可以采用各种策略来减轻AI幻觉，降低产生不准确或误导性信息的风险。
检索增强生成（RAG）是其中一种极具潜力的方法。
通过采用这种方法，大语言模型（LLM）可以从训练数据源以外的预先确定和授权的知识库中检索信息，从而提高大型语言模型的输出，而LLM是生成式AI模型的基础。这样，不仅能够为LLM提供最新的专有信息，还能确保生成式AI输出的相关性和准确性。
游戏公司应用RAG技术的一个很好的例子，是构建虚拟客服或AI助手（聊天机器人）为玩家提供服务。通过让聊天机器人访问安全的客户关系管理（CRM）数据，如过往服务对话和记录，可以提升其与玩家之间的对话定制能力，并跟进现有服务请求。
向量搜索是一种支持企业实施RAG架构的常用机制，如MongoDB Atlas Vector Search, 可根据条目目的向量及其特征或属性的数值表示来进行搜索。向量搜索通过比较向量之间的相似性来执行搜索任务，而无需逐一比较每个条目，因此相比传统文档搜索更加高效、快捷。
利用现代化开发者数据平台增强AI功能 为了最大限度地发挥AI的潜力，同时将相关风险降至最低，游戏公司需要专注于确保正确的数据设置。企业应使用包含文档云数据库和服务的数据平台，例如MongoDB Atlas。这类平台有助于确保企业保持竞争力，并获得及时准确的数据。
点击【阅读原文】访问MongoDB中文官网了解Atlas
● 文档数据库的灵活性
传统数据库通常采用表或图等结构存储数据，而文档数据库更加灵活，可以处理不同类型的数据结构、格式或源，其中包括富对象、表以及图的节点和边等。
使用文档数据库，开发者无需预先定义文档中的表格、名称或字段，且可以随时修改结构，极大地提升了灵活性。
这种灵活性使游戏公司能够更加轻松地适应数据或应用程序功能的变化，并在无需对数据设置做出重大调整的情况下集成AI工具。具体而言，公司可以轻松、快捷地向文档数据库添加新的信息字段，而其他数据库类型（如表格数据库）则需要开发者修改表结构。
很多企业面临的最大痛点在于旧系统缺乏灵活性，阻碍了与先进技术的无缝集成。然而，通过创建具有灵活文档模型的操作数据存储（ODS）系统，企业能够实时高效地处理大量数据，从而获取最新、最准确的数据。**这对游戏企业保持灵活性，并适应政策法规、玩家偏好、市场环境的变化至关重要。**借助基于灵活文档数据库的最新数据训练的AI模型，游戏公司可以更好地管理风险、把握新机遇，并在快节奏的行业中保持领先地位。
● 无缝集成
所有生成式AI应用程序的构建都离不开基础数据和向量数据的联合使用。企业可将这些数据类型无缝集成到单一平台，从而解锁一系列好处。传统设置往往将向量数据与基础数据分开，而统一平台可消除成本高、风险大、关键信息检索延迟等缺点。将基础数据和向量数据整合到单一平台，可为开发者提供基本工具，使他们能够轻松、高效地构建生成式AI应用程序。
● 安全保障
现代化开发者数据平台还提供了内置安全控制措施，不仅可以保护敏感的用户数据，还可以降低外部方未经授权访问的风险。无论是在本地部署还是云托管，身份验证（单点登录和多因素身份验证）、基于角色的访问控制和全面的数据加密等安全功能，可以为用户提供强大的安全性保障。
结语 ChatGPT可以说是AI行业的分水岭。生成式AI技术将深刻地改变人们的生活和企业运营方式——企业可以一边制定计划、一边加速创新，双管齐下，充分把握该技术带来的机遇。在这方面，数据的准确性、及时性和相关性至关重要，而游戏公司具有海量的用户和场景数据，这一得天独厚的优势让游戏公司相比其他行业更加能够发挥这项技术的潜力，助推企业蓬勃发展。
MongoDB Atlas MongoDB Atlas 是 MongoDB 公司提供的 MongoDB 云服务，由 MongoDB 数据库的开发团队构建和运维，可以在AWS、Microsoft Azure、Google Cloud Platform 云平台上轻松部署、运营和扩展。MongoDB Atlas 内建了 MongoDB 安全和运维最佳实践，可自动完成基础设施的部署、数据库的构建、高可用部署、数据的全球分发、备份等即费时又需要大量经验运维工作。让您通过简单的界面和 API 就可以完成这些工作，由此您可以将更多宝贵的时间花在构建您的应用上。
👉点击访问 MongoDB中文官网
👉立即免费试用 MongoDB Atlas
☎️需要支持？欢迎联系我们：400-8662988
✅欢迎关注MongoDB微信订阅号（MongoDB-China），及时获取最新资讯。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88c7707597053b0092319b48f65d444f/" rel="bookmark">
			Spring Boot 3.2.5 集成 MyBatisPlus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前置条件，先连接好数据库，并且数据库里新建表插入几条数据 连接mysql传送门
版本 Spring Boot 3.2.5
第一步，添加依赖 &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-spring-boot3-starter&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt; &lt;/dependency&gt; 第二步，添加yml配置 mybatis-plus: mapper-locations: classpath*:/mapper/*Mapper.xml type-aliases-package: com.example.arrow_smart_toilet_back_01.mapper configuration: map-underscore-to-camel-case: true log-impl: org.apache.ibatis.logging.stdout.StdOutImpl global-config: banner: true db-config: id-type: auto logic-delete-field: deleted logic-not-delete-value: 0 logic-delete-value: 1 extension: enabled: true mapper-package: com.example.arrow_smart_toilet_back_01.mapper data-permission: enabled: true 第三步，配置全局扫描mapper 第四步，编写mapper代码,（如需自定义sql脚本需要在mapper.xml里编写sql代码） 第五步，测试代码并且访问接口 连接成功！希望对你有帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70da332fd0b4f716a2eea13c75296f90/" rel="bookmark">
			电影交流|基于SprinBoot&#43;vue的电影交流平台小程序系统(源码&#43;数据库&#43;文档)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电影交流平台目录
目录
基于SprinBoot+vue的电影交流平台小程序系统 一、前言 二、系统设计
三、系统功能设计 1用户信息管理
2 电影信息管理
3公告信息管理
4论坛信息管理
四、数据库设计
五、核心代码 六、论文参考
七、最新计算机毕设选题推荐
八、源码获取：
博主介绍：✌️大厂码农|毕设布道师，阿里云开发社区乘风者计划专家博主，CSDN平台Java领域优质创作者，专注于大学生项目实战开发、讲解和毕业答疑辅导。✌️
主要项目：小程序、SpringBoot、SSM、Vue、Html、Jsp、Nodejs等设计与开发。
🍅文末获取源码联系🍅
基于SprinBoot+vue的电影交流平台小程序系统 一、前言 电影交流平台小程序使用Java语言进行编码，使用Mysql创建数据表保存本系统产生的数据。系统可以提供信息显示和相应服务，其管理电影交流平台小程序信息，查看电影交流平台小程序信息，管理电影交流平台小程序。
总之，电影交流平台小程序集中管理信息，有着保密性强，效率高，存储空间大，成本低等诸多优点。它可以降低信息管理成本，实现信息管理计算机化。
关键词：电影交流平台小程序；Java语言；Mysql
二、系统设计 系统功能结构如图
三、系统功能设计 1用户信息管理 如图5.1显示的就是用户信息管理页面，此页面提供给管理员的功能有：用户信息的查询管理，可以删除用户信息、修改用户信息、新增用户信息，
还进行了对用户名称的模糊查询的条件
图5.1 用户信息管理页面 2 电影信息管理 如图5.2显示的就是电影信息管理页面，此页面提供给管理员的功能有：查看已发布的电影信息数据，修改电影信息，电影信息作废，即可删除，还进行了对电影信息名称的模糊查询 电影信息信息的类型查询等等一些条件。
图5.2 电影信息管理页面 3公告信息管理 如图5.3显示的就是公告信息管理页面，此页面提供给管理员的功能有：根据公告信息进行条件查询，还可以对公告信息进行新增、修改、查询操作等等。
图5.3 公告信息管理页面
4论坛信息管理 如图5.4显示的就是论坛信息管理页面，此页面提供给管理员的功能有：根据论坛信息进行新增、修改、查询操作等等。
图5.4 论坛信息管理页面
四、数据库设计 1）下图是客服聊天实体和其具备的属性。
客服聊天实体属性图
（2）下图是电影评价实体和其具备的属性。
电影评价实体属性图
（3）下图是用户实体和其具备的属性。
用户实体属性图
（4）下图是通知公告实体和其具备的属性。
通知公告实体属性图
数据库表的设计，如下表：
表4.1客服聊天表
序号
列名
数据类型
说明
允许空
1
Id
Int
id
否
2
yonghu_id
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70da332fd0b4f716a2eea13c75296f90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf09b67bd92ad3f49ea5282533dc4fb4/" rel="bookmark">
			AI聊天 AI绘画 AI视频 AI制作PPT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录：
一：AI聊天
二：AI绘画
三：AI视频
四：AI制作PPT
这些平台工具太多了，我列举一些我用过还可以的，如果亲，您有什么推荐的，可以在下面评论留言，我到时补充上去！ 这里主要放一些国内我感觉好用的，国外或者更多请移步——&gt;AI-Chat_Draw_Video_PPT
一：AI聊天 搜索AI伙伴：百度旗下，聊天，写代码【代码能力强】
豆包：字节跳动 抖音旗下，聊天，画画，音乐电台【有很多智能体库】
讯飞星火认知大模型 ：科大讯飞旗下，PPT，绘画，编程，简历生成，不同角色【可以加入插件】
文心一言：百度旗下，聊天，绘画，流程图【可以加入插件】
智谱清言：清华大学实验室研发，聊天，写代码，文档操作
360智脑 - 体验平台：360旗下，不同角色，绘画，写代码
通义千问：阿里巴巴旗下
腾讯混元：腾讯旗下
天工AI搜索：聊天，创作，阅读【可以对网页信息进行分析】
面壁露卡：面壁智能旗下
百川大模型：聊天，写代码
插件：进去搜索下载（iTab新标签页、Wetab 新标签页）安装到浏览器即可，里面有内置组件
YMI.AI-快捷、高效的人工智能創作平台：聊天，绘画，初始3000积分可以签到获取积分
AIWritingPal - AI：有不同角色，每月2000字数
分享账号：和GPT类似【国外】
BingAI：微软旗下，三种对话模式【国外】
Google Bard：谷歌旗下【国外】
xAI Grok：马斯克旗下【国外】
二：AI绘画 商汤秒画 ：商汤旗下【免费】
文心一言：百度旗下，聊天，绘画，流程图，可以加入插件
讯飞星火认知大模型 ：科大讯飞旗下，PPT，绘画，编程，简历生成，不同角色【可以加入插件】
XCole：初始130能量
360智脑 - 体验平台：360旗下，不同角色，绘画，写代码
360智绘：360旗下，初始100图豆
360鸿图：360旗下
海艺seaart：个人感觉质量美感还是不错的，也会有意境【国外】
PlaygroundAl：每天1000张图片，个人感觉质量美感还是不错的，通过输入描述可编辑图片【国外】
三：AI视频 数字人：免费
腾讯智影：比较贵
四：AI制作PPT 讯飞智文 ：好用的，初始用户1000积分，需要登陆
MindShow ：可以试用【免费】
BusinessAI：对话【免费】
灵感PPT：初始1500积分，可以设置页数
秒出PPT，10秒做出PPT：需要注册登录，可以在其基础上进行修改
ChatPPT_AI：百度的
讯飞星火认知大模型 ：科大讯飞旗下，PPT，绘画，编程，简历生成，不同角色【可以加入插件】
Gamma PPT ：好用的，初始用户400积分【国外】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87bd916d73d937e9675e1bb2ccf48522/" rel="bookmark">
			Hive面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hive：分布式SQL计算工具
作用：将SQL语句解析成MapReduce程序运行
架构：Metastore元数据存储 +Driver驱动解析SQL+用户接口
目录
1.Hive的SQL解析过程
2.Hive与数据库的区别
3.内部表和外部表
4.分桶表和分区表
5.Hive的四个by排序
6.开窗函数
7.表连接方式
8.union和union all区别
9.Delet/Drop/Truncate区别
10.count详解
11.join的实现
1.Hive的SQL解析过程 SQL--&gt;抽象语法树--&gt;查询块--&gt;逻辑计划--&gt;物理计划（MRjob）
解析器： 将 SQL 字符串转换成抽象语法树（ AST ） 语义分析器：将抽象语法树进一步抽象为基本的查询单元 查询块（QueryBlock） 逻辑计划生成器：通过遍历查询块 ，生成逻辑计划 逻辑优化器 ：对逻辑计划进行优化 物理计划生成器 ：根据优化后的逻辑计划生成物理计划（MR任务） 物理优化器 ：对物理计划进行优化 执行器：执行该计划（MR任务），得到查询结果并返回给客户端 2.Hive与数据库的区别 数据存储：Hive数据存储在HDFS中；数据库将数据保存在块设备或者本地文件系统中。数据格式：Hive可以指定数据格式（指定列分隔符，行分隔符）；数据库由数据引擎定义数据格式。数据更新：Hive的内容是读多写少的，不建议对数据改写；数据库中的数据通常是需要经常进行修改。执行延迟：Hive 执行延迟较高，数据库的执行延迟较低。Hive只有在大数据规模下才有优势。索引：Hive没有，数据库有。数据规模：Hive 支持很大规模的数据计算；数据库可以支持的数据规模较小。 3.内部表和外部表 内部表：保存元数据和原始数据，删除时会全部删除。外部表：只保存元数据，删除后表的原始数据还在。 使用场景：绝大多数是外部表，防止数据误删，相对来说安全一些，同时也方便共享源数据。
4.分桶表和分区表 分区表：按照指定列对数据进行分区，分区相当于将表拆分到不同文件夹中进行存储，一个分区代表一个文件夹，查询时使用分区字段筛选数据可以直接找的对应的目录，避免全表扫描，提高查询效率。分桶表：按照指定列对数据进行分桶，分桶相当于将表拆分到不同文件中进行存储，一个桶代表一个文件，查询时使用分桶字段可以直接定位到对应的分桶，避免全表扫描。 分桶列相同的数据一定在同一个桶内，所以基于分桶列的特定操作（过滤、分组、join）均可以带来性能提升。 使用场景：分区表适合用于多条数据有相同字段值的情况，比如所属分类、日期；分桶表适合用于数据字段没有重复值的情况，或者分区太多更不利于查询的情况，比如表id。
如何进行分桶：假设分桶数量为3，首先计算分桶列的hash值，然后基于分桶数3进行取模，结果为0.1.2分别进入3个桶。
5.Hive的四个by排序 order by：全局排序，默认只走一个reduce，当数据量非常大时，耗时太长，效率低下，适用于数据量较小的场景。 select * from emp order by sal desc; sort by：在数据进入reducer前完成排序，每个reducer内部排序 ，不保证全局有序；适用于数据量较大，但对排序要求不严格的场合，可以大幅度提升执行效率。 set mapreduce.job.reduces=3 #预先设置reducer数量 set mapreduce.job.reduces; select * from emp sort by deptno desc; distribute by：相当于分区，按照指定的字段对数据进行划分输出到不同的reducer中，默认使用hash值取余数方法，常和sort by一起使用。 hive (default)&gt; set mapreduce.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87bd916d73d937e9675e1bb2ccf48522/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0a3c8a19c3c096cfe2ec53280f89612/" rel="bookmark">
			【大数据】分布式数据库HBase
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.概述
1.1.前言
1.2.数据模型
1.3.列式存储的优势
2.实现原理
2.1.region
2.2.LSM树
2.3.完整读写过程
2.4.master的作用
1.概述 1.1.前言 本文式作者大数据系列专栏中的一篇文章，按照专栏来阅读，循序渐进能更好的理解，专栏地址：
https://blog.csdn.net/joker_zjn/category_12631789.html?spm=1001.2014.3001.5482
当前的分布式数据库其实都是参考的Google的BigTable，所以学习分布式数据库之前先学一下BigTable会一通百通。专栏中有对BigTable进行介绍的前文：
【大数据】bigtable，分布式数据库的鼻祖-CSDN博客
分布式数据库底层依托于分部署文件系统进行存储，分布式数据库更像在分布式文件系统上做了一层封装。就像BigTable底层依托于GFS一样，HBase底层依托于HDFS，专栏有专门介绍HDFS的文章：
【大数据】分布式文件系统HDFS-CSDN博客
1.2.数据模型 HBase中一个具体的数据由行键、列族、列限定符、时间戳组成。数据类型是不定的，统一存储为Bytes数组。
之所以有时间戳是因为HBASE底层是用的HDFS来做存储的，HDFS只支持追加写，所以HBASE为了实现删除效果只能用时间戳来区分哪个数据是最新的。
列族是个很核心的概念，底层的物理存储以列族为单位进行存储，支持动态扩展，一个列族其实就是HDFS中的一个文件，同一列族下的数据一定是被存到HDFS中的一个文件中的。
​
1.3.列式存储的优势 大数据技术中为什么采用列式存储：
HDBASE采用的这种存储模式叫列式存储，传统的关系型数据库采用的行式存储，大数据中普遍都采用列式存储。大数据中之所以采用列式存储是因为列式存储往往更有利于分析，当需要做指标统计的时候往往只需要访问一个列即可，而且列族在物理磁盘上是连续存储的，速度会很快。行式存储要进行指标统计的时候要访问很多无用的列，而且数据在物理磁盘上也不是连续存储的，性能不会很好。
比如数据表是这样：
​行式和列式的区别会是：
2.实现原理 2.1.region HBase最核心的概念！！！
hbase的架构直接参照bigtable即可，只是改了个名字。bigtable的核心是tablet，HBase的核心是region，存储region的服务器叫region server，对应bigtable中的tablet server。一个表会按照行键的字典序列进行排布，然后被分成多个region：
​
如何找到要的region？
HBASE参照BigTable的三层结构也维护了一个类树状结构用来快速查找到要的region：
叶子节点是region、meta表负责维护树形的层级结构，一个meta对应多个region，root只有一个，对应多个meta。
​
层次名称作用第一层root表记录了META表的位置信息第二层meta表记录了region表的位置信息，meta表相当于一个集合，将region分块的管理，用来维护了层级结构第三层用户表用来记录用户数据 2.2.LSM树 LSM树是一种专门针对海量数据读写而升的数据结构，前文中作者聊bigtable的时候单独写了一篇文章对LSM树进行过讲解，可移步：
【大数据】LSM树，专为海量数据读写而生的数据结构-CSDN博客
同样HBASE中也用了LSM树，也有类似于memtable和sstable的东西：
memstore-&gt;memtable
storefile-&gt;sstable
这里HBase和bigtable唯一有区别的就是bigtable的一个tablet里只会有一条线的memtable和sstable，而HBase由于支持多个列族所以会有多条线的memtable和sstable。
​
2.3.完整读写过程 写过程：
​
客户端发起写请求 客户端应用通过HBase客户端API（如Java API）向HBase提交一个PUT请求，包含待写入的数据（包括RowKey、列族、列限定符、值以及可选的时间戳等）。
定位目标Region 访问ZooKeeper：客户端首先访问ZooKeeper集群，先查询hbase:root表以获取hbase:meta表所在的Region Server位置。 缓存元数据：客户端将获取到的元数据信息（如hbase:meta表或目标Region的位置）缓存在本地Client Cache中，以减少后续操作对ZooKeeper的依赖和网络开销。
查找目标Region 查询元数据表：客户端使用缓存的信息连接到hbase:meta表所在的Region Server，根据待写入数据的RowKey在hbase:meta表中查找目标Region的位置。这个过程可能涉及Region的三层定位（Namespace、表名、RowKey区间），确保找到正确的Region负责处理该RowKey的数据。 更新缓存：客户端将查询到的目标Region的位置信息（包括Region Server地址和Region边界）更新到本地缓存中。
与目标Region Server交互 发送写请求：客户端根据缓存中的信息，向目标Region Server发送实际的PUT请求。
Region Server内部处理 追加写入HLog（WAL，Write Ahead og）：Region Server接收到PUT请求后，首先将写操作作为一条日志记录追加到HLog。HLog是一种预写式日志，用于保证在发生故障时能够恢复未持久化到磁盘的数据。 随机写入MemStore：接着，Region Server将数据随机写入对应Region的MemStore。MemStore是内存中的数据结构，用于临时存储待写入HFile（HBase的数据文件）的修改。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0a3c8a19c3c096cfe2ec53280f89612/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa2cae71a9dc733bc35ae558a30104e2/" rel="bookmark">
			如何在虚拟专用服务器上配置 Nginx Web 服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文档涵盖的是不再受支持的 Ubuntu 版本。如果您目前正在运行 Ubuntu 12.04 服务器，我们强烈建议升级或迁移到受支持的 Ubuntu 版本：
升级到 Ubuntu 14.04从 Ubuntu 14.04 升级到 Ubuntu 16.04将服务器数据迁移到受支持的版本 原因： Ubuntu 12.04 已于 2017 年 4 月 28 日到达生命周期终点（EOL），不再接收安全补丁或更新。本指南不再维护。
请参阅：
本指南可能仍然作为参考有用，但可能不适用于其他 Ubuntu 版本。如果可能的话，我们强烈建议使用适用于您使用的 Ubuntu 版本的指南。您可以使用页面顶部的搜索功能查找更新版本。
什么是 Nginx？ Nginx 是一个 Web 服务器和反向代理服务器。它已经被广泛采用，并正在取代许多其他常见选项。
虽然 Nginx 是一个强大的工具，但对于那些来自其他服务器或对 Web 服务器不熟悉的人来说，它的配置可能会令人生畏。在本指南中，我们将探讨主要的 Nginx 配置文件，并揭开一些语法和选项的神秘面纱。
我们将使用 Ubuntu 12.04 安装，但大多数发行版都将配置为具有类似的文件位置。
Nginx 配置目录层次结构 Nginx 将其配置文件存储在 “/etc/nginx” 目录中。
在此目录中，您将找到一些目录和各种模块化配置文件：
cd /etc/nginx ls -F conf.d/ koi-win naxsi.rules scgi_params uwsgi_params fastcgi_params mime.types nginx.conf sites-available/ win-utf koi-utf naxsi_core.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa2cae71a9dc733bc35ae558a30104e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fc61c6166626046a1e4a19882e30aa7/" rel="bookmark">
			MySQL 数据库的特点和优势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 开源免费 MySQL 是一种开源数据库管理系统，用户可以免费使用、修改和分发。其开源性使得 MySQL 成为了许多开发者和组织的首选数据库解决方案，同时也促进了数据库技术的创新和发展。
2. 高性能和稳定性 MySQL 具有出色的性能和稳定性，能够处理大规模数据和高并发访问。其优化的存储引擎和查询执行引擎，以及对事务处理的支持，使得 MySQL 在各种应用场景下都能够提供高效的数据处理能力。
3. 易用性和可管理性 MySQL 提供了直观的管理工具和丰富的文档支持，使其易于学习和使用。用户可以通过简单的 SQL 查询语句就能够实现对数据库的管理、维护和优化，同时也能够进行监控和性能调优。
4. 可扩展性和灵活性 MySQL 支持水平和垂直扩展，可以根据需要进行灵活的扩展和部署。其集群和复制功能使得 MySQL 在大规模应用和高可用性需求的场景中表现出色。
5. 安全性和权限控制 MySQL 提供了丰富的安全功能和权限控制，可以保护数据不受未授权访问。其支持的加密连接、身份验证和访问控制机制，为用户的数据提供了可靠的保护。
6. 广泛的应用场景 MySQL 在各种应用场景中都发挥着重要的作用，包括 Web 开发、企业应用、数据分析等领域。其稳定性、性能和灵活性，使得 MySQL 成为了众多应用的首选数据库解决方案。
结语 MySQL 作为一种开源、高性能且功能丰富的数据库管理系统，具有诸多优秀的特性和优势，为用户和开发者提供了强大的数据库解决方案。随着数据处理需求的不断增长和多样化，MySQL 将继续发挥其重要作用，并为用户带来更好的数据库体验。
如果您对 MySQL 数据库的特点和优势有更多的兴趣和疑问，欢迎留言讨论，我将继续为您带来更多有关 MySQL 的精彩内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9df022403f497c2fcb926dd92a1551fd/" rel="bookmark">
			一文教你在windows上实现ollama&#43;open webui、外网访问本地模型、ollama使用GPU加速
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： ollama工具的出现让大语言模型的部署变得格外的轻松，但是在windows系统部署之后发现无法使用GPU进行加速，通过多方面查找资料发现可以在docker中使用命令启用GPU加速。另外通过Docker也可以快速部署open webui,于是本文基于docker实现ollama模型的部署，以及webui部署。
最终部署成功后可以实现公网访问本地大语言模型功能。
目录： 安装docker
在docker中安装ollama
在docker中安装webui
内网穿透实现公网访问本地大语言模型
环境： 系统：windows10
CPU：i5-9400
GPU：GTX1050ti
内容 安装docker 第一步：启动Hyper-v 如果之前没有安装过docker，需要先进行设置一下。
依次打开 控制面板&gt;程序&gt;程序和功能&gt;启用或关闭windows功能
勾选Hyper-V、虚拟机平台、Linux子系统并点击确认
确认后重启计算机
第二步：安装WSL 打开 powershell，以管理员的身份启动命令窗口
输入
wsl --update 安装
wsl --install 安装成功后重启电脑
第三步：访问Docker官网进行下载 点击下载链接：https://docs.docker.com/desktop/install/windows-install/
下载完成后，双击安装程序进行安装，如果是第一次安装，安装后会提示重启电脑，重启后点击桌面的Docker Desktop图标：选择先不注册直接登录即可。
打开Docker Desktop后，左下角显示是绿色的running就代表我们成功了：
在docker中使用GPU运行ollama 第一步：安装英伟达容器安装包 打开之前安装的ubuntu
依次将一下命令输入ubuntu
配置apt源
curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \ &amp;&amp; curl -s -L https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list | \ sed 's#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g' | \ sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.list 更新源
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9df022403f497c2fcb926dd92a1551fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfb711eafcedf5a9048ed1a287004e2e/" rel="bookmark">
			【JS】前端文件读取FileReader操作总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：开发中经常遇到文件上传的场景，有时需要前端将文件内容读取出来再以base64格式传到接口。
目录 FileReader主要方法readAsArrayBuffer(blob)readAsText(blob, [encoding])readAsDataURL(blob) 主要事件React + antd Upload 组件示例 FileReader FileReader 是一个对象，允许 Web 应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。
构造函数：
let reader = new FileReader(); // 没有参数 主要方法 readAsArrayBuffer(blob) 将数据读取为二进制格式的 ArrayBuffer。当读取操作完成时，readyState 变成 DONE（已完成），并触发 loadend 事件，同时 result 属性中将包含一个 ArrayBuffer 对象以表示所读取文件的数据。
reader.readAsArrayBuffer(blob) readAsText(blob, [encoding]) 将数据读取为给定编码（默认为 utf-8 编码）的文本字符串。
instanceOfFileReader.readAsText(blob[, encoding]); readAsDataURL(blob) 读取二进制数据，并将其编码为 base64 的 data url。
reader.readAsDataURL(blob); 读取方法都是异步的，也就是说只有当执行完成后才能够查看到结果，如果直接查看是无结果的，并返回 undefined。必须要挂载 实例下的 onload 或 onloadend 的方法才能处理转化后的结果
FileReader的三个属性：
error: 返回读取时的错误信息readyState: 返回操作的当前状态result: 返回读取文件的结果 读取文件的示例：
参考 https://blog.csdn.net/qq_60440599/article/details/136071142
&lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfb711eafcedf5a9048ed1a287004e2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6168494b39f43824639edea522966fbf/" rel="bookmark">
			CentOS7安装并配置Yearning并实现无公网IP远程SQL审核与数据查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
​编辑
前言
1. Linux 部署Yearning
2. 本地访问Yearning
3. Linux 安装cpolar
4. 配置Yearning公网访问地址
5. 公网远程访问Yearning管理界面
6. 固定Yearning公网地址
结语
前言 作者简介： 懒大王敲代码，计算机专业应届生
今天给大家聊聊CentOS7安装并配置Yearning并实现无公网IP远程SQL审核与数据查询，希望大家能觉得实用！
欢迎大家点赞 👍 收藏 ⭐ 加关注哦！💖💖 个人主页：
懒大王敲代码-CSDN博客https://blog.csdn.net/weixin_58070962?type=blog
其他专栏：
技术分享专栏http://t.csdnimg.cn/LVrbCjava专栏http://t.csdnimg.cn/bw2Thubantu与C语言学习专栏http://t.csdnimg.cn/A8yIivue3项目实战专栏http://t.csdnimg.cn/vP2no内网穿透专栏http://t.csdnimg.cn/GJZJA懒大王闲谈专栏http://t.csdnimg.cn/KxzqY
本文主要介绍在 Linux 系统简单部署 Yearning 并结合 cpolar 内网穿透工具实现远程访问，破除局域网访问限制，提高工作效率！
Yearning 简单, 高效的MYSQL 审计平台 一款MYSQL SQL语句/查询审计工具，为DBA与开发人员使用.本地部署，注重隐私，简单高效的MYSQL审计平台。
1. Linux 部署Yearning 在Github上下载对应的Linux 安装包:https://github.com/cookieY/Yearning/releases/latest
下载后把安装包上传到Linux 中,这里上传到/usr/local文件夹下面
然后解压文件
unzip 文件名 解压后可以看到一个名叫Yearning的文件夹,
进入Yearning文件夹,可以看到配置文件:conf.toml
接下来需要修改配置文件,配置mysql数据库连接,如未安装mysql 需提前安装好,然后登录mysql,创建一个名字叫,Yearning的数据库!
然后编辑配置文件:
vim conf.toml 设置连接mysql的信息,主要是设置连接mysql用户名和密码
设置完成保存配置文件,执行下面命令进行安装,注意,当前目录必须保持在解压的Yearning文件夹中.
./Yearning install 执行后,可以看到如下信息,登陆web 界面的用户名和密码,还有访问web 界面的端口:8000
然后运行Yearning,当然,这个命令我们可以使用nohup 在后台运行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6168494b39f43824639edea522966fbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0326a68432e9386bac1cceb2ad012824/" rel="bookmark">
			【数据结构】单链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页点这里~
原代码在gitee里~
单链表 一、链表的概念及结构二、单链表的实现project.hproject.ctest.c 一、链表的概念及结构 链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的
与顺序表不同的是，链表里的每个存储单元叫做节点，都是独立申请下来的空间，节点由两部分组成：当前节点要保存的数据和下一个节点的指针变量
我们创建一个变量为plist指向第一个数据
链表中每个节点都是独立申请的，我们需要通过指针变量来保存下一个节点位置才能从当前节点找到下一个节点
我们用结构体来实现这个单链表
当节点数据类型为整形时：
struct SListNode { int data; //节点数据 struct SListNode* next; //指针变量⽤保存下⼀个节点的地址 }; 链式结构在逻辑上是连续的，在物理结构上不一定连续
节点一般是在堆上申请的
从堆上申请来的空间，可能连续可能不连续
二、单链表的实现 project.h #pragma once #include &lt;stdio.h&gt; #include &lt;assert.h&gt; typedef int SLTDataType; typedef struct SListNode { SLTDataType data; //节点数据 struct SListNode* next; //指针保存下⼀个节点的地址 }SLTNode; void SLTPrint(SLTNode* phead); //头部插⼊删除/尾部插⼊删除 void SLTPushBack(SLTNode** pphead, SLTDataType x); void SLTPushFront(SLTNode** pphead, SLTDataType x); void SLTPopBack(SLTNode** pphead); void SLTPopFront(SLTNode** pphead); //查找 SLTNode* SLTFind(SLTNode* phead, SLTDataType x); //在指定位置之前插⼊数据 void SLTInsert(SLTNode** pphead, SLTNode* pos, SLTDataType x); //删除pos节点 void SLTErase(SLTNode** pphead, SLTNode* pos); //在指定位置之后插⼊数据 void SLTInsertAfter(SLTNode* pos, SLTDataType x); //删除pos之后的节点 void SLTEraseAfter(SLTNode* pos); //销毁链表 void SListDesTroy(SLTNode** pphead); project.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0326a68432e9386bac1cceb2ad012824/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7192eb03a82b0f75d23ae443e4fdb6ac/" rel="bookmark">
			【链表】：必写的四道基础题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎁个人主页：我们的五年
🔍系列专栏：每日一练
🌷追光的人，终会万丈光芒
目录
🏝问题1：反转链表
⛷问题描述：​编辑
⛷ 问题分析：
⛷代码实现：
🏝问题2：寻找链表的中间节
⛷问题描述：
⛷问题分析：
⛷代码实现：
🏝问题3：返回单链表的倒数第K个节点的值
⛷问题描述：
⛷问题分析： ⛷代码实现：
🏝问题4：合并两个有序链表
⛷问题描述：
⛷问题分析：
⛷代码实现：
前言：
这篇文章会给大家带来几道经典的单链表题目，这些题目的步骤，可能会在一些难的题目中作为基本步骤，也就是难的题目也会应用到这些思想。
比如：
反转一个单链表，寻找一个单链表的中间节点，找到单链表的倒数第K个节点等。
🏝问题1：反转链表 【LeetCode】链接：. - 力扣（LeetCode）
⛷问题描述：
⛷ 问题分析： ●原链表是：1&gt;2&gt;3&gt;4&gt;5
●我们只需要把2节点指向1，3节点指向2……
●但是最重要的还是把1的next指针置为空，不然还是指向2节点，2节点也是指向1节点，就会形成环，所以我们可以先申请一个头节点为NULL，第1个节点指向NULL，然后2&gt;1,3&gt;2,4&gt;3,5&gt;4
●在循环的过程中，要把pcur指向的next指向前一个节点的指针，如果不做任何操作，就直接把next指向newhead，我们就找不到pcur的下一个节点了，所以要先保存下一个节点的指针，然后再去改变pcur的next指针。
⛷代码实现： /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ typedef struct ListNode ListNode; struct ListNode* reverseList(struct ListNode* head) { ListNode* newhead=NULL; ListNode* pcur=head; while(pcur) { ListNode* pnext=pcur-&gt;next; pcur-&gt;next=newhead; newhead=pcur; pcur=pnext; } return newhead; } 🏝问题2：寻找链表的中间节 【LeetCode】链接:.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7192eb03a82b0f75d23ae443e4fdb6ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5648e1393587d75ab322ec0fba6731e3/" rel="bookmark">
			7.MyBatis 操作数据库(初阶)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.什么是MyBatis2.为什么要学习 MyBatis？3.通过spring框架创建MyBatis项目3.1使用MyBatis查询数据库3.2 mysql连接不上报错解决方法 4.MyBatis的基础操作4.1企业建表规范：4.2MyBatis基本实现4.3单元测试4.4使用MyBatis可能遇到的问题4.5配置MyBatis相关日志4.6打印MyBatis的日志配置4.7MyBatis增删查改 - 注解方式4.7.1增加4.7.1.1插入数据4.7.1.2如何获得自增ID4.7.1.3参数为对象时，对参数进行重命名 4.7.2删除4.7.2.1删除数据 4.7.3更改4.7.3.1更改数据 4.7.4查询4.7.4.1查询数据 (与3.1一致)4.7.4.2如果mysql字段名和Java对象的属性不一致4.7.4.2.1对mysql查询结果进行重命名4.7.4.2.2使用@Results注解4.7.4.2.3自动转驼峰 4.8传递参数 5.学习XML5.1学习xml的方式5.2xml常见问题5.3xml实现增删查改5.3.1增5.3.2删5.3.3改5.3.4查 5.4如果mysql字段名和Java对象的属性不一致 6.其他查询操作6.1多表查询6.2#{}和${}6.3排序功能6.3.1 SQL中Group by排序讲解：6.3.1.1sum + group by：6.3.1.2avg + group by：6.3.1.3max + group by6.3.1.4min + group by6.3.1.5Where + group by6.3.1.6having + group by6.3.1.7where + having + group by6.3.1.8count + group by6.3.1.9 min+max+sum+avg+count()+group by+having+as 6.3.2代码排序6.3.3SQL注入问题(重点)6.3.3.1恶意拼接6.3.3.2利用注释执行非法命令6.3.3.3传入非法参数6.3.3.4添加额外条件 6.3.4如何避免SQL注入6.3.5mybatis中#和$的区别(重点) 6.4like 查询 7.数据库连接池7.1介绍7.2使用 大家好，我是晓星航。今天为大家带来的是 MyBatis 操作数据库(初阶) 相关的讲解！😀
1.什么是MyBatis MyBatis 是⼀款优秀的持久层框架，它⽀持⾃定义 SQL、存储过程以及⾼级映射。MyBatis 去除了⼏ 乎所有的 JDBC 代码以及设置参数和获取结果集的⼯作。MyBatis 可以通过简单的 XML 或注解来配置 和映射原始类型、接⼝和 Java POJO（Plain Old Java Objects，普通⽼式 Java 对象）为数据库中的 记录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5648e1393587d75ab322ec0fba6731e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c1ca4b69b3f921c56e6f5487a4db9ae/" rel="bookmark">
			详解MySQL C API 相关接口(大白话就是：MySQL的c语言怎么写)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、C API 官方文档2、初始化 MYSQL3、连接 MySQL设置连接字符集（使得客户端编码方式匹配） 4、下发 mysql 指令5、获取 mysql 查询结果(保存起来)获取行与列遍历存储结果 6、释放 MYSQL\_RES 对象7、关闭 MySQL 连接8、总结 1、C API 官方文档 关于C语言连接数据所涉及到的各种数据结构的介绍以及相关函数的使用其实在 MySQL C API 官方文档中已经给出了，我们可以通过它来快速了解并上手 MySQL C API。
2、初始化 MYSQL 要使用 MySQL C语言库，需要先使用 mysql_init 函数完成对 MYSQL 结构体指针的初始化工作。
MYSQL *mysql_init(MYSQL *mysql) 函数返回值：失败返回 NULL。 注意：mysql_init 函数的参数以及返回值都是 MYSQL 指针类型，对于 MYSQL，大家把它类比到C语言中的文件指针来理解即可。MYSQL 和C语言文件 FILE 一样，本质上都是一个结构体。
MYSQL *mfp = mysql_init(nullptr); if(mfp == nullptr) { cerr &lt;&lt; "mysql init error" &lt;&lt; endl; return 1; } cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c1ca4b69b3f921c56e6f5487a4db9ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aabadcef9243650858755aa73b73ade1/" rel="bookmark">
			如何看待当下AIGC技术？请思考我回答
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、引言
1.1 简述AIGC技术的定义和发展背景
1.2 引出对AIGC技术当前状态及未来发展的讨论
二、AIGC技术的核心优势
2.1 高效的内容生成能力
2.2 广泛的应用场景
三、AIGC技术面临的挑战和问题
3.1 数据安全和隐私保护
3.2 技术瓶颈与创新需求
四、AIGC技术的发展趋势与前景
4.1 技术不断进步与应用拓展
4.2 伦理与社会影响的考量
五、结论
一、引言 1.1 简述AIGC技术的定义和发展背景 AIGC，即人工智能生成内容（Artificial Intelligence Generated Content），是近年来随着人工智能技术的快速发展而兴起的一种新型内容生成方式。它利用深度学习、自然语言处理、计算机视觉等先进技术，使机器能够模仿人类的创作过程，生成文字、图像、音频、视频等多种形式的内容。
AIGC技术的发展背景主要源于两方面。一方面，随着大数据和计算能力的提升，人工智能算法得以不断优化，使得机器能够更准确地理解和生成内容。另一方面，随着人们对个性化、多样化内容的需求日益增长，传统的内容生产方式已无法满足市场需求，而AIGC技术正好能够弥补这一缺口，提供高效、灵活的内容生成解决方案。
1.2 引出对AIGC技术当前状态及未来发展的讨论 当前，AIGC技术已经取得了显著的进展，并在多个领域得到了广泛应用。例如，在文学创作领域，AIGC技术能够生成具有创意和文学性的文章；在新闻报道领域，它可以根据实时数据自动生成新闻稿件；在艺术设计领域，AIGC技术能够创作出具有独特风格的画作和设计作品。
然而，尽管AIGC技术已经取得了一定的成果，但它仍面临着诸多挑战和限制。例如，机器生成的内容往往缺乏人类创作的深度和情感；同时，由于技术的限制，AIGC技术在某些领域的应用仍不够成熟。
未来，随着技术的不断进步和算法的持续优化，AIGC技术有望在更多领域发挥更大的作用。我们可以预见，未来的AIGC技术将更加智能化、个性化，能够更准确地理解用户需求，生成更符合用户口味的内容。同时，随着技术的不断完善，AIGC技术也将逐渐克服当前存在的限制，为人类创造更加丰富多彩的内容世界。
二、AIGC技术的核心优势 2.1 高效的内容生成能力 AIGC技术的核心优势之一在于其高效的内容生成能力。借助深度学习和大数据分析，AIGC系统可以快速地处理和分析大量的数据，从中提取出有价值的信息，并据此生成内容。这种自动化的生产方式不仅极大地提高了内容生产的效率，还降低了人力成本，使得内容生产变得更加经济高效。
此外，AIGC技术还能根据用户的个性化需求进行内容生成。通过理解用户的喜好、兴趣和需求，AIGC系统可以生成更符合用户口味的内容，从而提升用户体验。这种个性化的内容生成方式不仅满足了用户的多样化需求，还增强了用户与内容之间的互动性，进一步提升了内容的吸引力。
2.2 广泛的应用场景 AIGC技术的应用场景十分广泛，几乎涵盖了所有需要内容生成的领域。在新闻报道方面，AIGC技术可以根据实时数据自动生成新闻稿件，为新闻媒体提供快速、准确的内容来源。在广告创意领域，AIGC技术可以生成具有创意和吸引力的广告内容，帮助品牌更好地传达其价值和理念。在文学创作领域，AIGC技术可以辅助作家进行创作，提供灵感和素材，丰富作品的内容和形式。
除了这些传统的应用领域，AIGC技术还在其他行业中发挥着越来越重要的作用。例如，在教育领域，AIGC技术可以生成个性化的学习资源和辅导材料，帮助学生更好地掌握知识；在娱乐产业中，AIGC技术可以生成虚拟角色和场景，为游戏、电影等提供丰富的素材和创意。
三、AIGC技术面临的挑战和问题 3.1 数据安全和隐私保护 在AIGC技术的应用过程中，用户数据扮演着至关重要的角色。然而，这也带来了数据安全和隐私保护方面的挑战。AIGC系统需要收集、分析和处理用户的个人信息、喜好等数据，以生成符合用户需求的内容。然而，如果这些数据被不当使用或泄露，将可能导致严重的隐私泄露问题，给用户带来损失和风险。
因此，加强数据保护和隐私安全的措施变得尤为重要。这包括采取先进的技术手段保护用户数据的安全，如数据加密、访问控制等；同时，还需要建立完善的隐私政策和用户协议，明确告知用户数据收集、使用和共享的方式，确保用户的知情权和选择权。
3.2 技术瓶颈与创新需求 尽管AIGC技术在内容生成方面已经取得了显著的进步，但仍面临着一些技术瓶颈。目前，AIGC技术在内容多样性、创意性等方面仍存在一定的局限性。例如，在文学创作领域，尽管AIGC可以生成通顺的文章，但其内容往往缺乏深度和创新性，难以与人类作品相媲美。
为了突破这些限制，推动技术创新是至关重要的。这包括研究更先进的算法和模型，以提升AIGC技术在内容生成方面的能力和质量；同时，还需要探索新的应用场景和商业模式，以拓展AIGC技术的应用范围和商业价值。
四、AIGC技术的发展趋势与前景 4.1 技术不断进步与应用拓展 随着技术的不断进步，AIGC技术将在未来呈现出更加广阔的发展空间和更加丰富的应用场景。一方面，深度学习、自然语言处理、计算机视觉等核心技术的持续创新将推动AIGC技术在内容生成的质量和效率上实现新的突破。另一方面，随着大数据和云计算等基础设施的完善，AIGC技术将能够处理更大规模、更复杂的数据，从而生成更加精准、个性化的内容。
在应用领域方面，AIGC技术将逐渐渗透到更多的行业和领域。除了目前已经在文学创作、新闻报道、广告创意等领域得到广泛应用外，未来AIGC技术还将进一步拓展到教育、医疗、娱乐等更多领域。例如，在教育领域，AIGC技术可以为学生提供更加个性化、智能化的学习资源和辅导；在医疗领域，AIGC技术可以帮助医生更快速地获取和分析病人的医疗数据，提供精准的诊疗建议。
4.2 伦理与社会影响的考量 随着AIGC技术的快速发展和广泛应用，我们也需要关注其带来的伦理和社会影响。首先，数据安全和隐私保护是AIGC技术发展中必须重视的问题。我们需要确保用户数据的安全性和隐私性，防止数据被滥用或泄露。其次，AIGC技术生成的内容可能存在版权和知识产权的问题，需要制定明确的法律和规范来保障创作者的权益。此外，AIGC技术还可能对就业市场和社会结构产生影响，我们需要关注这些变化并采取相应的措施来应对。
在技术发展的过程中，我们应该始终强调技术应造福人类的原则。我们需要确保AIGC技术的发展符合社会的价值观和道德标准，避免其带来的负面影响。同时，我们也应该积极探索AIGC技术的正面应用，利用其优势为人类创造更多的价值。
五、结论 首先，AIGC技术以其高效的内容生成能力和广泛的应用场景展现出强大的市场潜力。无论是新闻报道、广告创意还是文学创作，AIGC技术都能够快速、准确地生成内容，满足用户个性化需求，提升用户体验。这种自动化的生产方式不仅提高了生产效率，还降低了成本，为各行各业带来了全新的机遇。 然而，AIGC技术也面临着数据安全和隐私保护、技术瓶颈与创新需求等挑战。在享受技术带来的便利的同时，我们必须重视用户数据的安全性和隐私性，防止数据被滥用或泄露。同时，我们也需要关注AIGC技术在内容多样性、创意性等方面的局限性，并推动技术创新以突破这些限制。 展望未来，AIGC技术的发展趋势将更加明朗。随着技术的不断进步和应用领域的拓展，AIGC技术将在更多领域发挥重要作用。同时，我们也需要关注其伦理和社会影响，确保技术的发展符合社会的价值观和道德标准。 因此，我们呼吁理性看待AIGC技术，既要看到其带来的机遇和优势，也要正视其面临的挑战和问题。只有积极应对挑战，推动AIGC技术的健康发展，才能使其真正为人类创造更多的价值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1a966c886f6715ee3beb5687d66df93/" rel="bookmark">
			【Java--数据结构】链表经典OJ题详解（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎关注个人主页：逸狼
创造不易，可以点点赞吗~
如有错误，欢迎指出~
目录
谈谈头插、头删、尾插、头插的时间复杂度
反转一个单链表 链表的中间结点
返回倒数第k个结点
合并两个链表
谈谈头插、头删、尾插、头插的时间复杂度 头插和头删的时间复杂度为O（1），
尾插和尾删的时间复杂度为O（n） (因为尾插和尾删要一个个遍历完链表)
反转一个单链表 OJ链接
采用头插法
创建cur指针使得cur=head.next
将head.next置空（作为尾节点）(注意要判断head为空的情况，return head,否则会报空指针异常)
创建curN指针使得curN=cur.next让cur.next=headhead=cur 1~3步是一个循环，进入循环条件是cur!=null（即当cur为空时，代表cur已经遍历完链表）
class Solution { public ListNode reverseList(ListNode head) { if(head==null){ return head; } //正常情况 ListNode cur=head.next; head.next=null; while(cur!=null){ ListNode curN=cur.next; cur.next=head; head=cur; cur=curN; } return head; } } 链表的中间结点 给定一个带有头结点 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结 点。OJ链接
快慢指针法
定义一个慢指针slow（每次走一步），一个快指针fast(每次走两步)
即slow=slow.nextfast=fast.next.next 这是一个循环，进入循环的条件为fast!=null&amp;&amp;fast.next!=null（这两个条件不可以交换，否则当fast=null时，先判断fast.next!=null时，会出现空指针异常）
fast!=null针对的是链表长度是奇数的情况
fast.next!=null针对的是链表长度是偶数的情况
class Solution { public ListNode middleNode(ListNode head) { ListNode slow=head; ListNode fast=head; while(fast!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1a966c886f6715ee3beb5687d66df93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1db32014b677b1e8905e5315a7ed520/" rel="bookmark">
			基于SpringBoot和Leaflet的地震台网信息预警可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、后台管理设计与实现
1、Model层
2、业务层
3、控制层
二、前端预警可视化设计与实现
1、网页结构
2、数据绑定
三、效果展示
总结
前言 在之前的几篇博客中，我们讲解了如何在Leaflet中进行预警信息提示效果，以及基于XxlCrawler进行中国地震台网信息的采集、入库以及如何进行反爬处理。博文目录如下，感兴趣的朋友可以点击标题进入：
序号博客地址1基于Leaflet.js的Marker闪烁特效的实现-模拟预警2基于Java的XxlCrawler网络信息爬取实战-以中国地震台网为例3使用SpringBoot将中国地震台网数据保存PostGIS数据库实践4在Java中使用XxlCrawler时防止被反爬的几种方式 在实际应用中，我们不仅需要将数据及时的采集回来，同时也需要实现对数据进行可视化。不仅对二维数据的列表展示，同时还需要对数据进行空间可视化。
本文即对采集回来的中国地震台网数据进行预警可视化进行深入讲解。首先讲解后台的代码和功能设计，然后基于L.Icon.Pulse进行地震预警展示，最后展示预警可视化效果。地址灾害不可预测，但是我们在灾后应该快速提供应急救援，将尽量减少人民群众的生命财产损失。如果您目前也有类似的需求，不妨来博文中指导一二。
一、后台管理设计与实现 后台管理使用SpringBoot框架来开发，数据库访问层依然采用熟悉的Mybatis-Plus框架。本小节将主要基于MVC结构介绍后台的相关设计与实现。数据后台提供数据访问支持，为前台的数据展示提供有效支撑。
1、Model层 model层包含地震台网数据的实体类，在之前的博客中有过介绍，这里也将主要的代码分享出来。让大家在熟悉这部分代码时，不至于有不适感：
package com.yelang.project.extend.earthquake.domain.crawler; import java.io.Serializable; import java.math.BigDecimal; import java.util.Date; import com.baomidou.mybatisplus.annotation.TableField; import com.baomidou.mybatisplus.annotation.TableId; import com.baomidou.mybatisplus.annotation.TableName; import com.google.gson.annotations.SerializedName; import com.yelang.framework.handler.PgGeometryTypeHandler; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import lombok.ToString; @Data @ToString @AllArgsConstructor @NoArgsConstructor @TableName(value ="biz_ceic_earthquake",autoResultMap = true) public class CeicEarthquake implements Serializable{ private static final long serialVersionUID = -1212153879708670015L; @TableId(value="pk_id") private Long pkId;//主键 @SerializedName("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1db32014b677b1e8905e5315a7ed520/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42030ba12059debcaf1ae53f57fc6df2/" rel="bookmark">
			MySQL-----多表查询（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.多表关系：
1.1 一对多(多对一)：
1.2 多对多:
1.3 一对一:
二.多表查询概述：
三.连接查询：
3.1内连接：
3.2外连接：
3.3自连接查询：
3.4联合查询：
一.多表关系： 项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：
一对多(多对一)多对多一对一 1.1 一对多(多对一)： 案例: 部门 与 员工的关系关系: 一个部门对应多个员工，一个员工对应一个部门实现: 在多的一方建立外键，指向一的一方的主键 大致关系图（展示部分）：
对应SQL脚本：
create table dept( id int auto_increment comment 'ID' primary key, name varchar(50) not null comment '部门名称' )comment '部门表'; INSERT INTO dept (id, name) VALUES (1, '研发部'), (2, '市场部'),(3, '财务部'), (4, '销售部'), (5, '总经办'); create table emp( id int auto_increment comment 'ID' primary key, name varchar(50) not null comment '姓名', age int comment '年龄', job varchar(20) comment '职位', salary int comment '薪资', entrydate date comment '入职时间', managerid int comment '直属领导ID', dept_id int comment '部门ID' )comment '员工表'; INSERT INTO emp (id, name, age, job,salary, entrydate, managerid, dept_id) VALUES (1, '金庸', 66, '总裁',20000, '2000-01-01', null,5),(2, '张无忌', 20, '项目经理',12500, '2005-12-05', 1,1), (3, '杨逍', 33, '开发', 8400,'2000-11-03', 2,1),(4, '韦一笑', 48, '开 发',11000, '2002-02-05', 2,1), (5, '常遇春', 43, '开发',10500, '2004-09-07', 3,1),(6, '小昭', 19, '程 序员鼓励师',6600, '2004-10-12', 2,1); -- 添加外键约束 alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id); 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42030ba12059debcaf1ae53f57fc6df2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/31/">«</a>
	<span class="pagination__item pagination__item--current">32/71</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/33/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>