<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d15f10472419eeaba416ea08e43b98d/" rel="bookmark">
			C&#43;&#43;使用类的一些注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 本篇内容为前面的补充，介绍了我们使用类时需要注意些什么以及一些编译器的优化，可能有些理解不到位或者错误，请斧正。 目录
前言：
1.再谈构造函数
2.（c++98）隐式类型转换中的编译器的优化
3.explicit关键字
4.static成员
5.匿名对象
6.友元函数
7.内部类
8.编译器的一些场上的优化
总结：
若有歧义，请指出，感谢阅读！
1.再谈构造函数 我们在构造函数体中，给成员变量赋值能叫做成员变量的初始化吗？并不可以，这种行为只是给成员变量赋初值，在函数体中，我们可以多次赋值，而初始化只能初始化一次。
那该如何初始化呢？
使用初始化列表。以一个冒号开始，接着是一个以逗号分割的数据成员列表，每个成员变量的后面跟一个放在括号中的初始值表达式。
class Date { public: Date(int year, int month, int day) :_year(year) ,_month(month) ,_day(day) {} private: int _year; int _month; int _day; }; 那像const这样的必须在定义位置的初始化的，放在成员变量里面该怎么初始化呢？
可以给缺省值，但不是初始化：
class A { public: A() :_x(1) { _a1++; } private: int _a1 = 1; int _a2 = 2; const int _x;//可以给缺省值，但不是初始化 }; 另外，缺省值也会在初始化列表进行初始化：
如上图我们可以看到， _a1的结果是2，虽然没有在初始化列表中显示的初始化，但是还是会走初始化列表初始化；其次_a2的结果是0，虽然_a2的缺省值是2，但是在初始化列表中显示的初始化为了1，所以再--就是0。而对于即不给缺省值也不给初始化的普通成员变量，经过测试，那就是随机值。
对于成员变量是引用的与成员变量是自定义类型的：
class B { public: B(int b) :_b(0) { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d15f10472419eeaba416ea08e43b98d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a5b4b7540dc113ac023f605e508357d/" rel="bookmark">
			Kafka的配置和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.服务器用docker安装kafka
2.springboot集成kafka实现生产者和消费者
1.服务器用docker安装kafka ①、安装docker（docker类似于linux的软件商店，下载所有应用都能从docker去下载）
a、自动安装 curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun
b、启动docker
sudo systemctl start docker
c、 通过运行hello-world镜像来验证是否正确安装了Docker Engine-Community。
// 拉取镜像
sudo docker pull hello-world
// 执行
hello-world sudo docker run hello-world
d、安装成功
②、zookeeper
a、docker search zookeeper
b、docker pull zookeeper
③、安装kafka
a、docker search kafka
b、docker pull wurstmeister/kafka
④、运行zookeeper
a、docker run -d --restart=always --log-driver json-file --log-opt max-size=100m --log-opt max-file=2 --name zookeeper -p 2181:2181 -v /etc/localtime:/etc/localtime zookeeper
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a5b4b7540dc113ac023f605e508357d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3c42b7eafba2c8a4cd0d1fae7ae2e8c/" rel="bookmark">
			uniapp纯h5的vue页面和上级webview通信 - window.postMessage方式 - 纯H5版vue页面中的webview无法捕捉html文件的uni.postMessage消息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		示例图 问题 问题1：纯H5版vue页面中的uni.postMessage报错未定义 - js文件引用、npm引用都不行；
问题2：H5环境下的webview无法捕捉hybrid/html文件的uni.postMessage消息 - 一点反应都没有；
解决办法 1.纯H5版vue页面中的uni.postMessage报错未定义，那就另辟蹊径，
webview中的vue页面先通过window.location.href跳到项目的hybrid/html某页面中，
再按照官方手册即可引入"uni.webview.1.5.5.js"，即可使用
uni.webView.postMessage({
data: JSON.stringify(sendData)
})
2.H5环境下的webview无法捕捉hybrid/html文件的uni.postMessage消息？
看以下完整代码
window.addEventListener("message", (event) =&gt; {
// 全量打印
console.log(event)
}, false)
完整代码 hybrid/html
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt; &lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt; &lt;!-- 主业务操作 --&gt; &lt;script type="text/javascript" src="../static/js/uni.webview.1.5.5.js"&gt;&lt;/script&gt; &lt;script&gt; document.addEventListener('UniAppJSBridgeReady', () =&gt; { uni.webView.getEnv((res) =&gt; { console.log('webview页面：goback') console.log('当前环境：' + JSON.stringify(res)) // pData.ready = true }) let sendData = { action: 'back', data: { url: window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3c42b7eafba2c8a4cd0d1fae7ae2e8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd4fe8b873ce5074955a2312d2b0739b/" rel="bookmark">
			Android学习笔记（四）：TextView 设置内容、字体大小、颜色、背景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如图所示，我们可以在Android手机中设置文本字体的大小、颜色，以及背景颜色。
一、TextView 设置内容 我们前面章节已经提到过，如何利用TextView模块显示文本内容，在这里再简单提及一次吧。
//strings.xml &lt;string name="hello"&gt;Hello World!&lt;/string&gt; &lt;string name="android"&gt;hello Android!&lt;/string&gt; // activity_main.xml &lt;TextView android:id="@+id/text1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/hello" /&gt; // MainActivity.java TextView textView = findViewById(R.id.text1); textView.setText(R.string.android); 想必，通过前面的学习，你已经能够读懂以上代码的含义，并且，能够在对应的文件中创建对应的值。在上面的代码中，就给出了两种设置内容的方式。
第一种，通过xml布局文件中，通过 text= 的方式设置内容。
第二种，就是通过TextView对象利用 setText 函数设置内容。
注意，xml设置是静态的，java类设置是动态的，先布局时使用静态，再用类中设置的内容动态覆写掉，所以呈现的是后者（java类设置）的内容。
二、TextView 设置字体大小 1、字体字号单位 我们先了解一下字号单位：
px（pixel像素）: 它是手机屏幕的最小显示单位，手机屏幕就是由多个像素构成的
dp（设备独立像素） : 同一单位在不同设备上有不同的显示效果。当你设置字体大小单位为dp，其实它最终还是会转换为px。
现在你可以不用太清楚他们之间的转换关系，只要知道dp以下两点特性：
1、对于相同分辨率的手机，屏幕尺寸越大，同dp的组件占用的屏幕比例越小。
2、对于相同尺寸的手机，分辨率不同，同dp的组件占用屏幕的比例是相同的。
因此，我们可以看到，当我们使用dp作为单位时，只要在同一尺寸的手机上，无论其分辨率如何，可以得到很好的适配。如果你不能够很清晰的理解，你利用Android studio创建不同尺寸，不同分辨率的手机进行实验。
除此之外，还有一个 sp ，它与dp类似，区别在于它的大小会跟随系统设置的字体大小改变。
2、设置字体大小 // MainActivity.java TextView textView2 = findViewById(R.id.text2); textView2.setTextSize(30); // activity_main.xml &lt;TextView android:id="@+id/text3" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/hello" android:textSize="35sp"/&gt; 设置字体大小也有两种方式：
1、通过TextView对象利用 setTextSize 函数设置大小，你可以看到，在这里不用给出单位，它默认单位为sp
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd4fe8b873ce5074955a2312d2b0739b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ad06973ff046b72c45d78159e8f3d6d/" rel="bookmark">
			Whisper对于中文语音识别与转写中文文本优化的实践(Python3.10)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：Whisper对于中文语音识别与转写中文文本优化的实践(Python3.10) - 知乎
阿里的FunAsr对Whisper中文领域的转写能力造成了一定的挑战，但实际上，Whisper的使用者完全可以针对中文的语音做一些优化的措施，换句话说，Whisper的“默认”形态可能在中文领域斗不过FunAsr，但是经过中文特殊优化的Whisper就未必了。
中文文本标注优化 Whisper经常被人诟病的一点是对中文语音转写后标点符号的支持不够完备。首先安装whisper:
pip install -U openai-whisper 编写转写脚本：
import whisper device = "cuda:0" if torch.cuda.is_available() else "cpu" audio = whisper.load_audio(audio_path) audio = whisper.pad_or_trim(audio) model = whisper.load_model("large-v2",download_root="./whisper_model/") mel = whisper.log_mel_spectrogram(audio).to(model.device) options = whisper.DecodingOptions(beam_size=5) result = whisper.decode(model, mel, options) print(result.text) 程序返回：
Erwin_0.wav|Erwin|ZH|如果这个作战顺利。 Erwin_1.wav|Erwin|ZH|你也许可以趁此机会干掉狩之巨人 Erwin_10.wav|Erwin|ZH|如果到時候我不衝在最前面 Erwin_11.wav|Erwin|ZH|他们根本不会往前冲然后我会第一个去死 Erwin_12.wav|Erwin|ZH|地下室里到底有什么 Erwin_13.wav|Erwin|ZH|也就无从知晓了好想去地下室看一看我之所以能撑着走到今天 Erwin_14.wav|Erwin|ZH|就是因为相信这一天的到来。 Erwin_15.wav|Erwin|ZH|因为艰辛着 Erwin_16.wav|Erwin|ZH|我才想能够得到证实 Erwin_17.wav|Erwin|ZH|我之前無數次的想過,要不然乾脆死了算了。 Erwin_18.wav|Erwin|ZH|可即便如此,我還是想要實現父親的夢想。 Erwin_19.wav|Erwin|ZH|然而现在 Erwin_2.wav|Erwin|ZH|但得拿所有新兵不管選擇哪條路 Erwin_20.wav|Erwin|ZH|她的答案就在我触手可及的地方 Erwin_21.wav|Erwin|ZH|仅在咫尺死去的同伴们也是如此吗 Erwin_22.wav|Erwin|ZH|那些流血的棲身,都是沒有意義的嗎? Erwin_23.wav|Erwin|ZH|不!不對! Erwin_24.wav|Erwin|ZH|那些死去士兵的意义将由我们来赋予 Erwin_25.wav|Erwin|ZH|那些勇敢的死者可憐的死者 Erwin_26.wav|Erwin|ZH|是他们的牺牲换来了我们活着的今天 Erwin_27.wav|Erwin|ZH|让我们能站在这里否则今天我们将会死去 Erwin_28.wav|Erwin|ZH|将依依托福给下一个活着的人 Erwin_29.wav|Erwin|ZH|这就是我们与这个残酷的世界 Erwin_3.wav|Erwin|ZH|我们基本都会死吧是的全灭的可能性相当的高 Erwin_30.wav|Erwin|ZH|抗爭的意義 Erwin_4.wav|Erwin|ZH|但事到如今,也只能做好玉石俱焚的觉悟。 Erwin_5.wav|Erwin|ZH|將一切賭在獲勝渺茫的戰術上 Erwin_6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ad06973ff046b72c45d78159e8f3d6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86a7ca9975d3b9f4ab3fc622eaf3da17/" rel="bookmark">
			2011-2023各省数字普惠金融指数（数据&#43;计算方法&#43;参考文献）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 各省数字普惠金融指数数据 最新版数据已整理为Excel格式，数据的时间区间为2011-2023年，内含“数据+计算方法+数据来源+参考文献”，欢迎下载！ 下载地址 各省数字普惠金融指数数据已更新到最新的第六期，时间区间为2011-2023年。 中国各省的数字普惠金融指数数据，从数字金融覆盖广度、数字金融使用深度和普惠金融数字化程度3个维度来构建数字普惠金融指标体系。数字普惠金融指数一共3个维度、33项具体指标。 全套指数包含数字金融覆盖广度指数、数字金融使用深度指数和普惠金融数字化程度指数，以及数字金融使用深度指数下属的支付、保险、货币基金、信用服务、投资、信贷等分类指数。 指数的计算主要分为以下三个步骤： （1）无量纲化处理：在指数合成之前，首先必须先将性质和计量单位不同的指标进行无量纲化处理。无量纲化函数的选取，一般要求严格单调、取值区间明确、结果直观、意义明确、不受指标正向或逆向形式的影响。结合数字金融快速扩张的特点，为缓解极端值的影响，保持指数的平稳性，采取对数型功效函数法。 （2）赋权方法：采用主观赋权与客观赋权相结合的方法来确定权重。先利用变异系数法求各具体指标对上一层准则层的权重，再通过层次分析法求各准则层指标对上层目标的权重。 （3）指数合成：在根据对数功效函数计算各指标得分时，各年都以基年相应指标值的上下限作为比较基准，因此指标无量纲得分有可能为0或负数，为避免最终加权汇总指数值为0，采用算术加权平均法进行指数合成。 数据已进行标准化处理，各省之间的数据可比，也可考察数据的动态变化。 数据来源权威、可靠、详实，并由中国经济研究资料室精心整理。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ada82b5c5953b27952cbd7deff908a90/" rel="bookmark">
			Android Studio制作简单登录界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Studio制作简单登录界面 实现目标 应用线性布局设计登录界面，要求点击输入学号时弹出数字键盘界面，点击输入密码时弹出字母键盘，出现的文字、数字、尺寸等全部在values文件夹下相应.xml文件中设置好，使用时直接引用。当用户名或密码为空，显示一个提示信息“用户名与密码不能为空！”，当用户名和密码匹配，显示“登录成功”。
整体效果图如下：
实现过程 新建项目 新建一个项目如图所示：
UI设计 1.新建login.xml，选择线性布局
步骤如下：
设计登录页面
LinearLayout是线性布局，布局中的组件按照垂直或者水平方向进行排列
gravity：设置自身内部元素的对齐方式layout_gravity：用来控制该控件在包含该控件的父控件中的位置
本设计采用垂直线性布局，如图所示：
控件类型: EditText 是一个允许用户输入和编辑文本的控件。
android:id: 这个属性为控件设置了一个唯一的ID（@+id/ed2），使得开发者可以在Java或Kotlin代码中通过这个ID来引用这个控件。
android:layout_width 和 android:layout_height: 这些属性定义了控件的宽度和高度。531dp 指定了宽度为531设备独立像素，wrap_content 表示高度会根据内容的大小自动调整。
实现代码如下：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/login" android:layout_width="match_parent" android:layout_height="match_parent" android:padding="25dp" android:background="@color/white" tools:context="com.example.myapplication1.LoginActivity" android:orientation="vertical" android:weightSum="1"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/login_page_title" android:textSize="@dimen/text_size_large" android:textColor="@android:color/black" android:layout_gravity="center_horizontal"/&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical" android:gravity="center" android:layout_weight="0.55"&gt; &lt;LinearLayout android:layout_width="300dp" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;TextView android:layout_width="@dimen/label_width" android:layout_height="wrap_content" android:text="@string/student_id_label" android:textSize="@dimen/text_size_medium" android:textColor="@android:color/black"/&gt; ​ &lt;EditText android:id="@+id/ed1" android:layout_width="531dp" android:layout_height="wrap_content" android:minHeight="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ada82b5c5953b27952cbd7deff908a90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8192964779b5a71b3c276790b4c237ad/" rel="bookmark">
			DataGrip连接人大金仓数据库（kingbase）详细教程【超详细】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		==========================================================================
其实就是选择我们本地仓库引入的jar包
如下图：
选择Driver Files，也就是我们本地仓库中kingbase8的jar包
从本地仓库中找到
切换Class
完成后如下图：
点击Apply保存引擎
第三步：输入账号密码连接
======================================================================
先测试连接一下
没有问题就点击OK
第四步：查看数据库
===================================================================
我们需要勾选下All database，不然看不到表数据
这样就OK了
关于连接其它数据库
===================================================================
连接其他数据库的时候，自定义性没有那么强，可以从支持的数据库中选择，上面连接kingbase数据库自定义性较强，使用DataGrip比较方便，对于MySQL这些比较常用的，使用我们比较熟悉的SQLYog、Naviate即可。
自我介绍一下，小编13年上海交大毕业，曾经在小公司待过，也去过华为、OPPO等大厂，18年进入阿里一直到现在。
深知大多数前端工程师，想要提升技能，往往是自己摸索成长或者是报班学习，但对于培训机构动则几千的学费，着实压力不小。自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年Web前端开发全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友，同时减轻大家的负担。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，基本涵盖了95%以上前端开发知识点，真正体系化！
由于文件比较大，这里只是将部分目录截图出来，每个节点里面都包含大厂面经、学习笔记、源码讲义、实战项目、讲解视频，并且会持续更新！
如果你觉得这些内容对你有帮助，可以扫码获取！！（备注：前端）
最后 本人分享一下这次字节跳动、美团、头条等大厂的面试真题涉及到的知识点，以及我个人的学习方法、学习路线等，当然也整理了一些学习文档资料出来是附赠给大家的。知识点涉及比较全面，包括但不限于前端基础，HTML，CSS，JavaScript，Vue，ES6，HTTP，浏览器，算法等等
详细大厂面试题答案、学习笔记、学习视频等资料领取，点击资料领取直通车免费领取！
前端视频资料：
大厂面试题答案、学习笔记、学习视频等资料领取，点击资料领取直通车免费领取！
[外链图片转存中…(img-Uw2yuTwE-1712093410307)]
前端视频资料：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d5a463afd63511d7f02f0b9a80bfa79/" rel="bookmark">
			【2024最新】jetbrains全家桶解锁（PyCharm,IntelliJ IDEA,PhpStorm,RubyMine,WebStorm)一键激活永久使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ##注意1：以下说明基于Windows 确保.jar文件的完整路径中不包含任何空格。
##注意2：同一时间只能使用一个javaagent，如果您正在替换/升级其他代理，请确保从vmoptions中删除相应行。
查看下面的常见问题解答以获取更多信息
此代理将激活IDE和部分插件！
/--/注意：如果您已经登录到您的JB账户，请首先退出！--
/--/注意：如果您已经安装了“IDE Eval Reset”插件，请先卸载它！--\
1）将ja-netfilter-all文件夹复制到C：
（因此，ja-netfilter.jar文件的路径应为C:\ja-netfilter-all\ja-netfilter.jar）
2）选项＃1（推荐）：
使用自动vmoptions配置程序（如果不起作用，请使用手动方式（下面的选项＃2））：
Windows：双击执行“scripts\install-current-user.vbs”（对于当前用户）
“scripts\install-all-users.vbs”（对于所有用户）
2）选项＃2：
找到所需JetBrains产品的.vmoptions文件：
这位于JetBrains IDE的bin目录中。例如：
C:\Program Files\JetBrains\IDEA\bin\idea64.exe.vmoptions
或者，如果您使用自定义VM选项，则路径可能如下，例如：
C:\Users%username%\AppData\Roaming\JetBrains\IntelliJIdea2021.3\idea64.exe.vmoptions
（注意：此文件不会默认存在，可以手动创建，也可以在IDE内部使用“编辑自定义VM选项…”菜单（如果您可以访问IDE））
因此，如果某些功能无法正常工作，请确保更改正确的文件（自定义文件优先于bin目录中的文件）
在.vmoptions文件的末尾添加以下行：
-javaagent:C:\ja-netfilter-all\ja-netfilter.jar=jetbrains
注意：
JBR17（JetBrains产品的最新版本）：
在您的vmoptions文件中添加以下2行：（用于手动操作，不包含任何空白字符）
--add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED
--add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED
3）运行JetBrains产品，选择“激活&lt;IDE名称&gt;”，选择“激活码”，
输入“激活代码”文件夹中的相应代码，然后点击激活。
完成！
注意：不要担心激活时间（如果显示激活时间），这是一个备用许可证，不会过期。
注意：此许可证可激活“Code With Me”插件！
脚本下载地址：https://www.cke66.icu/2024/04/02/jetbrains_loose/ 视频教程：【2024最新】jetbrains全家桶解锁（PyCharm,IntelliJ IDEA,PhpStorm,RubyMine,WebStorm)一键激活永久使用_哔哩哔哩_bilibili 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57de5221941bbfd5faf7350bb03b78c8/" rel="bookmark">
			【热门话题】WebKit架构简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页: 鑫宝Code
🔥热门专栏: 闲话杂谈｜ 炫酷HTML | JavaScript基础 ​💫个人格言: "如无必要，勿增实体" 文章目录 WebKit架构简介一、引言二、WebKit概览1. 起源与发展2. 模块化设计 三、WebCore详解1. DOM与CSSOM2. Render Tree与布局3. 绘图与合成4. JavaScriptCore 四、WebKit2与多进程架构五、结论 WebKit架构简介 一、引言 WebKit，作为全球范围内广泛使用的开源浏览器引擎，以其高效、稳定和跨平台特性，为诸如Apple Safari、Google Chrome（早期版本）、Amazon Kindle等众多知名应用提供核心渲染支持。深入理解Webkit的内部结构，有助于开发者更好地掌握其工作原理，优化网页性能，甚至参与社区贡献。本文将对WebKit的主要组成部分、关键技术和运行机制进行条理清晰的梳理与介绍，以期为读者构建一幅完整的WebKit架构图景。
二、WebKit概览 1. 起源与发展 WebKit源于KDE项目的KHTML浏览器引擎，于2001年被Apple公司采纳并进一步发展，成为Safari浏览器的核心。随后，WebKit凭借其卓越性能和开放源代码的优势，吸引了众多厂商与开发者加入，逐渐成为移动设备浏览器市场的主导力量。尽管Google后来基于WebKit创建了Chromium项目（采用Blink引擎），但WebKit在桌面与嵌入式系统中仍保持着重要地位。
2. 模块化设计 WebKit采用了高度模块化的架构设计，各部分职责明确，既有利于独立开发与维护，也便于第三方开发者根据需求定制或集成。主要模块包括：
WebCore：负责HTML、CSS、JavaScript等网页内容的解析、渲染、脚本执行及网络通信等核心功能。JavaScriptCore（JSC）：WebKit内置的JavaScript引擎，负责处理网页中的JS脚本。User Agent（UA）：提供浏览器标识、用户界面及特定平台适配功能。Network：处理HTTP、HTTPS等网络请求，实现缓存管理、数据压缩等功能。WebKit2（多进程架构）：为提高稳定性与安全性，WebKit2引入了多进程架构，将UI与渲染逻辑分离到单独进程中。 三、WebCore详解 1. DOM与CSSOM **DOM（Document Object Model）**是HTML文档的内存表示，用于解析、遍历和操作网页元素。WebCore通过HTML解析器（HTMLTokenizer、HTMLParser等）将HTML文本转化为DOM树结构。同时，CSS解析器将CSS样式表转化为CSSOM（CSS Object Model），并与DOM结合形成Render Tree。
2. Render Tree与布局 Render Tree由可视元素（包括DOM节点与CSSOM规则作用下的样式信息）组成，用于描绘页面的视觉呈现。Render Tree构建完成后，WebCore进行 布局（Layout） 过程，计算每个节点的几何属性（如位置、大小），确保元素间正确的相对定位。
3. 绘图与合成 绘图（Painting 阶段，WebCore将Render Tree转换为实际像素绘制到屏幕上。现代WebKit还引入了 合成（Compositing） 技术，将复杂页面划分为多个层，通过硬件加速实现高性能渲染。合成层间的层级关系、透明度、变换等属性，由LayerTree来描述和管理。
4. JavaScriptCore JavaScriptCore（JSC）是WebKit内置的高性能JavaScript引擎，遵循ECMAScript标准。其主要包括：
解析器：将JS代码转化为抽象语法树（AST）。解释器（LLInt）：执行简单、非优化的JS代码。即时编译器（FTL、DFG）：对热点代码进行优化编译，生成机器码以提升执行效率。垃圾回收：采用精确标记-清除算法管理内存。 JSC还提供了丰富的API（如WebAssembly、WebGL、WebCrypto等）以支持现代Web应用开发。
四、WebKit2与多进程架构 WebKit2引入了多进程架构，将浏览器分为以下主要进程：
UI进程：负责用户交互、窗口管理、网络请求发起等，包含User Agent模块。Web进程：负责网页内容的解析、渲染、脚本执行等，包含WebCore与JavaScriptCore。辅助进程（如GPU进程、Service Worker进程等）：处理特定任务以提升性能或实现新特。 这种架构设计旨在提升浏览器稳定性（单个页面崩溃不影响整个浏览器）、安全性（严格隔离不同网页与系统资源）以及响应速度（通过进程间通信与数据同步机制实现异步加载与渲染）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57de5221941bbfd5faf7350bb03b78c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4492afc67728daee796b4c9d8734e1ba/" rel="bookmark">
			好书推荐 《AIGC重塑金融》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：林建明
来源：IT 阅读排行榜
本文摘编自《AIGC 重塑金融：AI 大模型驱动的金融变革与实践》，机械工业出版社出版
这是最好的时代，也是最坏的时代。尽管大模型技术在金融领域具有巨大的应用潜力，但其应用也面临不容忽视的风险和挑战。本文将深入研究大模型在金融领域的数据隐私和安全风险、模型可解释性和透明度、监管和合 规要求，梳理中国、美国、欧洲等地 AIGC 技术的应用规则，探索对应的风险管理和应对策略。
01.大模型在金融领域的 5 个典型应用场景 当前，金融科技已经从 “立柱架梁” 迈入了 “积厚成势” 新阶段，越来越多的金融机构积极使用数字技术来为金融血脉注入全新能量。人工智能技术正加速与金融产业深度融合，以 ChatGPT 为代表的大模型技术不断进化，为金融业带来深刻变革，驱动金融服务更加高效、便捷、有温度。
ChatGPT 拥有持续的多轮对话能力，并具备一定逻辑推理能力，在生成文章、生成代码、翻译等方面展现出令人惊叹的水平。ChatGPT 的问世，意味着人工智能从 1.0 时代迈入了 2.0 时代。ChatGPT 背后的 GPT 大模型技术是下一代 AI 技术竞争的核心，将重新定义包括金融在内的众多行业，重塑全球科技竞争格局。
金融行业属于信息密集型行业，是大模型技术的最佳应用场景之一。未来，具有通用能力的大模型将成为信息处理的基础设施，大幅降低中小银行应用人工智能技术的门槛。由于在数字资源、科技能力、业务场景等方面的天然劣势，中小银行与大银行相比，在数字化转型方面相对落后，且差距越拉越大，“智能化鸿沟”也越来越明显。在大模型时代，各类银行重新站在同一条起跑线上，都可以便捷地使用 AI 技术，插上一双数智化 “翅膀”，曾经再“阳春白雪” 的复杂数据，也能飞入“寻常人家”。
如果将大模型的能力放在金融行业中去处理原有的任务，会对很多工作产生颠覆性的影响。相比现有的 AI 技术，大模型技术在众多金融场景具有广泛的应用潜力和影响力。
金融风险管理。大模型技术可以用于构建更准确、更全面的风险模型， 帮助金融机构评估和管理市场风险、信用风险、操作风险等，提供更 精确的风险预测和决策支持，有助于金融机构制定有效的风险管理 策略。
量化交易。大模型技术可以应用于量化交易策略的开发和执行。通过 分析海量的金融数据和市场信息，识别出潜在的交易机会和趋势，自 动执行交易策略并进行实时调整。这有助于提高交易效率，降低交易 成本，提升交易的稳定性，以及增加收益。
个性化投资建议。大模型技术可以根据个体投资者的偏好和风险承受 能力，生成个性化的投资建议和组合配置，辅助投资者做出更明智的 决策。
金融欺诈检测和预防。大模型技术可以应用于金融欺诈检测和预防。通过分析用户的交易数据、行为模式和历史记录，识别出潜在的欺诈行为和异常交易，提高金融机构对欺诈风险的识别和应对能力，保护 客户和金融系统的安全。
智能客户服务。大模型技术可以用于构建智能客户服务系统，通过提 供流畅的人机对话服务，提升客户满意度和忠诚度。
02.大模型在金融领域应用所面临的风险及其防范 自 2020 年 OpenAI 提出大语言模型的缩放法则（Scaling Law）以来，用 “大力出奇迹”的方式去做大模型仿佛成为 “金科玉律”，“大炼丹” 时代序幕 拉开，百亿、千亿参数规模的大模型比比皆是。量变引发质变，超大模型蕴 含着的涌现能力被发现，但在惊讶于这种神奇能力的同时，我们同样应该审 视其潜在风险。在斯坦福大学的学者们的眼里，大模型涌现的能力既是科学兴奋的源泉，也是意外后果的忧虑之源。换言之，如果不能引导大模型“向 善”，那么它随时可能伤及人类本身，带来不可估量的后果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4492afc67728daee796b4c9d8734e1ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/537e6b77eea55b513093feab7d25a728/" rel="bookmark">
			OpenCV与AI深度学习 | 实战 | YOLOv8自定义数据集训练实现手势识别 (标注&#43;训练&#43;预测 保姆级教程)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文来源公众号“OpenCV与AI深度学习”，仅用于学术分享，侵权删，干货满满。
原文链接：实战 | YOLOv8自定义数据集训练实现手势识别 (标注+训练+预测 保姆级教程)
0 导 读 本文将手把手教你用YoloV8训练自己的数据集并实现手势识别。
1 安装环境 【1】安装torch, torchvision对应版本，这里先下载好，直接安装
pip install torch-1.13.1+cu116-cp38-cp38-win_amd64.whl pip install torchvision-0.14.1+cu116-cp38-cp38-win_amd64.whl 安装好后可以查看是否安装成功，上面安装的gpu版本，查看指令与结果：
import torch print(torch.__version__) print(torch.cuda.is_available()) 【2】安装ultralytics
pip install ultralytics 【3】下载YoloV8预训练模型：GitHub - ultralytics/ultralytics: NEW - YOLOv8 🚀 in PyTorch &gt; ONNX &gt; OpenVINO &gt; CoreML &gt; TFLite
本文使用YOLOv8n，直接下载第一个即可
【4】运行demo测试安装是否成功：
from ultralytics import YOLO # Load a model model = YOLO('yolov8n.pt') # pretrained YOLOv8n model # Run batched inference on a list of images results = model(['1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/537e6b77eea55b513093feab7d25a728/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c88f8554671a52934aceb2881bd1c3c/" rel="bookmark">
			南京邮电大学数学实验MATLAB2023
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明 使用R2023b版本完成，参考教材为数学实验（第三版）金正猛 王正新等编 科学出版社。参考了不少前人智慧的结晶，在此表示感谢，不保证全对，仅供大家参考，请勿抄袭，有错漏、疑问之处，烦请通过QQ或者评论区留言交流指正，欢迎大家多交流。联系QQ：3468039783
模块一：基础练习 1.1 clear syms x m=628; f=(log(1+x-m*x^2)-x)/(1-cos(x)); limit(f) f=((sqrt(m*x^2+2)-atan(m*x))/x); limit(f,x,inf) pretty(limit(f,x,inf)) 常用函数见书P5页，微积分部分见书P25页。pretty（f）将f显示为数学书写形式，见课本P13页 1.2 clear syms x m=628; f=exp(m*x)*sin(x); diff(f,2) subs(f,x,0); diff(f,6) 1.3 clear syms x m=628; f=(x+sin(x))/(1+cos(x)); int(f,x) pretty(int(f,x)) f=log(1+m*x)-m*x; int(f,x,0,1) pretty(int(f,x,0,1)) 1.4 clear syms x m=628; f=cos(x*(m/200+sin(x))); taylor(f,x,'Order',5,'ExpansionPoint',0) pretty(taylor(f,x,'Order',5,'ExpansionPoint',0)) 在学校的机房的电脑上可能不可以加'Order'，答案可能会变得很长，请自行取舍'Order','ExpansionPoint',0等
1.5 clear x=[]; x(1)=rand(1); m=628; for k=2:10 x(k)=sqrt(m/100+x(k-1)); end x rand函数见书P5页
1.6 clear m=628; A=[4,2,m-2;-3,0,5;1,5,2*m] B=[3,4,0;2,0,-3;-2,1,1] det(A) inv(A) eig(A) [P,D]=eig(A); X=P(1:3,1:1) Y=P(1:3,2:2) Z=P(1:3,3:3) A\B A/B C=[A B]; Q=rref(C) 向量与矩阵见书P11、12页，线性代数见书P27页
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c88f8554671a52934aceb2881bd1c3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3190312bd8d84bc4639f17b7a4362697/" rel="bookmark">
			CVPR 2024 | 图像超分、图像恢复汇总！用AIGC扩散模型diffusion来解决图像low-level任务的思路...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Arbitrary-Scale Image Generation and Upsampling using Latent Diffusion Model and Implicit Neural Decoder 超分辨率（SR）和图像生成是计算机视觉中重要的任务，在现实应用中得到广泛采用。然而，大多数现有方法仅在固定放大倍数下生成图像，并且容易出现过平滑和伪影。此外，在输出图像的多样性和不同尺度下的一致性方面也不足。大部分相关工作应用了隐式神经表示（INR）到去噪扩散模型中，以获得连续分辨率的多样化且高质量的SR结果。由于该模型在图像空间中操作，所以产生分辨率越大的图像，需要的内存和推理时间也越多，并且它也不能保持尺度特定的一致性。
本文提出一种新流程，可在任意尺度上对输入图像进行超分辨率处理或从随机噪声生成新图像。方法由一个预训练的自编码器、一个潜在扩散模型和一个隐式神经解码器以及它们的学习策略组成。方法采用潜在空间中的扩散过程，因此高效且与由MLP在任意尺度上解码的输出图像空间保持对齐。更具体说，任意尺度解码器是由预训练自编码器的无上采样对称解码器和局部隐式图像函数（LIIF）串联而成的。通过去噪和对齐损失联合学习潜在扩散过程。输出图像中的误差通过固定解码器进行反向传播，提高输出质量。
通过在包括图像超分辨率和任意尺度上的新图像生成这两个任务上使用多个公共基准测试进行广泛实验，方法在图像质量、多样性和尺度一致性等指标上优于相关方法。在推理速度和内存使用方面，它比相关先前技术明显更好。
2、Diffusion-based Blind Text Image Super-Resolution 恢复退化的低分辨率文本图像是一项具有挑战性的任务，特别是在现实复杂情况下处理带有复杂笔画和严重退化的中文文本图像。保证文本的保真度和真实性风格对于高质量的文本图像超分辨率非常重要。最近，扩散模型在自然图像合成和恢复方面取得成功，因为它们具有强大的数据分布建模能力和数据生成能力。
这项工作提出一种基于图像扩散模型（IDM）的文本图像恢复方法，可以恢复带有真实风格的文本图像。对于扩散模型来说，它们不仅适用于建模真实的图像分布，而且也适用于学习文本的分布。由于文本先验对于根据现有艺术品保证恢复的文本结构的正确性非常重要，还提出了一种文本扩散模型（TDM）用于文本识别，可以指导IDM生成具有正确结构的文本图像。进一步提出一种多模态混合模块（MoM），使这两个扩散模型在所有扩散步骤中相互合作。
对合成和现实世界数据集的广泛实验证明，基于扩散的盲文本图像超分辨率（DiffTSR）可以同时恢复具有更准确的文本结构和更真实的外观的文本图像。
3、Text-guided Explorable Image Super-resolution 本文介绍零样本文本引导的开放域图像超分辨率解决方案的问题。目标是允许用户在不明确训练这些特定退化的情况下，探索各种保持与低分辨率输入一致的、语义准确的重建结果。
提出两种零样本文本引导超分辨率的方法，一种是修改文本到图像（T2I）扩散模型的生成过程，以促进与低分辨率输入的一致性，另一种是将语言引导融入零样本扩散式恢复方法中。展示了这些方法产生的多样化解决方案与文本提示所提供的语义意义相匹配，并且保持与退化输入的数据一致性。评估提出的基线方法在极端超分辨率任务上的任务表现，并展示了在恢复质量、多样性和解决方案的可探索性方面的优势。
4、Boosting Image Restoration via Priors from Pre-trained Models 以CLIP和稳定扩散为代表的使用大规模训练数据的预训练模型，在图像理解和从语言描述生成方面展现显著性能。然而，它们在图像恢复等低级任务中的潜力相对未被充分探索。本文探索这些模型来增强图像恢复。
由于预训练模型的现成特征（off-the-shelf features，OSF）并不能直接用于图像恢复，提出一个学习额外的轻量级模块——预训练引导细化模块（Pre-Train-Guided Refinement Module，PTG-RM），用于通过OSF改进目标恢复网络的恢复结果。PTG-RM由两个组成部分组成，预训练引导空间变化增强（Pre-Train-Guided Spatial-Varying Enhancement，PTG-SVE）和预训练引导通道-空间注意力（Pre-TrainGuided Channel-Spatial Attention，PTG-CSA）。PTG-SVE可以实现最佳的短和长距离神经操作，而PTG-CSA增强了与恢复相关的空间-通道注意力。
实验证明，PTG-RM以其紧凑的体积（小于1M参数）有效地增强了不同任务中各种模型的恢复性能，包括低光增强、去雨、去模糊和去噪。
5、Image Restoration by Denoising Diffusion Models with Iteratively Preconditioned Guidance 训练深度神经网络已成为解决图像恢复问题的常用方法。对于每个模型训练一个“任务特定”的网络的替代方法是，使用预训练的深度去噪器仅在迭代算法中强加信号先验，而无需额外训练。最近，这种方法基于采样的变体在扩散/基于分数的生成模型兴起时变得流行起来。
本文提出一种新的引导技术，基于预处理，可以沿着恢复过程从基于BP的引导过渡到基于最小二乘的引导。所提出方法对噪声具有鲁棒性，而且实施起来比替代方法更简单（例如，不需要SVD或大量迭代）。将其应用于优化方案和基于采样的方案，并展示其在图像去模糊和超分辨率方面相比现有方法的优势。
6、Diff-Plugin: Revitalizing Details for Diffusion-based Low-level Tasks 在大规模数据集上训练的扩散模型取得显著进展。然而，由于扩散过程中的随机性，它们经常难以处理需要保留细节的不同低层次任务。为克服这个限制，提出一个新的Diff-Plugin框架，使单个预训练的扩散模型能够在各种低层次任务中生成高保真度的结果。
具体来说，首先提出一个轻量级的Task-Plugin模块，采用双分支设计，提供任务特定的先验知识，引导扩散过程中的图像内容保留。然后，提出一个Plugin-Selector，可以根据文本指令自动选择不同的Task-Plugin，允许用户通过自然语言指示进行多个低层次任务的图像编辑。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3190312bd8d84bc4639f17b7a4362697/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/915c400596ad39780fc3962b2bcd3c3b/" rel="bookmark">
			Linux环境搭建Hadoop及完全分布式集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hadoop Hadoop是一个开源的分布式计算框架，旨在处理大规模数据集和进行并行计算。核心包括两个组件：HFDS、MapReduce。
配置方案 各虚拟机的用户名分别为test0、test1、test2，主机名为hadoop100、hadoop101、hadoop102
虚拟机的分配如下：
hadoop100：NameNode + ResourceManagerhadoop101：DataNode + NodeManagerhadoop102：SecondaryNameNode 其中Master为hadoop100，这个配置方案可以提供集群的基本功能，Master节点负责管理整个文件系统的元数据和资源调度，而Worker节点负责存储数据和执行任务。
各节点的作用：
NameNode：负责管理整个分布式文件系统的命名空间和文件元数据。它是HDFS的主节点，负责存储文件系统的元数据信息，并处理客户端的文件操作请求。将一台虚拟机作为NameNode节点可以提供高可靠性和容错性。SecondaryNameNode：主要负责协助NameNode进行元数据备份和检查点操作。它定期从NameNode获取编辑日志，并创建检查点，从而减少NameNode对元数据的负担和故障恢复时间。请注意，SecondaryNameNode并不是NameNode的备份，无法自动接管NameNode的角色。HDFS DataNode：负责存储和管理实际的数据块。它接收并处理从NameNode分配的数据块写入请求，并执行数据块的读取和复制操作。HDFS DataNode节点存储实际的数据块和后续读写操作。 安装Hadoop 上传压缩包，并解压
tar zxvf hadoop-3.3.6.tar.gz 打开环境变量注册表
vim /etc/profile 配置环境变量
export HADOOP_HOME=/opt/hadoop export PATH=$PATH:$HADOOP_HOME/bin export PATH=$PATH:$HADOOP_HOME/sbin 配置生效
source /etc/profile 进入Hadoop的安装目录，编辑/etc/hadoop/hadoop-env.sh文件，设置JAVA_HOME为您的JDK安装路径
export JAVA_HOME=/opt/dev/jdk1.8.0_151 检查是否安装完成，使用命令查看hfs中的根目录
hadoop fs -ls / 由于Hadoop单机模式是一种用于开发和测试的模式，它并不需要进行集群和分布式环境的设置。在Hadoop单机模式下，默认情况下，Hadoop会使用当前用户的身份进行操作，而无需输入密码。
配置Hadoop分布式集群 前提条件：
三台Linux系统虚拟机（可使用VMWare软件进行克隆）定义为hadoop100、hadoop101、hadoop102所有虚拟机都需要联通网络虚拟机之间区别主机名三台虚拟机都拥有相同路径版本的 JDK 和 Hadoop 设置主机名 首先分别打开三台虚拟机，分别使用下列指令将主机名修改。
由于NetworkManager服务的配置问题，直接使用hostname指令设置主机名在重启后会失效，需要每次开机重启，若想永久修改主机名生效，则修改/etc/hostname文件
vi /etc/hostname 下述的hadoop100是指新的主机名。同理修改其他的虚拟机主机名
hadoop100 分别检查虚拟机网络，当有数据返回时则无问题
ping www.baidu.com 编辑主机名列表文件
vi /etc/hosts 在文件加入，指定IP地址对应的hostname
192.168.10.128 badoop100 192.168.10.130 hadoop101 192.168.10.131 hadoop102 重启生效
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/915c400596ad39780fc3962b2bcd3c3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/650b51db913edec82066639326cabe00/" rel="bookmark">
			运行kafka出现ModuleNotFoundError: No module named ‘kafka.vendor.six.moves‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行pip install git+https://github.com/dpkp/kafka-python.git即可
但是未来有新版本不会更新
解决方法来自于github kafka [Python 3.12.0] ModuleNotFoundError: No module named 'kafka.vendor.six.moves' · Issue #2401 · dpkp/kafka-python (github.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a687af14b10f28ac5914d2af7aa4f9cb/" rel="bookmark">
			掌握Python的多方式分支——switch case 实现详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍀 前言 博客地址：
CSDN：https://blog.csdn.net/powerbiubiu 👋 简介 在 Python 编程语言中，没有内置的 switch case 功能。switch case 是一种常见的编程结构，它可以根据不同的条件值执行不同的代码块。然而，在 Python 中，我们不能直接使用 switch case 结构来实现这种功能。在本文中，我们将探讨如何在Python中实现switch语句。
📖 正文 1 使用if-elif-else实现 def switch(choice): if choice == 'a': print("Case: A") elif choice == 'b': print("Case: B") elif choice == 'c': print("Case: C") else: print("default Case") switch('a') switch(1) # Case: A # default Case 2 使用字典实现 def switch(case): cases = { 'a': 'Case A', 'b': 'Case B', 'c': 'Case C' } return cases.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a687af14b10f28ac5914d2af7aa4f9cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22bdb2d71bb609b8f580451a63565af3/" rel="bookmark">
			Stable Diffusion插件：提示词
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多同学使用Stable Diffusion生成图片时，之所以做不出高质量的图片，很大程度上是由于不知道怎么写提示词，常常陷入词穷的窘境，要么不知道该写点啥，要么翻译出来的英文不是很贴切。今天我就给大家分享几个Stable Diffusion WebUI的提示词插件，助你写出高质量的提示词。
sd-webui-prompt-all-in-one 这个插件是秋叶整合包默认使用的提示词插件，功能特别强大，没有使用秋叶整合包的小伙伴可以试试。
安装 方法一，通过 WebUI 的扩展功能进行安装
启动 Stable Diffusion WebUI 后，在“扩展”中安装：
方法二，下载扩展程序后，自己上传到 WebUI 的扩展目录。可以使用我分享的资源，关于微信公众号：萤火遛AI（yinghuo6ai），发消息：SD，在插件文件夹中找到 sd-webui-prompt-all-in-one，下载后解压，然后上传到 WebUI 的插件目录。
安装成功后，记得重新启动 Stable Diffusion WebUI 。
使用 在“文生图”和“图生图”的提示词、反向提示词输入框下方会出现一些书写提示词的辅功能，这里简单介绍下使用方法。
以填写提示词为例。在下图1的位置输入中文关键字，键盘回车之后，就会把关键字填写到提示词输入框中，并自动翻译为英文。
我们也可以在提示词输入框中直接输入中文关键字，然后再点击下图中的翻译按钮，翻译为英文。
如果你实在不知道该写点啥，可以试试下图中这些预置好的关键词，它们一定可以给你带来一些灵感，点击就可以自动填写到提示词输入框中。不过需要注意这些内置的提示词不一定在所有的模型中都有比较好的效果，这个还得多测试。
这个插件还能保存历史提示词、收藏提示词，有兴趣的快去试试吧 。
SD WebUI Tag Autocomplete 这是另一个十分优秀的提示词插件，使用者众多。
就像使用Google、Baidu等搜索引擎，我们只需要输入部分文字或者单词，搜索引擎就会自动给我们一些相关的下拉提示，然后我们可以选择一个最接近我们需求的提示进行搜索，这种能力称为 Auto Complete。它可以让我们专注在提示词的编写上，而不用跳来跳去。
通过这个插件我们就可以在“文生图”或者“图生图”的提示词输入框中使用 Auto Complete 的能力。
安装 插件的安装方式还是有两种：
一是直接在 WebUI 的扩展中在线安装，插件仓库地址：github.com/DominikDoom…
二是下载扩展程序后，自己上传到 WebUI 的插件目录。下载我整理的插件安装包，关注微信公众号：萤火遛AI（yinghuo6ai），发消息：SD，在插件文件夹中找到 a1111-sd-webui-tagcomplete，下载后解压，然后上传到 WebUI 的插件目录。
安装之后，不要忘了重启WebUI。
使用 以“文生图”为例，在提示词这里输入“blue”，然后就会自动弹出一个提示框，其中罗列了一些相关的提示词，提示词按照使用量由大到小排列，点击某个提示词就会自动填入输入框，并自动加上逗号分隔符。是不是很方便？！
如果你的 WebUI 没有弹出提示，请多等几秒钟再试试，有时候可能会加载的慢一些。
不过有的同学可能还会说，英文一个单词都写不出来，怎么办？别着急，支持翻译。
这里有两个翻译好的文件：github.com/DominikDoom…
然后我们在 WebUI 的设置中启用它，如下图所示，找到“Tag Autocomplete”-&gt;“Translation filename”，选择已经上传的文件，注意勾选上“Translation file uses old 3-column…”，然后保存设置，重启WebUI。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22bdb2d71bb609b8f580451a63565af3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d387af156d012cf514b7158923f0a45/" rel="bookmark">
			AI绘图:Controlnet在ComfyUI中的使用教程：提升Stable Diffusion可控性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 Controlnet是Stable Diffusion中一个至关重要的功能，它极大地增强了图像生成的可控性。通过引入额外的条件，Controlnet使我们能够更精确地控制生成的图像内容。本教程将详细介绍如何在ComfyUI中使用Controlnet，从而让你的创作过程更加灵活和精确。
安装Controlnet预处理器插件和模型 在开始使用Controlnet之前，我们需要安装Controlnet预处理器插件并下载相应的模型。
安装Controlnet预处理器插件：
访问插件的GitHub页面：ComfyUI Controlnet预处理器插件。下载并安装插件。如果ComfyUI无法导入插件，请运行插件目录下的install.bat文件。 下载Controlnet模型：
常用模型可以在教程文件链接中找到。将下载的模型存放在ComfyUI_windows_portableComfyUImodelscontrolnet目录下。 创建Controlnet使用流程 加载图像：
使用“加载图像”节点导入你想要处理的图片。 选择Controlnet预处理器：
根据你的需求选择一个预处理器，例如“Canny细致线预处理器”。将“加载图像”节点与预处理器节点连接，并连接一个“预览图像”节点以查看效果。 加载Controlnet模型：
右键新建节点，选择“Controlnet加载器”。 应用Controlnet：
右键新建节点，选择“条件” -&gt; “Controlnet应用”或“Controlnet应用（高级）”。设置强度、开始时间和结束时间以控制Controlnet的效果。 连接工作流：
将预处理器输出的图像连接到“Controlnet应用”节点。选择合适的Controlnet模型并连接到“Controlnet加载器”。将“Controlnet应用”节点连接到后续的采样器节点。 生成图像：
输入你的关键词，然后运行工作流以生成图像。 多Controlnet的连接 如果你需要使用多个Controlnet，可以在“Controlnet应用”节点后面继续串联更多的“Controlnet应用”节点。确保每个Controlnet相关的节点都正确连接到相应的预处理器和模型。
好了基于大家到此应该都比较熟练了，我就不在详细配图了。通过本教程，你现在应该能够熟练地在ComfyUI中使用Controlnet，为你的Stable Diffusion创作过程带来更高的精确度和灵活性。不断实践和探索，你将能够充分发挥Controlnet的潜力，创作出更加精彩的艺术作品。
最后分享一下附件。链接: 百度网盘 提取码: 7800 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5c39cbd38ecbfe694fa02874e664aa0/" rel="bookmark">
			LLaMA-Factory微调（sft）ChatGLM3-6B保姆教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LLaMA-Factory微调（sft）ChatGLM3-6B保姆教程 准备 1、下载 下载LLaMA-Factory下载ChatGLM3-6B下载ChatGLM3windows下载CUDA ToolKit 12.1 （本人是在windows进行训练的，显卡GTX 1660 Ti） CUDA安装完毕后，通过指令nvidia-smi查看
2、PyCharm打开LLaMA-Factory项目 1、选择下载目录：E:\llm-train\LLaMA-Factory，并打开
2、创建新的python环境，这里使用conda创建一个python空环境，选择python3.10
3、安装依赖 参考LLaMA-Factory的依赖安装步骤
安装LLaMA-Factory依赖
(llm) PS E:\llm-train\LLaMA-Factory&gt; pwd Path ---- E:\llm-train\LLaMA-Factory (llm) PS E:\llm-train\LLaMA-Factory&gt; pip install -r requirements.txt Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simple Collecting torch&gt;=1.13.1 (from -r requirements.txt (line 1)) Downloading https://pypi.tuna.tsinghua.edu.cn/packages/3a/81/684d99e536b20e869a7c1222cf1dd233311fb05d3628e9570992bfb65760/torch-2.2.2-cp310-cp310-win_amd64.whl (198.6 MB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 198.6/198.6 MB 5.0 MB/s eta 0:00:00 Collecting transformers&gt;=4.37.2 (from -r requirements.txt (line 2)) Downloading https://pypi.tuna.tsinghua.edu.cn/packages/e2/52/02271ef16713abea41bab736dfc2dbee75e5e3512cf7441e233976211ba5/transformers-4.39.2-py3-none-any.whl (8.8 MB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 8.8/8.8 MB 4.0 MB/s eta 0:00:00 Collecting datasets&gt;=2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5c39cbd38ecbfe694fa02874e664aa0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/38/">«</a>
	<span class="pagination__item pagination__item--current">39/71</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/40/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>