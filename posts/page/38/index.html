<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97363b3f6e78d3582e7727cbc6e7dbc1/" rel="bookmark">
			Linux使用宝塔面板安装MySQL结合内网穿透实现公网连接本地数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 推荐前言1.Mysql服务安装2.创建数据库3.安装cpolar3.2 创建HTTP隧道 4.远程连接5.固定TCP地址5.1 保留一个固定的公网TCP端口地址5.2 配置固定公网TCP端口地址 推荐 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。【点击跳转到网站】
前言 宝塔面板的简易操作性,使得运维难度降低,简化了Linux命令行进行繁琐的配置,下面简单几步,通过宝塔面板+cpolar即可快速搭建一个mysql数据库服务并且实现公网远程访问。
1.Mysql服务安装 我们打开宝塔面板,点击数据库,然后点击安装mysql服务,
选择极速安装即可,版本默认
然后等待安装完成
2.创建数据库 安装好后,修改一下root密码,这个root密码也是登陆mysql时候时输入的密码
修改后,我们测试添加数据库,宝塔面板提供可以直接在页面就可以创建一个mysql数据库,设置用户名和密码,访问权限设置为所有人,然后提交即可
提交成功我们可以看到列表中出现了一个数据库
然后我们在宝塔面板安全页面开放一个3306的端口
3.安装cpolar 打开宝塔终端命令窗口,使用cpolar一件安装脚本:
curl -L https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash token认证
登录cpolar官网www.cpolar.com,点击左侧的验证，查看自己的认证token，之后将token贴在命令行里
cpolar authtoken xxxxxxx 向系统添加服务
sudo systemctl enable cpolar 启动cpolar服务
sudo systemctl start cpolar 在宝塔面板中选择安全.然后开放9200端口
然后局域网ip+:9200端口即可出现cpolar管理界面,然后使用官网注册的账号进行登陆,如没有注册可以点击下面账号免费注册
3.2 创建HTTP隧道 点击左侧仪表盘的隧道管理——创建隧道,由于mysql中默认的是3306端口，因此我们要来创建一条tcp隧道，指向3306端口：
隧道名称：可自定义，注意不要重复协议：tcp本地地址：3306域名类型：选择随机域名地区：选择China VIP 点击创建
创建成功后,打开在线隧道列表,查看公网tcp地址
4.远程连接 接下来我们使用数据库连接工具navicat进行测试连接,地址使用上面的公网地址,点击测试连接后表示成功.
5.固定TCP地址 由于以上创建的隧道是随机地址隧道,地址会在24小时内变化,为了使连接更加稳定,需要固tcp地址
需要注意，配置固定TCP端口地址需要将cpolar升级到专业版套餐或以上。
5.1 保留一个固定的公网TCP端口地址 登录cpolar官网后台，点击左侧的预留，选择保留的TCP地址。
地区：选择China VIP描述：即备注，可自定义填写 点击保留
地址保留成功后，系统会生成相应的固定公网地址，将其复制下来
5.2 配置固定公网TCP端口地址 再次登录cpolar web ui管理界面，点击左侧仪表盘的隧道管理&gt;&gt;隧道列表，找到上面创建的mysql隧道，点击右侧的编辑,
修改隧道信息，将保留成功的固定tcp地址配置到隧道中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97363b3f6e78d3582e7727cbc6e7dbc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f274c83e16a9b02961f105d9e4d5d45/" rel="bookmark">
			Mysql：Your password does not satisfy the current policy requirements错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误：Your password does not satisfy the current policy requirements
这个错误就是 修改密码的时候没有符合安全规范， 这时候我们可以有两个方法：1.设置一个符合Mysql安全规范的密码。2.修改Mysql的安全策略
Mysql 密码安全规范 密码安全规范是在Mysql5.6以后加入的
密码长度：密码长度至少为8个字符。
复杂性要求：密码必须包含以下字符类别中的至少一个：
大写字母小写字母数字字符特殊 密码过期策略： MySQL 5.7.10 默认情况下启用了密码过期策略。这意味着用户的密码会在一定时间后，需要用户更改密码。
密码历史记录： MySQL 5.7.10 仍然支持密码历史记录功能，以防止用户在短时间内重复使用相同的密码。
这些是MySQL 5.7.10中默认的密码策略要求。管理员可以根据需要调整这些设置，以满足其安全要求。
修改Mysql 密码安全规范 临时策略 1.查看策略 SHOW VARIABLES LIKE ‘validate_password%’; 现在密码策略是中等。
2.修改密码验证强度等级，设置validate_password_policy 的全局参数为LOW
#进行设值 set global validate_password_policy=LOW; 3.设置密码的长度，当前默认为8，设置validate_password_length 的全局参数 = 4
# 进行设值 set global validate_password_length=4; 现在就可以设置简单密码了
ALTER USER ‘root’@‘localhost’ IDENTIFIED BY ‘1234’; 永久策略 在my.cnf 中修改，一般my.cnf 都是在 etc 目录下面
vim /etc/my.cnf 可以参考下面修改
[client] socket= /tmp/mysql.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f274c83e16a9b02961f105d9e4d5d45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1160ca1fe949ee97d43cef8cd3529c92/" rel="bookmark">
			python和pycharm从安装到激活全过程（保姆级教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接：https://pan.baidu.com/s/1rwYJgXRkMJ8XS9viLBhQtw 提取码：e9ex
以下三个文件及安装路径最好都放在一个文件夹中
目录
python的安装
pycharm的安装
pycharm的激活
python的安装 第一步：双击文件夹第三个文件，一般都选择安装3.11.4这个版本
等待
出现这个界面即可完成
pycharm的安装 第一步：双击文件夹中的第二个文件
浏览自己想要安装的文件目录
到这里pycharm就安装完成了，这只是试用版，接下来我们要进行激活
pycharm的激活 第一步：点击文件夹中的第一个文件，选择"安装"那个文件进行安装
最后出现"success"就说明安装成功了，这时需要重启一下电脑
第二步：双击自己刚刚安装的pycharm，就进入到这个界面，选择"Activation"手动添加激活码
第三步：将文件中第一个文件夹中的第四个文件"激活码"中的所有数据复制粘贴到上面的区域内,这时的激活码是有效的
第四步点击中间的"+"号，新建项目
第五步：在新建项目的时候，注意文件名，文件路径最好都是英文的，然后最下面python版本环境一定要选择自己安装python的路径中找到python.exe文件，最后点击create即可完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/339942eccf8d46844544a78cdeef5ed8/" rel="bookmark">
			CVPR 2024 | 图像检测类（目标、deepfake、异常）！AIGC扩散模型diffusion解决detection任务...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标跟踪 1、Delving into the Trajectory Long-tail Distribution for Muti-object Tracking 多目标跟踪（Multiple Object Tracking，MOT）是计算机视觉领域中一个关键领域，有广泛应用。当前研究主要集中在跟踪算法的开发和后处理技术的改进上。然而，对跟踪数据本身的特性缺乏深入的研究。
本研究首次对跟踪数据的分布模式进行探索，并发现现有 MOT 数据集中存在明显的长尾分布问题。发现不同行人分布存在显著不平衡现象，将其称为“行人轨迹长尾分布”。针对这一挑战，提出一种专门设计用于减轻这种分布影响的策略。具体而言，提出两种数据增强策略，包括静态摄像机视图数据增强（SVA）和动态摄像机视图数据增强（DVA），针对视点状态，以及面向 Re-ID 的 Group Softmax（GS）模块。SVA 是为了回溯并预测尾部类别的行人轨迹，而 DVA 则使用扩散模型改变场景的背景。GS 将行人划分为不相关的组，并对每个组进行 softmax 操作。
策略可以集成到许多现有的跟踪系统中，实验证实方法在降低长尾分布对多目标跟踪性能的影响方面的有效性。https://github.com/chen-si-jia/Trajectory-Long-tail-Distribution-for-MOT
目标检测 2、SAFDNet: A Simple and Effective Network for Fully Sparse 3D Object Detection 基于 LiDAR 的三维物体检测，在自动驾驶中起关键作用。目前已有的高性能三维物体检测器通常在骨干网络和预测头中构建密集特征图。然而，随着感知范围增加，密集特征图带来的计算成本呈二次增长，使得这些模型很难扩展到长距离检测。最近一些研究尝试构建完全稀疏的检测器来解决这个问题，然而所得模型要么依赖于复杂的多阶段流水线，要么表现不佳。
本文提出 SAFDNet，简单高效，专为完全稀疏的三维物体检测而设计。在 SAFDNet 中，设计了一种自适应特征扩散策略来解决中心特征丢失的问题。在 Waymo Open、nuScenes 和 Argoverse2 数据集上进行大量实验证明，SAFDNet 在前两个数据集上的性能略优于先前的 SOTA，但在具有长距离检测特点的最后一个数据集上表现更好，验证 SAFDNet 在需要长距离检测的场景中的有效性。
在 Argoverse2 上，SAFDNet 在速度上比先前最好的混合检测器 HEDNet 快 2.1 倍，并且相对于先前最好的稀疏检测器 FSDv2 提高了 2.1% 的 mAP，速度提高了 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/339942eccf8d46844544a78cdeef5ed8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f71c66dca14d18687a14a2d5dfcfb102/" rel="bookmark">
			前端给后端传数据的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端给后端传数据的几种方式 1.发送get请求将参数通过？拼接在url后面2.将参数拼接在url中，后台通过占位符接收参数 /{id}3.通过post提交方式将form表单中的数据序列化后传递到后台。4.通过post提交方式将form表单的类型是 json5. 前台将普通数据转换为json 1.发送get请求将参数通过？拼接在url后面 $.ajax({ url: "/order/userPage?page="+page+"&amp;pageSize="+pageSize, //请求的url地址 cache: "false", //设置为false将不会从浏览器中加载请求信息 async: "true", //true所有请求均为异步请求 dataType: "json", //请求返回数据的格式 type:"get", //请求方式 上面等同于==&gt;&gt; async initData(){ paging: { page: 1, pageSize: 5 } const res = await orderPagingApi(this.paging) } function orderPagingApi(data) { return $axios({ 'url': '/order/userPage', 'method': 'get', //请求参数 params: {...data} }) 上面等同于==&gt;&gt; async initData(){ paging: { page: 1, pageSize: 5 } const res = await orderPagingApi(this.paging) } function orderPagingApi(data) { return $axios({ 'url': '/order/userPage', 'method': 'get', 'data': data }) 后端接收参数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f71c66dca14d18687a14a2d5dfcfb102/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/725c6fb683ba394a19a8db19defb140e/" rel="bookmark">
			copilot的几个问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.copilot提示：很抱歉，目前无法连接到服务。请稍后重试或刷新 的解决方案 copilot是微软自带的，很多人在打开时会发现，自带的这个无法连接
看到了csdn友 有的说改语言和区域啥的，试过了，对我无效
copilot提示：很抱歉，目前无法连接到服务。请稍后重试或刷新 的解决方案_copilot无法连接到服务-CSDN博客
因此我选择直接在edge浏览器上使用，在这个友友的帖子中有介绍
一招解决微软copilot提示:该服务在您所在的地区不可用_copilot该服务在你所在的地区不可用解问题-CSDN博客
其中需要补充的是，设置中用户的切换问题
切换用户后，使用科学上网就可以连接了使用了（这是一般情况）
2.无法登录，始终卡在登录界面，点击后循环回登录界面，如何解决？ 本人在连接之后却出现了在这个界面无线循环的请假，点击登陆之后还是这个界面
试了几次之后，我的建议是，修改下科学上网为全局模式，同时修改下节点，等待几分钟之后就正常了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65e819a4b602294d11b8b0140f2e50f1/" rel="bookmark">
			AI绘画之SD从入门到变现-快速变装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天我们在来学习一下另外几个图生图方式，给你的AI女衣换件新外套。
1、涂鸦手绘
这个功能简单来说就是在我们添加的图片上面用画笔画一些内容，SD会提示词和画的内容来在这个绘画的地方进行生产创作。
比如我们想在模特头上加一段小花。一个发卡。都是这样操作。
首先点击绘图，上传我们需要修改的图片，在点击画笔工具。
在模特头上随便花几个点，关键词中加入花朵。重绘幅度：0.5
左上角可以这个i的图标可以快捷键+鼠标滚轮调节图片大小，公众号里的整合包内已经集合了这个插件。使用其他整合包没有这个插件的话可以直接去下载一下。
2、局部重绘
打开局部重绘，上传我们需要的图片。我们这里给模特换一件衣服，我们使用画笔工具把模特衣服区域涂成白色即可。
也就是说我们需要改变哪里可以把哪里涂成白色。这种属于在下面这个蒙版参数里选择 重绘蒙版内容。
这里我们把先发推提示词，把原提示词中的白衬衣提示词删除掉，让后加入我们想给模特换的衣服的提示词。
但是如果想要重绘除衣服以外的内容，依旧是涂白衣服部分，在蒙版参数内选择重绘非蒙版内容。
如下图：我们这里蒙版把脸遮住，然后提示加入一个蓝色外套。
下面选择重绘非模板区域。重绘幅度0.8
下面我们单独说一下 蒙版区域内容处理 这一块
1.填充、潜空间噪声、空白潜空间。出图和原图差别会比较大。
2.原版出图和原图比较相似。
填充:处理图片时，把蒙住的内容重新打散了，再去重组后填充到蒙版的位置。
原图: 处理图片时，参考原图修改。
潜空间噪声: 处理图片时，通过噪声去铺满蒙版的位置再去噪得出图片。
空白潜空间:预处理图片时，理解为那一块儿重回混沌了，然后再生成图片。
下面是几个模式 相同重绘幅度 下分别生成4张图片的效果，实际感受一下。
3、涂鸦重绘
涂鸦重绘和局部重绘的区别是画笔是可以调颜色的，SD会根据我们画笔的颜色来重绘蒙版区域。
文章使用的AI绘画SD整合包、各种模型插件、提示词、AI人工智能学习资料都已经打包好放在网盘中了，有需要的小伙伴文末扫码自行获取。
写在最后 AIGC技术的未来发展前景广阔，随着人工智能技术的不断发展，AIGC技术也将不断提高。未来，AIGC技术将在游戏和计算领域得到更广泛的应用，使游戏和计算系统具有更高效、更智能、更灵活的特性。同时，AIGC技术也将与人工智能技术紧密结合，在更多的领域得到广泛应用，对程序员来说影响至关重要。未来，AIGC技术将继续得到提高，同时也将与人工智能技术紧密结合，在更多的领域得到广泛应用。
感兴趣的小伙伴，赠送全套AIGC学习资料和安装工具，包含AI绘画、AI人工智能等前沿科技教程，模型插件，具体看下方。
一、AIGC所有方向的学习路线
AIGC所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照下面的知识点去找对应的学习资源，保证自己学得较为全面。
二、AIGC必备工具
工具都帮大家整理好了，安装就可直接上手！
三、最新AIGC学习笔记
当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
四、AIGC视频教程合集
观看全面零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
五、实战案例
纸上得来终觉浅，要学会跟着视频一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
若有侵权，请联系删除 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7088a8d8fc427071b1b267ae38ccb9f9/" rel="bookmark">
			【赠书第20期】AI绘画与修图实战：Photoshop&#43;Firefly从入门到精通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
前言
1 入门篇：初识Photoshop与Firefly
2 进阶篇：掌握Photoshop与Firefly的核心技巧
3 实战篇：运用Photoshop与Firefly进行创作
4 精通篇：提升创作水平，拓展应用领域
5 结语
6 推荐图书
7 粉丝福利
前言 随着科技的不断发展，人工智能（AI）已经渗透到各个领域，其中 AI 绘画与修图技术更是备受瞩目。Photoshop 和 Firefly 作为这一领域的两款强大工具，为艺术家和创作者提供了前所未有的创作可能。本文将从入门到精通，深入探讨 Photoshop 与 Firefly 在 AI 绘画与修图实战中的应用。
1 入门篇：初识Photoshop与Firefly Photoshop 是一款功能强大的图像处理软件，广泛应用于摄影后期、平面设计、UI 设计等领域。而 Firefly 则是一款基于 AI 技术的绘画与修图工具，能够自动化地完成一系列繁琐的操作，提高创作效率。
对于初学者来说，首先要了解这两款软件的基本操作界面和功能。Photoshop 拥有丰富的工具和面板，可以通过图层、滤镜、调整等功能来实现图像的精细处理。而 Firefly 则更加注重于 AI 技术的应用，通过智能识别、一键优化等功能，让修图变得更加简单快捷。
2 进阶篇：掌握Photoshop与Firefly的核心技巧 在掌握了基本操作后，我们需要进一步学习 Photoshop 与 Firefly 的核心技巧，以便更好地应用于AI 绘画与修图中。
在 Photoshop 中，图层是创作的基础。通过合理地管理图层，可以实现图像的叠加、融合和修改。同时，滤镜和调整功能也是 Photoshop 的两大亮点，可以实现对图像的特效处理和色彩调整。
而在 Firefly 中，我们需要学习如何利用其 AI 技术来实现自动化处理。例如，通过智能识别功能，可以快速定位并修复图像中的瑕疵；通过一键优化功能，可以自动调整图像的亮度、对比度和色彩平衡等参数。
此外，我们还可以将 Photoshop 与 Firefly 进行结合使用，发挥它们的优势。例如，在 Photoshop中完成图像的初步处理后，再使用 Firefly 进行进一步的优化和修饰，以达到更好的效果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7088a8d8fc427071b1b267ae38ccb9f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d13f3026bdc58cff05a15c27121ef3d0/" rel="bookmark">
			【频繁模式挖掘】FP-Tree算法（附Python实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验内容简介 该实验主要使用频繁模式和关联规则进行数据挖掘，在已经使用过Apriori算法挖掘频繁模式后，这次使用FP-tree算法来编写和设计程序，依然使用不同规模的数据集来检验效果，最后分析和探讨实验结果，看其是否达到了理想的效果。本实验依然使用Python语言编写。
二、算法说明 首先简单介绍频繁模式和关联规则：
频繁模式一般是指频繁地出现在数据集中的模式。
关联规则是形如X→Y的蕴涵表达式，其中X和Y是不相交的项集，即X∩Y=∅。关联规则的强度可以用它的支持度（support）和置信度（confidence）来度量。计算公式如下：
支持度：support(A=&gt;B)=P(A∪B)，表示A和B同时出现的概率。
置信度：confidence(A=&gt;B)=support(A∪B)/support(A)，表示A和B同时出现的概率占A出现概率的比值。
强关联规则是指达到了最小支持度和最小置信度的关联规则。
然后再介绍FP-Tree算法：
2000年，Han Jiawei等人提出了基于频繁模式树（Frequent Pattern Tree, FP—Tree）的发现频繁模式的算法FP-Growth。其思想是构造一棵FP-Tree，把数据集中的数据映射到树上，再根据这棵FP-Tree找出所有频繁项集。
FP-Growth算法是指，通过两次扫描事务数据集，把每个事务所包含的频繁项目按其支持度降序压缩存储到FP-Tree中。在以后发现频繁模式的过程中，不需要再扫描事务数据集，而仅在FP-Tree中进行查找即可。通过递归调用FP-Growth的方法可直接产生频繁模式，因此在整个发现过程中也不需产生候选模式。由于只对数据集扫描两次，因此FP-Growth算法克服了Apriori算法中存在的问题，在执行效率上也明显好于Apriori算法。
上图为FP-Tree示意图，展示了该数据结构的构成方式。
三、算法分析与设计 了解完算法的基本原理后，现在开始真正实现该算法。首先需要读取最小支持度，读取数据集。这里的数据集可大可小，我用Python中的字典来表示数据
这里的数据存储格式与之前写Apriori算法时一样，使用字典来存储。然后由用户来输入支持度和置信度（因为这次还要挖掘关联规则，所以增加了置信度输入）。
作为FP-Tree的基础，首先构建树节点。一个节点有四个基本属性，分别节点名称、出现次数、双亲节点和孩子节点。因为这里不是二叉树，树的孩子节点个数不确定，因此用字典来存储，大小可控。
class Node: def __init__(self, value, parent, count=0): self.value = value self.parent = parent self.count = count self.children = {} def addChild(self, child): self.children.update(child) def __init__(self, value, parent, count=0): 前置准备完成后，开始实现FP-Tree算法。FP-Tree算法可大致分为构建项头表、构建FP-Tree、利用条件模式基挖掘频繁模式和关联规则几步。把这几步集成到一个类中，这样避免了大量函数传参操作，思路更清晰。
首先构建项头表，先扫描一遍数据集挖掘频繁1项集，挖掘出来的数据按支持度降序排列，并按此顺序重新排列原数据集的数据，对于不符合要求的数据直接删除。
def first_scan(self): """ 生成项头表，整理数据 """ Dict = dict() for i in self.data.values(): for j in i: if j not in Dict.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d13f3026bdc58cff05a15c27121ef3d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e29c3a31cffbd70224258ed808c63feb/" rel="bookmark">
			uniapp:聊天消息列表（好友列表&#43;私人单聊）支持App、H5、小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎬 江城开朗的豌豆：个人主页
🔥 个人专栏 :《 VUE 》 《 javaScript 》
📝 个人网站 :《 江城开朗的豌豆🫛 》 ⛺️ 生活的理想，就是为了理想的生活 !
目录
⭐ 文章简介（效果图展示） 📟 插件传送门：聊天消息列表
📘 文章背景
📘 平台兼容性
📘 功能实现
废话不说直接上代码
📟 用户列表完整代码
📟 单人对话框 完整代码 🔥 文章总结
📟 隐私、权限声明
1. 本插件需要申请的系统权限列表：
2. 本插件采集的数据、发送的服务器地址、以及数据用途说明：
3. 本插件是否包含广告，如包含需详细说明广告表达方式、展示频率：
⭐ 文章简介（效果图展示） 在现代社交互动中，聊天消息列表是应用程序中的关键组成部分。它不仅仅是一种通信工具，更是人们日常生活中连接感情、分享信息的重要方式之一。随着移动互联网的发展，用户在不同平台上（如App、H5、小程序等）进行聊天的需求也愈发增加。因此，设计并实现一个支持多平台、多种形式的聊天消息列表成为了开发者们的挑战之一。
📟 插件传送门：聊天消息列表 📘 文章背景 最近我专注于优化我们聊天消息列表的交互体验。现在，我们的消息列表页面上有多个标签，每个标签对应着不同的聊天会话。当用户点击某个标签时，页面会流畅地滚动到相应的聊天记录位置，这样用户就可以更方便地查看他们感兴趣的对话内容。
今天下午，我花了些时间在消息列表的交互功能上进行调整和改进。经过一番努力，我成功地实现了这一功能！在这个过程中，我逐步解决了各种技术挑战，体验着一个个问题被一一击破的成就感。这种改进用户体验的过程真是让人感到无比满足！
📘 平台兼容性 Vue2Vue3√√ App快应用微信小程序支付宝小程序百度小程序字节小程序QQ小程序HBuilderX 3.6.11 app-vue app-nvue√√√√√√ 钉钉小程序快手小程序飞书小程序京东小程序√√√√ H5-SafariAndroid Browser微信浏览器(Android)QQ浏览器(Android)ChromeIEEdgeFirefoxPC-Safari√√√√√√√√√ 📘 功能实现 废话不说直接上代码 📟 用户列表完整代码 &lt;template&gt; &lt;view class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e29c3a31cffbd70224258ed808c63feb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a65403658174467bbe24f1e44649774e/" rel="bookmark">
			前端AES加密，后端解密，有效防止数据外泄_前端加密后端解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先引入前端需要用到的js：crypto-js，下载地址： CryptoJS-v4.1.1
https://www.aliyundrive.com/s/bXP6M8ZxVAD
点击链接保存，或者复制本段内容，打开「阿里云盘」APP ，无需下载极速在线查看，视频原画倍速播放。
2、将 crypto-js 文件放到要引用的路径 3、以下是要引用到的js 4、在注册按钮的点击事件中，设置 key 值和 iv 值，这是加密的设置字段，定义要进行加密的密码 encryptedPwd function register() {
var password = . c o m m o n . t r i m ( .common.trim( .common.trim((“input[name=‘password’]”).val());
//AES加密
var key = “ABCDEFGHIJKL_key”;
var iv = “ABCDEFGHIJKLM_iv”;
var encryptedPwd = aesMinEncrypt(key,iv,password);
$.ajax({
type: “post”,
url: ctx + “register”,
data: {
“password”: encryptedPwd,
…
…
}
success: function (res) {}
});
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a65403658174467bbe24f1e44649774e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1531b9a14db8a815960c8e9a87e69228/" rel="bookmark">
			初始Java篇（JavaSE基础语法）（6）（继承和多态）（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java学习篇 个人主页（找往期文章包括但不限于本期文章中不懂的知识点）：我要学编程(ಥ_ಥ)-CSDN博客
目录
继承篇 为什么需要继承？
继承概念
继承的语法
父类成员访问
super关键字
子类构造方法
super和this的比较
再谈初始化
protected 关键字
继承方式 final 关键字
继承与组合
继承篇 为什么需要继承？ Java中使用类对现实世界中实体来进行描述，类经过实例化之后的产物对象，则可以用来表示现实中的实体，但是现实世界错综复杂，事物之间可能会存在一些关联，那在设计程序时就需要考虑。比如：狗和猫，它们都是一个动物。我们现在就可以创建一个猫类和狗类。
class Dog{ public String name; public int age; //构造方法来初始化成员变量 public Dog(String name, int age){ this.name = name; this.age = age; } //来打印成员变量 public void show(){ System.out.println("name:"+this.name+"age:"+this.age); } } class Cat{ public String name; public int age; //构造方法来初始化成员变量 public Cat(String name, int age){ this.name = name; this.age = age; } //来打印成员变量 public void show(){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1531b9a14db8a815960c8e9a87e69228/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f140989a10519fba5ae5ccbdc61102e5/" rel="bookmark">
			数据结构之顺序表的相关知识点及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页（找往期文章包括但不限于本期文章中不懂的知识点）：我要学编程(ಥ_ಥ)-CSDN博客
目录
顺序表的概念及结构
顺序表的分类
顺序表的实现 在顺序表中增加数据 在顺序表中删除数据 在顺序表中查找数据 顺序表源码
顺序表的概念及结构 在了解顺序表之前，得先知道一个东西：线性表。线性表（linear list）是n个具有相同特性的数据元素的有限序列。简单理解就是：线性表指的是具有部分相同特性的一类数据结构的集合。例如：蔬菜分为绿叶类、瓜类、菌菇类。线性表是一种在实际中广泛使用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串... 线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的， 线性表在物理上存储时，通常以数组和链式结构的形式存储。 如何理解逻辑结构和物理结构？我们去超市买东西的时候，去付款时要排队，假设有很多人，也就意味着我们需要排成一条对去付款。这是在逻辑上就是一条线性的（我们下意识认为，是理想的），但是实际上在站队时不一定是线性的（现实情况）。但是顺序表在逻辑结构和物理结构上都是线性的。这是因为顺序表的底层实现逻辑是数组。我们知道数组在内存上是连续存放的（实际情况）。
注意：顺序表的底层虽然是数组，但是却是在数组的基础之上对数组进行了封装，实现了增删查改的一些功能。
顺序表的分类 我们知道数组有两种：一种是定长数组，也就是空间大小不可变化，是固定的；还有一种是变长数组，这个变长数组是我们用动态内存开辟函数申请来的（注意区分C99中引入的变长数组）。
根据数组的不同，顺序表也分为两种：静态顺序表（大小不可变），动态顺序表（大小可变）。
顺序表的实现 这两种顺序表一比较，肯定是第二种的优势明显一些，同样在项目中，动态顺序表的应用远远大于静态顺序表。下面我们就来学习动态顺序表的实现。
首先创建三个文件：SeqList.h —— 顺序表的头文件 SeqList.c —— 顺序表的实现 test.c——&gt;测试顺序表
顺序表的创建：
typedef struct SeqList { SLDataType* arr;//数组指针 int size;//记录当前有效的空间大小 int capacity;//记录当前总空间大小 }SL;//由于struct SeqList太长，比较麻烦，因此就重新定义 由于数组的类型是暂定为int，后续如果要改动的话，不是很方便，因此也是重定义。
typedef int SLDataType;//数组不一定是int类型 顺序表创建完了之后，就得开始实现它的基本功能：增 删 查 改。
在实现上面那些基本功能之前，我们肯定得把这个顺序表进行初始化。 //初始化顺序表 void InitSeqList(SL* ps)//由于要改变顺序表，所以传地址 { ps-&gt;arr = NULL;//没为数组分配内存空间 ps-&gt;capacity = 0; ps-&gt;size = 0; } 在顺序表中增加数据 接下来就开始实现增加数据，这个增加稍微有所不同：是在指定的位置增加数据。
我们先来实现两种特殊的情况：头插和尾插。头插是在顺序表的第一个位置（数组下标为0的位置）插入（增加）数据；尾插是在顺序表的有效数据的末尾插入（增加）数据。
首先，来实现头插：（数据从后往前覆盖）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f140989a10519fba5ae5ccbdc61102e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/316364288d2859184260b1b99295a1f7/" rel="bookmark">
			前端必备技能——轮播图（原生代码&#43;插件），前端开发项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		height: 20px;
border-radius: 50%;
margin-right: 6px;
background: rgba(0, 0, 0, .3);
}
.circle .current {
background-color: #fff;
}
3.动画效果
接下来就是我们的重头戏，将页面中的图片滚动起来就是轮播图：
制作轮播图我们所想要的效果：
在写javascript之前，我们需要先绑定“load”事件，为了能够让页面渲染完再执行javascript
代码如下：
window.addEventListener(‘load’, function() {
}
鼠标经过轮播图 当鼠标经过轮播图，左右按钮就显示，一旦离开就隐藏左右按钮。
用mouseenter、mouseleave两个事件来绑定执行：
focus.addEventListener(‘mouseenter’, function() {
arrowl.style.display = ‘block’;
arrowr.style.display = ‘block’;
})
focus.addEventListener(‘mouseleave’, function() {
arrowl.style.display = ‘none’;
arrowr.style.display = ‘none’;
}, 2000);
})
点击左右按钮图片就播放一张 思路：我们先定义一个全局变量num，当我们点击一下就自增一次，然后滚动的距离就是ul的滚动距离，ul滚动距离=num*图片宽度。
var num = 0;
// 右侧按钮
arrowr.addEventListener(‘click’, function() {
if (flag) {
// flag = false; //关闭节流阀
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/316364288d2859184260b1b99295a1f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef547677077e57de6d44776ff0c90edc/" rel="bookmark">
			关于Exception in thread “main“ java.lang.NoSuchMethodError: 报错的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在进行项目框架搭建完成，启动测试的时候出现了这样的问题：
根据报错信息应该是spring框架中SpringFactoriesLoader这个类中的forDefaultResourceLocation方法不存在。
于是在依赖项中排查相应的maven库
分析springframework，发现在springframework：spring-core中是有这个方法的，
但是有两个不同版本的包
在5.323的版本中是没有的
这下破案了，应该是依赖时使用了错误的包，有的包使用的是5.323的版本，而有的使用的是6.04的版本，怎么解决呢？
使用了@Anakki在java.lang.NoSuchMethodError: org.springframework.core.annotation.AnnotationAwareOrderComparator.sort-CSDN博客这篇文章中的方法查看了依赖结构
emmmmm，全部依赖的都是 6.0.4和6.1.0，这就奇怪了，为什么会爆出这样的错误呢，也没有看到什么错误的依赖
直接不作不休了，上maven文件夹把5.23的jar包删掉试试，如果报错就说明项目引用的实际上还是5.23
IDEA，启动！
有趣的事情发生了，还真是这个包的问题，可是我查了maven的依赖中并没有这个包啊？有没有大佬给点思路？
啊啊啊啊啊想起来了，我这是个多模块项目，刚才光盯着主模块看了，没想到可能是子模块的依赖项目出问题
我们直接对子模块进行依赖关系分析
还真是这个玩意引用了5.3.23的包，怎么个事，怎么别的项目都是6.04就它这么特殊？
原来是我创建子模块的时候手残了没有把spring boot的版本设置成跟主模块相同的3.02啊，那没事了。
重新设置好版本，运行maven clean，重新maven install
Yes，这回没有那个5.3.23了，WebApplition，启动！
啊这，问题不大问题不大，原来是我没设置数据库的url，先把这个在pom文件中注释掉……
成功运行好耶！
总结一下：浪费了好几个小时，最终发现是自己太粗心emmmmm，好在在解决问题的过程中学到了很多IDEA的使用方法和依赖问题的解决方案，所以说还算不亏？（但是这粗心的毛病什么时候能改改啊）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de0c2441bfa6235ccb250d39ecae64f0/" rel="bookmark">
			2024免费Mac苹果解压压缩包软件BetterZip5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在2024年，对于Mac电脑用户来说，如果你想要无需解压就能快速查看压缩文档的内容，BetterZip是一个极佳的选择。这款软件不仅支持多种格式的压缩和解压，如zip、rar、7z、tar等，还具备丰富的功能和设置，包括预览、编辑、加密、分卷、过滤等。
使用BetterZip，你可以轻松地将需要操作的压缩文件拖到软件界面内，然后单击选中存档中的压缩文件，就可以在右下方的界面中预览到这个压缩文件中的内容了。这个过程无需解压整个文档，非常便捷。
此外，BetterZip还有简洁的界面和操作，可以通过拖拽或右键菜单来压缩或解压文件。同时，它还可以集成到Finder中，提供快捷的压缩和解压操作。这些特点使得BetterZip成为Mac电脑上备受推崇的压缩解压软件。
BetterZip是一款专为苹果电脑开发且功能全面的压缩软件，是Mac平台上颇受好评的“解压缩”工具之一。它支持十余种主流文件格式的解压缩，且能够对压缩文件进行单独加密处理。BetterZip能对多个文件同时进行压缩，缩短多个文件压缩的时间。
BetterZip5-安装包绿色版下载如下：
https://wm.makeding.com/iclk/?zoneid=60187
除此之外，它还支持文件预览功能，即无需正式解压也能浏览压缩包内的文件。
2.keka 用户如果喜欢轻量化的解压软件，选择keka肯定不会错！keka软件体积小巧且页面简洁。压缩设置简单，支持解压RAR, 7z, Lzma, Zip, Tar, Gzip, Bzip2等格式的压缩包。
3.归档实用工具
如果经常收到zip格式的压缩包，你会发现，苹果电脑可以直接对其进行解压，这是因为苹果自带的解压缩软件“归档实用工具”，可直接解压zip格式的压缩包。用户只需要右键文件，打开方式选择“归档实用工具”即可完成解压操作。但对于其他比较常见的格式，诸如RAR、7z、TAR等，则无能为力。
1.下载并安装软件，
2.运行软件，将需要解压的压缩包拖入软件界面。
3.选择待解压文件并点击软件上方工具栏中的“解压”按钮。
4.等待软件解压即可。
软件评测：BetterZip for Mac
一、主要功能
BetterZip是一款专为Mac系统设计的压缩与解压软件，凭借其强大的功能和便捷的操作，受到了广大Mac用户的喜爱。其主要功能包括：
支持多种压缩格式：如ZIP、RAR、7-Zip、TAR、GZ等，几乎涵盖了市面上所有主流的压缩格式，满足用户多样化的需求。
无需解压即可预览：用户可以直接在软件内预览压缩包中的文件，包括图片、文档等，无需解压整个压缩包，大大节省了时间和空间。
文件加密与保护：提供AES-256等高强度加密方式，确保用户数据的安全性。
批量处理：支持同时处理多个压缩任务，提高工作效率。
Finder集成：与Mac的Finder无缝集成，用户可以直接在Finder中对文件进行压缩和解压操作。
智能修复：在解压过程中，如果遇到损坏的文件，BetterZip能够自动检测并尝试修复，确保数据的完整性。
二、使用方法
使用BetterZip非常简单，用户只需将需要压缩或解压的文件拖放到软件界面，然后选择相应的操作即可。软件界面简洁直观，支持拖放操作，大大降低了用户的学习成本。
三、适用场景
BetterZip适用于各种需要压缩和解压文件的场景，如：
文件传输：在需要将大量文件或文件夹发送给他人时，可以使用BetterZip进行压缩，减小文件体积，加快传输速度。
备份与恢复：对于重要的文件或数据，用户可以使用BetterZip进行压缩并加密，然后存储到安全的地方，以备不时之需。
节省磁盘空间：对于不经常使用的文件或数据，可以使用BetterZip进行压缩，以节省磁盘空间。
四、用户评价
根据我们的收集，大部分用户对BetterZip的评价都非常高。他们认为这款软件功能强大、操作简便、界面美观，是Mac系统上不可或缺的压缩与解压工具。当然，也有部分用户提到软件的价格相对较高，但考虑到其提供的功能和服务，这个价格也是相对合理的。
五、专业评价与建议
作为一款专业的压缩与解压软件，BetterZip在功能、性能和用户体验方面都表现出色。它支持多种压缩格式、提供高强度的加密方式、支持批量处理等操作，能够满足各种用户的需求。同时，其简洁直观的界面和易上手的操作也大大降低了用户的学习成本。
当然，软件的价格可能对一些用户来说是一个考虑因素。但考虑到其提供的功能和服务以及Mac系统的特殊性（Mac系统上优秀的压缩解压软件相对较少），这个价格也是相对合理的。因此，如果你是一位Mac用户且经常需要处理压缩文件的话，我会强烈推荐你使用BetterZip这款软件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b404f34da566e2ebe971f7bfce115474/" rel="bookmark">
			常微分方程算法之阿当姆斯法（Adams法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、方法背景
二、算法原理及推导过程
1、辛普森（Simpson）方法
2、汉明（Hamming）方法
3、隐式四阶阿当姆斯（Adams）方法
4、预估-校正阿当姆斯法
三、算例实现 一、方法背景 欧拉法、梯形法、改进欧拉法以及龙格-库塔法都属于单步法，即计算的时候只用到上一步的值。如果可以将已经计算出来的结果值用于的计算，就能够增加计算精度。我们尝试使用前面已经计算出来的k个值来提高求解的精度，即线性多步法的思路。通常线性k步法的公式为：
式中且，和为待定系数。如果，就是单步法：
，其中
若，得到，即为欧拉法；
若，得到，即为隐式欧拉法；
若，得到，即为梯形法。
同时，如果时是显格式；如果时是隐格式。
龙格-库塔法的原理是利用函数在某点处的函数值的线性组合来计算导数，而线性多步法的原理则是利用已经算出的函数值的线性组合来计算导数。
二、算法原理及推导过程 我们尝试推导k=3时的隐式线性多步法数值计算公式（即），阶数为四阶：
对于上式，其截断误差为：
假设，则，在处对分别使用泰勒公式，将得到的展开式带入到截断误差计算公式中可得：
为了得到四阶格式，需要满足：
上式有无穷多解，只要满足上式条件的系数、所组成的隐式线性多步格式都是四阶的。
其中，满足和系数条件的个别情况下的著名方法有：
1、辛普森（Simpson）方法 取，可得：
2、汉明（Hamming）方法 取，可得：
3、隐式四阶阿当姆斯（Adams）方法 取，可得：
在线性多步法中，形如：
的k步法称为阿当姆斯法。当时为阿当姆斯显格式，称为Adams-Bashforth公式；当时为阿当姆斯隐格式，称为Adams-Monlton公式。
4、预估-校正阿当姆斯法 与改进欧拉法类似，可以通过显示法预测初值，然后利用隐式法进行迭代。阿当姆斯法也可以使用预估-校正的方式进行计算：
显式阿当姆斯法为：
隐式阿当姆斯法为：
于是，预估-校正阿当姆斯法为：
①预估: ②校正： 三、算例实现 求解初值问题：
步长h=0.2。已知精确解为：
代码如下：
#include &lt;cmath&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; int main(int argc, char* argv[]) { int i,N; double a,b,h,y0,k1,k2,k3,k4,err,y_predict; double *x,*y; double exact(double x); double f(double x, double y); a=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b404f34da566e2ebe971f7bfce115474/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a50dac00a2037cfdb6d779e4e170c96/" rel="bookmark">
			【阿里云 centos7安装python3.12遇到的坑，openssl】Could not build the ssl module! Python requires a OpenSSL 1.1.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Could not build the ssl module! 基于源码安装python 3.12，执行`make`出现如下错误openssl 官网版本推荐安装openssl安装python 基于源码安装python 3.12，执行make出现如下错误 _hashlib _ssl _tkinter To find the necessary bits, look in configure.ac and config.log. Could not build the ssl module! Python requires a OpenSSL 1.1.1 or newer Checked 111 modules (31 built-in, 76 shared, 1 n/a on linux-x86_64, 0 disabled, 3 missing, 0 failed on import) 问题大概描述：找不到ssl模块。该问题如果不解决的话，缺少 OpenSSL 模块可能会影响许多涉及网络通信和安全加密的 Python 应用程序和库。例如：ssl,request模块等好多模块都没法使用。所以要要去openssl官网下载安装，再来安装python。
openssl 官网 注意:最新的稳定版本是3.2系列，支持到2025年11月23日。3.1系列支持到2025年3月14日，3.0系列是一个长期支持(LTS)版本，支持到2026年9月7日。所有旧版本(包括1.1.1、1.1.0、1.0.2、1.0.0和0.9.8)现在都不支持，不应该使用。建议这些旧版本的用户尽快升级到3.2或3.0。对1.1.1和1.0.2的扩展支持可以访问这些版本的安全修复程序。
版本推荐 虽然openssl官网推荐最新版本，但是安装python，执行make依然会报错，我建议下载安装python3.12时推荐的openssl 1.1.1版本。
[root@iZwz98v1pircy9j9329rhrZ local]# pwd /usr/local [root@iZwz98v1pircy9j9329rhrZ local]# ll total 60 drwxr-xr-x 8 root root 4096 Apr 4 20:22 aegis drwxr-xr-x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a50dac00a2037cfdb6d779e4e170c96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96e1898ea63685276fd16b884fb0ffe3/" rel="bookmark">
			JavaSE-----内部类详解（实例内部类，局部内部类，静态内部类，匿名内部类）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
认识内部类：
一.实例内部类：
二.局部内部类：
三 匿名内部类：
四、静态内部类
小结：
认识内部类： 🐻🐻🐻什么是内部类？官方解释：Java内部类是指在一个类的内部定义的类。它可以访问外部类的成员变量和方法，并且可以被外部类实例化。
🦉🦉🦉通俗的来讲就是：字面意思，在类的内部编写的类就叫内部类！即一个类的内部又完整的嵌套了另一个类结构，被嵌套的类称为内部类(inner class),嵌套其他类的类称为外部类(outer class)。
😺😺😺内部类是类的第五大成员→【提示:类的五大成员是哪些?----》[属性、方法、构造器、代码块、内部类]】
🧐🧐🧐部类一般来说包括这四种：实例内部类、局部内部类、匿名内部类和静态内部类。
🐞官方给的内部类优点如下：
1.每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整；
2.方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏；
3.方便编写事件驱动程序；
4.方便编写线程代码。
注意：内部类会增加代码的复杂性，因此在使用时需要根据实际情况进行选择。
一.实例内部类： 在类的内部方法的外部编写的类就是实例内部类
实例内部类的特点：
🧐🧐🧐实例内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）；🧐🧐🧐同名的属性名/方法名访问外部类时 → 外部类.this.成员名 OuterClass.this.name 实例内部类是依附外部类而存在的，也就是说，如果要创建实例内部类的对象，前提是必须存在一个外部类的对象。 如下所示：
OuterClass out = new OuterClass(); OuterClass.InnerClass innerClass = out.new InnerClass(); innerClass.test();//访问实例内部类的方法 out.testA();//访问自己的方法 注意:实例内部类中不能书写静态变量和方法：
实例内部类案例演示：
class OuterClass { public int data1 = 1; private int data2 = 2; public static int data3 = 3; class InnerClass { public int data1 = 100; public int data4 = 4; private int data5 = 5; public int data6 = 6; public void test() { /*OuterClass outerClass = new OuterClass(); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96e1898ea63685276fd16b884fb0ffe3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0386aec8ca55100d15521104a158ef78/" rel="bookmark">
			植物大战僵尸Python版，附带源码注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、实现功能
二、安装环境要求
三、如何开始游戏
四、怎么玩
五、演示
六、部分源码注释
6.1main.py
6.2map.py
6.3Menubar.py
七、自定义
7.1plant.json
7.2zombie.json
一、实现功能 实施植物：向日葵、豌豆射手、壁桃、雪豆射手、樱桃炸弹、三豌豆射手、大口蘑菇，海扁蘑菇，土豆，尖刺草，惊吓蘑菇，南瓜，惊吓蘑菇，墨西哥辣椒，太阳蘑菇，冰蘑菇，催眠蘑菇。实现僵尸：僵尸、旗帜僵尸、锥头僵尸、桶头僵尸、报纸僵尸。使用JSON文件存储关卡数据（例如僵尸的位置和时间，背景信息）支持在关卡开始时选择植物卡支持日间关卡、夜间关卡、移动卡选择关卡和壁桃保龄球关卡 二、安装环境要求 Python 3.7Notice:建议使用 python 3.7 版本，但不是必需的。对于 LINUX：如果您的 Linux 系统预装了 python 3+，则可以运行此游戏。直接更新到 python 3.7 可能会破坏 LINUX Mint。Python-Pygame 1.9 三、如何开始游戏 python main.py 四、怎么玩 使用鼠标收集阳光，选择植物卡片并播种植物您可以通过更改 source/constants.py 中的START_LEVEL_NUM值来设置起始级别 级别 1 和 2：天级别第 3 级：夜间级别第 4 级：移动卡片选择级别第5级：墙果保龄球级别 五、演示 六、部分源码注释 项目结构如下：
6.1main.py import pygame as pg from source.main import main if __name__=='__main__': main() pg.quit() 6.2map.py 定义了一个地图类 Map，包含了地图的初始化、位置验证、可移动性检查、位置转换等方法。
__author__ = 'marble_xu' # 导入必要的模块 import random import pygame as pg from .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0386aec8ca55100d15521104a158ef78/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/37/">«</a>
	<span class="pagination__item pagination__item--current">38/71</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/39/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>