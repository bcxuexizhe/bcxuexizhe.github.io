<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0ee35fe225f055c650e8373f77b753e/" rel="bookmark">
			【赠书第22期】AI绘画全面精通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
前言
1 AI绘画基础知识
2 AI绘画技术应用
2.1 风格迁移
2.2 自动绘画
2.3 辅助绘画
3 AI绘画发展前景
3.1 艺术创作领域的变革
3.2 跨领域融合与创新
3.3 个性化艺术创作的普及
4 结语
5 推荐图书
6 粉丝福利
前言 随着科技的飞速发展，人工智能（AI）已经渗透到了我们生活的方方面面，其中 AI 绘画便是近年来备受瞩目的一个领域。AI 绘画不仅为我们带来了全新的艺术体验，还在一定程度上改变了传统绘画行业的生态。本文将围绕 AI 绘画展开探讨，从基础知识、技术应用、发展前景等多个方面，全面解析如何精通 AI 绘画。
1 AI绘画基础知识 AI 绘画是基于人工智能技术的绘画方式，它利用深度学习、神经网络等算法，让计算机能够模拟人类的绘画技巧和艺术风格。与传统绘画相比，AI 绘画具有更高的效率、更低的成本和更丰富的表现力。
要精通 AI 绘画，首先需要了解计算机视觉、图像处理等基础知识。这些知识将帮助我们更好地理解 AI 绘画的原理和实现方式。此外，还需要掌握一定的编程技能，以便能够编写和调试AI绘画程序。
2 AI绘画技术应用 AI 绘画技术的应用非常广泛，下面我们将从几个典型的方面进行介绍。
2.1 风格迁移 风格迁移是 AI 绘画的一个重要应用方向。它可以通过训练神经网络，将一幅图像的风格迁移到另一幅图像上，从而创造出具有独特风格的艺术作品。这种技术在艺术创作、设计等领域具有广阔的应用前景。
2.2 自动绘画 自动绘画是 AI 绘画的另一个重要应用。通过训练神经网络学习大量的绘画作品，AI可以自动生成具有一定艺术价值的绘画作品。这种技术可以大大提高绘画创作的效率，为艺术家提供更多的创作灵感。
2.3 辅助绘画 AI 绘画还可以作为辅助工具，帮助艺术家完成一些繁琐的绘画任务。例如，通过 AI 技术可以自动填充颜色、优化线条等，减轻艺术家的工作负担，让他们有更多精力专注于创作本身。
3 AI绘画发展前景 随着技术的不断进步和应用场景的不断拓展，AI 绘画的发展前景十分广阔。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0ee35fe225f055c650e8373f77b753e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7ebb2b8117932a4133f774591ae0e4b/" rel="bookmark">
			MySQL-----多表查询（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.子查询概述：
二：标量子查询：
三：列子查询：
四：行子查询：
五：表子查询：
六：练习部分：
写在之前：本文承接上文MySQL-----多表查询（一）-CSDN博客
一.子查询概述： 首先引出子查询的概念：子查询指一个查询语句嵌套在另一个查询语句内部的查询，即SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询
SQL 中子查询的使用大大增强了 SELECT 查询的能力，因为很多时候查询需要从结果集中获取数据，或者需要从同一个表中先计算得出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集合）进行比较。
如下面这种形式： SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2 ); 子查询分类：
A. 标量子查询（子查询结果为单个值）B. 列子查询(子查询结果为一列)C. 行子查询(子查询结果为一行)D. 表子查询(子查询结果为多行多列) 查询位置可分为：
A. WHERE之后B. FROM之后C. SELECT之后 接着，基于上面的概述，相信你对子查询有了一定了解了，首先我们导入要查询的数据，下面在根据子查询的分类一个一个说明：（在查询之前，我们先导入数据（建立表以及表之间的关系））
-- 创建部门表 create table dept( id int auto_increment comment 'ID' primary key, name varchar(50) not null comment '部门名称' )comment '部门表'; INSERT INTO dept (id, name) VALUES (1, '研发部'), (2, '市场部'),(3, '财务部'), (4, '销售部'), (5, '总经办'), (6, '人事部'); -- 创建员工表 create table emp( id int auto_increment comment 'ID' primary key, name varchar(50) not null comment '姓名', age int comment '年龄', job varchar(20) comment '职位', salary int comment '薪资', entrydate date comment '入职时间', managerid int comment '直属领导ID', dept_id int comment '部门ID' )comment '员工表'; -- 设置外键约束 alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id); -- 插入数据 INSERT INTO emp (id, name, age, job,salary, entrydate, managerid, dept_id) VALUES (1, '金庸', 66, '总裁',20000, '2000-01-01', null,5), (2, '张无忌', 20, '项目经理',12500, '2005-12-05', 1,1), (3, '杨逍', 33, '开发', 8400,'2000-11-03', 2,1), (4, '韦一笑', 48, '开发',11000, '2002-02-05', 2,1), (5, '常遇春', 43, '开发',10500, '2004-09-07', 3,1), (6, '小昭', 19, '程序员鼓励师',6600, '2004-10-12', 2,1), (7, '灭绝', 60, '财务总监',8500, '2002-09-12', 1,3), (8, '周芷若', 19, '会计',4800, '2006-06-02', 7,3), (9, '丁敏君', 23, '出纳',5250, '2009-05-13', 7,3), (10, '赵敏', 20, '市场部总监',12500, '2004-10-12', 1,2), (11, '鹿杖客', 56, '职员',3750, '2006-10-03', 10,2), (12, '鹤笔翁', 19, '职员',3750, '2007-05-09', 10,2), (13, '方东白', 19, '职员',5500, '2009-02-12', 10,2), (14, '张三丰', 88, '销售总监',14000, '2004-10-12', 1,4), (15, '俞莲舟', 38, '销售',4600, '2004-10-12', 14,4), (16, '宋远桥', 40, '销售',4600, '2004-10-12', 14,4), (17, '陈友谅', 42, null,2000, '2011-10-12', 1,null); 创建好后的表中数据及其对应关系：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7ebb2b8117932a4133f774591ae0e4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01eafd81206ec4747178bedc86d17aab/" rel="bookmark">
			RabbitMQ的是什么？RabbitMQ的使用场景？为什么要使用RabbitMQ，它对于其他中间件优势是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、消息中间件是什么？有哪些消息中间件？ Java消息中间件（Java Message Oriented Middleware，Java MOM）是基于Java语言开发的用于实现消息传递的中间件。它提供了一种可靠、异步、分布式的消息通信机制，用于在分布式系统中进行应用程序之间的通信和数据交换。
常见的Java消息中间件包括：
RabbitMQ：一个开源的、高性能的、可靠的消息中间件，采用AMQP协议，并提供了丰富的功能和插件。Apache Kafka：一个分布式的流数据平台，具有高吞吐量、可扩展性和持久性特性，适用于构建实时数据流应用。ActiveMQ：一个开源的、高性能的、可靠的消息中间件，采用JMS协议，并提供了多种消息传递模式和特性。IBM MQ：一款可靠的、安全的企业级消息传递中间件，支持多种协议和平台，并提供了高可用性和故障恢复能力。RocketMQ：一个分布式的、可靠的消息中间件，由阿里巴巴集团开发，支持大规模的消息传递和处理。JBoss Messaging：一个开源的、可编程的、可扩展的消息中间件，适用于构建可靠的分布式应用。HornetQ：一个开源的、高性能的、可扩展的消息中间件，由Red Hat公司开发，提供了JMS和Core API两种接口。 这些Java消息中间件各有特点和适用场景，可以根据具体需求进行选择和使用。它们都提供了Java客户端库和文档，方便开发人员进行集成和使用。
二、RabbitMQ的是什么？ RabbitMQ是一个开源消息中间件，用于在应用之间传递消息。它实现了高可靠性、可扩展性和灵活性，可以在分布式系统中使用，以支持复杂的消息通信模式。
RabbitMQ基于AMQP（高级消息队列协议）标准，允许应用程序之间进行异步通信。它可以处理大量的消息，同时保证消息的有序性和可靠性。
RabbitMQ提供了丰富的特性，包括多种交换机类型、队列和绑定的灵活配置，以及可靠的消息传递机制。它还支持消息的持久化、消息确认和事务等功能，使得开发者可以构建可靠的消息传递系统。
RabbitMQ可以用于各种应用场景，包括异步任务处理、事件驱动架构、日志收集和分发、发布订阅模式等。它在分布式系统中起到了连接各个应用和组件的重要角色，提供了可靠和高效的消息传递机制。
三、RabbitMQ在什么场景下使用？ 系统解耦：当需要将系统的不同部分解耦时，可以使用RabbitMQ作为消息的中间传递者。不同的系统之间通过发送和接收消息来进行通信，而不需要直接依赖于彼此。
异步处理：RabbitMQ可以用于异步处理任务。生产者将任务消息发送到RabbitMQ，然后消费者从队列中获取消息并处理。这种方法可以提高系统的响应性和吞吐量。
负载均衡：使用RabbitMQ可以实现负载均衡。当有多个消费者订阅同一个队列时，RabbitMQ会将消息均匀地发送给每个消费者，从而实现负载均衡。
优先级队列：RabbitMQ支持消息的优先级，可以为不同的消息设置不同的优先级。这在一些需要对消息进行排序和处理的场景中非常有用。
发布/订阅模式：RabbitMQ支持发布/订阅模式，可以同时将消息发送给多个消费者。生产者发布消息到交换机上，多个消费者可以订阅该交换机的队列来接收消息。
可靠性传输：RabbitMQ支持消息的持久化和可靠性传输。消息可以被持久化到磁盘上，即使RabbitMQ服务器出现故障，消息也不会丢失。
RabbitMQ具有高性能、可靠性和灵活性，适用于解决分布式系统中的可靠消息传递和异步通信的问题。它提供了丰富的功能和各种适配器，使得它在各种场景下使用都非常方便。
四、为什么要使用RabbitMQ，它对于其他中间件优势是什么？ 使用RabbitMQ有以下优势：
可靠性：RabbitMQ提供了消息的持久化和可靠性传输。这意味着即使在消息进入队列但尚未被处理或传递给消费者时，消息也可以被保存到磁盘上，以确保消息不会丢失。这使得RabbitMQ非常适合对消息可靠性要求较高的应用场景。
灵活性：RabbitMQ支持多种消息传递模式，包括点对点、发布/订阅、请求/响应等。这使得开发人员可以根据不同的需求选择最适合的模式，并灵活地构建复杂的消息传递系统。
可扩展性：RabbitMQ具有良好的可扩展性，可以在需要时轻松增加或减少服务器节点。这使得RabbitMQ能够应对高负载和大流量的情况，并保持高性能和低延迟。
多语言支持：RabbitMQ支持多种编程语言，包括Java、Python、Ruby、C#等。这使得开发人员可以使用他们熟悉的编程语言与RabbitMQ进行交互，方便快捷地开发和维护应用程序。
社区支持和生态系统：RabbitMQ拥有庞大的开源社区，这意味着有大量的文档、教程、示例代码和解决方案可供参考。此外，RabbitMQ还与其他开源工具和框架集成非常好，如Spring Boot、Docker和Kubernetes等，形成了一个强大的生态系统。
与其他中间件相比，RabbitMQ的主要优势在于其可靠性、灵活性和可扩展性。它提供了丰富的功能和良好的性能，适用于处理不同规模和类型的消息传递需求。此外，RabbitMQ的开源性和活跃的社区支持也是其优势之一，这使得开发人员更容易学习和使用该中间件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dc9df6b054d5424b623c2bdd7290f8a/" rel="bookmark">
			在HTML中使用JavaScript实时显示当前日期和时间（结尾完整例程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Web开发中，经常需要在网页上显示当前的日期和时间。HTML本身并不具备这样的动态功能，但我们可以借助JavaScript来实现。JavaScript是一种常用的前端脚本语言，它可以轻松地获取系统时间，并将其插入到HTML元素中。
下面是一个简单的示例，演示如何在HTML中使用JavaScript实时显示当前的日期和时间：
首先，我们创建一个HTML文件，并在其中添加一个用于显示日期和时间的&lt;p&gt;元素。给它一个唯一的id，这样我们就可以通过JavaScript找到它并更新其内容。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;实时显示当前日期和时间&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p id="currentDateTime"&gt;加载中...&lt;/p&gt; &lt;!-- 引入JavaScript代码 --&gt; &lt;script src="display-datetime.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 接下来，我们创建一个名为display-datetime.js的JavaScript文件，并编写用于获取和格式化当前日期时间的函数。
// 显示当前日期时间的函数 function showCurrentDateTime() { const now = new Date(); const year = now.getFullYear(); const month = String(now.getMonth() + 1).padStart(2, '0'); // 月份从0开始，所以+1 const day = String(now.getDate()).padStart(2, '0'); const hours = String(now.getHours()).padStart(2, '0'); const minutes = String(now.getMinutes()).padStart(2, '0'); const seconds = String(now.getSeconds()).padStart(2, '0'); const formattedDateTime = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`; document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dc9df6b054d5424b623c2bdd7290f8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/645d81e0a9266195b2458f1e91794ec4/" rel="bookmark">
			深入探索 Python 中的动态数组：实现、操作、优化及其与传统数组和其他数据结构的性能比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 简介1.1 什么是动态数组？1.2 Python 中的动态数组与传统数组的比较1.3 动态数组与其他数据结构的性能比较 2. Python 中的动态数组实现2.1 Python 列表的基本特性2.2 如何在 Python 中使用列表模拟动态数组 3. 内部工作原理3.1 列表的存储结构：如何在内存中表示3.2 动态调整大小：当数组达到当前容量时，Python 如何调整其大小3.3 时间复杂度分析：对添加元素的平摊时间复杂度进行分析 4. 列表的缩减4.1 使用 `del` 语句删除元素4.2 重新分配或通过切片调整大小 5. 优化和局限性5.1 如何优化列表操作5.2 动态数组的局限性 动态数组作为一种灵活的数据结构，其重要性不言而喻。
1. 简介 1.1 什么是动态数组？ 动态数组是一种数组，它可以在运行时动态调整其大小，以适应需要存储的数据量的变化。与静态数组不同，静态数组在创建时需要指定大小，并且其大小在整个生命周期中保持不变。动态数组通过在数组达到其容量极限时自动重新分配内存，并将元素复制到新的、更大的内存区域中来实现这一点。这种灵活性使得动态数组成为很多编程任务中非常受欢迎的数据结构。
在 Python 中，动态数组通常是通过列表（list）数据类型实现的。列表允许程序员在不关心底层数据存储细节的情况下，添加、删除和修改元素。
1.2 Python 中的动态数组与传统数组的比较 大小调整： 传统数组（如 C 或 Java 中的数组）：通常需要在编写代码时确定数组的大小，且一旦设置，数组的大小不能更改。Python 列表：不需要事先声明大小。列表的大小是动态和灵活的，可以根据需要增长或缩减。 性能考虑： 传统数组：访问元素的时间复杂度为 O(1)，因为它们提供直接的内存访问。Python 列表：同样提供 O(1) 时间复杂度的元素访问。但是，当列表需要扩容时（例如添加更多元素超过当前容量时），需要重新分配内存和复制现有元素到新的内存地址，这个操作的平均时间复杂度是 O(n)。 内存使用： 传统数组：可能会有内存浪费，如果数组的分配大小大于实际需要。Python 列表：更加灵活地管理内存，只有在需要更多空间时才进行内存重新分配，并且通常会按比当前需要稍大的量进行分配，以减少频繁的内存分配。 易用性： 传统数组：使用起来可能较为复杂，需要处理低级的内存管理问题。Python 列表：极大简化了数组操作，用户无需直接管理内存，可以使用多种便捷的方法进行列表操作，如 append(), remove(), pop() 等。 1.3 动态数组与其他数据结构的性能比较 动态数组（Python 列表）与其他数据结构如字典、集合和元组的性能比较主要集中在几个方面：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/645d81e0a9266195b2458f1e91794ec4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03f1597542f5fade6d56946b159a6992/" rel="bookmark">
			寝室快修|基于SprinBoot&#43;vue的贵工程寝室快修小程序(源码&#43;数据库&#43;文档)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		贵工程寝室快修目录
目录
基于SprinBoot+vue的贵工程寝室快修小程序
一、前言
二、系统设计
三、系统功能设计 1学生信息管理
2 在线报修管理
3公告信息管理
4论坛信息管理
四、数据库设计
五、核心代码 六、论文参考
七、最新计算机毕设选题推荐
八、源码获取：
博主介绍：✌️大厂码农|毕设布道师，阿里云开发社区乘风者计划专家博主，CSDN平台Java领域优质创作者，专注于大学生项目实战开发、讲解和毕业答疑辅导。✌️
主要项目：小程序、SpringBoot、SSM、Vue、Html、Jsp、Nodejs等设计与开发。
🍅文末获取源码联系🍅
基于SprinBoot+vue的贵工程寝室快修小程序 一、前言 贵工程寝室快修小程序使用Java语言进行编码，使用Mysql创建数据表保存本系统产生的数据。系统可以提供信息显示和相应服务，其管理贵工程寝室快修小程序信息，查看贵工程寝室快修小程序信息，管理贵工程寝室快修小程序。
总之，贵工程寝室快修小程序集中管理信息，有着保密性强，效率高，存储空间大，成本低等诸多优点。它可以降低信息管理成本，实现信息管理计算机化。
关键词：贵工程寝室快修小程序；Java语言；Mysql
二、系统设计 系统功能结构如图
三、系统功能设计 1学生信息管理 如图5.1显示的就是学生信息管理页面，此页面提供给管理员的功能有：学生信息的查询管理，可以删除学生信息、修改学生信息、新增学生信息，
还进行了对用户名称的模糊查询的条件
图5.1 学生信息管理页面
2 在线报修管理 如图5.2显示的就是在线报修管理页面，此页面提供给管理员的功能有：查看已发布的在线报修数据，修改在线报修，在线报修作废，即可删除，还进行了对在线报修名称的模糊查询 在线报修信息的类型查询等等一些条件。
图5.2 在线报修管理页面
3公告信息管理 如图5.3显示的就是公告信息管理页面，此页面提供给管理员的功能有：根据公告信息进行条件查询，还可以对公告信息进行新增、修改、查询操作等等。
图5.3 公告信息管理页面
4论坛信息管理 如图5.4显示的就是论坛信息管理页面，此页面提供给管理员的功能有：根据论坛信息进行新增、修改、查询操作等等。
图5.4 论坛信息管理页面
四、数据库设计 （1）下图是论坛实体和其具备的属性。
论坛实体属性图
（2）下图是学生实体和其具备的属性。
学生实体属性图
（3）下图是维修人员实体和其具备的属性。
维修人员实体属性图
（4）下图是公告实体和其具备的属性。
公告实体属性图
数据库表的设计，如下表：
表4.1字典表
序号
列名
数据类型
说明
允许空
1
Id
Int
id
否
2
dic_code
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03f1597542f5fade6d56946b159a6992/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ae9424a03cb74d9e710cd38c6965a71/" rel="bookmark">
			【Go语言快速上手(五)】文件操作&amp;协程操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💓博主CSDN主页:杭电码农-NEO💓
⏩专栏分类:Go语言专栏⏪
🚚代码仓库:NEO的学习日记🚚
🌹关注我🫵带你学习更多Go语言知识
🔝🔝
GO快速上手 1. 前言2. GO语言的文件操作2. 初识协程3. 协程的等待问题4. 协程的资源竞争问题5. 总结以及拓展 1. 前言 本篇文章将会将GO语言的一大杀器,那就是协程. 为啥很多大厂都在慢慢的转GO.看完这篇文章你可能会有所感悟
本章重点:
本篇文章会讲解GO语言中如何读写/创建文件,也就是我们所谓的IO流的用法. 然后, 会讲解协程的基本概念和GO语言中是如何操控协程的, 在协程的讲解中会穿插资源竞争下的锁问题,会讲解互斥锁和读写锁在GO语言中是如何使用的. 最后会给大家讲解GO语言中的特殊的类型: channel管道
2. GO语言的文件操作 这里就不多叙述什么是IO操作了,毕竟本系列的文章不是0基础. 首先最经典的IO操作函数,open和close:
请注意, open是函数,而close是方法,他们的用法是不同的,并且,open函数位于os包下,使用前记得import包进去. 除此之外,打开文件后不能直接读取内容,需要创建一个流,这个流你可以理解为是一条管道,连接被打开的文件和程序, 利用这条管道来读取文件中的数据
package main import ( "bufio" "fmt" "os" ) func main() { //打开文件 f, err := os.Open("test.txt") if err != nil{ fmt.Println("打开文件失败 } defer f.close() //函数执行完后关闭 //创建一个流) reader := bufio.NewReader(f) //读取操作 for{ //以回车作为标识符,遇见\n后就是一次读取 str.err := reader.ReadString("\n") if err!=io.EOF{ break } fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ae9424a03cb74d9e710cd38c6965a71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdf4e986cd3f3ca3e8a4e99eae126f84/" rel="bookmark">
			【mysql】mysql中的数据类型知多少？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨✨ 欢迎大家来到景天科技苑✨✨
🎈🎈 养成好习惯，先赞后看哦~🎈🎈
🏆 作者简介：景天科技苑
🏆《头衔》：大厂架构师，华为云开发者社区专家博主，阿里云开发者社区专家博主，CSDN全栈领域优质创作者，掘金优秀博主，51CTO博客专家等。
🏆《博客》：Python全栈，前后端开发，小程序开发，人工智能，js逆向，App逆向，网络系统安全，数据分析，Django，fastapi，flask等框架，linux，shell脚本等实操经验，网站搭建，数据库等分享。
所属的专栏：MySQL数据库入门，进阶应用实战必备
景天的主页：景天科技苑
文章目录 MySQL数据类型整形DECIMALfloatdatecharvarcharconcatTINYBLOB数据库内部方法枚举和集合 MySQL数据类型 mysql主要包括以下五大类：
整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT
浮点数类型：FLOAT、DOUBLE、DECIMAL
字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB
日期类型：Date、DateTime、TimeStamp、Time、Year
其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等。
整形 INT 整形 4个字节 有符号范围(-21亿 ~ 21亿左右) 无符号(0~42亿) 大整型值 TINYINT 一个非常小的整数 1个字节 有符号范围(-128~127) 无符号(0~255) unsigned 小整型值 SMALLINT 一个小整数 MEDIUMINT 一个中间大小的整数 INT or INTEGER 一个正常大小的整数 BIGINT 一个大的整数 FLOAT 一个小的 (单精度) 浮点数，不能是无符号的那种 DOUBLE, DOUBLE PRECISION, REAL 一个正常大小 (双精度) 的浮点数，不能使无符号的那种 DECIMAL DECIMAL, NUMERIC decimal无论写入数据中的数据是多少，都不会存在精度丢失问题，这就是我们要引入decimal类型的原因， decimal类型常见于银行系统、互联网金融系统等对小数点后的数字比较敏感的系统中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdf4e986cd3f3ca3e8a4e99eae126f84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d123f7020e1189735ceedd53a496107e/" rel="bookmark">
			spring boot3多模块项目工程搭建-上（团队开发模板）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		⛰️个人主页: 蒾酒
🔥系列专栏：《spring boot实战》
目录
写在前面
多模块结构优缺点
模块介绍
Common 模块：
API 模块：
Web 模块：
Service 模块：
DAO 模块：
搭建步骤
1.创建 父Maven 项目
2.添加各模块
3.配置父项目构建
4.配置Web模块构建
5.配置Service模块构建
6.配置DAO模块构建
7.配置API模块构建
8.配置Common模块构建
9.启动类位置修改
10.编写测试接口
11.打包测试
12.启动项目测试接口
写在最后 写在前面 本文介绍了springboot开发后端服务，多模块项目工程搭建。坚持看完相信对你有帮助。
同时欢迎订阅springboot系列专栏，持续分享spring boot的使用经验。
多模块结构优缺点 多模块项目将代码分成多个子模块，每个模块可以单独构建和管理。通常适用于大型项目或团队，以及那些希望将不同的功能或服务进行解耦的场景。
优点
模块化：代码解耦，每个模块负责特定的功能，易于维护。团队协作：不同的团队可以在不同的模块上工作，减少冲突。重用性：可以将模块打包成共享库，供其他项目使用。 缺点
复杂性：项目结构更复杂，构建和部署过程可能需要更多配置。管理难度：需要更多的协调和沟通，以确保模块之间的兼容性。 模块介绍 Common 模块： 职责：Common 模块通常包含各种通用的工具类、常量定义、异常类等。功能： 存放通用的工具方法，如日期处理、字符串处理等。存放常量定义，如错误码、常量字符串、数据对象等。定义通用的异常类，如自定义的业务异常。 API 模块： 职责：API 模块用于定义应用程序的外部接口，通常是 RESTful API 或 GraphQL 接口。功能： 定义接口的请求和响应对象。定义接口的路径、请求方法和参数。提供接口文档和描述。 Web 模块： 职责：Web 模块负责处理 HTTP 请求，将请求转发给 Service 模块处理，并返回响应给客户端。功能： 处理请求参数的验证和转换。调用 Service 模块提供的服务进行业务逻辑处理。构建响应并返回给客户端。 Service 模块： 职责：Service 模块包含应用程序的业务逻辑，负责处理业务规则和数据处理。功能： 实现应用程序的业务逻辑。调用 DAO 模块提供的数据访问接口进行数据库操作。处理事务管理。 DAO 模块： 职责：DAO 模块负责与数据库进行交互，执行数据访问操作。功能： 提供数据访问对象（DAO）接口，定义对数据库的增删改查操作。实现 DAO 接口，执行 SQL 查询和更新操作。处理数据库连接和资源管理。 搭建步骤 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d123f7020e1189735ceedd53a496107e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dad4d46b2403dc07a9b3a304c4d74263/" rel="bookmark">
			【JavaScript】内置对象 - Date 日期对象 ② ( 日期格式化 | 获取年 - getFullYear | 获取月 - getMonth | 获取每月的第几天 - getDate )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、日期格式化1、获取年 - getFullYear2、获取月 - getMonth3、获取每月的第几天 - getDate4、获取每周的第几天 - getDay5、获取每天的第几小时 - getHours6、完整代码示例 Date 日期对象参考文档 : https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date
一、日期格式化 1、获取年 - getFullYear 调用 Date.prototype.getFullYear() 方法 可以获取指定日期的年份 ;
Date 是 JavaScript 的内置对象 , 用于处理日期和时间 ;prototype 是 JavaScript 中 每一个对象都有一个 prototype 属性 , 该属性 是 指向原型对象的指针 , 原型对象 包含可以由特定类型的所有实例共享的属性和方法 ;getFullYear 是一个定义在 Date 的原型对象上的方法 , 所以所有的 Date 对象实例都可以调用这个方法 ; 参考 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/getFullYear 文档 ;
调用 Date 构造函数 , 创建一个新的 Date 对象时 , 该新对象会继承 Date 的 原型对象 上的所有属性和方法 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dad4d46b2403dc07a9b3a304c4d74263/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2766452ababd2bf778a4d52eabaa090/" rel="bookmark">
			SpringMVC进阶（自定义拦截器以及异常处理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.自定义拦截器1.基本介绍1.说明2.自定义拦截器的三个方法3.流程图 2.快速入门1.Myinterceptor01.java2.FurnHandler.java3.springDispatcherServlet-servlet.xml配置拦截器4.单元测试 3.拦截特定路径1.拦截指定路径2.通配符配置路径 4.细节说明5.多个拦截器1.执行流程图2.应用实例1.FurnHandler.java目标方法2.拦截器3.结果展示 2.异常处理1.基本介绍2.局部异常处理器1.需求分析2.抛出问题1.MyExceptionHandler.java2.不处理异常则交给tomcat处理 3.局部异常实例1.MyExceptionHandler.java2.exception_mes.jsp3.结果展示 3.全局异常处理器1.基本介绍2.全局异常实例1.MyGlobalException.java2.global_exception.jsp3.结果展示 3.细节说明1.局部异常优先级高于全局异常2.处理异常机制 4.自定义异常1.基本介绍2.自定义异常应用实例1.SelfException.java2.selfex.java3.结果展示 3.可以使用有参构造，抛出异常交给异常处理器接管1.SelfException.java2.selfex.java抛出自定义异常并制定message3.MyGlobalException.java捕获自定义异常4.结果展示 5.统一异常处理器1.基本介绍2.需求分析3.具体实现1.MyExceptionHandler.java抛出数组越界异常2.springDispatcherServlet-servlet.xml配置统一异常处理器3.arrEx.jsp异常处理页面4.结果展示 6.对未知异常进行统一处理1.具体实现1.MyExceptionHandler.java抛出异常2.springDispatcherServlet-servlet.xml修改统一异常处理器3.allEx.jsp所有未知异常的处理4.结果展示 7.异常处理的优先级1.局部异常处理器2.全局异常处理器3.统一异常处理器4.Tomcat默认机制 3.springMVC阶段的配置文件1.springDispatcherServlet-servlet.xml2.web.xml 1.自定义拦截器 1.基本介绍 1.说明 2.自定义拦截器的三个方法 3.流程图 2.快速入门 1.Myinterceptor01.java package com.sun.web.interceptor; import org.springframework.stereotype.Component; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * @author 孙显圣 * @version 1.0 */ @Component //注入容器 public class Myinterceptor01 implements HandlerInterceptor { /** * 在目标方法执行前被调用，如果返回false，目标方法不会被执行 * * @param request * @param response * @param handler * @return * @throws Exception */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2766452ababd2bf778a4d52eabaa090/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f833ff52b19757eb60caaf7303d52b61/" rel="bookmark">
			web网页连接MQTT，显示数据与下发控制命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		web网页连接MQTT，显示数据与下发控制命令 零、前言 在完成一些设备作品后，常常会因为没有一个上位机用来实时检测数据和下发命令而苦恼，在上一篇文章中提到了怎么白嫖阿里云服务器，并且在上面搭建了属于自己的web网站。那么现在就可以利用这个公网web来实现一个上位机，这样就可以在有网的地方随时对设备进行监控和下发控制指令。以下就是完成这样一个可以连接MQTT服务器的web的制作过程。
一、body部分 html网页具有很多部分，其中最重要的是body部分，这部分决定了网站显示什么东西，stye部分就是对这部分进行美化。今天只完成功能，不对样式进行美化，有需要自行学习。
1.显示部分 用于显示数据，常用的有标签、文本框、标题等。显示部分我写了一个大标题，还有几个用于显示一些数据的文本，例如温度、湿度、光照强度等，这部分代码如下：
&lt;h1&gt;物联网Web界面示例&lt;/h1&gt; &lt;h2&gt;示例参数&lt;/h2&gt; &lt;p&gt;温度：&lt;span id="temperature"&gt;25°C&lt;/span&gt;&lt;/p&gt; &lt;p&gt;湿度：&lt;span id="humidity"&gt;50%&lt;/span&gt;&lt;/p&gt; &lt;p&gt;光照强度：&lt;span id="light"&gt;800 lux&lt;/span&gt;&lt;/p&gt; 温度、湿度、光照强度这三部分需要有自己唯一的id，以便于后续可以通过id来索引到，进而对显示内容进行修改。
2.按钮部分 除了有显示以外，还需要有控制，控制最常用的就是按钮的形式。举例了三个按钮，分别是控制灯光、打开设备、关闭设备
&lt;h2&gt;示例按钮&lt;/h2&gt; &lt;button onclick="toggleLight()"&gt;控制灯光&lt;/button&gt; &lt;button onclick="sendCommand('turnOn')"&gt;打开设备&lt;/button&gt; &lt;button onclick="sendCommand('turnOff')"&gt;关闭设备&lt;/button&gt; 其中的onclick就是点击按钮后，会触发执行的函数。
二、script部分 在这部分中主要写的是处理逻辑相关的代码，包括MQTT连接、数据监听、发送消息等等。
1.连接MQTT 要在web中使用MQTT服务，需要引入MQTT相关的库，使用如下代码即可引入：
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/mqtt/4.2.8/mqtt.min.js"&gt;&lt;/script&gt; 随后就可以使用MQTT的服务了，首先需要设置连接参数，例如使用的MQTT的服务器地址、端口、主题等等。例如使用开源免费的emqx服务器为例，设置一下发布主题和订阅主题：
// MQTT 连接配置 const mqttBroker = 'ws://broker-cn.emqx.io:8083/mqtt'; const publish_Topic = 'iot/my_pub'; const subscribe_Topic = 'iot/my_sub'; 随后调用connect函数即可连接MQTT服务器了：
// 创建 MQTT 客户端实例 const mqttClient = mqtt.connect(mqttBroker); 这样就可以尝试连接到开源的emqx服务器上了，那到底有没有连接上呢，还需要写点代码来验证，我们就让web连接上后打印一下连接成功。代码如下：
// 连接事件处理 mqttClient.on('connect', function () { console.log('连接成功'); // 订阅主题 mqttClient.subscribe(subscribe_Topic); }); 这样网页成功连接上MQTT服务器后，就会在浏览器控制台打印连接成功，如图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f833ff52b19757eb60caaf7303d52b61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1b4258cd52c158727637fbb2dcbf404/" rel="bookmark">
			算法——双指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双指针经常服务于需要一边遍历数组，一边对数组元素进行改动的题目，有些人也称双指针为快慢指针。
同时双指针只是一种思想，实际做题时并不一定会真的采用指针。
移动零 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
请注意 ，必须在不复制数组的情况下原地对数组进行操作。
示例 1:
输入: nums = [0,1,0,3,12] 输出: [1,3,12,0,0] 本题的思路，并非是着重于将0往后移，实际上是要将非0数按顺序往前移。
由题意，我们可以将数据分成两大类：0和非0，那么我们的两个指针，一个就去找0，一个就去找非0。
两个指针均从0下标开始，其中cur找0，dest找非0。cur找到0即停下，dest找到非0即停下。
这样，dest总会走在cur的前面，两者将数据进行交换，就可以将非0元素前移，0元素后移。直至dest走到数组末尾。
class Solution { public: void moveZeroes(vector&lt;int&gt;&amp; nums) { int size = nums.size(); int cur = 0; int dest = 0; while(dest &lt; size) { if(nums[cur] == 0 &amp;&amp; nums[dest] == 0) { dest++; } else { swap(nums[cur++],nums[dest++]); } } } }; 快乐数 「快乐数」 定义为：
对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果这个过程 结果为 1，那么这个数就是快乐数。 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1b4258cd52c158727637fbb2dcbf404/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82e47743d3c9140faa2d84f6a7a4dd05/" rel="bookmark">
			无脑入单向无头链表的实现| ArrayList和LinkedList的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. ArrayList的缺陷 上节课已经熟悉了ArrayList的使用，并且进行了简单模拟实现。通过源码知道，ArrayList底层使用数组来存储元素。
由于其底层是一段连续空间，当 在 ArrayList 任意位置插入或者删除元素时，就需要将后序元素整体往前或者往后 搬移，时间复杂度为 O(n) ，效率比较低，因此 ArrayList 不适合做任意位置插入和删除比较多的场景 。因此： java集合中又引入了LinkedList ，即链表结构。 2. 链表 2.1 链表的概念及结构 链表也是线性表的一种，链表是一种物理存储结构上非连续存储结构，数据元素的逻辑顺序是通过链表中的引用链接次序实现的。
实际中链表的结构非常多样，以下情况组合起来就有8种链表结构： 1. 单向或者双向 2. 带头或者不带头 3. 循环或者非循环 虽然有这么多的链表的结构，但是我们重点掌握两种: 无头单向非循环链表：结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结构的子结构，如哈希桶、图的邻接表等等。另外这种结构在笔试面试中出现很多。无头双向链表：在Java的集合框架库中LinkedList底层实现就是无头双向循环链表。 2.2 无头单向非循环链表实现 2.2.1 链表的类结构 2.2.2 头插法 2.2.3尾插法 2.2.4在index前面插入 2.2.5查找是否包含关键字key是否在单链表当中 2.2.6删除第一次出现关键字为key的节点 2.2.7删除所有出现关键字为key的节点 2.2.8得到单链表的长度 2.2.9释放链表 2.2.10节点打印 2.2.11得到节点长度 3.单向无头链表实现代码 MyLinkedList类 import java.util.Arrays; public class SingleLinkedList { static class ListNode { public int val; public ListNode next; public ListNode(int val) { this.val = val; } } //记录头节点 public ListNode head; //头插法 public void addFirst(int data) { ListNode node = new ListNode(data); // //更为简单的方式 // node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82e47743d3c9140faa2d84f6a7a4dd05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3db053236763afb13b5ca3be00c4552a/" rel="bookmark">
			【C#】.net core 6.0 MVC返回JsonResult显示API接口返回值不可被JSON反序列化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到《小5讲堂》
这是《C#》系列文章，每篇文章将以博主理解的角度展开讲解。
温馨提示：博主能力有限，理解水平有限，若有不对之处望指正！
目录 背景API接口接口代码请求失败原因排查调通效果 常见返回类型相关文章 背景 最近在体验AI应用自定义创建组件功能，组件能够接入自己API接口，
在对接API接口时，平台返回提示API接口返回值不可被JSON反序列化。
因此本篇文章将探索下为什么会出现这个提示，以及如何解决这个问题。
API接口 接口代码 主要是返回
[HttpGet] [ActionFilterInfo] public IActionResult GetApi(string name) { return new JsonResult(new { name = $"您输入名字是：{name}" }); } 请求失败 请求失败！错误代码400
原因排查 经过排查发现，接口返回其实没问题，是api接口地址不对，少了一个api路径。
实际上就是api接口报404错误了，找不到接口，因此会提示上面请求失败。
调通效果 常见返回类型 在.NET Core 6.0 MVC中，常见的返回类型包括但不限于：
1.ViewResult
用于返回视图页面，通常在控制器方法中使用
return View();来返回一个视图页面。
2.PartialViewResult
用于返回局部视图页面，通过
return PartialView();在控制器方法中返回一个局部视图页面。
3.JsonResult
用于返回JSON格式的数据，通过
return new JsonResult(data);在控制器方法中返回JSON数据。
4.ContentResult
用于返回纯文本内容，通过
return Content(“content”);在控制器方法中返回纯文本内容。
5.RedirectResult
用于执行重定向操作，通过
return Redirect(“url”);在控制器方法中执行重定向操作。
6.RedirectToActionResult
用于重定向到指定的控制器和操作方法，通过
return RedirectToAction(“Action”, “Controller”);在控制器方法中执行重定向到指定的控制器和操作方法。
7.FileResult
用于返回文件内容，通过
return File(“path”, “contentType”, “fileDownloadName”);在控制器方法中返回文件内容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3db053236763afb13b5ca3be00c4552a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a10a1140ea75f226d03bbb00e47fd7c5/" rel="bookmark">
			【MySQL精炼宝库】数据库的约束 | 表的设计 | 聚合查询 | 联合查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、数据库约束
1.1 约束类型：
1.2 案例演示：
二、表的设计
2.1 一对一:
2.2 一对多:
2.3 多对多:
2.4 内容小结：
三、新增
四、查询
4.1 聚合查询：
4.1.1 聚合函数：
4.1.2 GROUP BY子句：
4.1.3 HAVING：
4.2 联合查询：
4.2.1 内连接：
4.2.2 外连接：
4.2.3 自连接： 4.2.4 子查询：
4.2.5 合并查询：
一、数据库约束 1.1 约束类型： • NOT NULL：指示某列不能存储 NULL 值。
• UNIQUE：保证某列的每行必须有唯一的值。
• DEFAULT：规定没有给列赋值时的默认值。
• PRIMARY KEY：NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标 识，有助于更容易更快速地找到表中的一个特定的记录。
• FOREIGN KEY：保证一个表中的数据匹配另一个表中的值的参照完整性。
• CHECK（了解）：保证列中的值符合指定的条件。对于MySQL数据库，对CHECK子句进行分析，但是忽略 CHECK子句。
1.2 案例演示： • NULL约束：
创建表时，可以指定某列不为空，对应SQL脚本如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a10a1140ea75f226d03bbb00e47fd7c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c52441cd46ee1fd930c8f97b65fd1f5/" rel="bookmark">
			Java之多态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、多态前言 1.为什么要使用多态 Java中使用多态的主要目的是提高代码的可重用性和扩展性，使得代码更加灵活和易于维护。通过多态，我们可以将不同的对象看做是同一种类型，从而使得我们可以使用同一种接口来操作这些对象，而不必关心具体的实现细节。
2.多态概念 当父类的引用所指向的子类对象引用指向的对象不一样时。调用重写的方法，所表现出来的行为是不一样的，我们把这种思想叫做多态。上面所说的可能大家会觉得有点抽象，看到后面就懂了。
多态的基础是动态绑定，所以要了解多态前提我们还要了解动态绑定。
要想实现动态绑定，需要满足以上几个条件：
1.要发生向上转型
2.要发生重写
3.使用父类对象的引用去调用重写方法
完成了这三部分，就会发生动态绑定，而在这里，出现了重写以及向上转型这些概念。所以我们得先了解它们才能去了解动态绑定。进而了解多态。
二、重写 1.重写的概念 重写 (override) ：也称为覆盖。将父类的方法重新在子类中使用。 返回值和形参都不能改变 。 即外壳不变，核心重写！ 重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。 方法重写的规则：
1.子类在重写父类的方法时，必须与父类方法原型一致：即返回值、方法名、参数列表要完全一致
2.被重写的方法的访问修饰限定符在子类中要大于等于父类的。
3.父类中被static或private或final修饰的方法以及构造方法都不能被重写。 4.在子类中重写的方法, 可以使用 @Override 注解来显式指定. 有了这个注解能帮我们进行一些合法性校验。
2.重写的作用 对于已经投入使用的类，尽量不要进行修改。最好的方式是：重新定义一个新的类，来重复利用其中共性的内容，并且添加或者改动新的内容。 例如：若干年前的手机，只能打电话，发短信，来电显示只能显示号码，而今天的手机在来电显示的时候，不仅仅可以显示号码，还可以显示头像，地区等。在这个过程当中，我们不应该在原来老的类上进行修改，因为原来的 类，可能还在有用户使用 ，正确做法是： 新建一个新手机的类，对来电显示这个方法重写就好了，这样就达到了我 们当今的需求了 。 三、向上转型 向上转型：实际就是创建一个子类对象，将其当成父类对象来使用。
语法格式：父类类型 对象名 = new 子类类型 () Animal animal = Dog ( ); 我们对以上代码进行实质化分析，以上的代码其实是省略化了，见以下代码 Dog dog = new Dog（);
Animal animal = dog;//该代码发生了向上转换，将Dog对象转换为Animal类型
通过向上转型后，就可以父类对象名来访问子类的方法了。使用animal.eat();这语句来访问 这个语句发生了动态绑定（在编译过程中调用的其实是父类的eat，但是在运行时换为调用子类的eat了）故实现了 创建一个子类对象，将其当成父类对象来使用。见以下代码 class Animal {
void sound() {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c52441cd46ee1fd930c8f97b65fd1f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64f368985ddf6f1f7e6bd4c7cdd75e9a/" rel="bookmark">
			AI大模型探索之路-训练篇6：大语言模型预训练数据准备-预处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列篇章💥 AI大模型探索之路-训练篇1：大语言模型微调基础认知
AI大模型探索之路-训练篇2：大语言模型预训练基础认知
AI大模型探索之路-训练篇3：大语言模型全景解读
AI大模型探索之路-训练篇4：大语言模型训练数据集概览
AI大模型探索之路-训练篇5：大语言模型预训练数据准备-词元化
目录 系列篇章💥前言一、数据准备1、通用文本数据2、专业文本数据 二、数据质量过滤1、基于启发式规则2、基于分类器方法 三、数据去重过滤1、模糊去重2、精确去重 四、数据敏感过滤1、过滤有毒内容2、过滤隐私内容 五、数据影响分析1、数据数量的影响2、数据质量的影响 六、简单实践样例1、质量过滤2、去重过滤3、隐私过滤 总结 前言 随着人工智能技术的不断发展，大语言模型在自然语言处理、机器翻译、文本生成等领域取得了显著的成果。然而，训练一个高性能的大语言模型需要大量的高质量预训练数据。本文将详细介绍大语言模型预训练数据准备的各个环节，包括数据来源、质量过滤、去重过滤、敏感过滤以及数据影响分析等。希望通过本文的介绍，能够帮助读者更好地理解和应用大语言模型预训练数据的准备过程。
一、数据准备 大语言模型训练所需的数据来源大体上可以分为通用数据和专业数据两大类。通用数据包括网页、图书、新闻、对话文本等内容。通用数据具有规模大、多样性和易获取等特点，因此可以支持大语言模型的构建语言建模和泛化能力。专业数据包括多语言数据、科学数据、代码以及领域特有资料等数据。通过在预训练阶段引入专业数据可以有效提供大语言模型的任务解决能力。
不同的大语言模型在训练类型分布上的差距很大
国内常用的数据集网站：悟道数据
1、通用文本数据 通用数据在大模型训练数据中占比通常非常高，主要包括网页、书籍、对话文本等类型，为 大模型提供了大规模且多样的训练数据。
• 网页：是通用数据中数量最大的一类。随着互联网的大规模普及，人们通过网站、 论坛、博客、APP 等各种类型网站和应用，创造了海量的数据。网页数据所包含的海量内容，使得语言模型能够获得多样化的语言知识并增强其泛化能力。 同样包含很多低质量文本，需要进行过滤处理
• 对话数据：对话数据是指包含两个或更多参与者之间交流的文本内容。对话数据包含书面形式的对话、聊天记录、论坛帖子、社交媒体评论等。当前的一些研究也表明，对话数据可以有效增强语言模型的对话能力，并潜在地提高其在多种问答任务上的表现。
• 书籍：书籍可以丰富语言模型的知识库。书籍通常包含广泛的词汇，包括专业术语、文学表达以及各种主题词汇。利用书籍数据进行训练，语言模型可以接触到多样化的词汇，从而提高其对不同领域和主题的理解能力。相较于其他语料库，书籍也是最重要的，甚至是唯一的长文本书面语的数据来源。书籍提供了完整的句子和段落，使得语言模型可以学习到上下文之间的联系。这对于模型理解句子中的复杂结构、逻辑关系和语义连贯性非常重要。
2、专业文本数据 专业数据在通用大语言模型中所占比例通常较低，但是专业数据对于改进大语言模型在下游任务上的特定能力有着非常重要的作用。专业数据有非常多的种类，当前大语言模型使用的三类专业数据，包括多语言数据、科学文本以及代码。
• 多语言数据：对于增强大语言模型语言理解和生成多语言能力具有至关重要的作用。当前的大语言模型训练除了需要目标语言中的文本之外，通常还要整合多语言语料库。
• 科学文本：包括教材、论文、百科以及其他相关资源。这些数据对于提升大型语言模型在理解科学知识方面具有重要作用。科学文本数据的来源主要包括 arXiv 论文、 PubMed 论文、教材、课件和教学网页等。由于科学领域涉及众多专业领域且数据形式复杂，通常还需要对公式、化学式、蛋白质序列等采用特定的符号标记进行预处理。使得语言模型更好地处理和分析科学文本数据。
• 代码：代码是进行程序生成任务所必须的训练数据。通过在大量代码上进行预训练，大语言模型可以有效提升代码生成的效果。代码是一种格式化语言，它对应着长程依赖和准确的执行逻辑。可以提升语言模型的逻辑推理能力。
二、数据质量过滤 直接收集到的文本数据往往掺杂了很多低质量的数据。例如，从网页抓取的数据中可能包含由机器自动生成的广告网页。为了优化模型学习的性能，需要去除语料库中的低质量数据。目前主要使用以下两种数据清洗方法：基于启发式规则的方法，和基于分类器的方法。
1、基于启发式规则 基于启发式的方法则通过一组精心设计的规则来消除低质量文本，启发式规则主要包括：
• 语言过滤：如果一个大语言模型仅关注一种或者几种语言，那么就可以大幅度的过滤掉数据
中其他语言的文本。
• 指标过滤：利用评测指标也可以过滤低质量文本。例如，可以使用语言模型对于给定文本的困惑度（Perplexity）进行计算，利用该值可以过滤掉非自然的句子。
• 统计特征过滤：针对文本内容可以计算包括标点符号分布、符号字比（Symbol-to-Word Ratio）、句子长度等等在内的统计特征，利用这些特征过滤低质量数据。
• 关键词过滤：根据特定的关键词集，可以识别和删除文本中的噪声或无用元素，例如，HTML标签、超链接以及冒犯性词语等。
2、基于分类器方法 基于分类器的方法目标是训练文本质量判断模型，并利用该模型识别并过滤低质量数据。GPT-3、PALM 以及 GLam模型在训练数据构造时都使用了基于分类器的方法。
目前常用来实现分类器的方法包括轻量级模型（如 FastText 等）、可微调的预训练语言模型（如 BERT、BART 或者 LLaMA 等）以及闭源大语言模型 API（如 GPT-4、Claude 3）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64f368985ddf6f1f7e6bd4c7cdd75e9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/212404471ea762a618955cffd6fac904/" rel="bookmark">
			ChatGPT4.0知识问答、DALL-E生成AI图片、Code Copilot辅助编程，打开新世界的大门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、DALL-E 文字转图片 + 在线AI修改2、Write For Me3、Code Copilot 目前最强的AI编程大模型4、Diagrams: Show Me5、Instant Website [Multipage] 网站合成神器6、AskYourPDF Research Assistant 无限PDF7、Diagrams &amp; Data: Research, Analyze, Visualize 精读Excel 1、DALL-E 文字转图片 + 在线AI修改 支持在线修改和图片导出。走一个~
（1）画一个会飞的猪
（2）通过选择select，对会飞的猪进行润色
（3）画一个花色翅膀
（4）来一个难的，根据斗罗大陆的设定，添加一个十万年魂环，哈哈
我记得金色魂环是百万年的了，哈哈。不过还可以理解。
（5）根据斗罗大陆的设计，小猪的武魂真身是蓝电霸王龙
（6）武魂真身的魂技雷霆龙爪
2、Write For Me 写量身定制的、引人入胜的内容，重点是质量、相关性和精确的字数。
chatgpt都有哪些功能，哪些功能可以应用在Java开发中。
3、Code Copilot 目前最强的AI编程大模型 用Java编写一个二分查找的代码，添加中文注释。
4、Diagrams: Show Me 官网简介：图表创建：流程图，思维导图，UML，图表，PlotUML，工作流，序列，ERD，数据库和架构可视化代码，演示文稿和文档。添加一个标志或任何图像到图形图表。易于下载和编辑。
5、Instant Website [Multipage] 网站合成神器 官网介绍：一个专门帮助用户快速创建和管理多页面网站的工具。你可以通过我来设计和部署一个完整的网站，包括主页和其他相关页面。使用我时，你只需要提供网站的标题、内容、色彩方案和其他相关信息，我就能帮助你构建一个专业的网站。
为一家烘焙店创建一个网站，名字叫哪吒面包，店铺的地址在大连，联系方式是哪吒编程，帮我生成一个包括首页、产品介绍页、价格页面和联系方式页面
查看生成的网站：
产品介绍页面添加关于生日蛋糕的介绍，并添加八臂哪吒蛋糕图片：
联系方式页面添加哪吒的联系方式，姓名：哪吒编程，电话18640839506，地址：大连市
6、AskYourPDF Research Assistant 无限PDF 官网介绍：免费聊天无限PDF，访问400多万篇论文(PubMed, Nature, Arxiv等)，分析PDF(无限PDF)，生成有效引用的文章/论文，ChatPDF，分析和生成论文参考文献，创建和交互您的文件知识库以及更多使用AskYourPDF。
（1）上传PDF资料
《Effective Java 第三版.pdf》2582K，这本经典书籍228页，我觉得如果想读完，怎么的也得1个礼拜吧，nezhagpt只需要10秒钟。
再看看它读的怎么样。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/212404471ea762a618955cffd6fac904/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ef680641faf8abcadb9eda0dd2898b9/" rel="bookmark">
			Redis内存优化策略：10个极大节省内存的技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序员缓解工作压力的小窍门 强烈推荐 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站:人工智能
引言 Redis作为一种高性能的内存数据库，其优势之一在于能够高效地利用内存，从而提供快速的数据访问和存储。
然而，在实际应用中，如何有效地管理和节省Redis所使用的内存，对于应用的性能和成本都具有重要意义。
在本文中，我们将探讨一些使用Redis时能够极大节省内存的技巧，通过这些技巧，你可以更加有效地利用Redis，提高应用的性能并降低成本。
优化技巧 下面就介绍10中能大大节省内容的技巧，提高redis的性能。
1.使用数据结构的最小存储形式： 假设你需要存储一组唯一的用户ID。你可以使用Redis的集合数据结构来实现，而不是使用列表，因为集合只存储唯一值，节省内存。
// 存储一组唯一用户ID的示例 Jedis jedis = new Jedis("localhost"); jedis.sadd("unique_user_ids", "user1", "user2", "user3"); 2.压缩列表和哈希：
如果你有一个小型的哈希表，只包含几个字段，Redis会将其存储为压缩哈希表，从而节省内存。
3.合并小对象：
假设你有多个小型用户配置信息，每个用户信息包含用户名、年龄和地址。你可以将这些信息合并到一个大的哈希表中，每个用户使用一个字段来存储，而不是为每个用户创建单独的哈希表，从而减少固定开销。
// 合并多个小型用户信息到一个哈希表中的示例 jedis.hset("user:1", "name", "Alice"); jedis.hset("user:1", "age", "30"); jedis.hset("user:1", "address", "123 Main St"); 4.优化数据结构：
如果你需要存储一个只包含唯一值的列表，例如用户的兴趣爱好，你可以使用Redis的集合数据结构，而不是列表，这样可以节省内存。
// 使用集合数据结构存储唯一值的示例 jedis.sadd("unique_interests", "sports", "music", "travel"); 5.使用整数编码：
如果你需要存储用户的年龄信息，将年龄存储为整数值，而不是字符串表示，可以节省内存。
// 存储用户的年龄信息，以整数值表示 jedis.set("user:1:age", "30"); 6.设置适当的过期时间：
如果你需要缓存某些数据，但知道它们在一段时间后将不再使用，可以为这些数据设置适当的过期时间，以确保它们在不再需要时及时释放内存。
// 设置缓存数据并为其设置过期时间的示例 jedis.setex("cached_data", 3600, "some_value"); // 缓存数据1小时 7.使用虚拟内存：
如果你的数据集很大，而可用内存有限，可以配置Redis使用虚拟内存，将不常访问的数据交换到磁盘上，以释放内存。
8.限制数据集大小：
你可以通过配置maxmemory参数来限制Redis数据集的大小，当数据集达到预设的内存限制时，Redis将根据你的配置策略来淘汰数据，以保持内存使用在可控范围内。
9.关闭持久化：
如果你的应用可以接受一定程度的数据丢失，可以考虑关闭Redis的持久化功能，以减少对内存的消耗。
// 关闭持久化功能的示例 jedis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ef680641faf8abcadb9eda0dd2898b9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/29/">«</a>
	<span class="pagination__item pagination__item--current">30/71</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/31/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>