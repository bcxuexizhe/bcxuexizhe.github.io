<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c8a59c641d7a15e914cc2812ee45524/" rel="bookmark">
			31万奖金池等你挑战！IJCAI 2024 第九届“信也科技杯”全球AI算法大赛正式开赛！聚焦AI尖端赛题！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ⭐️ 赛事概况⭐️ 赛事奖励⭐️ 赛事日程速览⭐️ 报名通道与赛事交流群⭐️ 关于 “信也科技杯”⭐️ 关于信也科技 ⭐️ 赛事概况 随着语音合成技术的不断进步,合成语音与真实语音之间的界限变得模糊,这不仅对数据安全构成威胁,也对科技伦理提出了新的要求。
第九届 “信也科技杯” 全球AI算法大赛 聚焦于语音深度鉴伪识别领域,旨在激发全球算法爱好者和专家的创新潜力,共同应对由人工智能技术发展带来的挑战。我们 邀请参赛者 运用深度学习等先进的算法技术，以期生成能够准确鉴别真伪语音的算法,共同推动这一领域的进步，确保技术的发展能够更好地服务于社会，实现科技与伦理的和谐共进。
⭐️ 赛事奖励 单赛道瓜分31万奖金池 · Top8 均可获得 现金奖励！ 冠军（1队）：100000 RMB 亚军（2队）：60000 RMB 季军（2队）：30000 RMB 全国八强（3队）：10000 RMB 数智新星奖 3队 荣誉证书：获奖团队均获得大赛荣誉证书线下颁奖：优秀团队将受邀参加在国际人工智能A类顶会IJCAI’24举办的「第九届信也科技杯」颁奖典礼,与学界、行业届顶尖高手共度盛宴、线下交流Tips：所有奖项金额均为税前金额,实际发放金额可能会受到适用税务法律法规的影响。 ⭐️ 赛事日程速览 组队报名北京时间：2024/05/10 00:00:00 至 06/03 23:59:59初赛北京时间： 2024/05/10 00:00:00 至 06/12 23:59:59复赛北京时间： 2024/06/13 00:00:00 至 06/28 23:59:59决赛北京时间： 2024/06/29 00:00:00 至 7月下旬(决赛日另行通知)颁奖典礼： 北京时间 2024/8月上旬 IJCAI'24 韩国济州岛 ⭐️ 报名通道与赛事交流群 报名通道：http://ai.ppdai.com/mirror/show （点击跳转）参赛选手交流群：⑦①⑥④②④①⑨②群名：信也科技杯官方QQ群 ⭐️ 关于 “信也科技杯” “信也科技杯” 是由信也科技主办的一项立足 金融科技领域的数据算法大赛。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c8a59c641d7a15e914cc2812ee45524/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f61e1aee36c9ad537bbffa5127165d4/" rel="bookmark">
			【数据结构】数组循环队列的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		队列（Queue）是一种特殊的线性数据结构，它遵循FIFO（First In First Out，先入先出）的原则。队列只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。队列中没有元素时，称为空队列。
队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以又称为先进先出（FIFO—first in first out）线性表，简称队列。
在程序中，队列常常被用来处理需要按一定顺序处理的任务，例如打印任务队列、线程任务调度等。此外，队列也在许多算法中发挥着重要作用，如广度优先搜索（BFS）等。
队列的实现方式有多种，包括基于数组的静态队列、基于链表的动态队列等。在实际应用中，可以根据具体需求选择合适的队列实现方式。
队列的主要特点包括：
先进先出：队列中的元素按照进入队列的先后顺序依次出队。
操作受限：队列只允许在队尾插入元素（入队），在队头删除元素（出队），其他位置的元素无法直接访问或修改。
有序性：由于遵循FIFO原则，队列中的元素始终保持一定的顺序。
队列的链式存储结构为：
typedef int QDataType; // 链式结构：表示队列 typedef struct QListNode { struct QListNode* next; QDataType data; }QNode; // 队列的结构 typedef struct Queue { QNode* front; QNode* rear; int size; }Queue; 队列的顺序存储结构为：
#define MAXQSIZE 100 //队列可能达到的最大长度 typedef struct { QElemType* base; //存储空间的基地址 int front; //头指针 int rear; //尾指针 }SqQueue; 假设当前队列分配的空间最大为6，则当队列处于上图的最后一个状态时，就不可以在继续插入新的队尾元素，否则会出现溢出的情况，即因数组越界而导致程序的非法操作错误。但是队列的实际空间并未占满，这种现象就被称为假溢出。
那么怎么解决这个问题呢？
我们就可以运用一个较为巧妙的方法：循环队列
但这里我们面临一个问题，就是front==rear的时候时队空还是队满
可以发现并不好来判断
下面我们就有两种方法来解决下列问题
多开辟用一个空间（即少用一个元素空间），假设队列的空间为k+1，但当有m个元素的时候就认为时队满即(Q.rear + 1)%(k+1) == Q.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f61e1aee36c9ad537bbffa5127165d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46ebb4bda2cbdfa76a6f790f9f0f8b6d/" rel="bookmark">
			【数据结构】详解队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在我们来掌握一下队列！如果有对往期知识有不足地方，可翻阅之前文章哦！
个人主页：小八哥向前冲~-CSDN博客
所属专栏：数据结构【c语言版】_小八哥向前冲~的博客-CSDN博客
栈和队列的实现其实都是对你顺序表和链表的检验，只有一些新的概念罢了！
哈哈！不信就往下看吧！！！
目录
什么是队列？
扩展--循环队列
队列的实现
初始化
队列的插入
队列的判空
队列的删除
队列的尾数据
队列的头数据
队列的销毁
总代码
Queue.h文件
Queue.c文件
什么是队列？ 队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先进先出 FIFO(First In First Out) 。入队列：进行插入操作的一端称为队尾。出队列：进行删除操作的一端称为队头。 上图理解：
注意：遵循先进先出的原则！这个原则就是区分栈（后进先出）和队列（先进先出）方法！
我们来看看一个队列需要有的最基本要求：详情见--queue - C++ Reference
了解了队列的基本概念，我们来扩展一下！
扩展--循环队列 生活中队列很常用，而在实际的生活中，有时我们会用到循环队列。
循环队列它也有一些应用场景。如：在操作系统中的生产者消费者模型（这个我们后续提到！）
在这种问题中，环形队列可以使用数组实现，也可以使用循环链表实现。
我们图上了解：
空的环形队列：
满的环形队列：
注意：为了能区别Q.front=Q.rear为队满还是队空，我们通常认为Q.rear+1=Q.front为满！
ok!了解了队列的基本，我们来巩固一下：
3.循环队列的存储空间为 Q(1:100) ，初始状态为 front=rear=100 。经过一系列正常的入队与退队操作 后， front=rear=99 ，则循环队列中的元素个数为（ ）
A .1
B.2
C.99
D.0或者100
4.以下( )不是队列的基本运算？
A.从队尾插入一个新元素
B.从队列中删除第i个元素
C.判断一个队列是否为空
D.读取队头元素的值
5.现有一循环队列，其队头指针为front，队尾指针为rear；循环队列长度为N。其队内有效长度为( )？(假设 队头不存放数据)
A.(rear - front + N) % N + 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46ebb4bda2cbdfa76a6f790f9f0f8b6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7575b50c4241b995281c7a759d597341/" rel="bookmark">
			Java抽象类：为何它是你代码架构的基石？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、抽象类的概念
2、抽象类语法
3、抽象类特性
4、抽象类的作用 5、 完结散花
个人主页：秋风起，再归来~
文章专栏：javaSE的修炼之路 个人格言：悟已往之不谏，知来者犹可追
克心守己，律己则安！
1、抽象类的概念 在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果 一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。 比如：
在打印图形例子中, 我们发现, 父类 Shape 中的 draw 方法好像并没有什么实际工作, 主要的绘制图形都是由 Shape 的各种子类的 draw 方法来完成的. 像这种没有实际工作的方法, 我们可以把它设计成一个 抽象方法(abstract method), 包含抽象方法的类我们称为 抽象类(abstract class).
2、抽象类语法 在Java中，一个类如果被 abstract 修饰称为抽象类，抽象类中被 abstract 修饰的方法称为抽象方法，抽象方法不用 给出具体的实现体。
// 抽象类：被abstract修饰的类 public abstract class Shape { // 抽象方法：被abstract修饰的方法，没有方法体 abstract public void draw(); abstract void calcArea(); // 抽象类也是类，也可以增加普通方法和属性 public double getArea(){ return area; } protected double area; // 面积 } 注意：抽象类也是类，内部可以包含普通方法和属性，甚至构造方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7575b50c4241b995281c7a759d597341/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b072da5962d0dd6154a42aa04aa483b6/" rel="bookmark">
			2024年大数据最全腾讯T4专家精心整理：大数据&#43;机器学习&#43;数据挖掘&#43;算法大集结(1)，2024年最新大数据开发开发框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，涵盖了95%以上大数据知识点，真正体系化！
由于文件比较多，这里只是将部分目录截图出来，全套包含大厂面经、学习笔记、源码讲义、实战项目、大纲路线、讲解视频，并且后续会持续更新
需要这份系统化资料的朋友，可以戳这里获取
本文共分为10章，第1章概述大数据算法，第2章介绍时间亚线性算法，第3章介绍空间亚线性算法，第4章概述外存算法，第5章介绍大数据外存查找结构，第6章讲授外存图数据算法，第7章概述MapReduce算法，第8章通过一系列例子讲授MapReduce算法，第9章介绍超越MapReduce的算法设计方法，第10章讨论众包算法。
数据结构与算法经典问题解析
=============
本文是数据结构方面的优秀教材，以Java为描述语言，介绍了计算机编程中使用的数据结构和算法。强调问题及其分析，而非理论阐述，共分为21章，讲述了基本概念、递归和回溯、链表、栈、队列、树、优先队列和堆、并查集DAT.图算法、排序、查找、选择算法(中位数)、符号表、散列、字符串算法、算法设计技术、贪婪算法、分治算法、动态规划算法、复杂度类型等内容。每章首先阐述必要的理论基础，然后给出问题集。全书中大约有700个算法问题及相应的解法，对于许多问题，本文提供了多个具有不同复杂度的解决方法。
算法基础：打开算法之门
===========
本文介绍了什么是计算机算法，如何描述它们，以及如何来评估它们。这些计算机算法将提供:利用计算机搜索信息的简单方式;解决各种排序问题的方法;利用有向无环图和最短路径法来解决基本问题的方法(可用于建模公路网络，任务间的依赖及金融关系);解决字符串(例如DNA结构)问题的方法;密码学背后的基本原理;数据压缩的基础知识;以及甚至一些没有人能够理解如何在计算机上用相当长的时间来解决的问题。
机器学习算法大集结
=========
Java数据结构和算法
===========
本文主要讲解有关计算机编程中所应用的数据结构和算法。数据结构是指数据在计算机存储空间中(或磁盘中)的安排方式。算法是指软件程序用来操作这些结构中的数据的过程。
几乎所有的计算机程序都使用数据结构和算法，即使最简单的程序也不例外。比如设想一个打印地址标签的程序，这个程序使用一个数组来存储地址，并且使用一个简单的for循环来遍历数组,打印每一个地址。
数组就是一个数据结构，用for 循环来顺序访问该数组，这就构造了一个简单的算法。对于一个仅有少量数据的简单程序来说，上述的这种方法已经足够了。 但是如果用程序来处理中等规模以上的数据或解决那些不太平常的问题时，就需要用-些更加复杂的技术来应付它们。仅仅知道诸如Java或C++等计算机语言的语法是远远不够的。
C++数据结构与算法
==========
本文全面系统地介绍了数据结构，并以C++语言实现相关的算法。
本文中主要强调了数据结构和算法之间的联系，使用面向对象的方法介绍数据结构，其内容包括算法的复杂度分析、链表、栈、队列、递归、二叉树、图、排序和散列。本书还清晰地阐述了同类教材中较少提到的内存管理、数据压缩和字符串匹配等主题。书中包含大量的示例分析和图形，便于读者进一步理解和巩固所学的知识。
总结
==
至此，这八大部分内容算法知识就给大家介绍完了，下面是总览内容，希望大家能够喜欢！
需要的小伙伴可以转发关注小编，私信小编“学习”来得到获取方式！
希望能够帮助到大家学习，也非常喜欢能够得到大家的支持！关注不迷路，期待下次光临寒舍！
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，涵盖了95%以上大数据知识点，真正体系化！
由于文件比较多，这里只是将部分目录截图出来，全套包含大厂面经、学习笔记、源码讲义、实战项目、大纲路线、讲解视频，并且后续会持续更新
需要这份系统化资料的朋友，可以戳这里获取
由于文件比较多，这里只是将部分目录截图出来，全套包含大厂面经、学习笔记、源码讲义、实战项目、大纲路线、讲解视频，并且后续会持续更新
需要这份系统化资料的朋友，可以戳这里获取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3aeea16573e6dec9753693797c3d572/" rel="bookmark">
			Java进阶-SpringCloud设计模式-工厂模式的设计与详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、设计模式介绍 设计模式是我们开发中常常需要面对的核心概念，它们是解决特定问题的模板或者说是经验的总结。这些模式被设计出来是为了让软件设计更加清晰、代码更加可维护且能应对未来的变化。良好的设计模式不仅能解决重复代码的问题，还能使团队中的每个成员都能理解并遵循统一的开发方式。
使用良好的设计模式可以显著提高软件项目的质量和开发效率。它们帮助开发者抽象复杂度，通过预定义的架构方式简化系统结构的设计和实现。设计模式还提供了一种通用语言，使得开发者在讨论架构问题时能够迅速地达成共识，同时确保代码的健壁性和可扩展性。不论是在创建对象、组织复杂的类结构，还是处理类与类之间的关系时，设计模式都提供了有效的管理和优化策略，使得软件更加稳健，易于管理和扩展。
下面是常见的 23 种设计模式：
本文详细介绍了设计模式中的工厂模式，旨在为软件开发人员提供清晰的理解和应用指南。工厂模式是一种创建型设计模式，用于在不直接指定具体类的情况下创建对象，从而增强代码的灵活性和可扩展性。我们探讨了工厂模式的三种主要形式：简单工厂模式、工厂方法模式和抽象工厂模式。每种模式都通过其结构、代码示例和类图进行了解释，以展示它们在实际开发中如何减少系统的依赖性、提高可维护性和支持易变需求。此外，本文还讨论了每种模式的优势、适用场景以及它们在现实世界软件开发中的实际应用，帮助开发者在面对不同的编程挑战时，能选择合适的模式以优化设计和实现过程。
二、工厂模式概述 工厂模式（Factory Pattern）是一种常用的创建型设计模式，其核心目的是实现创建对象的接口和具体的实例化分离，通过建立一个工厂类，对实现了同一接口的一些类进行实例的创建，以增加系统的灵活性和可维护性。
当需要大量创建一个类的实例的时候，可以使用工厂模式，即从原生的使用类的构造去创建对象的形式迁移到基于工厂提供的方法去创建对象的形式。基于工厂模式的实例创建具有以下好处：
大批量创建对象的时候有统一的入口，易于代码维护；当发生修改时，仅需修改工厂类的创建方法即可；符合现实世界的模式，即由工厂来制作产品（对象）； 本文将通过类图及示例代码详细介绍工厂模式的三种形式：简单工厂模式、工厂方法模式 和 抽象工厂模式。
三、简单工厂模式 简单工厂模式是一种创建型设计模式，它提供了一个创建对象的接口，让其子类决定实例化哪一个类。该模式将对象的创建集中管理，通过专门的工厂类来负责创建所有实例，这样可以避免在客户代码中重复创建对象，降低系统的耦合度，提高模块的可复用性。
1. 简单工厂模式类图 以下类图展示了简单工厂模式的结构：
在这个类图中，Client 不直接与具体产品类（ConcreteProductA 和 ConcreteProductB）交互，而是通过 Factory 类来进行。这样做的优点是客户端从具体产品的创建过程中解耦，提高了程序的扩展性和可维护性。
2. 简单工厂模式示例代码 下面的示例代码进一步阐释了简单工厂模式的应用：
抽象产品：定义了产品的接口，所有的产品都必须实现这个接口。 interface Product { void use(); } 具体产品：实现了产品接口的实体类，定义了具体产品的行为。 class ConcreteProductA implements Product { public void use() { System.out.println("Using ConcreteProductA"); } } class ConcreteProductB implements Product { public void use() { System.out.println("Using ConcreteProductB"); } } 简单工厂：一个工厂类，提供了一个创建对象的方法，客户端通过调用这个方法并传入参数来创建不同的产品实例。 class Factory { public static Product createProduct(String type) { if (type.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3aeea16573e6dec9753693797c3d572/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3d17756040a24906017310e1077cd47/" rel="bookmark">
			DS高阶：B树系列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、常见的搜索结构 1、顺序查找 时间复杂度：O(N)
2、二分查找 时间复杂度：O(logN)
要求：（1）有序 （2）支持下标的随机访问
3、二叉搜索树（BS树） 时间复杂度：O(logN)——&gt;O(N)
若接近有序的数据插入到BS中，会导致退化成单支树，时间复杂度退化为O(N)
4、平衡搜索树 （AVL树和RB树） 时间复杂度：O(logN)
在BS的基础上，通过一些规则加以限制，通过旋转来限制高度,维持logN的时间复杂度
5、哈希 时间复杂度：O(1)
底层是散列表，要注意解决哈希冲突。综合效率优于平衡搜索树
以上结构适合用于数据量相对不是很大，能够一次性存放在内存中（内查找），进行数据查找的场景。如果数据量很大，比如有100G数据，无法一次放进内存中，那就只能放在磁盘上了，如果放在磁盘上，有需要搜索某些数据，那么如果处理呢？那么我们可以考虑将存放关键字及其映射的数据的地址放到一个内存中的搜索树的节点中，那么要访问数据时，先取这个地址去磁盘访问数据。（B树系列 解决外查找的问题）
根据上面的分析，我们知道B树系列是为了解决外查找的问题而生的，但是你可能会有这样的疑惑：虽然高度下降了，但是由于我的一个节点存储这多个关键字信息，那么我即使找到这个节点，不也是要遍历关键字信息，效率真的能提高么？？
答：在磁盘中的搜索来说，定位的效率低，但是如果准确定位到了（节点），后面效率就会很高（顺序遍历节点中的关键字），这个跟磁盘的底层结构有关，具体可以参照下面的文献去理解。
二、B树的概念 1970年，R.Bayer和E.mccreight提出了一种适合外查找的树，它是一种平衡的多叉树，称为B树(后面有一个B的改进版本B+树、B*树，然后有些地方的B树写的的是B-树，注意不要误读成"B减树")。一棵m阶(m&gt;2)的B树，是一棵平衡的M路平衡搜索树，可以是空树或者满足一下性质：
（1）根节点至少有两个孩子
（2）每个分支节点都包含k-1个关键字和k个孩子，其中 ceil(m/2) ≤ k ≤ m ceil是向上取整函数
（3）每个叶子节点都包含k-1个关键字，其中 ceil(m/2) ≤ k ≤ m
（4）所有的叶子节点都在同一层
（5）每个节点中的关键字从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域划
分
（6）每个结点的结构为：（n，A0，K1，A1，K2，A2，… ，Kn，An）其中，Ki(1≤i≤n)为关键
字，且Ki&lt;Ki+1(1≤i≤n-1)。Ai(0≤i≤n)为指向子树根结点的指针。且Ai所指子树所有结点中的关键字均小于Ki+1。
（7）实际中M通常会设计得比较大（比如1024）
以上规则可能还有点抽象，我们通过分析B树的插入来剖析具体的过程
三、B树的插入过程分析 为了简单起见，假设M = 3. 即三叉树，每个节点中存储两个数据，两个数据可以将区间分割成三个部分，因此节点应该有三个孩子，为了后续实现简单期间，节点的结构如下：
注意孩子比关键字多一个，并且为了防止越界的问题，我们多开一个空间
用序列{53, 139, 75, 49, 145, 36, 50,47,101}构建B树的过程如下
（1）插入53
（2）插入139
（3）插入75
（4）进行分裂
这里可以解释为什么ceil(m/2) ≤ k ≤ M 假设M是偶数 比如是10 那么后面5个给兄弟，中位数给父亲，自己还剩下4个，兄弟会多一个
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3d17756040a24906017310e1077cd47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b24459880bf84d2861d0a41726a91cfc/" rel="bookmark">
			数据结构十三：八大排序算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排序算法（sorting algorithm）是用于对一组数据按照特定顺序进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更高效地查找、分析和处理。排序算法中的数据类型可以是整数、浮点数、字符或字符串等。排序的判断规则可根据需求设定，如数字大小、字符 ASCII 码顺序或自定义规则，本篇博客详细介绍常见的八大排序算法的基本思想以及实现过程，以及对于算法效率的分析和比较，希望通过本篇博客，能够深入掌握排序算法！
目录
一、排序简介
1.1 什么是排序？
1.2 排序的目的是什么？
1.3 排序的应用场景
1.4 排序算法好坏的度量指标
1.5 排序算法的分类
二、常见排序算法的实现（以升序为例）
2.1 插入类排序—&gt;直接插入排序
2.1.1 基本思想
2.1.2 算法步骤
2.1.3 图解算法 2.1.4 代码实现
2.1.5 测试
2.1.6 算法分析
2.1.7 优缺点
2.1.8 如何优化
2.2 插入类排序—&gt;希尔排序（难）
2.2.1 基本思想
2.2.2 希尔排序的增量数组
2.2.3 算法步骤
2.2.4 图解算法(有横线的值认为已经有序)
2.2.5 代码实现
2.2.6 核心代码分析
​2.2.7 测试
2.2.8 算法分析
2.2.9 总结
2.3 选择类排序—&gt;简单选择排序
2.3.1基本思想
2.3.2算法步骤
2.3.3图解算法
2.3.4代码实现
2.3.5测试
2.3.6算法分析
2.4 选择类排序—&gt;堆排序（难）
2.4.0 铺垫知识 2.4.1 大小堆介绍
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b24459880bf84d2861d0a41726a91cfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acd644bb8713e3d99622e2e9a60ae90b/" rel="bookmark">
			详解循环队列——链表与数组双版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：本节内容主要是讲解循环队列。 在本篇中会讲到两个版本——数组版本、链表版本。本篇内容适合正在学习数据结构队列章节或者已经学过队列但对循环队列感觉模糊的友友们 。
首先先来看一下什么是循环队列
什么是循环队列 因为是刚开始讲解， 所以我们要先来看什么是循环队列：循环队列就是首和尾相连接的队列。如图分别是链表和数组形式的循环队列：
循环队列和普通队列的相同点是：都是从队尾进数据， 从队头出数据。
循环队列和普通队列的不同点是： 普通队列的容量是动态的， 会根据数据的增加而增加。 但是循环队列的容量是静态的， 它不会随着数据的增加而增加。 当队满时， 我们如果想要再添加数据， 只有将对头的数据取出来才能再次添加数据。 循环队列也被成为： 环形缓冲器。
数组版本 判断队空与队满 博主认为对于一个数组版本的循环队列来说， 最重要的就是如何判断它的队空与队满。我们先来看一下如何判断队空和队满
我们利用上图进行分析。 图中tail 和 head为两个指针。 队列中的数字不是存放的数据， 而是数组的下标索引。
我们假设初始化队空的时候tail 和 head指向同一块空间。 那么因为此时队空，所以tail 和head指向的这块空间内没有数据。
然后我们进行入队操作， 入队一个‘5’， 这个‘5’我用绿色用来表示存放的数据。如下图：
既然， ‘5’入队， 那么tail一定要向后移动一位， 所以结果就是上图的情况。 接下来我们再进行入队操作， 依次入队‘6’、‘1’、‘8‘、’6‘、’1‘。这些元素入队后的情况如下图： ok， 到了这一步请思考一下， 这个循环队列应该是此时为满， 还是应该再入队一个元素才满？ 我们在这里进行假设如果再入队一个元素为满。 那么再入队一个元素后，假设这个元素为‘5’，循环队列的情况就是这个样子：
现在， 请将这两个图对比着看：
要知道， 如果此时的状态为满， 那么判满的条件就是 tail == head ； 而判空的条件我们上面说到了也是 tail == head 。那么我们如何区分这个条件下到底是满还是空？所以我们的假设是错误的。真正为满的时候应该是这样的：
这个时侯其实就是该循环队列队满的情况。 那么为什么会空出来一个位置， 这个位置怎么处理？ 对于这个问题。 回答是循环队列的元素个数要比开的空间数小一。 当然有别的办法解决这个问题， 但是传统的数组循环队列， 这里就是这样处理的：元素个数的最大容量要比开的空间数小一。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acd644bb8713e3d99622e2e9a60ae90b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee9da9629140428924253503fc78ca8b/" rel="bookmark">
			Android 系统省电软件分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、硬件耗电 主要有：
1、屏幕
2、CPU
3、WLAN
4、感应器
5、GPS(目前我们没有)
电量其实是目前手持设备最宝贵的资源之一，大多数设备都需要不断的充电来维持继续使用。不幸的是，对于开发者来说，电量优化是他们最后才会考虑的的事情。但是可以确定的是，千万不能让你的应用成为消耗电量的大户
2、参考 2.1 2.2 Purdue University研究了最受欢迎的一些应用的电量消耗，平均只有30%左右的电量是被程序最核心的方法例如绘制图片，摆放布局等等所使用掉的，剩下的70%左右的电量是被上报数据，检查位置信息，定时检索后台广告信息所使用掉的。如何平衡这两者的电量消耗，就显得非常重要了。
2.3 2.4 3、WIFI耗电 前段时间做的省电主要是针对wifi的，三种情况下效果很明显：
1、桌面待机
2、任何应用Home键待机
3、用浏览器或者爱奇艺看视频待机，这种效果相当的明显，完全秒杀
小米平板；同时待机86个小时小米平板（6700毫安）：没电自动关机
K1平板(4060毫安) ：还剩68%
这样处理过后，平板待机时间至少是10天
4、后台应用 目前我们做的做法是后台只保留一个后台程序。后期我们会考虑待机一定时间后，我们会把后台程序清理掉，这样会更省电。
5、APP提高续航 总体原则：提高性能
1、不作没有必要的工作
2、尽量避免内存分配
通常来讲，尽量避免创建短时临时对象.少的对象创建意味着低频的垃圾回收。而这对于用户体验产生直接的影响。
例：避免内部的Getters/Setters
在源生语言像C++中，通常做法是用Getters（i=getCount()）代替直接字段访问（
i=mCount）。这是C++中一个好的习惯，因为编译器会内联这些访问，并且如果需要约束或者调试这些域的访问，你可以在任何时间添加代码。
而在Android中，这不是一个好的做法。虚方法调用的代价比直接字段访问高昂许多。通常根据面向对象语言的实践，在公共接口中使用Getters和Setters是有道理的，但在一个字段经常被访问的类中宜采用直接访问。
无JIT时，直接字段访问大约比调用getter访问快3倍。有JIT时（直接访问字段开销等同于局部变量访问），要快7倍。在Froyo版本中确实如此，但以后版本可能会在JIT中改进Getter方法的内联。
6、布局 总体原则：控件尽量少、尽量减少布局层次
1、Textview +Imageview → Textview+icon（android:drawableXXX）
2、多个LinearLayout→单个RelativeLayout
3、使用 标签来减少视图层级结构
4、通过 标签来重用layout代码
5、Layout_weight使用时，android:layout_width或者android:layout_height值尽量为0，而不是自适应，为什么？
…
View渲染流程
7、WakeLock 尽量减少唤醒屏幕的次数与持续的时间(屏幕是用电大户)，用WakeLock来处理唤醒的问题，能够正确执行唤醒操作并根据设定及时关闭操作进入睡眠状态，使用wakelock.acquice() 方法，一定要加上超时处理(例如释放锁)。
使用场景：Android中通过各种Lock锁对电源进⾏行控制，比如保持通信和后台续连。
另一种思路：
不用冒着忘记释放Wakelock的风险，交给系统处理，也不用在manifest中设置权限，只在布局文件XML声明即可，当然也可以用函数：View.setKeepScreenOn()方法控制即可。
8、优化网络 1、设置网络超时时间包括连接超时和请求超时
2、触发网络请求的操作，每次都会保持无线信号持续一段时间，我们可以把零散的网络请求打包进行一次操作，避免过多的无线信号引起的电量消耗(例如APP的数据采集)。比如我们的大数据和推送等应用。
3、如果没有网络连接，你的应用跳过网络操作；只在有网络连接并且无漫游的情况下更新数据；
4、选择兼容的数据格式，把含有文本数据和二进制数据的请求全部转化成二进制数据格式请求；
5、使用高效的转换工具，多考虑使用流式转换工具，少用树形的转换工具；
很明显，使用流的方式解析效率要高一些，因为DOM解析是在对整个文档读取完后，再根据节点层次等再组织起来。而流的方式是边读取数据边解析，数据读取完后，解析也就完毕了。
在数据格式方面，JSON和Protobuf效率明显比XML好很多，XML和JSON大家都很熟悉，Protobuf是Google提出的，一种语言无关、平台无关、扩展性好的用于通信协议、数据存储的结构化数据串行化方法。
从上面的图中我们可以得出结论就是尽量使用SAX等边读取边解析的方式来解析数据，针对移动设备，最好能使用JSON之类的轻量级数据格式为佳。
6、如果可以的话，请使用framework的GZIP库来压缩文本数据以高效使用CPU资源。
9、调整定时更新的频率 int alarmType = AlarmManager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee9da9629140428924253503fc78ca8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7c49b9745853bb84a83f56fb3473c49/" rel="bookmark">
			2024/5/13 SpringBoot配置多个RabbitMQ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、单个RabbitMQ配置
1.1、导入Maven坐标
1.2、yaml配置
1.3、java配置类
1.3.1、交换机配置
1.3.2、队列配置
1.3.3、绑定配置
1.3.4、连接配置
1.4、生产者与消费者操作配置
1.4.1、生产者操作配置
1.4.2、消费者操作配置
二、多个RabbitMQ配置
2.1、yaml配置 2.2、java配置类
2.3、生产者与消费者操作配置
2.3.1、生产者操作配置
2.3.1、消费者操作配置
三、总结 需求描述：原SpringBoot工程已经配置了一个RabbitMQ，现需求是再配置一个RabbitMQ，实现效果是不同RabbitMQ推送到不同的队列中，且互不干扰影响使用。
一、单个RabbitMQ配置 1.1、导入Maven坐标 &lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;amqp-client&lt;/artifactId&gt; &lt;version&gt;5.10.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt; &lt;/dependency&gt; 1.2、yaml配置 rabbitmq: host: xx.xxx.xxx.xxx port: xxxx username: xxxx password: xxxxxx virtual-host: xxxx publisher-returns: true publisher-confirms: true listener: simple: default-requeue-rejected: true retry: enabled: false max-attempts: 3 initial-interval: 5000 1.3、java配置类 1.3.1、交换机配置 package com.ruoyi.report.config; import org.springframework.amqp.core.DirectExchange; import org.springframework.context.annotation.Bean; import org.springframework.stereotype.Component; @Component public class ExchangeConfig { public static final String ecoa_exchange = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7c49b9745853bb84a83f56fb3473c49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6527c4923c81f04881c04fed37afee14/" rel="bookmark">
			【数据结构】有关栈和队列相互转换问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 用队列实现栈思路实现 用栈实现队列思路实现 用队列实现栈 Leetcode-225 用队列实现栈
思路 建立队列的基本结构并实现队列的基本操作
这部分这里就不多说了，需要的可以看笔者的另一篇博客
【数据结构】队列详解(Queue)
就简单带过一下需要实现的功能
#define _CRT_SECURE_NO_WARNINGS 1 #pragma once #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;stdbool.h&gt; #include&lt;assert.h&gt; #include&lt;stdbool.h&gt; typedef int QDataType; typedef struct QueueNode { struct QueueNode* next; QDataType val; }QNode; typedef struct Queue { QNode* phead; QNode* ptail; int size; }Queue; //初始化 void QueueInit(Queue* pq); //销毁 void QueueDestroy(Queue* pq); // 队尾插入 void QueuePush(Queue* pq, QDataType x); // 队头删除 void QueuePop(Queue* pq); // 取队头和队尾的数据 QDataType QueueFront(Queue* pq); QDataType QueueBack(Queue* pq); //获取队列长度 int QueueSize(Queue* pq); //判断队列是否为空 bool QueueEmpty(Queue* pq); 使用两个队列实现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6527c4923c81f04881c04fed37afee14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e3b630a350bc942c5fb07e521d7bd66/" rel="bookmark">
			【Python贪吃蛇】：编码技巧与游戏设计的完美结合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🔥一、运行效果💥二、游戏教程✈1. 导入模块❤️2. 初始化游戏元素☔3. 改变蛇移动的方向👊4. 绘制方块🚀5. 检查蛇头是否在游戏区域内🌈6. 定义蛇的移动函数🎬7. 绑定键盘事件 ⭐三、完整代码 🔥一、运行效果 Python实现贪吃蛇
💥二、游戏教程 🚲turtle模块
Python的turtle模块是一个非常基础的绘图库，它允许用户创建一个画布并在上面绘制图形。这个模块通常用于教学目的，特别是适合初学者学习编程和理解基本的图形概念。
turtle的一些关键特性：
画布和乌龟：turtle模块提供了一个名为“乌龟”的画笔，可以在一个名为“画布”的窗口上绘制图形。用户可以控制乌龟的移动来画出各种图案。前进和后退：可以使用forward()和backward()方法让乌龟在画布上前进或后退。转向：left()和right()方法可以让乌龟左转或右转，可以通过度数参数指定转向的角度。抬笔和落笔：penup()和pendown()方法分别用于抬起和放下乌龟的笔，抬起笔时乌龟移动不会绘制线条，而放下笔时会绘制线条。颜色和填充：可以设置乌龟绘制的颜色，并且可以填充封闭图形的内部。速度控制：可以设置乌龟的移动速度，从最快到最慢。监听事件：turtle模块可以监听键盘和鼠标事件，这使得它可以用来创建简单的交互式图形应用。设置画布：可以设置画布的大小、背景颜色等。坐标系统：turtle模块使用笛卡尔坐标系，原点在画布的中心，x轴向右，y轴向上。子图和窗口：可以在一个窗口中创建多个乌龟对象，或者在多个窗口中绘图。更新和动画：通过update()方法可以刷新画布显示，实现动画效果。事件循环：turtle模块提供了事件循环，允许程序保持运行状态直到用户关闭窗口。 turtle模块非常适合用来创建游戏、绘制复杂的几何图形，或者作为教授编程逻辑和控制结构的工具。
✈1. 导入模块 import turtle import copy from random import randrange turtle：用于绘制图形和动画。copy：用于复制蛇的头部坐标，避免在移动蛇时直接修改原始列表。randrange：从random模块中导入，用于生成随机数，这里用来随机放置食物。 ❤️2. 初始化游戏元素 创建画布和设置标题
wn = turtle.Screen() wn.title('贪吃蛇游戏') 保持打开绘图窗口
# 不让屏幕立马消失 turtle.done() turtle.done()是一个非常重要的函数，它用于结束绘图操作并保持打开绘图窗口，直到用户关闭该窗口。这允许用户观察绘制的图形，而不会因为程序的结束而丢失绘图结果。
使用场景
在绘制图形或动画的最后，你会调用turtle.done()来结束你的绘图脚本。例如，在绘制完一个图形或完成一个动画循环后，你可以使用它来防止程序立即退出，从而让用户有足够的时间来查看结果。
注意事项
如果在调用turtle.done()之前程序崩溃或被强制终止，绘图窗口可能会立即关闭。在某些IDE（如Jupyter Notebook）中，turtle.done()可能不会按预期工作，因为这些环境可能不支持turtle模块的图形窗口特性。 设置蛇的长度
snake = [[0, 0], [0, 10], [0, 20]] 这里初始化了蛇的三个部分，每个部分由一个列表表示，列表包含两个元素，分别代表蛇的x和y坐标。在这个例子中，蛇有三个部分，初始位置分别是(0, 0)、(0, 10)和(0, 20)。
蛇移动的方向
aim = [0, 10] aim列表定义了蛇的移动方向，其中第一个元素是水平方向（向右为正，向左为负），第二个元素是垂直方向（向下为正，向上为负）。这里，蛇默认向上移动。
设置食物
food = [-10, 0] food列表定义了食物的初始位置，同样使用x和y坐标表示。这里食物的初始位置是(-10, 0)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e3b630a350bc942c5fb07e521d7bd66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e62856c9b3aab7bbd1f20b0fef6323b8/" rel="bookmark">
			【C#】.net core 6.0 ApiController，API控制器方法，API接口以实体类作为接收参数应该注意的点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到《小5讲堂》
这是《C#》系列文章，每篇文章将以博主理解的角度展开讲解。
温馨提示：博主能力有限，理解水平有限，若有不对之处望指正！
目录 背景实体类参数API接口不可空参数可空参数参数类型MVC历程相关文章 背景 对于API接口，接收参数的类型会有很多，有些是地址参数，有些是Form表单参数。
对于不同的后端开发语言，可能会有一定的限制，比如本次文章探讨的API控制器方法接收实体类参数问题。
如果实体类的参数是字符串并且没有指明是否可空，那么这个API接口则无法调用成功。
实体类参数 假设定义一个实体类，有两个参数，一个是Name字符串类型，一个是Age整型。
public class TempModel { public string Name { get; set; } public int Age { get; set; } } API接口 不可空参数 代码 using Microsoft.AspNetCore.Mvc; namespace core60api.Api { /// &lt;summary&gt; /// 临时 - api接口 /// &lt;/summary&gt; [ApiController] [Route("api/[controller]/[action]")] public class TempController : ControllerBase { public async Task&lt;IActionResult&gt; Get(TempModel model) { return Ok($"Name={model.Name}，Age={model.Age}"); } public class TempModel { public string Name { get; set; } public int Age { get; set; } } } } 调用报错
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e62856c9b3aab7bbd1f20b0fef6323b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2be8d795a10d291b056dd2e20c72eae0/" rel="bookmark">
			AI大模型探索之路-训练篇22： ChatGLM3微调实战-从原理到应用的LoRA技术全解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列篇章💥 AI大模型探索之路-训练篇1：大语言模型微调基础认知
AI大模型探索之路-训练篇2：大语言模型预训练基础认知
AI大模型探索之路-训练篇3：大语言模型全景解读
AI大模型探索之路-训练篇4：大语言模型训练数据集概览
AI大模型探索之路-训练篇5：大语言模型预训练数据准备-词元化
AI大模型探索之路-训练篇6：大语言模型预训练数据准备-预处理
AI大模型探索之路-训练篇7：大语言模型Transformer库之HuggingFace介绍
AI大模型探索之路-训练篇8：大语言模型Transformer库-预训练流程编码体验
AI大模型探索之路-训练篇9：大语言模型Transformer库-Pipeline组件实践
AI大模型探索之路-训练篇10：大语言模型Transformer库-Tokenizer组件实践
AI大模型探索之路-训练篇11：大语言模型Transformer库-Model组件实践
AI大模型探索之路-训练篇12：语言模型Transformer库-Datasets组件实践
AI大模型探索之路-训练篇13：大语言模型Transformer库-Evaluate组件实践
AI大模型探索之路-训练篇14：大语言模型Transformer库-Trainer组件实践
AI大模型探索之路-训练篇15：大语言模型预训练之全量参数微调
AI大模型探索之路-训练篇16：大语言模型预训练-微调技术之LoRA
AI大模型探索之路-训练篇17：大语言模型预训练-微调技术之QLoRA
AI大模型探索之路-训练篇18：大语言模型预训练-微调技术之Prompt Tuning
AI大模型探索之路-训练篇19：大语言模型预训练-微调技术之Prefix Tuning
AI大模型探索之路-训练篇20：大语言模型预训练-常见微调技术对比
AI大模型探索之路-训练篇21：Llama2微调实战-LoRA技术微调步骤详解
目录 系列篇章💥前言一、经典的Transformer架构二、ChatGLM3架构设计1、GLM 动机2、GLM的核心机制3、预训练任务类型1）掩码语言模型，自编码模型2）因果模型，自回归模型3）序列到序列模型 4、prompt格式 三、ChatGLM3微调准备1、数据准备2、模型选择 四、基于LoRA微调ChatGLM3步骤1 导入相关包步骤2 加载数据集步骤3 数据集预处理1）获取分词器2）定义数据处理函数3）对数据进行预处理4）解码检查input_ids的格式5）检查labels数据格式 步骤4 创建模型1、创建模型实例1）创建模型2）精度查看确认3）查看模型参数 2、PEFT 步骤1 配置文件3、PEFT 步骤2 创建模型1）创建微调模型2）查看LoRA层添加情况3）查看模型中可训练参数的数量 步骤5 配置训练参数步骤6 创建训练器步骤7 模型训练步骤8 模型推理 总结 前言 在自然语言处理的浪潮中，Transformer架构以其独特的设计和卓越性能，成为了大语言模型的基石。ChatGLM3，作为其中的一员，通过微调在特定任务上展现了其强大的适应性和灵活性。本文将深入探讨ChatGLM3的架构设计，微调策略，并提供实战案例，以期为开发者提供宝贵的参考。
一、经典的Transformer架构 Transformer架构自问世以来，已成为NLP领域的一个里程碑。其核心思想是利用自注意力机制（Self-Attention）来捕捉文本中的长距离依赖关系，无需像循环神经网络（RNN）那样逐步处理序列。各大语言模型虽基于Transformer演变；但在结构、编码方式、激活函数、layer Norm方法上各有不同；另外掩码的设计不同，训练数据和目标的多样性等，都赋予了模型不同的特性和应用场景。
二、ChatGLM3架构设计 1、GLM 动机 大型预训练语言模型的发展可归纳为三个主要方向：
1）自编码模型 (Auto Encoding)： BERT，ROBERTa，DeBERTa，ALBERT等；采用双向注意力机制，擅长处理自然语言理解任务，如情感分类、抽取式问答和自然语言推理等。
2）自回归模型 (Auto Regressive) ：GPT系列，Llama，百川，等；通过单向注意力机制，专注于生成任务，包括语言建模和文本生成。
3）编码器-解码器模型 (Encoder-Decoder) : T5，BART，MASS，PALM等；结合了双向和单向注意力（encoder的attention是双向的，decoder的attention是单向的）。适用于条件生成(seq2seq)任务，比如：文本摘要，机器翻译等。
然而，现有模型在多任务性能上存在局限。GLM（General Language Model）旨在融合三者优势，实现在自然语言理解、生成和条件生成任务上的全面优化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2be8d795a10d291b056dd2e20c72eae0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5089fd683ac3fe1866cf760627f75b31/" rel="bookmark">
			限流算法(令牌桶&amp;漏桶&amp;计数器)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页：五敷有你 🔥系列专栏：Spring
⛺️稳中求进，晒太阳
业务重的三种情况：突发流量、恶意流量、业务本身需要
限流: 是为了保护自身系统和下游系统不被高并发流量冲垮，导致系统雪崩。
保证系统在可用的情况下尽可能增加进入的请求，其余的请求在排队等待，或者返回友好提示。保证进入系统的用户可以友好使用。
令牌桶算法 令牌桶算法是一个设定的速率产生令牌(token) 并放入令牌通，每次用户请求都得申请令牌。如果令牌不足，则拒绝请求。
令牌桶算法中新请求到来时会从桶中拿走一个令牌，如果桶内没有i令牌可拿，就拒绝服务。
当然令牌的数量也是有上限的。令牌的数量与时间和发放速率强相关。时间流逝的时间越长，会不断往桶里加入越多的令牌，如果令牌发送的速度比申请速度快，令牌会放满令牌桶，直到令牌占满令牌桶
令牌桶的算法特点： 好处：可以方便地应对突发出口流量。
比如：可以改变令牌发放速度(需要后端系统能力的提升)，算法能按照新的发送速率调大令牌的发放数量，使得出口突发流量能被处理。
令牌生成的速度固定，消费速度不固定。
代码简单实现： package ratelimit; import java.util.concurrent.*; import java.util.concurrent.atomic.AtomicInteger; import java.util.logging.Logger; public class TokenBucketLimiter { //桶的容量 private static int capacity=100; //令牌生成速度 rate/s private static final int rate=50; //令牌数量 private volatile static AtomicInteger tokens=new AtomicInteger(0); /** * 开启一个线程，按固定频率放入令牌桶固定个数 */ public static void productTokens(){ ScheduledExecutorService scheduledExecutorService= Executors.newScheduledThreadPool(1); scheduledExecutorService.scheduleAtFixedRate(()-&gt;{ int allTokens = tokens.get()+rate; //设置当前的tokens数量 tokens.set(allTokens); },1000,1000,TimeUnit.MILLISECONDS); } /** * true是被限流了 * * @param needCount * @return */ public static synchronized boolean limited(int needCount){ if(tokens.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5089fd683ac3fe1866cf760627f75b31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/715ef15cea32c8beeeb38e749d64e5c0/" rel="bookmark">
			【高阶数据结构(三)】图的遍历&amp;最小生成树问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💓博主CSDN主页:杭电码农-NEO💓
⏩专栏分类:高阶数据结构专栏⏪
🚚代码仓库:NEO的学习日记🚚
🌹关注我🫵带你学习更多Go语言知识
🔝🔝
高阶数据结构 1. 前言2. 图的遍历3. 图的广度优先遍历4. 图的深度优先遍历5. 图的最小生成树6. Kruskal算法讲解7. prim算法讲解8. 总结以及拓展 1. 前言 如果你还不知道什么是图论,以及关于图的存储结构和一些专有名词, 请先阅读这篇文章: 初识图论.
本章重点:
本篇文章着重讲解图的两种遍历方式: 深度优先遍历和广度优先遍历. 并会模拟实现这两种遍历方法. 其次,会讲解关于图的最小生成树的概念,以及关于最小生成树的两个算法: Kruskal算法和Prim算法
2. 图的遍历 给定一个图G和其中任意一个顶点v0，从v0出发，沿着图中各边访问图中的所有顶点，且每个顶点仅被遍历一次。
这道面试题就是典型的图论的遍历
3. 图的广度优先遍历 正如其名, 广度优先遍历就是先遍历完一个顶点的所有相邻顶点
比如现在要找东西，假设有三个抽屉，东西在那个抽屉不清楚，现在要将其找到，广度优先遍历的做法是:
先将三个抽屉打开，在最外层找一遍将每个抽屉中红色的盒子打开，再找一遍将红色盒子中绿色盒子打开，再找一遍直到找完所有的盒子 注意:每个盒子只能找一次，不能重复找
具体到一个图中就是这样的:
广度优先遍历看似很简单, 对于顶点A来说, 先走B,C,D. 然后再看B顶点, 走A,C,E, 但是A和C已经走过了,所以不能再此将它们算进去. 做法很简单, 使用一个队列和一个数组, 数组用来存储一个顶点是否已经入过队列了. 对于队列而言, 它的功能相信我不说大家也能明白: 最开始只有A在队列中, A出队, BCD入队, B出队, AC不用入队, 只入E. C出队…
话不多说,直接上代码:
void BFS(const V&amp; src) //图的广度优先遍历 { size_t srci = _index[src];//找到值src对应在数组中的下标 queue&lt;int&gt; q; vector&lt;bool&gt; check(_vertex.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/715ef15cea32c8beeeb38e749d64e5c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e96e22a1585929ee6682d55a42d3220/" rel="bookmark">
			高校普法|基于SSM＋vue的高校普法系统的设计与实现(源码&#43;数据库&#43;文档)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高校普法系统
目录
基于SSM＋vue的高校普法系统的设计与实现
一、前言
二、系统设计
三、系统功能设计 1系统功能模块
2管理员功能模块
3律师功能模块
4学生功能模块
四、数据库设计
五、核心代码 六、论文参考
七、最新计算机毕设选题推荐
八、源码获取：
博主介绍：✌️大厂码农|毕设布道师，阿里云开发社区乘风者计划专家博主，CSDN平台Java领域优质创作者，专注于大学生项目实战开发、讲解和毕业答疑辅导。✌️
主要项目：小程序、SpringBoot、SSM、Vue、Html、Jsp、Nodejs等设计与开发。
🍅文末获取源码联系🍅
基于SSM＋vue的高校普法系统的设计与实现 一、前言 本高校普法系统以ssm作为框架，b/s模式以及MySql作为后台运行的数据库，同时使用Tomcat用为系统的服务器。本系统主要包括以下功能模块：首页，个人中心，律师推荐管理，咨询问题管理，问题回复管理，学生管理，律师管理，类型管理，法律知识管理，新闻类型管理，法律新闻管理，律师推荐管理，咨询问题管理，问题回复管理，管理员管理，普法论坛，系统管理等模块，通过这些模块的实现能够基本满足日常高校普法管理的操作。
本文着重阐述了高校普法系统的分析、设计与实现，首先介绍开发系统和环境配置、数据库的设计，接着说明功能模块的详细实现，最后进行了总结。
关键词：高校普法系统；ssm；MySql数据库；Tomcat
二、系统设计 系统功能结构如图
三、系统功能设计 1系统功能模块 高校普法系统，进入到系统首页，可以查看首页，法律知识，法律新闻，律师推荐，普法论坛，法律与校园，个人中心，后台管理等内容进行操作，如图4-1所示。
图4-1系统首页界面图
2管理员功能模块 登录，通过填写注册时输入的用户名、密码、选择角色等信息进行登录操作，如图4-6所示。
图4-6登录界面图
3律师功能模块 律师登录进入高校普法系统后台可以查看首页，个人中心，律师推荐管理，咨询问题管理，问题回复管理等内容进行相应操作，如图4-13所示。
图4-13律师功能界面图
4学生功能模块 学生登录进入高校普法系统后台可以对首页，个人中心，咨询问题管理，问题回复管理等内容进行相应操作，如图4-16所示。
图4-16学生功能界面图
四、数据库设计 学生注册实体属性图如下所示：
图3-2学生注册实体属性图
数据库表的设计，如下表：
表3-1：token表
字段名称
类型
长度
字段说明
主键
默认值
id
bigint
主键
主键
userid
bigint
用户id
username
varchar
100
用户名
tablename
varchar
100
表名
role
varchar
100
角色
token
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e96e22a1585929ee6682d55a42d3220/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1b4049547a0ebdc9e4745c35010fa0d/" rel="bookmark">
			动态规划----股票买卖问题（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.买卖股票的最佳时机：
二.买卖股票的最佳时机含冷冻期：
三.买卖股票的最佳时期含⼿续费：
四.买卖股票的最佳时机III: 五.买卖股票的最佳时机IV:
买卖股票的最佳时机问题介绍：动态规划买卖股票的最佳时机是一个经典的算法问题。该问题的目标是在给定的股票价格数组中，找到最大的利润，即最佳的买入和卖出时间，使得买入时间早于卖出时间。
下面我们通过一些例题，来解决这一类动态规划的问题：
一.买卖股票的最佳时机： 题目链接：121. 买卖股票的最佳时机 - 力扣（LeetCode）题目描述： 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
①.动态规划解法：
一.状态表示dp[ i ][ j ]：下标为 i 这一天结束的时候，手上持股状态为 j 时，我们持有的最大利润。这里我们定义状态 j （两种情况）分别为：0 买入状态1 可交易状态二.状态转移方程：dp[ i ][ 0 ] = Math.max( dp[ i - 1 ][ 0 ], -prices[ i ]) ; ①.在前面一天已经是买入状态，今天选择什么也不干，今天结束后，是买入状态。②.前面是可交易状态，今天选择买入，则今天结束后是买入状态，这里注意不是dp[ i - 1][ 1 ] - prices[ i ];因为只能交易一次，如果今天选择买入，那后面一定要卖出（这算一次交易),此时才可能有最大利润。则前面不能有交易，利润为0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1b4049547a0ebdc9e4745c35010fa0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dad8984eac2d6201502435e9e1024726/" rel="bookmark">
			【一步一步了解Java系列】：了解Java与C语言的运算符的“大同小异”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看到这句话的时候证明：此刻你我都在努力~
加油陌生人~
个人主页： Gu Gu Study ​​
专栏：一步一步了解Java
喜欢的一句话： 常常会回顾努力的自己，所以要为自己的努力留下足迹。
如果喜欢能否点个赞支持一下，谢谢啦！
作者：小闭
目录
一、算术运算符
二、赋值运算符（增量，自增运算符）
三、关系运算符
四、逻辑运算符
五、位运算符
六、移位操作符
运算符的作用
在 Java 中，运算符具有以下主要作用：
计算机语言最基本的作用就是进行数学运算
1. 执行运算：如算术运算符（+、-、*、/等）用于进行数学计算。
2. 比较操作：比较运算符（如&gt;、&lt;、&gt;=、&lt;=等）用于比较两个值的大小关系。
3. 逻辑判断：逻辑运算符（&amp;&amp;、||、!等）用于组合和判断条件。
4. 赋值操作：赋值运算符（=）用于将值赋给变量。
5. 其他操作：还有一些特殊的运算符，如位运算符等，用于位操作等。
Java中各种运算符功能
Java 中的运算符可以分为以下几类：
1. 算术运算符：用于执行基本的数学运算，如加法、减法、乘法、除法和取模（取余）等。例如，+ 表示加法运算，- 表示减法运算。
2. 关系运算符：用于比较两个值的关系，如等于、不等于、大于、小于等。关系运算符返回布尔值（true 或 false），用于条件判断。例如，== 表示等于运算，&lt; 表示小于运算。
3. 逻辑运算符：用于执行逻辑运算，如逻辑与、逻辑或和逻辑非等。逻辑运算符通常用于布尔值的操作，它们返回布尔结果。例如，&amp;&amp; 表示逻辑与，|| 表示逻辑或，! 表示逻辑非。
4. 赋值运算符：用于将值赋给变量，如 = 表示赋值运算，+= 表示加并赋值。
5. 自增和自减运算符：用于增加或减少变量的值，例如 ++ 表示自增，-- 表示自减。
6. 位运算符：用于对二进制位进行操作，如位与、位或、位异或、取反等。
7. 三目运算符：用于根据条件选择一个值。
一、算术运算符 基本四则运算符：加减乘除模(+ - * / %)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dad8984eac2d6201502435e9e1024726/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/19/">«</a>
	<span class="pagination__item pagination__item--current">20/71</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/21/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>