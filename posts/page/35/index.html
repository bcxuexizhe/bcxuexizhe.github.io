<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c353499a03cc044b72445abd3acbe52/" rel="bookmark">
			【C&#43;&#43;干货基地】面向对象核心概念 const成员函数 | 初始化列表 | explicit关键字 | 取地址重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎬 鸽芷咕：个人主页 🔥 个人专栏: 《C++干货基地》《粉丝福利》 ⛺️生活的理想，就是为了理想的生活! 引入 哈喽各位铁汁们好啊，我是博主鸽芷咕《C++干货基地》是由我的襄阳家乡零食基地有感而发，不知道各位的城市有没有这种实惠又全面的零食基地呢？C++ 本身作为一门篇底层的一种语言，世面的免费课程大多都没有教明白。所以本篇专栏的内容全是干货让大家从底层了解C++，把更多的知识由抽象到简单通俗易懂。
⛳️ 推荐 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站。
文章目录 引入⛳️ 推荐一、const 成员函数1.1 什么是const 成员函数1.2 const成员函数的注意事项总结 二、取地址及const取地址操作符重载2.1 取地址操作的意义 三、重新认识构造函数3.1构造函数体赋值3.2 初始化列表规则一规则二 四、explicit关键字4.1 构造函数的隐式类型转换4.2 隐式转换的作用4.2 explicit关键字的使用 一、const 成员函数 1.1 什么是const 成员函数 cosnt 的成员函数其实就是在我们 函数的括号外 多加一个 const void Dlsplay() const 其他的作用是修饰 隐含的 this 指针，使其不能修改。 1.2 const成员函数的注意事项 const 成员可以直接修饰this指针那么使用起来有什么要注意的嘛？
下面我们看一下这些代码来思考一下 #include&lt;iostream&gt; using namespace std; class Date { public: Date(int year, int month, int day) { _year = year; _month = month; _day = day; } void Print() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c353499a03cc044b72445abd3acbe52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e86dccd2a70fe3753dedc8534891351/" rel="bookmark">
			AI大模型探索之路-应用篇17：GLM大模型-大数据自助查询平台架构实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、技术架构设计二、本地知识库准备三、SQLServer服务1. 数据库准备步骤1：安装MySQL数据库步骤2：启动MySQL数据库步骤3：登录MySQL数据库步骤4：创建数据库用户glm步骤5：给数据库用户赋权限步骤6：创建数据库 2. 数据准备3. SQL服务封装 四、核心代码落地1.模型加载2.本地知识库读取3.function call函数封装4.工具函数封装5. 调用查询测试 五、结束思考 前言 在众多大型企业中，数据资产庞大无比，因此它们纷纷构建了多种大数据平台。然而，关键在于如何高效地利用这些数据，例如，将数据有效地提供给产品经理或数据分析师以供他们进行设计和分析。在传统工作流程中，由于这些角色通常不是技术专家，他们往往无法直接使用和操控SQL，导致必须依赖技术人员来编写SQL查询并返回结果，然后才能由产品经理、数据分析师或其他相关人员进一步处理。
然而，随着强大的大模型]的出现，我们对自然语言的理解能力得到了极大的提升，同时通过支持的插件式扩展（允许自主调用相关外部方法或API），为我们解决这一难题提供了全新的思路。这些大模型不仅能够理解复杂的自然语言查询，还能够与现有的数据处理工具无缝集成，从而使得非技术用户也能够直接参与到数据分析的过程中，无需通过技术人员作为中介，极大地提高了工作效率和决策的速度。
一、技术架构设计 用户输入说明要查询的信息，LLM基于本地知识库生成SQL，调用不同的Funcation Call，每个一个Funcation call中都封装一个不同的数据服务的调用；比如Mysql、Hive、Spark、Flink。
二、本地知识库准备 大模型擅长将输出转化为不同格式，比如从一种语言翻译成另一种语言，帮助拼写、语法纠正以及编写正则表达式；整个平台有两个基础支持的部分，第一部分就是数据字典，我们先将所有需要查询的数据库、表、字段信息结构化整理成数据字典，作为本地知识库。
三、SQLServer服务 平台中两个核心支撑中另外一个就是数据服务的开发，基于不同的数据库类型，开发不同的数据服务，用于支撑LLM的数据查询；包括但不限于：MySQL数据服务，Hive数据服务、Spark数据服务、Flink数据服务等；
1. 数据库准备 步骤1：安装MySQL数据库 sudo apt-get update sudo apt-get install mysql-server 步骤2：启动MySQL数据库 sudo service mysql start sudo systemctl start mysqld 步骤3：登录MySQL数据库 mysql -u root -p 步骤4：创建数据库用户glm CREATE USER 'glm'@'localhost' IDENTIFIED BY 'glm'; 步骤5：给数据库用户赋权限 GRANT ALL PRIVILEGES ON *.* TO 'glm'@'localhost'; FLUSH PRIVILEGES; 步骤6：创建数据库 CREATE DATABASE glm; USE glm; 2. 数据准备 CREATE TABLE user_info ( customerID VARCHAR(255), gender VARCHAR(255), SeniorCitizen INT, Partner VARCHAR(255), Dependents VARCHAR(255) ); INSERT INTO user_info (customerID, gender, SeniorCitizen, Partner, Dependents) VALUES ('1', 'Female', 0, 'Yes', 'No'), ('2', 'Male', 1, 'No', 'Yes'), ('3', 'Male', 0, 'No', 'No'), ('4', 'Female', 1, 'Yes', 'Yes'), ('5', 'Male', 0, 'No', 'No'), ('6', 'Female', 0, 'Yes', 'Yes'), ('7', 'Male', 1, 'Yes', 'No'), ('8', 'Female', 0, 'No', 'No'), ('9', 'Male', 1, 'Yes', 'Yes'), ('10', 'Female', 0, 'No', 'No'), ('11', 'Male', 0, 'Yes', 'Yes'), ('12', 'Female', 1, 'No', 'No'), ('13', 'Male', 0, 'No', 'Yes'), ('14', 'Female', 0, 'Yes', 'No'), ('15', 'Male', 1, 'Yes', 'Yes'), ('16', 'Female', 0, 'No', 'No'), ('17', 'Male', 0, 'No', 'Yes'), ('18', 'Female', 1, 'Yes', 'No'), ('19', 'Male', 0, 'No', 'No'), ('20', 'Female', 1, 'No', 'Yes'); 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e86dccd2a70fe3753dedc8534891351/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68e64924571bed6615ad57f9e9009de1/" rel="bookmark">
			ai绘画软件哪个好用？满足你的创作需求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在看到各种唯美的插画时，大家有没有想过，其实自己也能来创作呢？
ai绘画生成功能的出现，让人们可以在无需具备专业绘画技能的情况下，享受到艺术创作的乐趣，尽情挥洒想象力。
这个功能可以智能识别关键词并生成符合要求的绘画作品，省去绘画过程，为创作者提供了创作灵感，也让普通人带来了更多欣赏和体验艺术的机会。
可是这样的ai绘画图片该用什么软件呢？今天就带你去了解一下。
一、软件：AI绘图助手
▷产品简介：AI绘图助手是一个将你的创意想法转化为图像的智能工具，通过简单的文字描述就能生成相应的画作。
▷适用场合：无论是设计初步概念图、寻找创作灵感，还是仅仅为了娱乐和探索艺术的无限可能，它都能派上用场。
▷功能优势：它的直观操作界面让没有专业绘画技能的人也能轻松创作，而且生成的图像多样性和创意性常常给人惊喜。
二、软件：Leonardo
▷产品简介：Leonardo是一个专注于模仿经典绘画风格的AI软件，能够根据描述创作出具有一定艺术风格的画作。
▷适用场合：如果你对古典艺术感兴趣，或者需要为特定风格的项目寻找视觉素材，它会是一个很好的选择。
▷功能优势：它的强项在于能够捕捉并再现历史上著名画家的风格，让你的作品看起来像是出自大师之手。
三、软件：midjourney
▷产品简介：midjourney是一个能够根据简短的文字提示创造出独特艺术作品的AI绘画工具。
▷适用场合：适合用于社交媒体内容创作、个人项目的视觉设计，或者作为日常放松心情的一种方式。
▷功能优势：它的创作速度快，图像质量高，而且每次生成的作品都具有独特性，让人充满期待。
四、软件：Nightcafe
▷产品简介：Nightcafe是一个结合了AI技术和艺术创造力的平台，可以帮你将概念转化为视觉艺术作品。
▷适用场合：无论是想要为自己的小说设计封面，还是为个人品牌创造独特的视觉标识，它都能提供帮助。
▷功能优势：它的特色在于能够理解和转化复杂的创意指令，生成具有深度和内涵的艺术作品。
五、软件：Picso
▷产品简介：Picso是一个AI艺术创作工具，通过输入简单的文字描述，就能生成具有现代感和创意的图像。
▷适用场合：适合用于广告设计、社交媒体帖子的视觉装饰，或者是个人创意项目的图像创作。
▷功能优势：界面简洁易用，生成的图像风格多样，非常适合快节奏的创意工作。
六、软件：Prisma
▷产品简介：Prisma是一款将普通照片转化为艺术作品的应用程序，它使用AI技术模仿各种著名画家的风格。
▷适用场合：无论是想要给日常生活照片增添艺术感，还是为专业作品寻找独特的视觉效果，它都能满足需求。
▷功能优势：它提供了大量的艺术风格选择，操作简单，一键转换，让每个人都能成为艺术创作者。
七、软件：Runway ML
▷产品简介：Runway ML是一个结合了机器学习和创意工具的平台，它可以通过AI生成独特的视觉内容。
▷适用场合：适合设计师、艺术家和创意工作者使用，可以用于项目原型设计、视觉实验，或者仅仅是探索AI艺术的边界。
▷功能优势：提供了丰富的模型和工具，支持深度定制，让创作过程更加灵活和个性化。
八、软件：Stability AI
▷产品简介：Stability AI是一个强大的AI绘画工具，能够根据文字描述生成高质量的图像。
▷适用场合：无论是游戏开发者需要角色设计，还是作家需要插图配合，它都能提供专业的支持。
▷功能优势：它的图像生成速度快，质量高，且能够根据反馈进行调整，确保最终作品符合预期。
九、软件：WOMBO Dream
▷产品简介：WOMBO Dream是一个能够将你的想法转化为现实画面的AI绘画应用，只需简单描述你的想法即可。
▷适用场合：适合那些喜欢天马行空的想象，需要将创意视觉化的人，无论是艺术创作还是日常娱乐。
▷功能优势：它的创作不受限制，能够根据文字描述生成各种奇特和富有想象力的画面。
好啦，现在知道ai绘画图片该用什么软件了吧？艺术创作的大门已经向更广泛的群体敞开，它让那些缺乏专业训练的人能够享受到绘画的乐趣，更推动了艺术的创新和发展。
让我们在虚拟与现实的交融中，一起探索艺术的新境界，共同见证艺术创作的新时代。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12a3aa8e570e68aaa6a39ddb7cbaaecb/" rel="bookmark">
			BoostCompass( http_server 模块 | 项目前端代码 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读导航 一、模块概述二、编写http_server 模块✅cpp-httplib库的安装1. 详细代码2. 编写思路 三、项目前端代码✅index.html⭕应用效果 一、模块概述 这个模块是一个基于C++的简单搜索引擎服务程序，我们整合了HTTP服务器和搜索功能。我们首先初始化一个搜索器对象，使用预先处理好的文档数据（来自第一个模块）来建立索引。然后，我们设置了一个HTTP服务器，并为服务器定义了一个GET请求的处理函数，该函数响应客户端对"/s"路径的访问。
当客户端发送包含搜索关键字的请求时，服务器会验证请求中是否包含关键字参数。如果没有关键字，服务器会返回错误信息。如果有关键字，服务器将调用搜索器的搜索方法，传入关键字，并获取搜索结果，这些结果被封装为JSON字符串返回给客户端。
二、编写http_server 模块 ✅cpp-httplib库的安装 我们要先在Linux机器上安装cpp-httplib库相关介绍文章链接：🔴C++ HTTP 库 cpp-httplib 使用
🚨注意：cpp-httplib库在使用的时候需要使用较新版本的gcc
1. 详细代码 // 引入所需的头文件 #include "httplib.hpp" #include "searcher.hpp" // 定义输入文件的路径和Web服务器的根目录 const std::string input = "data/raw_html/raw.txt"; const std::string root_path = "./wwwroot"; // 主函数，程序的入口点 int main() { // 创建Searcher类的实例并初始化 ns_searcher::Searcher search; search.InitSearcher(input); // 创建httplib::Server类的实例，用于处理HTTP请求 httplib::Server svr; // 设置服务器的根目录为root_path svr.set_base_dir(root_path.c_str()); // 为服务器添加一个GET请求的处理函数 svr.Get("/s", [&amp;search](const httplib::Request &amp;req, httplib::Response &amp;rsp) { // 检查请求中是否包含搜索关键字参数"word" if (!req.has_param("word")) { // 如果没有搜索关键字，返回错误信息 rsp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12a3aa8e570e68aaa6a39ddb7cbaaecb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbf9d2729632a68ae55f56eeb5fd4451/" rel="bookmark">
			使用 VMWare 安装 Android-x86 系统（小白版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 VMWare 介绍Android 系统介绍概述最终效果前置步骤开始安装 VMWare 介绍 VMware Workstation是VMware公司开发的一款桌面虚拟化软件。它允许用户在一台物理计算机上同时运行多个操作系统，每个操作系统都在自己的虚拟机中运行。这使得用户可以在同一台计算机上同时测试不同的操作系统、应用程序和配置，而无需在物理计算机之间进行重启或分区。
VMware Workstation提供了一套丰富的功能，包括：
虚拟机快照：可以在运行时捕捉和还原虚拟机的状态，使用户可以轻松回滚到之前的状态。虚拟网络：用户可以自定义虚拟网络配置，创建复杂的网络拓扑，以便测试和开发各种网络应用。接口友好的用户界面：用户界面简单直观，使用户可以轻松创建、启动和管理虚拟机。虚拟机克隆和部署：可以快速复制和部署虚拟机，节省配置时间。共享虚拟机：可以将虚拟机打包成一个文件，与其他用户共享，便于协作和测试。 VMware Workstation支持多种操作系统，包括Windows，Linux和macOS。它适用于个人用户和企业用户，可以用于软件开发、测试、培训和演示等场景。通过使用VMware Workstation，用户可以提高开发和测试的效率，节省硬件成本，并提供更好的虚拟化体验。
Android 系统介绍 Android是一种基于Linux内核的开放源代码移动操作系统，由Google开发。它被广泛用于智能手机、平板电脑、电视、汽车和其他可穿戴设备等各种移动设备上。
Android系统具有以下特点：
开放源代码：Android系统是开放源代码的，这意味着任何开发者都可以访问、修改和定制系统的源代码。这也促进了开发者社区的发展和创新。
多设备支持：Android系统可以在各种设备上运行，包括智能手机、平板电脑、智能电视、汽车娱乐系统等。这使得它成为一个全面的移动操作系统。
应用生态系统：Android系统拥有庞大的应用生态系统，用户可以从Google Play商店下载和安装各种应用程序。开发者可以轻松地开发和发布应用程序，从而为用户提供丰富的功能和体验。
定制性和灵活性：Android系统允许用户和手机制造商进行高度的定制和个性化。用户可以根据自己的喜好和需求进行界面、主题和功能的定制。
强大的通知系统：Android系统拥有一个灵活而强大的通知系统，可以及时向用户提供各种通知和消息，用户可以在通知面板中查看和管理。
多任务处理：Android系统支持多任务处理，用户可以同时运行多个应用程序，并在应用之间进行切换。这使得用户可以更高效地完成多个任务。
总的来说，Android系统是功能强大、灵活性高的移动操作系统，为用户提供了丰富的应用程序和个性化定制选项。它的开放性和广泛支持使其成为市场上最受欢迎的移动操作系统之一。
概述 VMWare 软件版本：VMware® Workstation 17 Pro 17.0.0 build-20800274Android 系统版本：android-x86_64-7.1 最终效果 前置步骤 点击进入 Android-x86 官方网站点击下载 Android-x86 系统镜像点击下载 VMware 17 Pro点击下载 VMware 17 Pro 激活码 开始安装 打开 VMWare 软件点击新建虚拟机，配置选择选择典型，点击下一步
勾选安装程序光盘映像文件，浏览选择下载的 Android 镜像，点击下一步
客户机操作系统勾选 Linux，版本选择其他Linux 4.x 内核64位（客户机操作系统选择其他应该也没有问题）
自定义虚拟机的名称，点击下一步
根据需求选择虚拟机大小与存储方式，磁盘大小建议不低于系统建议大小；点击下一步
点击完成
点击完成后开启虚拟机
虚拟机开启后出现改页面选择 Installation - Install Android-x86 to harddisk，将系统安装到硬盘上，将鼠标定位到系统中，通过键盘 ↑ ↓ 键选择。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbf9d2729632a68ae55f56eeb5fd4451/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/605f863b72f385826dcc8dd88af841a8/" rel="bookmark">
			Hadoop知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hadoop是什么呢？
Hadoop是一个由Apache基金会所开发的分布式系统基础架构，它允许用户在不需要深入了解分布式底层细节的情况下，开发分布式程序，并充分利用集群的威力进行高速运算和存储。Hadoop的核心设计主要包括分布式文件系统（HDFS）和MapReduce编程模型。
HDFS是Hadoop的分布式文件系统，具有高容错性，并设计用来部署在低廉的硬件上。它提供高吞吐量来访问应用程序的数据，特别适合处理超大数据集。HDFS放宽了POSIX的要求，能以流的形式访问文件系统中的数据。
MapReduce是Hadoop的编程模型，它使得分布式计算变得简单和高效。开发人员只需编写Map函数和Reduce函数，Hadoop就能自动在集群中并行执行任务，处理大规模数据集。
Hadoop的主要特点包括可靠性、可扩展性、高性能、易用性、开源性和支持多种数据类型。其数据可靠性和可扩展性是传统文件系统无法比拟的，因此被许多大型企业和组织用于大数据存储和处理。
此外，Hadoop还广泛应用于数据处理和分析、数据挖掘和机器学习、日志分析、图像和音频处理等领域。例如，企业可以使用Hadoop的MapReduce框架处理和分析数据，发现数据中的模式和趋势，从而作出更好的业务决策；还可以使用Hadoop的机器学习库Mahout在大规模数据集上训练机器学习模型，进行客户行为分析、欺诈识别或风险评估等任务。
然而，随着技术的不断进步和业务需求的日益复杂，Hadoop也面临着新的挑战和机遇。为了满足日益增长的实时数据处理需求，Hadoop社区已经推出了一系列相关项目，如Apache Flink和Apache Spark，以弥补Hadoop在实时性方面的不足。
总的来说，Hadoop是一个功能强大且灵活的大数据处理框架，它正在不断地发展和完善，以适应日益复杂的数据处理需求。
1.Hadoop集群的搭建和配置 要完成Hadoop集群的搭建和配置首先要在个人计算机上安装配置虚拟机，然后在虚拟机中搭建Hadoop完全分布式集群。
个人计算机硬件的最低配置建议Hadoop相关软件安装包及其版本说明：
软 件版 本安 装 包 名 称备注Linux OSCentOS 7.8CentOS-7-x86_64-DVD-2003.iso64位JDK1.8+jdk-8u281-linux-x64.rpm64位VMware15VMware-workstation-full-15.5.7-17171714.exe虚拟机软件Hadoop3.1.4hadoop-3.1.4.tar.gz已编译好的安装包IDEA2018.3.6ideaIC-2018.3.6.exe64位SH连接工具5Xme5.exe远程连接虚拟机 Hadoop完全分布式集群是主从架构，一般需要使用多台服务器组建。
我们可以通过课程或者网络上的教程来创建虚拟机，然后再设置固定IP，然后用Xmanager（Xmanager是应用于Windows系统的Xserver服务器软件，通过Xmanager用户可以将远程的Linux桌面无缝导入至Windows系统中）远程连接虚拟机，配置本地YUM源及安装常用软件，在Linux虚拟机下安装Java，修改配置文件。
克隆虚拟机：在虚拟机master上配置完成Hadoop集群相关配置后，将虚拟机master克隆，生成3个新的虚拟机slave1、slave2、slave3，在虚拟机master的安装目录“E:\Vmware”下建立3个文件slave1、slave2、slave3。在master、slave1、slave2、slave3中配置SSH免密码登录，进行Hadoop集群配置时间同步服务。
启动关闭集群：完成Hadoop的所有配置后，即可执行格式化NameNode操作，该操作会在NameNode所在机器节点中初始化一些HDFS的相关配置，并且该操作在集群搭建过程中只需执行一次，执行格式化之前可以先配置环境变量，配置环境变量是在master、slave1、slave2、slave3节点上修改/etc/profile文件，文件修改完保存退出，使用“source /etc/profile”命令使配置生效。
监控集群：Hadoop集群有相关的服务监控端口
服务Web接口默认端口NameNodehttp://namenode_host:port/9870ResourceManagerhttp://resourcemanager_host:port/8088MapReduce JobHistoryServehttp://jobhistoryserver_host:port/19888 （1）查看HDFS文件信息
依次选择“Utilities”→“Browse the file system”命令可以查看HDFS上的文件信息。
（2） YARN监控
在浏览器的地址栏中输入“http://master:8088”网址，即可看到YARN的监控界面。
（3）日志监控
在浏览器的地址栏中输入“http://master:19888 ”地址，即可看到Hadoop的日志监控界面。
2.HDFS分布式文件系统 查看、解除与开启Hadoop安全模式 1. 查看安全模式 当启动Hadoop集群时，首先会进入安全模式，主要是为了检查系统中DataNode节点上的数据块数量和有效性。在Linux系统上启动Hadoop集群，启动完成后可以在本机的浏览器输入“http://master:9870”网址，查看HDFS的监控服务。
2. 解除和开启安全模式 当启动Hadoop集群时集群会开启安全模式，原因是DataNode的数据块数没有达到总块数的阈值。如果没有先关闭Hadoop集群时，而直接关闭了虚拟机，那么Hadoop集群也会进入安全模式，保护系统。当再次开启Hadoop集群时，系统会一直处于安全模式不会自动解除，这时使用“hdfs dfsadmin -safemode leave”令可以解除安全模式。
查看Hadoop集群的基本信息 查询集群的存储系统信息 当HDFS文件系统完成启动时，在服务器集群上也将启动相关的监控服务。通过这些监控服务，即可查询到大量相与HDFS文件系统相关的信息。HDFS的监控服务默认是通过NameNode节点的9870端口进行访问。 在本机浏览器的地址栏输入“http://master:9870”网址，查看当前HDFS文件系统的基本统计信息。
继续单击页面中的“Datanodes”标签栏，可以显示出各数据节点的信息。在图中显示了组成HDFS的3个Datanode节点的状态与各自的存储使用情况。在HDFS中，数据是被分块进行存储的，每个数据块默认有3个副本，即每个数据节点上存储一份数据副本，因此各节点的存储用量是大致相等的。
Hadoop也提供了命令行查询HDFS文件系统资源信息的方式，即hdfs dfsadmin -report命令，该命令的基本语法格式如下。
hdfs dfsadmin -report [-live] [-dead] [-decommissioning] 查询集群的计算资源信息 Hadoop集群的计算资源，是由YARN资源管理器的ResourceManager进行管理的。通过ResourceManager的监控服务，可以方便地查询目前集群上的计算资源信息。 在本机浏览器的地址栏输入“http://master:8088/cluster/nodes”网址，查看当前集群的计算资源信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cb7079fef5320bdbc4dd0b7df892baf/" rel="bookmark">
			前端实现Excel文件导出功能的完整指南（vue实现excel文件导出功能）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介：在许多Web应用程序中，导出数据到Excel文件是一项常见的需求。本文将介绍如何通过前端代码实现Excel文件的导出功能，以及如何优化和扩展这一功能，以满足不同场景下的需求。这里来记录一下 一. 技术背景 在许多业务场景中，用户需要将网页上的数据导出到Excel文件中进行进一步处理或分享。通过前端实现Excel文件的导出功能，可以提高用户体验并简化数据交互流程。
二. 实现原理 我们将通过以下步骤实现前端Excel文件导出功能：
发起异步请求获取需要导出的数据。将数据转换成Blob对象，设置文件类型为application/msword。创建下载链接，并设置链接的href属性为Blob对象的URL。添加链接到页面并模拟点击，触发文件下载。释放Blob对象所占用的内存并移除下载链接。 三. 代码解析 代码主要包括以下几部分，这里的场景需要请求后端接口（多看注释）：
// 导出Excel文件的函数 exportAllExcel().then((res) =&gt; { // 创建一个a标签元素 const link = document.createElement("a"); // 创建一个Blob对象，用于存储Excel文件的数据，设置文件类型为application/msword const blob = new Blob([res], { type: "application/msword" }); // 将a标签设置为不可见 link.style.display = "none"; // 通过URL.createObjectURL方法创建一个下载链接 const url = window.URL.createObjectURL(blob); // 将链接设置为a标签的href属性 link.href = url; // 设置下载文件的名称 link.setAttribute("download", "数据文件.xlsx"); // 将a标签添加到页面的body中 document.body.appendChild(link); // 触发点击事件，开始下载文件 link.click(); // 释放Blob对象所占用的内存 window.URL.revokeObjectURL(url); // 将a标签从页面中移除 document.body.removeChild(link); }); 四. 实际应用 这段代码可以广泛应用于各种Web应用程序中，例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cb7079fef5320bdbc4dd0b7df892baf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d784f6d2dec1698850fe78ce9e71c0d3/" rel="bookmark">
			2024 前端高频面试题之 Vue 篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue 篇（持续更新中） 1、v-for 和 v-if 可以混合使用吗？为什么？2、v-for 中为什么加 key？3、事件默认有个 event 参数，它是什么？怎么使用？事件被绑定到哪里？4、vue 父子组件如何通讯？5、父子组件声明周期调用顺序？6、vue 双向绑定原理（响应式原理）？7、$nextTick 是什么？为什么优先解决微任务？8、vuex 是什么？为什么使用？9、keep-alive 是什么？怎么实现的？生命周期？首次加载是先执行 activated 还是 deactivated，为什么？10、vue2 和 vue3 的区别？11、history 和 hash 路由实现原理？区别是什么？12、请说出常用的设计模式？（5 种以上）并举例实际项目中的使用场景。13、$emit 和 $on 的本质？14、虚拟 dom 是什么？原理？优缺点？15、mixin 是什么？优缺点？原理？vue3 用什么取代了？16、自定义指令？原理？17、事件绑定原理？18、$set 的原理？19、Vue3 比 Vue2 有什么优势？20、Vue3 声明周期21、Composition API 和 Options API22、如何理解 ref、toRef 和 toRefs23、为何 ref 需要 value 属性？24、Vue3 升级了哪些重要的功能？ 1、v-for 和 v-if 可以混合使用吗？为什么？ 可以，但是尽量不要同时使用，v-for计算优先级比v-if高，首先会把虚拟节点渲染出来，然后再进行v-if判断。降低渲染性能
2、v-for 中为什么加 key？ 如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 算法可以更准确、更快速
更准确：因为带 key 就不是就地复用了，在 sameNode 函数 a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d784f6d2dec1698850fe78ce9e71c0d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e923e9638927971effba37d1a4e1951/" rel="bookmark">
			【数据结构与算法】：关于时间复杂度与空间复杂度的计算（C/C&#43;&#43;篇）——含Leetcode刷题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、什么是时间复杂度和空间复杂度？1.1 算法效率1.2 时间复杂度的概念1.3 空间复杂度的概念1.4 复杂度计算在算法中的意义 二、时间复杂度的计算2.1 大O渐进表示法2.2 常见时间复杂度计算举例 三、空间复杂度的计算四、Leetcode刷题1. 消失的数2. 旋转数组 一、什么是时间复杂度和空间复杂度？ 1.1 算法效率 算法效率分析分为两种：第一种是时间效率，第二种是空间效率。时间效率被称为时间复杂度，而空间效率被称作空间复杂度。 时间复杂度主要衡量的是一个算法的运行速度，而空间复杂度主要衡量一个算法所需要的额外空间，在计算机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。所以我们如今已经不需要再特别关注一个算法的空间复杂度。
1.2 时间复杂度的概念 时间复杂度的定义：在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。一个算法执行所耗费的时间，从理论上说，是不能算出来的，只有在电脑上跑起来之后才知道，而且根据电脑硬件配置的不同，同一个程序跑的效率可能是不一样的，所以时间复杂度不是计算一个程序跑的时间长短。而是一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度，时间复杂度通常用大O渐进表示法。
1.3 空间复杂度的概念 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度 。空间复杂度不是程序占用了多少bytes的空间，因为这个也没太大意义，所以空间复杂度算的是变量的个数。空间复杂度计算规则基本跟时间复杂度类似，也使用大O渐进表示法。
1.4 复杂度计算在算法中的意义 一张图告诉你复杂度计算的意义：
二、时间复杂度的计算 2.1 大O渐进表示法 // 请计算一下Func1基本操作执行了多少次？ void Func1(int N) { int count = 0; for (int i = 0; i &lt; N ; ++ i) { for (int j = 0; j &lt; N ; ++ j) { ++count; } } for (int k = 0; k &lt; 2 * N ; ++ k) { ++count; } int M = 10; while (M--) { ++count; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e923e9638927971effba37d1a4e1951/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19a4bbdd32db101b0b1770feadbd8f03/" rel="bookmark">
			SpringBoot之JWT令牌校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot之JWT令牌校验 本文根据黑马b站springboot3+vue3课程
JWT （JSON Web Token）是一种开放标准（RFC 7519），用于在不同实体之间安全地传输信息。它由三个部分组成：头部（Header）、载荷（Payload）和签名（Signature）。
头部（Header）：头部通常由两部分组成，标识token的类型和所使用的签名算法，例如： { "alg": "HS256", "typ": "JWT" } 这表示该JWT使用HS256算法进行签名，并且是一个JWT类型的token。
载荷（Payload）：载荷是JWT的第二部分，也称为Claim。它包含了要传输的数据，可以是用户的身份信息、权限信息等。载荷分为三个部分：
注册声明（Registered Claims）：这些是预定义的声明，包含了一些标准的信息，如iss（签发者）、sub（主题）、aud（接收者）、exp（过期时间）、nbf（生效时间）、iat（签发时间）等。公共声明（Public Claims）：这些是自定义的声明，用于传递一些非强制性的信息，例如用户的角色、权限等。私有声明（Private Claims）：这些也是自定义的声明，用于在JWT的发送和接收方之间共享信息，但它们不是JWT规范的一部分，只是双方之间协商的私有信息。 签名（Signature）：签名是JWT的第三部分，用于验证消息的完整性和来源。它由使用私钥对头部和载荷进行签名的结果组成，以确保数据在传输过程中没有被篡改。
JWT通常用于身份验证和信息交换。例如，在 Web 应用程序中，当用户成功登录后，服务器会生成一个JWT并将其发送回客户端，客户端将JWT存储起来，并在后续的请求中将其发送给服务器进行身份验证。服务器收到JWT后，会验证其签名和有效期，并根据载荷中的信息来决定是否授权用户访问特定的资源。
如果输入正确的账号密码在本机访问如下
public class JwtTest { @Test public void testGen() { Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;(); claims.put("id", 1); claims.put("username", "张三"); //生成jwt的代码 String token = JWT.create() .withClaim("user", claims)//添加载荷 .withExpiresAt(new Date(System.currentTimeMillis() + 1000*60*60))//添加过期时间 .sign(Algorithm.HMAC256("itheima"));//指定算法,配置秘钥 System.out.println(token); } 创建步骤 创建Payload（载荷）：将需要在JWT中传输的信息组织成一个键值对的形式。Payload可以包含任何您希望传递的信息，例如用户ID、用户名等。在您的示例中，您创建了一个包含用户ID和用户名的Map作为Payload。
设置过期时间：为了增加安全性，通常会设置JWT的过期时间。过期时间可以是一个具体的日期时间，也可以是一个相对于当前时间的时间段。在您的示例中，您通过withExpiresAt方法设置了JWT的过期时间为当前时间后的一小时。
选择签名算法并配置密钥：JWT需要使用密钥对其进行签名，以确保其完整性和安全性。在您的示例中，您选择了HMAC256算法，并通过sign方法传入了密钥"itheima"。
生成JWT：使用以上设置，调用相应的JWT库方法来生成JWT。在您的示例中，您调用了JWT.create().withClaim().withExpiresAt().sign()方法来生成JWT。
获取生成的JWT：生成JWT后，您可以将其打印输出或将其传递给需要使用JWT的其他部分。
总的来说，JWT生成的过程就是根据需要传递的信息创建Payload，设置过期时间，选择签名算法并配置密钥，然后生成JWT。完成这些步骤后，您就可以使用生成的JWT进行身份验证或在网络请求中传递用户信息等。
@Test public void testParse() { //定义字符串,模拟用户传递过来的token String token = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19a4bbdd32db101b0b1770feadbd8f03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/004e85839ca8374513d67c831a8a6cf3/" rel="bookmark">
			Mac系统下Jmeter的下载、安装、及环境变量配置_jmeter mac
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先自我介绍一下，小编浙江大学毕业，去过华为、字节跳动等大厂，目前阿里P7
深知大多数程序员，想要提升技能，往往是自己摸索成长，但自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年最新Golang全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，涵盖了95%以上Go语言开发知识点，真正体系化！
由于文件比较多，这里只是将部分目录截图出来，全套包含大厂面经、学习笔记、源码讲义、实战项目、大纲路线、讲解视频，并且后续会持续更新
如果你需要这些资料，可以添加V获取：vip1024b （备注go）
正文 1、jdk下载官网：https://www.oracle.com/java/technologies/downloads/#java8
下载好的安装包，直接双击安装就好了。
2、查看是否已经配置好了jdk环境变量
在终端输入命令 echo $JAVA_HOME echo $PATH echo $CLASSPATH 查看是否配置java环境变量
3、查看jdk安装的位置
在终端中输入命令：/usr/libexec/java_home -V
就可获取当前你的jdk安装的位置，拷贝该路径，去配置环境变量。
4、怎么在Mac中配置jdk环境变量
（1）首先在终端中输入：open .bash_profile
输入：
export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_291.jdk/Contents/Home
（2）保存，终端执行:source .bash_profile
（3）在终端中输入：java 或javac 或 java --version 能正常输出内容就证明你的jdk环境变量配置好了。
5、补充：为什么要配置环境变量
配置了环境变量之后，我们可以在任意目录下去使用jdk，或执行相关的命令，而不用每次在切换到jdk的安装目录下再去执行。
java_home 指向jdk的安装目录；path 指定命令搜索路径，设置好path后就可以在任意路径下执行javac或java等工具；classpath 指定类的搜索路径
6、path和classpath的区别
在安装JDK时需要添加环境变量，经常使用的环境变量有两个：
PATH与CLASSPATH
下面总结一下环境变量的作用。
PATH是系统用来指定可执行文件的完整路径。当在CMD中执行命令时，如果执行的可执行文件不在当前目录下，那么系统就会依次搜索PATH中设置的路径。如果在PATH中设置了JDK的安装目录：（如在PATH中添加如下的路径——D:\Program Files\Java\jdk1.8.0\bin;D:\ProgramFiles\Java\jdk1.8.0\jre\bin;），
那么就可以在CMD中直接使用java、javac等命令，而不必在CMD中切换到JDK的安装目录下运行该命令。
CLASSPATH是指定程序中所使用的类文件所在的位置。CLASSPATH环境变量中点(“.”)的含义是：在当前路径下搜索Java类。如果编译器按照CLASSPATH指定的路径找不到所需要的类，则会提示“*类找不到”这样的错误。 classpath环境变量不属于windows操作系统，是java编程语言当中的一个机制，这种机制是专门为类加载器加载class文件时提供路径依据的。
用户变量只对当前用户有效；系统变量对所有用户有效。对于当前用户而言，设置用户变量与系统变量的效果大致相同，只是系统变量的路径排在用户变量的路径之前。
四、Jmeter官网下载地址 https://jmeter.apache.org/download_jmeter.cgi
1、下载
在Apache Jmeter官网下载release包，注：Binaries表示编译好的二进制压缩包，是已经编译好的。而source表示源码压缩包，下载后是需要编译的，故下载Binaries即可。
Mac电脑选择.下载Binaries栏第一个文件，tgz的压缩包
2、下载完成后，直接双击解压即可，打开目录，可以看到以下目录文件
3、进入bin目录，在终端输入 sh jmeter，启动jmeter
注意：Don’t use GUI mode for load testing：这是一段提示信息，不要使用GUI模式进行负载测试，要使用NON GUI模式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/004e85839ca8374513d67c831a8a6cf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a84818d3521cfc2a5a37d379a3f6d805/" rel="bookmark">
			Qt报错dependent ‘..\..\..\..\..\..\Qt\5.14.2\msvc2017\include\QtWidgets\QMainWindow‘ does not exist
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 QtCreator使用cmake创建工程运行正常，但是qmake创建widget工程一直报错，说找不到qt库的目录，如下所示：
:-1: error: dependent '..\..\..\..\..\..\Qt\5.14.2\msvc2017\include\QtWidgets\QMainWindow' does not exist. 网上搜了下内容乱七八糟的，后面看了qt的官方论坛，发现在pro中添加如下内容生效：
QMAKE_PROJECT_DEPTH = 0 解释说这个语法将使makefile包含绝对路径。
参考 Dependent (that clearly exists) does not exist error when building Qt Creator project 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1800a24e4ee85c215c2ba80b03584dca/" rel="bookmark">
			ZooKeeper中节点的操作命令（查看、创建、删除节点）_zookeeper 删除 节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先自我介绍一下，小编浙江大学毕业，去过华为、字节跳动等大厂，目前阿里P7
深知大多数程序员，想要提升技能，往往是自己摸索成长，但自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年最新大数据全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，涵盖了95%以上大数据知识点，真正体系化！
由于文件比较多，这里只是将部分目录截图出来，全套包含大厂面经、学习笔记、源码讲义、实战项目、大纲路线、讲解视频，并且后续会持续更新
如果你需要这些资料，可以添加V获取：vip204888 （备注大数据）
正文 dataVersion = 0
表示当前节点的变化号，0表示未被修改过
aclVersion = 0
表示访问控制列表的变化号，access control list
ephemeralOwner = 0x0
表示如果临时节点，表示当前节点的拥有者的sessionId
dataLength = 0
表示数据长度
numChildren = 1
表示子节点的数量
2.3 查看根节点的名称 ls -w / 2.4 查看根节点的所有节点及子节点 ls -R / 3. get获取节点信息 语法：
get [-s] [-w] path 如获取根节点信息
get -s / 4. create创建节点 语法：
create 节点名称 节点内容 创建节点，如果节点内容含有空格则需要将其用双引号括起来
如创建名为a1的节点，内容为a
create /a1 a 然后获取子节点a1的信息，看到数据长度dataLength为a的长度1
创建子节点a2内容为aa bb cc，加双引号""，不加会报错
create /a2 "aa bb cc"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1800a24e4ee85c215c2ba80b03584dca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/988f351a1c14f7cbbf4833dae48bad2f/" rel="bookmark">
			【Stable Diffusion】最新换脸模型：IP-Adapter Face ID Plus V2 WebUI 效果超赞！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ControlNet 是 Stable Diffusion Web UI 中功能最强大的插件。基于 ControlNet 的各种控制类型让 Stable Diffusion 成为 AI 绘图工具中最可控的一种。
IP Adapter 就是其中的一种非常有用的控制类型。它不仅能够实现像 Midjourney 一样的“垫图”功能，还能用来给肖像人物换脸。
IP Adapter 的很多老的模型都可以用来换脸，如 Plus Face。然而，IP Adapter 不断推出了更新的模型，持续为我们带来惊喜。通过我的亲身测试，我发现新的 Face ID Plus V2 模型在换脸效果上远胜以往。
我尝试将好莱坞女星 Angelina Jolie 的脸部特征融合到了由 Midjourney 生成的多个图片中，包括一名中世纪女战士、一幅文艺复兴时期的美女肖像，以及一位女王的形象，效果都非常令人满意。
怎么样？效果还不错吧？接下来我来介绍如何在 Web UI 中安装并使用这个模型。
准备工作 我们主要利用 Control Net 中的 IP Adapter 来进行换脸，同时使用 OpenPose 保持原图人物的头部姿势。
相对于 Control Net 的其他控制类型，IP Adapter 是后来才有的。如果你的 Control Net 版本较旧，可能需要更新以支持 IP Adapter 功能。
我们需要下载以下内容：
Open Pose 模型IP-Adapter FaceID Plus V2 模型和 Lora 其中 IP Adapter 用来换脸，Open Pose 用来保持住原图人物的头部姿势。Lora 可以提升面部 ID 的一致性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/988f351a1c14f7cbbf4833dae48bad2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ddd0f39e3a5c141c9b08ecd60cef6ed/" rel="bookmark">
			StarRocks实战——多点大数据数仓构建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、背景介绍
二、原有架构的痛点
2.1 技术成本
2.2 开发成本
2.2.1 离线 T+1 更新的分析场景
2.2.2 实时更新分析场景
2.2.3 固定维度分析场景
2.2.4 运维成本
三、选择StarRocks的原因
3.1 引擎收敛
3.2 “大宽表”模型替换
3.3 简化Lambda架构
3.4 模型持续迭代
3.5 明细、汇总一体化
3.6 外表能力
3.7 单表聚合查询
3.8 多表关联查询
3.9 实时更新读写查询
四、实践经验
4.1 集群拆分
4.2 按照数据更新频率进行拆分
4.3 按照业务域进行拆分
4.4 调优手段
4.4.1 优化表结构定义
1）模型选择
2）分区和分桶 3）稀疏索引、bloomfilter、Bitmap Index
4）物化视图
5）使用BITMAP / HyperLogLog 数据类型进行去重
4.4.2 优化查询SQL
1）Broadcast Join
2）Colocation Join
3）并行度调整
4）CBO 优化器
4.5 工具集成
4.5.1 数据集成
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ddd0f39e3a5c141c9b08ecd60cef6ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c569bd84a2098fab45b4064507055d16/" rel="bookmark">
			【大数据】分布式文件系统HDFS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.什么是分布式文件系统
2.HDFS的特点
3.HDFS的核心概念
4.HDFS的体系结构
5.HDFS的配置建议
6.HDFS的局限性
7.HDFS的存储机制
7.1.数据冗余机制
7.2.错误与恢复
8.HDFS数据读写过程
1.什么是分布式文件系统 分布式文件系统是整个大数据技术的基础，是大数据技术栈的核心组件，其解决了海量数据的管理问题，可以说没有分布式文件系统就没有大数据技术。分布式文件系统是起源于Google，Google的分布式文件系统GFS奠定了分布式文件系统的设计思想，市面上目前所有的分布式文件系统都是参照GFS来设计实现的，包括HDFS也是。之前作者有一篇文章专门聊过GFS其中有分布式文件系统的来龙去脉，有兴趣可以移步：
【GFS】大数据技术的基石，分布式文件系统的鼻祖-CSDN博客
2.HDFS的特点 HDFS有以下特点：
能用廉价的设备来搞定
实现流数据读写（因为跑计算任务的时候，往往需要一次性把全部或者绝大多数数据读完，而不是只读一部分，所以HDFS实现了数据的顺序读写，从而实现了流数据读写）
支持各种量级的数据
只支持简单的数据操作，即只支持顺序读写、追加。不支持进行修改！
跨平台，因为是用JAVA开发的
HDFS存在的局限性：
不适合低延迟的数据访问，因为是顺序写入的，要读某一条具体的数据需要先顺序读出之前的数据。
无法高效存储大量小文件
不支持修改文件
3.HDFS的核心概念 块：
一个块默认64MB，其大小可以调整，但是不能调的过大，因为块过大后执行计算任务时计算引擎的并行性就没意义了，因为文件根本就没被分成几块，没被怎么分散的进行存储，可能就一两个子任务去跑一两个块去了，根本就并行计算不起来。
当客户端完成所有数据写入后，会通知NameNode所有的数据块都已经成功写入DataNode，并完成文件关闭操作，也就是说在逻辑上HDFS中一个块中存放的一定是一个文件，不可能一个块儿中存放着来自两个文件的内容。
名称节点和数据节点：
名称节点上面负责维护整个集群中块儿的详细信息，块儿被存在哪儿？各自的顺序是什么？节点的状态和信息等内容。
数据节点什么负责进行具体的数据存储。
名称节点中记录的最核心的两大块内容：
FsImage，以树型的方式来记录整个集群中的文件相关信息，树上的每个节点包含文件的复制等级、修改和访问时间、访问权限、块大小以及组成文件的块。要注意，这颗树里面不包含哪些块存储在哪颗树上的这种对应关系。这种映射关系存放在内存中的另一种数据结构中的。
editLog，对文件的操作记录。
这两个东西拿来做什么喃？
HDFS中去名称节点上拿块儿所在位置的时候，先通过FsImage来定位文件由哪些块儿组成，然后再去找块儿和数据节点的对应关系，FsImage的存在加速了在NameNode上检索文件块位置的过程。FsImage当然是不能频繁更新的，因为其一定是要保持强一致性的，一旦进行更新，更新期间就会对外拒绝服务，影响系统的可用性。所以就需要editLog来记录集群中文件的操作，为了避免过大的EditLog对NameNode性能的影响，会有定期checkpoint（检查点）操作，将EditLog的部分内容合并到FsImage中，以此来减小EditLog的大小并刷新FsImage。
换句话说HDFS选择了最终一致性，而没有选择强一致性。
这会存在一个问题：万一在最终一致性发生之前，我要访问的文件有操作记录未被记录入FsImage中而是只存在于editLog中时怎么办？这种操作记录可能是这个文件就是新存入集群的，或者这个文件被删除了。
HDFS用了一种补偿机制来解决这种问题，首先我要访问的文件大概率是存在FsImage中的，在editlog中还没合过去只是小概率事件。所以HDFS会现在FsImage中找文件存在哪些块中，如果FsImage中没有，再去editLog中找有没有，这样就不会出现漏网之鱼。就是说当我们访问一个文件时一定是要走FsImage以及editLog的，要两份文件合起来才能确定文件的最终状态，只是说小概率会出现我们要访问的文件操作在editLog中，但是不在FsImage中对吧，所以其实没必要发现这种情况就立即进行合并，而是仍然可以在固定的时间再进行合并。
第二名称节点：
在早期版本的Hadoop中存在一个第二名称节点，在Hadoop 2.x及更高版本中，第二名称节点的功能已经被更加完善的组件取代。
第二名称节点是对名称节点的一个冷备，之所以说是冷备，是因为其并不同步名称节点的内存状态，也就是说并没有完整的元数据，其只负责定期从主NameNode下载FsImage和EditLog文件，合并FsImage和EditLog中的最新变更，然后将新的FsImage文件上传回主NameNode，以此来帮助主NameNode减少合并FsImage和EditLog所需的时间，减轻主NameNode的压力，防止EditLog过大，进而优化系统性能和稳定性。
元数据：
元数据的核心组成部分包括：
文件和目录的元数据：包括文件和目录的名称、路径、权限、所有权、创建时间、修改时间等基本属性信息。
块信息：不在fsimage上，而是在内存中，包括每个文件被切分成的块的数据块ID、块的大小以及块的副本数量等信息，以及每个数据块的所有副本在哪些DataNode上的映射关系，即块到节点的映射关系。
命名空间管理：维护整个文件系统的目录结构，即文件和目录的层级关系。
FsImage 和 EditLog 则是用于持久化和管理这些元数据的两种关键机制。
4.HDFS的体系结构 5.HDFS的配置建议 DataNode用来存数据和跑计算任务，因此其需要一定扽内存用来跑任务和大量的硬盘存储来存放数据，一般企业级应用建议DataNode的配置为：
NameNode用来存元数据，元数据是经常要用到的，所以存在内存中，所以NameNode的内存要够大，一般企业应用建议NameNode的配置为：
secondNameNode的配置和NameNode对齐。
6.HDFS的局限性 因为名称节点的元数据都是保存在内存中的，因此，名称节点能容纳的块的个数是有上限的。
集群的吞吐量受名称节点的吞吐量限制。
隔离问题，集群中只有一个名称节点，一个命名空间，无法对不同应用进行隔离。
容错性不高，因为名称节点是单点的，一旦故障，集群就崩了。
以上局限性完整存在于1.0版本中，2.0版本已经优化掉了一些。
7.HDFS的存储机制 7.1.数据冗余机制 因为是用廉价机器搭建起来的，出故障是常态，所以需要数据冗余机制来存储数据。HDFS中采用副本机制来进行冗余，默认副本数量为3个。
数据块进集群来，先复制成三个副本，副本一会被放在最优节点（磁盘占用最少）的节点上，然后副本二、副本三被放到不同的节点上。
那么数据读取的时候会先读哪个喃？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c569bd84a2098fab45b4064507055d16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4971a174ec12a8b609a5b7325f4a57cd/" rel="bookmark">
			Stable Diffusion本地部署教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SEO元描述: 本教程将向您详细介绍如何在本地部署Stable Diffusion，以增强隐私、性能并控制您的AI生成艺术项目，包括必要的提示和最佳实践。
引言：Stable Diffusion简介 Stable Diffusion已经革新了数字艺术创作，使用户能够根据文本描述生成高质量图像。在本地部署这一工具可以显著提升您的控制和效率，提供更快的处理时间和无需依赖互联网连接的优势。本教程将指导您完成在本机设置Stable Diffusion的关键步骤。
部署前的基本要求 在开始设置之前，确保您的系统满足进行顺利部署所需的硬件和软件要求。
硬件要求 Stable Diffusion的效率在很大程度上取决于您的硬件，尤其是GPU。为了获得最佳性能，建议使用至少具有8GB VRAM的现代NVIDIA GPU。此外，至少具有8核心和16GB RAM的CPU将有助于高效管理任务。
软件先决条件 操作系统：Linux或Windows 10/11。Python：版本3.8或更新。Docker：如果您偏好容器化环境。 必要的依赖和库 您将需要几个Python库，如Torch、Transformers和PIL。安装Anaconda可以简化这些依赖的管理。
逐步安装指南 在本地部署Stable Diffusion涉及多个详细步骤，从设置您的环境到安装软件。
设置您的环境 使用Anaconda开始设置Python环境：
conda create --name stable-diffusion python=3.8 conda activate stable-diffusion 安装Stable Diffusion 您可以从预构建包安装Stable Diffusion，或从源代码编译：
pip install diffusers 验证安装 通过运行一个简单的测试脚本来生成图像，确保所有组件都正确安装。
配置和自定义 调整配置文件并自定义模型参数，以根据您的具体需求调整性能。
调整配置文件 根据您的硬件能力优化内存使用和处理速度，修改提供的配置文件。
自定义模型参数 尝试不同的参数，以影响生成图像的质量和风格。
在本地运行Stable Diffusion 一切设置完成后，您就可以开始生成图像了。
开始的基本命令 使用基本命令从文本提示生成图像：
python generate.py --prompt "未来城市天际线在日落时分" 生成您的第一批图像 尝试不同的提示把，探索Stable Diffusion的创造潜力。
本文由mdnice多平台发布
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de05c0d4c988c31fe1ca877d7db7f15b/" rel="bookmark">
			数据结构-----二叉排序树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1.什么是二叉排序树
2.如何构建二叉排序树
3.二叉排序树的操作
3.1定义节点储存方式
3.2插入节点操作
3.2创建二叉排序树
3.4遍历输出（中序遍历）
3.5数据查找操作
3.6获取最大值和最小值
3.7删除节点操作
3.8销毁二叉排序树
4.完整代码
前言 今天我们继续学习新的知识点----排序二叉树，在此之前我们学习了相关的排序算法，给你一个数组，然后对这个数组进行排序。那么同样的我们也可以去构建一个二叉排序树，在创建树的过程中进行排序，也能实现排序的效果，下面就一起来看看吧！
1.什么是二叉排序树 二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。是数据结构中的一类。在一般情况下，查询效率比链表结构要高。 给定一个二叉树，如果满足以下条件，那就是二叉排序树
若它的左子树不空，则左子树上所有结点的值均小于它根结点的值。若它的右子树不空，则右子树上所有结点的值均大于它根结点的值。它的左、右子树都满足为⼆叉排序树 二叉排序树最大的好处就是查找效率高，相较于链表一个一个去查找，二叉排序树可以去根据数据的排序规律来进行查找
二叉排序树图示：
2.如何构建二叉排序树 比如给定一个数组 [62,88,58,47,35,73,51,99,37,93] ，首先拿到第一个数字，以这个数字为根结点（标准），进行构建，如果比这个数字要大的就放到右子树，比这个要小的就放到左子树去，如下图所示：
这里我们可以看出，这些节点是一个一个去进行插入的，那我们就可以去通过递归插入的方式来创建，依次往下遍历，找到合适的位置再进行插入操作。
3.二叉排序树的操作 3.1定义节点储存方式 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; //二叉排序树节点存储方式 typedef int DataType; typedef struct binarytreenode { DataType data;	//数据域 struct binarytreenode* left;	//左指针 struct binarytreenode* right;	//右指针 }BTnode; 3.2插入节点操作 插入一个节点首先就要找到这个节点应该插入的位置，从跟节点开始，如果比跟节点小就往左，大就往右，直到叶子节点的位置进行插入操作。
代码实现： //插入数据 void Insert_node(BTnode** root, DataType data) { if (*root == NULL) { *root = (BTnode*)malloc(sizeof(BTnode)); if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de05c0d4c988c31fe1ca877d7db7f15b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb6a3c8704a899d160f020834a553e06/" rel="bookmark">
			华为ensp中nat server 公网访问内网服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者主页：点击！
ENSP专栏：点击！
创作时间：2024年4月15日17点30分
NAT服务器是一种在网络边界设备上配置的服务，它允许外部网络的用户访问内部网络中的服务或主机，同时隐藏了内部网络的真实IP地址。通过NAT服务器，内部网络中的服务或主机可以对外部网络提供服务，同时保护了内部网络的隐私和安全。
应用场景
NAT服务器通常用于以下场景：
提供对内部网络服务的访问：例如，内部网络中的Web服务器、邮件服务器或FTP服务器需要对外部网络提供服务，但内部网络使用的是私有IP地址，无法直接从外部网络访问。通过NAT服务器，外部网络用户可以使用公共IP地址和端口访问内部网络中的服务。
隐藏内部网络结构：通过NAT服务器，内部网络中的真实IP地址被隐藏起来，只暴露NAT服务器的公共IP地址。这样可以增强内部网络的安全性，防止攻击者直接访问内部网络中的主机。
节省公共IP地址资源：由于IPv4地址资源有限，使用NAT服务器可以在一定程度上节省公共IP地址资源，通过一个公共IP地址映射多个内部网络主机或服务。
NAT服务器可以实现三方面功能：对内部网络服务的访问提供了便捷，如Web、邮件、FTP服务器；隐藏了内部网络的真实IP地址，加强了安全性；并能有效节省公共IP地址资源，通过一个公共IP地址映射多个内部网络主机或服务。
实验拓扑 实验要求通过公网 访问内网的服务器应用
环境前配置 AR1的基本配置 //基本的IP地址和默认路由配置
&lt;Huawei&gt;sys Enter system view, return user view with Ctrl+Z. [Huawei]un in en Info: Information center is disabled. [Huawei]int g0/0/0 [Huawei-GigabitEthernet0/0/0]ip add 192.168.1.1 24 [Huawei-GigabitEthernet0/0/0]int g0/0/1 [Huawei-GigabitEthernet0/0/1]ip add 202.96.0.1 24 [Huawei-GigabitEthernet0/0/1]q [Huawei]ip route-static 0.0.0.0 0 202.96.0.2 [Huawei] 如图所示
AR2的基本配置 //基本的IP配置
&lt;Huawei&gt;sys Enter system view, return user view with Ctrl+Z. [Huawei]un in en Info: Information center is disabled.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb6a3c8704a899d160f020834a553e06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2db4ad7aa6269223bbb451919bf97b06/" rel="bookmark">
			无法读取 chrome-error://chromewebdata/ 的源映射: Unexpected 503 response from chrome-error://chromewebdata/
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 之前我都是用的Hbuilder，在使用vscode的过程中发现了个问题，
在vscode里一直运行不了，会报错，在上网查询许多资料后依然没有解决，后来我发现我的文件目录里多了个.vscode文件
解决方法： 之后我想着之前没有都正常运行了，删了会不会变正常？然后直接删除了vscode这个文件，之后就正常运行了 希望我的经历能帮到大家！这是我的第一篇博客，写着玩的，哪里做的不好请多见谅。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/34/">«</a>
	<span class="pagination__item pagination__item--current">35/71</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/36/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>