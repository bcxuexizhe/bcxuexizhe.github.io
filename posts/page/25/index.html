<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3f0e947814c486c131605818f9370ac/" rel="bookmark">
			2024年网络安全最全凯哥带你从零学大数据系列之Java篇---第十七章 集合(List)(1)，2024年最新带你轻松理解网络安全-Hook机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习路线： 这个方向初期比较容易入门一些，掌握一些基本技术，拿起各种现成的工具就可以开黑了。不过，要想从脚本小子变成黑客大神，这个方向越往后，需要学习和掌握的东西就会越来越多以下是网络渗透需要学习的内容：
网上学习资料一大堆，但如果学到的知识不成体系，遇到问题时只是浅尝辄止，不再深入研究，那么很难做到真正的技术提升。
需要这份系统化资料的朋友，可以点击这里获取
一个人可以走的很快，但一群人才能走的更远！不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！
17.3. 示例代码
import java.util.ArrayList; import java.util.List; /** * @Description List接口的方法 */ public class Test1 { public static void main(String[] args) { // 1. 实例化一个ArrayList对象，向上转型为接口类型。 List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 2. 增元素 list.add("Lily"); list.add("Lucy"); list.add("Polly"); list.add("Jim"); // 3. 在集合中指定的下标位插入元素 list.add(2, "Tom"); // 4. 在集合中指定的下标位插入另外一个集合中所有的数据 list.addAll(2, list); // 5. 删除集合中指定下标位的元素 // 返回值：这个被删除的元素 System.out.println(list.remove(2)); // 6. 修改指定下标位的值 // 返回被覆盖的值。 System.out.println(list.set(2, "AAA")); // 7* 元素替换 // 将集合中的每一个元素，带入到接口的方法中，用返回值替换原来的元素 // list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3f0e947814c486c131605818f9370ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41410fb202f6d75264b7302ccbcb637b/" rel="bookmark">
			【一步一步了解Java系列】：探索Java基本类型转换的秘密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看到这句话的时候证明：此刻你我都在努力~
加油陌生人~
个人主页： Gu Gu Study ​​
专栏：一步一步了解Java
喜欢的一句话： 常常会回顾努力的自己，所以要为自己的努力留下足迹。
如果喜欢能否点个赞支持一下，谢谢啦！
作者：小闭
Java 中的类型转化 在 Java 中，类型转化是一种常见的操作，它允许我们将一种数据类型转换为另一种数据类型。类型转化可以分为自动类型转换和强制类型转换。
int a = 10; long b = 100L; b = a; // 可以通过编译 a = b; // 编译失败 看上上面的代码是否有了那么一些疑惑了呢？至于为什么，下面的知识会给你答案！ 一、自动类型转换 自动类型转换是指在不丢失信息的情况下，将一种数据类型自动转换为另一种数据类型。这种转换通常发生在取值范围较小的数据类型向取值范围较大的数据类型转换时。（代码不需要经过任何处理，在代码编译时，编译器会自动进行处理。）
1.1 自动类型转换(隐式)
例如：byte转化为int类型
byte b = 10; int i = b; // 自动类型转换 这里byte的取值范围是比int型的取值范围小所以是可以完成自动类型转换
public class Test { public static void main(String[] args) { System.out.println(18);// 整型默认情况下是int System.out.println(18.8); // 浮点型默认情况下是double int a = 100; long b = 10L; b = a; // a和b都是整形，a的范围小，b的范围大，当将a赋值给b时，编译器会自动将a提升为long类型，然后赋值 a = b; // 编译报错，long的范围比int范围大，会有数据丢失，不安全 float f = 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41410fb202f6d75264b7302ccbcb637b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c564e2a3218f8be092299b3c7da244cd/" rel="bookmark">
			初识指针（2）＜C语言＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 前文介绍完了一些指针基本概念，下面介绍一下，const关键字、指针的运算、野指针的成因以及避免，assert函数等。
目录
const（常属性）
变量的常属性
指针的常属性
指针的运算
①指针+ -整数
②指针-指针
③指针与指针的比较
野指针的成因以及避免
①指针未初始化，就使用
②指针越界访问数组 ③指针使用已释放的地址
assert（断言）函数
const（常属性） 变量的常属性 变量是可以被修改的，也可以通过将其地址交给指针变量来进行修改。如果在变量声明阶段，在变量名前加上const，那么这个变量就具有了常属性，在后面就不能进行修改了。
报错了，程序也不能正常运行。
指针的常属性 指针变量是否也能使用const来限制变量的修改呢？如果能够修改，const应该放哪呢？
在此之前先讲一讲3个容易弄混的概念(以指针变量p为例)
①p——指针变量，里面存放着一个地址
②*p——p中存放地址指向的对象
③&amp;p——指针变量p的地址
两种情况：①const在“*”左边，限制的是*p,也就是p中存放地址指向的对象
可以看到解引用指针p时报错，但是更改p中的地址是可以的。
②const在“*”右边，限制的是p中指向的对象。
同理， 可以看到更改指针p指向地址时报错，但是更改p中的地址的对象的值是可以的。
指针的运算 指针的运算主要有以下三种：
①指针+ -整数
②指针-指针
③指针与指针的比较
①指针+ -整数 上文说到，指针类型决定了指针向前一步或向后一步“走”多大距离，数组名是一个地址常量，存放的是第一个元素的地址，那么是否能够通过加减指针完成对数组的访问呢？
②指针-指针 指针与指针的加法是无意义的。但是可通过指针与指针之间的减法完成对数组元素个数的统计。
③指针与指针的比较 野指针的成因以及避免 野指针就是指针指向位置是不可知的（随机的、不正确的、没有限制的）
成因：
①指针未初始化，就使用
②指针越界访问数组
③指针使用已释放的地址
①指针未初始化，就使用 ②指针越界访问数组 因为指针越界访问数组导致打印出野指针
③指针使用已释放的地址 避免
①初始化指针，如果不知道指向哪，可以将指针赋值给NULL
②小心越界
③指针不再使用时及时置NULL，使用指针时，先检查指针的有效性
④避免返回局部变量的地址
assert（断言）函数 assert()函数包含在库函数&lt;assert.h&gt;中，使用时需先声明。
用法：用于确保程序满足指定条件，如果不符合，就报错终止运行
也可以在函数开始加上#define NDEBUG使文件中的assert()函数失效，在release环境中默认失效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2efe50d08b0ba71b910197d5b0b1a40d/" rel="bookmark">
			【数据结构与算法】之五道链表进阶面试题详解！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、链表的回文结构
2、相交链表
3、随机链表的复制
4、环形链表
5、环形链表（||）
6、完结散花
个人主页：秋风起，再归来~
数据结构与算法 个人格言：悟已往之不谏，知来者犹可追
克心守己，律己则安！
1、链表的回文结构 题目描述：
对于一个链表，请设计一个时间复杂度为O(n),额外空间复杂度为O(1)的算法，判断其是否为回文结构。
给定一个链表的头指针A，请返回一个bool值，代表其是否为回文结构。保证链表长度小于等于900。
测试样例：
1-&gt;2-&gt;2-&gt;1 返回：true 题目链接：OJ链接
解题代码：
ListNode* findMid(ListNode* head) { struct ListNode* fast=head,*slow=head; while(fast) { fast=fast-&gt;next-&gt;next; slow=slow-&gt;next; } return slow; } ListNode* reverse(ListNode* mid) { ListNode* n1=NULL; ListNode* n2=mid; ListNode* n3=mid-&gt;next; while(n2) { n2-&gt;next=n1; n1=n2; n2=n3; if(n3) { n3=n3-&gt;next; } } return n1; } class PalindromeList { public: bool chkPalindrome(ListNode* A) { // write code her //找中间节点 ListNode* mid=findMid(A); //把中间节点后的节点逆置 ListNode* rmid=reverse(A); while(A) { if(A-&gt;val!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2efe50d08b0ba71b910197d5b0b1a40d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca3524b561081090c4c4495b696bf7d6/" rel="bookmark">
			C&#43;&#43;：哈希表和unordered系列容器的封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、unordered系列关联式容器的介绍 在C++98中，STL提供了底层为红黑树结构的一系列关联式容器，在查询时效率可达到log2N，即最差情况下需要比较红黑树的高度次，当树中的节点非常多时，查询效率也不理想。最好的查询是，进行很少的比较次数就能够将元素找到，因此在C++11中，STL又提供了4个unordered系列的关联式容器，这四个容器与红黑树结构的关联式容器使用方式基本类似，只是
其底层结构不同（哈希表）
1.1 unordered_map unordered_map的介绍
1. unordered_map是存储&lt;key, value&gt;键值对的关联式容器，其允许通过keys快速的索引到与其对应的value。
2. 在unordered_map中，键值通常用于惟一地标识元素，而映射值是一个对象，其内容与此键关联。键和映射值的类型可能不同。
3. 在内部,unordered_map没有对&lt;kye, value&gt;按照任何特定的顺序排序, 为了能在常数范围内找到key所对应的value，unordered_map将相同哈希值的键值对放在相同的桶中。
4. unordered_map容器通过key访问单个元素要比map快，但它通常在遍历元素子集的范围迭代方面效率较低。
5. unordered_maps实现了直接访问操作符(operator[])，它允许使用key作为参数直接访问value。
6. 它的迭代器至少是前向迭代器。
7.unordered就是无序的意思
使用细节基本上和map一致
1.2 unordered_set unordered_set的文档说明
1.3 性能对比 通过一个测试代码来比较unordered_set 和set的效率
void testop() //测试 底层是红黑树和哈希表的效率比对 { const size_t N = 1000000; unordered_set&lt;int&gt; us; set&lt;int&gt; s; vector&lt;int&gt; v; v.reserve(N); srand((unsigned int)time(0)); for (size_t i = 0; i &lt; N; ++i) { v.push_back(rand()); //v.push_back(rand()+i); //v.push_back(i); } size_t begin1 = clock(); for (auto e : v) { s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca3524b561081090c4c4495b696bf7d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/367fbfe437b454add8cb4d018e009d95/" rel="bookmark">
			Spring IoC&amp;DI（1）—入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、IoC &amp; DI入门
1、Spring是什么
（1）什么是容器？
（2）什么是IoC？
二、IoC介绍
1、传统程序开发
2、解决方案
3、IoC程序开发
4、IoC优势
三、DI介绍
通过前面的学习，我们知道Spring是一个开源框架，它能让我们的开发更简单，它支持广泛的应用场景，有着活跃而庞大的社区，这也是Spring长久不衰的原因。但是这个概念还是比较抽象的，我们用一句更具体的话来概括Spring：Spring是包含了众多工具方法的IoC容器。
一、IoC &amp; DI入门 1、Spring是什么 （1）什么是容器？ 容器是用来容纳某种物品的（基本）装置。——来自：百度百科。生活中的水杯、垃圾桶、冰箱等等这些都是容器，之前接触过的容器：List/Map-&gt;数据存储容器、Tomcat-&gt;Web容器。
（2）什么是IoC？ IoC是Spring的核心思想，也是常见的面试题，那么什么是IoC呢？其实IoC在前面的代码练习已经使用过了，比如在类上面添加 @RestController 和 @Controller 注解，就是把这个对象交给Spring管理，Spring框架启动时，就会加载该类。——把对象交给Spring管理，这就是IoC思想。
IoC：Inversion of Control（控制反转），也就是说Spring是一个“控制反转”的容器。
什么是控制反转呢？就是控制权反转。什么控制权发生了反转？获得依赖对象的过程被反转了，也就是说，当需要某个对象时，传统开发模式需要自己通过 new 创建对象，现在不需要再进行创建了，把创建对象的任务交给容器，程序中只需要依赖注入（Dependency Injection，简称DI）就可以了。这个容器称为：IoC容器。Spring是一个IoC容器，所以有时也称为Spring容器。
控制反转是一种思想，在生活中也处处体现。比如自动驾驶，传统驾驶方式，车辆的横向和纵向驾驶控制权由驾驶员来控制，现在交给了驾驶自动化系统来控制，这也是控制反转思想在生活中的实现；还有招聘，企业的员工招聘、入职、解雇等控制权，由老板转交给HR（人力资源）来处理；还有外包等等。
二、IoC介绍 下面通过案例来介绍什么是IoC，现在需求：造一辆车
1、传统程序开发 我们是实现思路是这样的：先设计轮子（Tire），然后根据轮子的大小设计底盘（；），接着根据底盘设计车身（FrameWork），最后根据车身设计好整个汽车（Car）。这里就出现了一个 “依赖” 关系：汽车依赖车身，车身依赖底盘，底盘依赖轮子。如图：
代码实现如下：
public class Main { public static void main(String[] args) { Car car = new Car(); car.run(); } } public class Car { private FrameWork frameWork; public Car() { frameWork = new FrameWork(17); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/367fbfe437b454add8cb4d018e009d95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eae9abccac6f5f18a15a8bc58cd76cec/" rel="bookmark">
			【LLama】Llama3 的本地部署与lora微调(基于xturn)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列课程代码+文档（前2节课可跳过）：https://github.com/SmartFlowAI/Llama3-Tutorial
课程视频：https://space.bilibili.com/3546636263360696/channel/series
XTuner ：https://github.com/InternLM/xtuner/blob/main/README_zh-CN.md
一、Llama 3 本地部署（Nidia3090显卡） 教程所提供的在线显卡只有8G, 微调和推理时一般是16-20G，所以本地部署。
下载llama3模型 # 如果下面命令报错则使用 apt install git git-lfs -y conda install git-lfs git-lfs install git clone https://code.openxlab.org.cn/MrCat/Llama-3-8B-Instruct.git Meta-Llama-3-8B-Instruct 下载在本地后的内容
本地环境 conda create -n llama3-xtuner python=3.10 -y conda activate llama3-xtuner conda install pytorch==2.1.2 torchvision==0.16.2 torchaudio==2.1.2 pytorch-cuda=12.1 -c pytorch -c nvidia 其他依赖 git clone https://github.com/InternLM/xtuner.git cd xtuner conda activate llama3-xtuner pip install -e . 运行llama3-instruct Llama3-Tutorial-main
streamlit run ~/code/Llama3-Tutorial-main/tools/internstudio_web_demo.py \ ~/code/Meta-Llama-3-8B-Instruct 二、 使用Xturn微调llama3 （1条数据） 主要参考：https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eae9abccac6f5f18a15a8bc58cd76cec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5294cd99c6df32e380f6baecdc9d2827/" rel="bookmark">
			2024年前端最全vue项目首页优化问题（前后端都要优化），web前端开发面试技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结尾 正式学习前端大概 3 年多了，很早就想整理这个书单了，因为常常会有朋友问，前端该如何学习，学习前端该看哪些书，我就讲讲我学习的道路中看的一些书，虽然整理的书不多，但是每一本都是那种看一本就秒不绝口的感觉。
以下大部分是我看过的，或者说身边的人推荐的书籍，每一本我都有些相关的推荐语，如果你有看到更好的书欢迎推荐呀。
开源分享：【大厂前端面试题解析+核心总结学习笔记+真实项目实战+最新讲解视频】
2.2 配置Gzip的 插件配置 打开webpack.prod.config.js 配置一下这段代码
代码如下
if (config.build.productionGzip) {
const CompressionWebpackPlugin = require(‘compression-webpack-plugin’)
webpackConfig.plugins.push(
new CompressionWebpackPlugin({
asset: ‘[path].gz[query]’,
algorithm: ‘gzip’,
test: new RegExp(
‘\.(’ +
config.build.productionGzipExtensions.join(‘|’) +
‘)$’
),
threshold: 10240,
minRatio: 0.8
})
)
}
2.3 配置打包report 查看详细打包信息 打开package.json ，配置
“report”: “npm run build --report=true”
2.4 重新打包查看Gzip压缩情况 重新 npm run build 可以看到提供的 gz 压缩包 vendor.js.gz 已经小到了100k左右了， 从刚开始1M已经优化到现在的100k了
3.开启Nginx Gzip功能 （后端操作）
3.1 gzip的概念 gzip 是 Web 世界最广泛的文件压缩算法，已经得到了绝大多数的服务端和客户端软件（例如我们使用的浏览器）的支持。gzip 最为擅长的是压缩纯文本文件，其效果非常明显，大约可以减少70％以上的文件大小，所以 Web 项目中开启 gzip 十分必要
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5294cd99c6df32e380f6baecdc9d2827/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1b55e5a982ca61cb7439515840cd9cb/" rel="bookmark">
			【MySQL数据库】详解数据库审核工具SQLE的部署及接口调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQLE部署及使用 1. 部署SQLE SQLE相信大家都不陌生吧，它是一款开源，支持多场景审核，支持标准化上线流程，原生支持 MySQL 审核且数据库类型可扩展的 SQL审核工具。我们可以基于此工具进行数据库SQL审核，提升SQL脚本质量，大大提高我们的开发效率。
其主要功能和优势包括：
平台管理：支持用户和角色管理、配置上线数据库、基于角色的资源隔离、配置审核规则模板，以及对不同的数据库应用不同的规则模板。SQL审核：支持工单审批流程、工单隔离、邮件推送审批事件、SQL上线、生成回滚语句、审核MyBatisXML文件，以及审核建议按SQL归类去重展示等功能。此外，SQLE还支持审核报告下载，并提供静态审核（即脱离上线数据库审核）和定时审核功能。SQL审核计划：支持通过标准接口收集来自业务的SQL统计信息，提供MyBatis文件扫描上传程序（scanner），可集成CI/CD。 SQLE3.0在SQL审核方面具有高效性和准确性的双重优势。它能够自动化地对SQL语句进行审核，从而减少了人工审核的工作量和错误率。此外，SQLE 3.0还具备强大的规则引擎，可以通过预设规则对SQL语句进行灵活的审核和检测，从而保证了SQL语句的规范性和安全性。
与其他数据库审核工具相比，SQLE具有其独特的优势。例如，本地数据库平台虽然简单，但分析范围有限，且需要人为管理。而DAM数据库活动监控平台和SIEM、日志管理工具虽然功能更多，但可能会消耗本地数据库性能。SQLE则通过提供全面的审核功能和高效的审核效率，为用户提供了更好的选择。
下载地址：https://github.com/actiontech/sqle/releases
安装：
mkdir /opt/sqle 创建SQLE元数据存储库（mysql中）： create database sqle
修改配置：修改配置文件名，并按需修改端口、元数据数据库信息
启动sqle: systemctl start sqled
2. SQLE使用 功能列表如下：
已有的审核规则 如下，大家可以部署后自行查看 配置数据源：需配置具体实例、用户信息、审核规则模板、开启审核等
创建审核任务：
点击下方审核
审核结果如下
3. 调用审核接口 审核接口：http://ip：port/v1/tasks/audits
先获取token
使用postman调用接口进行审核：需输入token 、instance_name、instance_schema 、sql
输入token:
提交待审核SQL
查看审核结果 ：
http://ip:10000/v1/tasks/audits/9/sqls?page_index=1&amp;page_size=10&amp;no_duplicate=false
注：数据库SQL脚本的审核是相当重要的一项工作，建议使用SQL审核工具进行审核，提升SQL质量。下一篇将通过代码来调用对应的接口并获得审核结果。
SQLE接口调用 1、创建自定义审核接口
因直接调用SQLE的审核接口，会出现token过期，且审核及结果查询接口是分开的，因此，出于以上2个原因的考虑，重新编写一个接口用于调用SQLE的审核接口并返回审核结果。参考代码如下：
# coding=utf-8 import requests from flask import request import json from flask import Flask app = Flask(__name__) @app.route('/audit_task', methods=['post','get']) def audit_task(): get_data = request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1b55e5a982ca61cb7439515840cd9cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd6e55d6dfb755ffecc7ea779fb5f544/" rel="bookmark">
			数据结构：线性表(详解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线性表 线性表的知识框架：
线性表的定义：
线性表是具有相同数据类型的n(n &gt; 0)个数据元素的有限序列，当n = 0时线性表为一个空表。
若用L命名为线性表，则数据集合为L= {a1,a2,…,an}，其中a1称为表头元素，an称为表尾元素。除第一个元素外，每个元素有且仅有一个直接前驱。除最后一个元素外，每个元素有且仅有一个直接后继。
线性表的特点： 1.表中元素的个数有限
2.表中元素具有逻辑上的顺序表，表中元素有其先后次序
3.表中元素都是数据元素，每个元素都是单个元素
4.表中元素的数据类型相同，所以每个元素占有相同大小的存储空间
5.线性表是一种逻辑结构，表示元素之间一对一的相邻关系。顺序表和链表是指存储结构
线性表的顺序存储结构 顺序表的的定义： 线性表的顺序存储又称顺序表。它是用一组地址连续的存储单元依次存储线性表中的数据元素。
顺序表的特点： 1.顺序表的存储密度高，每个结点只存储数据结构。
2.顺序表逻辑上相邻的元素在物理上也相邻，所以插入和删除操作需要移动大量数据
3.顺序表是随机访问，即通过首地址和元素序号可在时间O(1)内找到指定的元素
顺序表代码实现：
顺序表储存结构： typedef int SLTDataType; typedef struct SeqList { SLDatatype capacity;//数组的容量 SLDatatype size;//有效数据 SLDatatype* arr; }SL; 顺序表所有接口： //初始化/销毁 void SLInit(SL* ps); void SLDestroy(SL* ps); void SLPrint(SL* ps); //顺序表的头部/尾部插入 void SLPushBack(SL* ps, SLDatatype x); void SLPushFront(SL* ps, SLDatatype x); //顺序表的头部/尾部删除 void SLPopBack(SL* ps); void SLPopFront(SL* ps); //指定位置之前插入数据/删除指定位置数据 void SLInsert(SL* ps, SLDatatype pos, SLDatatype x); void SLErase(SL* ps, SLDatatype pos); 顺序表初始化和销毁： void SLInit(SL* ps) { ps-&gt;arr = NULL; ps-&gt;capacity = ps-&gt;size = 0; } 顺序表输出：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd6e55d6dfb755ffecc7ea779fb5f544/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcbcc17429eb8ab2af78e6feba81b03b/" rel="bookmark">
			1. MySQL 5.7安装部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RDBMS关系型数据库管理系统 一、RDBMS关系型数据库管理系统1、数据存储结构2、约束 constraint1)、域约束2)、检查性约束3)、主键约束 primary key4)、惟一键约束 unique key5)、外键约束 Foreign Key 3、关系型数据库管理系统的软件 二、MySQL 5.7安装部署1、安装MySQL软件仓库2、安装MySQL 5.73、启动MySQL服务4、修改root用户密码5、测试连接登录数据库6、在防火墙中放行数据库服务 三、MySQL配置文件解析1、配置文件 ---- /etc/my.cnf 一、RDBMS关系型数据库管理系统 1、数据存储结构 数据库
表
记录 record
字段 column
2、约束 constraint 1)、域约束 在字段进行数据类型限制
作用: 确保表中的某个字段的数据格式统一
2)、检查性约束 作用: 确保数据的合理性
3)、主键约束 primary key 作用：确保某一行的数据的惟一性
不允许出现重复数据
不允许为空
注意: 一张表只能有一个主键
4)、惟一键约束 unique key 不允许重复、允许为空
一张表中可以存在多个惟一键
5)、外键约束 Foreign Key 作用: 确保数据的完整性
3、关系型数据库管理系统的软件 开源软件
MySQL、PostgreSQL
MariaDB
商业数据库
Oracle
SQL Server
国产数据库
阿里 OceanBase
华为 GuassDB
二、MySQL 5.7安装部署 1、安装MySQL软件仓库 [root@web ~]# wget http://repo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcbcc17429eb8ab2af78e6feba81b03b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc47b0a743d6fb61a5726eaf1601a7b8/" rel="bookmark">
			数据结构：队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 队列的基本概念： 1.队列的定义： 队列(Queue)简称队，也是和栈一样是一种受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。向队列中插入元素称为入队或进队；删除元素称为出队或离队。这和我们日常生活中的排队是一致的，最早排队的也是对早离队的，其操作的特性就是先进先出(First In First Out FIFO)。
队头 (Front) 允许删除的一端，又称队首。
队尾(Rear) 允许插入的一端。
空队列 不含元素的空链表。
二 队列的链式存储结构： 1.队列的存储结构： typedef int QDataType; typedef struct QueueNode { int val; struct QueueNode* next; }QNode; typedef struct Queue { QNode* phead; QNode* ptail; int size; }Queue; 2.队列的所有接口： //队列的初始化、销毁 void QueueInit(Queue* pq); void QueueDestroy(Queue* pq); // 入队列、 出队列 void QueuePush(Queue* pq, QDataType x); void QueuePop(Queue* pq); //获取队头、队尾元素 QDataType QueueFront(Queue* pq); QDataType QueueBack(Queue* pq); //判断队列是否为空 bool QueueEmpty(Queue* pq); //获取队列元素个数 int QueueSize(Queue* pq); 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc47b0a743d6fb61a5726eaf1601a7b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4b31db9d34e2c6d31141e206abdcd72/" rel="bookmark">
			为什么 ChatGPT 不火了？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不火了是有原因的，下面我来从大部分人拿到 ChatGPT 之后的两大痛点开始讲起：
很多朋友拿到 ChatGPT 后的第一个痛点就是：用的不好
你经常会感觉到 ChatGPT 回答的好空，没有太多参考价值。
而第二个痛点则是：无处去用
有了 ChatGPT 之后，发现自己好像并没有什么好问的，不知道可以用它来干嘛。
所以，在这两个痛点的影响下，当你折腾完账号，闲聊天的新鲜期过去之后，ChatGPT 也就跟着躺平吃灰了，你的生活、工作依旧一成不变。
但是，我用 ChatGPT 的结果可能和你不太一样，它真真正正的变成了我的私人助理。
其实，用同样的工具，我之所以能用它创造出实际的价值，而你却陷入了【回答好空，不知道用来干嘛】尴尬情况的核心原因，就是因为你缺少了这么两点：
1.没有掌握 GPT 的使用方法。
2.无法让 GPT 与自身的应用场景关联起来，最后躺平吃灰。
可以说，几乎所有无法用 GPT 创造出实在生产力的朋友，都死在了这两关上。
我们先来介绍下用好 GPT 的第一条线，也就是：带你掌握使用 GPT 的方法
那么如何使用 GPT 呢?
其实整个 GPT 使用的核心心法，用一句话就可以概括了：GPT 生成的答案质量，完全取决于你『问它』，以及『引导它』的方式，如果你能问得好，引导的好，那么它就会帮你生成让你惊喜的答案，反之则无价值，假大空。
这里『问它的方式』指的就是：与 GPT 沟通的语言，而『引导它的方式』，则就是调教 GPT 的方法。
可以说：只要你搞懂了这两点，那么你就掌握了如何使用GPT的核心能力。
其实很好理解，由于目前人类的技术对自然语言（人说的话）处理的技术还不完美，所以导致目前 AI 生成内容的质量，非常依赖于提示词（Prompts）
PS：你可以把“提示词”理解成：让 GPT 能精准 Get 到你意图的话，或者与 GPT 沟通的语言方式。
也就是说：如果你给 GPT 的提示词质量不好，或者不到位，那么它给到你的，往往就是那种 “像是一堆正确的废话堆积而成” 的文字垃圾。
所以，想要获得 GPT 高质量回答的第一步，就是先学会与它沟通的语言，也就是学会写提示词。
关于这一点，我这里给你总结了一个通用且屡试不爽的提示词模版：
也就是说，一个好的提示词是由：立角色 + 述问题 + 定目标 + 补要求，这四部分构成的！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4b31db9d34e2c6d31141e206abdcd72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e15884ad32f1c5d26989fde50d17b9f/" rel="bookmark">
			【Rust】——引用循环与内存泄漏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💻博主现有专栏：
C51单片机（STC89C516），c语言，c++，离散数学，算法设计与分析，数据结构，Python，Java基础，MySQL，linux，基于HTML5的网页设计及应用，Rust（官方文档重点总结），jQuery，前端vue.js，Javaweb开发，Python机器学习等
🥏主页链接：
Y小夜-CSDN博客
目录
🎯制造引用循环
🎃创建树形数据结构：带有子节点的Node
🎃增加子到父的作用
🎃可视化strong_count和week_count的改变
Rust 的内存安全性保证使其难以意外地制造永远也不会被清理的内存（被称为 内存泄漏（memory leak）），但并不是不可能。Rust 并不保证完全防止内存泄漏，这意味着内存泄漏在 Rust 中被认为是内存安全的。这一点可以通过 Rc&lt;T&gt; 和 RefCell&lt;T&gt; 看出：创建引用循环的可能性是存在的。这会造成内存泄漏，因为每一项的引用计数永远也到不了 0，持有的数据也就永远不会被释放。
🎯制造引用循环 让我们看看引用循环是如何发生的以及如何避免它。
use crate::List::{Cons, Nil}; use std::cell::RefCell; use std::rc::Rc; #[derive(Debug)] enum List { Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;), Nil, } impl List { fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; { match self { Cons(_, item) =&gt; Some(item), Nil =&gt; None, } } } fn main() {} 现在 Cons 成员的第二个元素是 RefCell&lt;Rc&lt;List&gt;&gt;，这意味着不同于像示例 15-24 那样能够修改 i32 的值，我们希望能够修改 Cons 成员所指向的 List。这里还增加了一个 tail 方法来方便我们在有 Cons 成员的时候访问其第二项。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e15884ad32f1c5d26989fde50d17b9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbe43324ab3517f589a1028f81638e32/" rel="bookmark">
			揭秘实时渲染技术在AI去衣中的神奇魔法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言：
随着人工智能技术的飞速发展，其在图像处理和计算机视觉领域的应用日益广泛。其中，AI去衣技术作为一种颇具争议的话题，不仅涉及了深度学习、计算机图形学等多个领域，还引发了众多关于隐私、伦理的讨论。在这场科技与道德的较量中，实时渲染技术扮演着至关重要的角色。今天，就让我们一起走进这项神秘而强大的技术，探索它在AI去衣中的作用及其背后的原理。
一、实时渲染技术概述
实时渲染技术，简单来说，就是计算机能够即时生成图像或视频的技术。它广泛应用于游戏、电影、虚拟现实（VR）和增强现实（AR）等领域。实时渲染的核心在于快速且高效地将三维模型转换为二维图像，同时保持高质量的视觉效果。这一过程涉及到复杂的图形算法、光照模型、纹理映射等关键技术。
二、AI去衣技术简介
AI去衣技术，是指利用人工智能算法自动识别并去除图片或视频中人物的衣物。这一技术通常基于深度学习模型，如卷积神经网络（CNN），通过大量带有标签的数据训练，使模型学会识别不同类型和风格的服装。然而，由于涉及到个人隐私问题，该技术的发展和应用受到了严格的法律和伦理限制。
三、实时渲染在AI去衣中的作用
实时渲染在AI去衣技术中的作用主要体现在两个方面：一是提升去衣效果的自然度和真实感；二是优化计算效率，实现实时处理。
提升去衣效果的自然度和真实感
在AI去衣过程中，实时渲染技术能够根据人物的姿态和体型变化，动态地调整去除衣物后的阴影、褶皱等细节，使得最终效果更加贴近真实情况。此外，通过模拟不同材质的光线反射和散射特性，实时渲染还能够增加皮肤的真实质感，让整个去衣过程看起来更加自然。
优化计算效率，实现实时处理
传统的去衣算法往往需要大量的计算资源和时间来处理每一帧图像，这在实时应用中是不切实际的。而实时渲染技术通过高效的图形硬件加速，如GPU编程和并行计算，显著提升了去衣过程的计算效率。这意味着在保证视觉效果的同时，AI去衣可以实时响应用户的操作，为用户提供更加流畅的体验。
四、技术挑战与伦理考量
尽管实时渲染技术在AI去衣中展现出巨大的潜力，但它也面临着一系列技术挑战和伦理问题。技术上，如何平衡渲染质量与速度、如何处理复杂场景下的动态去衣等问题仍然是研究的热点。而在伦理层面，如何在不侵犯个人隐私的前提下合理使用AI去衣技术，以及如何防止其被滥用，都是必须严肃考虑的问题。
实时渲染技术在带来高度逼真的视觉体验的同时，可能会引发以下几个伦理问题：
隐私侵犯：随着实时渲染技术的发展，生成逼真图像的能力越来越强，这可能导致个人隐私被侵犯。例如，通过实时渲染技术可以创建看似真实的人物肖像或场景，这可能被用于不当目的，如制造虚假新闻、诈骗或侵犯版权等。虚拟与现实的界限模糊：实时渲染技术能够创造出难以区分真伪的虚拟世界，这可能导致人们在虚拟与现实之间的界限变得模糊。对于儿童和青少年来说，过度沉浸在这些虚拟世界中可能会影响他们的社交能力和现实世界的认知。身份盗用和欺诈：实时渲染技术可以被用来创建高度真实的虚拟人物，这可能使得身份盗用和欺诈行为更加容易。不法分子可能利用这项技术进行身份伪装，实施网络钓鱼或其他形式的诈骗。版权和知识产权问题：实时渲染技术可以复制现实世界中的物品和场景，这可能引发关于版权和知识产权的问题。如何确保创作者的权益不被侵犯，以及如何处理由AI生成的内容的版权，都是需要解决的问题。道德和审美标准：实时渲染技术的应用可能会挑战现有的道德和审美标准。例如，通过技术制作的色情内容可能会引起社会道德的争议，同时也对个人的心理健康造成影响。资源分配不均：高质量的实时渲染通常需要高性能的硬件支持，这可能导致资源分配不均的问题。拥有先进技术的个人或团体可能会获得不公平的优势，而那些无法负担高昂硬件成本的人则可能被边缘化。安全性问题：实时渲染技术的进步也带来了新的安全挑战。例如，深度伪造（deepfake）技术可以利用实时渲染技术制作虚假视频，这可能对政治、娱乐和个人安全造成严重影响。 综上所述，实时渲染技术在为人们带来前所未有的视觉体验的同时，也引发了一系列伦理问题。这些问题需要技术开发者、法律制定者、社会各界人士共同努力，以确保技术的健康发展和正面应用。
亲自试一把ai逆天的去依功能吧
下载链接:
https://pan.baidu.com/s/1Eh9kjBVmUow4FTpnu0lsVg?pwd=9999
提取码：9999
解压密码：ai_gongju
结语：
实时渲染技术在AI去衣中的应用，不仅展现了人工智能在图像处理领域的强大能力，也对我们提出了更高的技术挑战和伦理要求。作为科技工作者，我们应当不断探索和创新，推动技术进步，同时也要审慎思考技术的社会责任，确保科技的发展能够造福人类，而不是成为伤害的工具。让我们共同期待，在不久的将来，这项技术能够在尊重隐私和伦理的前提下，为我们的生活带来更多便利和乐趣。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e640d9381ab3e02e42a4ba34fb817db/" rel="bookmark">
			链表经典面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下的每个题都配有链接，大家可以点击进入进行练习，想了解更多知识可以关注以下个人主页
敲上瘾-CSDN博客
目录
1.反转链表
2.回文链表
3.相交链表
4.环形链表
5.合并两个有序链表
1.反转链表 分析：首先确定函数的返回值，需要返回的是反转后的头节点，显然，返转后的头结点是原链表的尾结点，而原链表的头结点应该指向NULL。
方法一：使用一个结构体指针数组，将每一个结点存入数组内，然后把arr[0]的下一个结点指向NULL，arr[1]的下一个结点指向arr[0]，以此类推。然后把数组最后一个元素返回。此方法空间复杂度为O(n)，时间复杂度为O(n)。
方法二：这个题就是让我们把头结点的next指向NULL，然后把后面的每个结点的next都指向前一个结点，可以使用三个指针变量比如n1，n2，n3。n1=NULL，n2=head，n3=head-&gt;next。n2存放的是需要改变的结点，n1存放的是前一个结点(防止前结点找不到)，n3存放后一个结点(防止后结点丢失)，然后每完成一次反转，这三个指针同时往右移一位。空间复杂度为O(1)，时间复杂度为O(n)。如下图：
代码演示： struct ListNode* reverseList(struct ListNode* head) { if(head==NULL||head-&gt;next==NULL) return head; struct ListNode* n1=NULL,*n2=head,*n3=head-&gt;next; while(n2) { n2-&gt;next=n1; n1=n2; n2=n3; if(n3) n3=n3-&gt;next; } return n1; } 2.回文链表 分析：回文链表的特性是对称性，也就是它关于中间结点对称，即链表节点序列从后往前看和从前往后看是相同的，实例1从前往后看和从后往前看都是1,2,3,3,2,1。是一个回文链表。 方法一：使用结构体指针数组储存各节点(也可用整型数组直接储存各节点对应的值)，然后从最左边和最右边开始比较它们对应的值，然后两边同时往中间移，直到比较到最中间元素都相等为止，则为回文链表。空间复杂度为O(n)，时间复杂度为O(n)。因为该方法空间复杂度为O(n)，效率比较低，在这里就不在展示，来看方法二。
方法二：因为回文链表具有对称性，所以把链表从中间分为两段，后半段反转后是和前半段相同的。所以现在要做的是把后半段反转，首先就需要找到中间节点，如何来找呢？，有一个巧妙的方法，就是用快慢指针，快指针每次走两步，慢指针每次走一步。这样快指针走完整个链表，慢指针刚好走完链表的一半，此时慢指针指向的位置就是链表的中间节点。然后把该节点当做头节点进行反转变成新的链表最后与前半段进行比较。空间复杂度为O(1)，时间复杂度为O(n)。
struct ListNode* Fnod(struct ListNode* head)//反转链表 { struct ListNode* n1=NULL,*n2=head,*n3=head-&gt;next; while(n2) { n2-&gt;next=n1; n1=n2; n2=n3; if(n3) n3=n3-&gt;next; } return n1; } bool isPalindrome(struct ListNode* head) { if(!head) return false; if(head-&gt;next==NULL) return true; struct ListNode* p1=head,*p2=head; while(p2&amp;&amp;p2-&gt;next)//找中间节点 { p1=p1-&gt;next; p2=p2-&gt;next-&gt;next; } struct ListNode* fp= Fnod(p1); while(fp&amp;&amp;head)//比较 { if(fp-&gt;val!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e640d9381ab3e02e42a4ba34fb817db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/815a919ecadf08f015b4165c4c04b8b1/" rel="bookmark">
			ChatGPT 4.0 直接用 ！！！Code Copilot编程大模型、DALL-E AI绘图、绘制流程图、上传文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嗨，你好呀，我是哪吒。
这一年最让人揪心的热点，就是各种层出不穷的AI技术。
原以为它只是短暂霸屏，但现实却赤裸裸展示了，什么叫AI抢走你的饭碗，连招呼都不打一声!
什么策划方案、公众号文案、营销卖点、宣传海报，打工人辛辛苦苦掌握到手的技能，却被AI分分钟吊打。
平常要绞尽脑汁的文档报告、复盘总结，合同大纲，AI能帮忙以秒为单位完成。
哪吒AI是一个AI 聚合工具平台，包含ChatGPT4.0知识问答、DALL-E AI绘画、图片自动识别、Code Copilot辅助编程、联网查询、毕设去重、BUG解决、代码优化、上传文件、数据分析等。
这些功能都是3.5不能具备的 ！
可以很自信的说：我们的产品目前就是同类型体验最好的，对于需要 AI 辅助工作和学习的人来说，真的是非常有用。
当然，也欢迎你亲自体验。
👉使用地址：我的GPT4
👉也可以私信哪吒，备注：AI，先体验，好用才是硬道理，领取价值30元的授权码。
找人买过 ChatGPT Plus的朋友都知道一个 GPT Plus 账号再加一个月售后，基本都卖到了差不多 220元钱每月。就算自己充，加上各种手续费也要 200元每月以上而且流程繁琐，大部分人搞不定。另外，自己购买官方账号，很容易出现官方大规模封号，导致损失 。
一句话说明：用官方一半价格的钱，享受跟官方ChatGPT账号一模一样的功能 。
哪吒AI优点：
同时支持PC+手机、平板浏览器使用。不需要国外特殊网络，可以直接使用，非常方便 。个人专属授权码，放心使用。官方独立账户规定每3小时40次 4.0提问，我们这个不限制4.0提问次数。我们这个不会出现封号的情况，避免你因为封号多花冤枉钱。使用期内一直有售后，如果系统故障会补时长，可以放心。系统运行非常稳定，用了我们这种账号，次月续费率达到95%以上 。 登录我们给的官方Plus账号，可以看到很多账号，随着人数的增加，我们还会增加账号的数量，完全不用担心账号不够用 。可以随意登录一个账号 。随时随地都可以进行切换使用 。如下图所示：
支持官方最新出的GPTs，100+大模型
Code Copilot 目前最强的AI编程大模型：
用Java编写一个二分查找的代码，添加中文注释。
好友问的技术问题，10秒钟搞定。
使用DALL-E AI绘图功能：
Prompt：画一张3D卡通女孩，女孩是一个3D动画角色，具有现代动画电影中常见的大眼睛风格，给人一种可爱和天真无邪的感觉。她的头发是棕色，披肩长度，并有一个浅粉色的蝴蝶结头带修饰。她的眼睛大而明亮，呈现出深蓝色的瞳孔，眼睛下方有浅色的睫毛。
AI绘画：保持人物形象一致，适配更多的表情、动作、服装、场景等。
AI绘画：改变穿衣风格
AI绘画：小女孩的不同年龄段展示
AI绘画：不同社交平台的个性头像创作
Diagrams: Show Me
画一个用户登录鉴权的UML图
上传PDF并阅读分析
好用的功能太多太多，我就不在这个一一列举了，有兴趣的可以自行尝试。
👉 GPT功能：ChatGPT4.0知识问答、DALL-E生成AI图片、Code Copilot辅助编程、毕设去重、BUG解决、代码优化、精读分析PDF+Word…
👉使用地址：我的GPT4
👉也可以私信哪吒，备注：AI，先体验，好用才是硬道理，领取价值30元的授权码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ce8e34f21a47c1fdbaa85772970c771/" rel="bookmark">
			【前端篇】微信小程序ActionSheet封装 -- 封装特性，开发只需要关注功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好啊，这次来分享一下小程序开发的一个使用封装。
背景 先来看下什么是ActionSheet，参考下图（来源：豆流便签）
参考原生代码实现：
wx.showActionSheet({ itemList: ["action1", "action2"], success: (res) =&gt; { if (res.tapIndex === 0) { // do action 1 }else if (res.tapIndex === 1){ // do action 2 } }, fail: (res) =&gt; { console.log(res.errMsg) } }) action sheet的优点：
实现简单符合微信操作风格 但是原生的这种写法是比较繁琐的，我们很容易在wx.showActionSheet方法里放入大量逻辑代码，层级变的很高。
另一个致命问题，则是如果action是动态的，比如需要根据权限决定是否展示删除功能等，原生api方法需要写大量if else，还需要额外判断动态itemList和执行逻辑之间的关系。
所以这次带来一个开箱即用的action sheet代码。
封装实现 先看下封装后的操作代码：
let actionMenu = new ActionSheetMenu() if (admin) { actionMenu.addMenu("删除", () =&gt; { // do del logic }) } actionMenu.addMenu("复制", () =&gt; { // do copy logic }) actionMenu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ce8e34f21a47c1fdbaa85772970c771/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6cc793d51c9cf90b684a14afbfd1f11/" rel="bookmark">
			太原理工大学大数据期末简答题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.简述大数据云计算与物联网三者之间的区别和联系
区别：大数据侧重于对海量数据存储处理分析，云计算旨在整合和优化各种IT资源，物联网发展目标是实现物物相连
联系:云计算为大数据提供了技术基础,大数据为云计算提供了用武之地。物联网是大数据重要来源，大数据为物联网数据分析提供支撑。云计算为物联网提供了海量数据存储能力，物联网为云计算提供了广阔的应用空间。
2.名称节点和数据节点各自的功能
名称节点负责管理分布式文件系统的命名空间，Fsimage用于维护文件系统数据文件系统处中所有文件和文件夹的元数据，EditLog用于维护用于记录所有文件的创建删除重命名的操作；而数据节点是负责数据存储和读取。
3.名称节点的工作过程
名称节点在启动时，FsImage的内容加载到内存中然后执行EditLog文件中的各项操作，这个操作完成后就会创造一个FsImage和一个空的EditLog。在名称节点启动并正常运行后，HDFS的更新操作就会被写入EditLog
4.第二名称节点工作过程
第二名称节点会要求第一名称节点停止使用EditLog，将新到达的操作写入EditLog.new中，然后把FsImage和EditLog拉回本地，将两者进行合并，生成FsImage文件，第一名称节点会用这个去代替旧的FsImage，用EditLog.new代替EditLog。
5.HDFS的冗余数据保存策略
在集群内挑选一台磁盘充足、CPU不太忙的数据节点作为第一个副本存放点；第二副本存放点在与第一个副本不同机架的数据节点；第三副本存放在与第一副本存放点相同机架的不同节点；第四副本存放点从集群中随机挑选节点。
6.数据复制主要是在数据写入和数据恢复的时候发生，HDFS数据复制是使用流水线复制的策略，请阐述该策略的细节
每个块都会向HDFS集群中的名称节点发出写请求，名称节点会返回一个数据节点列表给客户端，客户端将数据写入列表中第一个数据节点时，同时把列表传给第一个数据节点；第一个节点在接收到数据写入本地的同时，会把数据传给第二个数据节点，同时第二个数据节点接收到数据时，会在写入的同时将数据发送给第三个节点，以此类推。
7.请阐述HBase和BigTable底层技术的对应关系
8. 试述HBase各功能组件及其作用
库函数：链接到每一个客户端
一个Master主服务器：管理和维护HBase表的分区信息和Region服务器列表及Region服务器，处理模式变化
多个Region服务器（核心）：维护和分配给自己的Region，响应用户读写操作
9.试述HBase系统基本架构以及每个组成部分的作用
客户端：访问Hbase的接口，同时在缓存中维护已经访问过的Region位置信息
Zookeeper服务器：帮助维护当前的集群中机器的服务状态，帮助选出一个“总管”，即保证在任何时刻总有唯一一个Master在运行（监听Region反应给Master）
Master：负责表和Region的管理工作。管理用户对表的增删改查操作；实现Region服务器之间的负载平衡；负责重新调整Region的分布；对发生故障失效的Region服务器上的Region数据进行迁移
Region服务器：负责维护分配给自己的Region，响应用户的读写请求
10.试述HBase的三层结构中各层次的名称作用，以及三级寻址的过程
Zookeeper：记录-Root表的位置信息
-RooT表：记录.META表的Region信息（只有一个）
.MATE.表：记录用户数据表的Region信息（多个）
过程：首先通过Zookeeper获取-Root表的位置信息，然后访问-Root表得到.MATE表的位置信息，访问.MATE表，找到对应的Region位于哪个Region服务器上，再到相应的服务器上读取数据。
11.请阐述Region服务器向HDFS文件系统中读写数据的基本原理
用户写入数据时，分配相应的Region服务器去执行，首先会将数据写入MemStore和HLog中，commit（）调用才会返回给客户端
用户读取数据时，Region服务器会先访问MemStore，如果数据不在缓存中才会去磁盘的StoreFile中寻找
12.试述HLog的工作原理
HBase系统为每个Region服务器配置了一个HLog文件，用户更新数据必须首先被计入日志后才能写入MemStore缓存（预写式日志），并且直到MemStore缓存内容对应的日志已经被写入磁盘之后，该缓存内容才会被刷新写入磁盘。
13.NoSQL数据库的四大类型（括号里是缺点）
键值数据库：使用哈希表，表中有一个特定的key和一个指针指向的value，key用来定位value（条件查询效率低）
列族数据库：采样列族数据模型，数据库由多行构成，不同行可以有多个列族，属于同一列族的数据放在一起（功能少，大多不支持事务一致性）
文档数据库：文档作为最小单位，文档以某种标准化格式封装加密数据（缺乏统一的数据查询语言）
图数据库：使用图来存储数据（复杂性高，只支持一定数据规模）
14.试述CAP理论的具体含义（三选二）
C：一致性，多点分布环境中，多点的数据是一致的。
A：可用性，指能够快速获取数据，可以在确定的时间内返回操作结果。
P：分区容忍性，指出现网络分区的情况时，分离的系统也能正常运行。
15.试述数据库的ACID四性的含义
原子性、一致性、隔离性、持久性
16.试述JobTracker和TaskTracker的功能
JobTracker监测每个Map任务结束后，通知相关的Reduce任务来领取数据
TaskTracker执行由JobTracker指派的任务
17.分别描述Map端和Reduce端的Shuffle过程
Map端：输入数据和执行map任务、写入缓存、溢写（分区、排序和合并）、文件归并
Reduce端：领取数据、归并数据、把数据输入Reduce任务
18.请描述YARN架构中各组件的功能，工作过程
ResourceManager：处理客户端请求；启动/监控ApplicationMaster；监控NodeManager；资源分配与调度。
ApplicationMaster：为应用程序申请资源，并二次分配给内部任务；任务调度、监控与容错。
NodeManager：单个节点上的资源管理，处理来自ResourceManager的命令；处理来自ApplicationMaster的命令。
过程：
1） 用户编写客户端应用程序，向YARN提交应用程序；
2） ResourceManager接到客户端应用程序请求后，为应用程序分配一个容器；同时与该容器的NodeManager通信，为该应用程序在容器中启动一个ApplicationMaster；
3） ApplicationMaster向ResourceManager注册；
4） ApplicaitonMaster采用轮询的方式通过RPC协议向ResourceMaster申请资源；
5） ResourceManager以容器的形式分配资源，一旦ApplicationMaster申请到资源之后，就会与该容器坐在的NodeManager进行通信，要求它启动任务；
6） 当容器启动任务时，Application会设置好运行环境，然后将任务启动命令写到一个脚本中，最后通过在容器中运行该脚本来启动任务；
7） 各个任务通过PRC协议向AppicationMaster汇报自己的状态和进度；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6cc793d51c9cf90b684a14afbfd1f11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8660631819f5fa470fde4c64e82f1e2c/" rel="bookmark">
			数据结构算法——链表带环问题——数学深度解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言:本节内容主要是讲解链表的两个问题 ：1、判断链表是否带环； 2、一个链表有环， 找到环的入口点。 本节内容适合正在学习链表或者链表基础薄弱的友友们哦。
我们先将问题抛出来，友友们可以自己去力扣或者牛客网去找相应题目， 这里直接贴链接：（没有做过这两个题的友友 千万！ 千万！ 千万！ 要先自己做一下这两个题。)
判断链表是否带环：141. 环形链表 - 力扣（LeetCode）
带环链表的入环节点：LCR 022. 环形链表 II - 力扣（LeetCode）
目录
判断链表是否带环
题目解析
算法原理
算法演示
算法原理
原理扩展
环形链表的入口节点
题目解析
算法原理
算法演示
算法原理
我们先来讲解第一道题
判断链表是否带环 题目解析 题目：
代码框：
题目非常的简单， 就是要求我们设计一个算法， 判断这个链表中是否右带环结构就可以了。 如果有带环结构， 那么就返回true， 如果没有带环结构， 那么就返回false。 算法原理 算法演示 解决这个问题需要用到快慢双指针算法， 我们利用题中所给示例进行演示:
先定义两个指针slow， fast。并且slow和fast要指向同时指向头节点， 否则在第二道题的时候处理起来会变的复杂。(具体为什么会变得复杂请友友们现在不要深究， 第二题的时候会讲到的， 到时再思考就行啦)
然后， 我们向后进行遍历， 遍历的过程是这样的： slow指针一次向后移动一个节点。 fast一次向后移动两个节点。当两个节点相遇的时候就说明我们的链表是带环的。
而如果我们的fast指向了空节点， 那么就说明我们的链表是不带环的。
我们演示一遍是这样的：
代码贴图如下：
bool hasCycle(struct ListNode *head) { //先判断下链表为空的情况 if (head == NULL) return false; //1、创建两个指针， slow, fast同时指向链表头节点。 struct ListNode* slow = head; struct ListNode* fast = head; //2、遍历整个链表， 判断是否有环 while (fast !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8660631819f5fa470fde4c64e82f1e2c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/24/">«</a>
	<span class="pagination__item pagination__item--current">25/71</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/26/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>