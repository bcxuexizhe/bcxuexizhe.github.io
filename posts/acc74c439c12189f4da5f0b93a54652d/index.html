<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端几种下载文件的方式(url方式和文件流方式) - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/acc74c439c12189f4da5f0b93a54652d/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="前端几种下载文件的方式(url方式和文件流方式)">
  <meta property="og:description" content="前端实现下载功能是依赖于浏览器特性，而非JS特性
第一种 a标签 前端创建超链接，通过a标签向后端发送get请求，需要给a标签添加一个download属性
这种写法是创造了一个a标签，把地址写到a标签里再用js调用点击，实现访问文件地址就是下载了
代码如下:
html &lt;a @click=&#34;downloadFile(file.url,file.originalFilename, file.id, file.fileTye)&#34;&gt;下载&lt;/a&gt; // 参数分别是：文件的路径 文件的名字 文件的id 文件的类型 js downloadFile(url, fileName, flieId, type) { let link = document.createElement(&#39;a&#39;); link.style.display = &#39;none&#39;; link.href = baseUrl &#43; &#39;/xxx/xxx/xxx?flieId=&#39; &#43; flieId; document.body.appendChild(link); link.click(); }, 或者 &lt;a :href=&#39;&#34;/user/downloadExcel&#34;&#39; &gt;下载模板&lt;/a&gt; //另一种情况是创建div标签，动态创建a标签： &lt;div name=&#34;downloadfile&#34; &#34;downloadExcel()&#34;&gt;下载&lt;/div&gt; function downloadExcel() { let a = document.createElement(&#39;a&#39;) a.href =&#34;/xxx/xxx&#34; a.click(); } 直接下载 a标签的href属性指定下载文件的路径,需要给a标签添加一个download属性，download指定下载文件保存时的名称。
&lt;a href=&#34;https://106.14.15.103:8000/downloadFile/test&#34; download=&#34;test.txt&#34;&gt;下载&lt;/a&gt; 第二种 通过window.open()下载 window.open就是打开了一个新网页直接在新网页访问文件地址了，只要访问文件地址，就能下载文件。这时候后端返回的是文件流直接渲染,不需要url再打开下载了
downloadFile() { window.open( baseUrl &#43; &#39;/xxx/xxx/xxx/getTemplate?">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-25T15:56:02+08:00">
    <meta property="article:modified_time" content="2024-03-25T15:56:02+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端几种下载文件的方式(url方式和文件流方式)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="background-color:#ffd900;">前端实现下载功能是依赖于浏览器特性，而非JS特性</span></p> 
<h2><br> 第一种 a标签</h2> 
<p>前端创建超链接，通过a标签向后端发送get请求，需要给a标签添加一个download属性<br> 这种写法是创造了一个a标签，把地址写到a标签里再用js调用点击，实现访问文件地址就是下载了<br> 代码如下:</p> 
<h6>html</h6> 
<pre><code class="language-javascript">   &lt;a @click="downloadFile(file.url,file.originalFilename, file.id, file.fileTye)"&gt;下载&lt;/a&gt;
   // 参数分别是：文件的路径 文件的名字 文件的id 文件的类型
</code></pre> 
<h6>js</h6> 
<pre><code class="language-javascript">  downloadFile(url, fileName, flieId, type) {
     let link = document.createElement('a');
     link.style.display = 'none';
     link.href = baseUrl + '/xxx/xxx/xxx?flieId=' + flieId;
     document.body.appendChild(link);
     link.click();
   },
</code></pre> 
<h6>或者</h6> 
<pre><code class="language-javascript">&lt;a :href='"/user/downloadExcel"' &gt;下载模板&lt;/a&gt;

//另一种情况是创建div标签，动态创建a标签：
&lt;div name="downloadfile" "downloadExcel()"&gt;下载&lt;/div&gt;
function downloadExcel() {
    let a = document.createElement('a')
    a.href ="/xxx/xxx"
    a.click();
} 

</code></pre> 
<h6>直接下载</h6> 
<p>a标签的href属性指定下载文件的路径,需要给a标签添加一个download属性，download指定下载文件保存时的名称。</p> 
<pre><code class="language-javascript">&lt;a href="https://106.14.15.103:8000/downloadFile/test" download="test.txt"&gt;下载&lt;/a&gt;
</code></pre> 
<h2>第二种 通过window.open()下载</h2> 
<p>window.open就是打开了一个新网页直接在新网页访问文件地址了，只要访问文件地址，就能下载文件。这时候后端返回的是文件流直接渲染,不需要url再打开下载了</p> 
<pre><code class="language-javascript">  downloadFile() {
    window.open(
      baseUrl + '/xxx/xxx/xxx/getTemplate?templateCode=manual_pc',
      '_self'
    );
  },
</code></pre> 
<h2>第三种 通过创建iframe的方式</h2> 
<pre><code class="language-javascript">&lt;el-button  size="mini" @click="handleExport(scope.row)"&gt;导出&lt;/el-button&gt;
//method方法：
handleExport(row) {
      var elemIF = document.createElement('iframe')
      elemIF.src = 'user/downloadExcel?snapshotTime=' + formatDate(new Date(row.snapshotTime), 'yyyy-MM-dd hh:mm') +
                    '&amp;category=' + row.category 
      elemIF.style.display = 'none'
      document.body.appendChild(elemIF)
    }
</code></pre> 
<h2>第四种 以文件流的形式，会对后端发post请求，使用blob格式，这种写法对于图片和pdf及svg能实现下载功能</h2> 
<pre><code class="language-javascript">$http({
   url: this.$http.adornUrl(`/strUrl/${id}`),
   method: 'get',
   responseType: 'blob',
   timeout: 1000 * 600
 }).then(res =&gt; {
   console.log('res', res)
   if (res.status === 200) {
     const blob = new Blob([res.data], { type: `application/octet-stream` })
     const downloadElement = document.createElement('a')
     const href = window.URL.createObjectURL(blob)
     downloadElement.href = href
     downloadElement.download = `${filename}`
     downloadElement.click()
   } else {
     Elmessage.error('下载出错!')
   }
 })
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/538a5951f8359a20b0a03e761b4cb152/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【喂饭级AI教程】手把手教你在本机安装Stable Diffusion秋包【附带全套资源】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/107227b0d9e85b6d91c82ecf9fac1a72/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">值得收藏！2024年人工智能顶级会议投稿信息汇总（大数据领域）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>