<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java之抽象类和接口 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/3a0ba73b538d79ac83657ca390e79f1f/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Java之抽象类和接口">
  <meta property="og:description" content="一、抽象类 1.抽象类概念 如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类， 比如动物类。没有实际工作的方法 , 我们可以把它设计成一个 抽象方法， 包含抽象方法的类我们称为 抽象类。 2.抽象类语法 在Java中，一个类如果被 abstract 修饰称为抽象类，抽象类中被 abstract 修饰的方法称为抽象方法，抽象方法不用给出具体的实现体。
// 抽象类：被abstract修饰的类 public abstract class Shape { // 抽象方法：被abstract修饰的方法，没有方法体 abstract public void draw(); abstract void calcArea(); // 抽象类也是类，也可以增加普通方法和属性 public double getArea(){ return area; } protected double area; // 面积 } 注意：抽象类也是类，内部可以包含普通方法和属性，甚至构造方法 3. 抽象类特性 1. 抽象类不能直接实例化对象
Shape shape = new Shape(); // 编译出错 Error:(30, 23) java: Shape是抽象的; 无法实例化 2.抽象方法不能被final和static和private修饰，因为抽象方法要被子类重写
public abstract class Shape { abstract private void draw(); abstract final void methodA(); abstract public static void methodB(); } // 编译报错： //Error:(19, 27) java: 非法的修饰符组合: abstract和private // Error:(20, 25) java: 非法的修饰符组合: abstract和final // Error:(21, 33) java: 非法的修饰符 4.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-30T16:56:27+08:00">
    <meta property="article:modified_time" content="2024-04-30T16:56:27+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java之抽象类和接口</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、抽象类</h3> 
<h4>1.抽象类概念 </h4> 
<div> 
 <span style="color:#333333;">如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是<strong>抽象类，</strong></span> 
 <span style="color:#333333;">比如动物类。没有实际工作的方法</span> 
 <span style="color:#333333;">, </span> 
 <span style="color:#333333;">我们可以把它设计成一个 </span> 
 <span style="color:#333333;"><strong>抽象方法，</strong></span> 
 <span style="color:#333333;">包含抽象方法的类我们称为</span> 
 <span style="color:#333333;"><strong>抽象类。</strong></span> 
</div> 
<h4>2.抽象类语法</h4> 
<div> 
 <p><span style="color:#333333;">在</span><span style="color:#333333;">Java</span><span style="color:#333333;">中，一个类如果被 </span><span style="color:#333333;">abstract </span><span style="color:#333333;">修饰称为抽象类，抽象类中被 </span><span style="color:#333333;">abstract 修饰的方法称为抽象方法，抽象方法不用给出具体的实现体。</span></p> 
 <pre><code class="language-java">// 抽象类：被abstract修饰的类
public abstract class Shape {
// 抽象方法：被abstract修饰的方法，没有方法体
abstract public void draw();
abstract void calcArea();
// 抽象类也是类，也可以增加普通方法和属性
public double getArea(){
return area;
}
protected double area; // 面积
}</code></pre> 
 <blockquote> 
  <div> 
   <span style="color:#333333;"><strong>注意：抽象类也是类，内部可以包含普通方法和属性，甚至构造方法 </strong></span> 
  </div> 
 </blockquote> 
</div> 
<h4><span style="color:#333333;"><strong>3. </strong></span><span style="color:#333333;"><strong>抽象类特性 </strong></span></h4> 
<p><span style="color:#333333;">1. </span><span style="color:#333333;">抽象类不能直接实例化对象</span></p> 
<pre><code class="language-java">Shape shape = new Shape();
// 编译出错
Error:(30, 23) java: Shape是抽象的; 无法实例化</code></pre> 
<div> 
 <p><span style="color:#333333;">2.抽象方法不能被final</span><span style="color:#333333;">和static和private修饰，因为抽象方法要被子类重写</span></p> 
 <pre><code class="language-java">public abstract class Shape {
abstract private void draw();
abstract final void methodA();
abstract public static void methodB();
}
// 编译报错：
//Error:(19, 27) java: 非法的修饰符组合: abstract和private
// Error:(20, 25) java: 非法的修饰符组合: abstract和final
// Error:(21, 33) java: 非法的修饰符</code></pre> 
 <p><span style="color:#333333;">4. </span><span style="color:#333333;">抽象类就是用来被继承的，并且继承后子类要重写父类中的抽象方法，否则子类也必须是抽象类</span></p> 
 <pre><code class="language-java">// 抽象类：被abstract修饰的类
 abstract public class Shape {
    // 抽象方法：被abstract修饰的方法，没有方法体
    abstract public void draw();
  
}
class X extends Shape{
    @Override
    public void draw() {
   
    }
}
//这里不要重写抽象方法
abstract class B extends Shape{
    abstract public void shope();
}
//下面补充了抽象方法（欠的债始终要还的）
class C extends B{
    @Override
    public void draw() {
        
    }
    @Override
    public void shope() {
       
    }
}
</code></pre> 
 <div> 
  <span style="color:#333333;">5. 抽象类中不一定包含抽象方法，但是有抽象方法的类一定是抽象类<br> 6. 抽象类中可以有构造方法，供子类创建对象时，初始化父类的成员变量</span> 
 </div> 
 <h4 style="background-color:transparent;"><span style="color:#333333;"><strong>4. </strong></span><span style="color:#333333;"><strong>抽象类的作用 </strong></span></h4> 
 <div> 
  <span style="color:#333333;">使用抽象类相当</span> 
  <span style="color:#0d0016;">于</span> 
  <span style="color:#fe2c24;"><strong>多了一重编译器的校验</strong></span> 
  <span style="color:#333333;"><strong>,</strong>我们多态中应该已经知道了父类其实没有多大作用，经常当作抽象类使用，</span> 
  <span style="color:#333333;">使用抽象类的场景好比多态，</span> 
  <span style="color:#333333;">实际工作不应该由父类完成</span> 
  <span style="color:#333333;">, </span> 
  <span style="color:#333333;">而应由子类完成</span> 
  <span style="color:#333333;">. </span> 
  <span style="color:#333333;">那</span> 
  <span style="color:#fe2c24;"><strong>么此时如果不重写抽象方法，将报错。</strong></span> 
 </div> 
</div> 
<h3>二、接口基础</h3> 
<h4><span style="color:#333333;"><strong>1.</strong></span><span style="color:#333333;"><strong>接口的概念 </strong></span></h4> 
<div> 
 <span style="color:#333333;">接口就是公共的行为规范标准，大家在实现时，只要符合规范标准，就可以通用。</span> 
 <span style="color:#333333;">在</span> 
 <span style="color:#333333;">Java</span> 
 <span style="color:#333333;">中，接口可以看成是：多个类的公共规范，是一种引用数据类型。</span> 
</div> 
<div> 
 <span style="color:#333333;">而如果有一个动物父类，他的子类就只能写动物，不够灵活。并且不是所有动物会飞会游泳会跑，所以不好在父类中写这些方法（语法没问题，但语义出现问题）。所以我们提供接口，只要会飞，不管你是不是动物。更加灵活。而且可以多实现。</span> 
</div> 
<h4><span style="color:#333333;"><strong>2.</strong></span><span style="color:#333333;"><strong>语法规则</strong></span></h4> 
<p><span style="color:#333333;">接口的定义格式与定义类的格式基本相同，将</span><span style="color:#333333;">class</span><span style="color:#333333;">关键字换成 </span><span style="color:#333333;">interface </span><span style="color:#333333;">关键字，就定义了接口。 </span></p> 
<pre><code>public interface 接口名称{
// 抽象方法
public abstract void method1(); // public abstract 是固定搭配，可以不写
public void method2();
abstract void method3();
void method4();
// 注意：在接口中上述写法都是抽象方法，更推荐方式4，代码更简洁
}</code></pre> 
<h4 style="background-color:transparent;"><span style="color:#333333;"><strong>3.接口使用</strong></span></h4> 
<p><span style="color:#333333;"><strong>1.接口不能直接使用，必须要有一个</strong></span><span style="color:#333333;"><strong>"</strong></span><span style="color:#333333;"><strong>实现类</strong></span><span style="color:#333333;"><strong>"</strong></span><span style="color:#333333;"><strong>来</strong></span><span style="color:#333333;"><strong>"</strong></span><span style="color:#333333;"><strong>实现</strong></span><span style="color:#333333;"><strong>"</strong></span><span style="color:#333333;"><strong>该接口，实现接口中的所有抽象方法</strong></span></p> 
<pre><code>public class 类名称 implements 接口名称{
// ...
}</code></pre> 
<blockquote> 
 <p><span style="color:#333333;">注意：子类和父类之间是</span><span style="color:#333333;">extends </span><span style="color:#333333;">继承关系，类与接口之间是</span><span style="color:#333333;"> implements </span><span style="color:#333333;">实现关系。</span></p> 
</blockquote> 
<p>例题：<span style="color:#333333;">请实现笔记本电脑使用</span><span style="color:#333333;">USB</span><span style="color:#333333;">鼠标、</span><span style="color:#333333;">USB</span><span style="color:#333333;">键盘的例子</span></p> 
<pre><code>// USB接口
public interface USB {
    void openDevice();
    void closeDevice();
}
// 鼠标类，实现USB接口
 class Mouse implements USB {
    @Override
    public void openDevice() {
        System.out.println("打开鼠标");
    }@Override
public void closeDevice() {
        System.out.println("关闭鼠标");
        }
public void click(){
        System.out.println("鼠标点击");
        }
        }
// 键盘类，实现USB接口
 class KeyBoard implements USB {
    @Override
    public void openDevice() {
        System.out.println("打开键盘");
    }
    @Override
    public void closeDevice() {
        System.out.println("关闭键盘");
    }
    public void inPut(){
        System.out.println("键盘输入");
    }
}
// 笔记本类：使用USB设备
class Computer {
    public void powerOn(){
        System.out.println("打开笔记本电脑");
    }
    public void powerOff(){
        System.out.println("关闭笔记本电脑");
    }
    public void useDevice(USB usb){
        usb.openDevice();
        if(usb instanceof Mouse){
            Mouse mouse = (Mouse)usb;
            mouse.click();
        }else if(usb instanceof KeyBoard){
            KeyBoard keyBoard = (KeyBoard)usb;
            keyBoard.inPut();
        }
        usb.closeDevice();
    }
}
class TestUSB {
    public static void main(String[] args) {
        Computer computer = new Computer();
        computer.powerOn();
// 使用鼠标设备
        computer.useDevice(new Mouse());
// 使用键盘设备
        computer.useDevice(new KeyBoard());
        computer.powerOff();
    }
}

//输出结果
打开笔记本电脑
打开鼠标
鼠标点击
关闭鼠标
打开键盘
键盘输入
关闭键盘
关闭笔记本电脑

</code></pre> 
<h4 style="background-color:transparent;">4.接口特征</h4> 
<div> 
 <span style="color:#333333;">1. </span> 
 <span style="color:#333333;">接口类型是一种引用类型，但是不能直接</span> 
 <span style="color:#333333;">new</span> 
 <span style="color:#333333;">接口的对象</span> 
</div> 
<div> 
 <pre><code>public class TestUSB {
public static void main(String[] args) {
USB usb = new USB();
}
}
// Error:(10, 19) java: day20210915.USB是抽象的; 无法实例化</code></pre> 
 <div> 
  <span style="color:#333333;">2. </span> 
  <span style="color:#333333;">接口中每一个方法都是</span> 
  <span style="color:#333333;">public</span> 
  <span style="color:#333333;">的方法</span> 
  <span style="color:#333333;">, </span> 
  <span style="color:#333333;">即接口中的方法会被隐式的指定为 </span> 
  <span style="color:#333333;"><strong>public abstract</strong></span> 
  <span style="color:#333333;">（只能是public abstract，其他修饰符都会报错</span> 
 </div> 
</div> 
<div></div> 
<div></div> 
<div> 
 <span style="color:#333333;">3. </span> 
 <span style="color:#333333;">接口中的方法是不能在接口中实现的，只能由实现接口的类来实现 </span> 
</div> 
<div> 
 <pre><code>public interface USB {
void openDevice();
// 编译失败：因为接口中的方式默认为抽象方法
// Error:(5, 23) java: 接口抽象方法不能带有主体
void closeDevice(){
System.out.println("关闭USB设备");
}
}</code></pre> 
 <div> 
  <span style="color:#333333;">4.在子类</span> 
  <span style="color:#333333;">重写接口中方法时，只能为public</span> 
 </div> 
 <div> 
  <span style="color:#333333;">5. </span> 
  <span style="color:#333333;">接口中可以含有变量，但是接口中的变量会被隐式的指定为 </span> 
  <span style="color:#333333;"><strong>public static final静态常量</strong></span> 
 </div> 
 <div> 
  <span style="color:#333333;">6. </span> 
  <span style="color:#333333;">接口中不能有代码块和构造方法</span> 
 </div> 
 <div> 
  <div> 
   <span style="color:#333333;">7. </span> 
   <span style="color:#333333;">接口虽然不是类，但是接口编译完成后字节码文件的后缀格式也是</span> 
   <span style="color:#333333;">.class </span> 
  </div> 
  <div> 
   <span style="color:#333333;">8. </span> 
   <span style="color:#333333;">如果类没有实现接口中的所有的抽象方法，则类必须设置为抽象类 </span> 
  </div> 
  <div> 
   <span style="color:#333333;">9. jdk8后</span> 
   <span style="color:#333333;">：接口中还可以包含</span> 
   <span style="color:#333333;">default</span> 
   <span style="color:#333333;">方法和静态方法。这两个方法可以有方法体。即可以实现方法了。</span> 
  </div> 
  <div> 
   <pre><code>public interface MyInterface {
    // 抽象方法
    void abstractMethod();
    // 默认方法
    default void defaultMethod() {
        System.out.println("This is a default method.");
    }
    // 静态方法
    static void staticMethod() {
        System.out.println("This is a static method.");
    }
    }
</code></pre> 
  </div> 
 </div> 
</div> 
<div></div> 
<h3 style="background-color:transparent;"><span style="color:#333333;"><strong>三、多接口</strong></span></h3> 
<h4 style="background-color:transparent;"><span style="color:#333333;"><strong>1.实现多个接口</strong></span></h4> 
<p><span style="color:#333333;">在Java</span><span style="color:#333333;">中，类和类之间是单继承的，一个类只能有一个父类，即</span><span style="color:#333333;"><strong>Java</strong></span><span style="color:#333333;"><strong>中不支持多继承</strong></span><span style="color:#333333;">，但是</span><span style="color:#333333;"><strong>一个类可以实现多个接</strong></span><span style="color:#333333;"><strong>口</strong></span><span style="color:#333333;">。下面通过类来表示一组动物</span><span style="color:#333333;">. </span></p> 
<div> 
 <pre><code>class Animal {
protected String name;
public Animal(String name) {
this.name = name;
}
}</code></pre> 
 <div> 
  <span style="color:#333333;">另外我们再提供一组接口</span> 
  <span style="color:#333333;">, </span> 
  <span style="color:#333333;">分别表示</span> 
  <span style="color:#333333;"> "</span> 
  <span style="color:#333333;">会飞的</span> 
  <span style="color:#333333;">", "</span> 
  <span style="color:#333333;">会跑的</span> 
  <span style="color:#333333;">", "</span> 
  <span style="color:#333333;">会游泳的</span> 
  <span style="color:#333333;">". </span> 
 </div> 
 <div> 
  <div></div> 
  <div> 
   <pre><code>interface IFlying {
void fly();
}
interface IRunning {
void run();
}
interface ISwimming {
void swim();
}</code></pre> 
   <div> 
    <span style="color:#333333;">接下来我们创建几个具体的动物 </span> 
   </div> 
   <div> 
    <span style="color:#333333;">猫</span> 
    <span style="color:#333333;">, </span> 
    <span style="color:#333333;">是会跑的</span> 
    <span style="color:#333333;">.</span> 
   </div> 
   <div> 
    <pre><code>class Cat extends Animal implements IRunning {
public Cat(String name) {
super(name);
}
@Override
public void run() {
System.out.println(this.name + "正在用四条腿跑");
}
}</code></pre> 
    <div> 
     <span style="color:#333333;">鱼</span> 
     <span style="color:#333333;">, </span> 
     <span style="color:#333333;">是会游的</span> 
     <span style="color:#333333;">. </span> 
    </div> 
    <div> 
     <pre><code>class Fish extends Animal implements ISwimming {
public Fish(String name) {
super(name);
}
@Override
public void swim() {
System.out.println(this.name + "正在用尾巴游泳");
}
}</code></pre> 
     <div> 
      <span style="color:#333333;">青蛙</span> 
      <span style="color:#333333;">, </span> 
      <span style="color:#333333;">既能跑</span> 
      <span style="color:#333333;">, </span> 
      <span style="color:#333333;">又能游</span> 
      <span style="color:#333333;">(</span> 
      <span style="color:#333333;">两栖动物</span> 
      <span style="color:#333333;">)</span> 
     </div> 
     <div> 
      <pre><code>class Frog extends Animal implements IRunning, ISwimming {
public Frog(String name) {
super(name);
}
@Override
public void run() {
System.out.println(this.name + "正在往前跳");
}
@Override
public void swim() {
System.out.println(this.name + "正在蹬腿游泳");
}
}</code></pre> 
      <blockquote> 
       <div> 
        <span style="color:#333333;"><strong>注意：一个类实现多个接口时，每个接口中的抽象方法都要实现，否则类必须设置为抽象类</strong></span> 
        <span style="color:#333333;">。</span> 
       </div> 
      </blockquote> 
      <div> 
       <span style="color:#333333;">鸭子会飞会跑会游泳</span> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div> 
  <div></div> 
  <div> 
   <pre><code>class Duck extends Animal implements IRunning, ISwimming, IFlying {
public Duck(String name) {
super(name);
}
@Override
public void fly() {
System.out.println(this.name + "正在用翅膀飞");
}
@Override
public void run() {
System.out.println(this.name + "正在用两条腿跑");
}
@Override
public void swim() {
System.out.println(this.name + "正在漂在水上");
}
}</code></pre> 
   <div> 
    <span style="color:#333333;">上面的代码展示了</span> 
    <span style="color:#333333;"> Java </span> 
    <span style="color:#333333;">面向对象编程中最常见的用法</span> 
    <span style="color:#333333;">: </span> 
    <span style="color:#fe2c24;">一个类继承一个父类, 同时实现多种接口. </span> 
   </div> 
   <div> 
    <span style="color:#fe2c24;">继承表达的含义是 is - a 语义, 而接口表达的含义是 具有 xxx 特性 </span> 
    <span style="color:#333333;">. </span> 
   </div> 
   <div> 
    <blockquote> 
     <div>
       因为多继承带来的菱形问题，我们出现了接口，当类要共享代码时或者有is-a关系用继承，当一个类要实现多个不同的功能时，用接口。 
     </div> 
    </blockquote> 
    <div> 
     <h4 style="background-color:transparent;"><span style="color:#333333;"><strong>2.</strong></span><span style="color:#333333;"><strong>接口间的继承 </strong></span></h4> 
     <div> 
      <span style="color:#333333;">接口可以继承一个接口</span> 
      <span style="color:#333333;">, </span> 
      <span style="color:#333333;">达到扩展的效果</span> 
      <span style="color:#333333;">. </span> 
      <span style="color:#333333;">使用</span> 
      <span style="color:#333333;"> extends </span> 
      <span style="color:#333333;">关键字.</span> 
      <span style="color:#777777;">接口间的继承相当于把多个接口合并在一起</span> 
      <span style="color:#777777;">. </span> 
     </div> 
     <div> 
      <pre><code>interface IRunning {
void run();
}
interface ISwimming {
void swim();
}
// 两栖的动物, 既能跑, 也能游
interface IAmphibious extends IRunning, ISwimming {
}
class Frog implements IAmphibious {
...
}</code></pre> 
     </div> 
    </div> 
   </div> 
  </div> 
  <h3 style="background-color:transparent;">四、常用接口实例</h3> 
  <p>java标准库中提供了多种默认接口。</p> 
  <p>1.比较引用类型时可以使用comparable接口，位于java.long包中，这个包是由虚拟机自动导入的，故使用该接口时不需要显示引用包名。该接口中有一个comparto方法（观察源码知道该方法只是说明要一个参数，本身不能比较，故要重写该方法）</p> 
  <pre><code> public class Students implements Comparable&lt;Students&gt; {
     public String name;
     public int age;
     public Students(String name, int age) {
         this.name = name;
         this.age = age;
     }
     @Override
     public int compareTo(Students o) { //重写comparto方法，若返回正数students大于students1，相等返回0，小于返回负数
         return this.age - o.age;
     }
     public static void main(String[] args) {
         Students students = new Students("huihuang", 3);
         Students students1 = new Students("zuihuang", 4);
        // System.out.println(students &gt; students1);//引用类型不能直接比较
         System.out.println(students.compareTo(students1));
     }
 }
//输出结果-1</code></pre> 
  <p>以上接口的缺点是我们如果要按里面名字进行比较，要写一个comparto方法替换原来的，如果有用户用你这个代码，你修改了，这会出问题。</p> 
  <p>2.比较引用类型时可以使用comparator接口，该接口在import java.util.Comparator类包中，该接口有一个compar方法（观察源码知道该方法只是说明要两个参数，本身不能比较，故要重写该方法）</p> 
  <pre><code>import java.util.Comparator;
public class Student {
    public String name;
    public int age;
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
    class AgeComparator implements Comparator&lt;Student&gt; {//比较age

        @Override
        public int compare(Student o1, Student o2) {
            return o1.age - o2.age ;
        }
    }


class S {
    public static void main(String[] args) {
        Student students = new Student("huihuang", 3);
        Student students1 = new Student("zuihuang", 4);
        AgeComparator ageComparator = new AgeComparator();
        System.out.println(ageComparator.compare(students, students1));
    }
}
//输出结果-1</code></pre> 
  <p>如果要根据name比较呢，引用类型不能直接减，所以我们String类中实现了 Comparable 接口，并重写了 compareTo 方法。String 类的 compareTo 方法用于比较两个字符串的大小，compareTo 方法的实现比较两个字符串中的字符，从第一个字符开始，如果当前字符小于参数字符串中的对应字符，则返回一个负数；如果当前字符大于参数字符串中的对应字符，则返回一个正数；如果当前字符等于参数字符串中的对应字符，则继续比较下一个字符，直到找到不相等的字符或者其中一个字符串结束。如果两个字符串相等，则返回 0。见以下代码</p> 
  <pre><code>......
class NameComparator implements Comparator&lt;Student&gt; {
    @Override
    public int compare(Student o1, Student o2) {

        //String  自己重写的 compareTo 方法
        return o1.name.compareTo(o2.name);
    }
}
 NameComparator nameComparator = new NameComparator(）;
System.out.println(ageComparator.compare(students, students1));
//其他部分同以上代码，这里根据 name比较，同时这里省略了部分代码

</code></pre> 
  <p>2.借助comparable接口和comparator接口（比较器）给引用数组排序，在数组里面讲过给整型数组排序用Arrays.sort方法。给引用数组排序时，一定要指定根据什么排序。观察源码知道sort方法里面调用了compareTo 方法，故比较的类要实现comparable接口。通过该方法比较大小后进行排序（底层源码就不深究了）。compareTo 方法根据什么比较，我们就根据这个排序。见以下代码</p> 
  <pre><code>import java.util.Arrays;
import java.util.Comparator;
public class Student implements Comparable&lt;Student&gt;{
    public String name;
    public int age;
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
    public int compareTo(Student o) {
        //System.out.println("===fdsfsafdsafdsafdsafdsafdsafsafdsafa");
        return this.age - o.age;
    }
    }
class S {
    public static void main(String[] args) {
        Student[] students = new Student[3];
        students[0] = new Student("zhangsan",10);
        students[1] = new Student("lisi",4);
        students[2] = new Student("abc",5);
        System.out.println("排序前： "+ Arrays.toString(students));
        Arrays.sort(students);
        System.out.println("排序后： "+Arrays.toString(students));

    }
}
//输出结果
排序前： [Student{name='zhangsan', age=10}, Student{name='lisi', age=4}, Student{name='abc', age=5}]
排序后： [Student{name='lisi', age=4}, Student{name='abc', age=5}, Student{name='zhangsan', age=10}]
</code></pre> 
  <p>如果我们要用比较器呢，sort有许多重载方法，我们可以再传一个实现比较器的方法对象名，见以下代码</p> 
  <pre><code>import java.util.Arrays;
import java.util.Comparator;
public class Student {
    public String name;
    public int age;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
    class AgeComparator implements Comparator&lt;Student&gt; {

        @Override
        public int compare(Student o1, Student o2) {
            return o2.age - o1.age ;
        }
    }

    class NameComparator implements Comparator&lt;Student&gt; {
        @Override
        public int compare(Student o1, Student o2) {

            //String  自己重写的 compareTo 方法
            return o1.name.compareTo(o2.name);
        }
    }
class S {
    public static void main(String[] args) {
        Student[] students = new Student[3];
        students[0] = new Student("zhangsan", 10);
        students[1] = new Student("lisi", 4);
        students[2] = new Student("abc", 5);
       AgeComparator ageComparator = new AgeComparator();
        System.out.println("根据age进行排序");
        System.out.println("排序前： " + Arrays.toString(students));
        Arrays.sort(students, ageComparator);
        System.out.println("排序后： " + Arrays.toString(students));
NameComparator nameComparator=new NameComparator();
        System.out.println("根据name进行排序");
        System.out.println("排序前： " + Arrays.toString(students));
        Arrays.sort(students,nameComparator );
        System.out.println("排序后： " +Arrays.toString(students) );
    }
}
//输出结果
根据age进行排序
排序前： [Student{name='zhangsan', age=10}, Student{name='lisi', age=4}, Student{name='abc', age=5}]
排序后： [Student{name='zhangsan', age=10}, Student{name='abc', age=5}, Student{name='lisi', age=4}]
根据name进行排序
排序前： [Student{name='zhangsan', age=10}, Student{name='abc', age=5}, Student{name='lisi', age=4}]
排序后： [Student{name='abc', age=5}, Student{name='lisi', age=4}, Student{name='zhangsan', age=10}]</code></pre> 
  <p>3.在浅拷贝与深拷贝中使用cloneable接口,该接口没有任何方法，仅仅表示实现他的类可以被克隆，此时该类就可以调用object类中的clone()方法了，该类自动导入包，不需要显示化导入包，拷贝方法返回值是一个object类，因为该方法修饰限定符是保护类型，故只能间接通过重写clone()方法调用super。点击鼠标右键，选择“Generate”选项，接着选择override methods，再选中clone()方法，IDE 会根据类中的字段自动生成以下代码</p> 
  <pre><code>protected Object clone() throws CloneNotSupportedException {
        return super.clone();  
    }</code></pre> 
  <p>该默认代码只能实现浅拷贝，如果要用深拷贝。我们要对默认拷贝方法进行修改。</p> 
  <p>先实现浅拷贝：拷贝方法只能拷贝引用指向的对象，如果有对象引用指向了另外一个对象，该对象要拷贝的话只能用深拷贝。</p> 
  <pre><code>class Money  {
    public  double m = 19.9;
}
class Person implements Cloneable {
    public String name;
    public int age;
    public Money money = new Money();
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();  //拷贝方法是保护的，故只能通过super访问，而super在main中只能间接访问
    }
}
     class Test {
    public  static void main(String[] args) throws CloneNotSupportedException {
        Person person = new Person("张三", 10);
        Person person2 = (Person) person.clone();//拷贝方法返回值是一个object类，故要强制转换
        System.out.println("person " + person.money.m);
        System.out.println("person2 " + person2.money.m);
        System.out.println("===========");
        person.money.m = 99.99;
        System.out.println("person " + person.money.m);
        System.out.println("person2 " + person2.money.m);
    }
    }
//输出结果
person 19.9
person2 19.9
===========
person 99.99
person2 99.99</code></pre> 
  <div>
    以上代码在克隆person 但是我没看到你克隆money，那么怎么克隆呢？用深拷贝。如果有对象引用指向了一个另外对象，该对象要拷贝的话只能用深拷贝。我们要对默认拷贝方法进行修改 
  </div> 
  <div> 
   <pre><code>
class Money  implements Cloneable {
    public  double m = 19.9;
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
class Person implements Cloneable {
    public String name;
    public int age;
    public Money money = new Money();
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    @Override

    protected Object clone() throws CloneNotSupportedException {
        Person tmp = (Person)super.clone();
        tmp.money = (Money) this.money.clone();
        return tmp;
    }
}
     class Test {
    public  static void main(String[] args) throws CloneNotSupportedException {
        Person person = new Person("张三", 10);
        Person person2 = (Person) person.clone();//clone
        System.out.println("person " + person.money.m);
        System.out.println("person2 " + person2.money.m);
        System.out.println("===========");
        person.money.m = 99.99;
        System.out.println("person " + person.money.m);
        System.out.println("person2 " + person2.money.m);
    }
    }
//输出结果
person 19.9
person2 19.9
===========
person 99.99
person2 19.9</code></pre> 
  </div> 
 </div> 
</div> 
<h3><span style="color:#333333;"><strong>五、 </strong></span><span style="color:#333333;"><strong>抽象类和接口的区别</strong></span></h3> 
<div> 
 <span style="color:#333333;"><strong>核心区别</strong></span> 
 <span style="color:#333333;">: </span> 
 <span style="color:#333333;"> </span> 
 <span style="color:#333333;">子类必须重写所有的抽象方法，抽象类不需要</span> 
</div> 
<div> 
 <blockquote> 
  <div> 
   <span style="color:#777777;">再次提醒</span> 
   <span style="color:#777777;">: </span> 
  </div> 
  <div> 
   <span style="color:#777777;">抽象类存在的意义是为了让编译器更好的校验</span> 
   <span style="color:#777777;">, </span> 
   <span style="color:#777777;">像</span> 
   <span style="color:#777777;"> Animal </span> 
   <span style="color:#777777;">这样的类我们并不会直接使用</span> 
   <span style="color:#777777;">, </span> 
   <span style="color:#777777;">而是使用它的子类</span> 
  </div> 
 </blockquote> 
</div> 
<h3 style="background-color:transparent;"><span style="color:#333333;"><strong>六、Object类</strong></span></h3> 
<div> 
 <span style="color:#333333;">Object</span> 
 <span style="color:#333333;">是</span> 
 <span style="color:#333333;">Java</span> 
 <span style="color:#333333;">默认提供的一个类。</span> 
 <span style="color:#333333;">Java</span> 
 <span style="color:#333333;">里面除了</span> 
 <span style="color:#333333;">Object</span> 
 <span style="color:#333333;">类，所有的类都是存在继承关系的。默认会继承</span> 
 <span style="color:#333333;">Object</span> 
 <span style="color:#333333;">父类。即所有类的对象都可以使用Object</span> 
 <span style="color:#333333;">的引用进行接收。</span> 
</div> 
<div> 
 <pre><code>Object obj=new Person()；//向上转型</code></pre> 
 <div> 
  <span style="color:#333333;">Object类也存在有定义好的一些方法，</span> 
  <span style="color:#333333;">对于整个</span> 
  <span style="color:#333333;">Object</span> 
  <span style="color:#333333;">类中的方法需要实现全部掌握。</span> 
  <span style="color:#333333;">本小节当中，我们主要来熟悉这几个方法：</span> 
  <span style="color:#333333;">toString()</span> 
  <span style="color:#333333;">方法，</span> 
  <span style="color:#333333;">equals()方法,</span>clone()方法(上面写了) 
 </div> 
 <h4 style="background-color:transparent;"><span style="color:#333333;">1.toString()</span><span style="color:#333333;">方法</span></h4> 
 <div> 
  <span style="color:#333333;">因为以下源码，如果不重写，会输出一个地址。</span> 
 </div> 
 <div> 
  <pre><code>// Object类中的toString()方法实现：
public String toString() {
return getClass().getName() + "@" + Integer.toHexString(hashCode());
}</code></pre> 
  <p>在Java中，当你使用 System.out.println() 或 System.out.print() 输出一个对象时这是因为这些输出方法期望接收一个 String 类型的参数，但是你可以传递任何类型的对象，Java会自动调用该对象的 toString() 方法来转换它。下面是重写方案（通过技巧快速重写），重写后不再输出地址，</p> 
  <pre><code>class Person implements Cloneable{
    public String name;
    public int age;

    public Money money = new Money();

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }</code></pre> 
  <h4>2.<span style="color:#333333;">equals()</span><span style="color:#333333;">方法</span></h4> 
  <p><span style="color:#333333;">以下是Object中equals()</span><span style="color:#333333;">方法源码</span></p> 
  <pre><code>public class Object {
    public boolean equals(Object obj) {
        return (this == obj);
    }

    // ... 其他方法 ...
}</code></pre> 
  <p>该方法返回值是object类型，比较的是两个对象的地址。</p> 
 </div> 
 <div>
   点击鼠标右键，选择“Generate”选项，接着选择 equals 和 hashCode 方法。IDE 会根据类中的字段自动生成以下代码 
 </div> 
 <div> 
  <pre><code>import java.util.Objects;
 @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Person person = (Person) o;
            return age == person.age &amp;&amp; Objects.equals(name, person.name);
        }
        @Override
        public int hashCode() {
            return Objects.hash(name, age);
        }</code></pre> 
  <pre>以上代码导入了Objects这个类，他里面也有一个toString方法，可以比较字符串是否相同
</pre> 
 </div> 
 <div>
   以上代码导入了Objects这个类，他里面也有一个equals方法，可以比较字符串是否相同， 
 </div> 
 <div> 
  <pre><code>Objects.equals(name, name2);</code></pre> 
  <p>然而String类自己提供了equals方法来比较字符串是否相同</p> 
  <pre><code>name.equals(name2);</code></pre> 
  <p>再Arrays这个类提供了equals方法来比较数组是否相同</p> 
 </div> 
 <div>
   例题：比较两个引用对象 
 </div> 
 <div></div> 
 <div> 
  <pre><code>import java.util.Objects;
    class Person implements Cloneable {
    public String name;
    public int age;
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Person person = (Person) o;
            return age == person.age &amp;&amp; Objects.equals(name, person.name);
        }
        @Override
        public int hashCode() {
            return Objects.hash(name, age);
        }
}
     class Test {
         public static void main(String[] args) {

             Person person = new Person("张三", 10);
             Person person1 = new Person("张三", 10);
            // System.out.println(person == person1);//这里会比较地址
             System.out.println(person.equals(person1));
         }
     }
//输出结果
true</code></pre> 
  <h4 style="background-color:transparent;">3.clone()方法</h4> 
  <p>浅拷贝那里讲了，这里就不讲了。</p> 
 </div> 
 <div></div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/025b8eddf10cf3a88076a575f3f03544/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java.lang.IllegalArgumentException异常的正确解决方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/deba299d72108179ce467d676b37727a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Java】实现一个简单的线程池</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>