<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【算法】基础算法002之滑动窗口（一） - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/19537149a9325628831aed2cf2650ed0/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【算法】基础算法002之滑动窗口（一）">
  <meta property="og:description" content="👀樊梓慕：个人主页
🎥个人专栏：《C语言》《数据结构》《蓝桥杯试题》《LeetCode刷题笔记》《实训项目》《C&#43;&#43;》《Linux》《算法》
🌝每一个不曾起舞的日子，都是对生命的辜负
目录
前言
1.长度最小的子数组
滑动窗口类问题解题思路大纲：
2.无重复字符的最长字串
3.最大连续1的个数Ⅲ
4.将 x 减到 0 的最小操作数（medium）
前言 本篇文章主要会讲解滑动窗口的解题思想，滑动窗口实际上就是利用双指针的基础思想，并且利用单调性进行解题的方法。
滑动窗口所用到的双指针是用来维护这个所谓的『 窗口』，所以这两个指针是『 同向』且『 不回退』的，这也就决定了滑动窗口解题的时间复杂度最多为O(2N) 即O(N)，所以滑动窗口是一种非常优秀的算法思想。
那么滑动窗口思想具体的应用，以及如何分析判断是否适用滑动窗口解题呢？
欢迎大家📂收藏📂以便未来做题时可以快速找到思路，巧妙的方法可以事半功倍。
=========================================================================
GITEE相关代码：🌟樊飞 (fanfei_c) - Gitee.com🌟
=========================================================================
1.长度最小的子数组 209. 长度最小的子数组 - 力扣（LeetCode）https://leetcode.cn/problems/minimum-size-subarray-sum/
给定一个含有 n 个正整数的数组和一个正整数 target 。
找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl&#43;1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。
如果依照暴力枚举的策略，解题思路大致如下：
利用双指针，一个指针固定，移动另一个指针，当两个指针中间的所有元素和大于等于目标值target时，记录此时的长度，然后循环往复，求长度最小值。
代码如下：
class Solution { public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { // 记录结果 int ret = INT_MAX; int n = nums.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-02-18T15:44:15+08:00">
    <meta property="article:modified_time" content="2024-02-18T15:44:15+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【算法】基础算法002之滑动窗口（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="%E2%80%8B%E7%BC%96%E8%BE%91" style="text-align:center;"><a id="_0"></a><img alt="" height="157" src="https://images2.imgbox.com/2b/dd/t4rsD13a_o.png" width="357"></h3> 
<p style="text-align:center;"><strong>👀<span style="color:#98c091;">樊梓慕：</span><strong><strong><strong><a href="https://blog.csdn.net/2301_77112634?type=blog" title="个人主页">个人主页</a></strong></strong></strong></strong></p> 
<p style="text-align:center;"><strong> 🎥<span style="color:#956fe7;">个人专栏：</span><strong><strong><strong><a href="http://t.csdn.cn/e7GFn" rel="nofollow" title="《C语言》">《C语言》</a></strong></strong></strong><strong><strong><strong><a href="http://t.csdn.cn/jUErT" rel="nofollow" title="《数据结构》">《数据结构》</a></strong></strong></strong><strong><strong><strong><a href="http://t.csdn.cn/q3iyZ" rel="nofollow" title="《蓝桥杯试题》">《蓝桥杯试题》</a></strong></strong></strong><strong><strong><strong><a href="http://t.csdn.cn/IUyeH" rel="nofollow" title="《LeetCode刷题笔记》">《LeetCode刷题笔记》</a></strong></strong></strong><strong><strong><strong><a href="http://t.csdn.cn/uK6me" rel="nofollow" title="《实训项目》">《实训项目》</a></strong></strong></strong><strong><strong><strong><a href="http://t.csdnimg.cn/uOlnu" rel="nofollow" title="《C++》">《C++》</a></strong></strong></strong><strong><strong><strong><a href="http://t.csdnimg.cn/cUhZr" rel="nofollow" title="《Linux》">《Linux》</a><a href="http://t.csdnimg.cn/S7d8A" rel="nofollow" title="《算法》">《算法》</a></strong></strong></strong></strong></p> 
<p style="text-align:center;"><strong>🌝<span style="color:#faa572;">每一个不曾起舞的日子，都是对生命的辜负</span></strong></p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="1.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-toc" style="margin-left:0px;"><a href="#1.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84" rel="nofollow">1.长度最小的子数组</a></p> 
<p id="%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%B1%BB%E9%97%AE%E9%A2%98%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E5%A4%A7%E7%BA%B2%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%B1%BB%E9%97%AE%E9%A2%98%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E5%A4%A7%E7%BA%B2%EF%BC%9A" rel="nofollow">滑动窗口类问题解题思路大纲：</a></p> 
<p id="2.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2-toc" style="margin-left:0px;"><a href="#2.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2" rel="nofollow">2.无重复字符的最长字串</a></p> 
<p id="3.%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%E2%85%A2-toc" style="margin-left:0px;"><a href="#3.%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%E2%85%A2" rel="nofollow">3.最大连续1的个数Ⅲ</a></p> 
<p id="4.%E5%B0%86%20x%20%E5%87%8F%E5%88%B0%200%20%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%88medium%EF%BC%89-toc" style="margin-left:0px;"><a href="#4.%E5%B0%86%20x%20%E5%87%8F%E5%88%B0%200%20%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%88medium%EF%BC%89" rel="nofollow">4.将 x 减到 0 的最小操作数（medium）</a></p> 
<hr id="hr-toc"> 
<h2>前言</h2> 
<p>本篇文章主要会讲解滑动窗口的解题思想，滑动窗口实际上就是利用双指针的基础思想，并且利用单调性进行解题的方法。</p> 
<p>滑动窗口所用到的双指针是用来维护这个所谓的『 窗口』，所以这两个指针是『 同向』且『 不回退』的，这也就决定了滑动窗口解题的时间复杂度最多为O(2N) 即O(N)，所以滑动窗口是一种非常优秀的算法思想。</p> 
<p>那么滑动窗口思想具体的应用，以及如何分析判断是否适用滑动窗口解题呢？</p> 
<hr> 
<p><span style="color:#ed7976;"><strong>欢迎大家📂</strong></span><span style="color:#be191c;"><strong>收藏</strong></span><span style="color:#ed7976;"><strong>📂以便未来做题时可以快速找到思路，巧妙的方法可以事半功倍。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>=========================================================================</strong></span></p> 
<p><span style="color:#9c8ec1;"><strong>GITEE相关代码：</strong></span><span style="color:#0d0016;"><strong>🌟</strong></span><a href="https://gitee.com/fanfei_c" rel="nofollow" title="樊飞 (fanfei_c) - Gitee.com">樊飞 (fanfei_c) - Gitee.com</a><span style="color:#0d0016;"><strong>🌟</strong></span></p> 
<p><span style="color:#0d0016;"><strong>=========================================================================</strong></span></p> 
<hr> 
<h2 id="1.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84">1.长度最小的子数组</h2> 
<p><a class="has-card" href="https://leetcode.cn/problems/minimum-size-subarray-sum/" rel="nofollow" title="209. 长度最小的子数组 - 力扣（LeetCode）"><span class="link-card-box"><span class="link-title">209. 长度最小的子数组 - 力扣（LeetCode）</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/f0/6a/1ZFcVSIp_o.png" alt="icon-default.png?t=N7T8">https://leetcode.cn/problems/minimum-size-subarray-sum/</span></span></a></p> 
<blockquote> 
 <p>给定一个含有 <code>n</code><strong> </strong>个正整数的数组和一个正整数 <code>target</code><strong> 。</strong></p> 
 <p>找出该数组中满足其总和大于等于<strong> </strong><code>target</code><strong> </strong>的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p> 
</blockquote> 
<p><img alt="" height="465" src="https://images2.imgbox.com/7d/32/kCOC7EPb_o.png" width="1044"></p> 
<p>如果依照暴力枚举的策略，解题思路大致如下：</p> 
<p>利用双指针，一个指针固定，移动另一个指针，当两个指针中间的所有元素和大于等于目标值target时，记录此时的长度，然后循环往复，求长度最小值。</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">class Solution {
public:
    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) {
        // 记录结果
        int ret = INT_MAX;
        int n = nums.size();
        // 枚举出所有满⾜和⼤于等于 target 的⼦数组[start, end]
        // 由于是取到最⼩，因此枚举的过程中要尽量让数组的⻓度最⼩
        // 枚举开始位置
        for (int start = 0; start &lt; n; start++)
        {
            int sum = 0; // 记录从这个位置开始的连续数组的和
            // 寻找结束位置
            for (int end = start; end &lt; n; end++)
            {
                sum += nums[end]; // 将当前位置加上
                if (sum &gt;= target) // 当这段区间内的和满⾜条件时
                {
                    // 更新结果，start 开头的最短区间已经找到
                    ret = min(ret, end - start + 1);
                    break;
                }
            }
        }
        // 返回最后结果
        return ret == INT_MAX ? 0 : ret;
    }
};</code></pre> 
<hr> 
<p>可其实这其中有太多可以忽略掉的枚举区间，我们来分析一下：</p> 
<p><img alt="" height="354" src="https://images2.imgbox.com/cb/63/WbgRAQGL_o.png" width="910"></p> 
<p>本题要求的是长度最小子数组，所以此时一定是要更新left的位置即可，这就达到了不回退的目的。</p> 
<p>注意：要在移动left之前更新结果。</p> 
<p>所以此类问题，我们可以将left和right中间的区域看作一块窗口，该窗口不断的向后移动，直到right超出数组为止。</p> 
<p>在这一过程中：</p> 
<ul><li>right移动导致元素进入窗口的行为我们称为『 进入窗口』；</li><li>left移动导致元素离开窗口的行为我们称为『 离开窗口』；</li><li>判断left和right维护的窗口是否满足题目条件我们称为『 判断』；</li><li>满足题目条件时更新结果的行为我们称为『 更新结果』。</li></ul> 
<p>所以以上这些步骤就构成了『 滑动窗口』类问题的解题思路。</p> 
<h3 id="%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%B1%BB%E9%97%AE%E9%A2%98%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E5%A4%A7%E7%BA%B2%EF%BC%9A">滑动窗口类问题解题思路大纲：</h3> 
<blockquote> 
 <p>①left=0,right=0；</p> 
 <p>②进入窗口；</p> 
 <p>③判断；        </p> 
 <p>        离开窗口；</p> 
 <p>④更新结果；</p> 
</blockquote> 
<p>其中更新结果取决于具体的题目要求，『 就题论题』。</p> 
<p>比如本题就需要在『 离开窗口』之前『 更新结果』。</p> 
<p>有了思路，画图独立完成代码，不要直接看博主的代码。</p> 
<pre><code class="language-cpp">class Solution {
public:
    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) {
        int left=0,right=0;
        int size=nums.size();
        int sum=0;
        int len=INT_MAX;
        while(right&lt;size)
        {
            sum+=nums[right];//进入窗口
            while(sum&gt;=target)//判断
            {
                len=min(len,right-left+1);//更新结果
                sum-=nums[left++];//离开窗口
            }
            right++;
        }
        return len == INT_MAX ? 0 : len;
    }
};</code></pre> 
<hr> 
<h2 id="2.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2">2.无重复字符的最长字串</h2> 
<p><a class="has-card" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/" rel="nofollow" title="3. 无重复字符的最长子串 - 力扣（LeetCode）"><span class="link-card-box"><span class="link-title">3. 无重复字符的最长子串 - 力扣（LeetCode）</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/8e/e1/x0qTedNf_o.png" alt="icon-default.png?t=N7T8">https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/</span></span></a></p> 
<blockquote> 
 <p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串 </strong>的长度。</p> 
</blockquote> 
<p><img alt="" height="531" src="https://images2.imgbox.com/ea/c1/sXHIzNMy_o.png" width="1050"></p> 
<p>其实滑动窗口类题目最重要的是弄清楚『 为什么』要使用滑动窗口，而不是『 怎样』适用滑动窗口。</p> 
<p>像本题，你是如何分析出要使用滑动窗口的呢？</p> 
<p>首先依据暴力枚举的策略，同样固定一个指针，移动另一指针，搭配哈希表得到最长字串：</p> 
<pre><code class="language-cpp">class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int ret = 0; // 记录结果
        int n = s.length();
        // 1. 枚举从不同位置开始的最⻓重复⼦串
        // 枚举起始位置
        for (int i = 0; i &lt; n; i++)
        {
            // 创建⼀个哈希表，统计频次
            int hash[128] = { 0 };
            // 寻找结束为⽌
            for (int j = i; j &lt; n; j++)
            {
                hash[s[j]]++; // 统计字符出现的频次
                if (hash[s[j]] &gt; 1) // 如果出现重复的
                    break;
                // 如果没有重复，就更新 ret
                ret = max(ret, j - i + 1);
            }
        }
        // 2. 返回结果
        return ret;
    }
};</code></pre> 
<blockquote> 
 <p>注意：因为题目说明都为字符，所以我们可以创建一个128大小的数组用来模拟哈希表，没有必要真的申请一个哈希表出来。 </p> 
</blockquote> 
<p>然后才能依据这一暴力枚举的底子我们做优化。</p> 
<p>思路：</p> 
<p>当right指向重复字符时，我们是否需要直接让right回退，left++呢？</p> 
<p>其实如果right指向重复字符了，那么就证明此时就是left开头代表的窗口的最长字串了（因为在这之前right没有指向重复字符），所以此时不需要移动right，而应该移动left直到没有重复字符为止，然后再移动right即可。</p> 
<blockquote> 
 <ul><li>如果这个字符出现的频次超过1 ，说明窗口内有重复元素，那么就从左侧开始划出窗口，直到这个元素的频次变为1，然后再更新结果。</li><li>如果没有超过1 ，说明当前窗口没有重复元素，可以直接更新结果。</li></ul> 
 <p>所以『 更新结果』我们可以统一放在『 判断』的外面。</p> 
</blockquote> 
<p> 有了思路，画图独立完成代码，不要直接看博主的代码。</p> 
<pre><code class="language-cpp">class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int hash[128]={0};
        int left=0,right=0,len=0;
        int n=s.size();
        while(right&lt;n)
        {
            hash[s[right]]++;//进入窗口
            while(hash[s[right]]&gt;1)//判断
                hash[s[left++]]--;//离开窗口
            len=max(len,right-left+1);//更新结果
            right++;
        }
        return len;
    }
};</code></pre> 
<hr> 
<h2 id="3.%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%E2%85%A2">3.最大连续1的个数Ⅲ</h2> 
<p><a class="has-card" href="https://leetcode.cn/problems/max-consecutive-ones-iii/description/" rel="nofollow" title="1004. 最大连续1的个数 III - 力扣（LeetCode）"><span class="link-card-box"><span class="link-title">1004. 最大连续1的个数 III - 力扣（LeetCode）</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/20/f6/eHwvwyLN_o.png" alt="icon-default.png?t=N7T8">https://leetcode.cn/problems/max-consecutive-ones-iii/description/</span></span></a></p> 
<blockquote> 
 <p>给定一个二进制数组 <code>nums</code> 和一个整数 <code>k</code>，如果可以翻转最多 <code>k</code> 个 <code>0</code> ，则返回 <em>数组中连续 <code>1</code> 的最大个数</em> 。</p> 
</blockquote> 
<p><img alt="" height="394" src="https://images2.imgbox.com/0e/a8/AZMMYbDy_o.png" width="1062"></p> 
<p> 虽然题目中说是要翻转数字，但我们要的最终结果与翻转无关，何况如果真的实现翻转反而变得复杂，所以这里我们没有必要真的翻转。</p> 
<p>仔细阅读题目，其实就是求数组中⼀段最长的连续区间，要求这段区间内 0 的个数不超过 k 个。</p> 
<p>既然是连续区间，可以考虑使用『 滑动窗口』来解决问题。</p> 
<p>思路：</p> 
<p>设置一个 0 计数器 zero。</p> 
<p>如果 right 遇到 0，我们应该让 zero ++ ，如果 right 遇到 1，直接跳过即可，这就是『 进入窗口』。</p> 
<p>判断什么呢？当然是『 判断』zero是否超过 k，如果超过 就『 离开窗口』，每轮『 更新结果』。</p> 
<p> 有了思路，画图独立完成代码，不要直接看博主的代码。</p> 
<pre><code class="language-cpp">class Solution {
public:
    int longestOnes(vector&lt;int&gt;&amp; nums, int k) {
        int left=0,right=0,zero=0;
        int n=nums.size();
        int ret=0;
        while(right&lt;n)
        {
            if(nums[right]==0)//进入窗口
                zero++;
            while(zero&gt;k)//判断
            {
                if(nums[left++]==0)//离开窗口
                    zero--;
            }
            ret=max(ret,right-left+1);//更新结果
            right++;
        }
        return ret;
    }
};</code></pre> 
<h2></h2> 
<hr> 
<h2 id="4.%E5%B0%86%20x%20%E5%87%8F%E5%88%B0%200%20%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%88medium%EF%BC%89">4.将 x 减到 0 的最小操作数（medium）</h2> 
<p><a class="has-card" href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/description/" rel="nofollow" title="1658. 将 x 减到 0 的最小操作数 - 力扣（LeetCode）"><span class="link-card-box"><span class="link-title">1658. 将 x 减到 0 的最小操作数 - 力扣（LeetCode）</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/fd/6c/1Yab4zur_o.png" alt="icon-default.png?t=N7T8">https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/description/</span></span></a></p> 
<blockquote> 
 <p>给你一个整数数组 <code>nums</code> 和一个整数 <code>x</code> 。每一次操作时，你应当移除数组 <code>nums</code> 最左边或最右边的元素，然后从 <code>x</code> 中减去该元素的值。请注意，需要 <strong>修改</strong> 数组以供接下来的操作使用。</p> 
 <p>如果可以将 <code>x</code> <strong>恰好</strong> 减到 <code>0</code> ，返回<strong> 最小操作数 </strong>；否则，返回 <code>-1</code> 。</p> 
</blockquote> 
<p><img alt="" height="472" src="https://images2.imgbox.com/85/ac/jAD27HEb_o.png" width="1051"></p> 
<p>阅读题目后，我们发现解决方案可能比较复杂，因为既有可能从左面，也有可能从右面，还有可能一左一右等等，这么多复杂的情况，所以我们需要尝试对问题做转化，这也就是『 正难则反』的思路。 </p> 
<p><img alt="" height="317" src="https://images2.imgbox.com/1b/fc/IJvM6ZaH_o.png" width="831"></p> 
<p>如上图，我们可以求 target 这一区域最长时，那么此时就对应着最小操作数，最小操作数就等于数组元素个数减去target区域的元素个数。</p> 
<p>所以我们成功转化出『 滑动窗口』问题。</p> 
<ul><li>如果 sum &lt; target ，右移右指针，直至变量和大于等于 target ，或右指针已经移到头；</li><li>如果 sum &gt; target ，右移左指针，直至变量和小于等于 target ，或左指针已经移到头；</li><li>如果经过前两步的左右移动使得 sum == target ，维护满足条件数组的最大长度，并让下个元素进入窗口；</li></ul> 
<p> 有了思路，画图独立完成代码，不要直接看博主的代码。</p> 
<pre><code class="language-cpp">class Solution {
public:
    int minOperations(vector&lt;int&gt;&amp; nums, int x) {
        int sum=0;
        for(int a : nums)
        {
            sum+=a;
        }
        int target = sum-x;
        if(target&lt;0) return -1;//处理细节
        int left=0,right=0,tmp=0;
        int n=nums.size();
        int len=-1;
        while(right&lt;n)
        {
            tmp+=nums[right];//进入窗口
            while(tmp &gt; target)//判断
                tmp-=nums[left++];//离开窗口
            if(tmp==target)
                len=max(len,right-left+1);//更新结果
            right++;
        }
        if(len==-1) return len;
        else return n-len;
    }
};</code></pre> 
<hr> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong>=========================================================================</strong></span></p> 
<p style="text-align:center;"><span style="color:#956fe7;"><strong>如果你对该系列文章有兴趣的话，欢迎持续关注博主动态，博主会持续输出优质内容</strong></span></p> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong>🍎博主很需要大家的支持，你的支持是我创作的不竭动力🍎</strong></span></p> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong>🌟</strong></span><span style="color:#79c6cd;"><strong>~ 点赞收藏＋关注 ~</strong></span><span style="color:#0d0016;"><strong>🌟</strong></span></p> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong>=========================================================================</strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8bd839ecd75020870dbd25185aafd4dc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">用Python开发一个飞机大战游戏（附源码教程）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a977083886c5489a1e2e035c37c4ef0f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">org/springframework/boot/maven/RepackageMojo has been compiled by a more recent version of the Java</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>