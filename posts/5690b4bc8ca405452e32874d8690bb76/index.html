<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>精通C&#43;&#43; STL（一）：解开string类的面纱与高效应用 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/5690b4bc8ca405452e32874d8690bb76/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="精通C&#43;&#43; STL（一）：解开string类的面纱与高效应用">
  <meta property="og:description" content="目录
string的定义方式
string的插入
string的拼接
string的删除
string的查找
string的比较
string的替换
string的交换
string的大小和容量
string中元素的访问
string中运算符的使用
string中与迭代器相关的函数
string与字符串之间的转换
string中子字符串的提取
string中的getline函数
string的定义方式 string()：默认构造函数，创建一个空字符串。
string (const string&amp; str)：拷贝构造函数，创建一个新的字符串对象，它是给定字符串str的一个副本。
string (const string&amp; str, size_t pos, size_t len = npos)：从已存在的字符串str中提取子串构造新字符串。pos是开始位置的索引，len是要提取的字符数；如果省略或设为npos，则提取从pos到字符串末尾的所有字符。
string (const char* s)：从C风格字符串s构造字符串对象。
string (const char* s, size_t n)：从C风格字符串s的前n个字符构造字符串对象。
string (size_t n, char c)：创建一个长度为n，每个字符都为c的字符串。
template &lt;class InputIterator&gt; string (InputIterator first, InputIterator last)：这是一个模板构造函数，它接受一对迭代器（first和last），在这对迭代器所指定的范围内构造字符串。这使得可以从任何支持迭代访问的对象（如数组、容器等）中构造字符串。
代码演示：
#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { // 1. 默认构造函数 string strDefault; cout &lt;&lt; strDefault &lt;&lt; endl; // 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-19T23:26:28+08:00">
    <meta property="article:modified_time" content="2024-05-19T23:26:28+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">精通C&#43;&#43; STL（一）：解开string类的面纱与高效应用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="string%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;"><a href="#string%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F" rel="nofollow">string的定义方式</a></p> 
<p id="string%E7%9A%84%E6%8F%92%E5%85%A5-toc" style="margin-left:0px;"><a href="#string%E7%9A%84%E6%8F%92%E5%85%A5" rel="nofollow">string的插入</a></p> 
<p id="string%E7%9A%84%E6%8B%BC%E6%8E%A5-toc" style="margin-left:0px;"><a href="#string%E7%9A%84%E6%8B%BC%E6%8E%A5" rel="nofollow">string的拼接</a></p> 
<p id="string%E7%9A%84%E5%88%A0%E9%99%A4-toc" style="margin-left:0px;"><a href="#string%E7%9A%84%E5%88%A0%E9%99%A4" rel="nofollow">string的删除</a></p> 
<p id="string%E7%9A%84%E6%9F%A5%E6%89%BE-toc" style="margin-left:0px;"><a href="#string%E7%9A%84%E6%9F%A5%E6%89%BE" rel="nofollow">string的查找</a></p> 
<p id="string%E7%9A%84%E6%AF%94%E8%BE%83-toc" style="margin-left:0px;"><a href="#string%E7%9A%84%E6%AF%94%E8%BE%83" rel="nofollow">string的比较</a></p> 
<p id="string%E7%9A%84%E6%9B%BF%E6%8D%A2-toc" style="margin-left:0px;"><a href="#string%E7%9A%84%E6%9B%BF%E6%8D%A2" rel="nofollow">string的替换</a></p> 
<p id="string%E7%9A%84%E4%BA%A4%E6%8D%A2-toc" style="margin-left:0px;"><a href="#string%E7%9A%84%E4%BA%A4%E6%8D%A2" rel="nofollow">string的交换</a></p> 
<p id="string%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%92%8C%E5%AE%B9%E9%87%8F-toc" style="margin-left:0px;"><a href="#string%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%92%8C%E5%AE%B9%E9%87%8F" rel="nofollow">string的大小和容量</a></p> 
<p id="string%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE-toc" style="margin-left:0px;"><a href="#string%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE" rel="nofollow">string中元素的访问</a></p> 
<p id="string%E4%B8%AD%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#string%E4%B8%AD%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">string中运算符的使用</a></p> 
<p id="string%E4%B8%AD%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#string%E4%B8%AD%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0" rel="nofollow">string中与迭代器相关的函数</a></p> 
<p id="string%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2-toc" style="margin-left:0px;"><a href="#string%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2" rel="nofollow">string与字符串之间的转换</a></p> 
<p id="string%E4%B8%AD%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8F%90%E5%8F%96-toc" style="margin-left:0px;"><a href="#string%E4%B8%AD%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8F%90%E5%8F%96" rel="nofollow">string中子字符串的提取</a></p> 
<p id="string%E4%B8%AD%E7%9A%84getline%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#string%E4%B8%AD%E7%9A%84getline%E5%87%BD%E6%95%B0" rel="nofollow">string中的getline函数</a></p> 
<hr id="hr-toc"> 
<p><img alt="" height="1122" src="https://images2.imgbox.com/0e/54/pWHMmcnL_o.png" width="862"></p> 
<p><img alt="" height="782" src="https://images2.imgbox.com/bb/45/gcIAJkRU_o.png" width="959"></p> 
<h2 id="string%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F" style="background-color:transparent;">string的定义方式</h2> 
<p><img alt="" height="260" src="https://images2.imgbox.com/72/72/LEdmOIN6_o.png" width="964"></p> 
<blockquote> 
 <ul><li> <p><code>string()</code>：默认构造函数，创建一个空字符串。</p> </li><li> <p><code>string (const string&amp; str)</code>：拷贝构造函数，创建一个新的字符串对象，它是给定字符串<code>str</code>的一个副本。</p> </li><li> <p><code>string (const string&amp; str, size_t pos, size_t len = npos)</code>：从已存在的字符串<code>str</code>中提取子串构造新字符串。<code>pos</code>是开始位置的索引，<code>len</code>是要提取的字符数；如果省略或设为<code>npos</code>，则提取从<code>pos</code>到字符串末尾的所有字符。</p> </li><li> <p><code>string (const char* s)</code>：从C风格字符串<code>s</code>构造字符串对象。</p> </li><li> <p><code>string (const char* s, size_t n)</code>：从C风格字符串<code>s</code>的前<code>n</code>个字符构造字符串对象。</p> </li><li> <p><code>string (size_t n, char c)</code>：创建一个长度为<code>n</code>，每个字符都为<code>c</code>的字符串。</p> </li><li> <p><code>template &lt;class InputIterator&gt; string (InputIterator first, InputIterator last)</code>：这是一个模板构造函数，它接受一对迭代器（<code>first</code>和<code>last</code>），在这对迭代器所指定的范围内构造字符串。这使得可以从任何支持迭代访问的对象（如数组、容器等）中构造字符串。</p> </li></ul> 
</blockquote> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() 
{
    // 1. 默认构造函数
    string strDefault;
    cout &lt;&lt; strDefault &lt;&lt; endl;

    // 2. 拷贝构造函数
    string strCopy("Hello");
    string strCopied(strCopy);
    cout &lt;&lt; strCopied &lt;&lt; endl;

    // 3. 从已有字符串提取子串构造
    string strSubstr("HelloWorld", 6);
    cout &lt;&lt; strSubstr &lt;&lt; endl;

    // 4. 从C风格字符串构造
    string strFromCStr("World");
    cout &lt;&lt; strFromCStr &lt;&lt; endl;

    // 5. 从C风格字符串的部分构造
    const char* partCStr = "HelloWorld";
    string strPartCStr(partCStr, 5);
    cout &lt;&lt; strPartCStr &lt;&lt; endl;

    // 6. 创建指定长度和字符的字符串
    string strCharRepeat(5, 'A');
    cout &lt;&lt; strCharRepeat &lt;&lt; endl;

    // 7. 使用迭代器构造
    char arr[] = { 'H', 'e', 'l', 'l', 'o' };
    string strFromIter(arr, arr + sizeof(arr) - 1);
    cout &lt;&lt; strFromIter &lt;&lt; endl;

    return 0;
}</code></pre> 
<p>代码结果：<img alt="" height="158" src="https://images2.imgbox.com/ce/91/XAGMqYDe_o.png" width="249"></p> 
<h2 id="string%E7%9A%84%E6%8F%92%E5%85%A5">string的插入</h2> 
<h3><strong>  使用push_back进行尾插</strong></h3> 
<p><img alt="" height="361" src="https://images2.imgbox.com/76/b4/n3JKtQLn_o.png" width="968"></p> 
<blockquote> 
 <pre><code>void push_back(char ch);</code></pre> 
 <p><strong>功能说明：</strong></p> 
 <ul><li><strong>参数</strong>：<code>ch</code> - 要添加到字符串末尾的字符。</li><li><strong>返回值</strong>：此函数没有返回值，它直接修改调用它的字符串对象，在其末尾增加给定的字符。</li><li><strong>扩容</strong>：如果添加字符导致字符串超出当前容量，<code>std::string</code>会自动进行内存管理，包括重新分配内存和复制现有内容到新位置，以容纳新增的字符，这个过程对用户透明。</li></ul> 
</blockquote> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() 
{
    string str = "Hello, ";
    str.push_back('W');
    str.push_back('o');
    str.push_back('r');
    str.push_back('l');
    str.push_back('d');
    str.push_back('!');

    cout &lt;&lt; str &lt;&lt; endl;  // 输出: Hello, World!

    return 0;
}</code></pre> 
<p>代码结果：<img alt="" height="65" src="https://images2.imgbox.com/b5/b7/OL8HcswI_o.png" width="274"></p> 
<h3><strong>  使用insert插入</strong></h3> 
<p><img alt="" height="236" src="https://images2.imgbox.com/9d/b8/HFnojTdb_o.png" width="738"></p> 
<blockquote> 
 <p><strong>插入单个字符：</strong></p> 
 <pre><code class="hljs">string&amp; insert(size_type pos, char ch);</code></pre> 
 <ul><li><strong>参数</strong>：<code>pos</code> - 插入字符的位置（基于0的索引）。<code>ch</code> - 要插入的字符。</li><li><strong>返回值</strong>：返回对字符串自身的引用，允许链式调用。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>插入字符串：</strong></p> 
 <pre><code class="hljs">string&amp; insert(size_t pos, const string&amp; str);
string&amp; insert(size_t pos, const string&amp; str, size_t subpos, size_t sublen = npos);</code></pre> 
 <ul><li>第一种形式直接在<code>pos</code>位置插入整个字符串<code>str</code>。</li><li>第二种形式从字符串<code>str</code>的<code>subpos</code>位置开始，插入<code>sublen</code>个字符到<code>pos</code>位置。如果<code>sublen</code>被省略或设置为<code>npos</code>，则插入从<code>subpos</code>到<code>str</code>末尾的所有字符。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>插入字符数量：</strong></p> 
 <pre><code class="hljs">string&amp; insert(size_t pos, size_t count, char ch);</code></pre> 
 <ul><li>在<code>pos</code>位置插入<code>count</code>个字符<code>ch</code>。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>插入迭代器范围：</strong></p> 
 <pre><code class="hljs">template &lt;class Iterator&gt;
string&amp; insert(size_t pos, Iterator first, Iterator last);</code></pre> 
 <ul><li>插入由迭代器<code>first</code>和<code>last</code>指定的范围内所有字符到<code>pos</code>位置。</li></ul> 
</blockquote> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() 
{
    string str = "Hello";

    // 在索引2的位置插入字符'a'
    str.insert(2, "a");
    cout &lt;&lt; str &lt;&lt; endl;  // 输出: Helalo

    // 在末尾插入字符串" World"
    str.insert(str.size(), " World");
    cout &lt;&lt; str &lt;&lt; endl;  // 输出: Hela World

    // 插入重复字符'e'三次
    str.insert(1, 3, 'e');
    cout &lt;&lt; str &lt;&lt; endl;  // 输出: Heeele World

    return 0;
}</code></pre> 
<p>代码结果： <img alt="" height="96" src="https://images2.imgbox.com/8a/81/s2xHute8_o.png" width="278"></p> 
<h2 id="string%E7%9A%84%E6%8B%BC%E6%8E%A5">string的拼接</h2> 
<h3><strong>  使用append函数完成string的拼接</strong></h3> 
<p><img alt="" height="212" src="https://images2.imgbox.com/19/9d/q60XZs1E_o.png" width="738"></p> 
<blockquote> 
 <p><strong> 追加字符串：</strong></p> 
 <pre><code class="hljs">string&amp; append(const string&amp; str);</code></pre> 
 <ul><li>将整个字符串<code>str</code>追加到当前字符串末尾。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>追加子串：</strong></p> 
 <pre><code class="hljs">string&amp; append(const string&amp; str, size_t pos, size_t n = npos);</code></pre> 
 <ul><li>从字符串<code>str</code>的<code>pos</code>位置开始追加<code>n</code>个字符到当前字符串末尾。如果<code>n</code>等于<code>npos</code>，则追加从<code>pos</code>到<code>str</code>末尾的所有字符。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>追加字符数量：</strong></p> 
 <pre><code class="hljs">string&amp; append(size_t n, char c);</code></pre> 
 <ul><li>在字符串末尾追加<code>n</code>个字符<code>c</code>。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>追加字符数组：</strong></p> 
 <pre><code class="hljs">string&amp; append(const char* s);
string&amp; append(const char* s, size_t n);</code></pre> 
 <ul><li>第一种形式追加C风格字符串<code>s</code>直到遇到空字符<code>\0</code>。</li><li>第二种形式追加C风格字符串<code>s</code>的前<code>n</code>个字符。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>追加迭代器范围：</strong></p> 
 <pre><code class="hljs">template &lt;class Iterator&gt;
string&amp; append(Iterator first, Iterator last);</code></pre> 
 <ul><li>追加由迭代器<code>first</code>和<code>last</code>指定的范围内所有字符。</li></ul> 
</blockquote> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() {
    string str = "Hello";

    // 追加字符串" World"
    str.append(" World");
    cout &lt;&lt; str &lt;&lt; endl;  // 输出: Hello World

    // 追加三个字符'a'
    str.append(3, '!');
    cout &lt;&lt; str &lt;&lt; endl;  // 输出: Hello World!!!

    // 从"C-style String"中追加前4个字符
    const char* cs = "C-style String";
    str.append(cs, 4);
    cout &lt;&lt; str &lt;&lt; endl;  // 输出: Hello World!!!C-st

    return 0;
}</code></pre> 
<p>代码结果：<img alt="" height="95" src="https://images2.imgbox.com/94/84/VF51Gc7V_o.png" width="246"></p> 
<h2 id="string%E7%9A%84%E5%88%A0%E9%99%A4">string的删除</h2> 
<h3><strong>  使用pop_back进行尾删</strong></h3> 
<p><img alt="" height="252" src="https://images2.imgbox.com/d7/26/GBYUJoBX_o.png" width="747"></p> 
<blockquote> 
 <pre><code class="hljs">void pop_back();</code></pre> 
 <p><strong>功能说明：</strong></p> 
 <ul><li>此函数没有返回值，它直接修改调用它的字符串对象，移除其末尾的字符。</li><li>如果字符串为空，调用<code>pop_back</code>函数是未定义行为。实践中，一些实现可能会抛出异常或忽略此操作，但最好避免在空字符串上调用此函数。</li></ul> 
</blockquote> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() {
    std::string str = "Hello, World!";

    // 删除末尾的感叹号
    str.pop_back();
    cout &lt;&lt; str &lt;&lt; endl;  // 输出: Hello, World

    // 再次删除，这次是'd'
    str.pop_back();
    cout &lt;&lt; str &lt;&lt; endl;  // 输出: Hello, Worl

    // 继续删除，直至字符串为空
    while ( !str.empty() ) 
    {
        str.pop_back();
    }
    cout &lt;&lt; (str.empty() ? "Now the string is empty." : "String still has characters.") &lt;&lt; endl;  // 输出: Now the string is empty.

    return 0;
}</code></pre> 
<p>代码结果：<img alt="" height="97" src="https://images2.imgbox.com/8f/b0/qgQo358O_o.png" width="247"></p> 
<h3><strong>  使用erase删除</strong></h3> 
<p><img alt="" height="143" src="https://images2.imgbox.com/9f/41/w3hycmjZ_o.png" width="741"></p> 
<blockquote> 
 <p><strong>删除单个字符：</strong></p> 
 <pre><code class="hljs">iterator erase(iterator position);</code></pre> 
 <ul><li>删除指针<code>position</code>所指向的字符，并返回下一个字符的迭代器。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>删除指定范围内的字符：</strong></p> 
 <pre><code class="hljs">iterator erase(iterator first, iterator last);</code></pre> 
 <ul><li>删除从迭代器<code>first</code>到<code>last</code>之间（不包括<code>last</code>）的所有字符，并返回<code>last</code>之后的第一个字符的迭代器。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>删除指定位置及其后的若干字符：</strong></p> 
 <pre><code class="hljs">string&amp; erase(size_t pos = 0, size_t n = npos);</code></pre> 
 <ul><li>删除从索引<code>pos</code>开始的<code>n</code>个字符。如果<code>n</code>等于<code>npos</code>，则删除从<code>pos</code>到字符串末尾的所有字符。返回修改后的字符串的引用。</li></ul> 
</blockquote> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main()
{
    string str = "Hello, World!";

    // 删除第7个字符（逗号）
    str.erase(6, 1);
    cout &lt;&lt; str &lt;&lt; endl;  // 输出: Hello World!

    // 删除从位置3到5的字符（"lo"）
    str.erase(3, 2);
    cout &lt;&lt; str &lt;&lt; endl;  // 输出: HelWorld!

    // 使用迭代器删除"World"之后的所有字符
    auto it = str.find("World");
    if (it != string::npos)
    {
        it += 5; // 移动到"World"之后
        str.erase(it, str.end());
    }
    cout &lt;&lt; str &lt;&lt; endl;  // 输出: HelWorld

    return 0;
}</code></pre> 
<p>代码结果：</p> 
<h2 id="string%E7%9A%84%E6%9F%A5%E6%89%BE">string的查找</h2> 
<h3><strong>  使用find函数正向搜索第一个匹配项</strong></h3> 
<p><img alt="" height="157" src="https://images2.imgbox.com/e1/58/M9RZlTBC_o.png" width="737"></p> 
<blockquote> 
 <p><strong>查找子串：</strong></p> 
 <pre><code class="hljs">size_t find(const string&amp; str, size_t pos = 0) const;</code></pre> 
 <ul><li>在字符串中查找子串<code>str</code>首次出现的位置，搜索从索引<code>pos</code>开始。默认情况下，<code>pos</code>为0，即从字符串开头开始搜索。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>查找单个字符：</strong></p> 
 <pre><code class="hljs">size_t find(char c, size_t pos = 0) const;</code></pre> 
 <ul><li>查找字符<code>c</code>首次出现的位置，搜索同样从索引<code>pos</code>开始。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>查找子串并指定结束搜索位置：</strong></p> 
 <pre><code class="hljs">size_t find(const string&amp; str, size_t pos, size_t n) const;</code></pre> 
 <ul><li>查找子串<code>str</code>的前<code>n</code>个字符首次出现的位置，搜索从索引<code>pos</code>开始。</li></ul> 
</blockquote> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() 
{
    string str = "Hello, this is a test string.";

    // 查找子串"test"
    size_t pos1 = str.find("test");
    if (pos1 != string::npos) 
    {
        cout &lt;&lt; "Found 'test' at position: " &lt;&lt; pos1 &lt;&lt; endl;
    }
    else 
    {
        cout &lt;&lt; "'test' not found." &lt;&lt; endl;
    }

    // 查找字符'a'，从位置10开始
    size_t pos2 = str.find('a', 0);
    cout &lt;&lt; "Found 'a' after position 0 at: " &lt;&lt; pos2 &lt;&lt; endl;

    // 尝试查找不存在的子串
    size_t pos3 = str.find("notfound");
    if (pos3 == std::string::npos) 
    {
        cout &lt;&lt; "'notfound' not found in the string." &lt;&lt; endl;
    }

    return 0;
}</code></pre> 
<p>代码结果：<img alt="" height="95" src="https://images2.imgbox.com/15/06/1Wdw23J7_o.png" width="292"></p> 
<h3><strong>  使用rfind函数反向搜索第一个匹配项</strong></h3> 
<p><img alt="" height="154" src="https://images2.imgbox.com/9d/18/e9BJDZhr_o.png" width="735"></p> 
<blockquote> 
 <p><strong>查找子串：</strong></p> 
 <pre><code class="hljs">size_t rfind(const string&amp; str, size_t pos = npos) const;</code></pre> 
 <ul><li>从字符串末尾开始查找子串<code>str</code>首次出现的位置，可以指定搜索的起始位置<code>pos</code>为<code>npos</code>来从字符串的末尾开始搜索，默认也是这样。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>查找单个字符：</strong></p> 
 <pre><code class="hljs">size_t rfind(char c, size_t pos = npos) const;</code></pre> 
 <ul><li>从字符串末尾开始查找字符<code>c</code>首次出现的位置，同样可以指定搜索的起始位置。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>查找子串并指定结束搜索位置：</strong></p> 
 <pre><code class="hljs">size_t rfind(const string&amp; str, size_t pos, size_t n) const;</code></pre> 
 <ul><li>从字符串末尾开始查找子串<code>str</code>的前<code>n</code>个字符首次出现的位置，搜索从索引<code>pos</code>开始。</li></ul> 
</blockquote> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() 
{
    string str = "Hello, this is a test. Testing, 1, 2, test.";

    // 从后往前查找子串"test"
    size_t pos1 = str.rfind("test");
    if (pos1 != string::npos) 
    {
        cout &lt;&lt; "Found 'test' from end at position: " &lt;&lt; pos1 &lt;&lt; endl;
    }
    else 
    {
        cout &lt;&lt; "'test' not found from end." &lt;&lt; endl;
    }

    // 查找字符't'，限制搜索范围
    size_t pos2 = str.rfind('t', 20);
    cout &lt;&lt; "Last 't' before position 20 found at: " &lt;&lt; pos2 &lt;&lt; endl;

    // 尝试查找不存在的子串
    size_t pos3 = str.rfind("notfound");
    if (pos3 == std::string::npos) 
    {
        cout &lt;&lt; "'notfound' not found from end in the string." &lt;&lt; endl;
    }

    return 0;
}</code></pre> 
<p>代码结果：<img alt="" height="94" src="https://images2.imgbox.com/8f/a9/rQu291nX_o.png" width="367"></p> 
<h2 id="string%E7%9A%84%E6%AF%94%E8%BE%83">string的比较</h2> 
<h3><strong>  使用compare函数完成比较</strong></h3> 
<p><img alt="" height="196" src="https://images2.imgbox.com/15/22/KqwlpPCW_o.png" width="739"></p> 
<blockquote> 
 <p><strong>函数原型及返回值意义：</strong></p> 
 <pre><code class="hljs">int compare(const string&amp; str) const;
int compare(size_t pos1, size_t n1, const string&amp; str) const;
int compare(size_t pos1, size_t n1, const string&amp; str, size_t pos2, size_t n2 = npos) const;
int compare(const char* s) const;
int compare(size_t pos1, size_t n1, const char* s) const;
int compare(size_t pos1, size_t n1, const char* s, size_t n2) const;</code></pre> 
 <p><strong>返回值解释：</strong></p> 
 <ul><li>如果当前字符串小于比较的字符串，则返回负整数。</li><li>如果两者相等，则返回0。</li><li>如果当前字符串大于比较的字符串，则返回正整数。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>比较整个字符串：</strong></p> 
 <pre><code class="hljs">std::string str1 = "apple";
std::string str2 = "banana";
int result = str1.compare(str2);</code></pre> 
 <p>        如果<code>result &lt; 0</code>，说明<code>str1</code>在字典顺序上小于<code>str2</code>；如果<code>result &gt; 0</code>，则<code>str1</code>大于<code>str2</code>；若<code>result == 0</code>，两者相等。</p> 
</blockquote> 
<blockquote> 
 <p><strong>比较子串：</strong></p> 
 <pre><code class="hljs">std::string str1 = "pineapple";
std::string str2 = "apple";
int result = str1.compare(4, 5, str2); // 从str1的第4个字符开始，比较5个字符</code></pre> 
 <p>        这里比较的是"apple"与"apple"，由于它们相等，返回值将是0。</p> 
</blockquote> 
<blockquote> 
 <p><strong>比较与C风格字符串：</strong></p> 
 <pre><code class="hljs">std::string str = "hello";
int result = str.compare("world");</code></pre> 
 <p>        比较"hello"与"world"。</p> 
</blockquote> 
<blockquote> 
 <p><strong>指定长度的比较：</strong></p> 
 <pre><code class="hljs">std::string str1 = "abcdef";
std::string str2 = "abcxyz";
int result = str1.compare(0, 3, str2, 0, 3); // 比较前3个字符</code></pre> 
 <p>        比较"abc"与"abc"，结果为0，因为两者相同。</p> 
</blockquote> 
<h2 id="string%E7%9A%84%E6%9B%BF%E6%8D%A2">string的替换</h2> 
<h3><strong>  使用replace函数完成string的替换</strong></h3> 
<p><img alt="" height="283" src="https://images2.imgbox.com/fd/8f/8O3kcIuB_o.png" width="740"></p> 
<blockquote> 
 <p><strong> 替换单个范围的子串：</strong></p> 
 <pre><code class="hljs">string&amp; replace(size_t pos, size_t len, const string&amp; str);</code></pre> 
 <ul><li>从位置<code>pos</code>开始，替换长度为<code>len</code>的子字符串为<code>str</code>。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>使用子串替换另一子串：</strong></p> 
 <pre><code class="hljs">string&amp; replace(size_t pos, size_t len, const string&amp; str, size_t subpos, size_t sublen);</code></pre> 
 <ul><li>同样从位置<code>pos</code>开始，替换长度为<code>len</code>的子字符串，但是使用<code>str</code>中的从<code>subpos</code>开始长度为<code>sublen</code>的子串进行替换。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>用单个字符替换：</strong></p> 
 <pre><code class="hljs">string&amp; replace(size_t pos, size_t len, size_t n, char c);</code></pre> 
 <ul><li>从位置<code>pos</code>开始，替换长度为<code>len</code>的子字符串为<code>n</code>个字符<code>c</code>。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>迭代器范围替换：</strong></p> 
 <pre><code class="hljs">string&amp; replace(iterator i1, iterator i2, const string&amp; str);
string&amp; replace(iterator i1, iterator i2, size_t n, char c);</code></pre> 
 <ul><li>使用迭代器<code>i1</code>和<code>i2</code>指定的范围内的字符被<code>str</code>或<code>n</code>个字符<code>c</code>替换。</li></ul> 
</blockquote> 
<p> 代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() 
{
    string str = "Hello, world! Welcome to the programming world.";

    // 替换"world"为"universe"
    size_t pos = str.find("world");
    if (pos != string::npos) 
    {
        str.replace(pos, 5, "universe");
    }
    cout &lt;&lt; str &lt;&lt; endl;  // 输出: Hello, universe! Welcome to the programming world.

    // 使用子串替换
    pos = str.find("programming", pos);
    if (pos != string::npos) 
    {
        str.replace(pos, 11, "coding", 4, 4); // 取"coding"的前4个字符
    }
    cout &lt;&lt; str &lt;&lt; endl;  // 输出: Hello, universe! Welcome to the coding world.

    // 用字符替换
    str.replace(0, 7, 5, '-');
    cout &lt;&lt; str &lt;&lt; endl;  // 输出: ----- universe! Welcome to the coding world.

    return 0;
}</code></pre> 
<p>代码结果：<img alt="" height="95" src="https://images2.imgbox.com/96/94/piiRQD8E_o.png" width="412"></p> 
<h2 id="string%E7%9A%84%E4%BA%A4%E6%8D%A2" style="background-color:transparent;">string的交换</h2> 
<h3><strong>  使用swap函数完成两个string类的交换</strong></h3> 
<p><img alt="" height="352" src="https://images2.imgbox.com/2b/ec/fasi8hjK_o.png" width="741"></p> 
<blockquote> 
 <p><strong>函数原型：</strong></p> 
 <pre><code class="hljs">void swap(string&amp; other);</code></pre> 
 <p><strong>用法：</strong></p> 
 <p>        这个函数接受一个引用到另一个<code>std::string</code>对象作为参数，并直接交换两个字符串的内部数据结构，包括它们的字符缓冲区。交换后，两个字符串对象将包含对方之前的字符内容，但它们的容量和其它属性（如分配的内存大小）也会相应交换。</p> 
</blockquote> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() 
{
    string str1 = "Hello, World!";
    string str2 = "Goodbye, World!";

    cout &lt;&lt; "Before swapping:\nstr1 = " &lt;&lt; str1 &lt;&lt; "\nstr2 = " &lt;&lt; str2 &lt;&lt; endl;

    // 使用swap函数交换两个字符串的内容
    str1.swap(str2);

    cout &lt;&lt; "After swapping:\nstr1 = " &lt;&lt; str1 &lt;&lt; "\nstr2 = " &lt;&lt; str2 &lt;&lt; endl;

    return 0;
}</code></pre> 
<p>代码结果：<img alt="" height="142" src="https://images2.imgbox.com/e8/e3/j1SAMofl_o.png" width="254"></p> 
<h2 id="string%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%92%8C%E5%AE%B9%E9%87%8F" style="background-color:transparent;">string的大小和容量</h2> 
<h3><strong>  使用size函数或length函数获取当前有效字符的个数</strong></h3> 
<p><img alt="" height="447" src="https://images2.imgbox.com/59/97/URDONHyy_o.png" width="742"></p> 
<p><img alt="" height="448" src="https://images2.imgbox.com/ed/ab/4SuKO2fO_o.png" width="739"></p> 
<blockquote> 
 <p><strong>size()函数：</strong></p> 
 <ul><li><strong>原型</strong>： <pre><code class="hljs">size_t size() const;</code></pre> </li><li><strong>功能</strong>：返回字符串中字符的数量。</li><li><strong>备注</strong>：作为STL容器通用接口的一部分，它符合容器类的一般使用习惯。</li></ul> 
 <p><strong>length()函数：</strong></p> 
 <ul><li><strong>原型</strong>： <pre><code class="hljs">size_t length() const;</code></pre> </li><li><strong>功能</strong>：同样返回字符串中字符的数量。</li><li><strong>备注</strong>：这个函数主要是为了兼容传统的C语言风格的字符串处理，如<code>strlen</code>函数，使得C++程序员在使用<code>std::string</code>时能有熟悉的感觉。</li></ul> 
</blockquote> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() 
{
    // 初始化一个字符串
    string greeting = "Hello, World!";

    // 使用size()函数获取字符串长度
    cout &lt;&lt; "The length of the string using size() is: " &lt;&lt; greeting.size() &lt;&lt; endl;

    // 使用length()函数获取字符串长度
    cout &lt;&lt; "The length of the string using length() is: " &lt;&lt; greeting.length() &lt;&lt; endl;

    return 0;
}</code></pre> 
<p>代码结果：<img alt="" height="78" src="https://images2.imgbox.com/72/40/9Wu806ai_o.png" width="392"></p> 
<h3><strong>  使用max_size函数获取string对象对多可包含的字符数</strong></h3> 
<p><img alt="" height="365" src="https://images2.imgbox.com/36/d2/I7aZOJev_o.png" width="738"></p> 
<blockquote> 
 <p><strong>函数原型：</strong></p> 
 <pre><code class="hljs">size_t max_size() const;</code></pre> 
 <p><strong>功能解释：</strong></p> 
 <ul><li><strong>返回值</strong>：<code>max_size</code>函数返回<code>size_type</code>类型的值，表示当前系统环境下<code>std::string</code>对象理论上能存储的最大字符数量。<code>size_type</code>是一个无符号整型，足以存储任何可能的字符串长度。</li><li><strong>用途</strong>：虽然通常情况下不会达到这个极限值，但它可以用来做边界检查，比如在动态分配或调整字符串大小之前，确保操作不会超出可能的容量限制。</li></ul> 
</blockquote> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() 
{
    string str;
    cout &lt;&lt; "The maximum size of a string on this system can be: " &lt;&lt; str.max_size() &lt;&lt; " characters." &lt;&lt; endl;
    return 0;
}</code></pre> 
<p>代码结果：<img alt="" height="62" src="https://images2.imgbox.com/59/47/va4A5brn_o.png" width="675"></p> 
<h3><strong>  使用capacity函数获取当前对象所分配的存储空间的大小</strong></h3> 
<p><img alt="" height="502" src="https://images2.imgbox.com/a3/fe/vRZILueC_o.png" width="743"></p> 
<blockquote> 
 <p><strong>函数原型：</strong></p> 
 <pre><code>size_type capacity() const noexcept;</code></pre> 
 <p><strong>功能说明：</strong></p> 
 <ul><li><strong>返回值</strong>：返回当前字符串对象已分配的存储空间大小，以字符数量为单位。<code>size_type</code>是一个无符号整型，确保可以表示任何可能的容量值。</li><li><strong>目的</strong>：提供关于字符串内部存储管理的信息，帮助优化字符串操作，比如通过预先调整容量(<code>reserve()</code>函数)来避免自动增长导致的多次内存重分配。</li></ul> 
</blockquote> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() 
{
    string str("Hello");
    cout &lt;&lt; "Current string: \"" &lt;&lt; str &lt;&lt; "\"\n";
    cout &lt;&lt; "Current capacity: " &lt;&lt; str.capacity() &lt;&lt; endl;

    // 添加字符直到触发自动增长
    while (str.capacity() == str.size()) 
    { // 这里仅为示例，实际上不会进入循环，因为capacity通常大于size
        str += 'a';
        cout &lt;&lt; "Added a character. New capacity: " &lt;&lt; str.capacity() &lt;&lt; endl;
    }

    return 0;
}</code></pre> 
<p>代码结果：<img alt="" height="79" src="https://images2.imgbox.com/d5/40/tTsMfGIx_o.png" width="270"></p> 
<h3><strong>  使用resize改变当前对象的有效字符的个数</strong></h3> 
<p><img alt="" height="453" src="https://images2.imgbox.com/bd/a3/t9uaqSIU_o.png" width="739"></p> 
<blockquote> 
 <p> <strong>函数原型：</strong></p> 
 <pre><code>void resize(size_type n, char c = '\0');</code></pre> 
 <p><strong>参数说明：</strong></p> 
 <ul><li><code>n</code>：指定新的字符串长度。如果这个值大于当前长度，则字符串会被扩展，新添加的位置会被字符<code>c</code>填充；如果这个值小于当前长度，则字符串会被截断到指定长度。</li><li><code>c</code>：可选参数，默认值为<code>\0</code>（空字符）。当扩展字符串时，如果指定了这个参数，新增的位置将被此字符填充；如果不指定或值为默认，则默认使用空字符填充。</li></ul> 
 <p><strong>功能描述：</strong></p> 
 <ol><li><strong>扩展字符串</strong>：如果<code>n</code>大于当前字符串的长度，<code>resize</code>函数会在字符串末尾添加足够数量的字符<code>c</code>，直到字符串长度达到<code>n</code>。</li><li><strong>缩短字符串</strong>：如果<code>n</code>小于当前字符串的长度，<code>resize</code>会直接截断字符串，从原字符串末尾移除多出的字符，直到长度为<code>n</code>。</li><li><strong>调整容量</strong>：<code>resize</code>操作可能会影响到字符串的容量（即分配给字符串的内存空间），特别是当扩展字符串时，可能需要重新分配内存以容纳更多的字符。</li></ol> 
</blockquote> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() 
{
    string str = "Hello";

    // 扩展字符串并在末尾填充'a'
    str.resize(10, 'a');
    cout &lt;&lt; "After resizing to 10 with 'a': " &lt;&lt; str &lt;&lt; endl; // 输出: Helloaaaaaa

    // 缩短字符串
    str.resize(3);
    cout &lt;&lt; "After resizing to 3: " &lt;&lt; str &lt;&lt; endl; // 输出: Hel

    return 0;
}</code></pre> 
<p>代码结果：<img alt="" height="81" src="https://images2.imgbox.com/fa/e6/OMQ1JxVM_o.png" width="356"></p> 
<h3><strong>  使用reserve改变当前对象的容量大小</strong></h3> 
<p><img alt="" height="427" src="https://images2.imgbox.com/10/e2/dDHvcSpG_o.png" width="739"></p> 
<blockquote> 
 <p><strong> 函数原型：</strong></p> 
 <pre><code>void reserve(size_type n);</code></pre> 
 <p><strong>参数说明：</strong></p> 
 <ul><li><code>n</code>：指定要求的最小容量，即至少能存储<code>n</code>个字符的内存空间。如果<code>n</code>小于或等于当前的容量，则函数什么也不做。如果<code>n</code>大于当前的容量，那么<code>string</code>对象将尝试重新分配内存以满足新的容量需求。</li></ul> 
 <p><strong>功能描述：</strong></p> 
 <ul><li><strong>预防内存重分配</strong>：通过预先分配足够的内存，当后续通过插入操作增加字符串长度时，只要增加的长度不超过预留的容量，就不会发生内存重分配，从而提高了程序的效率。</li><li><strong>不改变字符串内容</strong>：<code>reserve()</code>调用不会改变字符串的实际内容或长度，只影响其容量。</li><li><strong>内存分配策略</strong>：实现可能会根据特定的内存管理策略（如分配多于请求的内存以应对未来增长）来决定实际分配的内存大小，但这保证至少能满足<code>n</code>个字符的存储需求。</li></ul> 
</blockquote> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() 
{
    string str;

    // 预先分配能容纳100个字符的内存空间
    str.reserve(100);

    cout &lt;&lt; "Initial capacity: " &lt;&lt; str.capacity() &lt;&lt; endl; // 显示初始容量

    // 接着可以安全地执行一系列的插入操作，而不会频繁触发内存重分配
    for (int i = 0; i &lt; 100; ++i) 
    {
        str.push_back('A' + (i % 26)); // 填充字母
    }

    cout &lt;&lt; "After inserting characters, capacity: " &lt;&lt; str.capacity() &lt;&lt; endl; // 显示调整后的容量
    cout &lt;&lt; "Size after insertions: " &lt;&lt; str.size() &lt;&lt; endl; // 显示实际大小

    return 0;
}</code></pre> 
<p>代码结果：<img alt="" height="95" src="https://images2.imgbox.com/83/03/zPNiMAXI_o.png" width="354"></p> 
<h3><strong>  使用clear删除对象的内容，删除后对象变为空字符串</strong></h3> 
<p><img alt="" height="273" src="https://images2.imgbox.com/5f/00/MX7nLZzF_o.png" width="744"></p> 
<blockquote> 
 <p><strong>函数原型：</strong></p> 
 <pre><code>void clear() noexcept;</code></pre> 
 <p><strong>功能描述：</strong></p> 
 <ul><li><strong>清空内容</strong>：调用<code>clear()</code>后，字符串中的所有字符都将被移除，字符串长度变为0。</li><li><strong>保留容量</strong>：虽然字符串变得为空，但它所占用的内存容量（即可以存储的字符数量而无需重新分配内存）通常保持不变。这意味着，再次添加字符时，直到达到原有容量之前，不会触发新的内存分配。</li><li><strong>性能优势</strong>：由于不需要重新分配内存，对于频繁需要清空并重新填充内容的场景，使用<code>clear()</code>比反复创建新的字符串对象更为高效。</li></ul> 
</blockquote> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() 
{
    string str = "Hello, World!";

    cout &lt;&lt; "Before clear: \"" &lt;&lt; str &lt;&lt; "\", Size: " &lt;&lt; str.size() &lt;&lt; ", Capacity: " &lt;&lt; str.capacity() &lt;&lt; endl;

    str.clear();

    cout &lt;&lt; "After clear: \"" &lt;&lt; str &lt;&lt; "\", Size: " &lt;&lt; str.size() &lt;&lt; ", Capacity: " &lt;&lt; str.capacity() &lt;&lt; endl;

    return 0;
}</code></pre> 
<p> 代码结果：<img alt="" height="83" src="https://images2.imgbox.com/9b/6f/o8CfM7NL_o.png" width="445"></p> 
<h3><strong>  使用empty判断对象是否为空</strong></h3> 
<p><img alt="" height="235" src="https://images2.imgbox.com/d0/c6/GjrDu4Ly_o.png" width="738"></p> 
<blockquote> 
 <p><strong>函数原型：</strong></p> 
 <pre><code>bool empty() const noexcept;</code></pre> 
 <p><strong>功能描述：</strong></p> 
 <ul><li><strong>检查字符串状态</strong>：<code>empty()</code>函数不接受任何参数，它检查调用该函数的字符串对象是否为空。</li><li><strong>返回值</strong>：如果字符串长度为0，表示字符串为空，则返回<code>true</code>；如果字符串包含至少一个字符，则返回<code>false</code>。</li><li><strong>常量成员函数</strong>：由于它被声明为<code>const</code>，这意味着它不会修改字符串对象的状态，只读取信息。</li></ul> 
</blockquote> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() 
{
    string str1 = "";
    string str2 = "Hello";

    if (str1.empty()) 
    {
        cout &lt;&lt; "str1 is empty." &lt;&lt; endl;
    }
    else 
    {
        cout &lt;&lt; "str1 is not empty." &lt;&lt; endl;
    }

    if (str2.empty()) 
    {
        cout &lt;&lt; "str2 is empty." &lt;&lt; endl;
    }
    else 
    {
        cout &lt;&lt; "str2 is not empty." &lt;&lt; endl;
    }

    return 0;
}</code></pre> 
<p>代码结果：<img alt="" height="79" src="https://images2.imgbox.com/ac/4a/D1K6y1cJ_o.png" width="250"></p> 
<h2 id="string%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE">string中元素的访问</h2> 
<h3><strong>  [ ]+下标</strong></h3> 
<p><img alt="" height="433" src="https://images2.imgbox.com/a1/f8/4iLDdfgz_o.png" width="745"></p> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() 
{
    string str = "Hello, World!";

    // 访问第一个字符
    char firstChar = str[0];
    cout &lt;&lt; "First character: " &lt;&lt; firstChar &lt;&lt; endl; // 输出 H

    // 访问最后一个字符
    char lastChar = str[str.size() - 1];
    cout &lt;&lt; "Last character: " &lt;&lt; lastChar &lt;&lt; endl; // 输出 !
}
</code></pre> 
<p>代码结果：<img alt="" height="78" src="https://images2.imgbox.com/22/2b/ajdvgvrV_o.png" width="248"></p> 
<h3><strong>  使用at访问对象中的元素</strong></h3> 
<p><img alt="" height="418" src="https://images2.imgbox.com/7f/9f/1VM90g7D_o.png" width="737"></p> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;stdexcept&gt; // 引入此头文件以处理std::out_of_range异常

int main() 
{
    try {
        std::string str = "Hello, World!";

        // 安全地访问第一个字符
        char firstChar = str.at(0);
        std::cout &lt;&lt; "First character: " &lt;&lt; firstChar &lt;&lt; std::endl; // 输出 H

        // 尝试访问超出范围的字符，这将抛出异常
        char invalidAccess = str.at(20); // 假设字符串没有这么长
        std::cout &lt;&lt; "Invalid access character: " &lt;&lt; invalidAccess &lt;&lt; std::endl;
    }
    catch (const std::out_of_range&amp; e) 
    {
        std::cerr &lt;&lt; "Caught an out_of_range exception: " &lt;&lt; e.what() &lt;&lt; std::endl;
    }

    return 0;
}</code></pre> 
<p>代码结果：<img alt="" height="79" src="https://images2.imgbox.com/c4/ef/C9S6QNIK_o.png" width="474"></p> 
<h3><strong>  使用范围for访问对象中的元素</strong></h3> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() 
{
    std::string str = "Hello, World!";

    // 使用范围for循环遍历字符串中的每个字符
    for (char ch : str) 
    {
        std::cout &lt;&lt; ch &lt;&lt; std::endl; // 分别打印每个字符
    }

    // 或者，如果你想在一行中打印整个字符串，不换行
    std::cout &lt;&lt; "Printing the string in one line: ";
    for (char ch : str) 
    {
        std::cout &lt;&lt; ch;
    }
    std::cout &lt;&lt; std::endl; // 在所有字符打印完成后换行

    return 0;
}</code></pre> 
<p>代码结果：<img alt="" height="272" src="https://images2.imgbox.com/8d/bf/TFk53ILS_o.png" width="407"></p> 
<p> </p> 
<h3><strong>  使用迭代器访问对象中的元素</strong></h3> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() 
{
    std::string str = "Hello, World!";

    // 使用迭代器遍历字符串
    for (std::string::iterator it = str.begin(); it != str.end(); ++it) 
    {
        std::cout &lt;&lt; *it &lt;&lt; std::endl; // 打印每个字符
    }

    // 使用const_iterator进行只读遍历
    for (std::string::const_iterator cit = str.cbegin(); cit != str.cend(); ++cit) 
    {
        std::cout &lt;&lt; *cit; // 同样打印每个字符，但明确表示不修改
    }
    std::cout &lt;&lt; std::endl; // 在所有字符打印完成后换行

    return 0;
}</code></pre> 
<p>代码结果：<img alt="" height="269" src="https://images2.imgbox.com/d0/4e/baAsk8q7_o.png" width="251"></p> 
<h2 id="string%E4%B8%AD%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8">string中运算符的使用</h2> 
<h3><strong>  operator=</strong></h3> 
<p><img alt="" height="142" src="https://images2.imgbox.com/1a/c2/Uw7MY5Tx_o.png" width="739"></p> 
<p> 代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main()
{
	string s1;
	string s2("CSDN");

	//支持string类的赋值
	s1 = s2;
	cout &lt;&lt; s1 &lt;&lt; endl; //CSDN

	//支持字符串的赋值
	s1 = "hello";
	cout &lt;&lt; s1 &lt;&lt; endl;  //hello

	//支持字符的赋值
	s1 = 'x';
	cout &lt;&lt; s1 &lt;&lt; endl; //x

	return 0;
}
</code></pre> 
<p>代码结果：<img alt="" height="95" src="https://images2.imgbox.com/12/89/YAvysbtm_o.png" width="257"></p> 
<p> </p> 
<h3><strong>  operator+=</strong></h3> 
<p><img alt="" height="139" src="https://images2.imgbox.com/df/1b/r3RNkpqQ_o.png" width="739"></p> 
<p> 代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main()
{
	string s1;
	string s2("hello");

	//支持string类的复合赋值
	s1 += s2;
	cout &lt;&lt; s1 &lt;&lt; endl; //hello

	//支持字符串的复合赋值
	s1 += " CSDN";
	cout &lt;&lt; s1 &lt;&lt; endl; //hello CSDN

	//支持字符的复合赋值
	s1 += '!';
	cout &lt;&lt; s1 &lt;&lt; endl; //hello CSDN!

	return 0;
}
</code></pre> 
<p>代码结果：<img alt="" height="93" src="https://images2.imgbox.com/e2/20/zs4qoOtD_o.png" width="272"></p> 
<h3><strong>  operator+</strong></h3> 
<p><img alt="" height="166" src="https://images2.imgbox.com/76/17/6h12cXCb_o.png" width="736"></p> 
<blockquote> 
 <p><strong>基本用法：</strong></p> 
 <ul><li>字符串与字符串相加</li><li>字符串与C风格字符串相加</li><li>字符串与字符相加</li></ul> 
</blockquote> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main()
{
	string s;
	string s1("super");
	string s2("man");
	char str[] = "woman";
	char ch = '!';

	//string类 + string类
	s = s1 + s2;
	cout &lt;&lt; s &lt;&lt; endl; //superman

	//string类 + 字符串
	s = s1 + str;
	cout &lt;&lt; s &lt;&lt; endl; //superwoman

	//字符串 + string类
	s = str + s1;
	cout &lt;&lt; s &lt;&lt; endl; //womansuper

	//string类 + 字符
	s = s1 + ch;
	cout &lt;&lt; s &lt;&lt; endl; //super!
	
	//字符 + string类
	s = ch + s1;
	cout &lt;&lt; s &lt;&lt; endl; //!super

	return 0;
}
</code></pre> 
<p>代码结果：<img alt="" height="124" src="https://images2.imgbox.com/de/84/Jbo8iHXP_o.png" width="249"></p> 
<h3><strong>  operator&gt;&gt; 和 operator&lt;&lt;</strong></h3> 
<p><img alt="" height="495" src="https://images2.imgbox.com/6e/1d/8ZWBBk6Q_o.png" width="743"></p> 
<p><img alt="" height="411" src="https://images2.imgbox.com/03/d3/Tktm1oli_o.png" width="738"></p> 
<blockquote> 
 <p><strong> <code>operator&lt;&lt;</code> (插入运算符)：</strong></p> 
 <ul><li> <p><strong>功能</strong>： 该运算符用于将数据插入到输出流中。最常见的用途是在<code>std::cout</code>上，用于打印变量的值或者字符串到控制台或其他输出设备。</p> </li><li> <p><strong>语法</strong>:<code>：std::cout &lt;&lt; expression1 &lt;&lt; expression2 ...;</code></p> </li><li> <p><strong>示例</strong>：</p> <pre><code class="hljs">int age = 25;
std::string name = "Alice";
std::cout &lt;&lt; "Name: " &lt;&lt; name &lt;&lt; ", Age: " &lt;&lt; age &lt;&lt; std::endl;</code></pre> </li></ul> 
 <p>        上述代码会输出: <code>Name: Alice, Age: 25</code></p> 
</blockquote> 
<blockquote> 
 <p><strong><code>operator&gt;&gt;()</code> (提取运算符)：</strong></p> 
 <ul><li> <p><strong>功能</strong>:：该运算符用于从输入流中提取（读取）数据到变量中。最常用的输入流是<code>std::cin</code>，它通常用于接收用户键盘输入。</p> </li><li> <p><strong>语法</strong>:<code>：std::cin &gt;&gt; variable1 &gt;&gt; variable2 ...;</code></p> </li><li> <p><strong>示例</strong>：</p> <pre><code class="hljs">int number;
std::string inputText;
std::cout &lt;&lt; "Enter an integer: ";
std::cin &gt;&gt; number;
std::cout &lt;&lt; "Enter some text: ";
std::cin &gt;&gt; inputText;</code></pre> </li></ul> 
 <p>        在上述代码中，程序首先提示用户输入一个整数，然后输入一段文本。</p> 
 <p> </p> 
</blockquote> 
<h3><strong>  relational operators</strong></h3> 
<p><img alt="" height="354" src="https://images2.imgbox.com/2c/ba/PhFbZRKP_o.png" width="738"></p> 
<blockquote> 
 <ol><li> <p><strong>等于 (<code>==</code>)</strong></p> 
   <ul><li><strong>功能</strong>：检查两个字符串是否相等，即它们的字符序列完全相同。</li><li><strong>示例</strong>： <pre><code class="hljs">if (str1 == str2) { /* 字符串str1和str2相等 */ }</code></pre> </li></ul></li><li> <p><strong>不等于 (<code>!=</code>)</strong></p> 
   <ul><li><strong>功能</strong>：检查两个字符串是否不相等。</li><li><strong>示例</strong>： <pre><code class="hljs">if (str1 != str2) { /* 字符串str1和str2不相等 */ }</code></pre> </li></ul></li><li> <p><strong>小于 (<code>&lt;</code>)</strong></p> 
   <ul><li><strong>功能</strong>：按照字典顺序，检查左边的字符串是否在右边的字符串之前。</li><li><strong>示例</strong>： <pre><code class="hljs">if (str1 &lt; str2) { /* 字符串str1在str2之前 */ }</code></pre> </li></ul></li><li> <p><strong>大于 (<code>&gt;</code>)</strong></p> 
   <ul><li><strong>功能</strong>：按照字典顺序，检查左边的字符串是否在右边的字符串之后。</li><li><strong>示例</strong>： <pre><code class="hljs">if (str1 &gt; str2) { /* 字符串str1在str2之后 */ }</code></pre> </li></ul></li><li> <p><strong>小于等于 (<code>&lt;=</code>)</strong></p> 
   <ul><li><strong>功能</strong>：检查左边的字符串是否在右边的字符串之前或与之相等。</li><li><strong>示例</strong>： <pre><code class="hljs">if (str1 &lt;= str2) { /* 字符串str1在str2之前或与之相等 */ }</code></pre> </li></ul></li><li> <p><strong>大于等于 (<code>&gt;=</code>)</strong></p> 
   <ul><li><strong>功能</strong>：检查左边的字符串是否在右边的字符串之后或与之相等。</li><li><strong>示例</strong>： <pre><code class="hljs">if (str1 &gt;= str2) { /* 字符串str1在str2之后或与之相等 */ }</code></pre> </li></ul></li></ol> 
</blockquote> 
<blockquote> 
 <p><strong>注意：</strong>这些运算符在比较字符串时，按照字符的ASCII（或Unicode）值逐个进行比较，首先是第一个字符，如果相同则继续比较下一个，直到找到不匹配的字符或一个字符串结束。 </p> 
</blockquote> 
<h2 id="string%E4%B8%AD%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0">string中与迭代器相关的函数</h2> 
<h3><strong>  与正向迭代器相关的函数</strong></h3> 
<h4><strong>        begin函数</strong></h4> 
<p><img alt="" height="111" src="https://images2.imgbox.com/b8/fb/6kQXYVWn_o.png" width="743"></p> 
<blockquote> 
 <p><strong>函数原型：</strong></p> 
 <pre><code class="hljs">iterator begin();
const_iterator begin() const;</code></pre> 
 <p><strong>功能说明：</strong></p> 
 <ul><li> <p><strong>非const版本</strong>：<code>begin()</code>返回一个迭代器，指向字符串的第一个字符。这个迭代器是可修改的，意味着你可以通过它来修改字符串的内容。</p> </li><li> <p><strong>const版本</strong>：在<code>const</code>上下文中（比如字符串为<code>const std::string</code>类型或者被<code>const</code>引用或指针引用），<code>begin()</code>返回一个<code>const_iterator</code>，它只能用于读取字符串内容，不能修改。</p> </li></ul> 
</blockquote> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() 
{
    std::string str = "Hello, World!";

    // 遍历字符串
    for (auto it = str.begin(); it != str.end(); ++it) 
    {
        std::cout &lt;&lt; *it; // 输出字符串中的每个字符
    }
    std::cout &lt;&lt; std::endl;

    // 在const上下文中的使用
    const std::string constStr = "Example";
    for (auto cit = constStr.begin(); cit != constStr.end(); ++cit) 
    {
        std::cout &lt;&lt; *cit; // 输出: Example
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}</code></pre> 
<p>代码结果：<img alt="" height="77" src="https://images2.imgbox.com/06/7b/Yh5E4WvM_o.png" width="274"></p> 
<h4><strong>        end函数</strong></h4> 
<p><img alt="" height="116" src="https://images2.imgbox.com/b3/fa/8Aa3OgAS_o.png" width="738"></p> 
<blockquote> 
 <p><strong> 函数原型：</strong></p> 
 <pre><code>iterator end(); 
const_iterator end() const;</code></pre> 
 <p><strong>功能说明：</strong></p> 
 <ul><li> <p><strong>非const版本</strong>：返回一个迭代器，指向字符串的末端，可以用来检测遍历是否结束，但不应解引用此迭代器访问实际的字符。</p> </li><li> <p><strong>const版本</strong>：在<code>const</code>上下文中，<code>end()</code>返回一个<code>const_iterator</code>，同样指向字符串末端，用于只读操作。</p> </li></ul> 
</blockquote> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() 
{
    std::string str = "Hello, World!";

    // 遍历字符串
    for (auto it = str.begin(); it != str.end(); ++it) 
    {
        std::cout &lt;&lt; *it; // 输出字符串中的每个字符
    }
    std::cout &lt;&lt; std::endl;

    // 在const上下文中的使用
    const std::string constStr = "Example";
    for (auto cit = constStr.begin(); cit != constStr.end(); ++cit) 
    {
        std::cout &lt;&lt; *cit; // 输出: Example
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}</code></pre> 
<p>代码结果：<img alt="" height="77" src="https://images2.imgbox.com/da/2a/2m36Nvux_o.png" width="250"></p> 
<h3><strong>  与反向迭代器相关的函数</strong></h3> 
<h4>        rbegin函数</h4> 
<p><img alt="" height="116" src="https://images2.imgbox.com/f6/54/XmZiwp2D_o.png" width="736"></p> 
<blockquote> 
 <p><strong>函数原型：</strong></p> 
 <pre><code>reverse_iterator rbegin(); 
const_reverse_iterator rbegin() const;</code></pre> 
 <p><strong>功能说明：</strong></p> 
 <ul><li> <p><strong>非const版本</strong>：返回一个反向迭代器，初始时指向字符串的最后一个字符。这个迭代器允许你从字符串的末尾向前遍历。</p> </li><li> <p><strong>const版本</strong>：在<code>const</code>上下文中，<code>rbegin()</code>返回一个<code>const_reverse_iterator</code>，同样指向字符串的最后一个字符，但不允许修改字符串内容。</p> </li></ul> 
</blockquote> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() 
{
    std::string str = "Hello, World!";

    // 反向遍历字符串
    for (auto rit = str.rbegin(); rit != str.rend(); ++rit) 
    {
        std::cout &lt;&lt; *rit; // 逆序输出字符串中的每个字符
    }
    std::cout &lt;&lt; std::endl;

    // 在const上下文中的使用
    const std::string constStr = "Example";
    for (auto crit = constStr.rbegin(); crit != constStr.rend(); ++crit) 
    {
        std::cout &lt;&lt; *crit; // 逆序输出: !dlroW ,olleH
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}</code></pre> 
<p>代码结果：<img alt="" height="79" src="https://images2.imgbox.com/29/31/4fsCjcZa_o.png" width="245"></p> 
<h4>        rend函数</h4> 
<p><img alt="" height="114" src="https://images2.imgbox.com/fc/d8/8gWTonYg_o.png" width="735"></p> 
<blockquote> 
 <p><strong>函数原型：</strong></p> 
 <pre><code>reverse_iterator rend(); 
const_reverse_iterator rend() const;</code></pre> 
 <p><strong>功能说明：</strong></p> 
 <ul><li> <p><strong>非const版本</strong>：返回一个反向迭代器，逻辑上位于字符串的开始位置之前，用于标识反向遍历的终点。</p> </li><li> <p><strong>const版本</strong>：在<code>const</code>上下文中，<code>rend()</code>返回一个<code>const_reverse_iterator</code>，同样位于开始位置之前，确保遍历时不可修改字符串。</p> </li></ul> 
</blockquote> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() 
{
    std::string str = "Hello, World!";

    // 反向遍历字符串
    for(auto rit = str.rbegin(); rit != str.rend(); ++rit) 
    {
        std::cout &lt;&lt; *rit; // 逆序输出字符串中的每个字符，直到遇到rend()
    }
    std::cout &lt;&lt; std::endl;

    // 在const上下文中的使用
    const std::string constStr = "Example";
    for(auto crit = constStr.rbegin(); crit != constStr.rend(); ++crit) 
    {
        std::cout &lt;&lt; *crit; // 类似地，逆序输出: !elpmaxE
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}</code></pre> 
<p>代码结果：<img alt="" height="78" src="https://images2.imgbox.com/9d/20/KmZroixj_o.png" width="273"></p> 
<h2 id="string%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2">string与字符串之间的转换</h2> 
<h3><strong>  将字符串转换为string</strong></h3> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main()
{
	//方式一
	string s1("hello world");

	//方式二
	char str[] = "hello world";
	string s2(str);

	cout &lt;&lt; s1 &lt;&lt; endl; //hello world
	cout &lt;&lt; s2 &lt;&lt; endl; //hello world

	return 0;
}
</code></pre> 
<h3><strong>  使用c_str或data将string转换为字符串</strong></h3> 
<p><img alt="" height="423" src="https://images2.imgbox.com/fc/79/liCYYgj9_o.png" width="743"></p> 
<p><img alt="" height="439" src="https://images2.imgbox.com/75/92/OsowLjn6_o.png" width="741"></p> 
<blockquote> 
 <p><strong>c_str()：</strong></p> 
 <ul><li><strong>功能</strong>：<code>c_str()</code>方法返回一个指向常量字符数组的指针，这个字符数组包含了<code>std::string</code>对象的内容，末尾带有空字符<code>\0</code>。这意味着返回的指针指向的数据是不可修改的。</li><li><strong>适用场景</strong>：当你需要将<code>std::string</code>传递给要求C字符串的API或者C库函数时（例如<code>printf</code>），应使用<code>c_str()</code>。因为这些函数期望字符串以<code>\0</code>结尾，并且通常假设字符串是不可变的。</li></ul> 
 <p><strong>data()：</strong></p> 
 <ul><li><strong>功能</strong>：<code>data()</code>方法同样返回一个指向字符数组的指针，该数组包含了字符串的内容，但直到C++11标准，<code>data()</code>返回的指针是否以<code>\0</code>结尾并未明确规定。从C++11开始，<code>data()</code>保证了当字符串不是空字符串时，返回的指针指向的数组末尾也会有<code>\0</code>。不过，与<code>c_str()</code>不同的是，如果<code>std::string</code>对象是可变的，通过<code>data()</code>获得的指针指向的数据可能是可修改的。</li><li><strong>适用场景</strong>：当你只需要读取字符串内容而不需要确保字符串不可变，或者需要传递给接受<code>const char*</code>但不修改其内容的函数时，可以使用<code>data()</code>。但在将字符串传递给可能修改其内容的C函数之前，应当谨慎，最好使用<code>c_str()</code>或确保<code>std::string</code>对象本身不可变。</li></ul> 
</blockquote> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() 
{
    std::string str = "Hello, World!";
    
    // 使用c_str()方法
    const char* cStr = str.c_str();
    std::cout &lt;&lt; "Using c_str(): " &lt;&lt; cStr &lt;&lt; std::endl;

    // 使用data()方法
    const char* pData = str.data();
    std::cout &lt;&lt; "Using data(): " &lt;&lt; pData &lt;&lt; std::endl;

    return 0;
}</code></pre> 
<p>代码结果：<img alt="" height="78" src="https://images2.imgbox.com/b9/b0/9qzTx6gK_o.png" width="258"></p> 
<h2 id="string%E4%B8%AD%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8F%90%E5%8F%96">string中子字符串的提取</h2> 
<h3><strong>  使用substr函数提取string中的子字符串</strong></h3> 
<p><img alt="" height="464" src="https://images2.imgbox.com/3a/c1/I534HHb8_o.png" width="740"></p> 
<blockquote> 
 <p><strong>函数原型：</strong></p> 
 <pre><code>std::string substr(size_type pos = 0, size_type n = npos) const;</code></pre> 
 <p><strong>参数说明：</strong></p> 
 <ul><li><strong>pos</strong>：子字符串开始提取的位置索引，默认为0，即字符串的起始位置。</li><li><strong>n</strong>：要提取的字符数量。如果省略或设置为<code>npos</code>（<code>std::string::npos</code>表示最大可能值，通常用作结束标志），则提取从<code>pos</code>开始到字符串结束的所有字符。</li></ul> 
 <p><strong>返回值：</strong></p> 
 <p>        返回一个新的<code>std::string</code>对象，包含从原字符串中提取的子字符串。</p> 
</blockquote> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() 
{
    std::string originalString = "Hello, World!";
    
    // 提取从位置3开始的5个字符
    std::string subStr1 = originalString.substr(3, 5);
    std::cout &lt;&lt; "Substring 1: " &lt;&lt; subStr1 &lt;&lt; std::endl; // 输出: lo, W
    
    // 提取从位置7到字符串结束的子字符串
    std::string subStr2 = originalString.substr(7);
    std::cout &lt;&lt; "Substring 2: " &lt;&lt; subStr2 &lt;&lt; std::endl; // 输出: World!
    
    // 提取整个字符串（等效于pos=0, n=npos）
    std::string subStr3 = originalString.substr();
    std::cout &lt;&lt; "Substring 3: " &lt;&lt; subStr3 &lt;&lt; std::endl; // 输出: Hello, World!
    
    return 0;
}</code></pre> 
<p>代码结果：<img alt="" height="95" src="https://images2.imgbox.com/9a/6e/xnhXvaNo_o.png" width="249"></p> 
<h3><strong>  使用copy函数将string的子字符串复制到字符数组中</strong> </h3> 
<p><img alt="" height="489" src="https://images2.imgbox.com/d5/91/pSSCvOlG_o.png" width="745"></p> 
<p> 代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt; // 包含std::copy
#include &lt;iterator&gt;  // 包含std::begin, std::end

int main() 
{
    std::string str = "Hello, World!";
    char charArray[10]; // 目标字符数组

    // 使用substr获取子字符串
    std::string subStr = str.substr(0, 5); // 获取前5个字符 "Hello"

    // 使用std::copy将子字符串复制到字符数组
    std::copy(subStr.begin(), subStr.end(), charArray);

    // 确保字符串末尾加上空字符
    charArray[subStr.size()] = '\0';

    std::cout &lt;&lt; "Copied substring: " &lt;&lt; charArray &lt;&lt; std::endl;

    return 0;
}</code></pre> 
<p>代码结果：<img alt="" height="62" src="https://images2.imgbox.com/e8/05/zmSjx1Hv_o.png" width="273"></p> 
<h2 id="string%E4%B8%AD%E7%9A%84getline%E5%87%BD%E6%95%B0">string中的getline函数</h2> 
<blockquote> 
 <p><strong>函数原型：</strong></p> 
 <pre><code>std::istream&amp; getline(std::istream&amp; is, std::string&amp; str, char delim = '\n');</code></pre> 
 <p><strong>参数说明：</strong></p> 
 <ul><li><strong>is</strong>：输入流对象，通常为<code>std::cin</code>，但也可以是其他输入流对象，如文件流<code>std::ifstream</code>。</li><li><strong>str</strong>：<code>std::string</code>对象的引用，用于存储读取到的行内容。</li><li><strong>delim</strong>：可选参数，指定的分隔符，默认为<code>\n</code>（换行符）。读取会停止于该分隔符，但分隔符本身不会被存储在字符串中。</li></ul> 
</blockquote> 
<p>代码演示：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() 
{
    std::string userInput;

    std::cout &lt;&lt; "请输入一行文本: ";
    // 读取整行文本直到遇到换行符
    std::getline(std::cin, userInput);
    std::cout &lt;&lt; "你输入的是: " &lt;&lt; userInput &lt;&lt; std::endl;

    // 另一个例子，使用自定义分隔符
    std::cout &lt;&lt; "使用自定义分隔符读取（以#结束）: ";
    std::getline(std::cin, userInput, '#');
    std::cout &lt;&lt; "你输入的是: " &lt;&lt; userInput &lt;&lt; std::endl;

    return 0;
}</code></pre> 
<p>代码演示：<img alt="" height="113" src="https://images2.imgbox.com/c0/45/gZizcpJe_o.png" width="339"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/64ab23115e979161338109f01b57d0ec/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于SSM实现的新生报到系统源码&#43;数据库&#43;论文</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6da9031b7f65b239b9122f43966e4700/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构|C语言版】树、二叉树和堆</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>