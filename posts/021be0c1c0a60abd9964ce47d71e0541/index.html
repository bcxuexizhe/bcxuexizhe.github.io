<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>计算机网络-运输层 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/021be0c1c0a60abd9964ce47d71e0541/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="计算机网络-运输层">
  <meta property="og:description" content="运输层 网络层在两个端系统之间的交付服务拓展到运行在两个不同端系统上的应用层进程之间的交付服务。
概述和运输层服务 运输层协议为运行在不同主机上的引用进程之间提供了逻辑通信功能。通过逻辑通信，运行在不同进程之间的主机好像直接连接一样。
运输层协议是在端系统而不是在服务器中实现的，在发送端，运输层将发送引用程序进程接受到的报文[运输层报文端]转换为运输层分组。实现的方法是将应用报文划分为小块，并且为每块加上一个运输层首部以生成运输层报文段。在发送端系统中，运输层将这些报文段传输给网络层，网络层对这些字段进行封装，变为网络层分组，并且向目的地发送。网络路由器作用域该数据报的网络层字段，不检查封装在该数据爆的运输层报文端的字段。在接收端，网络层从数据报中提取运输层报文段。并且为报文段向上交运输层。运输层处理接受到的报文段。使得该报文段中的数据为接受应用进程使用
运输层和网络层的关系 网络层为运输层提供最基本的数据传送服务，而运输层则在网络层的基础上提供更高层次的、更可靠的通信服务。
因特网运输层概述 应用开发人员在生成套接字的时候必须选定是udp还是tcp。将运输层分组称为报文段。也可以将tcp的运输层分组称为报文段，将udp的分组称为数据报文。将TCP和UDP的分组统称为报文段，而将数据报名称保留给网络层分组
多路复用和多路分解 网络层提供的主机到主机交付服务延伸到运行在主机上的应用程序提供进程到进程的交付服务。多路复用和多路分解服务是所有计算机网络都需要的
在目的主机，运输层从网络层接受报文段，运输层将这些报文中的数据交付给主机上运行的应用程序进程。
多路分解: 每个运输层报文段中具有几个字段，在接收端，运输层会检查这些字段，标识出接收套接字。从而将报文段定向到该套接字。将运输层报文段中的数据交付到正确的套接字的工作叫做多路分解
多路复用: 在源主机从不同的套接字中收集数据块，并为每个数据封装上首部信息，从而生成报文段。然后将报文段传递到网络层，这种工作叫做多路复用
在主机上的每个套接字能够分配一个端口号，当报文段到达主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字。然后报文段中的数据通过套接字进入其所连接的进程。如我们将看到的那样，UDP大体上是这样做的
无连接的多路复用和多路分解 一个udp是由一个二元组全面标识的，该二元组包含一个目的的ip地址和一个目的的端口号，因此，如果两个udp报文段有不同源ip地址和源端口号，但是具有相同的目的ip地址和目的端口号，那么这两个报文段通过相同的目的套接字被定向到相同的目的进程。
面向连接的多路复用和多路分解 TCP套接字和 UDP套接字之间的一个细微差别是，TCP套接字是由一个四元组(源IP地址源端口号，目的IP地址，目的端口号)来标识的。当一个TCP报文段从网络到达一台主机时，该主机使用全部4个值来将报文段定向(分解)到相应的套接字。两个具有不同源里地址或源端口号的到达TCP报文段将被定向到两个不同的套接字，除非TCP报文段携带了初始创建连接的请求。
web服务器与TCP 连接套接字与进程之间并非总是有着一一对应的关系。事实上，当今的高性能Web服务器通常只使用一个进程，但是为每个新的客户连接创建一个具有新连接套接字的新线程。(线程可被看作是一个轻量级的子进程)
如果客户与服务器使用持续HTTP，则在整条连接持续期间，客户与服务器之间经由同一个服务器套接字交换HTTP报文。然而，如果客户与服务器使用非持续HTTP，则对每一对请求/响应都创建一个新的TCP连接并在随后关闭，因此对每一对请求/响应创建一个新的套接字并在随后关闭。
无连接运输:UDP UDP报文段结构 应用层数据占用UDP报文段的数据字段。通过端口号可以使得目的主机将应用数据交给运行在目的端系统的主机中的相应进程。
长度字段指示了在udp报文段中的字节数。
UDP检验和 在数据接收端，接收端会按照相同的规则对接收端的udp数据包进行计算，得到一个新的校验和值，然后接收方会将这个新的校验和值和数据包中携带的原始校验和值进行比较，如果相等，则说明在传输过程中没有发生错误。
udp校验和只能提供一定程度的错误检测功能，并不能保证数据的可靠性传输。udp协议不存在重传机制。在使用udp协议进行数据传输的时候，需要应用层来负责处理可能出现的错误和丢包的数据包。
可靠数据连接运输原理 可靠数据传输的实现问题不仅在运输层中出现，也会在链路层以及应用层中出现。数据可以通过一条可靠的信道进行传输，借助于可靠信道，传输数据比特不会受到损坏或者丢失。
实现这种服务抽象的是可靠数据运输协议。
构造可靠数据传输协议 经完全可靠信道数据传输: rdt1.0 它主要基于完全可靠的信道进行数据传输。在这个协议中，主要有传输端和接收端两个部分。传输端等待上层传递数据，一旦收到数据，就将其打包成封包并发送出去。接收端在收到封包后，会将其解开，然后将数据发送到上层应用。
RDT1.0假设底层的信道是完全可靠的，即没有比特错误和分组丢失，数据分组会按照顺序到达。发送方和接收方都有各自的有限状态机（FSM）来控制数据的传输和接收。
经具有比特差错信造的可靠数据传输: rdt2.0 ARQ[自动重传请求协议]: 当传输介质不能保证数据的通信质量时（例如，在无线通信中），就需要采用错误控制方法来纠正传输过程中可能产生的错误。ARQ 就是一种广泛使用的错误控制方法。
差错检测: 使接收方检测到何时出现了比特差错
接收方反馈: 让接收方提供明确的反馈信息给发送方
重传: 接收方收到有差错的分组时，发送方将重传该分组文
停等协议: 发送方每发送一个数据分组后，就会进入等待状态，直到收到接收方的确认消息。如果收到 NAK 消息，发送方会重传上一个数据分组。该方法简单但效率较低，因为发送方在等待确认消息时不能发送新的数据分组。
考虑到 ACK 或 NAK 分组受损的可能性
经具有比特差错的丢包信道的可靠数据传输: rdt3.0 超时重传：为了处理数据丢失的情况，RDT3.0使用了超时重传机制。如果在预定的时间内没有收到确认信息，发送方会重新发送数据包。
状态机：RDT3.0的操作可以通过发送方和接收方的状态机来描述。状态机定义了在不同情况下应该采取的动作，比如发送数据、等待确认或者重传数据包。
流水线可靠数据传输协议 必须增加序号范围，因为每个输送中的分组(不计算重传的)必须有一个唯一的序号，而且也许有多个在输送中的未确认报文。
协议的发送方和接收方两端也许不得不缓存多个分组。发送方最低限度应当能缓冲那些已发送但没有确认的分组。接收方或许也需要缓存那些已正确接收的分组。
所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。解决流水线的差错恢复有两种基本方法是:回退N步(Go-Back-N，CBN)和选择重传(SelectiveRepeat，SR)。
回退N步 将基序号(base)定义为最早未确认分组的序号，将下一个序号(nextseqmum)定义为最小的未使用序号(即下一个待发分组的序号)，则可将序号范围分割成4段。在[0，base-1]段内的序号对应于已经发送并被确认的分组。[base，nextseqnum-1]段内对应已经发送但未被确认的分组。[nextseqnum，base&#43;N-1]段内的序号能用于那些要被立即发送的分组，如果有数据来自上层的话。最后，大于或等于base&#43;N的序号是不能使用的，直到当前流水线中未被确认的分组(特别是序号为base的分组)已得到确认为止。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-27T17:39:20+08:00">
    <meta property="article:modified_time" content="2024-05-27T17:39:20+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">计算机网络-运输层</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>运输层</h2> 
<p>网络层在两个端系统之间的交付服务拓展到运行在两个不同端系统上的应用层进程之间的交付服务。</p> 
<h3><a id="_2"></a>概述和运输层服务</h3> 
<p>运输层协议为运行在不同主机上的引用进程之间提供了逻辑通信功能。通过逻辑通信，运行在不同进程之间的主机好像直接连接一样。<br> <img src="https://images2.imgbox.com/ea/b3/KROGYkIf_o.png" alt="在这里插入图片描述"></p> 
<p>运输层协议是在端系统而不是在服务器中实现的，在发送端，运输层将发送引用程序进程接受到的报文[运输层报文端]转换为运输层分组。实现的方法是将应用报文划分为小块，并且为每块加上一个运输层首部以生成运输层报文段。在发送端系统中，运输层将这些报文段传输给网络层，网络层对这些字段进行封装，变为网络层分组，并且向目的地发送。网络路由器作用域该数据报的网络层字段，不检查封装在该数据爆的运输层报文端的字段。在接收端，网络层从数据报中提取运输层报文段。并且为报文段向上交运输层。运输层处理接受到的报文段。使得该报文段中的数据为接受应用进程使用</p> 
<h4><a id="_7"></a>运输层和网络层的关系</h4> 
<p>网络层为运输层提供最基本的数据传送服务，而运输层则在网络层的基础上提供更高层次的、更可靠的通信服务。</p> 
<h4><a id="_9"></a>因特网运输层概述</h4> 
<p>应用开发人员在生成套接字的时候必须选定是udp还是tcp。将运输层分组称为报文段。也可以将tcp的运输层分组称为报文段，将udp的分组称为数据报文。将TCP和UDP的分组统称为报文段，而将数据报名称保留给网络层分组</p> 
<h3><a id="_11"></a>多路复用和多路分解</h3> 
<p>网络层提供的主机到主机交付服务延伸到运行在主机上的应用程序提供进程到进程的交付服务。多路复用和多路分解服务是所有计算机网络都需要的<br> 在目的主机，运输层从网络层接受报文段，运输层将这些报文中的数据交付给主机上运行的应用程序进程。<br> <img src="https://images2.imgbox.com/f1/d5/xxIz154i_o.png" alt="在这里插入图片描述"></p> 
<p>多路分解: 每个运输层报文段中具有几个字段，在接收端，运输层会检查这些字段，标识出接收套接字。从而将报文段定向到该套接字。将运输层报文段中的数据交付到正确的套接字的工作叫做多路分解<br> 多路复用: 在源主机从不同的套接字中收集数据块，并为每个数据封装上首部信息，从而生成报文段。然后将报文段传递到网络层，这种工作叫做多路复用<br> <img src="https://images2.imgbox.com/1f/3f/zoy3O5Cr_o.png" alt="在这里插入图片描述"></p> 
<p>在主机上的每个套接字能够分配一个端口号，当报文段到达主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字。然后报文段中的数据通过套接字进入其所连接的进程。如我们将看到的那样，UDP大体上是这样做的</p> 
<h4><a id="_21"></a>无连接的多路复用和多路分解</h4> 
<p>一个udp是由一个二元组全面标识的，该二元组包含一个目的的ip地址和一个目的的端口号，因此，如果两个udp报文段有不同源ip地址和源端口号，但是具有相同的目的ip地址和目的端口号，那么这两个报文段通过相同的目的套接字被定向到相同的目的进程。<br> <img src="https://images2.imgbox.com/d7/af/ogEQFRRH_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_25"></a>面向连接的多路复用和多路分解</h4> 
<p>TCP套接字和 UDP套接字之间的一个细微差别是，TCP套接字是由一个四元组(源IP地址源端口号，目的IP地址，目的端口号)来标识的。当一个TCP报文段从网络到达一台主机时，该主机使用全部4个值来将报文段定向(分解)到相应的套接字。两个具有不同源里地址或源端口号的到达TCP报文段将被定向到两个不同的套接字，除非TCP报文段携带了初始创建连接的请求。<br> <img src="https://images2.imgbox.com/e9/57/iTb7o8c5_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="webTCP_29"></a>web服务器与TCP</h4> 
<p>连接套接字与进程之间并非总是有着一一对应的关系。事实上，当今的高性能Web服务器通常只使用一个进程，但是为每个新的客户连接创建一个具有新连接套接字的新线程。(线程可被看作是一个轻量级的子进程)<br> 如果客户与服务器使用持续HTTP，则在整条连接持续期间，客户与服务器之间经由同一个服务器套接字交换HTTP报文。然而，如果客户与服务器使用非持续HTTP，则对每一对请求/响应都创建一个新的TCP连接并在随后关闭，因此对每一对请求/响应创建一个新的套接字并在随后关闭。</p> 
<h3><a id="UDP_32"></a>无连接运输:UDP</h3> 
<h4><a id="UDP_33"></a>UDP报文段结构</h4> 
<p>应用层数据占用UDP报文段的数据字段。通过端口号可以使得目的主机将应用数据交给运行在目的端系统的主机中的相应进程。<br> 长度字段指示了在udp报文段中的字节数。<br> <img src="https://images2.imgbox.com/8d/5e/hSEzHHvK_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="UDP_38"></a>UDP检验和</h4> 
<p>在数据接收端，接收端会按照相同的规则对接收端的udp数据包进行计算，得到一个新的校验和值，然后接收方会将这个新的校验和值和数据包中携带的原始校验和值进行比较，如果相等，则说明在传输过程中没有发生错误。<br> udp校验和只能提供一定程度的错误检测功能，并不能保证数据的可靠性传输。udp协议不存在重传机制。在使用udp协议进行数据传输的时候，需要应用层来负责处理可能出现的错误和丢包的数据包。</p> 
<h3><a id="_41"></a>可靠数据连接运输原理</h3> 
<p>可靠数据传输的实现问题不仅在运输层中出现，也会在链路层以及应用层中出现。数据可以通过一条可靠的信道进行传输，借助于可靠信道，传输数据比特不会受到损坏或者丢失。<br> <img src="https://images2.imgbox.com/8f/aa/LGWH53KS_o.png" alt="在这里插入图片描述"></p> 
<p>实现这种服务抽象的是可靠数据运输协议。</p> 
<h4><a id="_46"></a>构造可靠数据传输协议</h4> 
<h5><a id="_rdt10_47"></a>经完全可靠信道数据传输: rdt1.0</h5> 
<p>它主要基于完全可靠的信道进行数据传输。在这个协议中，主要有传输端和接收端两个部分。传输端等待上层传递数据，一旦收到数据，就将其打包成封包并发送出去。接收端在收到封包后，会将其解开，然后将数据发送到上层应用。<br> RDT1.0假设底层的信道是完全可靠的，即没有比特错误和分组丢失，数据分组会按照顺序到达。发送方和接收方都有各自的有限状态机（FSM）来控制数据的传输和接收。</p> 
<h5><a id="_rdt20_50"></a>经具有比特差错信造的可靠数据传输: rdt2.0</h5> 
<p>ARQ[自动重传请求协议]: 当传输介质不能保证数据的通信质量时（例如，在无线通信中），就需要采用错误控制方法来纠正传输过程中可能产生的错误。ARQ 就是一种广泛使用的错误控制方法。<br> 差错检测: 使接收方检测到何时出现了比特差错<br> 接收方反馈: 让接收方提供明确的反馈信息给发送方<br> 重传: 接收方收到有差错的分组时，发送方将重传该分组文<br> 停等协议: 发送方每发送一个数据分组后，就会进入等待状态，直到收到接收方的确认消息。如果收到 NAK 消息，发送方会重传上一个数据分组。该方法简单但效率较低，因为发送方在等待确认消息时不能发送新的数据分组。<br> 考虑到 ACK 或 NAK 分组受损的可能性</p> 
<h5><a id="_rdt30_57"></a>经具有比特差错的丢包信道的可靠数据传输: rdt3.0</h5> 
<p><img src="https://images2.imgbox.com/a8/9d/iUOAXxvy_o.png" alt="在这里插入图片描述"></p> 
<p>超时重传：为了处理数据丢失的情况，RDT3.0使用了超时重传机制。如果在预定的时间内没有收到确认信息，发送方会重新发送数据包。<br> 状态机：RDT3.0的操作可以通过发送方和接收方的状态机来描述。状态机定义了在不同情况下应该采取的动作，比如发送数据、等待确认或者重传数据包。</p> 
<h4><a id="_62"></a>流水线可靠数据传输协议</h4> 
<p>必须增加序号范围，因为每个输送中的分组(不计算重传的)必须有一个唯一的序号，而且也许有多个在输送中的未确认报文。<br> 协议的发送方和接收方两端也许不得不缓存多个分组。发送方最低限度应当能缓冲那些已发送但没有确认的分组。接收方或许也需要缓存那些已正确接收的分组。<br> 所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。解决流水线的差错恢复有两种基本方法是:回退N步(Go-Back-N，CBN)和选择重传(SelectiveRepeat，SR)。<br> <img src="https://images2.imgbox.com/0c/96/OpZ7Rdyf_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="N_68"></a>回退N步</h4> 
<p>将基序号(base)定义为最早未确认分组的序号，将下一个序号(nextseqmum)定义为最小的未使用序号(即下一个待发分组的序号)，则可将序号范围分割成4段。在[0，base-1]段内的序号对应于已经发送并被确认的分组。[base，nextseqnum-1]段内对应已经发送但未被确认的分组。[nextseqnum，base+N-1]段内的序号能用于那些要被立即发送的分组，如果有数据来自上层的话。最后，大于或等于base+N的序号是不能使用的，直到当前流水线中未被确认的分组(特别是序号为base的分组)已得到确认为止。<br> <img src="https://images2.imgbox.com/de/5e/Ugex1Ebh_o.png" alt="在这里插入图片描述"></p> 
<p>随着协议的运行，该窗口在序号空间向前滑动。因此，N常被称为窗口长度, GBN协议也常被称为滑动窗口协议<br> <img src="https://images2.imgbox.com/18/a7/dcoksefW_o.png" alt="在这里插入图片描述"></p> 
<p>数据必须按序交付，接收方可能缓存(保存)分组n+1 ，然后，在它收到并交付分组 n 后，再将该分组交付到上层 。 然<br> 而，如果分组 n 丢失，则该分组及分组 n + 1 最终将在发送方根据GBN重传规则而被重传。接收方只需丢弃分组[n + 1]即可。这种方法的优点是接收缓存简单，即接收方不需要缓存任何失序分组。<br> <img src="https://images2.imgbox.com/e1/0f/9iFQ5zwV_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_78"></a>选择重传</h4> 
<p>选择 重传 (SR) 协议通过让发送方仅重传那些它怀疑在接收方出错(即丢失或受损)的分组而避免了不必要的重传<br> <img src="https://images2.imgbox.com/79/ae/e3VwC7Jf_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/60/03/k6nzQyrv_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/44/b5/0lBsN0tD_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_TCP_85"></a>面向连接的运输: TCP</h3> 
<h4><a id="TCP__86"></a>TCP 连接</h4> 
<p>客户端先服务端发起请求，客户端通知客户运输层，和服务器上的一个进程建立一个连接。客户上的tcp开始向服务器上的tcp简历一条tcp连接，客户首先发送一个特殊的tcp报文作为响应，前两个文段不承载有效载荷，不包含应用层数据，而第三个报文可以承载有效载荷，在这两台主机之间发送了3个报文段，这种连接被称为三次握手<br> 一旦建立起tcp连接，两个应用进程之间就可以相互发送数据了，客户进程向服务器进程发送数据的情况。客户进程通过套接字传递数据流，数据一旦通过该门，就被客户中运行的tcp控制了，tcp将这些数据引导到改连接的发送缓存中，发送缓存是发起三次握手期间设置的缓存之一，接下来tcp机会时不时从发送缓存中取出一块数据，将数据发送到网络层。TCP 可从缓存中取出并放入报文段中的数据数量受限于最大报文段长度<br> TCP为每块客户数据配上一个tcp首部，从而形成多个tcp报文段，这些报文段被下传道网络中，网络层将其封装在网络ip数据报中，然后这些ip数据报被发送到网络层，当tcp在另一端接收到一个报文段的时候，该报文段中的数据被放入到tcp连接的接收缓存中，</p> 
<h3><a id="_TCP_91"></a>面向连接的运输: TCP</h3> 
<h4><a id="TCP__92"></a>TCP 连接</h4> 
<p>客户端先服务端发起请求，客户端通知客户运输层，和服务器上的一个进程建立一个连接。客户上的tcp开始向服务器上的tcp简历一条tcp连接，客户首先发送一个特殊的tcp报文作为响应，前两个文段不承载有效载荷，不包含应用层数据，而第三个报文可以承载有效载荷，在这两台主机之间发送了3个报文段，这种连接被称为三次握手<br> 一旦建立起tcp连接，两个应用进程之间就可以相互发送数据了，客户进程向服务器进程发送数据的情况。客户进程通过套接字传递数据流，数据一旦通过该门，就被客户中运行的tcp控制了，tcp将这些数据引导到改连接的发送缓存中，发送缓存是发起三次握手期间设置的缓存之一，接下来tcp机会时不时从发送缓存中取出一块数据，将数据发送到网络层。TCP 可从缓存中取出并放入报文段中的数据数量受限于最大报文段长度<br> TCP为每块客户数据配上一个tcp首部，从而形成多个tcp报文段，这些报文段被下传道网络中，网络层将其封装在网络ip数据报中，然后这些ip数据报被发送到网络层，当tcp在另一端接收到一个报文段的时候，该报文段中的数据被放入到tcp连接的接收缓存中，<br> <img src="https://images2.imgbox.com/42/85/I82uXvFl_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="TCP__98"></a>TCP 报文段结构</h4> 
<p><img src="https://images2.imgbox.com/b8/c0/qiM5KVBw_o.png" alt="在这里插入图片描述"></p> 
<p>tcp报文段是由首部字段和一个数据字段组成的，数据字段包含一块应用数据，mss限制了报文段数据字段的最大程度，当tcp发送一块大文件，tcp通常是该文件划分为长度为mss的若干块，交互式引用通常传递长度小于mss的数据块<br> 32bit的序号字段和32bit的确认号字段，这些字段被tcp发送方和接受方用来实现可靠数据传输服务<br> 16bit的接受窗口字段用于流量控制，字段用于只是接收方愿意接受的字节数量<br> 4bit的首部长度字段指示了32bit的字为单位的tcp首部长度，由于tcp选项字段的原因，tcp首部的长度是可以变化的。通常选项字段为空，所以tcp的首部的典型长度为20字节。<br> 可选与边长的选项字段，该字段用于发送方与接收方协商最大报文段长度时，或在高速网络环境下用作窗口调节因子的时候使用，首部字段中还定义了一个时间戳选项。<br> 6bit的标志字段，ACKbit用于指示确认字段中的值是有效的，即该报文段中包括一个已被成功接收的报文段的确认。RST, SYN, FINbit是用于连接建立和拆除，在明确拥塞通告中使用了CWR和ECEbit,当PSH被闲置的时候，就只是接受方应该将数据交给上层，最后URGbit用来只是报文段中的发送端的上层实体职位紧急的数据，紧急数据存在并在给出指向紧急数据尾指针的时候，tcp必须通知接收端的上层实体</p> 
<h5><a id="_108"></a>序号和确认号</h5> 
<p>tcp报文段首部中最重要的字段就是序号字段和确认号字段。<br> tcp把数据看场一个无结构的，有序的字节流，从tcp对序号的使用上，可以看出。序号是建立在传输的字节流之上，而不是建立在传输的报文段之上。一个报文段的序号是该报文段首字节的字节流编号。<br> <img src="https://images2.imgbox.com/22/18/FRU4RwXf_o.png" alt="在这里插入图片描述"></p> 
<p>tcp是全双公的，主机a在向主机b发送数据的同时，也可能会接受到来自主机b的数据，从主机b到达的报文段中都有一个序号用于b流向a的数据。<strong>主机a填充进报文段的确认好是主机a期望从主机b中受到的下一字节的序号</strong> TCP累计确认是指当TCP接收方收到连续的有序数据包时，它只发送一个确认段（ACK）来确认收到的数据包。这个确认段中包含了已收到的连续数据包中最后一个数据包的序列号，表示序列号之前的所有数据包都已成功接收。<br> <img src="https://images2.imgbox.com/aa/16/y6yfghBb_o.png" alt="在这里插入图片描述"></p> 
<p>ack: 表示确认号，在tcp中，接收方使用确认好来告知发送方已经成功接收到了数据字节的序列号，表示已经成功接收到的数据的下一个字节的序列号。<br> seq: 表示序列号，在tcp中，每个tcp报文段都有一个序列号，用于表示在文件传输过程中的顺序， 发送方使用序列号来对报文段进行编号，接收方可以利用序列号来重新排列报文段。seq字段表示该tcp报文段中第一个字节的数据序列表示，也是在一个tcp连接中，该报文段所携带的数据的开始位置。</p> 
<h4><a id="_118"></a>往返时间的估计与超时</h4> 
<p>tcp使用超时重传机制来处理报文段的丢失问题。</p> 
<h4><a id="_120"></a>可靠的数据传输</h4> 
<p>因特网中的网络服务ip服务是不可靠的，ip不能保证数据报的交付，不能保证数据包的按序交付，不能保证数据包中的数据的完整性，对于ip服务，数据报中的bit可能会损坏。<br> tcp的可靠数据传输服务确保了一个进程从其接受缓存中读出的数据流是无损坏，无间隙，非冗余和按序的数据流。<br> <img src="https://images2.imgbox.com/1f/ca/pfUfqAsa_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/c7/2e/6vI8pzNY_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_127"></a>超时间隔加倍</h5> 
<p>在定时器时限过期后超时间隔的长度，在这种修改中，每当超时事件发生的时候，tcp重传具有最小序号的时候还未被确认的报文段。每次tcp重传的时候都会将下一次的超时间间隔设置为先前值的两倍。</p> 
<h5><a id="_129"></a>快速重传</h5> 
<p>冗余ack就是再次确认某个报文段的ack。因为发送方经常一个接一个的发送大量的报文段，如果一个报文段丢失，就可能引起去多一个接一个的冗余ack，如果tcp发送方接收到对相同数据的三个冗余ack，一旦受到三个冗余ack，tcp就进行快速重传。<br> TCP（传输控制协议）的选择确认（Selective Acknowledgment，简称SACK）是一种机制，用于提高TCP在丢失数据包时的传输效率。在传统的TCP确认机制中，接收方会针对每个收到的数据包发送一个确认包，但SACK允许接收方在单个确认包中同时确认多个不连续的数据包，并告知发送方哪些数据包已经丢失<br> <img src="https://images2.imgbox.com/d1/c7/nNmyuDVb_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_134"></a>流量控制</h4> 
<p>消除发送方使接收方缓存溢出的可能性。流量控制是一个速度匹配服务，即发送方的发送速率和接收方的应用程序的读取熟读相匹配，tcp发送方可能因为ip网络的拥塞而被遏制，这个称为拥塞控制。<br> tcp通过让发送方维护一个称为接受窗口的变量来提供流量控制。接收窗口用于给发送发一个指示–该接收方还有多少可用的缓存空间，因为tcp是全双工同行。在连接两端的发送方各自维护一个接收窗口。<br> rwnd:用来提供流量控制服务，主机b把当前的rwnd值放入报文段接收窗口中。通知主机a他当前的缓存窗口中还有多少可用的空间。<br> 当主机B的接收窗口为0时，主机A继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认。最终缓存将开始清空，并且确认报文里将包含一个非0的rwnd值</p> 
<h4><a id="TCP_139"></a>TCP连接管理</h4> 
<p>客户端的tcp首先向服务器端的tcp发送一个特殊的tcp报文段，该报文段中不包含应用层数据，报文段的首部中的一个标志位被置为1。客户端会随机选择一个初始序号，将该编号放置于起始的tcp syn报文段的序号字段中，该报文段会被封装在一个ip数据包中，发送给服务器。<br> 一旦包含tcp syn报文段的ip数据报到达服务器主机，服务器会根据该数据包提取出tcp和syn报文段。为该tcp连接分配tcp缓存和变量，并且会向该客户tcp发送允许连接的报文段。这个允许连接的报文段不包含应用层数据，但是在报文段中包含3个重要的信息，syn被置为1。该允许连接的报文段成为isynack报文段。<br> 在受到synack报文段之后，客户端也要给该连接分配缓存和变量，客户主机则向服务器发送另外一个报文段，最后这个报文段对服务器的允许连接的报文段来进行确认。<br> 一旦完成了这三个不走，客户和服务器主机就都可以相互发送包括数据的报文段了，以后每一个报文段中，syn比特都被置为0<br> <img src="https://images2.imgbox.com/28/99/uGqpMvpV_o.png" alt="在这里插入图片描述"></p> 
<p>客户应用进程发出一个关闭连接命令。这会引起客户tcp向服务器进程发送一个特殊的tcp报文段，这个特殊的报文段让器首部的一个标志位FIN标志位被指为1，当服务器受到该报文之后，就像发送方返回一个确认报文段，然后服务器发送自己的终止报文段。其中的finbit被只为1，最后，客户对服务器的终止报文段进行确认。这个时候，两台主机上的所有资源就都被释放了。<br> tcp状态序列如下<br> <img src="https://images2.imgbox.com/87/9f/PQRqX04z_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_150"></a>拥塞控制原理</h3> 
<h4><a id="_151"></a>拥塞控制方法</h4> 
<h5><a id="_152"></a>端到端拥塞控制</h5> 
<p>在端到端拥塞控制方法中，网络层中没有为运输层控制提供显示支持，即使网络中存在拥塞，端系统也必须对网络行为的观察来推断。tcp采用端到端的方法解决拥塞控制，因为ip层不会向端系统中提供有关网络拥塞的反馈星系。tcp报文段的丢失(通过超时或冗余三次以上)被认为是网络拥塞的一个迹象。tcp会减少其窗口长度。</p> 
<h5><a id="_154"></a>网络辅助的拥塞控制</h5> 
<p>在网络辅助的拥塞控制中，路由器向发送方提供关于网络中拥塞状态的显示反馈信息。这种反馈可以简单的用一个比特来显示链路中的拥塞清况<br> <img src="https://images2.imgbox.com/64/19/1SttwbfY_o.png" alt="在这里插入图片描述"></p> 
<p>直接反馈信息可以有网络路由器发送给发送方，这种放肆的通知采用了一种阻塞分组的形式。路由器标记从发送方流向接收方的分组的某个字段来指示拥塞的产生，一旦收到一个标记的分组后，接受方就会像发送方通过该网络拥塞指示， 后一种形式的通知至少要经过一个完整的往返时间。</p> 
<h3><a id="TCP_159"></a>TCP拥塞控制</h3> 
<p>tcp必须采用端到端的拥塞控制而不是网络辅助的拥塞控制，因为ip层不会像端系统提供显式的网络拥塞反馈。<br> tcp采用的方法是让每个发送方根据所感知到的网络拥塞程度来限制其能想发送方流量的速率。如果一个tcp发送方感知到它到目的地之间的路劲没有什么拥塞，则tcp发送方增加其发送速率，如果发送方感知到该路径上有拥塞，则发送方就会降低发送速率。<br> tcp连接的每一段都是一个接受缓存，一个发送缓存和几个变量组成，运行在发送方的tcp拥塞控制机制跟踪一个额外的变量，即拥塞窗口，拥塞窗口表示为cwnd， 对一个tcp发送方能向网络中发送流量的速率进行了限制。<br> tcp发送方的"丢包事件": 要么出现超时，要么接收到来自接收方的三个冗余ack，当出现过度的拥塞的时候，在沿着这条路径上的一台或者多台路由器的缓存会溢出，引起一个数据包被丢弃。丢弃的数据报会引起发送方的丢包事件，要么超时或者收到3个ack，发送方就认为在发送方到接收方的路径上出现了拥塞的指示。<br> 没有出现丢包事件的时候，tcp的发送方会受到以前从未确认的报文段的确认，tcp将受到的确认作为一切正常的指示，即在网络上传输的报文端端杯成功的交付给目的地，并且使用确认来增加窗口的长度。如果确认相当慢的速度到达，拥塞窗口会以相当慢点速率增加，如果确认以高速率到达，则该拥塞窗口将会更为高效的增加。因此tcp使用确认来出发增大它的拥塞窗口的长度，tcp被说成是自计时的。<br> 一个丢失的报文段表意味着拥塞，因此当丢失报文段时应当降低 TCP 发送方的速率<br> 一个确认报文段指示该网络正在向接收方交付发送方的报文段<br> 带宽检测,给定的ack指示源到目的地路径无拥塞，而丢包事件指示路径拥塞，TCP 调节其传输速率的策略是增加其速率以响应到达的 ACK，除非出现丢包事件，此时才减小传输速率。</p> 
<h4><a id="_168"></a>慢启动</h4> 
<p>在一条tcp连接开始的时候，cwnd通常被设置为一个mss的较小值，使得初始发送速率大约只有mss/rtt，对于tcp发送方来说，可用带宽可能比mss/rtt大得多，tcp发送方希望找到可用的带宽的数量，在慢启动状态，cwnd以一个mss开始并且当传输的报文段首次被确认就加一个mss，tcp向网络发送一个报文段并等待一个确认，当确认到达的时候，tcp发送方将拥塞窗口增加一个mss，并发出两个最大长度的报文段。这两个报文段被确认，则发送方对每个确认的报文段的拥塞窗口增加一个mss，这样下去，经过一个rtt，发送速率就翻倍。<br> 如果存在由超市指示的丢包事件，tcp发送方将cwnd设置为1并重新开始慢启动的过程。将第二个状态设置为ssthresh(慢启动阈值)，设置为cwnd/2,当检测到拥塞时候将ssthresh置为拥塞窗口值的一半，慢启动结束的第二种方法就是直接和ssthresh的值相关联，当cwnd的值等于ssthresh时，结束慢启动并且TCP转移到拥塞避免模式，当cwnd的值等于ssthresh时，结束慢启动并且TCP转移到拥塞避免模式。最后一种结束慢启动的方式: 如果检测到3个冗余ack，这个时候tcp就会执行一个快速重传，进入快速修复状态。</p> 
<h4><a id="_171"></a>拥塞避免</h4> 
<p>一旦进入到拥塞避免状态，cwnd的值是上次拥塞的一半，tcp无法通过一个rtt在将cwnd的值翻倍，而是将cwnd的值增加一个mss<br> 当丢包的事件出现，ssthresh的值被设置为cwnd的一半<br> 丢包事件由一个三个冗余ack事件触发，在这种情况下，网络继续从发送方向交付报文段。tcp将cwnd的值减半，将三个冗余的ack加上3个mss，当受到3个冗余的ack，将ssthresh的值记录为cwnd的值的一半，进入快速修复状态</p> 
<h4><a id="_175"></a>快速修复</h4> 
<p>在快速修复中，对于引起tcp进入快速修复状态的缺失报文段，对于受到的每个冗余的ack，cwnd的值增加一个mss，当对丢失报文的一个ack到达的时候，tcp在降低cwnd后进入拥塞避免状态，如果出现超时事件，快速修复在执行如同在慢启动和拥塞避免种相同的动作后，迁移到慢启动状态，当丢包事件出现的时候，cwnd的值被设置为一个mss，ssthresh的值被设置为cwnd的一半。</p> 
<h3><a id="__177"></a>明确拥塞通告: 网络辅助拥塞控制</h3> 
<p>ECN标记：在IP数据报首部的服务类型字段中，使用两个比特位来表示ECN。这两个比特位由路由器在检测到拥塞时设置。<br> ECE和CWR标志：当接收方TCP收到带有ECN标记的数据包时，它会在后续的TCP ACK报文段中设置ECE比特，通知发送方TCP收到拥塞指示。发送方TCP在收到带有ECE的ACK后，会减半其拥塞窗口，并在下一个TCP报文段中设置CWR比特，以确认已经收到并处理了拥塞通知。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dcfbb5d92ffe66bffcb71a3091fa3490/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VsCode个人插件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/185b4e94114395cf34a7a49a73e034ce/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Day08：CSS 高级</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>