<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】排序详解（希尔排序，快速排序，堆排序，插入排序，选择排序，冒泡排序） - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/aa66ca1275e089ccda3363632876fc16/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【数据结构】排序详解（希尔排序，快速排序，堆排序，插入排序，选择排序，冒泡排序）">
  <meta property="og:description" content="目录
0. 前情提醒：
1. 插入排序
1.1 基本思想：
1.2 直接插入排序
实现步骤：
动图演示：
特性总结：
代码实现：
1.3 希尔排序（缩小增量排序）
基本思想：
步骤演示：
特性总结：
代码实现：
2. 交换排序
2.1 基本思想：
2.2 冒泡排序
特性总结：
代码实现：
2.3 快速排序
3.选择排序
3.1 基本思想：
3.2 直接选择排序
步骤思路：
动图演示： 特性总结：
代码实现：
3.3 堆排序
代码实现：
0. 前情提醒： 下面的所有代码实现均为升序
1. 插入排序 1.1 基本思想： 把待排序的记录按其关键码值的大小逐个插入到一个已经排序好的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列。
1.2 直接插入排序 实现步骤： 当插入第i（i&gt;=1）各元素时，前面的array[0]，array[1]，......，array[i-1]已经排好序，此时用array[i]的排序码与array[i-1]，array[i-2]，......的排序码顺序进行比较，找到插入位置即将array[i]插入，原来位置上的元素顺序后移
动图演示： 特性总结： 元素集合越接近有序，直接插入排序算法的时间效率越高时间复杂度：O(N^2)空间复杂度：O(1)，它是一种稳定的排序算法4.稳定性：稳定 代码实现： void InsertSort(int* a, int n) { for (int i = 0; i &lt; n; i&#43;&#43;) { int m = a[i]; int end = i; while (end &gt; 0 &amp;&amp; a[end - 1] &gt; m) { a[end] = a[end - 1]; end--; } a[end] = m; } } 1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-22T12:02:35+08:00">
    <meta property="article:modified_time" content="2024-05-22T12:02:35+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】排序详解（希尔排序，快速排序，堆排序，插入排序，选择排序，冒泡排序）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:80px;"></p> 
<p id="0.%20%E5%89%8D%E6%83%85%E6%8F%90%E9%86%92%EF%BC%9A-toc" style="margin-left:80px;"><a href="#0.%20%E5%89%8D%E6%83%85%E6%8F%90%E9%86%92%EF%BC%9A" rel="nofollow">0. 前情提醒：</a></p> 
<p id="1.%20%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#1.%20%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" rel="nofollow">1. 插入排序</a></p> 
<p id="1.1%20%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A-toc" style="margin-left:120px;"><a href="#1.1%20%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A" rel="nofollow">1.1 基本思想：</a></p> 
<p id="1.2%C2%A0%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-toc" style="margin-left:120px;"><a href="#1.2%C2%A0%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" rel="nofollow">1.2 直接插入排序</a></p> 
<p id="%C2%A0%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%C2%A0%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%EF%BC%9A" rel="nofollow"> 实现步骤：</a></p> 
<p id="%C2%A0%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%C2%A0%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%9A" rel="nofollow"> 动图演示：</a></p> 
<p id="%C2%A0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%C2%A0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%EF%BC%9A" rel="nofollow"> 特性总结：</a></p> 
<p id="%C2%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%C2%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A" rel="nofollow"> 代码实现：</a></p> 
<p id="1.3%20%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E7%BC%A9%E5%B0%8F%E5%A2%9E%E9%87%8F%E6%8E%92%E5%BA%8F%EF%BC%89-toc" style="margin-left:120px;"><a href="#1.3%20%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E7%BC%A9%E5%B0%8F%E5%A2%9E%E9%87%8F%E6%8E%92%E5%BA%8F%EF%BC%89" rel="nofollow">1.3 希尔排序（缩小增量排序）</a></p> 
<p id="%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A" rel="nofollow">基本思想：</a></p> 
<p id="%E6%AD%A5%E9%AA%A4%E6%BC%94%E7%A4%BA%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%E6%AD%A5%E9%AA%A4%E6%BC%94%E7%A4%BA%EF%BC%9A" rel="nofollow">步骤演示：</a></p> 
<p id="%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%EF%BC%9A" rel="nofollow">特性总结：</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A" rel="nofollow">代码实现：</a></p> 
<p id="2.%20%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#2.%20%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F" rel="nofollow">2. 交换排序</a></p> 
<p id="2.1%20%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A-toc" style="margin-left:120px;"><a href="#2.1%20%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A" rel="nofollow">2.1 基本思想：</a></p> 
<p id="2.2%C2%A0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-toc" style="margin-left:120px;"><a href="#2.2%C2%A0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" rel="nofollow">2.2 冒泡排序</a></p> 
<p id="%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%EF%BC%9A" rel="nofollow">特性总结：</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A" rel="nofollow">代码实现：</a></p> 
<p id="2.3%20%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-toc" style="margin-left:120px;"><a href="#2.3%20%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" rel="nofollow">2.3 快速排序</a></p> 
<p id="3.%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#3.%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" rel="nofollow">3.选择排序</a></p> 
<p id="3.1%20%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A-toc" style="margin-left:120px;"><a href="#3.1%20%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A" rel="nofollow">3.1 基本思想：</a></p> 
<p id="3.2%20%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-toc" style="margin-left:120px;"><a href="#3.2%20%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" rel="nofollow">3.2 直接选择排序</a></p> 
<p id="%E6%AD%A5%E9%AA%A4%E6%80%9D%E8%B7%AF%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%E6%AD%A5%E9%AA%A4%E6%80%9D%E8%B7%AF%EF%BC%9A" rel="nofollow">步骤思路：</a></p> 
<p id="%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%9A%C2%A0-toc" style="margin-left:160px;"><a href="#%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%9A%C2%A0" rel="nofollow">动图演示： </a></p> 
<p id="%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%EF%BC%9A" rel="nofollow">特性总结：</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A" rel="nofollow">代码实现：</a></p> 
<p id="3.3%20%E5%A0%86%E6%8E%92%E5%BA%8F-toc" style="margin-left:120px;"><a href="#3.3%20%E5%A0%86%E6%8E%92%E5%BA%8F" rel="nofollow">3.3 堆排序</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A" rel="nofollow">代码实现：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h4 id="0.%20%E5%89%8D%E6%83%85%E6%8F%90%E9%86%92%EF%BC%9A">0. 前情提醒：</h4> 
<p><span style="color:#38d8f0;">下面的所有代码实现均为升序</span></p> 
<h4 id="1.%20%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">1. 插入排序</h4> 
<h5 id="1.1%20%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A">1.1 基本思想：</h5> 
<blockquote> 
 <p>把待排序的记录按其关键码值的大小逐个<span style="color:#38d8f0;">插入到一个已经排序好的有序序列中</span>，直到所有的记录插入完为止，得到一个新的有序序列。</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2b/6e/ZWBl5R4T_o.png"></p> 
<h5 id="1.2%C2%A0%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span style="color:#0d0016;">1.2 </span><span style="color:#fe2c24;">直接插入排序</span></h5> 
<h6 id="%C2%A0%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%EF%BC%9A"> 实现步骤：</h6> 
<blockquote> 
 <p>当插入第i（i&gt;=1）各元素时，前面的array[0]，array[1]，......，array[i-1]已经排好序，此时用array[i]的排序码与array[i-1]，array[i-2]，......的排序码顺序进行比较，找到插入位置即将array[i]插入，原来位置上的元素顺序后移</p> 
</blockquote> 
<h6 id="%C2%A0%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%9A"> 动图演示：</h6> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/98/a5/qT0upxLV_o.gif"></p> 
<h6 id="%C2%A0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%EF%BC%9A"> 特性总结：</h6> 
<ol><li><span style="background-color:#e7fafa;">元素集合越接近有序，直接插入排序算法的时间效率越高</span></li><li><span style="background-color:#e7fafa;">时间复杂度：O(N^2)</span></li><li><span style="background-color:#e7fafa;">空间复杂度：O(1)，它是一种稳定的排序算法</span></li><li><span style="background-color:#e7fafa;">4.稳定性：稳定</span></li></ol> 
<h6 id="%C2%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A"> 代码实现：</h6> 
<pre><code>void InsertSort(int* a, int n) {
	for (int i = 0; i &lt; n; i++) {
		int m = a[i];
		int end = i;
		while (end &gt; 0 &amp;&amp; a[end - 1] &gt; m) {
			a[end] = a[end - 1];
			end--;
		}
		a[end] = m;
	}
}</code></pre> 
<h5 id="1.3%20%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E7%BC%A9%E5%B0%8F%E5%A2%9E%E9%87%8F%E6%8E%92%E5%BA%8F%EF%BC%89">1.3 <span style="color:#fe2c24;">希尔排序（缩小增量排序）</span></h5> 
<h6 id="%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A">基本思想：</h6> 
<blockquote> 
 <p>先选定一个整数，把待排序的文件中所有（n个）记录分成（n/gap）个组，所有距离为gap的记录分在同一个组，并对每个组内的记录进行排序。然后去gap=gap/2，重复上述分组和排序的工作。当到达gap=1时，所有记录在统一组内排好序（<span style="color:#38d8f0;">gap=1时就是直接插入排序，gap&gt;1时属于预排序</span>）。</p> 
</blockquote> 
<h6 id="%E6%AD%A5%E9%AA%A4%E6%BC%94%E7%A4%BA%EF%BC%9A">步骤演示：</h6> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/66/4c/1yMCLNJ6_o.png"></p> 
<h6 id="%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%EF%BC%9A">特性总结：</h6> 
<ol><li><span style="background-color:#e7fafa;">希尔排序是<span style="color:#38d8f0;">对直接插入排序的优化</span></span></li><li><span style="background-color:#e7fafa;">当gap&gt;1时都是预排序，目的是让数组更接近有序。当gap==1时，数组已经接近有序，这样排序就会很快。这样整体而言，可以达到优化的效果</span></li><li><span style="background-color:#e7fafa;">希尔排序的<span style="color:#38d8f0;">时间复杂度不好计算，因为gap的取值方法很多</span>，导致很难去计算，因此在不同书上给出的希尔排序的时间复杂度都不一样</span></li></ol> 
<h6 id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A">代码实现：</h6> 
<pre><code>void ShellSort(int* a, int n) {
	int gap = n;
	while (gap &gt; 1) {
		gap = gap / 3 + 1;
		for (int i = 0; i &lt; n; i++) {
			int m = a[i];
			int end = i;
			while (end &gt; 0 &amp;&amp; a[end - gap] &gt; m) {
				a[end] = a[end - gap];
				end -= gap;
			}
			a[end] = m;
		}
	}
}</code></pre> 
<h4 id="2.%20%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F">2. 交换排序</h4> 
<h5 id="2.1%20%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A">2.1 基本思想：</h5> 
<blockquote> 
 <p>所谓交换，就是根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，交换排序的特点是：<span style="color:#38d8f0;">将键值较大的记录向序列的尾部移动，键值较小的记录向前部移动</span></p> 
</blockquote> 
<h5 id="2.2%C2%A0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">2.2 <span style="color:#fe2c24;">冒泡排序</span></h5> 
<blockquote> 
 <p><span style="color:#38d8f0;">左边大于右边交换</span>，一趟排下来最大的在右边</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9c/b1/3l9yCtsN_o.gif"></p> 
<h6>特性总结：</h6> 
<ol><li><span style="background-color:#e7fafa;">冒泡排序是一种非常容易理解的排序</span></li><li><span style="background-color:#e7fafa;">时间复杂度：O(N^2)</span></li><li><span style="background-color:#e7fafa;">空间复杂度：O(1)</span></li><li><span style="background-color:#e7fafa;">稳定性：稳定</span></li></ol> 
<h6>代码实现：</h6> 
<pre><code>void BubbleSort(int* a, int n) {
	for (int i = 0; i &lt; n; i++) {
		int k = 1;
		for (int j = 0; j &lt; n-i-1; j++) {
			if (a[j] &gt; a[j + 1]) {
				k = 0;
				int x = a[j];
				a[j] = a[j + 1];
				a[j + 1] = x;
			}
		}
		if (k) {
			break;
		}
	}
}</code></pre> 
<h5 id="2.3%20%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">2.3 快速排序</h5> 
<p>快速排序较为复杂，想了解请点击-----》<a class="link-info" href="https://blog.csdn.net/lzh20040919/article/details/139094373" title="快速排序">快速排序</a></p> 
<h4 id="3.%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">3.选择排序</h4> 
<h5 id="3.1%20%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A">3.1 基本思想：</h5> 
<blockquote> 
 <p>每一次从待排序的数据元素中选出一个最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完</p> 
</blockquote> 
<h5 id="3.2%20%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">3.2 <span style="color:#fe2c24;">直接选择排序</span></h5> 
<h6 id="%E6%AD%A5%E9%AA%A4%E6%80%9D%E8%B7%AF%EF%BC%9A">步骤思路：</h6> 
<blockquote> 
 <ul><li>在元素array[i]--array[n-1]中选择关键码最小（或最大）的数据元素</li><li>若它不是这组元素中最后一个（第一个）元素，则将它与这组元素中的最后一个（第一个）元素交换</li><li>在剩余的array[i]--array[n-2]（array[i+1]--array[n-1]）集合中，重复上述步骤，直到集合剩余1个元素</li></ul> 
</blockquote> 
<h6 id="%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%9A%C2%A0">动图演示： </h6> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/7c/01/Fn5tMfR5_o.gif"></p> 
<h6>特性总结：</h6> 
<ol><li><span style="background-color:#e7fafa;">思路很好理解，但效率不好，实际很少应用，主要具有教学意义</span></li><li><span style="background-color:#e7fafa;">时间复杂度：O(N^2)</span></li><li><span style="background-color:#e7fafa;">空间复杂度：O(1)</span></li><li><span style="background-color:#e7fafa;">稳定性：不稳定</span></li></ol> 
<h6>代码实现：</h6> 
<pre><code>void SelectSort(int* a, int n) {
	for (int i = 0; i &lt; n; i++) {
		int min = n - 1;
		for (int j = i; j &lt; n; j++) {
			if (a[min] &gt; a[j]) {
				min = j;
			}
		}
		swap(&amp;a[min], &amp;a[i]);
	}
}</code></pre> 
<h5 id="3.3%20%E5%A0%86%E6%8E%92%E5%BA%8F">3.3 <span style="color:#fe2c24;">堆排序</span></h5> 
<blockquote> 
 <p>堆排序（HeapSort）是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。它是通过堆来进行选择数据，<span style="color:#38d8f0;">利用堆中某个节点的值总是不大于或不小于其父节点的值的特性</span>。注意：<span style="color:#fe2c24;">升序建大堆，降序建小堆</span></p> 
</blockquote> 
<h6>代码实现：</h6> 
<pre><code>void AdjustDwon(int* a, int n, int root) {
	int i = 2 * root + 1;
	if (i &lt; n - 1 &amp;&amp; a[i] &lt; a[i + 1]) {
		i++;
	}
	if (i &lt; n &amp;&amp; a[root] &lt; a[i]) {
		swap(&amp;a[root], &amp;a[i]);
		AdjustDwon(a, n, i);
	}
}
void HeapSort(int* a, int n) {
//建堆
	for (int i = (n - 1 - 1) / 2; i &gt;= 0; i--) {
		AdjustDwon(a, n, i);
	}
	while (n&gt;1) {
		swap(&amp;a[0], &amp;a[n-1]);
		n--;
		AdjustDwon(a, n, 0);
	}
}</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/df34a47041ce6c93d6125b4c3d3c910e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Lua常用C Api接口</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7f912dada0bdfe4705ad7bee27582485/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android 项目中自定义多个 RadioButton 并排一列选择效果实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>