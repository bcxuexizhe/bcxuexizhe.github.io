<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【每日刷题】Day50 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/55eaf96310eadd940257bd896dccc609/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【每日刷题】Day50">
  <meta property="og:description" content="【每日刷题】Day50
🥕个人主页：开敲🍉
🔥所属专栏：每日刷题🍍
🌼文章目录🌼
1. 654. 最大二叉树 - 力扣（LeetCode）
2. 119. 杨辉三角 II - 力扣（LeetCode）
3. 735. 小行星碰撞 - 力扣（LeetCode）
1. 654. 最大二叉树 - 力扣（LeetCode） //思路：递归遍历，通过不断改变左右区间找到最大值，从而保证在最大值左边构建子树以及最大值右边构建子树。
typedef struct TreeNode TN;
TN* CreatBinaryTree(int* nums,int left,int right)
{
if(left&gt;right)//当区间不存在时，说明已经没有值能找了，直接返回NULL
return NULL;
int max = left;
for(int i = left;i&lt;=right;i&#43;&#43;)
{
if(nums[i]&gt;nums[max])//定位当前最大值的下标，作为下一次寻找左右最大结点的区间
{
max = i;
}
}
TN* node = (TN*)malloc(sizeof(TN));
node-&gt;val = nums[max];
node-&gt;left = CreatBinaryTree(nums,left,max-1);
node-&gt;right = CreatBinaryTree(nums,max&#43;1,right);
return node;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-28T21:27:48+08:00">
    <meta property="article:modified_time" content="2024-05-28T21:27:48+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【每日刷题】Day50</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>【每日刷题】Day50</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/29/bd/oYIA1uq3_o.gif"></p> 
<blockquote> 
 <p><span style="color:#38d8f0;">🥕个人主页：<a class="link-info" href="https://blog.csdn.net/2301_78022459?spm=1010.2135.3001.5343" title="开敲🍉">开敲🍉</a></span></p> 
 <p><span style="color:#38d8f0;">🔥所属专栏：<a class="link-info" href="https://blog.csdn.net/2301_78022459/category_12630000.html" title="每日刷题🍍">每日刷题🍍</a></span></p> 
</blockquote> 
<p></p> 
<p id="main-toc"><strong>🌼文章目录🌼</strong></p> 
<p id="1.%C2%A0654.%20%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89-toc" style="margin-left:120px;"><a href="#1.%C2%A0654.%20%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89" rel="nofollow">1. 654. 最大二叉树 - 力扣（LeetCode）</a></p> 
<p id="2.%C2%A0119.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%20II%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89-toc" style="margin-left:120px;"><a href="#2.%C2%A0119.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%20II%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89" rel="nofollow">2. 119. 杨辉三角 II - 力扣（LeetCode）</a></p> 
<p id="3.%C2%A0735.%20%E5%B0%8F%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89-toc" style="margin-left:120px;"><a href="#3.%C2%A0735.%20%E5%B0%8F%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89" rel="nofollow">3. 735. 小行星碰撞 - 力扣（LeetCode）</a></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a6/64/UUvCPLjJ_o.gif"></p> 
<h5 id="1.%C2%A0654.%20%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89">1. <a href="https://leetcode.cn/problems/maximum-binary-tree/description/" rel="nofollow" title="654. 最大二叉树 - 力扣（LeetCode）">654. 最大二叉树 - 力扣（LeetCode）</a></h5> 
<blockquote> 
 <p><strong><span style="color:#98c091;">//思路：递归遍历，通过不断改变左右区间找到最大值，从而保证在最大值左边构建子树以及最大值右边构建子树。</span></strong></p> 
 <p><strong>typedef struct TreeNode TN;</strong></p> 
 <p></p> 
 <p><strong>TN* CreatBinaryTree(int* nums,int left,int right)</strong></p> 
 <p><strong>{<!-- --></strong></p> 
 <p><strong>    if(left&gt;right)<span style="color:#98c091;">//当区间不存在时，说明已经没有值能找了，直接返回NULL</span></strong></p> 
 <p><strong>        return NULL;</strong></p> 
 <p><strong>    int max = left;</strong></p> 
 <p><strong>    for(int i = left;i&lt;=right;i++)</strong></p> 
 <p><strong>    {<!-- --></strong></p> 
 <p><strong>        if(nums[i]&gt;nums[max])<span style="color:#98c091;">//定位当前最大值的下标，作为下一次寻找左右最大结点的区间</span></strong></p> 
 <p><strong>        {<!-- --></strong></p> 
 <p><strong>            max = i;</strong></p> 
 <p><strong>        }</strong></p> 
 <p><strong>    }</strong></p> 
 <p><strong>    TN* node = (TN*)malloc(sizeof(TN));</strong></p> 
 <p><strong>    node-&gt;val = nums[max];</strong></p> 
 <p><strong>    node-&gt;left = CreatBinaryTree(nums,left,max-1);</strong></p> 
 <p><strong>    node-&gt;right = CreatBinaryTree(nums,max+1,right);</strong></p> 
 <p><strong>    return node;</strong></p> 
 <p><strong>}</strong></p> 
 <p><br><br>  </p> 
 <p><strong>struct TreeNode* constructMaximumBinaryTree(int* nums, int numsSize)</strong></p> 
 <p><strong>{<!-- --></strong></p> 
 <p><strong>    return CreatBinaryTree(nums,0,numsSize-1);</strong></p> 
 <p><strong>}</strong></p> 
</blockquote> 
<h5 id="2.%C2%A0119.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%20II%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89">2. <a href="https://leetcode.cn/problems/pascals-triangle-ii/description/" rel="nofollow" title="119. 杨辉三角 II - 力扣（LeetCode）">119. 杨辉三角 II - 力扣（LeetCode）</a></h5> 
<blockquote> 
 <p><strong><span style="color:#98c091;">//思路：构建杨辉三角。</span></strong></p> 
 <p><strong>int* getRow(int rowIndex, int* returnSize)</strong></p> 
 <p><strong>{<!-- --></strong></p> 
 <p><strong>    int** arr = (int**)malloc(sizeof(int*)*34);</strong></p> 
 <p><strong>    for(int i = 0;i&lt;34;i++)</strong></p> 
 <p><strong>    {<!-- --></strong></p> 
 <p><strong>        arr[i] = (int*)malloc(sizeof(int)*35);</strong></p> 
 <p><strong>    }</strong></p> 
 <p><strong>    for(int i = 0;i&lt;34;i++)</strong></p> 
 <p><strong>    {<!-- --></strong></p> 
 <p><strong>        arr[i][0] = 1;</strong></p> 
 <p><strong>        arr[i][i] = 1;</strong></p> 
 <p><strong>    }</strong></p> 
 <p><strong>    for(int i = 2;i&lt;34;i++)</strong></p> 
 <p><strong>    {<!-- --></strong></p> 
 <p><strong>        for(int j = 1;j&lt;i;j++)</strong></p> 
 <p><strong>        {<!-- --></strong></p> 
 <p><strong>            arr[i][j] = arr[i-1][j-1]+arr[i-1][j];</strong></p> 
 <p><strong>        }</strong></p> 
 <p><strong>    }</strong></p> 
 <p><strong>    int* ans = (int*)malloc(sizeof(int)*34);</strong></p> 
 <p><strong>    int count = 0;</strong></p> 
 <p><strong>    for(int i = 0;i&lt;rowIndex+1;i++)</strong></p> 
 <p><strong>    {<!-- --></strong></p> 
 <p><strong>        ans[count++] = arr[rowIndex][i];</strong></p> 
 <p><strong>    }</strong></p> 
 <p><strong>    *returnSize = count;</strong></p> 
 <p><strong>    return ans;</strong></p> 
 <p><strong>}</strong></p> 
</blockquote> 
<h5 id="3.%C2%A0735.%20%E5%B0%8F%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89">3. <a href="https://leetcode.cn/problems/asteroid-collision/description/" rel="nofollow" title="735. 小行星碰撞 - 力扣（LeetCode）">735. 小行星碰撞 - 力扣（LeetCode）</a></h5> 
<blockquote> 
 <p><strong><span style="color:#98c091;">//思路：栈。遍历数组，入栈情况: ① 如果栈中没有元素则入栈  ② 如果数组当前元素＞0，则不可能发生碰撞，入栈  ③ 如果栈顶元素＜0并且数组当前元素也＜0，入栈</span></strong></p> 
 <p><strong><span style="color:#98c091;">出栈情况: 如果栈顶元素＞0并且数组当前元素＜0，则要判断是否出栈。① 如果数组当前元素的绝对值＞栈顶元素，则将栈顶元素替换为当前数组元素，并继续跟栈顶下一个元素比较</span></strong></p> 
 <p><strong><span style="color:#98c091;">② 如果数组当前元素的绝对值＝栈顶元素，则直接将栈顶元素出栈，不进行入栈操作</span></strong></p> 
 <p><strong><span style="color:#98c091;">③ 如果数组当前元素的绝对值＜栈顶元素，则不进行操作。</span></strong></p> 
 <p><span style="color:#fe2c24;"><strong>注意:这里需要考虑到当 是第①种出栈情况时，需要考虑到栈顶下面元素也为负数，或者栈的下标为0的情况。</strong></span></p> 
 <p><strong>int* asteroidCollision(int* asteroids, int asteroidsSize, int* returnSize)</strong></p> 
 <p><strong>{<!-- --></strong></p> 
 <p><strong>    int* ans = (int*)malloc(sizeof(int)*10000);</strong></p> 
 <p><strong>    int count = 0;</strong></p> 
 <p><strong>    for(int i = 0;i&lt;asteroidsSize;i++)</strong></p> 
 <p><strong>    {<!-- --></strong></p> 
 <p><strong>        if(count==0||asteroids[i]&gt;0||(asteroids[i]&lt;0&amp;&amp;ans[count-1]&lt;0))<span style="color:#98c091;">//入栈情况</span></strong></p> 
 <p><strong>        {<!-- --></strong></p> 
 <p><strong>            ans[count++] = asteroids[i];</strong></p> 
 <p><strong>        }</strong></p> 
 <p><strong>        else</strong></p> 
 <p><strong>        {<!-- --></strong></p> 
 <p><strong>            while(count&amp;&amp;(asteroids[i]*(-1))&gt;ans[count-1]&amp;&amp;ans[count-1]&gt;0)<span style="color:#98c091;">//当前数组元素的绝对值大于栈顶元素，并且栈顶元素必须＞0才能发生碰撞</span></strong></p> 
 <p><strong>            {<!-- --></strong></p> 
 <p><strong>                ans[--count] = asteroids[i];</strong></p> 
 <p><strong>            }</strong></p> 
 <p><strong>            if(count==0||(asteroids[i]&lt;0&amp;&amp;ans[count-1]&lt;0))<span style="color:#98c091;">//考虑到 10 5 -15 这种一路碰撞到栈下标为0或者栈顶下面元素都为负数的情况，需要将返回大小+1</span></strong></p> 
 <p><strong>            {<!-- --></strong></p> 
 <p><strong>                count++;</strong></p> 
 <p><strong>            }</strong></p> 
 <p><strong>            if(count&amp;&amp;(asteroids[i]*(-1))==ans[count-1])<span style="color:#98c091;">//如果当前数组元素绝对值与栈顶元素相同，则同归于尽</span></strong></p> 
 <p><strong>            {<!-- --></strong></p> 
 <p><strong>                count--;</strong></p> 
 <p><strong>            }</strong></p> 
 <p><strong>        }</strong></p> 
 <p><strong>    }</strong></p> 
 <p><strong>    *returnSize = count;</strong></p> 
 <p><strong>    return ans;</strong></p> 
 <p><strong>}</strong></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/681aba2dbee8d3633d79b1f003fcfd90/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">springboot项目使用validated参数校验框架</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2b3f528a28605cc85feb1773f5a4dbe1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Java】类和对象</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>