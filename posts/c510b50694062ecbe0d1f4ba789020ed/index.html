<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>大数据开发语言Scala（一）——scala入门 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/c510b50694062ecbe0d1f4ba789020ed/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="大数据开发语言Scala（一）——scala入门">
  <meta property="og:description" content="累了，基础配置不想写了，直接抄了→Scala的环境搭建
这里需要注意的是，创建新项目时，不要用默认的Class类，用Object，原因看→scala中的object为什么可以直接运行
一、Scala简介 1.1 图解Scala和Java的关系 1.2 关键字说明 package： 包，等同于java中的package
object：关键字，声明一个单例对象（伴生对象）
main方法：从外部可以直接调用执行的方法
def 方法名称 ( 参数名称 : 参数类型 ) : 返回值类型 = { 方法体 }
Scala 完全面向对象，故scala去掉了Java中非面向对象的元素，如static关键字，void类型 1) static scala无static关键字,由object实现类似静态方法的功能(类名.方法名) class关键字和Java中的class关键字作用相同,用来定义一个类 2) void 对于无返回值的函数,scala定义其返回值类型为Unit类型 1.3 代码案例 package com.scala.chapter1 object Hello { def main(args: Array[String]): Unit = { println(&#34;hello scala&#34;) System.out.println(&#34;hello scala&#34;) } } 1.4 Scala语言特点 Scala是一门以Java虚拟机 (JVM）为运行环境并将面向对象和函数式编程的最佳特性结合在一起的静态类型编程语言（静态语言需要提前编译的如: Java、C、C&#43;&#43;等，动态语言如：JS）。
1）Scala是一门多范式的编程语言，Scala支持面向对象和函数式编程。 (多范式，就是多种编程方法的意思。有面向过程、面向对象、泛型、函数式四种程序设计方法。)
2）Scala源代码 (.scala) 会被编译成Java字节码 (.class)，然后运行于JVM之上，并可以调用现有的Java类库，实现两种语言的无缝对接。
3）Scala单作为一门语言来看，非常的简洁高效
4）Scala在设计时，马丁·奥德斯基是参考了Java的设计思想，可以说Scala是源于Java，同时马丁·奥德斯基也加入了自己的思想，将函数式编程语言的特点融合到JAVA中，因此，对于学习过Java的同学,只要在学习Scala的过程中，搞清楚Scala和Java相同点和不同点，就可以快速的掌握Scala这门语言。
二、变量和数据类型 Any： 所有类型的超类（顶级类型） AnyVal： 值类型的超类 AnyRef： 引用类型的超类，对应java.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-03-23T20:34:11+08:00">
    <meta property="article:modified_time" content="2023-03-23T20:34:11+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">大数据开发语言Scala（一）——scala入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <p style="">累了，基础配置不想写了，直接抄了→<a class="kdocs-link" style="color:#0A6CFF;" href="https://blog.csdn.net/Zp_insist/article/details/125160393?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167892818916800186524158%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167892818916800186524158&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-125160393-null-null.142%5Ev73%5Einsert_down3,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;utm_term=scala&amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener noreferrer">Scala的环境搭建</a></p> 
 <p style="">这里需要注意的是，创建新项目时，不要用默认的Class类，用Object，原因看→<a class="kdocs-link" style="color:#0A6CFF;" href="https://blog.csdn.net/liyang7916/article/details/111477294?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167893931616800186520669%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=167893931616800186520669&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-111477294-null-null.142%5Ev73%5Einsert_down3,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;utm_term=scala%20%E4%B8%BA%E4%BB%80%E4%B9%88object&amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener noreferrer">scala中的object为什么可以直接运行</a></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:692px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:47.254337%;height:0;"> 
    <img src="https://images2.imgbox.com/e3/3a/vPRdDJ27_o.png" style="margin-left:;display:block;width:692px;margin-top:-47.254337%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <h2 style="">一、Scala简介</h2> 
 <h3 style="">1.1 图解Scala和Java的关系</h3> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:56.216217%;height:0;"> 
    <img src="https://images2.imgbox.com/d7/98/lsa2GcRd_o.png" style="margin-left:;display:block;width:740px;margin-top:-56.216217%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <h3 style="">1.2 关键字说明</h3> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">package</span>： 包，等同于java中的package</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">object</span>：关键字，声明一个单例对象（伴生对象）</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">main方法</span>：从外部可以直接调用执行的方法</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">def 方法名称</span> ( 参数名称 : 参数类型 ) : 返回值类型 = { 方法体 }</p> 
 <blockquote class="kdocs-blockquote" style="">
   Scala 完全面向对象，故scala去掉了Java中非面向对象的元素，如static关键字，void类型 
  <br> 1) static 
  <br> scala无static关键字,由object实现类似静态方法的功能(类名.方法名) 
  <br> class关键字和Java中的class关键字作用相同,用来定义一个类 
  <br> 2) void 
  <br> 对于无返回值的函数,scala定义其返回值类型为Unit类型 
 </blockquote> 
 <p style=""></p> 
 <h3 style="">1.3 代码案例</h3> 
 <pre class="kdocs-java"><code class="language-java">package com.scala.chapter1

object Hello {
  def main(args: Array[String]): Unit = {
    println("hello scala")
    System.out.println("hello scala")
  }
}</code></pre> 
 <p style=""></p> 
 <h3 style="">1.4 Scala语言特点</h3> 
 <p style="text-indent:1.4em;">Scala是一门以Java虚拟机 (JVM）为运行环境并将<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">面向对象</span></span>和<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">函数式编程</span></span>的最佳特性结合在一起的<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">静态类型编程语言</span></span>（静态语言需要提前编译的如: Java、C、C++等，动态语言如：JS）。</p> 
 <p style="text-indent:1.4em;">1）Scala是一门<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">多范式</span></span>的编程语言，Scala支持<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">面向对象和函数式编程</span></span>。 (多范式，就是多种编程方法的意思。有面向过程、面向对象、泛型、函数式四种程序设计方法。)</p> 
 <p style="text-indent:1.4em;">2）Scala源代码 (.scala) 会被编译成Java字节码 (.class)，然后运行于JVM之上，并可以<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">调用现有的Java类库</span></span>，<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">实现两种语言的无缝对接</span></span>。</p> 
 <p style="text-indent:1.4em;">3）Scala单作为一门语言来看，<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">非常的简洁高效</span></span></p> 
 <p style="text-indent:1.4em;">4）Scala在设计时，马丁·奥德斯基是参考了Java的设计思想，可以说Scala是源于Java，同时马丁·奥德斯基也加入了自己的思想，将<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">函数式编程语言的特点融合到JAVA中</span></span>，因此，对于学习过Java的同学,只要在学习Scala的过程中，搞清楚Scala和Java相同点和不同点，就可以快速的掌握Scala这门语言。</p> 
 <p style="text-indent:1.4em;"></p> 
 <h2 style="">二、变量和数据类型</h2> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:876px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:68.949776%;height:0;"> 
    <img src="https://images2.imgbox.com/ae/07/rEfOa6L7_o.png" style="margin-left:;display:block;width:876px;margin-top:-68.949776%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <blockquote class="kdocs-blockquote" style=""> 
  <span class="kdocs-bold" style="font-weight:bold;">Any</span>： 所有类型的超类（顶级类型） 
  <br> 
  <span class="kdocs-bold" style="font-weight:bold;">AnyVal</span>： 值类型的超类 
  <br> 
  <span class="kdocs-bold" style="font-weight:bold;">AnyRef</span>： 引用类型的超类，对应java.lang.Object 
  <br> 
  <span class="kdocs-bold" style="font-weight:bold;">Unit</span>： 无值，类似java中的void 
  <br> 
  <span class="kdocs-bold" style="font-weight:bold;">Nothing</span>： 所有类型的子类 
  <br> 
  <span class="kdocs-bold" style="font-weight:bold;">Null</span>： 表示null或空引用 
 </blockquote> 
 <p style=""></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">2.1 注释</span></h3> 
 <p style="text-align:null;">Scala注释使用和Java完全一样。</p> 
 <p style="text-align:null;">注释是一个程序员必须要具有的良好编程习惯。将自己的思想通过注释先整理出来，再用代码去体现。</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">（1）单行注释：//

（2）多行注释：/* */

（3）文档注释：/**
            *
            */</code></pre> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">object Test1 {
def main(args: Array[String]): Unit = {
//单行注释
println("单行")

//多行
/*
println("多行")
*/

//文档注释
/**
   * println("文档注释")
   */
}
}
</code></pre> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">3） 代码规范</span></p> 
 <p style="">（1）使用一次tab操作，实现缩进，默认整体向右边移动，用shift+tab整体向左移</p> 
 <p style="">（2）或者使用ctrl + alt + L来进行格式化</p> 
 <p style="">（3）运算符两边习惯性各加一个空格。比如：2 + 4 * 5</p> 
 <p style="">（4）一行最长不超过80个字符，超过的请使用换行展示，尽量保持格式优雅</p> 
 <p style=""></p> 
 <h3 style="">2.2 变量和常量（重点）</h3> 
 <p style="">常量：在程序执行的过程中，其值不会被改变的变量</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <p style="">​ <span class="kdocs-bold" style="font-weight:bold;">var 变量名</span><span class="kdocs-color" style="color:#C21C13;"> [: 变量类型]</span> = 初始值 var i:Int = 10</p> 
 <p style="">​ <span class="kdocs-bold" style="font-weight:bold;">va</span>l <span class="kdocs-bold" style="font-weight:bold;">常量名</span> <span class="kdocs-color" style="color:#C21C13;">[: 常量类型]</span> = 初始值 val j:Int = 20</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">​ </span><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">注意：能用常量的地方不用变量</span></span></p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <p style="">（1）声明变量时，类型可以省略，编译器自动推导，即类型推导</p> 
 <p style="">（2）类型确定后，就不能修改，说明Scala是强数据类型语言。</p> 
 <p style="">（3）变量声明时，必须要有初始值</p> 
 <p style="">（4）在声明/定义一个变量时，可以使用var或者val来修饰，var修饰的变量可改变，val修饰的变量不可改。</p> 
 <pre class="kdocs-scala"><code class="language-scala">object TestValueTransfer {
def main(args: Array[String]): Unit = {
var n = 1 + 2.2222
println(n) //Double

var n2: Double = 2.2222
//    var n3: Int = n2 //报错

var n4 : Byte = 44
//    var c1 : Char = n4 //报错
var n5 : Int = n4

var n6 : Byte = 66
var c2 : Char = 22
//    var n : Short = n6 + c2  //报错，结果是Int类型
//    var n7 : Short = 10 + 20  //报错，byte，short，char他们三者可以计算，在计算时首先转换为int类型。

}
}
</code></pre> 
 <p style="text-indent:1.4em;">（5）var修饰的对象引用可以改变，val修饰的对象则不可改变，但对象的状态（值）却是可以改变的。（比如：自定义对象、数组、集合等等）</p> 
 <pre class="kdocs-scala"><code class="language-scala">object TestVar {
def main(args: Array[String]): Unit = {
var age = 22
age = 29
//    age = "hh"  //报错

var n1 = 1 //可变
n1 = 2

val n2 = 2 //不可变
//n2 = 3

//p1 是var修饰的，p1的属性可以变，p1本身也可以变
var p1 = new Person()
p1.name = "varp1"
p1 = null

val p2 = new Person()
p2.name = "valp2"
//    p2 = null //报错
}

class Person {
var name: String = "who"
}
}
</code></pre> 
 <p style=""></p> 
 <h3 style="">2.3 标识符的命名规范</h3> 
 <p style="">Scala对各<span class="kdocs-color" style="color:#C21C13;">种变量、方法、函数</span>等命名时使用的字符序列称为<span class="kdocs-color" style="color:#C21C13;">标识符</span>。即：凡是自己可以起名字的地方都叫标识符。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）命名规则</span></p> 
 <p style="">Scala中的标识符声明，基本和Java是一致的，但是细节上会有所变化，有以下三种规则：</p> 
 <p style="">（1）以字母或者下划线开头，后接字母、数字、下划线</p> 
 <p style="">（2）以操作符开头，且只包含操作符（+ - * / # !等）</p> 
 <p style="">（3）用反引号....包括的任意字符串，即使是Scala关键字（39个）也可以</p> 
 <pre class="kdocs-scala"><code class="language-scala">• package, import, class, object, trait, extends, with, type, for
• private, protected, abstract, sealed, final, implicit, lazy, override
• try, catch, finally, throw
• if, else, match, case, do, while, for, return, yield
• def, val, var
• this, super
• new
• true, false, null</code></pre> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <p style="text-align:null;"> 需求：判断hello、Hello12、1hello、h-b、x h、h_4、<span class="kdocs-italic" style="font-style:italic;">ab、Int、</span>、+<span class="kdocs-italic" style="font-style:italic;">-/#!、+</span>-/#!1、if、<span class="kdocs-fontSize" style="font-size:9pt;">if</span>，这些名字是否合法。</p> 
 <pre class="kdocs-scala"><code class="language-scala">object TestName {
  def main(args: Array[String]): Unit = {

    //1.以字母或者下划线开头，后接字母、数字、下划线
    var hello: String = ""
    var hello2: String = " "

    //    var 1 hello:String = ""  数字不能开头
    //    var h - b: String = ""  不能用-
    //    var x h: String = ""  不能用空格

    var h_4: String = ""
    val _ab: String = ""
    var Int: String = "" //ok 因为在Scala中Int是预定义的字符,不是关键字，但不推荐
    var _: String = "" // ok 单独一个下划线不可以作为标识符，因为_被认为是一个方法



    //2.以操作符开头，且只包含操作符（+ - * / # ! 等）
    var +*-/#! : String = ""
    //    var +*-/#!1 : String = "" 以操作符开头必须都是操作符

    //3.用反引号`...`包括的任意字符串，即使是Scala关键字（39）个也可以
    //    var if:String = ""  不用用关键字
    var `if`: String = ""

  }
}</code></pre> 
 <p style=""></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">2.4 字符串输出</span></h3> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <p style="text-align:null;">（1）字符串，通过+号连接</p> 
 <p style="text-align:null;">（2）printf用法：字符串，通过%传值。</p> 
 <p style="text-align:null;">（3）字符串模板（插值字符串）：通过$获取变量值</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">object TestCharType {
def main(args: Array[String]): Unit = {
var name: String = "zhangsan"
var age: Int = 22

//1.字符串 通过 + 号连接
println(name + " " + age)

//2.printf 用法字符串，通过%传值
printf("name=%s age=%d\n", name, age)

//3.字符串，通过$引用
//多行字符串，在Scala中，利用三个双引号包围多行字符串就可以实现。//输入的内容，带有空格、\t之类，导致每一行的开始位置不能整洁对齐。
//应用scala的stripMargin方法，在scala中stripMargin默认是“|”作为连接符，//在多行换行的行头前面加一个“|”符号即可。

val s =

"""
  | select
  | name
  |,
  |age
  |from user
  |where name = "zhangsan"
""".stripMargin
println(s)


//如果需要对变量进行运算，那么可以加${}
val s1 =
s"""
   | select
   | name
   |,
   |age
   |from user
   |where name="$name" and age=${age + 2}
""".stripMargin
val s2 = s"name=$name"
println(s2)
}
}
</code></pre> 
 <p style=""></p> 
 <h3 style="">2.5 键盘输入</h3> 
 <p style="">在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。</p> 
 <p style="">1）基本语法</p> 
 <p style="">StdIn.readLine()、StdIn.readShort()、StdIn.readDouble()</p> 
 <p style="">2）案例实操</p> 
 <p style="">需求：可以从控制台接收用户信息，【姓名，年龄，薪水】。</p> 
 <pre class="kdocs-scala"><code class="language-scala">import scala.io.StdIn

object TestInput {
def main(args: Array[String]): Unit = {
//    输入姓名
println("input name:")
var name = StdIn.readLine()

//    输入年龄
println("input age:")
var age = StdIn.readShort()

//    输入薪水
println("input sal:")
var sal = StdIn.readDouble()

//    打印
println("name=" + name)
println("age=" + age)
println("sal=" + sal)
}

}</code></pre> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">从文件中读取数据：</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">import scala.io.Source;

Source.fromFile("C:\\Users\\90513\\Desktop\\datas.csv").foreach(print)</code></pre> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:704px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:26.84659%;height:0;"> 
    <img src="https://images2.imgbox.com/fc/4b/rEjZh1qO_o.png" style="margin-left:;display:block;width:704px;margin-top:-26.84659%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <h3 style="">2.6 数据类型（重点）</h3> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p><span class="kdocs-bold" style="font-weight:bold;">Java 数据类型</span></p></li></ul> 
 <p style="padding-left:1.4em;">Java基本数据类型：char、byte、short、int、long、float、double、boolean</p> 
 <p style="padding-left:1.4em;">Java引用类型：（对象类型）</p> 
 <p style="padding-left:1.4em;"><span class="kdocs-color" style="color:#C21C13;">由于Java有基本类型，而且基本类型不是真正意义的对象</span>，即使后面产生了基本类型的包装类，但是仍然存在基本数据类型，所以Java语言并不是真正意义上的面向对象</p> 
 <p style="padding-left:1.4em;">Java基本类型的包装类：Character、Byte、Short、Integer、Long、Float、Double、Boolean</p> 
 <p style="padding-left:1.4em;">注意：<span class="kdocs-bold" style="font-weight:bold;">Java中基本类型和引用类型没有共同的祖先</span>。</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p><span class="kdocs-bold" style="font-weight:bold;">Scala 数据类型</span></p></li></ul> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:51.48649%;height:0;"> 
    <img src="https://images2.imgbox.com/8b/67/G1ZmHBDa_o.png" style="margin-left:;display:block;width:740px;margin-top:-51.48649%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">2.7 整数类型（Byte、Short、Int、Long）</span></h3> 
 <p style="text-align:null;">Scala的整数类型就是用于存放整数值的，比如12，30，3456等等。</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）整型分类</span></p> 
 <div style=""> 
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1" style=""><tbody><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:138px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">数据类型</span></span></p></td><td class="kdocs-tableCell" style="width:737px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">描述</span></span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:138px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">Byte [1]</span></p></td><td class="kdocs-tableCell" style="width:737px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">8位有符号补码整数。数值区间为 -128 到 127</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:138px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">Short [2]</span></p></td><td class="kdocs-tableCell" style="width:737px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">16位有符号补码整数。数值区间为 -32768 到 32767</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:138px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">Int [4]</span></p></td><td class="kdocs-tableCell" style="width:737px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">32位有符号补码整数。数值区间为 -2147483648 到 2147483647</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:138px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">Long [8]</span></p></td><td class="kdocs-tableCell" style="width:737px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">64位有符号补码整数。数值区间为 -9223372036854775808 到 9223372036854775807 = 2的(64-1)次方-1</span></p></td></tr></tbody></table> 
 </div> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <p style="text-align:null;">（1）Scala各整数类型有固定的表示范围和字段长度，不受具体操作的影响，以保证Scala程序的可移植性。</p> 
 <p style="text-align:null;">（2）Scala的整型，默认为Int型，声明Long型，须后加‘l’或‘L’</p> 
 <pre class="kdocs-java"><code class="language-java">object TestDataType {
def main(args: Array[String]): Unit = {

// 正确
var n1: Byte = 127
var n2: Byte = -128

// 错误
//    var n3:Byte = 128
//    var n4:Byte = -129

// Scala的整型，默认为Int型，声明Long型，然后加”i“ 或者 ”L“
var n5 = 10
println(n5)

var n6 = 98989898989898989L
println(n6)

var n7 = 2.43434309898f
var n8 = 2.4343662343223
println(n7)
println(n8)

var God = new God()
God = null

//var n1 : Int = null //错误
//println("n1:" + n1)
}

class God {
}

}
</code></pre> 
 <p style="">（3）Scala程序中变量常声明为Int型，除非不足以表示大数，才使用Long</p> 
 <p style=""></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">2.8 浮点类型（Float、Double）</span></h3> 
 <p style="text-align:null;">Scala的浮点类型可以表示一个小数，比如123.4f，7.8，0.12等等。</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）浮点型分类</span></p> 
 <div style=""> 
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1" style=""><tbody><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:123px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">数据类型</span></span></p></td><td class="kdocs-tableCell" style="width:576px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">描述</span></span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:123px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">Float [4]</span></p></td><td class="kdocs-tableCell" style="width:576px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">32 位, IEEE 754标准的单精度浮点数</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:123px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">Double [8]</span></p></td><td class="kdocs-tableCell" style="width:576px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">64 位 IEEE 754标准的双精度浮点数</span></p></td></tr></tbody></table> 
 </div> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <p style="text-align:null;">Scala的浮点型常量默认为Double型，声明Float型常量，须后加‘f’或‘F’。</p> 
 <pre class="kdocs-java"><code class="language-java">object TestDataType {
def main(args: Array[String]): Unit = {

// 正确
var n1: Byte = 127
var n2: Byte = -128

// 错误
//    var n3:Byte = 128
//    var n4:Byte = -129

// Scala的整型，默认为Int型，声明Long型，然后加”i“ 或者 ”L“
var n5 = 10
println(n5)

var n6 = 98989898989898989L
println(n6)

var n7 = 2.43434309898f
var n8 = 2.4343662343223
println(n7)
println(n8)

var God = new God()
God = null

//var n1 : Int = null //错误
//println("n1:" + n1)
}

class God {
}

}
</code></pre> 
 <p style=""></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">2.9 字符类型（Char）</span></h3> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）基本说明</span></p> 
 <p style="text-indent:1.4em;text-align:null;">字符类型可以表示单个字符，字符类型是Char。</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <p style="text-align:null;">（1）字符常量是用单引号 ’ ’ 括起来的单个字符。</p> 
 <p style="text-align:null;">（2）\t ：一个制表位，实现对齐的功能</p> 
 <p style="text-align:null;">（3）\n ：换行符</p> 
 <p style="text-align:null;">（4）\\ ：表示\</p> 
 <p style="text-align:null;">（5）" ：表示"</p> 
 <pre class="kdocs-java"><code class="language-java">package com.atguigu.chapter1

object TestCharType2 {
def main(args: Array[String]): Unit = {
var c1: Char = 'a'
println("c1=" + c1)

//注意：这里涉及自动类型提升，其实编译器可以自定判断是否超出范围
//不过idea提示报错
var c2: Char = 'a' + 1
println(c2)

//    \t ：一个制表位，实现对齐的功能
println("姓名\t年龄")

//   \n ：换行符
println("西门庆\n潘金莲")

//（4）\\ ：表示\
println("c:\\天黑了\\饿狼来了")

//（5）\" ：表示"
println("你过来：\"看我一拳打死你\"")
}
}
</code></pre> 
 <p style=""></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">2.10 布尔类型：Boolean</span></h3> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）基本说明</span></p> 
 <p style="text-align:null;">（1）布尔类型也叫Boolean类型，Booolean类型数据只允许取值true和false</p> 
 <p style="text-align:null;">（2）boolean类型占1个字节。</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <pre class="kdocs-java"><code class="language-java">object TestBooleanType {
def main(args: Array[String]): Unit = {
var isResult : Boolean = false
var isResult2 : Boolean = true

}

}
</code></pre> 
 <p style=""></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">2.11 Unit类型、Null类型和Nothing类型（重点）</span></h3> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）基本说明</span></p> 
 <div style=""> 
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1" style=""><tbody><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">数据类型</span></span></p></td><td class="kdocs-tableCell" style="width:694px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">描述</span></span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">Unit</span></span></p></td><td class="kdocs-tableCell" style="width:694px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">表示无值，和其他语言中void等同。用作不返回任何结果的方法的结果类型。Unit只有一个实例值，写成()。</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">Null</span></span></p></td><td class="kdocs-tableCell" style="width:694px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">null , Null 类型只有一个实例值null</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">Nothing</span></span></p></td><td class="kdocs-tableCell" style="width:694px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">Nothing类型在Scala的类层级最低端；<span class="kdocs-bold" style="font-weight:bold;">它是任何其他类型的子类型</span>。 当一个函数，我们确定<span class="kdocs-bold" style="font-weight:bold;">没有正常的返回值（如抛出异常），可以用Nothing来指定返回类型</span>，这样有一个好处，就是我们可以把返回的值（异常）赋给其它的函数或者变量（<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">兼容性</span></span>）</span></p><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">在Java中有时候有返回值，如int，但有些情况下会抛出异常。为了兼容多种可能性，就可以使用nothing类型。</span></p></td></tr></tbody></table> 
 </div> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <p style="text-align:null;">（1）Unit类型用来标识过程，也就是没有明确返回值的函数。</p> 
 <p style="text-align:null;">由此可见，Unit类似于Java里的void。Unit只有一个实例——<span class="kdocs-bold" style="font-weight:bold;">( )</span>，这个实例也没有实质意义</p> 
 <pre class="kdocs-scala"><code class="language-scala">def m1():Unit={
    println("m1被执行")
}
val a:Unit=m1()
println("a="+a)

// 输出：a=()</code></pre> 
 <p style="">（2）Null类只有一个实例对象，Null类似于Java中的<span class="kdocs-bold" style="font-weight:bold;">null</span>引用。<span class="kdocs-bold" style="font-weight:bold;">Null可以赋值给任意引用类型（AnyRef），但是不能赋值给值类型（AnyVal）</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">object TestDataType {
def main(args: Array[String]): Unit = {

// 正确
var n1: Byte = 127
var n2: Byte = -128

// 错误
//    var n3:Byte = 128
//    var n4:Byte = -129

// Scala的整型，默认为Int型，声明Long型，然后加”i“ 或者 ”L“
var n5 = 10
println(n5)

var n6 = 98989898989898989L
println(n6)

var n7 = 2.43434309898f
var n8 = 2.4343662343223
println(n7)
println(n8)


// null可以赋值给任意引用类型（AnyRef），但是不能赋值给值类型（AnyVal）
var God = new God()
God = null

//    var n1: Int = null //错误
//    println("n1:" + n1)
}

class God {
}

}
</code></pre> 
 <p style="">（3）Nothing，可以作为没有正常返回值的方法的返回类型，非常直观的告诉你这个方法不会正常返回，而且由于Nothing是其他任意类型的子类，他还能跟要求返回值的方法兼容。</p> 
 <pre class="kdocs-scala"><code class="language-scala">object TestSpecialType {
def test(): Nothing = {
throw new Exception
}

test()
}
}
</code></pre> 
 <p style=""></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">2.12 类型转换</span></h3> 
 <h4 style="">2.12.1 数值类型自动转换</h4> 
 <p style="">当Scala程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数值类型，这个就是自动类型转换（隐式转换）。数据类型按精度（容量）大小排序为：</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）基本说明</span></p> 
 <p style="">（1）自动提升原则：有多种类型的数据混合运算时，系统首先自动将所有数据转换成精度大的那种数据类型，然后再进行计算。</p> 
 <p style="">（2）把精度大的数值类型赋值给精度小的数值类型时，就会报错，反之就会进行自动类型转换。</p> 
 <p style="">（3）（byte，short）和char之间不会相互自动转换。</p> 
 <p style="">（4）byte，short，char他们三者可以计算，在计算时首先转换为int类型。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">object TestValueTransfer {
def main(args: Array[String]): Unit = {

//（1）自动提升原则：有多种类型的数据混合运算时，系统首先自动将所有数据转换成精度大的那种数值类型，然后再进行计算。
var n = 1 + 2.2222
println(n) //Double

//（2）把精度大的数值类型赋值给精度小的数值类型时，就会报错，反之就会进行自动类型转换。
var n2: Double = 2.2222
//    var n3: Int = n2 //报错

//（3）（byte，short）和char之间不会相互自动转换。
var n4: Byte = 44
//    var c1 : Char = n4 //报错
var n5: Int = n4

//（4）byte，short，char他们三者可以计算，在计算时首先转换为int类型。
var n6: Byte = 66
var c2: Char = 22
//    var n : Short = n6 + c2  //报错，结果是Int类型
//    var n7 : Short = 10 + 20  //报错，byte，short，char他们三者可以计算，在计算时首先转换为int类型。

}
}
</code></pre> 
 <p style="">注意：Scala还提供了非常强大的隐式转换机制（隐式函数，隐式类等），我们放在高级部分专门用一个章节来讲解。</p> 
 <h4 style="">2.12.2 强制类型转换</h4> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）基本说明</span></p> 
 <p style="">自动类型转换的逆过程，将精度大的数值类型转换为精度小的数值类型。使用时要加上强制转函数，但可能造成精度降低或溢出，格外要注意。</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <p style="text-align:null;">（1）将数据由<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">高精度</span></span>转换为<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">低精度</span></span>，就需要使用到强制转换</p> 
 <p style="text-align:null;">（2）强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级</p> 
 <pre class="kdocs-scala"><code class="language-scala">object TestForceTransfer {

def main(args: Array[String]): Unit = {

//（1）将数据由高精度转换为低精度，就需要使用到强制转换
var n1: Int = 2.5.toInt // 这个存在精度损失

//（2）强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级
var r1: Int = 10 * 3.5.toInt + 6 * 1.5.toInt // 10 *3 + 6*1 = 36
var r2: Int = (10 * 3.5 + 6 * 1.5).toInt // 44.0.toInt = 44

println("r1=" + r1 + " r2=" + r2)
}
}
</code></pre> 
 <h4 style="">2.12.3 数值类型和String类型间转换</h4> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）基本说明</span></p> 
 <p style="">在程序开发中，我们经常需要将基本数值类型转成String类型。或者将String类型转成基本数值类型。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <p style="">（1）基本类型转String类型（语法：将基本类型的值+“” 即可）</p> 
 <p style="">（2）String类型转基本数值类型（语法：s1.toInt、s1.toFloat、s1.toDouble、s1.toByte、s1.toLong、s1.toShort）</p> 
 <pre class="kdocs-scala"><code class="language-scala">object TestStringTransfer {
def main(args: Array[String]): Unit = {
//（1）基本类型转String类型（语法：将基本类型的值+"" 即可）
var str1: String = true + "你kin"
println(str1)
var str2: String = 4.444 + "拜拜"
println(str2)
var str3: String = 4444 + ""
println(str3)

//（2）String类型转基本数值类型（语法：调用相关API）
var s1: String = "11"
var n1: Byte = s1.toByte
var n2: Short = s1.toShort
var n3: Int = s1.toInt
var n4: Long = s1.toLong
println(s1)
println(n1)
println(n2)
println(n3)
println(n4)
}
}
</code></pre> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">（3）注意事项</span></p> 
 <p style="">在将String类型转成基本数值类型时，要确保String类型能够转成有效的数据，比如我们可以把"123"，转成一个整数，但是不能把"hello"转成一个整数。</p> 
 <p style="">var n5:Int = “12.6”.toInt会出现NumberFormatException异常。</p> 
 <h3 style="">2.13 字符串String</h3> 
 <p style="text-indent:1.4em;">Scala中本身没有String数据类型，字符串本质上是Java String。和Java String 一样，String是一个不可变对象，该对象不可修改。</p> 
 <p style="text-indent:1.4em;"></p> 
 <h2 style="">三、<span class="kdocs-bold" style="font-weight:bold;">运算符</span></h2> 
 <p style="text-align:null;">Scala运算符的使用和Java运算符的使用基本相同，只有个别细节上不同。</p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">3.1 算术运算符</span></h3> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <div style=""> 
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1" style=""><tbody><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">运算符</span></span></p></td><td class="kdocs-tableCell" style="width:209px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">运算</span></span></p></td><td class="kdocs-tableCell" style="width:194px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">范例</span></span></p></td><td class="kdocs-tableCell" style="width:232px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">结果</span></span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">+</span></p></td><td class="kdocs-tableCell" style="width:209px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">正号</span></p></td><td class="kdocs-tableCell" style="width:194px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">+3</span></p></td><td class="kdocs-tableCell" style="width:232px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">3</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">-</span></p></td><td class="kdocs-tableCell" style="width:209px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">负号</span></p></td><td class="kdocs-tableCell" style="width:194px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">b=4; -b</span></p></td><td class="kdocs-tableCell" style="width:232px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">-4</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">+</span></p></td><td class="kdocs-tableCell" style="width:209px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">加</span></p></td><td class="kdocs-tableCell" style="width:194px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">5+5</span></p></td><td class="kdocs-tableCell" style="width:232px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">10</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">-</span></p></td><td class="kdocs-tableCell" style="width:209px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">减</span></p></td><td class="kdocs-tableCell" style="width:194px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">6-4</span></p></td><td class="kdocs-tableCell" style="width:232px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">2</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">*</span></p></td><td class="kdocs-tableCell" style="width:209px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">乘</span></p></td><td class="kdocs-tableCell" style="width:194px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">3*4</span></p></td><td class="kdocs-tableCell" style="width:232px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">12</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">/</span></p></td><td class="kdocs-tableCell" style="width:209px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">除</span></p></td><td class="kdocs-tableCell" style="width:194px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">5/5</span></p></td><td class="kdocs-tableCell" style="width:232px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">1</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">%</span></p></td><td class="kdocs-tableCell" style="width:209px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">取模(取余)</span></p></td><td class="kdocs-tableCell" style="width:194px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">7%5</span></p></td><td class="kdocs-tableCell" style="width:232px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">2</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">+</span></p></td><td class="kdocs-tableCell" style="width:209px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">字符串相加</span></p></td><td class="kdocs-tableCell" style="width:194px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">“He”+”llo”</span></p></td><td class="kdocs-tableCell" style="width:232px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">“Hello”</span></p></td></tr></tbody></table> 
 </div> 
 <p style="text-align:null;">（1）对于除号“/”，它的整数除和小数除是有区别的：整数之间做除法时，只保留整数部分而舍弃小数部分。</p> 
 <p style="text-align:null;">（2）对一个数取模a%b，和Java的取模规则一样。</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">object TestArithmetic {
def main(args: Array[String]): Unit = {

//    1）对于除号“/”，它的整数除和小数除是有区别的：整数之间做除法时，只保留整数部分而舍弃小数部分。
var r1: Int = 10 / 3
println(r1) //3

var r2: Double = 10 / 3
println(r2) //3.0

var r3: Double = 10.0 / 3
println(r3) //3.3333333333333335
println(r3.formatted("%.2f")) //3.33  含义：保留小数点2位，使用四舍五入

//（2）对一个数取模a%b，和Java的取模规则一样。
var r4 = 10 % 3
println(r4) //1

}

}
</code></pre> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">3.2 关系运算符（比较运算符）</span></h3> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <div style=""> 
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1" style=""><tbody><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">运算符</span></span></p></td><td class="kdocs-tableCell" style="width:205px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">运算</span></span></p></td><td class="kdocs-tableCell" style="width:240px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">范例</span></span></p></td><td class="kdocs-tableCell" style="width:181px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">结果</span></span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">==</span></p></td><td class="kdocs-tableCell" style="width:205px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">相等于</span></p></td><td class="kdocs-tableCell" style="width:240px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">4==3</span></p></td><td class="kdocs-tableCell" style="width:181px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">false</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">!=</span></p></td><td class="kdocs-tableCell" style="width:205px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">不等于</span></p></td><td class="kdocs-tableCell" style="width:240px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">4！=3</span></p></td><td class="kdocs-tableCell" style="width:181px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">true</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">&lt;</span></p></td><td class="kdocs-tableCell" style="width:205px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">小于</span></p></td><td class="kdocs-tableCell" style="width:240px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">4&lt;3</span></p></td><td class="kdocs-tableCell" style="width:181px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">false</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">&gt;</span></p></td><td class="kdocs-tableCell" style="width:205px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">大于</span></p></td><td class="kdocs-tableCell" style="width:240px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">4&gt;3</span></p></td><td class="kdocs-tableCell" style="width:181px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">true</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">&lt;=</span></p></td><td class="kdocs-tableCell" style="width:205px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">小于等于</span></p></td><td class="kdocs-tableCell" style="width:240px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">4&lt;=3</span></p></td><td class="kdocs-tableCell" style="width:181px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">false</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">&gt;=</span></p></td><td class="kdocs-tableCell" style="width:205px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">大于等于</span></p></td><td class="kdocs-tableCell" style="width:240px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">4&gt;=3</span></p></td><td class="kdocs-tableCell" style="width:181px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">true</span></p></td></tr></tbody></table> 
 </div> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <p style="text-align:null;"> （1）需求1：</p> 
 <pre class="kdocs-scala"><code class="language-scala">object TestRelation {
def main(args: Array[String]): Unit = {

// 测试：&gt;、&gt;=、&lt;=、&lt;、==、!=
var a: Int = 2
var b: Int = 1

println(a &gt; b) // true
println(a &gt;= b) // true
println(a &lt; b) // false
println(a &lt;= b) // false
println("a==b" + (a == b)) // false
println(a != b) // true
}
}
</code></pre> 
 <p style="text-align:null;">（2）需求2：Java和Scala中关于==的区别</p> 
 <p style="text-align:null;">Java：==比较两个变量本身的值，即两个对象在内存中的首地址；equals比较字符串中所包含的内容是否相同。</p> 
 <pre class="kdocs-scala"><code class="language-scala">public class TestRelation2 {
public static void main(String[] args) {
  String s1 = "hhhh";
  String s2 = new String("hhhh");

  System.out.println(s1 == s2);   // false
  System.out.println(s1.equals(s2));  // true
}
}
</code></pre> 
 <p style="">Scala：==更加类似于Java中的equals，参照jd工具</p> 
 <pre class="kdocs-scala"><code class="language-scala">object TestRelationScala {
def main(args: Array[String]): Unit = {
val s1 = "aaa"
val s2 = new String("aaa")

println(s1 == s2) //  true
println(s1.eq(s2))   // false
}
}
</code></pre> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">3.3 逻辑运算符</span></h3> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <p style="text-align:null;">用于连接多个条件（一般来讲就是关系表达式），最终的结果也是一个Boolean值。</p> 
 <p style="text-align:null;">假定：变量A为true，B为false</p> 
 <div style=""> 
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1" style=""><tbody><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">运算符</span></span></p></td><td class="kdocs-tableCell" style="width:178px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">描述</span></span></p></td><td class="kdocs-tableCell" style="width:267px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">实例</span></span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">&amp;&amp;</span></p></td><td class="kdocs-tableCell" style="width:178px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">逻辑与</span></p></td><td class="kdocs-tableCell" style="width:267px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">(A &amp;&amp; B) 运算结果为 false</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">||</span></p></td><td class="kdocs-tableCell" style="width:178px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">逻辑或</span></p></td><td class="kdocs-tableCell" style="width:267px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">(A || B) 运算结果为 true</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">!</span></p></td><td class="kdocs-tableCell" style="width:178px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">逻辑非</span></p></td><td class="kdocs-tableCell" style="width:267px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">!(A &amp;&amp; B) 运算结果为 true</span></p></td></tr></tbody></table> 
 </div> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">object TestLogic {

def main(args: Array[String]): Unit = {

//  测试：&amp;&amp;、||、！
var a = true
var b = false

println("a&amp;&amp;b=" + (a &amp;&amp; b)) //  a&amp;&amp;b=false
println("a || b =" + (a || b))  //  a || b =true
println("!(a&amp;&amp;b)" + (!(a &amp;&amp; b)))  // !(a&amp;&amp;b)true
}
}
</code></pre> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">3.4 赋值运算符</span></h3> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <p style="text-align:null;">赋值运算符就是将某个运算后的值，赋给指定的变量。</p> 
 <div style=""> 
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1" style=""><tbody><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">运算符</span></span></p></td><td class="kdocs-tableCell" style="width:344px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">描述</span></span></p></td><td class="kdocs-tableCell" style="width:371px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">实例</span></span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">=</span></p></td><td class="kdocs-tableCell" style="width:344px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">简单的赋值运算符，将一个表达式的值赋给一个左值</span></p></td><td class="kdocs-tableCell" style="width:371px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">C = A + B 将 A + B 表达式结果赋值给 C</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">+=</span></p></td><td class="kdocs-tableCell" style="width:344px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">相加后再赋值</span></p></td><td class="kdocs-tableCell" style="width:371px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">C += A 等于 C = C + A</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">-=</span></p></td><td class="kdocs-tableCell" style="width:344px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">相减后再赋值</span></p></td><td class="kdocs-tableCell" style="width:371px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">C -= A 等于 C = C - A</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">*=</span></p></td><td class="kdocs-tableCell" style="width:344px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">相乘后再赋值</span></p></td><td class="kdocs-tableCell" style="width:371px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">C *= A 等于 C = C * A</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">/=</span></p></td><td class="kdocs-tableCell" style="width:344px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">相除后再赋值</span></p></td><td class="kdocs-tableCell" style="width:371px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">C /= A 等于 C = C / A</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:49px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">%=</span></p></td><td class="kdocs-tableCell" style="width:344px;vertical-align:middle;height:49px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">求余后再赋值</span></p></td><td class="kdocs-tableCell" style="width:371px;vertical-align:middle;height:49px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">C %= A 等于 C = C % A</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">&lt;&lt;=</span></p></td><td class="kdocs-tableCell" style="width:344px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">左移后赋值</span></p></td><td class="kdocs-tableCell" style="width:371px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">C &lt;&lt;= 2等于 C = C &lt;&lt; 2</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">&gt;&gt;=</span></p></td><td class="kdocs-tableCell" style="width:344px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">右移后赋值</span></p></td><td class="kdocs-tableCell" style="width:371px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">C &gt;&gt;= 2 等于 C = C &gt;&gt; 2</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">&amp;=</span></p></td><td class="kdocs-tableCell" style="width:344px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">按位与后赋值</span></p></td><td class="kdocs-tableCell" style="width:371px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">C &amp;= 2 等于 C = C &amp; 2</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">^=</span></p></td><td class="kdocs-tableCell" style="width:344px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">按位异或后赋值</span></p></td><td class="kdocs-tableCell" style="width:371px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">C ^= 2 等于 C = C ^ 2</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">|=</span></p></td><td class="kdocs-tableCell" style="width:344px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">按位或后赋值</span></p></td><td class="kdocs-tableCell" style="width:371px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">C |= 2 等于 C = C | 2</span></p></td></tr></tbody></table> 
 </div> 
 <p style="text-align:null;">注意：Scala中没有++、–操作符，可以通过+=、-=来实现同样的效果；</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">object TestAssignment {
def main(args: Array[String]): Unit = {
var r1 = 11

//  没有++
r1 += 1 //12
println(r1)
// 没有--
r1 -= 2 //10
println(r1)
}
}
</code></pre> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">3.5 位运算符</span></h3> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <p style="text-align:null;"> 下表中变量 a 为 60，b 为 13。</p> 
 <div style=""> 
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1" style=""><tbody><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">运算符</span></span></p></td><td class="kdocs-tableCell" style="width:152px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">描述</span></span></p></td><td class="kdocs-tableCell" style="width:376px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">实例</span></span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">&amp;</span></p></td><td class="kdocs-tableCell" style="width:152px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">按位与运算符</span></p></td><td class="kdocs-tableCell" style="width:376px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">|</span></p></td><td class="kdocs-tableCell" style="width:152px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">按位或运算符</span></p></td><td class="kdocs-tableCell" style="width:376px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">(a | b) 输出结果 61 ，二进制解释： 0011 1101</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">^</span></p></td><td class="kdocs-tableCell" style="width:152px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">按位异或运算符</span></p></td><td class="kdocs-tableCell" style="width:376px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">~</span></p></td><td class="kdocs-tableCell" style="width:152px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">按位取反运算符</span></p></td><td class="kdocs-tableCell" style="width:376px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">&lt;&lt;</span></p></td><td class="kdocs-tableCell" style="width:152px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">左移动运算符</span></p></td><td class="kdocs-tableCell" style="width:376px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">a &lt;&lt; 2 输出结果 240 ，二进制解释： 0011 0000</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">&gt;&gt;</span></p></td><td class="kdocs-tableCell" style="width:152px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">右移动运算符</span></p></td><td class="kdocs-tableCell" style="width:376px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">&gt;&gt;&gt;</span></p></td><td class="kdocs-tableCell" style="width:152px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">无符号右移</span></p></td><td class="kdocs-tableCell" style="width:376px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">a &gt;&gt;&gt;2 输出结果 15, 二进制解释: 0000 1111</span></p></td></tr></tbody></table> 
 </div> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">object TestPositon {
def main(args: Array[String]): Unit = {

//  测试：1000 &lt;&lt; 1 =&gt;10000
var n1: Int = 8
n1 = n1 &lt;&lt; 1
println(n1) // 16
}

}
</code></pre> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">3.6 Scala运算符本质</span></h3> 
 <p style="text-align:null;">在Scala中其实是没有运算符的，<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">所有运算符都是方法</span></span>。</p> 
 <p style="text-align:null;">1）当调用对象的方法时，点.可以省略</p> 
 <p style="text-align:null;">2）如果函数参数只有一个，或者没有参数，()可以省略</p> 
 <pre class="kdocs-scala"><code class="language-scala">object TestOpt {
   def main(args: Array[String]): Unit = { 
// 标准的加法运算
 val i:Int = 1.+(1)
 
 // （1）当调用对象的方法时，.可以省略
 val j:Int = 1 + (1)
 
 // （2）如果函数参数只有一个，或者没有参数，()可以省略
 val k:Int = 1 + 1
 
 println(1.toString())
 println(1 toString())
 println(1 toString)
   }
 }
</code></pre> 
 <p style=""></p> 
 <h2 style="">四、流程控制</h2> 
 <h3 style="">4.1 分支控制if-else</h3> 
 <p style="">让程序有选择的的执行，分支控制有三种：单分支、双分支、多分支</p> 
 <h4 style="">4.1.1 单分支</h4> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <blockquote class="kdocs-blockquote" style="">
   if (条件表达式) { 
  <br> 执行代码块 
  <br>} 
 </blockquote> 
 <p style="">说明：当条件表达式为ture时，就会执行{ }的代码。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <p style="">需求：输入人的年龄，如果该同志的年龄小于18岁，则输出“童年”</p> 
 <p style=""></p> 
 <pre class="kdocs-scala"><code class="language-scala">if (age &lt; 18){
    println("童年")
}</code></pre> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">4.1.2 双分支</span></h4> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <blockquote class="kdocs-blockquote" style="">
   if (条件表达式) { 
  <br> 执行代码块1 
  <br>} else { 
  <br> 执行代码块2 
  <br>} 
 </blockquote> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <p style="text-align:null;">需求：输入年龄，如果年龄小于18岁，则输出“童年”。否则，输出“成年”。</p> 
 <pre class="kdocs-scala"><code class="language-scala">if (age &lt; 18) {
    println("童年")
} else {
    println("成年")
}</code></pre> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">4.1.3 多分支</span></h4> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <blockquote class="kdocs-blockquote" style="">
   if (条件表达式1) { 
  <br> 执行代码块1 
  <br>} 
  <br>else if (条件表达式2) { 
  <br> 执行代码块2 
  <br>} 
  <br>…… 
  <br>else { 
  <br> 执行代码块n 
  <br>} 
 </blockquote> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <p style="text-align:null;">（1）需求1：需求：输入年龄，如果年龄小于18岁，则输出“童年”。如果年龄大于等于18且小于等于30，则输出“中年”，否则，输出“老年”。</p> 
 <pre class="kdocs-scala"><code class="language-scala">if (age &lt; 18) {
    println("童年")
} else if (age &gt;= 18 &amp;&amp; age &lt; 30) {
    println("中年")
} else {
    println("老年")
}</code></pre> 
 <p style="">（2）需求2：Scala中if else表达式其实是有返回值的，具体返回值取决于满足条件的代码体的最后一行内容。</p> 
 <pre class="kdocs-scala"><code class="language-scala">val res :String = if (age &lt; 18) {
    "童年"
} else if (age &gt;= 18 &amp;&amp; age &lt; 30) {
    "中年"
} else {
    "老年"
}

println(res)</code></pre> 
 <p style="">（3）需求3：Scala中返回值类型不一致，取它们共同的祖先类型。</p> 
 <pre class="kdocs-scala"><code class="language-scala">val res :Any = if (age &lt; 18) {
    "童年"
} else if (age &gt;= 18 &amp;&amp; age &lt; 30) {
    "中年"
} else {
    100
}

println(res)</code></pre> 
 <p style="text-align:null;">（4）需求4：Java中的三元运算符可以用if else实现</p> 
 <p style="text-align:null;">如果大括号{}内的逻辑代码只有一行，大括号可以省略。如果省略大括号，if只对最近的一行逻辑代码起作用。</p> 
 <pre class="kdocs-java"><code class="language-java">// Java中三元运算符：a?b:c
// 如：int result = flag ? 1 : 0

// Scala
val res:String = if(age&gt;=18) "成年" else "未成年"

println(res)</code></pre> 
 <p style=""></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">4.2 嵌套分支</span></h3> 
 <p style="text-align:null;">在一个分支结构中又完整的嵌套了另一个完整的分支结构，里面的分支的结构称为内层。分支外面的分支结构称为外层分支。嵌套分支不要超过3层。</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <blockquote class="kdocs-blockquote" style="">
   if(){ 
  <br>if(){ 
  <br>}else{ 
  <br>} 
  <br>} 
 </blockquote> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <p style="text-align:null;">需求：如果输入的年龄小于18，返回“童年”。如果输入的年龄大于等于18，需要再判断：如果年龄大于等于18且小于30，返回“中年”；如果其他，返回“老年”。</p> 
 <pre class="kdocs-java"><code class="language-java">import scala.io.StdIn

object TestIfElse {
def main(args: Array[String]): Unit = {

// Scala
println("input age:")
var age = StdIn.readShort()
val res: Any = if (age &lt; 18) {
"童年"
} else {
if (age &gt;= 18 &amp;&amp; age &lt; 30) {
  "中年"
} else {
  "老年"
}
}

println(res)
}
}
</code></pre> 
 <p style=""></p> 
 <h3 style="">4.3 Switch分支结构</h3> 
 <p style="">在Scala中没有Switch，而是使用模式匹配来处理。</p> 
 <p style="">模式匹配涉及到的知识点较为综合，因此我们放在后面讲解。</p> 
 <p style=""></p> 
 <h3 style="">4.4 For循环控制</h3> 
 <p style="">Scala也为for循环这一常见的控制结构提供了非常多的特性，这些for循环的特性被称为for推导式或for表达式。</p> 
 <h4 style="">4.4.1 范围数据循环（To）</h4> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">// java for循环语法
for(int i = 0; i &lt; 10; i++){
    System.out.println("i=" + i);
}

// scala for循环语法
for(i &lt;- 1 to 10){
    println("i=" + i)
}
// 输出：从1~10（包含 1 和 10 ）</code></pre> 
 <p style="text-align:null;">（1）i 表示循环的变量，&lt;- 规定to</p> 
 <p style="text-align:null;">（2）i 将会从 1-3 循环，<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">前后闭合</span></span></p> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">4.4.2 范围数据循环（Until）</span></h4> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">// 方法一：
for(i &lt;- 1 until 10) {
    print("i=" + i)
}
// 输出：从1~10（包含 1，不包含 10 ）

// 方法二：
for(i &lt;- Range(1,10)) {
    print("i=" + i)
}</code></pre> 
 <p style="text-align:null;">（1）这种方式和前面的区别在于i是从1到3-1</p> 
 <p style="text-align:null;">（2）即使前闭合后开的范围</p> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">4.4.3 循环守卫</span></h4> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">for(i &lt;- 1 to 3 if i != 2) {
    print(i + " ")
}</code></pre> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">说明</span>：</p> 
 <p style="text-align:null;">（1）循环守卫，即循环保护式（也称条件判断式，守卫）。保护式为true则进入循环体内部，为false则跳过，类似于continue。</p> 
 <p style="text-align:null;">（2）上面的代码等价</p> 
 <pre class="kdocs-scala"><code class="language-scala">for (i &lt;- 1 to 3){
    if (i != 2) {
        print(i + " ")
    }
}</code></pre> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">4.4.4 循环步长by</span></h4> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">for (i &lt;- 1 to 10 by 2) {
    println(“i=” + i)
}</code></pre> 
 <p style="text-align:null;">说明：by表示步长</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <p style="text-align:null;"> 需求：输出1到10以内的所有奇数</p> 
 <pre class="kdocs-java"><code class="language-java">for (i &lt;- 1 to 10 by 2) {
println(“i=” + i)
}

输出结果
i=1
i=3
i=5
i=7
i=9</code></pre> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">4.4.5 嵌套循环</span></h4> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">for(i &lt;- 1 to 3; j &lt;- 1 to 3) {
    println(" i =" + i + " j = " + j)
}</code></pre> 
 <p style="text-align:null;">说明：没有关键字，所以范围后一定要加；来隔断逻辑</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）基本语法</span></p> 
 <p style="text-align:null;">上面的代码等价</p> 
 <pre class="kdocs-scala"><code class="language-scala">for (i &lt;- 1 to 3) {
    for (j &lt;- 1 to 3) {
        println(“i =” + i + " j=" + j)
    }
}</code></pre> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">4.4.6 引入变量</span></h4> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">for(i &lt;- 1 to 3; j = 4 - i) {
  println("i=" + i + " j=" + j)
}</code></pre> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">说明：</span></p> 
 <p style="text-align:null;">（1）for推导式一行中有多个表达式时，所以要加 <span class="kdocs-bold" style="font-weight:bold;">;</span> 来隔断逻辑</p> 
 <p style="text-align:null;">（2）for推导式有一个不成文的约定：当for推导式仅包含单一表达式时使用圆括号，当包含多个表达式时，一般每行一个表达式，并用花括号代替圆括号，如下：</p> 
 <pre class="kdocs-scala"><code class="language-scala">for {
    i &lt;- 1 to 3
    j = 4 - i
} {
    println(“i=” + i + " j=" + j)
}</code></pre> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <p style="text-align:null;">上面的代码等价于</p> 
 <pre class="kdocs-scala"><code class="language-scala">for (i &lt;- 1 to 3) {
    var j = 4 - i
    println(“i=” + i + " j=" + j)
}</code></pre> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">4.4.7 循环返回值</span></h4> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">val res = for(i &lt;- 1 to 10) yield i
println(res)</code></pre> 
 <p style="text-align:null;">说明：<span class="kdocs-bold" style="font-weight:bold;">将遍历过程中处理的结果返回到一个新Vector集合中</span>，使用<span class="kdocs-bold" style="font-weight:bold;">yield关键字</span>。</p> 
 <p style="text-align:null;"><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">注意：开发中很少使用。</span></span></p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <p style="text-align:null;"> 需求：将原数据中所有值乘以2，并把数据返回到一个新的集合中。</p> 
 <pre class="kdocs-scala"><code class="language-scala">var res = for(i &lt;-1 to 10) yield {
  i * 2
}
println(res)</code></pre> 
 <p style="text-align:null;">输出结果：</p> 
 <p style="text-align:null;">Vector(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)</p> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">4.4.8 倒序打印</span></h4> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）说明：</span>如果想倒序打印一组数据，可以用reverse。</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操：</span></p> 
 <p style="text-align:null;">需求：倒序打印10到1</p> 
 <pre class="kdocs-scala"><code class="language-scala">for(i &lt;- 1 to 10 reverse){
   println(i)
 }
</code></pre> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">4.5 While和do…While循环控制</span></h3> 
 <p style="text-align:null;">While和do…While的使用和Java语言中用法相同。</p> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">4.5.1 While循环控制</span></h4> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">循环变量初始化

while (循环条件) {

   循环体(语句)

   循环变量迭代

}
</code></pre> 
 <p style="">说明：</p> 
 <p style="">（1）循环条件是返回一个布尔值的表达式</p> 
 <p style="">（2）while循环是先判断再执行语句</p> 
 <p style="">（3）与for语句不同，<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">while语句没有返回值</span></span>，即整个while语句的<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">结果是Unit类型()</span></span></p> 
 <p style="">（4）因为while中没有返回值，所以当要用该语句来计算并返回结果时，就不可避免的使用变量，而变量需要声明在while循环的外部，那么就等同于循环的内部对外部的变量造成了影响，所以不推荐使用，而是<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">推荐使用for循环</span></span>。</p> 
 <pre class="kdocs-scala"><code class="language-scala">object For01 {
def main(args: Array[String]): Unit = {

//    1.范围循环 To
for (i &lt;- 1 to 3)
println("生如")
println("to----------------------")


//  2.范围循环 Unit
for (i &lt;- 1 until 3)
println("夏花")
println("until----------------------")


//  3.循环守卫
for (i &lt;- 1 to 6) {
if (i != 2) {
  println(i)
}
}
println("!=----------------------")
//    4.循环步长 by
for (i &lt;- 1 to 6 by 2)
println(i)

println("by----------------------")
for (i &lt;- -10 to -1 by 2)
println(i)
println("by----------------------")

//    5.循环嵌套
for (i &lt;- 1 to 4; j &lt;- 1 to 6) {
print("i=" + i + ",j=" + j + "\t")
if (j == 6)
  println()
}
println("嵌套----------------------")

//  6.引入变量
for (i &lt;- 1 to 10; j = 10 - i) {
println("i=" + i + ",j=" + j)
}
println("引入变量----------------------")


for {
i &lt;- 1 to 3
j = 3 - i
} {
println("i=" + i + ",j=" + j)
}
println("引入变量----------------------")


//  7.循环返回值
val res = for (i &lt;- 1 to 10) yield i
println(res)
println("----------------------")

//需求：将原数据中所有值乘以2，并把数据返回到一个新的集合中。
var res1 = for (i &lt;- 1 to 10) yield {
i * 2
}
println(res1)
println("循环返回值----------------------")

//  8.倒序打印
for (i &lt;- 1 to 10 reverse) {
println(i)
}
println("倒序----------------------")
}

}
</code></pre> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">4.5.2 do…while循环控制</span></h4> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <pre class="kdocs-scala"><code class="language-scala"> 循环变量初始化;
  do{
    循环体(语句)
    循环变量迭代
  } while(循环条件)
</code></pre> 
 <p style="">说明</p> 
 <p style="">（1）循环条件是返回一个布尔值的表达式</p> 
 <p style="">（2）do…while循环是<span class="kdocs-bold" style="font-weight:bold;">先执行，再判断</span></p> 
 <h3 style="">4.6 循环中断</h3> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）基本说明</span></p> 
 <p style="">Scala内置控制结构特地<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">去掉了break和continue</span></span>，是为了更好的适应函数式编程，推荐使用函数式的风格解决break和continue的功能，而不是一个关键字。Scala中使用breakable控制结构来实现break和continue功能。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <p style="">需求1：采用异常的方式退出循环</p> 
 <pre class="kdocs-scala"><code class="language-scala">//  1.正常结束循环
try {
 for (elem &lt;- 1 to 10) {
   println(elem)
   if (elem == 5) throw new RuntimeException
 }
} catch {
 case e =&gt;
}
println("正常结束循环")
}
</code></pre> 
 <p style="">需求2：采用Scala自带的函数，退出循环</p> 
 <pre class="kdocs-scala"><code class="language-scala">//  2.采用scala自带的函数，退出循环
Breaks.breakable(
    for (e &lt;- 1 to 5) {
        println(e)
        if (e == 5) Breaks.break()
    }
)
println("正常结束循环")</code></pre> 
 <p style=""> 需求3：对break进行省略</p> 
 <pre class="kdocs-scala"><code class="language-scala">import scala.util.control.Breaks._

breakable {
    for (elem &lt;- 1 to 10) {
         println(elem)
      if (elem == 5) break
    }
}
println("正常结束循环")</code></pre> 
 <p style=""> 需求4：循环遍历10以内的所有数据，奇数打印，偶数跳过（continue）</p> 
 <pre class="kdocs-scala"><code class="language-scala">//循环遍历10以内的所有数据，奇数打印，偶数跳过（continue）

for (elem &lt;- 1 to 10) {
    if (elem % 2 == 1){
         println(elem)
    }else{
         println("continue")
    }
}</code></pre> 
 <h3 style="">4.7 多重循环</h3> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）基本说明</span></p> 
 <p style="">（1）将一个循环放在另一个循环体内，就形成了嵌套循环。其中，for，while，do…while均可以作为外层循环和内层循环。【建议一般使用两层，最多不要超过3层】</p> 
 <p style="">（2）设外层循环次数为m次，内层为n次，则内层循环体实际上需要执行m*n次。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <p style="">需求：打印出九九乘法表</p> 
 <pre class="kdocs-scala"><code class="language-scala">for (i &lt;- 1 to 10) {
    for (j &lt;- 1 to i) {
      print(j + "*" + i + "=" + (i * j) + "\t")
    }
println()
}</code></pre> 
 <p style=""></p> 
 <h2 style="">五、函数式编程</h2> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）面向对象编程</span></p> 
 <p style="">解决问题，分解对象，行为，属性，然后通过对象的关系以及行为的调用来解决问题。</p> 
 <p style="">对象：用户</p> 
 <p style="">行为：登录、连接JDBC、读取数据库</p> 
 <p style="">属性：用户名、密码</p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">Scala语言是一个完全面向对象编程语言。万物皆对象</span></span></p> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">对象的本质：对数据和行为的一个封装</span></span></p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">2）函数式编程</span></p> 
 <p style="">解决问题时，将问题分解成一个一个的步骤，将每个步骤进行封装（函数），通过调用这些封装好的步骤，解决问题。</p> 
 <p style="">例如：请求-&gt;用户名、密码-&gt;连接JDBC-&gt;读取数据库</p> 
 <p style="">Scala语言是一个完全函数式编程语言。万物皆函数。</p> 
 <p style="">函数的本质：函数可以当做一个值进行传递</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">3）在Scala中函数式编程和面向对象编程完美融合在一起了。</span></p> 
 <p style=""></p> 
 <h3 style="">5.1 函数基础</h3> 
 <h4 style="">5.1.1 函数基本语法</h4> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">def sum ( x : Int , y : Int ) : Int = {
    x + y
}</code></pre> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:429px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:48.95105%;height:0;"> 
    <img src="https://images2.imgbox.com/c0/42/rB0rFKb4_o.png" style="margin-left:;display:block;width:429px;margin-top:-48.95105%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <p style="text-align:null;"> 需求：定义一个函数，实现将传入的名称打印出来。</p> 
 <pre class="kdocs-scala"><code class="language-scala">object TestFunction {
    def main(args: Array[String]): Unit = {
​ // （1）函数定义
        def f(arg: String): Unit = {
​            println(arg)
        }
​ // （2）函数调用
​ // 函数名（参数）
        f(“hello world”)
    }
}</code></pre> 
 <h4 style="">5.1.2 函数和方法的区别</h4> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）核心概念</span></p> 
 <p style="">（1）为完成某一功能的程序语句的集合，称为函数。</p> 
 <p style="">（2）类中的函数称之方法。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <p style="">（1）Scala语言可以在任何的语法结构中声明任何的语法</p> 
 <p style="">（2）函数没有重载和重写的概念；方法可以进行重载和重写</p> 
 <p style="">（3）Scala中函数可以嵌套定义</p> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">5.1.3 函数定义</span></h4> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）函数定义</span></p> 
 <p style="text-align:null;">（1）函数1：无参，无返回值</p> 
 <p style="text-align:null;">（2）函数2：无参，有返回值</p> 
 <p style="text-align:null;">（3）函数3：有参，无返回值</p> 
 <p style="text-align:null;">（4）函数4：有参，有返回值</p> 
 <p style="text-align:null;">（5）函数5：多参，无返回值</p> 
 <p style="text-align:null;">（6）函数6：多参，有返回值</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">object TestFunctionDeclare {
    def main(args: Array[String]): Unit = {
//1.无参，无返回值
        def t1():Unit={
            println("1.无参，无返回值")
        }
        t1()

//2.无参，有返回值
        def t2():String ={
            return "2.无参，有返回值"
        }
        println(t2())
    
//3.有参，无返回值
        def t3(s:String):Unit={
            println(s)
        }
        t3("t3")
    
//4.有参，有返回值
        def t4(s:String):String={
            return s+"4.有参，有返回值"
        }
        println(t4("hello"))
    
//5.多参，无返回值
        def t5(name:String,age:Int):Unit={
            println(s"$name,$age")
        }
        t5("monika",22)
    }
}</code></pre> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">5.1.4 函数参数</span></h4> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）案例实操</span></p> 
 <p style="text-align:null;">（1）可变参数</p> 
 <p style="text-align:null;">（2）如果参数列表中存在多个参数，那么可变参数一般放置在最后</p> 
 <p style="text-align:null;">（3）参数默认值，一般将有默认值的参数放置在参数列表的后面</p> 
 <p style="text-align:null;">（4）带名参数</p> 
 <pre class="kdocs-scala"><code class="language-scala">def main(args: Array[String]): Unit = {
//1.可变参数
    def test(s: String*): Unit = {
        println(s)
        for (str&lt;-s) println(str)
    }
    //有输入参数：输出Array
    test("Hello", "Scala")

    //无输入参数：输出List()
    test()

//2.如果参数列表中存在多个参数，那么可变参数一般放置在最后
    def test2(name: String, s: String): Unit = {
        println(name + "," + s)
    }

    test2("jinlian", "dalang")


//3.参数默认值
    def test3(name: String, age: Int = 30): Unit = {
        println(s"$name,$age")
    }
    //如果参数传递了值，那么会覆盖默认值
    test3("jinlian", 20)
    //如果参数有默认值，在调用的时候，可以省略这个参数
    test3("dalang")

    //一般情况下，将有默认值的参数放置在参数列表的后面
    def test4(sex: String = "男", name: String): Unit = {
        println(s"name,sex")
    }

    //Scala函数中参数传递是，从左到右
    //test4("wusong") //报错
    test4("女", "jinlian")

//4.带名参数
    test4(name = "ximenqing")

}</code></pre> 
 <h4 style="">5.1.5 函数至简原则（重点）</h4> 
 <p style="">函数至简原则：能省则省</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）至简原则细节</span></p> 
 <p style="">（1）return可以省略，<span class="kdocs-bold" style="font-weight:bold;">Scala会使用函数体的最后一行代码作为返回值</span></p> 
 <p style="">（2）如果函数体只有一行代码，可以省略花括号</p> 
 <p style="">（3）返回值类型如果能够推断出来，那么可以省略（:和返回值类型一起省略）</p> 
 <p style="">（4）如果有return，则不能省略返回值类型，必须指定</p> 
 <p style="">（5）如果函数明确声明unit，那么即使函数体中使用return关键字也不起作用</p> 
 <p style="">（6）Scala如果期望是无返回值类型，可以省略等号</p> 
 <p style="">（7）如果函数无参，但是声明了参数列表，那么调用时，小括号，可加可不加</p> 
 <p style="">（8）如果函数没有参数列表，那么小括号可以省略，调用时小括号必须省略</p> 
 <p style="">（9）如果不关心名称，只关心逻辑处理，那么函数名（def）可以省略（<span class="kdocs-bold" style="font-weight:bold;">匿名函数，lambda表达式</span>）</p> 
 <blockquote class="kdocs-blockquote" style=""> 
  <span class="kdocs-bold" style="font-weight:bold;">lambda表达式：</span> 
  <br> ( name: String ) =&gt; { println( name ) } 
 </blockquote> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">def main(args: Array[String]): Unit = {
    def f(s: String): String = {
        return s + "f"
    }

// 1.return可以省略，scala会使用函数体的最后一行代码作为返回值
    def f1(s: String): String = {
        s + "f1"
    }

// 2.如果函数体只有一行代码，可以省略花括号
    def f2(s: String): String = s + "f2"

// 3.返回值类型如果能够推断出来，那么可以省略
    def f3(s: String) = s + "f3"

// 4.如果有return，则不能省略返回值类型，必须指定
    def f4(): String = {
        return "f4"
    }

// 5.如果函数明确声明unit，那么即使函数体中使用return关键字也不起作用
    def f5(): Unit = {
        return "f5"
    }

// 6.如果期望是无返回值类型，那么可以省略等号
    def f6() {
        "f6"
    }

// 7.如果函数无参，但是声明了参数列表，那么调用时，小括号，可加可不加
    def f7() = "f7"
    println(f7())
    println(f7)

// 8.如果函数没有参数列表，那么小括号可以省略，调用时小括号必须省略
    def f8() = "f8" 
简化为=&gt; 
    def f8 = "f8"
    println(f8)

// 9.如果不关心名称，只关心逻辑处理，那么函数名（def）可以省略
    def f9(str: String) = { println("f9") }
简化为=&gt;
    // 匿名函数，lambda表达式
    (name: String) =&gt; { println(name) }
}</code></pre> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">5.2 函数高级</span></h3> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">5.2.1 高阶函数</span></h4> 
 <p style="text-align:null;">在Scala中，函数是一等公民。怎么体现的呢？</p> 
 <p style="text-align:null;">对于一个函数我们可以：<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">定义函数</span></span>、<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">调用函数</span></span></p> 
 <pre class="kdocs-scala"><code class="language-scala">object TestFunction {

  def main(args: Array[String]): Unit = {
    // 调用函数
    foo()
  }

  // 定义函数
  def foo():Unit = {
    println("foo...")
  }
}
</code></pre> 
 <p style="text-align:null;">但是其实函数还有更高阶的用法</p> 
 <h5 style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）函数可以作为值进行传递</span></h5> 
 <pre class="kdocs-scala"><code class="language-scala">def f(n: Int):Int = {
    println("f调用")
    n + 1
}

// 调用f(123)，返回值124，将返回值赋值给val变量result
val result: Int = f(123)    
println(result)        // 输出124</code></pre> 
 <h5 style=""><span class="kdocs-bold" style="font-weight:bold;">2）函数可以作为参数进行传递</span></h5> 
 <pre class="kdocs-scala"><code class="language-scala">// 正常定义函数
def funTest03(msg1:String, msg2:String) : String = {  }

// msg1替换为：f:(Int,Int)=&gt;Int （lambda表达式）
def funTest( f:(Int,Int)=&gt;Int, msg:String ):String={
  val a = 100;
  val b = 200;
  val result = f(a,b)
  msg + result
}

// 函数调用
println("funTest:"+funTest(_*_,"abc"))    // funTest:abc20000

// 重新定义f函数
val f:(Int,Int)=&gt;Int = (a:Int,b:Int)=&gt;a*b
println("funTest:"+funTest(f,"abc"))      // funTest:abc20000</code></pre> 
 <h6 style=""><span class="kdocs-bold" style="font-weight:bold;">备注：f函数说明</span></h6> 
 <pre class="kdocs-scala"><code class="language-scala">// 参数的定义：
    val a: Int = 12
// 函数的定义：
    def f(a:Int,b:Int):Int = { a + b }
    // lambda表达式
    val f:(Int,Int)=&gt;Int = { (a:Int,b:Int)=&gt;a*b }

其中：
(Int,Int)=&gt;Int    是函数类型，表示输入两个Int类型参数，输出一个Int类型值。
                   类似参数定义中的Int类型值，可省略
(a:Int,b:Int)=&gt;a*b  a,b为形参，a*b为返回值

// 简化：
// 1. 函数体只有一条语句，省略{}
    val f:(Int,Int)=&gt;Int = (a:Int,b:Int)=&gt;a*b
// 2. 函数类型可省略
    val f = (a:Int,b:Int)=&gt;a*b</code></pre> 
 <p style="">函数简化后我们就比较容易看出，f函数本质是<span class="kdocs-bold" style="font-weight:bold;">匿名函数</span>作为<span class="kdocs-bold" style="font-weight:bold;">值传递</span>给一个变量f</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:702px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:26.638176%;height:0;"> 
    <img src="https://images2.imgbox.com/19/a6/qAMkrOjt_o.png" style="margin-left:;display:block;width:702px;margin-top:-26.638176%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <h5 style=""><span class="kdocs-bold" style="font-weight:bold;">3）函数可以作为返回值进行传递</span></h5> 
 <pre class="kdocs-scala"><code class="language-scala">// 正常定义函数
def funTest03(num:Int) : String = {  }

// 返回类型：函数
// (Int,Int)=&gt;Int：传入两个Int类型的参数，返回一个Int类型的参数
def funTest03(num:Int) : (Int,Int)=&gt;Int = {
  println("num value is " + num)
  def sum(a: Int, b: Int): Int = a + b
  def sub(a: Int, b: Int): Int = a - b
  if(num%2==0) sum else sub
}


// 方法调用
val result = funTest03(10)(10,20)
println(result)

// 上面方法调用等效于如下：
val resultFun:(Int, Int) =&gt; Int = funTest03(9)
val resultVal = resultFun(10,20)
println(resultFun)</code></pre> 
 <h4 style="">5.2.2 匿名函数</h4> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）说明</span></p> 
 <p style="">没有名字的函数就是匿名函数。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">( x : Int ) </span><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">=&gt;</span></span><span class="kdocs-bold" style="font-weight:bold;"> { 函数体 }</span></p> 
 <p style="">x：表示输入参数类型；Int：表示输入参数类型；函数体：表示具体代码逻辑</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <p style="">​ 需求1：传递的函数有一个参数</p> 
 <p style="">传递匿名函数至简原则：</p> 
 <p style="">（1）参数的类型可以省略，会根据形参进行自动的推导</p> 
 <p style="">（2）类型省略之后，发现只有一个参数，则圆括号可以省略；其他情况：没有参数和参数超过1的永远不能省略圆括号。</p> 
 <p style="">（3）匿名函数如果只有一行，则大括号也可以省略</p> 
 <p style="">（4）如果参数只出现一次，则参数省略且后面参数可以用_代替</p> 
 <pre class="kdocs-scala"><code class="language-scala">// 函数原型
    f( (name: String) =&gt; { println(name) } ) 

// （1）参数的类型可以省略，会根据形参进行自动的推导
    f( (name) =&gt; { println(name) })

// （2）类型省略之后，发现只有一个参数，则圆括号可以省略；其他情况：没有参数和参数超过1的永远不能省略圆括号。
    f( name =&gt; { println(name) })

// （3）匿名函数如果只有一行，则大括号也可以省略
    f( (name) =&gt; println(name) )

// （4）如果参数只出现一次，则参数省略且后面参数可以用_代替
    f( println(_) )
// （5）如果可以推导出，当前传入的println是一个函数体，而不是条用语句，可以直接省略下划线
    f( println )</code></pre> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">实际案例：</span></p> 
 <p style="">定义 一个“二元运算”函数</p> 
 <pre class="kdocs-scala"><code class="language-scala">// 基础函数
def sum(a:Int, b:Int):Int = a + b
println(sum(1,2))

// 函数作为值进行传递
val add = (a:Int, b:Int) =&gt; a + b
println(add(1,2))
val add2: (Int, Int) =&gt; Int = (a:Int, b:Int)=&gt;{
                                    println("a + b = "+ (a+b))
                                    a + b
                                }

// 用函数作为参数传递
def funTest( a:Int, msg:String ):String={ }    //原函数
def funTest( f:(Int,Int)=&gt;Int, msg:String ):String={
    val a = 100
    val b = 200
    val result = f(a,b)
    msg + result
  }
def funcTest2(num:Int, f1:(Int,Int)=&gt;Int,f2:(Int,Int)=&gt;Int):Int={
    val value1 = 1000
    val value2 = 2000
    val res:Int = if (num%2==0) f1(value1,value2) else f2(value1,value2)
    res
  }
 println(funcTest2(9 , _+_ , _-_ ))</code></pre> 
 <p style=""> </p> 
 <h3 style="">5.3 函数柯里化</h3> 
 <p style="">柯里化（Currying）是<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">把接受多个参数的函数变换成接受一个单一参数</span></span>(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数</p> 
 <pre class="kdocs-scala"><code class="language-scala">def fun(a:Int,b:Int,c:Int,d:Int):Int={
    a+b+c+d
}

def fun2(a:Int,b:Int)(c:Int,d:Int):Int={
    a+b+c+d
}

def fun3(a:Int,b:Int,c:Int)(d:Int):Int={
    a+b+c+d
}
// fun3：传入三个Int类型的参数，输出一个Int类型的值
private val fun: (Int, Int, Int) =&gt; Int =&gt; Int = fun3 _

def fun4(a:Int)(b:Int)(c:Int)(d:Int):Int={
    a+b+c+d
}
private val fun: Int =&gt; Int =&gt; Int =&gt; Int =&gt; Int = fun4 _</code></pre> 
 <h3 style="">5.4 偏函数</h3> 
 <p style="">所谓偏函数，就是以原函数为基础，将某个位置上的参数固定住（默认是从第一个参数固定），后续参数重新扩展传递给原函数，对外则是生成一个新函数。</p> 
 <p style="">使用<span class="kdocs-bold" style="font-weight:bold;">collect方法</span>并行计算</p> 
 <pre class="kdocs-scala"><code class="language-scala">// 普通方法定义一个函数
def funPartition:(Int, Int)=&gt; Int= { }

def funPartition:PartialFunction[String,Int] = {
    case "hello" =&gt; 1
    case "world" =&gt; 2
    case _       =&gt; 3
}
println(funPartition("scala"))        // 输出3

// 输入一个数组，并进行计算
val strings = Array("hello","java","scala","world")
val ints: Array[Int] = strings.collect(funPartition)
println(ints.mkString(","))        // 1,3,3,2</code></pre> 
 <p style=""></p> 
 <p style=""></p> 
 <h2 style="">六、面向对象</h2> 
 <p style="text-align:null;">Scala的面向对象思想和Java的面向对象思想和概念是一致的。</p> 
 <p style="text-align:null;">Scala中语法和Java不同，补充了更多的功能。</p> 
 <h3 style="">6.1 Scala包</h3> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <p style="">package 包名</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">2）Scala包的三大作用（和Java一样）</span></p> 
 <p style="">（1）区分相同名字的类</p> 
 <p style="">（2）当类很多时，可以很好的管理类</p> 
 <p style="">（3）控制访问范围</p> 
 <h3 style="">6.1.1 包的命名</h3> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）命名规则</span></p> 
 <p style="">只能包含数字、字母、下划线、小圆点.，但不能用数字开头，也不要使用关键字。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <blockquote class="kdocs-blockquote" style="">
   demo.class.exec1 //错误，因为 class 关键字 
  <br>demo.12a //错误，数字开头 
 </blockquote> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">3）命名规范</span></p> 
 <p style="">一般是小写字母+小圆点</p> 
 <p style=""><span class="kdocs-color" style="color:#116AF0;"><span class="kdocs-bold" style="font-weight:bold;">com.公司名.项目名.业务模块名</span></span></p> 
 <h4 style="">6.1.2 包说明（包语句）</h4> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）说明</span></p> 
 <p style="text-indent:1.4em;">Scala有两种包的管理风格，一种方式和Java的包管理风格相同，每个源文件一个包（包名和源文件所在路径不要求必须一致），包名用“.”进行分隔以表示包的层级关系，如com.atguigu.scala。另一种风格，通过嵌套的风格表示层级关系，如下：</p> 
 <pre class="kdocs-scala"><code class="language-scala">package com{
    package baidu{
        package scala{

        }
    }
}</code></pre> 
 <p style="text-align:null;">第二种风格有以下特点：</p> 
 <p style="text-align:null;">（1）一个源文件中可以声明多个package</p> 
 <p style="text-align:null;">（2）子包中的类可以直接访问父包中的内容，而无需导包</p> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">6.1.3 包对象</span></h4> 
 <p style="text-align:null;">在Scala中可以为每个包定义一个<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">同名</span></span>的包对象，定义在包对象中的成员，作为其<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">对应包下</span></span>所有class和object的共享变量，可以被直接访问。</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）定义</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">package object com{
    val shareValue="share"
    def shareMethod()={}
}</code></pre> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2） 说明</span></p> 
 <p style="text-indent:1.4em;text-align:null;">若使用Java的包管理风格，则包对象一般定义在其对应包下的package.scala文件中，包对象名与包名保持一致。</p> 
 <h4 style="">6.1.4 导包说明</h4> 
 <p style="">1）和Java一样，可以在顶部使用import导入，在这个文件中的所有类都可以使用。</p> 
 <p style="">2）局部导入：什么时候使用，什么时候导入。<span class="kdocs-bold" style="font-weight:bold;">在其作用范围内都可以使用</span></p> 
 <p style="">3）通配符导入：import java.util._</p> 
 <p style="">4）给类起名：import java.util.{ArrayList=&gt;JL}</p> 
 <p style="">5）屏蔽类：import java.util.{ArrayList =&gt;,}</p> 
 <p style="">6）导入<span class="kdocs-bold" style="font-weight:bold;">相同包的</span>多个类：import java.util.{HashSet, ArrayList}</p> 
 <p style="">7）导入包的绝对路径：new root.java.util.HashMap</p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">6.2 类和对象</span></h3> 
 <p style="text-align:null;">类：可以看成一个模板</p> 
 <p style="text-align:null;">对象：表示具体的事物</p> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">6.2.1 定义类</span></h4> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">0）回顾</span>：Java中的类</p> 
 <p style="text-align:null;"> 如果类是public的，则必须和文件名一致。</p> 
 <p style="text-align:null;"> 一般，一个.java有一个public类</p> 
 <p style="text-align:null;"><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">注意：Scala中没有public，一个.scala中可以写多个类。</span></span></p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">[修饰符] class类名 {
    类体
}</code></pre> 
 <p style="text-align:null;">说明</p> 
 <p style="text-align:null;">（1）Scala语法中，类并不声明为public，所有这些类都具有公有可见性（即默认就是public）</p> 
 <p style="text-align:null;">（2）一个Scala源文件可以包含多个类</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">//    (1)Scala语法中，类并不声明public，所有这些类都具有共有可见性（即默认就是public）
class Person {
    // 定义属性
    private var name: String = "alice"
    var age: Int = _
    var sex: String = _
}

//    (2) 一个Scala源文件可以包含多个类
class Teacher {

}

def main(args: Array[String]): Unit = {
    // 创建一个对象
    val stu = new Student;
    stu.name        // error，不能访问
    stu.age
    stu.sex
}</code></pre> 
 <h3 style="">6.3 封装</h3> 
 <p style="text-indent:1.4em;">封装就是把抽象出的<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">数据和对数据的操作</span></span>封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作（成员方法），才能对数据进行操作。Java封装操作如下，</p> 
 <p style="">（1）将属性进行私有化</p> 
 <p style="">（2）提供一个公共的set方法，用于对属性赋值</p> 
 <p style="">（3）提供一个公共的get方法，用于获取属性的值</p> 
 <p style="text-indent:1.4em;">Scala中的<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">public</span></span>属性，底层实际为<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">private</span></span>，并通过get方法（obj.field()）和set方法（obj.field_=(value)）对其进行操作。所以Scala并不推荐将属性设为private，再为其设置public的get和set方法的做法。但由于很多Java框架都利用反射调用getXXX和setXXX方法，有时候为了和这些框架兼容，也会为Scala的属性设置getXXX和setXXX方法（通过<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">@BeanProperty</span></span>注解实现）。</p> 
 <h4 style="">6.3.1 访问权限</h4> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）说明</span></p> 
 <p style="text-indent:1.4em;">在Java中，访问权限分为：public，private，protected和默认。在Scala中，你可以通过类似的修饰符达到同样的效果。但是使用上有区别。</p> 
 <p style="">（1）Scala 中属性和方法的默认访问权限为public，但Scala中无public关键字。</p> 
 <p style="">（2）private为私有权限，只在类的内部和伴生对象中可用。</p> 
 <p style="">（3）<span class="kdocs-color" style="color:#C21C13;">protected为受保护权限，Scala中受保护权限比Java中更严格，同类、子类可以访问，同包无法访问。</span></p> 
 <p style="">（4）<span class="kdocs-color" style="color:#C21C13;">private[包名]增加包访问权限，包名下的其他类也可以使用</span></p> 
 <h4 style="">6.3.3 创建对象</h4> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <p style="">val | var 对象名 [：类型] = new类型()</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <p style="">（1）val修饰对象，不能改变对象的引用（即：内存地址），可以改变对象属性的值。</p> 
 <p style="">（2）var修饰对象，可以修改对象的引用和修改对象的属性值</p> 
 <p style="">（3）自动推导变量类型不能多态，所以多态需要显示声明</p> 
 <pre class="kdocs-scala"><code class="language-scala">class Person05 {
    var name: String = "taotao"
}

object Person05 {
    def main(args: Array[String]): Unit = {
//    val 修饰对象，不能改变对象的引用（即内存地址），可以改变对象属性的值。
        val person = new Person05()
        person.name = "bingbing"
    }
}</code></pre> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">6.3.4 构造器</span></h4> 
 <p style="text-align:null;">和Java一样，Scala构造对象也需要调用构造方法，并且可以有任意多个构造方法。</p> 
 <p style="text-align:null;">Scala类的构造器包括：<span class="kdocs-bold" style="font-weight:bold;">主构造器和辅助构造器</span></p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <blockquote class="kdocs-blockquote" style="">
   class 类名 
  <span class="kdocs-bold" style="font-weight:bold;">(形参列表)</span>{ / 
  <span class="kdocs-bold" style="font-weight:bold;">/主构造器</span> 
  <br> // 类体 
  <br> def 
  <span class="kdocs-color" style="color:#C21C13;"> this</span>(形参列表){ // 辅助构造器 
  <br> 
  <br> } 
  <br> def 
  <span class="kdocs-color" style="color:#C21C13;">this</span>(形参列表){ // 辅助构造器可以有多个。。。 
  <br> 
  <br> } 
  <br>} 
 </blockquote> 
 <p style="text-align:null;">说明：</p> 
 <p style="text-align:null;">（1）辅助构造器，函数的名称this，可以有多个，编译器通过参数的个数及类型来区分。</p> 
 <p style="text-align:null;">（2）辅助构造方法不能直接构建对象，必须直接或者间接调用主构造方法。</p> 
 <p style="text-align:null;">（3）<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">构造器调用其他另外的构造器，要求被调用构造器必须提前声明</span></span></p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">// 定义一个类
class Student{
    // 定义属性
    var name: String = _
    var age: Int = _
    println("1. 主构造方法被调用")
    
    // 声明辅助构造方法
    def this(name: String){
        this()    // 直接调用主构造器
        println("2. 辅助构造方法一被调用")
        this.name = name
    }

    def this(name: String, age:Int){
        this(name)
        println("3. 辅助构造方法二被调用")
        this.age = age
    }
}</code></pre> 
 <h4 style="">6.3.5 构造器参数</h4> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）说明</span></p> 
 <p style="">Scala类的主构造器函数的形参包括三种类型：未用任何修饰、var修饰、val修饰</p> 
 <p style="">（1）未用任何修饰符修饰，这个参数就是一个局部变量</p> 
 <p style="">（2）var修饰参数，作为类的成员属性使用，可以修改</p> 
 <p style="">（3）val修饰参数，作为类只读属性使用，不能修改</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">// 定义类
// 无参构造器
class Student{
    // 单独定义属性
    var name : String = _
    var age : Int = _
}

// 上面等价于：
class Student(var name: String, var age: Int)

val stu = new Student("bob",20)</code></pre> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">6.4 继承</span></h3> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <blockquote class="kdocs-blockquote" style=""> 
  <span class="kdocs-color" style="color:#0E52D4;"><span class="kdocs-bold" style="font-weight:bold;">class</span> <span class="kdocs-bold" style="font-weight:bold;">子类名 </span> <span class="kdocs-bold" style="font-weight:bold;">extends</span> <span class="kdocs-bold" style="font-weight:bold;">父类名</span> <span class="kdocs-bold" style="font-weight:bold;">{ </span> <span class="kdocs-bold" style="font-weight:bold;">类体</span> <span class="kdocs-bold" style="font-weight:bold;">}</span></span> 
 </blockquote> 
 <p style="text-align:null;">（1）子类继承父类的<span class="kdocs-bold" style="font-weight:bold;">属性</span>和<span class="kdocs-bold" style="font-weight:bold;">方法</span></p> 
 <p style="text-align:null;">（2）scala是单继承</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <p style="text-align:null;">（1）子类继承父类的<span class="kdocs-bold" style="font-weight:bold;">属性</span>和<span class="kdocs-bold" style="font-weight:bold;">方法</span></p> 
 <p style="text-align:null;">（2）继承的调用顺序：父类构造器-&gt;子类构造器</p> 
 <h3 style="">6.5 抽象属性和抽象方法abstract</h3> 
 <h4 style="">6.5.1 抽象属性和抽象方法</h4> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <p style="">​ （1）定义抽象类：abstract class Person{} //通过abstract关键字标记抽象类</p> 
 <p style="">​ （2）定义抽象属性：val|var name:String //一个属性没有初始化，就是抽象属性</p> 
 <p style="">​ （3）定义抽象方法：def hello():String //只声明而没有实现的方法，就是抽象方法</p> 
 <pre class="kdocs-scala"><code class="language-scala">abstract class Person09 {
    val name: String  //抽象属性
    def hello(): Unit   //抽象方法
}

class Teacher extends Person09{
    val name:String = "teacher"
    def hello():Unit = {
        println("hello teacher")
    }
}
</code></pre> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">2）继承&amp;重写</span></p> 
 <p style="">（1）如果父类为抽象类，那么子类需要将抽象的属性和方法实现，否则子类也需声明为抽象类</p> 
 <p style="">（2）重写非抽象方法需要用override修饰，重写抽象方法则可以不加override。</p> 
 <p style="">（3）子类中调用父类的方法使用super关键字</p> 
 <p style="">（4）子类对抽象属性进行实现，父类抽象属性可以用var修饰；</p> 
 <p style="text-indent:1.4em;">子类对非抽象属性重写，父类非抽象属性只支持val类型，而不支持var。</p> 
 <p style="text-indent:1.4em;"><span class="kdocs-bold" style="font-weight:bold;">因为var修饰的为可变变量，子类继承之后就可以直接使用，没有必要重写</span></p> 
 <p style="">（5）<span class="kdocs-color" style="color:#0E52D4;"><span class="kdocs-bold" style="font-weight:bold;">Scala中属性和方法都是动态绑定</span></span>，而<span class="kdocs-color" style="color:#0E52D4;"><span class="kdocs-bold" style="font-weight:bold;">Java</span></span>中只有<span class="kdocs-color" style="color:#0E52D4;"><span class="kdocs-bold" style="font-weight:bold;">方法为动态绑定</span></span>。</p> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">6.5.2 匿名子类</span></h4> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）说明</span></p> 
 <p style="text-align:null;">Java一样，可以通过包含带有定义或重写的代码块的方式创建一个匿名的子类。</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">// 定义抽象类
abstract class Persion{
    var name: String
    def eat(): Unit
}

def main(args:Array[String]): Unit = {
    val person:Person = new Persion{
        override var name: String = "candy"
        override def eat(): Unit = println("eat...")
    }
    println(person.name)
    person.eat()
}</code></pre> 
 <h3 style="">6.6 特质（Trait）</h3> 
 <p style="text-indent:1.4em;"><span class="kdocs-color" style="color:#C21C13;">Scala语言中，采用特质trait（特征）来代替接口的概念</span>，也就是说，多个类具有相同的特质（特征）时，就可以将这个特质（特征）独立出来，采用关键字trait声明。</p> 
 <p style="text-indent:1.4em;">Scala中的trait中即可以有抽象属性和方法，也<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">可以有具体的属性和方法，一个类可以混入（mixin）多个特质</span></span>。这种感觉<span class="kdocs-color" style="color:#C21C13;">类似于Java中的抽象类</span>。</p> 
 <p style="text-indent:1.4em;">Scala引入trait特征，第一可以替代Java的接口，第二个也是对单继承机制的一种补充。</p> 
 <h4 style="">6.6.1 特质声明</h4> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">trait 特质名 {
  trait主体
}
</code></pre> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">6.6.2 特质基本语法</span></h4> 
 <p style="text-indent:1.4em;text-align:null;">一个类具有某种特质（特征），就意味着这个类满足了这个特质（特征）的所有要素，所以在使用时，也采用了<span class="kdocs-color" style="color:#C21C13;">extends关键字</span>，如果有多个特质或存在父类，那么需要采用<span class="kdocs-color" style="color:#C21C13;">with关键字</span>连接。</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）基本语法</span></p> 
 <blockquote class="kdocs-blockquote" style=""> 
  <span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">没有父类</span></span>：class 类名 extends 特质1 with 特质2 with 特质3 ... 
  <br> 
  <span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">有父类</span></span>：class 类名 extends 父类 with 特质2 with 特质3 ... 
 </blockquote> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）说明</span></p> 
 <p style="text-align:null;"> （1）类和特质的关系：使用继承的关系。</p> 
 <p style="text-align:null;"> （2）当一个类去继承特质时，第一个连接词是extends，后面是with。</p> 
 <p style="text-align:null;"> （3）如果一个类在同时继承特质和父类时，应当把父类写在extends后。</p> 
 <pre class="kdocs-scala"><code class="language-scala">package org.example

object Person {
  def main(agrs: Array[String]): Unit = {
    val student:Student = new Student
    student.age = 20
    student.say()
    student.study
    student.dating
    student.play
    println(student.age)
  }
}

class Person {
  val name: String = "person"
  var age: Int = 18
  def say(): Unit = {
    println("hello from " + name )
  }
}

// 定义一个特质
trait Young {
  // 声明抽象和非抽象属性
  var age: Int
  val name: String = "young"
  // 声明抽象和非抽象方法
  def play(): Unit = {
    println("young people is playing")
  }
  def dating(): Unit
}

class Student extends Person with Young{
  // 重写冲突的属性
  override val name: String = "student"
  // 实现抽象方法
  def dating(): Unit = println(s"student $name is dating")
  def study(): Unit = println(s"student $name is studing")
  // 重写父类方法
  override def say(): Unit = {
    super.say()
    println(s"hello from: student $name")
  }
}</code></pre> 
 <h4 style="">6.6.3 特质叠加</h4> 
 <p style="text-indent:1.4em;">由于一个类可以混入（mixin）多个trait，且trait中可以有具体的属性和方法，若混入的特质中具有相同的方法（方法名，参数列表，返回值均相同），必然会出现继承冲突问题。冲突分为以下两种：</p> 
 <p style="text-indent:1.4em;">第一种，一个类（Sub）混入的两个trait（TraitA，TraitB）中具有相同的具体方法，且两个trait之间没有任何关系，解决这类冲突问题，直接在类（Sub）中重写冲突方法。</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:155px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:75.48387%;height:0;"> 
    <img src="https://images2.imgbox.com/aa/1e/wP2uJ3GL_o.png" style="margin-left:;display:block;width:155px;margin-top:-75.48387%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style="text-indent:1.4em;">第二种，一个类（Sub）混入的两个trait（TraitA，TraitB）中具有相同的具体方法，且两个trait继承自相同的trait（TraitC），及所谓的“钻石问题”，解决这类冲突问题，Scala采用了<span class="kdocs-bold" style="font-weight:bold;">特质叠加</span>（<span class="kdocs-color" style="color:#0E52D4;"><span class="kdocs-bold" style="font-weight:bold;">从右到左</span></span>）的策略。</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:133px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:133.83458%;height:0;"> 
    <img src="https://images2.imgbox.com/be/3c/hDQMybCN_o.png" style="margin-left:;display:block;width:133px;margin-top:-133.83458%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">所谓的<span class="kdocs-bold" style="font-weight:bold;">特质叠加</span>，就是将混入的多个trait中的冲突方法叠加起来，案例如下，</p> 
 <pre class="kdocs-scala"><code class="language-scala">object Test14_Trait {
  def main(args: Array[String]): Unit = {
    val myBall = new MyBall()
    println(myBall.describe()) //yellow-foot-ball
  }
}

//定义一个父特征
trait Ball {
  def describe(): String = "ball"
}

//定义子特征
trait Color extends Ball {
  var color: String = "yellow"

  override def describe(): String = color + "-" + super.describe()
}

trait Category extends Ball {
  var category: String = "foot"

  override def describe(): String = category + "-" + super.describe()
}

//定义子类，继承两种特征
class MyBall extends Category with Color {
  override def describe(): String = "my ball is a" + super.describe()
}
</code></pre> 
 <p style="text-align:null;">结果如下：</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:303px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:6.930693%;height:0;"> 
    <img src="https://images2.imgbox.com/07/18/lByyYyEq_o.png" style="margin-left:;display:block;width:303px;margin-top:-6.930693%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <h4 style="">6.6.4 特质叠加执行顺序（从右到左按顺序叠加）</h4> 
 <p style="text-indent:1.4em;">当一个类混入多个特质的时候，scala会对所有的特质及其父特质按照一定的顺序进行排序，而此案例中的<span class="kdocs-color" style="background-color:#F7C7D3;color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">super.describe()调用的实际上是排好序后的下一个特质中的describe()方法</span></span>。，排序规则如下：</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:56.62162%;height:0;"> 
    <img src="https://images2.imgbox.com/c0/8a/EKqCgPax_o.png" style="margin-left:;display:block;width:740px;margin-top:-56.62162%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">6.6.5特质和抽象类的区别</span></h4> 
 <p style="text-align:null;">1）<span class="kdocs-color" style="color:#0E52D4;"><span class="kdocs-bold" style="font-weight:bold;">优先使用特质</span></span>。一个类扩展多个特质是很方便的，但却只能扩展一个抽象类。</p> 
 <p style="text-align:null;">2）如果你需要构造函数参数，使用抽象类。因为抽象类可以定义<span class="kdocs-bold" style="font-weight:bold;">带参数</span>的构造函数，而特质不行（有无参构造）。</p> 
 <h4 style="">6.6.6 动态混入特质</h4> 
 <p style="">在Java中，当一个类定义之后，没有继承的接口不可以实现。而在sacla中，可以动态混入特质，如下：</p> 
 <pre class="kdocs-scala"><code class="language-scala">// 1. 父类-抽象类
abstract class Car {
  def brand:String
  def engine:String
  def laba():Unit = {
    println("鸣笛")
  }
}

// 2. 定义子类，继承Car父类，实现父类抽象方法
class LingYun extends Car{
  override def brand: String = {
    println("凌云")
    "凌云骑车"
  }
  override def engine: String = {
    println("纯电动汽车")
    "电动车"
  }
}

// 3. 定义特质
trait Balance {
  def balance:String
}
trait FlyAndSea {
  def fly={
    println("冲上云霄")
  }
  def downSea():Unit
}

// 4. 实例化对象
object TestCar{
  def main(args: Array[String]): Unit = {

    // 动态混入特性，{ 花括号内重写方法 }
    val lingyun:LingYun with Balance with FlyAndSea = 
        new LingYun with Balance with FlyAndSea{
      override def balance: String = { 
        println("空气悬挂")
        "空气悬挂" 
      }
      override def downSea(): Unit = { println("下还") }
    }

  }
}</code></pre> 
 <p style=""></p> 
 <h2 style="">七、模式匹配match</h2> 
 <p style="">Scala中的模式匹配<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">类似于Java中的switch语法</span></span><span class="kdocs-color" style="color:#080F17;">，但scala从语法中补充了更多的功能。</span></p> 
 <h3 style="">7.1 基本语法</h3> 
 <p style="">模式匹配语法中，采用<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">match关键字</span></span>声明，每个分支采用case关键字进行声明，当需要匹配时，会从第一个case分支开始，如果匹配成功，那么执行对应的逻辑代码，如果匹配不成功，继续执行下一个分支进行判断。如果所有case都不匹配，那么会执行<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">case _</span></span>分支，类似于Java中default语句。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）说明</span></p> 
 <p style="">（1）如果所有case都不匹配，那么会执行case _ 分支，类似于Java中default语句，若此时没有case _ 分支，那么会抛出MatchError。</p> 
 <p style="">（2）每个case中，不需要使用break语句，自动中断case。</p> 
 <p style="">（3）match case语句可以匹配任何类型，而不只是字面量。</p> 
 <p style="">（4）=&gt; 后面的代码块，直到下一个case语句之前的代码是<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">作为一个整体执行</span></span>，可以使用{}括起来，也可以不括。</p> 
 <pre class="kdocs-scala"><code class="language-scala">// 模式匹配
  def match1(x:Int):String={
    x match {
      case 1 =&gt; "one"
      case 2 =&gt; "two"
      case _ =&gt; "many"
    }
  }

  println("match1=&gt;"+match1(1))    // match1 =&gt; one</code></pre> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">2）案例实操：</span>用匹配模式实现简单的二元运算</p> 
 <pre class="kdocs-scala"><code class="language-scala">  def matchs(a:Int,b:Int)(op:Char):Int = {
    op match{
      case '+' =&gt; a+b
      case '-' =&gt; a-b
      case '*' =&gt; a*b
      case '/' =&gt; a/b
      case _   -&gt; -1
    } 
  }
  println(matchs(3,2)('*'))</code></pre> 
 <h3 style="">7.2 模式守卫</h3> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）说明</span></p> 
 <p style="text-align:null;">如果想要表达匹配某个范围的数据，就需要在模式匹配中增加条件守卫。</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span>：</p> 
 <pre class="kdocs-scala"><code class="language-scala">// "A" 优秀 "B"良好 "C"合格 "D"不合格  "韩梅梅" 特殊学生
  def match4(name:String,score:String):Unit={
    score match {

      case "A" =&gt; println(name + "优秀")
      case "B" =&gt; println(name + "良好")
      case "C" =&gt; println(name + "合格")
      case _ if name=="韩梅梅" =&gt; println("特殊学生")
      case _ =&gt; println(name + "不合格")
    }
  }</code></pre> 
 <h3 style="">7.3 模式匹配类型</h3> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">7.3.1 匹配常量</span></h4> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）说明</span></p> 
 <p style="text-align:null;">Scala中，模式匹配可以匹配所有的字面量，包括字符串，字符，数字，布尔值等等。</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）实操</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">  def defcribeConst(x:Any):String=x match {
    case 1 =&gt; "Int one"
    case "hello" =&gt; "String hello"
    case true =&gt; "Boolean true"
    case '+' =&gt; "Char +"
    case _ =&gt; "else"                // _ 下划线为占位符，也可以换成其他符号
  }
  println(defcribeConst(2.3))</code></pre> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">7.3.2 匹配类型</span></h4> 
 <p style="">注意：</p> 
 <p style="">（1）我们在底层操作的时候，JVM有“<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">泛型擦除</span></span>”，判断底层类型的时候，只能判断出是一个List类型，而<span class="kdocs-bold" style="font-weight:bold;">List里面的泛型会被擦除</span>。所以不管List里面的泛型是Int还是String，都是List，所以能够直接匹配成功。但<span class="kdocs-bold" style="font-weight:bold;">Array没有泛型擦除</span>。</p> 
 <p style="text-align:left;">（2）_表示占位符，当数组中有多个元素时，用 <span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">_*</span></span> 表示多个元素的占位符</p> 
 <pre class="kdocs-scala"><code class="language-scala">  def defcribeType(x:Any):String=x match {
    case i:Int =&gt; "Int " + i
    case s:String =&gt; "String "+s
    case list:List[String] =&gt; "List "+list.mkString("-")
    case _ =&gt; "something else"
  }
  println(defcribeType(List(1,3,2,4)))    // List 1-3-2-4
  println(defcribeType(2.3))               // something else</code></pre> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">7.3.3 匹配数组</span></h4> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）说明</span></p> 
 <p style="text-align:null;"> scala模式匹配可以对集合进行精确的匹配，例如匹配只有两个元素的、且第一个元素为0的数组。</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">  def match5(arr:Array[String]):Unit={
    arr match {
      case Array("jack") =&gt; println("hello jack")
      case Array(str1,str2) =&gt; println(str1,str2)
      case Array("aaa",_*) =&gt; println("多元素数组")
      case Array(s1,s2,"nancy",_*) =&gt; println("第三个元素是nancy的数组")
      case Array(_,_,"bob",_*) =&gt; println("第三个元素是bob的数组",arr.mkString("-"))
      case _ =&gt; println("who are u")
    }
  }</code></pre> 
 <h4 style="">7.3.4 匹配列表</h4> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）说明</span></p> 
 <p style="">匹配列表与匹配数组类似。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">  def defcribeList(list:List[String]) = {
    list match {
      case List("1") =&gt; println(1)
      case List("acdc",_) =&gt;println("acdc开头的list")
      case List(l1,l2) =&gt; println(l1+","+l2)
      case _ =&gt; println("其他")
    }
  }
  defcribeList(List("acdb","1"))        // acdc开头的list</code></pre> 
 <h4 style="">7.3.5 匹配对象、样例类case</h4> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）匹配对象的方式</span></p> 
 <p style="">（1）定义类</p> 
 <p style="">（2）定义伴生对象</p> 
 <p style="">（3）实现apply方法、实现unapply方法，用来对对象属性进行拆解</p> 
 <p style="">上面这种方法尽管实现了匹配对象的功能，但是过于复杂。于是引入了<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">样例类 case</span></span>的概念。</p> 
 <p style="">样例类的定义只需要在类的前面加<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">关键字case</span></span><span class="kdocs-color" style="color:#080F17;">。默认定义了伴生对象，并实现了apply、unapply方法</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">object FunctionDemo {
  // 定义样例类
  case class Teacher(name:String, age:Int)

  def match(teacher:Teacher):Unit={
    teacher match {
      case Teacher("gree", 39) =&gt; println("hello gree teacher")
      case Teacher("burlin", 18) =&gt; println("hello burlin")
      case Teacher(name, age) if name=="李伟" =&gt; println("大神")
      case x:Teacher =&gt; println("hello "+x.name)
    }
  }

  match3(Teacher("gree",39))    // hello gree teacher
  match3(Teacher("gree",40))    // hello gree，age不符合
}</code></pre> 
 <h2 style="">八、隐式转换</h2> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:15pt;"><span class="kdocs-color" style="background-color:#FBF5B3;color:#0E52D4;"><span class="kdocs-bold" style="font-weight:bold;">当编译器第一次编译失败的时候，会在当前的环境中查找能让代码编译通过的方法，用于将类型进行转换，实现二次编译。</span></span></span></p> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">8.1 隐式函数</span></h3> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）说明</span></p> 
 <p style="text-align:null;">scala一切皆对象，通过toXxx的方法进行类型转换。但是当对象数量较多的时候，挨个调用方法进行转换，会大量增加代码量。于是引入了隐式转换的概念。</p> 
 <p style="text-align:null;"><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;"> 隐式转换</span></span>可以在<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">不需改任何代码</span></span>的情况下，扩展某个类的功能。</p> 
 <pre class="kdocs-scala"><code class="language-scala">// 当传入参数和输出参数不匹配时，运行时会报错
val a:Int = "1"
val s:String = 10

// scala一切皆对象，通过toInt方法进行转换。
val a:Int = "1".toInt
val s:String = 10.toString</code></pre> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <p style="text-align:null;"> 需求：通过隐式转化为Int类型增加方法。</p> 
 <pre class="kdocs-scala"><code class="language-scala">// 使用implicit关键字声明的函数称之为隐式函数
// 当想调用对象功能时，如果编译错误，那么编译器会尝试在当前作用域范围内查找能调用相应功能的转换规则
// 这个调用过程是由编译器完成的，所以称之为隐式转换，也叫自动转换
implicit def stringToInt(value:String):Int=Integer.parseInt(value)
implicit def intToString(value:Int):String=value.toString

val a:Int = "1"
val s:String = 10</code></pre> 
 <h3 style="">8.2 隐式参数</h3> 
 <p style="">普通方法或者函数中的参数可以通过<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">implicit关键字</span></span>声明为隐式参数，调用该方法时，就可以传入该参数，编译器会在相应的作用域寻找符合条件的隐式值。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）说明</span></p> 
 <p style="">（1）同一个作用域中，相同类型的隐式值只能有一个</p> 
 <p style="">（2）编译器按照<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">隐式参数的类型</span></span>去寻找对应类型的隐式值，<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">与隐式值的名称无关</span></span>。</p> 
 <p style="">（3）隐式参数优先于默认参数</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">// 定义sum函数
  def sum(a:Int)(b:Int,name:String):Int={
    println(name)
    a + b
  }
  println(sum(10)(20,"张三"))

// 定义隐式参数
  implicit val num1:Int = 11        // 与参数名无关，与类型有关
  implicit val name:String = "张三"

  def sum2(a:Int)(implicit name:String, b:Int):Int={
    println("sum2="+name)
    a + b
  }
  println(sum2(10))               // sum2=张三，21
// 对隐式参数重新赋值
  println(sum2(10)("李四",13))    // sum2=李四，23</code></pre> 
 <h4 style="">8.2.3 优先级比较</h4> 
 <p style=""><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">方法传值 &gt;&gt; 隐式传值 &gt;&gt; 默认值</span></span></p> 
 <pre class="kdocs-scala"><code class="language-scala">// 1. 隐式值
  implicit val num1:Int = 11
  implicit val name:String = "张三"

// 2. 方法传值 &gt; 隐式值
  def sum(a:Int)(b:Int,name:String):Int={
    println(name)
    a + b
  }
  println(sum(10)("李四",13))        // sum2=李四,23

// 3.默认值 &lt; 隐式值
  def sum2(a:Int)(implicit name:String="赵六",b:Int=5):Int={
    println("sum3="+name)
    a + b
  }
  println(sum2(10))                // sum3=张三,21

// 4.当调用方法，但不进行传参。使用默认值，隐式失效
  def sum3(a:Int)(implicit name:String="赵六",b:Int=5):Int={
    println("sum3="+name)
    a + b
  }
  println(sum3(10)())            // sum3=赵六,15</code></pre> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">应用：</span></p> 
 <p style="text-indent:1.4em;">如下代码，输入的类型为Double，输出类型为String，会调用隐式函数，完成+500的操作。<span class="kdocs-color" style="color:#0E52D4;"><span class="kdocs-bold" style="font-weight:bold;">和输入输出的类型有关</span></span>。</p> 
 <pre class="kdocs-scala"><code class="language-scala">// 传入一个double的数，+500后以String类型输出
implicit def doubleFun(value:Double):String={(value+500).toString}
val d:String = 23.0
println(d)                // 输出523.0</code></pre> 
 <h3 style="">8.3 隐式类</h3> 
 <p style="">在Scala2.10后提供了隐式类，可以使用<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">implicit</span></span>声明类，隐式类的非常强大，同样可以扩展类的功能，在集合中隐式类会发挥重要的作用。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1）隐式类说明</span></p> 
 <p style="">（1）其所带的<span class="kdocs-color" style="color:#0E52D4;"><span class="kdocs-bold" style="font-weight:bold;">构造参数有且只能有一个</span></span></p> 
 <p style="">（2）<span class="kdocs-color" style="color:#0E52D4;"><span class="kdocs-bold" style="font-weight:bold;">隐式类必须被定义在“类”或“伴生对象”或“包对象”里</span></span>，即隐式类不能是顶级的。</p> 
 <pre class="kdocs-scala"><code class="language-scala">Object Test_Implicit {
  def main(args: Array[String]):Unit = {

// 需要比较两数大小的时候new一个函数。
// 缺点：不通用，每来一个整数都需要new一个对象
    val newInt = new MyInt(12)
    println(newInt.myMas(15))
  }
}

// 自定义类
class MyInt(val self: Int) {
  // 自定义比较大小方法
  def myMax(n:Int):Int = if(n &lt; self) self else n
  def myMin(n:Int):Int = if(n &gt; self) self else n
}</code></pre> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">2）案例实操</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">Object Test_Implicit {

  // 1. 隐式类
  implicit class MyInt2(val self: Int){
    // 自定义比较大小方法
    def myMax(n:Int):Int = if(n &lt; self) self else n
    def myMin(n:Int):Int = if(n &gt; self) self else n
  }
  println(12,myMax(15))
}</code></pre> 
 <h2 style="">九、泛型</h2> 
 <h3 style="">9.1 <span class="kdocs-bold" style="font-weight:bold;">协变和逆变</span></h3> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）语法</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">class MyList[ +T ]{ //协变 } 
class MyList[ -T ]{ //逆变 }
class MyList[ T ] //不变</code></pre> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">2）说明</span></p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">协变</span>：Son是Father的<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">子类</span></span>，则MyList[Son] 也作为MyList[Father]的<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">“子类”</span></span>。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">逆变</span>：Son是Father的<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">子类</span></span>，则MyList[Son]作为MyList[Father]的<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">“父类”</span></span>。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">不变</span>：Son是Father的<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">子类</span></span>，则MyList[Father]与MyList[Son]<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">“无父子关系</span></span>”。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">3）实操</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">object Test_Generics {
  def main(args: Array[String]): Unit = {
    // 1. 协变和逆变
    val child: Child = new Child
    val childList:MyCollection1[Parent] = new MyCollection1[Child]
    val childList:MyCollection1[SubChild] = new MyCollection1[Child]

    // 2. 上下限
    def test[A &lt;: Child](a: A):Unit = {
      println(a.getClass.getName)
    }
    test[Parent](new Child)    // 报错
    test[Child](new Child)     // Child
    test[Child](new SubChild)  // SubChild
  }
}

// 定义继承关系
class Parent {}
class Child extends Child {}
class SubChild extends Child {}

// 定义带泛型的集合类型
class MyCollection1[+E] {}
class MyCollection1[-E] {}</code></pre> 
 <h3 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">9.2 泛型上下限</span></h3> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1）语法</span></p> 
 <pre class="kdocs-scala"><code class="language-scala">Class PersonList[T &lt;: Person]{ //泛型上限 }

Class PersonList[T &gt;: Person]{ //泛型下限 }</code></pre> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2）说明</span></p> 
 <p style="text-align:null;"> 泛型的上下限的作用是对传入的泛型进行限定。</p> 
 <p style=""></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/767d39602873f69faf0b13ec7592955d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何把自有数据接入GPT大模型？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/58067570d8c8740cf43b69890950f7af/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue3 解决各场景 loading过度 ，避免白屏尴尬！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>