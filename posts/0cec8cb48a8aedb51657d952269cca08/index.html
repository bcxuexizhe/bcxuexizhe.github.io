<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>动态规划的时间复杂度优化 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/0cec8cb48a8aedb51657d952269cca08/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="动态规划的时间复杂度优化">
  <meta property="og:description" content="作者推荐 视频算法专题
本文涉及知识点 动态规划汇总
优化动态规划的时间复杂度，主要有如下几种：
一，不同的状态表示。 比如：n个人，m顶帽子。
第一种方式：dp[i][mask] ,i表示前i个人已经选择帽子，mask 表示 那些帽子已经选择。 空间复杂度：O(n2m)。
第二种方式：dp[i][mask] ,i表示前i个帽子已经选择，mask表示那些人已经选择。 空间复杂度：O(m22)。
n大，则现在方式一；否则选择方式二。
【状态压缩】【动态规划】【C&#43;&#43;算法】1125.最小的必要团队
二，通过优化状态减少状态数 例一 【动态规划】【C&#43;&#43;算法】2518. 好分区的数目
num的长度 ∈ \in ∈[1,1000],num[i] ∈ \in ∈[0,106] k ∈ \in ∈[0,1000]。
将num的元素放到两个数组中，两个数组的和都为k。
由于num[i] &gt;=0，所以 数组和已经大于k 的无论如何都不会等于k，抛弃。
dp[k1][k2] 的状态数是固定。
当处理完 n u m [ 0 , i ) 时 , 两个数组的和是固定 ⟺ k 1 &#43; k 2 ≡ ∑ j : 0 i − 1 n u m s [ j ] 当处理完num[0,i)时,两个数组的和是固定 \iff k1&#43;k2 \equiv \sum\Large_{j:0}^{i-1} nums[j] 当处理完num[0,i)时,两个数组的和是固定⟺k1&#43;k2≡∑j:0i−1​nums[j]">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-27T19:19:07+08:00">
    <meta property="article:modified_time" content="2024-03-27T19:19:07+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">动态规划的时间复杂度优化</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>作者推荐</h2> 
<p><a href="https://blog.csdn.net/he_zhidan/category_12541620.html">视频算法专题</a></p> 
<h2><a id="_2"></a>本文涉及知识点</h2> 
<p><a href="https://blog.csdn.net/he_zhidan/article/details/135704784">动态规划汇总</a></p> 
<p>优化动态规划的时间复杂度，主要有如下几种：</p> 
<h2><a id="_7"></a>一，不同的状态表示。</h2> 
<p>比如：n个人，m顶帽子。<br> 第一种方式：dp[i][mask] ,i表示前i个人已经选择帽子，mask 表示 那些帽子已经选择。 空间复杂度：O(n2<sup>m</sup>)。<br> 第二种方式：dp[i][mask] ,i表示前i个帽子已经选择，mask表示那些人已经选择。 空间复杂度：O(m2<sup>2</sup>)。<br> n大，则现在方式一；否则选择方式二。</p> 
<p><a href="https://blog.csdn.net/he_zhidan/article/details/135768289">【状态压缩】【动态规划】【C++算法】1125.最小的必要团队</a></p> 
<h2><a id="_14"></a>二，通过优化状态减少状态数</h2> 
<h3><a id="_15"></a>例一</h3> 
<p><a href="https://blog.csdn.net/he_zhidan/article/details/135977303">【动态规划】【C++算法】2518. 好分区的数目</a><br> num的长度<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ∈ 
        
       
      
        \in 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mrel">∈</span></span></span></span></span>[1,1000],num[i]<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ∈ 
        
       
      
        \in 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mrel">∈</span></span></span></span></span>[0,10<sup>6</sup>] k<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ∈ 
        
       
      
        \in 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mrel">∈</span></span></span></span></span>[0,1000]。<br> 将num的元素放到两个数组中，两个数组的和都为k。<br> 由于num[i] &gt;=0，所以 数组和已经大于k 的无论如何都不会等于k，抛弃。<br> dp[k1][k2] 的状态数是固定。<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          当处理完 
         
        
          n 
         
        
          u 
         
        
          m 
         
        
          [ 
         
        
          0 
         
        
          , 
         
        
          i 
         
        
          ) 
         
        
          时 
         
        
          , 
         
        
          两个数组的和是固定 
           
        
          ⟺ 
           
        
          k 
         
        
          1 
         
        
          + 
         
        
          k 
         
        
          2 
         
        
          ≡ 
         
        
          ∑ 
         
         
          
           
           
           
             j 
            
           
             : 
            
           
             0 
            
           
           
           
             i 
            
           
             − 
            
           
             1 
            
           
          
         
           n 
          
         
           u 
          
         
           m 
          
         
           s 
          
         
           [ 
          
         
           j 
          
         
           ] 
          
         
        
       
         当处理完num[0,i)时,两个数组的和是固定 \iff k1+k2 \equiv \sum\Large_{j:0}^{i-1} nums[j] 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord cjk_fallback">当处理完</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mord cjk_fallback">时</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord cjk_fallback">两个数组的和是固定</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">⟺</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7778em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mord">2</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.8272em; vertical-align: -0.573em;"></span><span class="mop op-symbol large-op" style="position: relative; top: 0em;">∑</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord sizing reset-size6 size8"><span class=""></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.871em;"><span class="" style="top: -2.7371em; margin-right: 0.0347em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size8 size6 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span><span class="mrel mtight">:</span><span class="mord mtight">0</span></span></span></span><span class="" style="top: -3.413em; margin-right: 0.0347em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size8 size6 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3979em;"><span class=""></span></span></span></span></span></span><span class="mord mathnormal sizing reset-size6 size8">n</span><span class="mord mathnormal sizing reset-size6 size8">u</span><span class="mord mathnormal sizing reset-size6 size8">m</span><span class="mord mathnormal sizing reset-size6 size8">s</span><span class="mopen sizing reset-size6 size8">[</span><span class="mord mathnormal sizing reset-size6 size8" style="margin-right: 0.0572em;">j</span><span class="mclose sizing reset-size6 size8">]</span></span></span></span></span></span><br> 我记录k1或k2就可以了。新问题是k1 可能是5e8。<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          { 
         
         
          
           
            
             
             
               k 
              
             
               1 
              
             
            
           
           
            
             
             
               k 
              
             
               1 
              
             
               &lt; 
              
             
               k 
              
             
            
           
          
          
           
            
             
             
               − 
              
             
               m 
              
             
               i 
              
             
               n 
              
             
               ( 
              
             
               k 
              
             
               2 
              
             
               , 
              
             
               k 
              
             
               ) 
              
             
            
           
           
            
             
             
               e 
              
             
               l 
              
             
               s 
              
             
               e 
              
             
            
           
          
         
        
       
         \begin{cases} k1 &amp; k1 &lt;k \\ -min(k2,k) &amp; else \\ \end{cases} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 3em; vertical-align: -1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size4">{<!-- --></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.69em;"><span class="" style="top: -3.69em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mord">1</span></span></span><span class="" style="top: -2.25em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathnormal">min</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.19em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.69em;"><span class="" style="top: -3.69em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span><span class="" style="top: -2.25em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">se</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.19em;"><span class=""></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p> 
<h3><a id="_27"></a>例子二</h3> 
<p><a href="https://blog.csdn.net/he_zhidan/article/details/135987925">2742. 给墙壁刷油漆</a><br> 付费工人，各任务用时time[i]，免费工人用时1，time.length<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ∈ 
        
       
      
        \in 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mrel">∈</span></span></span></span></span>[1,500]。付费工人用时和必须大于等于免费工人用时。如果分别记录付费工人和免费工人用时，则状态数：500*500。<br> 付费工人用时和必须大于等于免费工人 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
      
           
       
         ⟺ 
          
       
      
        \iff 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.549em; vertical-align: -0.024em;"></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">⟺</span><span class="mspace" style="margin-right: 0.2778em;"></span></span></span></span></span> (statu = 付费工人用时 - 免费工人用时) &gt;= 0<br> statu <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ∈ 
        
       
      
        \in 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mrel">∈</span></span></span></span></span> [-500,500] 可以记录状态的时候+500，解析状态的时候再-500。</p> 
<h2><a id="__33"></a>三 通过优化转移方程</h2> 
<p>转移方程主要有两种：<br> a，枚举前置状态，更新后置状态。除剪枝小幅提升性能外，暂时没发现优化方法。<br> b,枚举后置状态，通过前置状态计算后置状态。利用前缀和、极值、优先队列（堆）、单调栈（队列、向量）、预处理 等优化。</p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><a href="https://blog.csdn.net/he_zhidan/article/details/134968820">2617 网格图中最少访问的格子数</a></td><td>两种方法：分别用单调栈、优先队列优化</td></tr><tr><td><a href="https://blog.csdn.net/he_zhidan/article/details/135560044">【动态规划】【滑动窗口】【C++算法】 629K 个逆序对数组</a></td><td>前缀和</td></tr><tr><td><a href="https://blog.csdn.net/he_zhidan/article/details/135857707">【动态规划】【状态压缩】【2次选择】【广度搜索】1494. 并行课程 II</a></td><td>剪枝小幅提升性能</td></tr><tr><td><a href="https://blog.csdn.net/he_zhidan/article/details/135886071">【动态规划】【C++算法】1563 石子游戏 V</a></td><td>极值</td></tr><tr><td><a href="https://blog.csdn.net/he_zhidan/article/details/136598985?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22136598985%22,%22source%22:%22he_zhidan%22%7D">【动态规划】【前缀和】【和式变换】100216. K 个不相交子数组的最大能量值</a></td><td>和氏变换</td></tr><tr><td>多重背包</td><td>前缀和</td></tr></tbody></table> 
<h2><a id="_01_46"></a>四 匹配无限次可以拆分成匹配0次和1次</h2> 
<p>以通配符为例。<br> abc 匹配 *<br> 初始匹配长度0<br> 处理* ：<br> 长度0的后置状态：*不匹配任何字符，匹配长度0。<br> 长度0的后置状态：*匹配一个字符，匹配长度1。<br> 长度1的后置状态：*不匹配任何字符，匹配长度1。<br> 长度1的后置状态：*匹配一个字符，匹配长度2。<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
        
        
          ⋮ 
         
         
          
         
        
       
      
        \quad \quad \vdots 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.53em; vertical-align: -0.03em;"></span><span class="mspace" style="margin-right: 1em;"></span><span class="mspace" style="margin-right: 1em;"></span><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width: 0em; border-top-width: 1.5em; bottom: 0em;"></span></span></span></span></span></span><br> <strong>总计</strong>： *可以匹配0到<strong>无限</strong>字符，才可以这样处理。 .只能匹配一个字符不能这样处理。</p> 
<p><a href="https://blog.csdn.net/he_zhidan/article/details/135313078">【动态规划】【字符串】C++算法：正则表达式匹配</a></p> 
<p><a href="https://blog.csdn.net/he_zhidan/article/details/135607317">【状态压缩】【动态规划】【C++算法】691贴纸拼词</a><br> <a href="https://blog.csdn.net/he_zhidan/article/details/135841180">【动态规划】【数学】【C++算法】1449. 数位成本和为目标值的最大数字</a><br> <a href="https://blog.csdn.net/he_zhidan/article/details/135960433">【动态规划】【C++算法】2188. 完成比赛的最少时间</a><br> 无限背包</p> 
<h2><a id="__65"></a>五 逆向思考</h2> 
<p><a href="https://blog.csdn.net/he_zhidan/article/details/135406333">【动态规划】【 矩阵】【逆向思考】C++算法174地下城游戏</a><br> 正向思考：要记录进入(r,c)后的健康，还有记录初始健康。比如：路径一： 3 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         → 
        
       
      
        \rightarrow 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.3669em;"></span><span class="mrel">→</span></span></span></span></span> -2 ，初始只需要1，最终健康2。<br> 路径二： -1 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         → 
        
       
      
        \rightarrow 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.3669em;"></span><span class="mrel">→</span></span></span></span></span> 4 ，初始要求 2，最终健康度 5。如果终点格是-1,前者能过。 如果是-4，后者能过。前者需要4，才能过。<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          { 
         
         
          
           
            
             
             
               路径一初始 
              
             
               1 
              
             
               ，路径二初始 
              
             
               2 
              
             
            
           
           
            
             
             
               终点 
              
             
               &lt; 
              
             
               − 
              
             
               1 
              
             
            
           
          
          
           
            
             
             
               路径一初始 
              
             
               4 
              
             
               ，路径二初始 
              
             
               2 
              
             
            
           
           
            
             
             
               终点 
              
             
               − 
              
             
               4 
              
             
            
           
          
         
        
       
         \begin{cases} 路径一初始1，路径二初始2 &amp; 终点&lt; -1 \\ 路径一初始4，路径二初始2 &amp; 终点-4 \\ \end{cases} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 3em; vertical-align: -1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size4">{<!-- --></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.69em;"><span class="" style="top: -3.69em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord cjk_fallback">路径一初始</span><span class="mord">1</span><span class="mord cjk_fallback">，路径二初始</span><span class="mord">2</span></span></span><span class="" style="top: -2.25em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord cjk_fallback">路径一初始</span><span class="mord">4</span><span class="mord cjk_fallback">，路径二初始</span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.19em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.69em;"><span class="" style="top: -3.69em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord cjk_fallback">终点</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mord">−</span><span class="mord">1</span></span></span><span class="" style="top: -2.25em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord cjk_fallback">终点</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.19em;"><span class=""></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p> 
<p><a href="https://blog.csdn.net/he_zhidan/article/details/135621347">【动态规划】【C++算法】741摘樱桃</a></p> 
<h2><a id="__76"></a>六 去掉重复</h2> 
<p><a href="https://blog.csdn.net/he_zhidan/article/details/135435982">【动态规划】C++算法：403.青蛙过河</a></p> 
<p>七，待整理<br> <a href="https://blog.csdn.net/he_zhidan/article/details/137086622">【状态机dp】【 排序 2809】 使数组和小于等于 x 的最少时间</a> 估计4月下旬和观众见面</p> 
<p><img src="https://images2.imgbox.com/ae/44/k9a6cI6j_o.gif" alt=""></p> 
<h2><a id="_86"></a>扩展阅读</h2> 
<h4><a id="_88"></a>视频课程</h4> 
<p>有效学习：明确的目标 及时的反馈 拉伸区（难度合适），可以先学简单的课程，请移步CSDN学院，听白银讲师（也就是鄙人）的讲解。<br> <a href="https://edu.csdn.net/course/detail/38771">https://edu.csdn.net/course/detail/38771</a></p> 
<p>如何你想快速形成战斗了，为老板分忧，请学习C#入职培训、C++入职培训等课程<br> <a href="https://edu.csdn.net/lecturer/6176">https://edu.csdn.net/lecturer/6176</a></p> 
<h4><a id="_96"></a>相关</h4> 
<p>下载</p> 
<p>想高屋建瓴的学习算法，请下载《喜缺全书算法册》doc版<br> <a href="https://download.csdn.net/download/he_zhidan/88348653">https://download.csdn.net/download/he_zhidan/88348653</a></p> 
<table><thead><tr><th>我想对大家说的话</th></tr></thead><tbody><tr><td>闻缺陷则喜是一个美好的愿望，早发现问题，早修改问题，给老板节约钱。</td></tr><tr><td>子墨子言之：事无终始，无务多业。也就是我们常说的专业的人做专业的事。</td></tr><tr><td>如果程序是一条龙，那算法就是他的是睛</td></tr></tbody></table> 
<h4><a id="_108"></a>测试环境</h4> 
<p>操作系统：win7 开发环境： VS2019 <strong>C++17</strong><br> 或者 操作系统：win10 开发环境： VS2022 **C+</p> 
<p>+17**<br> 如无特殊说明，本<strong>算法</strong>用**C++**实现。</p> 
<p><img src="https://images2.imgbox.com/e8/49/Fbi611yh_o.gif" alt=""></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/497c912e81e828d38b6581e27f1a91a7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">RedisTemplate.opsForHash()用法简介并举例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f95730ef2038419d27ae023574a791eb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL 8.0 新特性之不可见主键</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>