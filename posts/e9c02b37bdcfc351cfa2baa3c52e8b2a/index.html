<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>指针(6) - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/e9c02b37bdcfc351cfa2baa3c52e8b2a/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="指针(6)">
  <meta property="og:description" content="1. sizeof和strlen的对比 1.1 sizeof 在学习操作符的时候，我们学习了 sizeof ， sizeof 计算变量所占内存内存空间大小的，单位是字节，如果操作数是类型的话，计算的是使⽤类型创建的变量所占内存空间的大小。
sizeof 只关注占用内存空间的大小，不在乎内存中存放什么数据。
sizeof是操作符 不是函数
int main() { int a = 10; printf(&#34;%zd\n&#34;, sizeof(int)); printf(&#34;%zd\n&#34;, sizeof(a)); int arr[10] = { 0 };//里面放了什么数据不会影响 printf(&#34;%zd&#34;, sizeof(arr)); //只关注内存空间大小 } 1.2 strlen strlen库函数,求字符串的长度,只能针对字符串(字符数组)
统计的是从 strlen 函数的参数 str 中这个地址开始向后， \0 之前字符串中字符的个数。strlen 函数会⼀直向后找 \0 字符，直到找到为止，所以可能存在越界查找。
int main() { char arr[] = { &#39;a&#39;,&#39;b&#39;,&#39;c&#39; }; //char 一个字符一个字节 char arr1[] = &#34;abc&#34;; int arr2[] = { 1,2 };//int 一个整形4个字节 //strlen函数 计算数组的元素个数(字符串) printf(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-26T17:44:34+08:00">
    <meta property="article:modified_time" content="2024-05-26T17:44:34+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">指针(6)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1. sizeof和strlen的对比</h2> 
<h3>1.1 sizeof</h3> 
<blockquote> 
 <ul><li> <p>在学习操作符的时候，我们学习了 sizeof ， sizeof 计算变量所占内存内存空间大小的，单位是字节，如果操作数是类型的话，计算的是使⽤类型创建的变量所占内存空间的大小。</p> </li><li> <p>sizeof 只关注占用内存空间的大小，不在乎内存中存放什么数据。</p> </li><li> <p><strong>sizeof是操作符 不是函数</strong></p> </li></ul> 
</blockquote> 
<pre><code class="language-cpp">int main() {
    int a = 10;
    printf("%zd\n", sizeof(int));
    printf("%zd\n", sizeof(a));
    int arr[10] = { 0 };//里面放了什么数据不会影响 
    printf("%zd", sizeof(arr)); //只关注内存空间大小
}</code></pre> 
<h3>1.2 strlen</h3> 
<ul><li> <p>strlen库函数,求字符串的长度,<span style="color:#fe2c24;"><strong>只能针对字符串(字符数组)</strong></span></p> </li><li> <p>统计的是从 strlen 函数的参数 str 中这个地址开始向后， \0 之前字符串中字符的个数。strlen 函数会⼀直向后找 \0 字符，<span style="color:#fe2c24;"><strong>直到找到为止，所以可能存在越界查找</strong></span>。</p> </li></ul> 
<p><img alt="" height="280" src="https://images2.imgbox.com/27/05/6IVW5jRJ_o.png" width="831"></p> 
<pre><code class="language-cpp">int main() {
    char arr[] = { 'a','b','c' }; //char 一个字符一个字节
    char arr1[] = "abc";
    int arr2[] = { 1,2 };//int 一个整形4个字节
    //strlen函数 计算数组的元素个数(字符串)
    printf("%zd\n", strlen(arr));
    printf("%zd\n", strlen(arr1));
    //sizeof 不关注里面存的数据 只关注数组的大小
    printf("%zd\n", sizeof(arr));//3
    printf("%zd\n", sizeof(arr1));//4 把\0也也统计了
    printf("%zd\n", sizeof(arr2));//8
    return 0;
}</code></pre> 
<h3>1.3 sizeof和strlen比较</h3> 
<table><thead><tr><th>sizeof</th><th>strlen</th></tr></thead><tbody><tr><td>1. sizeof是操作符</td><td>1.strlen是库函数，使⽤需要包含头⽂件 string.h</td></tr><tr><td>2. sizeof计算操作数所占内存的大小，单位是字节</td><td>2. srtlen是求字符串⻓度的，统计的是 \0 之前字符的个数</td></tr><tr><td>3.不关注内存中存放什么数据</td><td>3. 关注内存中是否有 \0 ，如果没有 \0 ，就会持续往后找，可能越界</td></tr></tbody></table> 
<h2>2..数组和指针笔试题解析</h2> 
<h3>2.1 ⼀维数组</h3> 
<blockquote> 
 <ul><li> <p>整形的地址, --&gt;<strong>(&amp;a)</strong> 是地址都是<strong>4(x86)/8(x64)</strong></p> </li><li> <p>arr 只有在--&gt;<strong>sizeof(arr)</strong> 和 <strong>&amp;arr</strong>的时候 <strong>不是表示首字元素的地址</strong></p> </li><li> <p><span style="color:#fe2c24;"><strong>sizeof(arr) ---&gt; 整个数组的大小,单位是字节</strong></span></p> </li><li> <p><span style="color:#fe2c24;"><strong>&amp;arr ---&gt; 整个数组的地址 --&gt;&gt; 4 或者8</strong></span></p> </li><li> <p>sizeof(arr+0) 因为他不是 sizeof(arr) 这种形式 所以它代表的是首元素地址 +0 也一样</p> </li></ul> 
</blockquote> 
<pre><code class="language-cpp">int main() {
    int a[] = { 1,2,3,4 };
    printf("%zd\n", sizeof(a));
    printf("%zd\n", sizeof(a + 0));
    printf("%zd\n", sizeof(*a));
    printf("%zd\n", sizeof(a + 1));
    printf("%zd\n", sizeof(a[1]));
    printf("%zd\n", sizeof(&amp;a));//4 或者 8
    printf("%zd\n", sizeof(*&amp;a));//16
    printf("%zd\n", sizeof(&amp;a + 1));//4 或者 8
    printf("%zd\n", sizeof(&amp;a[0]));//4 或者 8
    printf("%zd\n", sizeof(&amp;a[0] + 1));//4 或者 8
}</code></pre> 
<ul><li> <p>看如下解析</p> </li></ul> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/59/9b/upR5gajP_o.png"></p> 
<h3>2.2字符数组</h3> 
<h5>2.2.1代码1</h5> 
<pre><code class="language-cpp">char arr[] = {'a','b','c','d','e','f'};
printf("%d\n", sizeof(arr));//整个数组的大小6个元素 6个字节
printf("%d\n", sizeof(arr+0));//  首元素地址4/8
printf("%d\n", sizeof(*arr));// 首元素大小1
printf("%d\n", sizeof(arr[1]));//首元素大小1
printf("%d\n", sizeof(&amp;arr));//首元素地址 4/8
printf("%d\n", sizeof(&amp;arr+1));//第二个元素地址 4/8
printf("%d\n", sizeof(&amp;arr[0]+1));//第二个元素地址 4/8</code></pre> 
<h5>2.2.2代码2</h5> 
<p><span style="color:#fe2c24;"><strong>字符数组 strlen函数找不到\0 输出随机值</strong></span></p> 
<pre><code class="language-cpp">int main() {
    char arr[] = { 'a','b','c','d','e','f' };
    printf("%zd\n", strlen(arr));
    printf("%zd\n", strlen(arr + 0));
    printf("%zd\n", strlen(*arr));
    printf("%zd\n", strlen(arr[1]));
    printf("%zd\n", strlen(&amp;arr));
    printf("%zd\n", strlen(&amp;arr + 1));
    printf("%zd\n", strlen(&amp;arr[0] + 1));
}</code></pre> 
<h5 style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b3/10/vhksYzip_o.png"></h5> 
<h5>2.2.3代码3</h5> 
<ul><li><span style="color:#fe2c24;">char arr[] = "abcdef";</span></li><li><span style="color:#fe2c24;"><strong>数组中存放的是{a,b,c,d,e,f,\0}</strong></span></li></ul> 
<pre><code class="language-cpp">int main() {
    char arr[] = "abcdef";
    //{ a b c d e f \0}
    printf("%zd\n", sizeof(arr));//7 
    printf("%zd\n", sizeof(arr + 0));//4/8
    printf("%zd\n", sizeof(*arr));//1
    printf("%zd\n", sizeof(arr[1]));//1
    printf("%zd\n", sizeof(&amp;arr));//4或8
    printf("%zd\n", sizeof(&amp;arr + 1));//4或8
    printf("%zd\n", sizeof(&amp;arr[0] + 1));//4或8
    return 0;
​
}</code></pre> 
<h5 style="text-align:center;"><img alt="" src="https://images2.imgbox.com/46/e7/aB4f1ja6_o.png"></h5> 
<h5>2.2.4代码4</h5> 
<blockquote> 
 <ul><li> <p>printf("%d\n", strlen(&amp;arr));</p> <p>&amp;arr 的类型是 char (*) [7]</p> <p>strlen函数接受的类型是 (const char* str) &amp;arr传给strlen的话会进行强制转换,从第一个元素开始数,最后输出也是6</p> </li></ul> 
 <p></p> 
</blockquote> 
<blockquote> 
 <ul><li> <p>printf("%d\n", strlen(&amp;arr + 1));</p> <p>&amp;arr+1 直接跳到数组的最后个元素,从该位置开始往后数,不知道后面有啥元素就返回一个随机</p> </li></ul> 
</blockquote> 
<pre><code class="language-cpp">int main() {
    char arr[] = "abcdef";
    //arr 是首元素地址 strlen从第一个元素往后统计个数 一直到\0
    printf("%d\n", strlen(arr)); //6 
    printf("%d\n", strlen(arr + 0));//6
    //printf("%d\n", strlen(*arr)); 得到一个元素'a' 找97的字符个数,程序报错 
    //printf("%d\n", strlen(arr[1]));'b',程序报错
    printf("%d\n", strlen(&amp;arr));
    printf("%d\n", strlen(&amp;arr + 1));
    printf("%d\n", strlen(&amp;arr[0] + 1));//第二个元素开始数 5
} </code></pre> 
<h5><img alt="" src="https://images2.imgbox.com/7f/c6/JwWwI2ew_o.png"></h5> 
<h5>2.2.5代码5</h5> 
<blockquote> 
 <p><strong>p[0] 等价于 *(p+0)</strong></p> 
</blockquote> 
<pre><code class="language-cpp">int main() {
    char* p = "abcdef";
    printf("%zd\n", sizeof(p));
    printf("%zd\n", sizeof(p + 1));
    printf("%zd\n", sizeof(*p));
    printf("%zd\n", sizeof(p[0]));
    printf("%zd\n", sizeof(&amp;p));
    printf("%zd\n", sizeof(&amp;p + 1));
    printf("%zd\n", sizeof(&amp;p[0] + 1));
}</code></pre> 
<h5 style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3f/78/CDiImT9D_o.png"></h5> 
<h5>2.2.6代码6</h5> 
<blockquote> 
 <ul><li> <p><strong>&amp;p[0] 等价于 &amp; * (p+0) 等价于 p</strong></p> </li><li> <p><strong>所以strlen(&amp;p[0]+1) 输出 5</strong></p> </li></ul> 
</blockquote> 
<pre><code class="language-cpp">char *p = "abcdef";
printf("%d\n", strlen(p));
printf("%d\n", strlen(p+1));
printf("%d\n", strlen(*p));
printf("%d\n", strlen(p[0]));
printf("%d\n", strlen(&amp;p));
printf("%d\n", strlen(&amp;p+1));
printf("%d\n", strlen(&amp;p[0]+1));</code></pre> 
<h3><img alt="" height="915" src="https://images2.imgbox.com/d0/6c/4djSJaNu_o.png" width="1186"></h3> 
<h3 style="background-color:transparent;">2.3二维数组</h3> 
<pre><code class="language-cpp">int a[3][4] = {0};
printf("%d\n",sizeof(a));
printf("%d\n",sizeof(a[0][0]));
printf("%d\n",sizeof(a[0]));
printf("%d\n",sizeof(a[0]+1));
printf("%d\n",sizeof(*(a[0]+1)));
printf("%d\n",sizeof(a+1));
printf("%d\n",sizeof(*(a+1)));
printf("%d\n",sizeof(&amp;a[0]+1));
printf("%d\n",sizeof(*(&amp;a[0]+1)));
printf("%d\n",sizeof(*a));
printf("%d\n",sizeof(a[3]));</code></pre> 
<p><img alt="" src="https://images2.imgbox.com/c2/e5/t1KHoEkU_o.png"><img alt="" src="https://images2.imgbox.com/eb/cb/85O4mrXO_o.png"></p> 
<blockquote> 
 <ul><li> <p>注意:a[3] 数组越界,但是sizeof内部的表达式不会真实计算,只会看它的类型int [4],所以只计算4个整形元素的大小 16个字节</p> </li><li> <p>如果不懂我们在再看看以下列子,他输出的是什么呢?</p> </li><li> <p>答案是4 因为sizeof内部不进行计算,只会看a的类型,a是整形所以是4个字节</p> </li></ul> 
</blockquote> 
<pre><code class="language-cpp">int main() {
    int a = 3;
    int b = 3;
    printf("%zd", sizeof(a = b + 3));
}</code></pre> 
<h2>3.指针运算笔试题解析</h2> 
<h3 style="background-color:transparent;">3.1题目1</h3> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
int main()
{
    int a[5] = { 1, 2, 3, 4, 5 };
    int* ptr = (int*)(&amp;a + 1); //int(*) 强制类型转换
    printf("%d,%d", *(a + 1), *(ptr - 1)); //输出 2 5 
    return 0;
}</code></pre> 
<h3 style="text-align:center;"><img alt="" src="https://images2.imgbox.com/30/0e/624zNlVp_o.png"></h3> 
<h3>3.2题目2</h3> 
<ul><li> <p>注意:</p> <p><span style="color:#fe2c24;">指针加1==&gt;跳过一个指针类型大小</span></p> <p><span style="color:#fe2c24;">整数加1==&gt;那就是加上一个1</span></p> </li></ul> 
<pre><code class="language-cpp">//在X86环境下
//假设结构体的⼤⼩是20个字节
//程序输出的结果是啥？
struct Test
{
	int Num;
	char* pcName;
	short sDate;
	char cha[2];
	short sBa[4];
}*  p = (struct Test*) 0x100000;
int main()
{
	printf("%p\n", p + 0x1);
	printf("%p\n", (unsigned long)p + 0x1);//强制转换成一个整数
	printf("%p\n", (unsigned int*)p + 0x1);//强制转换成整数类型指针
	return 0;
}</code></pre> 
<ul><li><strong><span style="color:#fe2c24;">为了让我们更好的理解以上代码,我们拆分如下</span></strong></li></ul> 
<blockquote> 
 <pre>struct Test
{
    int Num;
    char* pcName;
    short sDate;
    char cha[2];
    short sBa[4];
}*  这个代表的是结构体指针的类型 </pre> 
</blockquote> 
<blockquote> 
 <pre>p是指针变量 </pre> 
</blockquote> 
<blockquote> 
 <pre>(struct Test*) 0x100000
0x100000代表的是一个八进制数,整形  
(struct Test*) 强制类型转换成 结构体指针类型</pre> 
</blockquote> 
<h3>3.3题目3</h3> 
<blockquote> 
 <ul><li> <p>我们是不是觉得他是一个三行两列的二维数组,其实并不是</p> </li><li> <p><span style="color:#fe2c24;"><strong>我们数组赋值时用的是{ },并非( ), ( )代表的是括号表达式,从左向右计算,最终结果取右边的数值 例如(0,1) ==&gt; 1</strong></span></p> </li><li> <p>所以该数组的是 {1 , 3 , 5}</p> </li><li> <p>所以p[0] 输出 1</p> </li></ul> 
</blockquote> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
int main()
{
    int a[3][2] = { (0, 1), (2, 3), (4, 5) };
    int* p;
    p = a[0];
    printf("%d", p[0]);
    return 0;
}</code></pre> 
<h3>3.4题目4</h3> 
<blockquote> 
 <ul><li> <p>地址 ➖ 地址 = 元素个数 小地址减去大地址 取负数</p> </li><li> <p>-4在内存中以补码形式保存</p> </li><li> <p><span style="color:#fe2c24;"><strong>%p 打印16进制的地址,输出就是内存中保存 的-4的补码</strong> ==&gt;FF FF FF FC</span></p> </li><li> <p><span style="color:#fe2c24;"><strong>%d 打印原码 有符号数 -4</strong></span></p> </li></ul> 
</blockquote> 
<pre><code class="language-cpp">//假设环境是x86环境，程序输出的结果是啥？
#include &lt;stdio.h&gt;
int main()
{
 int a[5][5];
 int(*p)[4];
 p = a;
 printf( "%p,%d\n", &amp;p[4][2] - &amp;a[4][2], &amp;p[4][2] - &amp;a[4][2]);
 return 0;
}</code></pre> 
<h3 style="text-align:center;"><img alt="" src="https://images2.imgbox.com/45/ed/tVfqzvQj_o.png"></h3> 
<h3>3.5题目6</h3> 
<ul><li> <p><span style="color:#fe2c24;">(*(aa+1)) 等价于 aa[1] 第一行首元素的地址+1 然后解引用等于 6</span></p> </li></ul> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
int main()
{
 int aa[2][5] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
 int *ptr1 = (int *)(&amp;aa + 1);
 int *ptr2 = (int *)(*(aa + 1));
 printf( "%d,%d", *(ptr1 - 1), *(ptr2 - 1)); //10  5
 return 0;
}</code></pre> 
<h3 style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1b/38/i2cfDzlB_o.png"></h3> 
<h3>3.6题目6</h3> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
int main()
{
 char *a[] = {"work","at","alibaba"};
 char**pa = a;
 pa++;
 printf("%s\n", *pa);
 return 0;
}</code></pre> 
<pre style="text-align:center;"></pre> 
<h3>3.7题目7</h3> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
int main()
{
 char *c[] = {"ENTER","NEW","POINT","FIRST"};
 char**cp[] = {c+3,c+2,c+1,c};
 char***cpp = cp;
 printf("%s\n", **++cpp);
 printf("%s\n", *--*++cpp+3);
 printf("%s\n", *cpp[-2]+3);
 printf("%s\n", cpp[-1][-1]+1);
 return 0;
}</code></pre> 
<ul><li> <p><span style="color:#fe2c24;"><strong>注意</strong>: 一开始 ++cpp 这个运算 cpp自身的值发生改变 后面的结果会受到影响</span></p> </li><li> <p><strong><span style="color:#fe2c24;">第一个输出</span></strong></p> </li></ul> 
<p><img alt="" height="447" src="https://images2.imgbox.com/22/bc/9r8NdpFQ_o.png" width="753"></p> 
<ul><li> <p><span style="color:#fe2c24;"><strong>第二个输出</strong></span></p> </li></ul> 
<p><img alt="" height="388" src="https://images2.imgbox.com/fb/e6/Xyp11DTR_o.png" width="844"></p> 
<ul><li> <p><span style="color:#fe2c24;"><strong>第三个输出</strong></span></p> </li></ul> 
<p><img alt="" height="403" src="https://images2.imgbox.com/04/ec/ajH2oNcG_o.png" width="868"></p> 
<ul><li> <p><strong><span style="color:#fe2c24;">第四个输出</span></strong></p> </li></ul> 
<p><img alt="" height="394" src="https://images2.imgbox.com/f7/47/BZ137R2e_o.png" width="793"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/68cbbcb327ba185f1f899da45535929f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构----第二章线性表1</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2213eb1703155fc0c04794ee4124ea46/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【开源】大学生竞赛管理系统 JAVA&#43;Vue&#43;SpringBoot&#43;MySQL</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>