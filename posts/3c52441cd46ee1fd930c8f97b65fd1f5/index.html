<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java之多态 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/3c52441cd46ee1fd930c8f97b65fd1f5/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Java之多态">
  <meta property="og:description" content="一、多态前言 1.为什么要使用多态 Java中使用多态的主要目的是提高代码的可重用性和扩展性，使得代码更加灵活和易于维护。通过多态，我们可以将不同的对象看做是同一种类型，从而使得我们可以使用同一种接口来操作这些对象，而不必关心具体的实现细节。
2.多态概念 当父类的引用所指向的子类对象引用指向的对象不一样时。调用重写的方法，所表现出来的行为是不一样的，我们把这种思想叫做多态。上面所说的可能大家会觉得有点抽象，看到后面就懂了。
多态的基础是动态绑定，所以要了解多态前提我们还要了解动态绑定。
要想实现动态绑定，需要满足以上几个条件：
1.要发生向上转型
2.要发生重写
3.使用父类对象的引用去调用重写方法
完成了这三部分，就会发生动态绑定，而在这里，出现了重写以及向上转型这些概念。所以我们得先了解它们才能去了解动态绑定。进而了解多态。
二、重写 1.重写的概念 重写 (override) ：也称为覆盖。将父类的方法重新在子类中使用。 返回值和形参都不能改变 。 即外壳不变，核心重写！ 重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。 方法重写的规则：
1.子类在重写父类的方法时，必须与父类方法原型一致：即返回值、方法名、参数列表要完全一致
2.被重写的方法的访问修饰限定符在子类中要大于等于父类的。
3.父类中被static或private或final修饰的方法以及构造方法都不能被重写。 4.在子类中重写的方法, 可以使用 @Override 注解来显式指定. 有了这个注解能帮我们进行一些合法性校验。
2.重写的作用 对于已经投入使用的类，尽量不要进行修改。最好的方式是：重新定义一个新的类，来重复利用其中共性的内容，并且添加或者改动新的内容。 例如：若干年前的手机，只能打电话，发短信，来电显示只能显示号码，而今天的手机在来电显示的时候，不仅仅可以显示号码，还可以显示头像，地区等。在这个过程当中，我们不应该在原来老的类上进行修改，因为原来的 类，可能还在有用户使用 ，正确做法是： 新建一个新手机的类，对来电显示这个方法重写就好了，这样就达到了我 们当今的需求了 。 三、向上转型 向上转型：实际就是创建一个子类对象，将其当成父类对象来使用。
语法格式：父类类型 对象名 = new 子类类型 () Animal animal = Dog ( ); 我们对以上代码进行实质化分析，以上的代码其实是省略化了，见以下代码 Dog dog = new Dog（);
Animal animal = dog;//该代码发生了向上转换，将Dog对象转换为Animal类型
通过向上转型后，就可以父类对象名来访问子类的方法了。使用animal.eat();这语句来访问 这个语句发生了动态绑定（在编译过程中调用的其实是父类的eat，但是在运行时换为调用子类的eat了）故实现了 创建一个子类对象，将其当成父类对象来使用。见以下代码 class Animal {
void sound() {">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-28T11:59:50+08:00">
    <meta property="article:modified_time" content="2024-04-28T11:59:50+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java之多态</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、多态前言</h3> 
<h4>1.为什么要使用多态</h4> 
<p>Java中使用多态的主要目的是提高代码的可重用性和扩展性，使得代码更加灵活和易于维护。通过多态，我们可以将不同的对象看做是同一种类型，从而使得我们可以使用同一种接口来操作这些对象，而不必关心具体的实现细节。</p> 
<h4>2.多态概念</h4> 
<p><span style="color:#0d0016;">当父类的引用所指向的子类对象引用指向的对象不一样时。调用重写的方法，所表现出来的行为是不一样的，我们把这种思想叫做</span><span style="color:#fe2c24;"><strong>多态</strong></span>。上面所说的可能大家会觉得有点抽象，看到后面就懂了。<br> 多态的基础是动态绑定，所以要了解多态前提我们还要了解动态绑定。<br> 要想实现动态绑定，需要满足以上几个条件：<br> 1.要发生向上转型<br> 2.要发生重写<br> 3.使用父类对象的引用去调用重写方法<br> 完成了这三部分，就会发生动态绑定，而在这里，出现了重写以及向上转型这些概念。所以我们得先了解它们才能去了解动态绑定。进而了解多态。</p> 
<h3>二、重写</h3> 
<h4>1.重写的概念</h4> 
<div> 
 <span style="color:#333333;">重写</span> 
 <span style="color:#333333;">(override)</span> 
 <span style="color:#333333;">：也称为覆盖。将父类的方法重新在子类中使用。</span> 
 <span style="color:#fe2c24;"><strong>返回值和形参都不能改变</strong></span> 
 <span style="color:#333333;">。</span> 
 <span style="color:#333333;"><strong>即外壳不变，核心重写！</strong></span> 
 <span style="color:#333333;">重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</span> 
</div> 
<p><strong>方法重写的规则：<br><span style="color:#fe2c24;">1.子类在重写父类的方法时，必须与父类方法原型一致：即返回值、方法名、参数列表要完全一致<br> 2.被重写的方法的访问修饰限定符在子类中要大于等于父类的。<br> 3.父类中被static或private或final修饰的方法以及构造方法都不能被重写。 <br> 4.在子类中重写的方法, 可以使用 @Override 注解来显式指定. 有了这个注解能帮我们进行一些合法性校验。</span></strong></p> 
<h4>2.重写的作用</h4> 
<div> 
 <span style="color:#333333;">对于已经投入使用的类，尽量不要进行修改。最好的方式是：重新定义一个新的类，来重复利用其中共性的内容，并且添加或者改动新的内容。</span> 
 <div> 
  <span style="color:#333333;">例如：若干年前的手机，只能打电话，发短信，来电显示只能显示号码，而今天的手机在来电显示的时候，不仅仅可以显示号码，还可以显示头像，地区等。在这个过程当中，我们<strong>不应该在原来老的类上进行修改，因为原来的</strong></span> 
  <span style="color:#333333;"><strong>类，可能还在有用户使用</strong></span> 
  <span style="color:#333333;">，正确做法是：</span> 
  <span style="color:#333333;"><strong>新建一个新手机的类，对来电显示这个方法重写就好了，这样就达到了我</strong></span> 
  <span style="color:#333333;"><strong>们当今的需求了</strong></span> 
  <span style="color:#333333;">。</span> 
 </div> 
</div> 
<h3 style="background-color:transparent;">三、向上转型</h3> 
<div> 
 <span style="color:#333333;">向上转型：实际就是创建一个子类对象，将其当成父类对象来使用。<br> 语法格式：父类类型 对象名</span> 
 <span style="color:#333333;"> = new </span> 
 <span style="color:#333333;">子类类型</span> 
 <span style="color:#333333;">()</span> 
</div> 
<div> 
 <blockquote> 
  <div> 
   <span style="color:#000000;">Animal animal </span> 
   <span style="color:#981a1a;">= </span> 
   <span style="color:#770088;">Dog</span> 
   <span style="color:#333333;">(</span> 
   <span style="color:#333333;">);</span> 
  </div> 
 </blockquote> 
</div> 
<div> 
 <span style="color:#333333;">我们对以上代码进行实质化分析，以上的代码其实是省略化了，见以下代码</span> 
 <blockquote> 
  <p style="margin-left:.0001pt;text-align:justify;">Dog dog = new Dog（);<br>  Animal animal = dog;//该代码发生了向上转换，将Dog对象转换为Animal类型</p> 
 </blockquote> 
 <div>
   通过向上转型后，就可以父类对象名来访问子类的方法了。使用animal.eat();这语句来访问 
 </div> 
 <div>
   这个语句发生了动态绑定（在编译过程中调用的其实是父类的eat，但是在运行时换为调用子类的eat了）故实现了 
  <span style="color:#333333;">创建一个子类对象，将其当成父类对象来使用。见以下代码</span> 
  <blockquote> 
   <p style="margin-left:.0001pt;text-align:justify;">class Animal {<!-- --></p> 
   <p style="margin-left:.0001pt;text-align:justify;">void sound() {<!-- --></p> 
   <p style="margin-left:.0001pt;text-align:justify;">System.out.println("Animal makes a sound");</p> 
   <p style="margin-left:.0001pt;text-align:justify;">}</p> 
   <p style="margin-left:.0001pt;text-align:justify;">}</p> 
   <p style="margin-left:.0001pt;text-align:justify;">class Dog extends Animal {<!-- --></p> 
   <p style="margin-left:.0001pt;text-align:justify;"> void sound() {<!-- --></p> 
   <p style="margin-left:.0001pt;text-align:justify;">System.out.println("Dog barks");</p> 
   <p style="margin-left:.0001pt;text-align:justify;">}</p> 
   <p style="margin-left:.0001pt;text-align:justify;"> void fetch() {<!-- --></p> 
   <p style="margin-left:.0001pt;text-align:justify;">System.out.println("Dog fetches a ball");</p> 
   <p style="margin-left:.0001pt;text-align:justify;">}</p> 
   <p style="margin-left:.0001pt;text-align:justify;">}</p> 
   <p style="margin-left:.0001pt;text-align:justify;">public class Main {<!-- --></p> 
   <p style="margin-left:.0001pt;text-align:justify;">public static void main(String[] args) {<!-- --></p> 
   <p style="margin-left:.0001pt;text-align:justify;">Dog dog = new Dog(); // 创建Dog对象</p> 
   <p style="margin-left:.0001pt;text-align:justify;"> Animal animal = dog; // 向上转型，将Dog对象转换为Animal类型</p> 
   <p style="margin-left:.0001pt;text-align:justify;"> animal.sound();//调用子类的覆盖方法</p> 
   <p style="margin-left:.0001pt;text-align:justify;"> // <span style="color:#fe2c24;">animal.fetch();</span> // 编译错误，因为Animal类中没有fetch方法</p> 
   <p style="margin-left:.0001pt;text-align:justify;">}</p> 
   <p style="margin-left:.0001pt;text-align:justify;">}</p> 
   <p style="margin-left:.0001pt;text-align:justify;">// 输出: Dog barks</p> 
  </blockquote> 
  <p>通过以上代码发现一个问题<span style="color:#fe2c24;">，</span><strong><span style="color:#fe2c24;">不能调用到子类特有的方法</span>（因为编译时调用的是父类的方法），</strong><strong>我们可以通过向下转型来</strong><span style="color:#0d0016;">调用到子类特有的方法（后面介绍）</span><br><span style="color:#333333;"><strong>静态绑定</strong></span><span style="color:#333333;">：也称为前期绑定</span><span style="color:#333333;">(</span><span style="color:#333333;">早绑定</span><span style="color:#333333;">)</span><span style="color:#333333;">，即在编译时，根据用户所传递实参类型就确定了具体调用那个方法。典型代表函数重载。 </span><br><span style="color:#333333;"><strong>动态绑定</strong></span><span style="color:#333333;">：也称为后期绑定</span><span style="color:#333333;">(</span><span style="color:#333333;">晚绑定</span><span style="color:#333333;">)</span><span style="color:#333333;">，即在编译时，不能确定方法的行为，需要等到程序运行时，才能够确定具体调用那个类的方法。当发生重写时，通过父类调用该方法时会发生动态绑定。</span></p> 
 </div> 
 <div> 
  <span style="color:#333333;">【<strong>向上转型</strong></span> 
  <span style="color:#333333;"><strong>使用场景</strong></span> 
  <span style="color:#333333;">】</span> 
 </div> 
 <div> 
  <span style="color:#333333;">1. </span> 
  <span style="color:#333333;">直接赋值 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">2. </span> 
  <span style="color:#333333;">方法传参 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">3. </span> 
  <span style="color:#333333;">方法返回</span> 
  <br> 见以下代码 
  <blockquote> 
   <p style="margin-left:.0001pt;text-align:justify;">public class TestAnimal {<!-- --></p> 
   <p style="margin-left:.0001pt;text-align:justify;">// 2. 方法传参：形参为父类型引用，可以接收任意子类的对象</p> 
   <p style="margin-left:.0001pt;text-align:justify;">public<span style="color:#956fe7;"> static</span> void <span style="color:#fe2c24;">eatFood</span>(Animal a){<!-- --><span style="color:#fe2c24;"> </span><span style="color:#956fe7;">//因为主方法的原因使用静态方法</span></p> 
   <p style="margin-left:.0001pt;text-align:justify;">a.eat();  //<span style="color:#333333;">方法传参向上转型</span></p> 
   <p style="margin-left:.0001pt;text-align:justify;">}</p> 
   <p style="margin-left:.0001pt;text-align:justify;">// 3. 作返回值：返回任意子类对象的实例</p> 
   <p style="margin-left:.0001pt;text-align:justify;">public static <span style="color:#4da8ee;">Animal</span> buyAnimal(String var){<!-- --></p> 
   <p style="margin-left:.0001pt;text-align:justify;">return <span style="color:#4da8ee;">new Dog()</span>;</p> 
   <p style="margin-left:.0001pt;text-align:justify;">}</p> 
   <p style="margin-left:.0001pt;text-align:justify;">public <span style="color:#956fe7;">static</span> void <span style="color:#956fe7;">main</span>() {<!-- --></p> 
   <p style="margin-left:.0001pt;text-align:justify;">Animal cat = new Cat("元宝",2); // 1. 直接赋值：子类对象赋值给父类对象</p> 
   <p style="margin-left:.0001pt;text-align:justify;">Dog dog = new Dog("小七", 1);</p> 
   <p style="margin-left:.0001pt;text-align:justify;">animal.eat();  //<span style="color:#333333;">直接赋值向上转型</span></p> 
   <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#fe2c24;">eatFood</span>(cat);  //<span style="color:#fe2c24;">两种传参方式都可</span></p> 
   <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#fe2c24;">eatFood</span>(dog); </p> 
   <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#4da8ee;">Animal animal = buyAnimal(); </span> </p> 
   <p style="margin-left:.0001pt;text-align:justify;">animal.eat();//<span style="color:#333333;">方法返回向上转型</span></p> 
   <p style="margin-left:.0001pt;text-align:justify;">}</p> 
   <p style="margin-left:.0001pt;text-align:justify;">}</p> 
  </blockquote> 
  <div> 
   <span style="color:#333333;"><strong>向上转型的优点：让代码实现更简单灵活。 </strong></span> 
  </div> 
  <div> 
   <span style="color:#333333;"><strong>向上转型的缺陷：不能调用到子类特有的方法。</strong></span> 
  </div> 
 </div> 
</div> 
<h3 style="background-color:transparent;">四、多态的实现</h3> 
<p>多态具体点就是去完成某个行为时，当不同的对象去完成同一件事时（调用eat方法）会产生出不同的状态。代码如下：</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">class Animal {<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">    public void eat(){<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">        System.out.println( "吃饭");</p> 
 <p style="margin-left:.0001pt;text-align:justify;">    }</p> 
 <p style="margin-left:.0001pt;text-align:justify;">}</p> 
 <p style="margin-left:.0001pt;text-align:justify;"> class Cat extends Animal{<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">    @Override //注解</p> 
 <p style="margin-left:.0001pt;text-align:justify;">    public void eat(){<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">        System.out.println("吃鱼~~~");</p> 
 <p style="margin-left:.0001pt;text-align:justify;">    }</p> 
 <p style="margin-left:.0001pt;text-align:justify;">}</p> 
 <p style="margin-left:.0001pt;text-align:justify;"> class Dog extends Animal {<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">    @Override</p> 
 <p style="margin-left:.0001pt;text-align:justify;">    public void eat(){<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">        System.out.println("吃骨头~~~");</p> 
 <p style="margin-left:.0001pt;text-align:justify;">    }</p> 
 <p style="margin-left:.0001pt;text-align:justify;">}</p> 
 <p style="margin-left:.0001pt;text-align:justify;">public class TestAnimal {<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">    public static void eat(Animal a){<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">      <strong><span style="color:#fe2c24;">  a.eat(); //两次调用该方法，但是结果却不一样</span></strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;">    }</p> 
 <p style="margin-left:.0001pt;text-align:justify;">    public static void main(String[] args) {<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">        Cat cat = new Cat();</p> 
 <p style="margin-left:.0001pt;text-align:justify;">        Dog dog = new Dog();</p> 
 <p style="margin-left:.0001pt;text-align:justify;">        eat(cat);</p> 
 <p style="margin-left:.0001pt;text-align:justify;">        eat(dog);</p> 
 <p style="margin-left:.0001pt;text-align:justify;">    }</p> 
 <p style="margin-left:.0001pt;text-align:justify;">}</p> 
 <p style="margin-left:.0001pt;text-align:justify;">//输出结果</p> 
 <p style="margin-left:.0001pt;text-align:justify;">吃鱼~~~<br> 吃骨头~~~</p> 
</blockquote> 
<p>此时在上述代码中<span style="color:#fe2c24;">当父类的引用所指向的子类对象引用指向的对象不一样时。调用重写的方法（eat），所表现出来的行为是不一样的(输出结果不一样),我们把它叫做<strong>多态。</strong></span></p> 
<h3>五、向下转型</h3> 
<div> 
 <span style="color:#333333;">将一个子类对象经过向上转型之后当成父类方法使用，再无法调用子类的方法，但有时候可能需要调用子类特有的方法，此时可以实例化子类，然后调用子类方法即可。我们其实还可以将父类引用再还原为子类对象即可，即</span> 
 <span style="color:#fe2c24;">向下转型</span> 
 <span style="color:#333333;">。<br> 语法格式：子类类型 对象名</span> 
 <span style="color:#333333;"> = （强制转换）父类对象名</span> 
 <blockquote> 
  <p style="margin-left:.0001pt;text-align:justify;"> Dog myDog = (Dog) animal;</p> 
 </blockquote> 
 <p><span style="color:#333333;">那么以上代码为什么要强制类型转换呢？向上转型可以不用，因为是从小范围向大范围的转换。（可以类比整型里面的强制转换），我们现在提出一个问题：什么时候都可以向下转型吗？<br> 答案是不，在Java中，向下转型（将父类引用转换为子类引用）一般需要先进行向上转型<br> 见以下代码</span></p> 
 <blockquote> 
  <p style="margin-left:.0001pt;text-align:justify;">class Animal {<!-- --></p> 
  <p style="margin-left:.0001pt;text-align:justify;">    void sound() {<!-- --></p> 
  <p style="margin-left:.0001pt;text-align:justify;">        System.out.println("Animal的sound");</p> 
  <p style="margin-left:.0001pt;text-align:justify;">    }</p> 
  <p style="margin-left:.0001pt;text-align:justify;">    void sun() {<!-- --></p> 
  <p style="margin-left:.0001pt;text-align:justify;">        System.out.println("Animal特有的sun");</p> 
  <p style="margin-left:.0001pt;text-align:justify;">    }</p> 
  <p style="margin-left:.0001pt;text-align:justify;">}</p> 
  <p style="margin-left:.0001pt;text-align:justify;">class Dog extends Animal {<!-- --></p> 
  <p style="margin-left:.0001pt;text-align:justify;">    void sound() {<!-- --></p> 
  <p style="margin-left:.0001pt;text-align:justify;">        System.out.println("Dog的sound");</p> 
  <p style="margin-left:.0001pt;text-align:justify;">    }</p> 
  <p style="margin-left:.0001pt;text-align:justify;">    void fetch() {<!-- --></p> 
  <p style="margin-left:.0001pt;text-align:justify;">        System.out.println("Dog特有的fetches ");</p> 
  <p style="margin-left:.0001pt;text-align:justify;">    }</p> 
  <p style="margin-left:.0001pt;text-align:justify;">}</p> 
  <p style="margin-left:.0001pt;text-align:justify;">public class Mainn {<!-- --></p> 
  <p style="margin-left:.0001pt;text-align:justify;">    public static void main(String[] args) {<!-- --></p> 
  <p style="margin-left:.0001pt;text-align:justify;">        Animal animal = new Dog();<span style="color:#fe2c24;"> // 向上转型</span></p> 
  <p style="margin-left:.0001pt;text-align:justify;">        Dog myDog = (Dog) animal;<span style="color:#fe2c24;"> // 向下转型</span></p> 
  <p style="margin-left:.0001pt;text-align:justify;">        myDog.sound(); // 输出: Dog barks，调用子类的覆盖方法</p> 
  <p style="margin-left:.0001pt;text-align:justify;">        myDog.fetch(); // 输出: Dog fetches a ball，调用子类特有的方法</p> 
  <p style="margin-left:.0001pt;text-align:justify;">        myDog.sound(); // 输出: Dog barks，调用子类的覆盖方法</p> 
  <p style="margin-left:.0001pt;text-align:justify;">    }</p> 
  <p style="margin-left:.0001pt;text-align:justify;">}</p> 
 </blockquote> 
 <p><span style="color:#333333;">如果上面的代码没有</span> Animal animal = new Dog();，向下转型将报错，同时注意必须确保父类引用所指向的对象确实是子类的实例。如果父类引用所指向的对象不是子类的实例，那么即使进行了向上转型，向下转型也是不安全的：见以下代码</p> 
 <blockquote> 
  <p>class Parent {}<br> class Child extends Parent {}<br> class AnotherChild extends Parent {}</p> 
  <p>public class Main {<!-- --><br> public static void main(String[] args) {<!-- --><br> Parent parent = new AnotherChild(); // 向上转型<br>  // <span style="color:#fe2c24;">这里如果尝试向下转型为Child，编译器将会报错</span><br>  // Child child = (Child) parent;//<strong><span style="color:#ff9900;">不安全的向下转型</span></strong><br> }<br> }</p> 
  <p>//为了演示方便，这个代码是不完整的</p> 
 </blockquote> 
 <p><span style="color:#333333;">因此，向下转型之前，你需要确保父类引用所指向的对象确实是你要转型的子类的实例。这通常通过instanceof操作符来检查：用来判断parent是否为Child的实例，若是，返回true,否则返回false</span></p> 
 <blockquote> 
  <p><br><span style="color:#333333;">if (parent instanceof Child) {<!-- --><br>     Child child = (Child) parent; // </span><span style="color:#ff9900;"><strong>安全的向下转型</strong></span><br><span style="color:#333333;">} else {<!-- --><br>    ......                         // 不能转换为Child<br> }</span></p> 
 </blockquote> 
 <p>我们最后思考一个问题：<span style="color:#333333;"><strong>向上转型的缺陷是不能调用到子类特有的方法，那么向下转型可以调用父类特有的方法吗？是可以的，同时向下转型后不会影响向上转型的操作。</strong>见以下代码</span></p> 
 <blockquote> 
  <p style="margin-left:.0001pt;text-align:justify;">class Animal {<!-- --></p> 
  <p style="margin-left:.0001pt;text-align:justify;">    void sound() {<!-- --></p> 
  <p style="margin-left:.0001pt;text-align:justify;">        System.out.println("Animal的sound");</p> 
  <p style="margin-left:.0001pt;text-align:justify;">    }</p> 
  <p style="margin-left:.0001pt;text-align:justify;">    void sun() {<!-- --></p> 
  <p style="margin-left:.0001pt;text-align:justify;">        System.out.println("Animal特有的sun");</p> 
  <p style="margin-left:.0001pt;text-align:justify;">    }</p> 
  <p style="margin-left:.0001pt;text-align:justify;">}</p> 
  <p style="margin-left:.0001pt;text-align:justify;">class Dog extends Animal {<!-- --></p> 
  <p style="margin-left:.0001pt;text-align:justify;">    void sound() {<!-- --></p> 
  <p style="margin-left:.0001pt;text-align:justify;">        System.out.println("Dog的sound");</p> 
  <p style="margin-left:.0001pt;text-align:justify;">    }</p> 
  <p style="margin-left:.0001pt;text-align:justify;">    void fetch() {<!-- --></p> 
  <p style="margin-left:.0001pt;text-align:justify;">        System.out.println("Dog特有的fetches ");</p> 
  <p style="margin-left:.0001pt;text-align:justify;">    }</p> 
  <p style="margin-left:.0001pt;text-align:justify;">}</p> 
  <p style="margin-left:.0001pt;text-align:justify;">public class Mainn {<!-- --></p> 
  <p style="margin-left:.0001pt;text-align:justify;">    public static void main(String[] args) {<!-- --></p> 
  <p style="margin-left:.0001pt;text-align:justify;">        Animal animal = new Dog(); // 向上转型</p> 
  <p style="margin-left:.0001pt;text-align:justify;">        Dog myDog = (Dog) animal; // 向下转型</p> 
  <p style="margin-left:.0001pt;text-align:justify;">        myDog.sound(); // 输出: Dog barks，调用子类的覆盖方法</p> 
  <p style="margin-left:.0001pt;text-align:justify;">        myDog.fetch(); // 输出: Dog fetches a ball，调用子类特有的方法</p> 
  <p style="margin-left:.0001pt;text-align:justify;">    </p> 
  <p style="margin-left:.0001pt;text-align:justify;">        myDog.sound(); // 输出: Dog barks，调用子类的覆盖方法</p> 
  <p style="margin-left:.0001pt;text-align:justify;">        <span style="color:#fe2c24;">myDog.sun();</span>   //观察到向下转型过程中<span style="color:#fe2c24;">可以调用父类的特有的方法</span></p> 
  <p style="margin-left:.0001pt;text-align:justify;">        <span style="color:#956fe7;">animal.sun();</span>   //观察到<span style="color:#956fe7;">向下转型后不会影响向上转型的操作</span></p> 
  <p style="margin-left:.0001pt;text-align:justify;">       <span style="color:#956fe7;"> animal.sound();</span></p> 
  <p style="margin-left:.0001pt;text-align:justify;">    }</p> 
  <p style="margin-left:.0001pt;text-align:justify;">}</p> 
  <p style="margin-left:.0001pt;text-align:justify;">//输出结果</p> 
  <p style="margin-left:.0001pt;text-align:justify;">Dog的sound<br> Dog特有的fetches <br> Dog的sound<br> Animal特有的sun<br> Animal特有的sun<br> Dog的sound</p> 
 </blockquote> 
</div> 
<h3>六、多态的优缺点</h3> 
<div> 
 <span style="color:#333333;">如我们现在需要打印的不是一个形状了</span> 
 <span style="color:#333333;">, </span> 
 <span style="color:#333333;">而是多个形状</span> 
 <span style="color:#333333;">. </span> 
 <span style="color:#333333;">如果不基于多态</span> 
 <span style="color:#333333;">, </span> 
 <span style="color:#333333;">实现代码如下</span> 
</div> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">class Shape {<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">    //属性....</p> 
 <p style="margin-left:.0001pt;text-align:justify;">    public void draw() {<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">        System.out.println("画图形！");</p> 
 <p style="margin-left:.0001pt;text-align:justify;">    }</p> 
 <p style="margin-left:.0001pt;text-align:justify;">}</p> 
 <p style="margin-left:.0001pt;text-align:justify;">class Rect extends Shape{<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">    @Override</p> 
 <p style="margin-left:.0001pt;text-align:justify;">    public void draw() {<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">        System.out.println("♦");</p> 
 <p style="margin-left:.0001pt;text-align:justify;">    }</p> 
 <p style="margin-left:.0001pt;text-align:justify;">}</p> 
 <p style="margin-left:.0001pt;text-align:justify;">class Cycle extends Shape{<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">    @Override</p> 
 <p style="margin-left:.0001pt;text-align:justify;">    public void draw() {<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">        System.out.println("●");</p> 
 <p style="margin-left:.0001pt;text-align:justify;">    }</p> 
 <p style="margin-left:.0001pt;text-align:justify;">}</p> 
 <p style="margin-left:.0001pt;text-align:justify;">class Flower extends Shape{<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">    @Override</p> 
 <p style="margin-left:.0001pt;text-align:justify;">    public void draw() {<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">        System.out.println("❀");</p> 
 <p style="margin-left:.0001pt;text-align:justify;">    }</p> 
 <p style="margin-left:.0001pt;text-align:justify;">}</p> 
 <p style="margin-left:.0001pt;text-align:justify;">public class Mainn {<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">    public static void main(String[] args) {<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">        <span style="color:#ed7976;">    Rect rect = new Rect();</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ed7976;">            Cycle cycle = new Cycle();</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ed7976;">            Flower flower = new Flower();</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ed7976;">            String[] shapes = {"cycle", "rect", "cycle", "rect", "flower"};</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ed7976;">            for (String shape : shapes) {<!-- --></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ed7976;">                if (shape.equals("cycle")) {<!-- --></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ed7976;">                    cycle.draw();</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ed7976;">                } else if (shape.equals("rect")) {<!-- --></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ed7976;">                    rect.draw();</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ed7976;">                } else if (shape.equals("flower")) {<!-- --></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ed7976;">                    flower.draw();</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ed7976;">            }</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ed7976;">        }</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;">    }</p> 
 <p style="margin-left:.0001pt;text-align:justify;">}</p> 
</blockquote> 
<div> 
 <span style="color:#333333;"><strong>以上代码使用了大量的 if - else，增加了代码的</strong></span> 
 <span style="color:#333333;"><strong> "</strong></span> 
 <span style="color:#333333;"><strong>圈复杂度",</strong></span> 
 <div> 
  <span style="color:#777777;">什么叫</span> 
  <span style="color:#777777;"> "</span> 
  <span style="color:#777777;">圈复杂度</span> 
  <span style="color:#777777;">" ? </span> 
 </div> 
 <div> 
  <span style="color:#777777;">圈复杂度是一种描述一段代码复杂程度的方式</span> 
  <span style="color:#777777;">. </span> 
  <span style="color:#777777;">一段代码如果平铺直叙</span> 
  <span style="color:#777777;">, </span> 
  <span style="color:#777777;">那么就比较简单容易理解</span> 
  <span style="color:#777777;">. </span> 
  <span style="color:#777777;">而如 </span> 
 </div> 
 <div> 
  <span style="color:#777777;">果有很多的条件分支或者循环语句</span> 
  <span style="color:#777777;">, </span> 
  <span style="color:#777777;">就认为理解起来更复杂</span> 
  <span style="color:#777777;">. </span> 
 </div> 
 <div> 
  <span style="color:#777777;">因此我们可以简单粗暴的计算一段代码中条件语句和循环语句出现的个数</span> 
  <span style="color:#777777;">, </span> 
  <span style="color:#777777;">这个个数就称为</span> 
  <span style="color:#777777;"> "</span> 
  <span style="color:#777777;">圈复杂度</span> 
  <span style="color:#777777;">". </span> 
 </div> 
 <div> 
  <span style="color:#777777;">如果一个方法的圈复杂度太高</span> 
  <span style="color:#777777;">, </span> 
  <span style="color:#777777;">就需要考虑重构</span> 
  <span style="color:#777777;">. </span> 
 </div> 
 <div> 
  <span style="color:#777777;">不同公司对于代码的圈复杂度的规范不一样</span> 
  <span style="color:#777777;">. </span> 
  <span style="color:#777777;">一般不会超过</span> 
  <span style="color:#777777;"> 10 </span> 
 </div> 
</div> 
<div> 
 <span style="color:#333333;">如果使用使用多态</span> 
 <span style="color:#333333;">, </span> 
 <span style="color:#333333;">则不必写这么多的</span> 
 <span style="color:#333333;"> if - else </span> 
 <span style="color:#333333;">分支语句</span> 
 <span style="color:#333333;">, </span> 
 <span style="color:#333333;">代码更简单</span> 
</div> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">class Shape {<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">    //属性....</p> 
 <p style="margin-left:.0001pt;text-align:justify;">    public void draw() {<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">        System.out.println("画图形！");</p> 
 <p style="margin-left:.0001pt;text-align:justify;">    }</p> 
 <p style="margin-left:.0001pt;text-align:justify;">}</p> 
 <p style="margin-left:.0001pt;text-align:justify;">class Rect extends Shape{<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">    @Override</p> 
 <p style="margin-left:.0001pt;text-align:justify;">    public void draw() {<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">        System.out.println("♦");</p> 
 <p style="margin-left:.0001pt;text-align:justify;">    }</p> 
 <p style="margin-left:.0001pt;text-align:justify;">}</p> 
 <p style="margin-left:.0001pt;text-align:justify;">class Cycle extends Shape{<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">    @Override</p> 
 <p style="margin-left:.0001pt;text-align:justify;">    public void draw() {<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">        System.out.println("●");</p> 
 <p style="margin-left:.0001pt;text-align:justify;">    }</p> 
 <p style="margin-left:.0001pt;text-align:justify;">}</p> 
 <p style="margin-left:.0001pt;text-align:justify;">class Flower extends Shape{<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">    @Override</p> 
 <p style="margin-left:.0001pt;text-align:justify;">    public void draw() {<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">        System.out.println("❀");</p> 
 <p style="margin-left:.0001pt;text-align:justify;">    }</p> 
 <p style="margin-left:.0001pt;text-align:justify;">}</p> 
 <p style="margin-left:.0001pt;text-align:justify;">public class Mainn {<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">    public static void main(String[] args) {<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">      <span style="color:#ed7976;">      Shape[] shapes = {new Cycle(), new Rect(), new Cycle(),</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ed7976;">                    new Rect(), new Flower()};</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ed7976;">            for (Shape shape : shapes) {<!-- --></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ed7976;">                shape.draw();</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ed7976;">            }</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ed7976;">        }</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;">            }</p> 
</blockquote> 
<div> 
 <span style="color:#333333;">如果要新增一种新的形状</span> 
 <span style="color:#333333;">, </span> 
 <span style="color:#333333;">使用多态的方式代码改动成本也比较低</span> 
 <span style="color:#333333;">.见以下代码</span> 
 <blockquote> 
  <div>
    //公共部分 
  </div> 
  <div> 
   <span style="color:#ff9900;">class Triangle extends Sjx { </span> 
  </div> 
  <div> 
   <span style="color:#ff9900;">@Override </span> 
  </div> 
  <div> 
   <span style="color:#ff9900;">public void draw() { </span> 
  </div> 
  <div> 
   <span style="color:#ff9900;">System.out.println("△"); </span> 
  </div> 
  <div> 
   <span style="color:#ff9900;">} </span> 
  </div> 
  <div> 
   <span style="color:#ff9900;">} </span> 
  </div> 
  <div> 
   <span style="color:#333333;">//If lese 改动方式</span> 
  </div> 
  <div> 
   <p></p> 
   <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#956fe7;">Sjx sjx=new Sjx();</span></p> 
   <p style="margin-left:.0001pt;text-align:justify;">            String[] shapes = {"cycle", "rect", "cycle", "rect", "flower", <span style="color:#1a439c;">"</span><span style="color:#956fe7;">sjx"</span>};</p> 
   <p style="margin-left:.0001pt;text-align:justify;">            for (String shape : shapes) {<!-- --></p> 
   <p style="margin-left:.0001pt;text-align:justify;">                if (shape.equals("cycle")) {<!-- --></p> 
   <p style="margin-left:.0001pt;text-align:justify;">                    cycle.draw();</p> 
   <p style="margin-left:.0001pt;text-align:justify;">                } else if (shape.equals("rect")) {<!-- --></p> 
   <p style="margin-left:.0001pt;text-align:justify;">                    rect.draw();</p> 
   <p style="margin-left:.0001pt;text-align:justify;">                } else if (shape.equals("flower")) {<!-- --></p> 
   <p style="margin-left:.0001pt;text-align:justify;">                    flower.draw();</p> 
   <p style="margin-left:.0001pt;text-align:justify;">                }<span style="color:#956fe7;">else if(shape.equals("sjx"){<!-- --></span></p> 
   <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#956fe7;">                        sjx.draw();</span></p> 
   <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#956fe7;">                    }</span></p> 
   <p style="margin-left:.0001pt;text-align:justify;">            }</p> 
   <p style="margin-left:.0001pt;text-align:justify;">        }</p> 
   <p style="margin-left:.0001pt;text-align:justify;">}</p> 
   <p style="margin-left:.0001pt;text-align:justify;">//多态改动方式</p> 
   <p style="margin-left:.0001pt;text-align:justify;">public class Mainn {<!-- --></p> 
   <p style="margin-left:.0001pt;text-align:justify;">    public static void main(String[] args) {<!-- --></p> 
   <p style="margin-left:.0001pt;text-align:justify;">        Shape[] shapes = {new Cycle(), new Rect(), new Cycle(),</p> 
   <p style="margin-left:.0001pt;text-align:justify;">                new Rect(), new Flower()<span style="color:#fe2c24;">,new Sjx()</span>};</p> 
   <p style="margin-left:.0001pt;text-align:justify;">        for (Shape shape : shapes) {<!-- --></p> 
   <p style="margin-left:.0001pt;text-align:justify;">            shape.draw();</p> 
   <p style="margin-left:.0001pt;text-align:justify;">                    }</p> 
   <p style="margin-left:.0001pt;text-align:justify;">            }</p> 
   <p style="margin-left:.0001pt;text-align:justify;">        }</p> 
  </div> 
 </blockquote> 
 <div> 
  <span style="color:#333333;">对于类的调用者来说</span> 
  <span style="color:#333333;">(drawShapes</span> 
  <span style="color:#333333;">方法</span> 
  <span style="color:#333333;">), </span> 
  <span style="color:#333333;">只要创建一个新类的实例就可以了</span> 
  <span style="color:#333333;">, </span> 
  <span style="color:#333333;">改动成本很低</span> 
  <span style="color:#333333;">. </span> 
 </div> 
 <div> 
  <span style="color:#333333;">而对于不用多态的情况</span> 
  <span style="color:#333333;">, </span> 
  <span style="color:#333333;">就要把</span> 
  <span style="color:#333333;"> drawShapes </span> 
  <span style="color:#333333;">中的</span> 
  <span style="color:#333333;"> if - else </span> 
  <span style="color:#333333;">进行一定的修改</span> 
  <span style="color:#333333;">, </span> 
  <span style="color:#333333;">改动成本更高</span> 
  <span style="color:#333333;">. </span> 
 </div> 
</div> 
<div> 
 <span style="color:#333333;"><strong>多态缺陷：</strong></span> 
</div> 
<div> 
 <div> 
  <span style="color:#777777;">1. </span> 
  <span style="color:#777777;">属性没有多态性 </span> 
 </div> 
 <div> 
  <span style="color:#777777;">当父类和子类都有同名属性的时候，通过父类引用，只能引用父类自己的成员属性 </span> 
 </div> 
 <div> 
  <span style="color:#777777;">2. </span> 
  <span style="color:#777777;">构造方法没有多态性 </span> 
 </div> 
 <div> 
  <span style="color:#777777;">见如下代码</span> 
  <span style="color:#777777;">~ </span> 
 </div> 
</div> 
<h3>七、<span style="color:#333333;"><strong>避免在构造方法中调用重写的方法</strong></span></h3> 
<blockquote> 
 <div> 
  <span style="color:#770088;">class </span> 
  <span style="color:#0000ff;">B </span> 
  <span style="color:#333333;">{ </span> 
 </div> 
 <div> 
  <span style="color:#770088;">public </span> 
  <span style="color:#000000;">B</span> 
  <span style="color:#333333;">() { </span> 
 </div> 
 <div> 
  <span style="color:#aa5500;">// do nothing </span> 
 </div> 
 <div> 
  <span style="color:#000000;">func</span> 
  <span style="color:#333333;">(); </span> 
 </div> 
 <div> 
  <span style="color:#333333;">} </span> 
 </div> 
 <div> 
  <span style="color:#770088;">public </span> 
  <span style="color:#008855;">void </span> 
  <span style="color:#000000;">func</span> 
  <span style="color:#333333;">() { </span> 
 </div> 
 <div> 
  <span style="color:#000000;">System</span> 
  <span style="color:#333333;">.</span> 
  <span style="color:#000000;">out</span> 
  <span style="color:#333333;">.</span> 
  <span style="color:#000000;">println</span> 
  <span style="color:#333333;">(</span> 
  <span style="color:#aa1111;">"B.func()"</span> 
  <span style="color:#333333;">); </span> 
 </div> 
 <div> 
  <span style="color:#333333;">} </span> 
 </div> 
 <div> 
  <span style="color:#333333;">} </span> 
 </div> 
 <div> 
  <span style="color:#770088;">class </span> 
  <span style="color:#0000ff;">D </span> 
  <span style="color:#770088;">extends </span> 
  <span style="color:#000000;">B </span> 
  <span style="color:#333333;">{ </span> 
 </div> 
 <div> 
  <span style="color:#770088;">private </span> 
  <span style="color:#008855;">int </span> 
  <span style="color:#000000;">num </span> 
  <span style="color:#981a1a;">= </span> 
  <span style="color:#116644;">1</span> 
  <span style="color:#333333;">; </span> 
 </div> 
 <div> 
  <span style="color:#555555;">@Override </span> 
 </div> 
 <div> 
  <span style="color:#770088;">public </span> 
  <span style="color:#008855;">void </span> 
  <span style="color:#000000;">func</span> 
  <span style="color:#333333;">() { </span> 
 </div> 
 <div> 
  <span style="color:#000000;">System</span> 
  <span style="color:#333333;">.</span> 
  <span style="color:#000000;">out</span> 
  <span style="color:#333333;">.</span> 
  <span style="color:#000000;">println</span> 
  <span style="color:#333333;">(</span> 
  <span style="color:#aa1111;">"D.func() " </span> 
  <span style="color:#981a1a;">+ </span> 
  <span style="color:#000000;">num</span> 
  <span style="color:#333333;">); </span> 
 </div> 
 <div> 
  <span style="color:#333333;">} </span> 
 </div> 
 <div> 
  <span style="color:#333333;">} </span> 
 </div> 
 <div> 
  <span style="color:#770088;">public class </span> 
  <span style="color:#0000ff;">Test </span> 
  <span style="color:#333333;">{ </span> 
 </div> 
 <div> 
  <span style="color:#770088;">public static </span> 
  <span style="color:#008855;">void </span> 
  <span style="color:#000000;">main</span> 
  <span style="color:#333333;">(</span> 
  <span style="color:#008855;">String</span> 
  <span style="color:#333333;">[] </span> 
  <span style="color:#000000;">args</span> 
  <span style="color:#333333;">) { </span> 
 </div> 
 <div> 
  <span style="color:#000000;">D d </span> 
  <span style="color:#981a1a;">= </span> 
  <span style="color:#770088;">new </span> 
  <span style="color:#000000;">D</span> 
  <span style="color:#333333;">(); </span> 
 </div> 
 <div> 
  <span style="color:#333333;">} </span> 
 </div> 
 <div> 
  <span style="color:#333333;">} </span> 
 </div> 
 <div> 
  <span style="color:#aa5500;">// </span> 
  <span style="color:#aa5500;">执行结果 </span> 
 </div> 
 <div> 
  <span style="color:#000000;">D</span> 
  <span style="color:#333333;">.</span> 
  <span style="color:#000000;">func</span> 
  <span style="color:#333333;">() </span> 
  <span style="color:#116644;">0 </span>// 
  <span style="color:#333333;">此时子类对象还没构造完成，故num的值为0</span> 
 </div> 
</blockquote> 
<div> 
 <div> 
  <span style="color:#333333;">结论：尽量不要在构造器中调用方法</span> 
  <span style="color:#333333;">(</span> 
  <span style="color:#333333;">如果这个方法被子类重写</span> 
  <span style="color:#333333;">, </span> 
  <span style="color:#333333;">就会触发动态绑定, </span> 
  <span style="color:#333333;">但是此时子类对象还没构造完成</span> 
  <span style="color:#333333;">), </span> 
  <span style="color:#333333;">可能会出现一些隐藏的但是又极难发现的问题</span> 
  <span style="color:#333333;">. </span> 
 </div> 
</div> 
<div></div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/64f368985ddf6f1f7e6bd4c7cdd75e9a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AI大模型探索之路-训练篇6：大语言模型预训练数据准备-预处理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a10a1140ea75f226d03bbb00e47fd7c5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【MySQL精炼宝库】数据库的约束 | 表的设计 | 聚合查询 | 联合查询</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>