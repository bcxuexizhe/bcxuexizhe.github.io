<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>（C语言版）力扣（LeetCode）面试题 17.04. 消失的数字5种解法 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/977a3f4ebb26258dec250e482cd59f8e/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="（C语言版）力扣（LeetCode）面试题 17.04. 消失的数字5种解法">
  <meta property="og:description" content="消失的数字 题目介绍第一种解法：按位异或第二种解法：公式运算第三种解法：临时数组第四种解法：相加再相减第五种解法：快排加二分查找结语 题目介绍 该题目取自力扣（LeetCode）面试题 17.04. 消失的数字
链接：消失的数字
该题目主要考察时间复杂度的把握，题目如下：
数组nums包含从0到n的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在O(n)时间内完成吗？
注意：本题相对书上原题稍作改动
示例 1：
输入：[3,0,1]
输出：2
示例 2：
输入：[9,6,4,2,3,5,7,0,1]
输出：8
提示1：
你需要多长时间才能算出缺失数字的最小有效位?
提示2：
要找到缺失的数字中的最小有效位，你其实知道有多少个 0 和 1。例如，如果你看到最小有效位有 3 个 0 和 3 个 1，那么缺失的数字的最小值必定是 1。想想看:在任何 0 和 1 的序列中，你会得到 0，然后是 1，然后又是 0，然后又是 1，以此类推。
提示3：
一旦确定最小有效位是 0(或 1)，就可以排除所有不以 0 作为最小有效位的数。这个问题和前面的有什么不同?
第一种解法：按位异或 这个解法我们先看一张图：
这种算法的思路主要是先设临时变量x=0，让它与nums数组中的数遍历按位异或，
此时x保存按位异或的值，再与0-n按位异或，最后得到的值就是缺的那个数字。
代码如下：
int missingNumber(int* nums, int numsSize){ int misNum = 0; for(int i = 0; i &lt; numsSize; i&#43;&#43;) misNum ^= nums[i]; for(int j = 0; j &lt; numsSize &#43; 1; j&#43;&#43;) misNum ^= j; return misNum; } 这里主要是利用了按位异或的特性，任何数与他本身按位异或得到的就是0；">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-08-06T17:50:38+08:00">
    <meta property="article:modified_time" content="2023-08-06T17:50:38+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">（C语言版）力扣（LeetCode）面试题 17.04. 消失的数字5种解法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/f6/7b/poZOl9oh_o.gif" alt="在这里插入图片描述"></p> 
<p></p> 
<div class="toc"> 
 <h4>消失的数字</h4> 
 <ul><li><a href="#_4" rel="nofollow">题目介绍</a></li><li><a href="#_22" rel="nofollow">第一种解法：按位异或</a></li><li><a href="#_44" rel="nofollow">第二种解法：公式运算</a></li><li><a href="#_61" rel="nofollow">第三种解法：临时数组</a></li><li><a href="#_99" rel="nofollow">第四种解法：相加再相减</a></li><li><a href="#_115" rel="nofollow">第五种解法：快排加二分查找</a></li><li><a href="#_171" rel="nofollow">结语</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_4"></a>题目介绍</h2> 
<p>该题目取自力扣（LeetCode）面试题 17.04. 消失的数字<br> 链接：<a href="https://leetcode-cn.com/problems/missing-number-lcci/" rel="nofollow">消失的数字</a><br> 该题目主要考察时间复杂度的把握，题目如下：<br> <strong>数组nums包含从0到n的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在O(n)时间内完成吗？</strong><br> 注意：本题相对书上原题稍作改动<br> <strong>示例 1：</strong><br> 输入：[3,0,1]<br> 输出：2<br> <strong>示例 2：</strong><br> 输入：[9,6,4,2,3,5,7,0,1]<br> 输出：8<br> <strong>提示1：</strong><br> 你需要多长时间才能算出缺失数字的最小有效位?<br> <strong>提示2：</strong><br> 要找到缺失的数字中的最小有效位，你其实知道有多少个 0 和 1。例如，如果你看到最小有效位有 3 个 0 和 3 个 1，那么缺失的数字的最小值必定是 1。想想看:在任何 0 和 1 的序列中，你会得到 0，然后是 1，然后又是 0，然后又是 1，以此类推。<br> <strong>提示3：</strong><br> 一旦确定最小有效位是 0(或 1)，就可以排除所有不以 0 作为最小有效位的数。这个问题和前面的有什么不同?</p> 
<h2><a id="_22"></a>第一种解法：按位异或</h2> 
<p>这个解法我们先看一张图：<br> <img src="https://images2.imgbox.com/6d/f2/l5DXyw7y_o.jpg" alt="在这里插入图片描述"><br> 这种算法的思路主要是先设临时变量x=0，让它与nums数组中的数遍历按位异或，<br> 此时x保存按位异或的值，再与0-n按位异或，最后得到的值就是缺的那个数字。<br> 代码如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">missingNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> numsSize<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> misNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numsSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    misNum <span class="token operator">^=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> numsSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
    misNum <span class="token operator">^=</span> j<span class="token punctuation">;</span>
    <span class="token keyword">return</span> misNum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里主要是利用了按位异或的特性，任何数与他本身按位异或得到的就是0；<br> 那么在这里x按位异或了本身缺失数字的数组nums，再按位异或0-n的数字，<br> 最后剩下的自然就是缺失的数字了。<br> <strong>时间复杂度：O(n)<br> 空间复杂度：O(1)</strong></p> 
<h2><a id="_44"></a>第二种解法：公式运算</h2> 
<p><img src="https://images2.imgbox.com/7c/5e/cJ4jLv1w_o.jpg" alt="在这里插入图片描述"><br> 我们可以先看一张图，我们知道0-n在数学当中是一个自然数数列，那么他的前n项和公式就可以简化为[n(n-1)d]/2,那么这里的思路就是利用数列的前n项和公式先计算出0-n的总和，再建立一个临时变量k,利用一个for循环将nums中的元素逐个相加，最后两数相减得到的自然就是消失的数了。<br> 代码如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">missingNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> numsSize<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> misNum <span class="token operator">=</span> <span class="token punctuation">(</span>numsSize<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>numsSize<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> numsSize<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
    k<span class="token operator">+=</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    misNum <span class="token operator">=</span> misNum<span class="token operator">-</span>k<span class="token punctuation">;</span>
    <span class="token keyword">return</span> misNum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>时间复杂度：O(n)<br> 空间复杂度：O(1)</strong></p> 
<h2><a id="_61"></a>第三种解法：临时数组</h2> 
<p><img src="https://images2.imgbox.com/47/32/Tglx28KM_o.jpg" alt="在这里插入图片描述"><br> 这里的思路就是用空间换时间，首先我们建立一个临时数组temp，使用malloc函数进行动态内存分配，临时数组temp比初始数组要多一个元素位置，然后将每一个位置都赋值为-1（因为nums是0-n，只有负数不会重复，想给负多少都可以），再将nums中的元素利用for循环逐个找到temp中对应下标进行赋值，最后剩下的-1所对应的下标即为消失的数字，最后再用for循环遍历数组，找到值为-1的元素下标，返回下标即为消失的数字（别忘记把temp的空间释放，否则会造成内存泄露的问题）。<br> 代码如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">missingNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> numsSize<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span><span class="token operator">*</span> temp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>numsSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"missingNumber::malloc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numsSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token operator">*</span><span class="token punctuation">(</span>temp<span class="token operator">+</span>i<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numsSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        temp<span class="token punctuation">[</span><span class="token operator">*</span>nums<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">*</span>nums<span class="token punctuation">;</span>
        nums<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numsSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>temp <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
            temp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>时间复杂度：O(n)<br> 空间复杂度：O(n)</strong></p> 
<h2><a id="_99"></a>第四种解法：相加再相减</h2> 
<p>这种方法和公式法类似，这个的好处在于不用怎么动脑子，简单粗暴，先设立临时变量misNum,让misNum和0-n的值逐个相加，再利用一个for循环对nums数组进行遍历相减，最后得到的misNum的值即为消失的数。<br> 代码如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">missingNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> numsSize<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> misNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> numsSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
    misNum <span class="token operator">+=</span> j<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numsSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    misNum <span class="token operator">-=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> misNum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>时间复杂度：O(n)<br> 空间复杂度：O(1)</strong></p> 
<h2><a id="_115"></a>第五种解法：快排加二分查找</h2> 
<p>这种方法需要学到后序的数据结构中快速排序的知识，如果尚未学习，可以只参照前面4种解法，后续我还会出单独的板块介绍各类排序。</p> 
<p>快速排序使用了“分治法”和“递归”技巧，将一个数组分成两个子数组，其中一个子数组的所有元素都小于另一个子数组的所有元素，并按照同样的方式对这两个子数组进行排序。快速排序中的关键步骤是“Partition（划分）”函数，它选择一个pivot（枢轴），然后通过交换元素的方式，将数组分成两个部分。</p> 
<p>在该代码的“Partition”函数中，我们选择第一个元素为枢轴（pivot），然后使用两个指针low和high，从数组的两端开始遍历数组，交换两个指针所指的元素，以保证左侧的元素小于pivot，右侧的元素大于pivot。最后，将枢轴元素放在正确的位置上。</p> 
<p>在“QuickSort”函数中，我们使用“Partition”函数将数组划分为两个子数组，然后对这两个子数组递归地进行排序。</p> 
<p>在“missingNumber”函数中，我们先对输入数组进行排序，然后使用二分查找的技巧来找到缺失的数字。具体来说，我们定义左侧指针为0，右侧指针为数组的长度，然后计算中间位置mid，如果mid处的元素等于mid，则说明缺失的数字在mid的右侧，我们将左指针移到mid的右侧，否则缺失的数字在mid的左侧，我们将右指针移到mid的左侧。最终，左侧指针指向的位置就是消失的数字。<br> 代码如下：</p> 
<pre><code class="prism language-c"> <span class="token keyword">int</span> <span class="token function">Partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>A<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> pivot<span class="token operator">=</span>A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token operator">&gt;=</span>pivot<span class="token punctuation">)</span> high<span class="token operator">--</span><span class="token punctuation">;</span>
        A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token operator">&lt;=</span>pivot<span class="token punctuation">)</span> low<span class="token operator">++</span><span class="token punctuation">;</span>
        A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token operator">=</span>pivot<span class="token punctuation">;</span>
    <span class="token keyword">return</span> low<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>A<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> PartitionPos <span class="token operator">=</span> <span class="token function">Partition</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">QuickSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>low<span class="token punctuation">,</span>PartitionPos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">QuickSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>PartitionPos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

 <span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">missingNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> numsSize<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">QuickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> numsSize<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> left<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> right<span class="token operator">=</span>numsSize<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> mid<span class="token operator">=</span>left<span class="token operator">+</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>mid<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
            right<span class="token operator">=</span>mid<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> left<span class="token punctuation">;</span>

<span class="token punctuation">}</span>

</code></pre> 
<p><strong>时间复杂度：O(nlogn)<br> 空间复杂度：O(1)</strong><br> 需要注意的是，这个题目在不考虑时间复杂度的情况下，可以使用别的排序方法，比如，冒泡排序，但是它的时间复杂度为O(n*2),因此不符合本题题意，不过有兴趣的小伙伴可以试一试。</p> 
<h2><a id="_171"></a>结语</h2> 
<p>在后续更新中，我会一直写关于OJ题的题解，有兴趣的小伙伴可以关注作者，和作者讨论其他OJ题目，如果觉得内容不错，请给个一键三连吧，蟹蟹你哟！！！</p> 
<p>制作不易，如有不正之处敬请指出<br> 感谢大家的来访，UU们的观看是我坚持下去的动力<br> 在时间的催化剂下，让我们彼此都成为更优秀的人吧！！！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f60d6172aaffe25522d68f8d606a9277/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Springboot @Validated注解详细说明</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5f9fd0e116066f08775a03307ea7aa0e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python web实战之Django的文件上传和处理详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>