<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构：阶段测试(查漏补缺) - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/d13e42fb4876c05be67474feeb49fced/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="数据结构：阶段测试(查漏补缺)">
  <meta property="og:description" content="目录
选择题：
题一：
题二：
题三：
题四：
编程题：
题一：左叶子之和
思路一：
题二：约瑟夫问题（用单链表实现）
思路一：
本人实力有限可能对一些地方解释和理解的不够清晰，可以自己尝试读代码，或者评论区指出错误，望海涵！
感谢大佬们的一键三连！ 感谢大佬们的一键三连！ 感谢大佬们的一键三连！
选择题： 题一： 1.将长度为n的单链表连接在长度为m的单链表之后,其算法的时间复杂度为() A. O(m)
B. O(1)
C. O(n)
D. O(m&#43;n)
答案解析：
长度为n的单链表链接长度为m的单链表只需要长度为m的单链表的头节点的地址，所以时间复杂度还是O(n)。
题二： 2.以下属于链表的优点的是（ ）
A. 用数组可方便实现
B. 插入操作效率高
C. 不用为节点间的逻辑关系而增加额外的存储开销
D. 可以按元素号随机访问
答案解析：
链表插入不需要挪动数据，所以插入效率高。
题三： 3.对于序列{ 12,13,11,18,60,15,7,19,25,100 }，用筛选法建堆，应该从值为（）的数据开始建初始堆
A. 100
B. 12
C. 60
D. 15
答案解析：
一共有10个数据，下标为0--9，建堆需要从最后一层的父节点开始，所以,最后一个元素的父节点为：(9 - 1) / 2 = 4,以4为下标的元素为60.
题四： 4.将整数数组（ 7-6-3-5-4-1-2 ）按照堆排序的方式进行升序排列，请问在第一轮排序结束之后，数组的顺序是（）
A. 1-2-3-4-5-6-7
B. 2-6-3-5-4-1-7">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-10-24T22:35:40+08:00">
    <meta property="article:modified_time" content="2023-10-24T22:35:40+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构：阶段测试(查漏补缺)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="550" src="https://images2.imgbox.com/8e/b6/m4gkgpca_o.png" width="1111"></h2> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E9%80%89%E6%8B%A9%E9%A2%98%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E9%80%89%E6%8B%A9%E9%A2%98%EF%BC%9A" rel="nofollow">选择题：</a></p> 
<p id="%E9%A2%98%E4%B8%80%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E4%B8%80%EF%BC%9A" rel="nofollow">题一：</a></p> 
<p id="%E9%A2%98%E4%BA%8C%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E4%BA%8C%EF%BC%9A" rel="nofollow">题二：</a></p> 
<p id="%E9%A2%98%E4%B8%89%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E4%B8%89%EF%BC%9A" rel="nofollow">题三：</a></p> 
<p id="%E9%A2%98%E5%9B%9B%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E5%9B%9B%EF%BC%9A" rel="nofollow">题四：</a></p> 
<p id="%E7%BC%96%E7%A8%8B%E9%A2%98%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E7%BC%96%E7%A8%8B%E9%A2%98%EF%BC%9A" rel="nofollow">编程题：</a></p> 
<p id="%E9%A2%98%E4%B8%80%EF%BC%9A%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E4%B8%80%EF%BC%9A%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C" rel="nofollow">题一：左叶子之和</a></p> 
<p id="%E6%80%9D%E8%B7%AF%E4%B8%80%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E6%80%9D%E8%B7%AF%E4%B8%80%EF%BC%9A" rel="nofollow">思路一：</a></p> 
<p id="%E9%A2%98%E4%BA%8C%EF%BC%9A%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98%EF%BC%88%E7%94%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E4%BA%8C%EF%BC%9A%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98%EF%BC%88%E7%94%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%EF%BC%89" rel="nofollow">题二：约瑟夫问题（用单链表实现）</a></p> 
<p id="%E6%80%9D%E8%B7%AF%E4%BA%8C%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E6%80%9D%E8%B7%AF%E4%BA%8C%EF%BC%9A" rel="nofollow">思路一：</a></p> 
<p id="%E6%9C%AC%E4%BA%BA%E5%AE%9E%E5%8A%9B%E6%9C%89%E9%99%90%E5%8F%AF%E8%83%BD%E5%AF%B9%E4%B8%80%E4%BA%9B%E5%9C%B0%E6%96%B9%E8%A7%A3%E9%87%8A%E5%92%8C%E7%90%86%E8%A7%A3%E7%9A%84%E4%B8%8D%E5%A4%9F%E6%B8%85%E6%99%B0%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%B7%B1%E5%B0%9D%E8%AF%95%E8%AF%BB%E4%BB%A3%E7%A0%81%EF%BC%8C%E6%88%96%E8%80%85%E8%AF%84%E8%AE%BA%E5%8C%BA%E6%8C%87%E5%87%BA%E9%94%99%E8%AF%AF%EF%BC%8C%E6%9C%9B%E6%B5%B7%E6%B6%B5%EF%BC%81-toc" style="margin-left:0px;"><a href="#%E6%9C%AC%E4%BA%BA%E5%AE%9E%E5%8A%9B%E6%9C%89%E9%99%90%E5%8F%AF%E8%83%BD%E5%AF%B9%E4%B8%80%E4%BA%9B%E5%9C%B0%E6%96%B9%E8%A7%A3%E9%87%8A%E5%92%8C%E7%90%86%E8%A7%A3%E7%9A%84%E4%B8%8D%E5%A4%9F%E6%B8%85%E6%99%B0%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%B7%B1%E5%B0%9D%E8%AF%95%E8%AF%BB%E4%BB%A3%E7%A0%81%EF%BC%8C%E6%88%96%E8%80%85%E8%AF%84%E8%AE%BA%E5%8C%BA%E6%8C%87%E5%87%BA%E9%94%99%E8%AF%AF%EF%BC%8C%E6%9C%9B%E6%B5%B7%E6%B6%B5%EF%BC%81" rel="nofollow">本人实力有限可能对一些地方解释和理解的不够清晰，可以自己尝试读代码，或者评论区指出错误，望海涵！</a></p> 
<p id="%E6%84%9F%E8%B0%A2%E5%A4%A7%E4%BD%AC%E4%BB%AC%E7%9A%84%E4%B8%80%E9%94%AE%E4%B8%89%E8%BF%9E%EF%BC%81%C2%A0%E6%84%9F%E8%B0%A2%E5%A4%A7%E4%BD%AC%E4%BB%AC%E7%9A%84%E4%B8%80%E9%94%AE%E4%B8%89%E8%BF%9E%EF%BC%81%C2%A0%E6%84%9F%E8%B0%A2%E5%A4%A7%E4%BD%AC%E4%BB%AC%E7%9A%84%E4%B8%80%E9%94%AE%E4%B8%89%E8%BF%9E%EF%BC%81-toc" style="margin-left:0px;"><a href="#%E6%84%9F%E8%B0%A2%E5%A4%A7%E4%BD%AC%E4%BB%AC%E7%9A%84%E4%B8%80%E9%94%AE%E4%B8%89%E8%BF%9E%EF%BC%81%C2%A0%E6%84%9F%E8%B0%A2%E5%A4%A7%E4%BD%AC%E4%BB%AC%E7%9A%84%E4%B8%80%E9%94%AE%E4%B8%89%E8%BF%9E%EF%BC%81%C2%A0%E6%84%9F%E8%B0%A2%E5%A4%A7%E4%BD%AC%E4%BB%AC%E7%9A%84%E4%B8%80%E9%94%AE%E4%B8%89%E8%BF%9E%EF%BC%81" rel="nofollow">感谢大佬们的一键三连！ 感谢大佬们的一键三连！ 感谢大佬们的一键三连！</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E9%80%89%E6%8B%A9%E9%A2%98%EF%BC%9A">选择题：</h2> 
<h3 id="%E9%A2%98%E4%B8%80%EF%BC%9A">题一：</h3> 
<blockquote> 
 <p><strong>1.</strong>将长度为n的单链表连接在长度为m的单链表之后,其算法的<strong>时间复杂度为</strong>() </p> 
 <p><strong>A. </strong>O(m)</p> 
 <p><strong>B.</strong> O(1)</p> 
 <p><span style="color:#fe2c24;"><strong>C. O(n)</strong></span></p> 
 <p><strong>D.</strong> O(m+n)</p> 
</blockquote> 
<blockquote> 
 <p><strong>答案解析：</strong></p> 
 <p>        长度为n的单链表链接长度为m的单链表只需要长度为m的单链表的头节点的地址，所以时间复杂度还是O(n)。</p> 
</blockquote> 
<h3 id="%E9%A2%98%E4%BA%8C%EF%BC%9A">题二：</h3> 
<blockquote> 
 <p><strong>2.</strong>以下属于链表的<strong>优点</strong>的是（ ）</p> 
 <p><strong>A.</strong> 用数组可方便实现</p> 
 <p><span style="color:#fe2c24;"><strong>B. 插入操作效率高</strong></span></p> 
 <p><strong>C.</strong> 不用为节点间的逻辑关系而增加额外的存储开销</p> 
 <p><strong>D. </strong>可以按元素号随机访问</p> 
</blockquote> 
<blockquote> 
 <p><strong>答案解析：</strong></p> 
 <p>        链表插入不需要挪动数据，所以插入效率高。</p> 
</blockquote> 
<h3 id="%E9%A2%98%E4%B8%89%EF%BC%9A">题三：</h3> 
<blockquote> 
 <p><strong>3.</strong>对于序列{ 12,13,11,18,60,15,7,19,25,100 }，用筛选法建堆，应该从值为（）的数据<strong>开始建初始堆</strong></p> 
 <p><strong>A.</strong> 100</p> 
 <p><strong>B. </strong>12</p> 
 <p><span style="color:#fe2c24;"><strong>C. 60</strong></span></p> 
 <p><strong>D. </strong>15</p> 
</blockquote> 
<blockquote> 
 <p><strong>答案解析：</strong></p> 
 <p>        一共有10个数据，下标为0--9，建堆需要从最后一层的父节点开始，所以,最后一个元素的父节点为：(9 - 1) / 2 = 4,以4为下标的元素为60.</p> 
</blockquote> 
<h3 id="%E9%A2%98%E5%9B%9B%EF%BC%9A">题四：</h3> 
<blockquote> 
 <p><strong>4.</strong>将整数数组（ 7-6-3-5-4-1-2 ）按照堆排序的方式进行升序排列，请问在<strong>第一轮</strong>排序结束之后，数<strong>组的顺序</strong>是（）</p> 
 <p><strong>A.</strong> 1-2-3-4-5-6-7</p> 
 <p><strong>B.</strong> 2-6-3-5-4-1-7</p> 
 <p><span style="color:#fe2c24;"><strong>C. 6-5-3-2-4-1-7</strong></span></p> 
 <p><strong>D. </strong>5-4-3-2-1-6-7</p> 
</blockquote> 
<blockquote> 
 <p><strong>答案解析：</strong></p> 
 <p>        堆排序实现参考：<a href="https://blog.csdn.net/weixin_71964780/article/details/133839719" title="数据结构：一篇拿捏十大排序(超详细版)-CSDN博客">数据结构：一篇拿捏十大排序(超详细版)-CSDN博客</a>可知C正确。</p> 
</blockquote> 
<h2 id="%E7%BC%96%E7%A8%8B%E9%A2%98%EF%BC%9A">编程题：</h2> 
<h3 id="%E9%A2%98%E4%B8%80%EF%BC%9A%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C">题一：左叶子之和</h3> 
<p><a href="https://www.nowcoder.com/practice/405a9033800b403ba8b7b905bab0463d?tpId=196&amp;tqId=39666&amp;ru=/exam/oj" rel="nofollow" title="左叶子之和_牛客题霸_牛客网 (nowcoder.com)">左叶子之和_牛客题霸_牛客网 (nowcoder.com)</a></p> 
<p><img alt="" height="1145" src="https://images2.imgbox.com/22/4e/kBu30Ygo_o.png" width="1200"></p> 
<h4 id="%E6%80%9D%E8%B7%AF%E4%B8%80%EF%BC%9A">思路一：</h4> 
<p><strong>        第一步：首先：判断是否为空树；</strong></p> 
<p><strong>        第二步：在<span style="color:#fe2c24;">确保当前节点左子树存在</span>的情况下，判断当<span style="color:#fe2c24;">前节点的左子树的左子树和右子树是否为空</span>，为空则记录当前节点的左子树的值；</strong></p> 
<p><strong>        第三步：将<span style="color:#fe2c24;">当前节点继续遍历左子树和右子树进行递归遍历整棵树</span>，将所有符合第二步的节点值记录，最后合并，返回。</strong></p> 
<pre><code class="language-cpp">int sumOfLeftLeaves(struct TreeNode* root ) 
{
    if(root == NULL)
    {
        return 0;
    }
    int sum = 0;
    if(root-&gt;left &amp;&amp; root-&gt;left-&gt;left == NULL &amp;&amp; root-&gt;left-&gt;right == NULL)
    {
        sum +=  root-&gt;left-&gt;val;
    }

    sum += sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right);

    return sum;
}</code></pre> 
<h3 id="%E9%A2%98%E4%BA%8C%EF%BC%9A%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98%EF%BC%88%E7%94%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%EF%BC%89">题二：约瑟夫问题（用单链表实现）</h3> 
<p><a href="https://www.nowcoder.com/questionTerminal/b28d83bef5414b7f814ae76c66b66ff8" rel="nofollow" title="约瑟夫环__牛客网 (nowcoder.com)">约瑟夫环__牛客网 (nowcoder.com)</a></p> 
<p><img alt="" height="828" src="https://images2.imgbox.com/ca/2e/5Fck7HvT_o.png" width="697"></p> 
<h4 id="%E6%80%9D%E8%B7%AF%E4%BA%8C%EF%BC%9A">思路一：</h4> 
<p>        构<strong>建值为1~n的n个节点的循环链表2.实现约瑟夫环，借助cur从链表起始位置开始报数，因为约瑟夫环最终只剩余一个节点，即cur-&gt;next != cur时，说明链表中不止一个节点，则循环进行以下操作报数，即遍历链表，循环m-1次，循环停止时，<span style="color:#fe2c24;">cur即为报m的节点删除该节点，遍历时保存cur的前一个prev，删除cur，然后将cur放在prev的下一个;</span></strong></p> 
<p>        最后剩余的一个节点中的值域就是最后留下来的人。注意：在返回之后一定要把最后一个节点释放掉，否则会有内存泄漏。</p> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1

//约瑟夫问题

#include &lt;stdio.h&gt;
typedef struct List
{
    struct List* front;
    int val;
    struct List* next;
}L;

L* Init(int x)
{
    L* tmp = (L*)malloc(sizeof(L));
    tmp-&gt;val = x;
    tmp-&gt;next = NULL;
    tmp-&gt;front = NULL;

    return tmp;
}

L* DeletNode(L* cur)
{
    L* old = cur-&gt;front;

    old-&gt;next = cur-&gt;next;
    old-&gt;next-&gt;front = old;
    L* new = old-&gt;next;

    free(cur);
    return new;
}

int main()
{
    L l;
    L* prve = Init(0);
    L* count = prve;
    int n, m;
    scanf("%d%d", &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; i++)
    {
        L* tmp = Init(i);
        tmp-&gt;front = prve;
        prve-&gt;next = tmp;
        prve = tmp;
    }

    prve-&gt;next = count-&gt;next;
    count-&gt;next-&gt;front = prve;
    L* cur = prve-&gt;next;
    free(count);

    while (cur-&gt;next != cur)
    {
        for (int j = 0; j &lt; m - 1; j++)
        {
            cur = cur-&gt;next;
        }
        cur = DeletNode(cur);
    }
    printf("%d", cur-&gt;val);

    return 0;
}</code></pre> 
<p></p> 
<h2 id="%E6%9C%AC%E4%BA%BA%E5%AE%9E%E5%8A%9B%E6%9C%89%E9%99%90%E5%8F%AF%E8%83%BD%E5%AF%B9%E4%B8%80%E4%BA%9B%E5%9C%B0%E6%96%B9%E8%A7%A3%E9%87%8A%E5%92%8C%E7%90%86%E8%A7%A3%E7%9A%84%E4%B8%8D%E5%A4%9F%E6%B8%85%E6%99%B0%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%B7%B1%E5%B0%9D%E8%AF%95%E8%AF%BB%E4%BB%A3%E7%A0%81%EF%BC%8C%E6%88%96%E8%80%85%E8%AF%84%E8%AE%BA%E5%8C%BA%E6%8C%87%E5%87%BA%E9%94%99%E8%AF%AF%EF%BC%8C%E6%9C%9B%E6%B5%B7%E6%B6%B5%EF%BC%81">本人实力有限可能对一些地方解释和理解的不够清晰，可以自己尝试读代码，或者评论区指出错误，望海涵！</h2> 
<h2 id="%E6%84%9F%E8%B0%A2%E5%A4%A7%E4%BD%AC%E4%BB%AC%E7%9A%84%E4%B8%80%E9%94%AE%E4%B8%89%E8%BF%9E%EF%BC%81%C2%A0%E6%84%9F%E8%B0%A2%E5%A4%A7%E4%BD%AC%E4%BB%AC%E7%9A%84%E4%B8%80%E9%94%AE%E4%B8%89%E8%BF%9E%EF%BC%81%C2%A0%E6%84%9F%E8%B0%A2%E5%A4%A7%E4%BD%AC%E4%BB%AC%E7%9A%84%E4%B8%80%E9%94%AE%E4%B8%89%E8%BF%9E%EF%BC%81"><a name="t14"></a><a name="t13"></a>感谢大佬们的一键三连！ 感谢大佬们的一键三连！ 感谢大佬们的一键三连！</h2> 
<p>                                              <img alt="" height="234" src="https://images2.imgbox.com/50/56/ioXL0gEJ_o.jpg" width="234"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/594c5799a40afb08abac7820c5b052f4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python中的int()用法用法介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/338f87e5faef14e40c9cac10bd0c46e1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">引领位置服务驱动：腾讯地图 WebService 服务端 API 实用指南</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>