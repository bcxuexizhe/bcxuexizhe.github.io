<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>初始Java篇（JavaSE基础语法）（7）抽象类和接口（上） - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/4c5bde7cb86c8ebbc8d506d31dd7c4cd/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="初始Java篇（JavaSE基础语法）（7）抽象类和接口（上）">
  <meta property="og:description" content="找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：JavaSE
目录
抽象类 抽象类的概念： 抽象类语法
抽象类特性 抽象类的作用
接口 接口的概念：
语法规则
接口使用
接口特性
抽象类 抽象类的概念： 在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。
例如：有一个Animal类其中只有一个bark方法，但是没有具体实现逻辑，那么我们就把这个类称为抽象类。如下图所示：
​
至于为什么可以这样设计呢？因为Animal是动物类，但是又不是一个具体的动物，因此其内部的bark方法就无法具体实现。如果是狗类的话，就可以汪汪汪，如果是猫类的话，就可以喵喵喵。
像这种没有实际工作的方法, 我们可以把它设计成一个 抽象方法(abstract method), 包含抽象方法的类我们称为 抽象类(abstract class)
抽象类语法 在Java中，一个类如果被 abstract 修饰就称为抽象类，抽象类中被 abstract 修饰的方法称为抽象方法，抽象方法不用给出具体的方法体。
// 抽象类的定义格式 // 访问限定修饰符 abstract class 类名 public abstract class Test { //…… } // 抽象方法的定义格式 // abstract 访问限定修饰符 返回值 方法名（参数列表） abstract public void bark() { //…… } 抽象类特性 1. 抽象类不能直接实例化对象。
​
2. 抽象方法不能是 private 的 。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-03T17:24:38+08:00">
    <meta property="article:modified_time" content="2024-05-03T17:24:38+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">初始Java篇（JavaSE基础语法）（7）抽象类和接口（上）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>找往期文章包括但不限于本期文章中不懂的知识点：</p> 
<blockquote> 
 <p><strong>个人主页：</strong><a href="https://blog.csdn.net/2301_80854132?type=blog" title="我要学编程(ಥ_ಥ)-CSDN博客">我要学编程(ಥ_ಥ)-CSDN博客</a></p> 
 <p><strong>所属专栏：</strong><a href="https://blog.csdn.net/2301_80854132/category_12607527.html" title="JavaSE">JavaSE</a></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%8A%BD%E8%B1%A1%E7%B1%BB%C2%A0-toc" style="margin-left:0px;"><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%C2%A0" rel="nofollow">抽象类 </a></p> 
<p id="%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9A%C2%A0-toc" style="margin-left:40px;"><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9A%C2%A0" rel="nofollow">抽象类的概念： </a></p> 
<p id="%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%AF%AD%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%AF%AD%E6%B3%95" rel="nofollow">抽象类语法</a></p> 
<p id="%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%89%B9%E6%80%A7%C2%A0-toc" style="margin-left:40px;"><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%89%B9%E6%80%A7%C2%A0" rel="nofollow">抽象类特性 </a></p> 
<p id="%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8-toc" style="margin-left:40px;"><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8" rel="nofollow">抽象类的作用</a></p> 
<p id="%E6%8E%A5%E5%8F%A3%C2%A0-toc" style="margin-left:0px;"><a href="#%E6%8E%A5%E5%8F%A3%C2%A0" rel="nofollow">接口 </a></p> 
<p id="%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9A" rel="nofollow">接口的概念：</a></p> 
<p id="%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99-toc" style="margin-left:40px;"><a href="#%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99" rel="nofollow">语法规则</a></p> 
<p id="%E6%8E%A5%E5%8F%A3%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#%E6%8E%A5%E5%8F%A3%E4%BD%BF%E7%94%A8" rel="nofollow">接口使用</a></p> 
<p id="%E6%8E%A5%E5%8F%A3%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#%E6%8E%A5%E5%8F%A3%E7%89%B9%E6%80%A7" rel="nofollow">接口特性</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E6%8A%BD%E8%B1%A1%E7%B1%BB%C2%A0"><span style="color:#fe2c24;">抽象类</span> </h2> 
<h3 id="%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9A%C2%A0"><span style="color:#38d8f0;">抽象类的概念：</span> </h3> 
<p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p> 
<p>例如：有一个Animal类其中只有一个bark方法，但是没有具体实现逻辑，那么我们就把这个类称为抽象类。如下图所示：</p> 
<p><img alt="" height="551" src="https://images2.imgbox.com/fc/77/dBzVdusw_o.png" width="994">​</p> 
<p> 至于为什么可以这样设计呢？因为Animal是动物类，但是又不是一个具体的动物，因此其内部的bark方法就无法具体实现。如果是狗类的话，就可以汪汪汪，如果是猫类的话，就可以喵喵喵。</p> 
<p>像这种没有实际工作的方法, 我们可以把它设计成一个 抽象方法(abstract method), 包含抽象方法的类我们称为 抽象类(abstract class)</p> 
<h3 id="%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%AF%AD%E6%B3%95"><span style="color:#38d8f0;">抽象类语法</span></h3> 
<p>在Java中，一个类如果被 abstract 修饰就称为抽象类，抽象类中被 abstract 修饰的方法称为抽象方法，抽象方法不用给出具体的方法体。</p> 
<div> 
 <pre><code class="language-cs">// 抽象类的定义格式
// 访问限定修饰符 abstract class 类名

public abstract class Test {
    //……
}

// 抽象方法的定义格式
// abstract 访问限定修饰符 返回值 方法名（参数列表）

abstract public void bark() {
    //……
}</code></pre> 
</div> 
<h3 id="%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%89%B9%E6%80%A7%C2%A0"><span style="color:#38d8f0;">抽象类特性 </span></h3> 
<p>1. 抽象类不能直接实例化对象。</p> 
<p><img alt="" height="627" src="https://images2.imgbox.com/a2/c7/i7DZHcRg_o.png" width="1200">​</p> 
<p>2. 抽象方法不能是 private 的 。</p> 
<p><img alt="" height="328" src="https://images2.imgbox.com/d4/66/Lpm1HTAa_o.png" width="934">​</p> 
<p>3. 抽象方法不能被final和static修饰，因为抽象方法要被子类重写 </p> 
<p><img alt="" height="485" src="https://images2.imgbox.com/7c/79/m0mXkNNE_o.png" width="949">​</p> 
<p>4. 抽象类必须被继承，并且继承后子类要重写父类中的抽象方法，否则子类也是抽象类，必须要使用 abstract 修饰子类。</p> 
<div> 
 <pre><code class="language-java">abstract class Animal {
    abstract public void bark();
}

abstract class Cat extends Animal {
    abstract public void run();
}

class LittleFlowerCatCat extends Cat {
    //既要重写父类（不一定是直系）的所有抽象方法

    //重写Animal的抽象方法
    @Override
    public void bark() {
        System.out.println("miaomiao");
    }

    //重写Cat的抽象方法
    @Override
    public void run() {
        System.out.println("papa");
    }
}</code></pre> 
</div> 
<p><img alt="" height="1120" src="https://images2.imgbox.com/4b/a6/VkJ47Epl_o.png" width="1200">​</p> 
<p>5. 抽象类中不一定包含抽象方法，但是有抽象方法的类一定是抽象类。</p> 
<p>6. 抽象类中可以有构造方法，供子类创建对象时，初始化父类的成员变量。 </p> 
<h3 id="%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8"><span style="color:#38d8f0;">抽象类的作用</span></h3> 
<blockquote> 
 <p>抽象类本身不能被实例化，要想使用，只能创建该抽象类的子类，然后让子类重写抽象类中的抽象方法。有小伙伴会质疑：普通的类也可以被继承呀，普通的方法也可以被重写呀。为啥非得用抽象类和抽象方法呢? 确实如此。但是使用抽象类相当于多了一重编译器的校验。使用抽象类的场景就如上面的代码，实际工作不应该由父类完成，而应由子类完成。那么此时如果不小心误用成父类了，使用普通类编译器是不会报错的。但是父类是抽象类就会在实例化的时候提示错误, 让我们尽早发现问题。很多语法存在的意义都是为了 "预防出错"，例如我们曾经用过的 final 也是类似。创建的变量用户不去修改，不就相当于常量嘛? 但是加上 final 能够在不小心误修改的时候，让编译器及时提醒我们。充分利用编译器的校验，在实际开发中是非常有意义的。</p> 
</blockquote> 
<h2 id="%E6%8E%A5%E5%8F%A3%C2%A0"><span style="color:#fe2c24;">接口</span> </h2> 
<h3 id="%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9A"><span style="color:#38d8f0;">接口的概念：</span></h3> 
<p>在现实生活中，接口的例子比比皆是，比如：笔记本上的USB口，电源插座等。</p> 
<p>电脑的USB口上，可以插：U盘、鼠标、键盘...所有符合USB协议的设备。</p> 
<p>电源插座插孔上，可以插：电脑、电视机、电饭煲...所有符合规范的设备。</p> 
<p>通过上述例子可以看出：接口就是公共的行为规范标准，大家在实现时，只要符合规范标准，就可以通用。 <strong>在Java中，接口可以看成是：多个类的公共规范，是一种引用数据类型。</strong></p> 
<h3 id="%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99" style="background-color:transparent;"><span style="color:#38d8f0;">语法规则</span></h3> 
<p>接口的定义格式与定义类的格式基本相同，将class关键字换成 interface 关键字，就定义了一个接口。</p> 
<pre><code class="language-java">interface 接口名 {
    // 抽象方法
    public abstract void method1(); // public abstract 是固定搭配，可以不写
    public void method2();
    abstract void method3();
    void method4();
    // 注意：在接口中上述写法都是抽象方法，推荐方式4，代码更简洁
}</code></pre> 
<p>接口前面也可以加访问限定修饰符。</p> 
<p>注意：</p> 
<p>1. 创建接口时，接口的命名一般以大写字母 I 开头。</p> 
<p>2. 接口的命名一般使用 "形容词" 词性的单词。</p> 
<p>3. 阿里编码规范中约定，接口中的方法和属性不要加任何修饰符号（也就是不要加上public abstract），保持代码的简洁性。</p> 
<h3 id="%E6%8E%A5%E5%8F%A3%E4%BD%BF%E7%94%A8"><span style="color:#38d8f0;">接口使用</span></h3> 
<p>接口不能直接使用，必须要有一个"实现类"来"实现"该接口，实现接口中的所有抽象方法。</p> 
<pre><code class="language-java">interface ITest{
    // 抽象方法
    public abstract void method1(); // public abstract 是固定搭配，可以不写
    public void method2();
    abstract void method3();
    void method4();
    // 注意：在接口中上述写法都是抽象方法，跟推荐方式4，代码更简洁
}

//        类        实现      接口 
class TestDrive implements ITest {
    //重写接口中所有的抽象方法
    
    //因为接口中的抽象方法都是由public修饰，因此的方法都是要由public修饰
    @Override
    public void method1() {
        System.out.println("重写method1这个抽象方法");
    }

    @Override
    public void method2() {
        System.out.println("重写method2这个抽象方法");
    }

    @Override
    public void method3() {
        System.out.println("重写method3这个抽象方法");
    }

    @Override
    public void method4() {
        System.out.println("重写method3这个抽象方法");
    }
} </code></pre> 
<p>注意：子类和父类之间是extends（继承）关系，类与接口之间是 implements（实现）关系。 </p> 
<p>练习： 请实现笔记本电脑使用USB鼠标、USB键盘的例子 1. USB接口：包含打开设备、关闭设备功能 2. 笔记本类：包含开机功能、关机功能、使用USB设备功能 3. 鼠标类：实现USB接口，并具备点击功能 4. 键盘类：实现USB接口，并具备输入功能。</p> 
<p>思路：创建一个USB的接口，分别写上打开和关闭 USB设备的抽象方法，再分别由鼠标类和键盘类实现，最后创建一个电脑类，写一个使用USB设备的方法即可。</p> 
<pre><code class="language-java">//创建一个USB接口
interface USB {
    //打开设备和关闭设备的功能
    void open();
    void close();
}


//鼠标类
class Mouse implements USB{
    //实现USB接口
    public void open() {
        System.out.println("打开鼠标，开始点击！");
    }
    public void close() {
        System.out.println("关闭鼠标，结束点击！");
    }
    //实现点击功能
    public void click() {
        System.out.println("正在疯狂点击鼠标~");
    }
}


//键盘类
class KeyBoard implements USB {
    //实现USB接口
    public void open() {
        System.out.println("打开键盘，开始敲击！");
    }
    public void close() {
        System.out.println("关闭键盘，结束敲击！");
    }
    //实现敲击功能
    public void strike() {
        System.out.println("疯狂敲键盘~");
    }
}


//创建一个电脑类
class Computer {
    //开机和关机的功能
    public void open() {
        System.out.println("打开电脑，开始工作！");
    }
    public void close() {
        System.out.println("关闭电脑，结束工作！");
    }
    //使用USB设备
    public void useDrive(USB usb) {
        //打开USB设备
        usb.open();
        //判断是那个设备打开的USB
        if (usb instanceof Mouse) {
            //运行鼠标
            //只有Mouse才有click方法，因此要强制类型转换
            ((Mouse) usb).click();
        }else if (usb instanceof KeyBoard) {
            //运行键盘
            //只有KeyBoard才有Strike方法，因此要强制类型转换
            ((KeyBoard) usb).strike();
        }
        //关闭USB设备
        usb.close();
    }
}


public class TestUsb {
    public static void main(String[] args) {
        //创建一个电脑对象
        Computer computer = new Computer();
        //创建一个鼠标对象
        Mouse mouse = new Mouse();
        //创建一个键盘对象
        KeyBoard keyboard = new KeyBoard();
        //开始使用电脑
        computer.open();
        //开始使用鼠标
        computer.useDrive(mouse);
        //开始使用键盘
        computer.useDrive(keyboard);
        //关闭电脑
        computer.close();
    }
}</code></pre> 
<p><img alt="" height="440" src="https://images2.imgbox.com/18/3f/VX58oILc_o.png" width="1200"></p> 
<p>这里介绍一个关键字 instanceof 。</p> 
<p>功能：用来判断一个对象是否属于某个类或其子类的实例，或者是实现了某个接口。instanceof 键字会返回一个布尔值，如果对象确实是指定类的实例（或者位于该类的继承链上），那么返回true；否则，返回false。</p> 
<p>语法规则：</p> 
<pre><code class="language-java">object instanceof ClassName</code></pre> 
<p>其中，object 是要检查的对象，而 ClassName 是你想确认的类名（也可以是接口名）。这在需要检查对象的实际类型时特别有用，尤其是在进行类型转换之前，以确保转换是安全的，避免抛出ClassCastException 异常。</p> 
<p>在上面那个代码中的用处就是判断usb是否是Mouse或KeyBoard的实例。 </p> 
<h3 id="%E6%8E%A5%E5%8F%A3%E7%89%B9%E6%80%A7"><span style="color:#38d8f0;">接口特性</span></h3> 
<p>1. 接口类型是一种引用类型，但是不能直接new接口的对象。 </p> 
<p>2. 接口中每一个方法都是public的抽象方法, 即接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。</p> 
<p>3. 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现（重写接口中的抽象方法）。</p> 
<p>4. 重写接口中方法时，不能使用默认的访问权限，只能是public修饰。</p> 
<p>5. 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量，即常量。</p> 
<p>注意：接口中的成员变量因为都有final修饰，即常量，因此就要有初始值，否则就会报错。</p> 
<p><img alt="" height="637" src="https://images2.imgbox.com/57/04/dUcKBTQf_o.png" width="1200"></p> 
<p>6. 接口中不能有静态代码块、实例代码块和构造方法。</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/94/0e/tMgGspZ0_o.png" width="1200"></p> 
<p>7. 接口虽然不是类，但是接口编译完成后字节码文件的后缀格式也是.class。</p> 
<p>8. 如果类没有实现接口中的所有的抽象方法，则类必须设置为抽象类。</p> 
<p><img alt="" height="400" src="https://images2.imgbox.com/8c/d1/MxpYEwaw_o.png" width="1048"></p> 
<p>9. jdk8（以后的版本）中新增：接口中还可以包含default方法。 </p> 
<p> 那么这个有什么用途呢？被default修饰的方法可以有方法体。</p> 
<pre><code class="language-java">interface ITest {
    //正常抽象方法
    void method1();
    //被default修饰的抽象方法
    default public void method2(){
        System.out.println("被default修饰的方法，可以有方法体");
    }
}
public class Test implements ITest{
    public void method1(){
        System.out.println("重写method1方法");
    }

    public static void main(String[] args) {
        Test test = new Test();
        test.method1();
        test.method2();
    }
}</code></pre> 
<p><img alt="" height="940" src="https://images2.imgbox.com/86/b2/IAK6D9mm_o.png" width="1200"></p> 
<p> 好啦！本期初始Java篇（JavaSE基础语法）（7）抽象类和接口（上）的学习之旅就到此结束啦！我们下一期再一起学习吧！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f82902ab0ee4f119f9bbdb0d9a43e7b8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JavaEE 初阶篇-深入了解 Junit 单元测试框架和 Java 中的反射机制（使用反射做一个简易版框架）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3f9797f1c31a3de7e122d47c8f9ab0b9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">50个前端实战项目之04：隐藏的搜索小组件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>