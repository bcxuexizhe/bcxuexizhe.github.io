<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>哈希表C&#43;&#43;哈希表详解（知识点&#43;相关LeetCode题目） - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/5f58cf7ee77c268a5acf19a73a55638d/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="哈希表C&#43;&#43;哈希表详解（知识点&#43;相关LeetCode题目）">
  <meta property="og:description" content="目录
前言
一、什么是哈希表
二、哈希表的操作
2.1 操作时间复杂度
2.2 哈希表通用API
2.3 建立哈希表
2.3 哈希表常见结构介绍
Set（集合）
Map（映射）
unordered_map（哈希表）
三、哈希表的力扣经典题目
有效的字母异位词242
两个数组的交集 349
两数之和1
四数相加II 454
三数之和 15
四数之和 18
前言 本文将从哈希表的概念、复杂度、STL实现函数、哈希表相关经典题目展开叙述。
一、什么是哈希表 哈希表是散列表，就是通过关键码值而直接进行访问的一种数据结构
哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素
其内部由一个个key：value 样式的键值对组成。
哈希表中的key通过哈希函数得到内存地址，然后将key和value放到对应的内存地址，从而实现通过key获取Value的方式
哈希碰撞：2个不同的key通过哈希函数（hash function）得到了相同的内存地址，也就是是内存地址已经被一个占用了，解决方法是将其中之一变为链表结构，使用next指向。这样内存地址就不会重复，但是会影响查询
二、哈希表的操作 2.1 操作时间复杂度 1) 搜索：1.无哈希碰撞，直接用哈希函数通过Key定位到内存地址,复杂度O(1) 2.有哈希碰撞，因为存在内存地址需要通过链表查询,复杂度O(N)
2) 插入：通过key找到内存地址插入即可,复杂度 O(1)--自动插入
unorder_map&lt;int,int&gt; InquireMap; InquireMap[val] = 1; 3) 删除：通过key找到内存地址删除即可,复杂度 O(1)
2.2 哈希表通用API begin()：该函数返回一个指向哈希表开始位置的迭代器end()：返回一个指向哈希表结尾位置的下一个元素的迭代器empty()：判断哈希表是否为空，空则返回true，非空返回falsesize()：返回哈希表的大小erase()： 删除某个位置的元素，或者删除某个位置开始到某个位置结束这一范围内的元素， 或者传入key值删除键值对at()：根据key查找哈希表中的元素clear()：清空哈希表中的元素find()：以key作为参数寻找哈希表中的元素，如果哈希表中存在该key值则返回该位置上的迭代器，否则返回哈希表最后一个元素下一位置上的迭代器count()： 统计某个key值对应的元素个数 （注：因为unordered_map不允许重复元素，所以返回值为0或1） 2.3 建立哈希表 unordered_map&lt;char,int&gt; correspond{ {&#39;I&#39;,1}, {&#39;V&#39;,5}, {&#39;X&#39;,10}, {&#39;L&#39;,50}, {&#39;C&#39;,100}, {&#39;D&#39;,500}, {&#39;M&#39;,1000}, }; 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-10-15T10:21:40+08:00">
    <meta property="article:modified_time" content="2023-10-15T10:21:40+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">哈希表C&#43;&#43;哈希表详解（知识点&#43;相关LeetCode题目）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8C%E8%A1%A8-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8C%E8%A1%A8" rel="nofollow">一、什么是哈希表</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C" rel="nofollow">二、哈希表的操作</a></p> 
<p id="2.1%20%E6%93%8D%E4%BD%9C%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:40px;"><a href="#2.1%20%E6%93%8D%E4%BD%9C%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow">2.1 操作时间复杂度</a></p> 
<p id="2.2%20%E5%93%88%E5%B8%8C%E8%A1%A8%E9%80%9A%E7%94%A8API-toc" style="margin-left:40px;"><a href="#2.2%20%E5%93%88%E5%B8%8C%E8%A1%A8%E9%80%9A%E7%94%A8API" rel="nofollow">2.2 哈希表通用API</a></p> 
<p id="2.3%20%E5%BB%BA%E7%AB%8B%E5%93%88%E5%B8%8C%E8%A1%A8-toc" style="margin-left:40px;"><a href="#2.3%20%E5%BB%BA%E7%AB%8B%E5%93%88%E5%B8%8C%E8%A1%A8" rel="nofollow">2.3 建立哈希表</a></p> 
<p id="2.3%20%E5%93%88%E5%B8%8C%E8%A1%A8%E5%B8%B8%E8%A7%81%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#2.3%20%E5%93%88%E5%B8%8C%E8%A1%A8%E5%B8%B8%E8%A7%81%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D" rel="nofollow">2.3 哈希表常见结构介绍</a></p> 
<p id="Set%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89-toc" style="margin-left:80px;"><a href="#Set%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89" rel="nofollow">Set（集合）</a></p> 
<p id="Map%EF%BC%88%E6%98%A0%E5%B0%84%EF%BC%89-toc" style="margin-left:80px;"><a href="#Map%EF%BC%88%E6%98%A0%E5%B0%84%EF%BC%89" rel="nofollow">Map（映射）</a></p> 
<p id="unordered_map%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89-toc" style="margin-left:80px;"><a href="#unordered_map%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89" rel="nofollow">unordered_map（哈希表）</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%8A%9B%E6%89%A3%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%8A%9B%E6%89%A3%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE" rel="nofollow">三、哈希表的力扣经典题目</a></p> 
<p id="%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D242-toc" style="margin-left:40px;"><a href="#%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D242" rel="nofollow">有效的字母异位词242</a></p> 
<p id="%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%20349-toc" style="margin-left:40px;"><a href="#%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%20349" rel="nofollow">两个数组的交集 349</a></p> 
<p id="%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C1-toc" style="margin-left:40px;"><a href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C1" rel="nofollow">两数之和1</a></p> 
<p id="%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II%20454-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II%20454" rel="nofollow">四数相加II 454</a></p> 
<p id="%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2015-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2015" rel="nofollow">三数之和 15</a></p> 
<p id="%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C%2018-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C%2018" rel="nofollow">四数之和 18</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<p>本文将从哈希表的概念、复杂度、STL实现函数、哈希表相关经典题目展开叙述。</p> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8C%E8%A1%A8">一、什么是哈希表</h2> 
<p>哈希表是散列表，就是通过关键码值而直接进行访问的一种数据结构</p> 
<p>哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素</p> 
<p>其内部由一个个key：value 样式的键值对组成。</p> 
<p>哈希表中的key通过哈希函数得到内存地址，然后将key和value放到对应的内存地址，从而实现通过key获取Value的方式</p> 
<p>哈希碰撞：2个不同的key通过哈希函数（<strong>hash function</strong>）得到了相同的内存地址，也就是是内存地址已经被一个占用了，解决方法是将其中之一变为链表结构，使用next指向。这样内存地址就不会重复，但是会影响查询</p> 
<p></p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C">二、哈希表的操作</h2> 
<h3 id="2.1%20%E6%93%8D%E4%BD%9C%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">2.1 操作时间复杂度</h3> 
<p>1) 搜索：1.无哈希碰撞，直接用哈希函数通过Key定位到内存地址,复杂度O(1)                                               2.有哈希碰撞，因为存在内存地址需要通过链表查询,复杂度O(N)</p> 
<p>2) 插入：通过key找到内存地址插入即可,复杂度 O(1)--自动插入</p> 
<pre><code class="language-cpp">unorder_map&lt;int,int&gt; InquireMap;
InquireMap[val] = 1;</code></pre> 
<p>3) 删除：通过key找到内存地址删除即可,复杂度 O(1)</p> 
<h3 id="2.2%20%E5%93%88%E5%B8%8C%E8%A1%A8%E9%80%9A%E7%94%A8API">2.2 哈希表通用API</h3> 
<blockquote> 
 <ul><li><strong>begin()</strong>：该函数返回一个指向哈希表开始位置的迭代器</li><li><strong>end()</strong>：返回一个指向<span style="background-color:#d7d8d9;">哈希表结尾位置的下一个元素</span>的迭代器</li><li><strong>empty()</strong>：判断哈希表是否为空，空则返回true，非空返回false</li><li><strong>size()</strong>：返回哈希表的大小</li><li><strong>erase()</strong>： 删除某个位置的元素，或者删除某个位置开始到某个位置结束这一范围内的元素， 或者传入key值删除键值对</li><li><strong>at()</strong>：根据key查找哈希表中的元素</li><li><strong>clear()</strong>：清空哈希表中的元素</li><li><strong>find()</strong>：以key作为参数寻找哈希表中的元素，如果哈希表中存在该key值则返回该位置上的迭代器，否则返回哈希表<span style="background-color:#d7d8d9;">最后一个元素下一位置</span>上的迭代器</li><li><strong>count()</strong>： 统计某个key值对应的元素个数 （注：因为unordered_map不允许重复元素，所以返回值为0或1）</li></ul> 
</blockquote> 
<h3></h3> 
<h3></h3> 
<h3 id="2.3%20%E5%BB%BA%E7%AB%8B%E5%93%88%E5%B8%8C%E8%A1%A8">2.3 建立哈希表</h3> 
<pre><code class="language-cpp">unordered_map&lt;char,int&gt; correspond{
        {'I',1},
        {'V',5},
        {'X',10},
        {'L',50},
        {'C',100},
        {'D',500},
        {'M',1000},
    };</code></pre> 
<p></p> 
<h3 id="2.3%20%E5%93%88%E5%B8%8C%E8%A1%A8%E5%B8%B8%E8%A7%81%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D">2.3 哈希表常见结构介绍</h3> 
<p>总体结构上分为数组、set、map</p> 
<p>数组也是一种意义上的哈希表</p> 
<p>set的结构中每个元素都是一个值（类似于数组）</p> 
<p>map的结构是一个 key:value 的数据结构</p> 
<h4 id="Set%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89">Set（集合）</h4> 
<p>1） set、multiset 基于红黑树（一种平衡二叉搜索树），所以（key）值都是有序的，但是不可以修改，一旦修改就会引起整棵树的错乱，所以只能删除和增加，两者唯一的区别是前者不可重复（key）值，后者可以重复</p> 
<p>2）unordered_set 底层实现为哈希表，区别就是没有关键码这个说法,哈希表是无序的，所以查询效率要快些O(1)就可以实现。因为无序，所以值也不可以重复</p> 
<p>小结：当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。</p> 
<p>这三种数据结构的具体优劣在这里引用一张表来直观体现</p> 
<table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table> 
<p></p> 
<h4 id="Map%EF%BC%88%E6%98%A0%E5%B0%84%EF%BC%89">Map（映射）</h4> 
<p>1）map、multimap  基于红黑树（一种平衡二叉搜索树），key是有序的，和上面提到的set、multimap一样，key值可以添加、删除，但是不可以更改（map中，对key是有限制，对value没有限制的。所以说value值可以修改）两者唯一的区别是前者不可重复key值，后者可以重复</p> 
<p>2）unordered_map 底层实现为哈希表（无序），因为无序，所以key也不可以重复</p> 
<table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td> <p>O(1)</p> <p></p> </td></tr></tbody></table> 
<p></p> 
<h4 id="unordered_map%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89">unordered_map（哈希表）</h4> 
<p>这个数据结构更加常用，所以在这里特别讲一下它的性质</p> 
<ul><li>unordered_map底层存储的是&lt;key,value&gt;键值对，可以通过key快速的索引到value unordered_map内部因为是数据是通过映射存入哈希桶内的，所以对unordered_map进行遍历得到的是一个无序的序列。</li><li>unordered_map通过key进行访问的速度比map快，但是遍历元素的迭代效率就要低于map了。unordered_map也实现了operator[ ] 可以通过key直接访问到value</li></ul> 
<p></p> 
<h2 id="%E4%B8%89%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%8A%9B%E6%89%A3%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE">三、哈希表的力扣经典题目</h2> 
<p></p> 
<h3 id="%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D242">有效的字母异位词242</h3> 
<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p> 
<p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p> 
<p>示例 1:</p> 
<p>输入: s = "anagram", t = "nagaram"<br> 输出: true</p> 
<p></p> 
<div> 
 <pre><code class="language-cpp">class Solution {
public:
    bool isAnagram(string s, string t) {
        int hash[26] = {0};//26个英文字符
        for(int i =0 ;i&lt;s.size();i++){
            hash[s[i]-'a']++;
        }

        for(int i =0 ;i&lt;t.size();i++){
            hash[t[i]-'a']--;
        }

        for(int i =0 ;i&lt;26;i++){
            if(hash[i] != 0){
                return false;
            }
        }
        return true;
    }
};</code></pre> 
</div> 
<p><strong>题解:</strong></p> 
<p>使用哈希表的一种实现方式--数组--通过索引存储对应的值。</p> 
<p>具体体现于每一个元素与‘a’的差值作为索引，出现次数作为索引对应的值，通过判断出现次数是否相同（为0）得到题解</p> 
<p></p> 
<p></p> 
<h3 id="%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%20349">两个数组的交集 349</h3> 
<p>给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。</p> 
<p></p> 
<p>示例 1：</p> 
<p>输入：nums1 = [1,2,2,1], nums2 = [2,2]<br> 输出：[2]</p> 
<p></p> 
<div> 
 <pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        unordered_set&lt;int&gt; result;
        unordered_set&lt;int&gt; nums1_map(nums1.begin(),nums1.end());
        for(int i=0;i&lt;nums2.size();i++){
            if(nums1_map.find(nums2[i]) != nums1_map.end()){
                //说明是交集
                result.insert(nums2[i]);
            }
        }

        return vector&lt;int&gt;(result.begin(),result.end());
    }
};</code></pre> 
</div> 
<p><strong>题解：</strong></p> 
<p>由于交集是限制了返回唯一的元素，所以需要有一种数据结构既可以存储相同的元素，又可以返回唯一的值。使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。</p> 
<p>思路是将vector容器中的所有元素，以键值对的方式存入unordered_set容器中，此时已经去重复了，对应的key只会存在一个</p> 
<p>利用find的方法判断是否和nums2匹配，匹配就将元素存入result哈希表容器中，最终转化为vector容器返回即可</p> 
<p></p> 
<h3 id="%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C1">两数之和1</h3> 
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p> 
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p> 
<p>你可以按任意顺序返回答案。</p> 
<p></p> 
<p>示例 1：</p> 
<p>输入：nums = [2,7,11,15], target = 9<br> 输出：[0,1]<br> 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p> 
<div> 
 <pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        //分别将数值作为key，下标作为value
        unordered_map&lt;int,int&gt; result;
        for(int i =0;i&lt;nums.size();i++){
            auto turn = result.find(target-nums[i]);
            if(turn!= result.end()){
                //存在则返回
                return {turn-&gt;second,i};
            }else{
            result.insert(pair&lt;int,int&gt;(nums[i],i));
            }
        }
        return {};
    }
};</code></pre> 
</div> 
<p><strong>题解：</strong></p> 
<p>两数之和可以转换为有序存储的同时，计算有没有满足的存在</p> 
<p>并且由于需要比较大小，还需要返回下标，所以要进行map的存储方式</p> 
<p></p> 
<p></p> 
<h3 id="%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II%20454">四数相加II 454</h3> 
<p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</p> 
<p>0 &lt;= i, j, k, l &lt; n<br> nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0<br>  </p> 
<p>示例 1：</p> 
<p>输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]<br> 输出：2<br> 解释：<br> 两个元组如下：<br> 1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0<br> 2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0</p> 
<p></p> 
<div> 
 <pre><code class="language-cpp">class Solution {
public:
    int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) {
        unordered_map&lt;int,int&gt; countAB;
        int count = 0;
        for(int i : nums1){
            for(int j : nums2){
                countAB[i+j]++;//储存起来数值对应的次数
            }
        }

        for(int i : nums3){
            for(int j : nums4){
                //因为c++会自动给未创建的键值对自动增加
                int target = 0 - (i+j);
                if(countAB.find(target)!=countAB.end()){
                    count += countAB[target];
                }
            }
        }

        return count;
    }
};</code></pre> 
</div> 
<p><strong>题解：</strong></p> 
<p>首先考虑存储每种结果对应的次数，结果不可重复，所以在这里，最好使用unordered_map来实现，</p> 
<p>原理是得出nums1和nums2的所有结果（每一种对应几种可能），然后再遍历让nums3+nums4每一种可能对应的结果去查询nums1+nums2的结果，如果满足条件（<code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code>），总结果加上哈希表中对应的结果的次数，最终返回的就是所有结果的次数</p> 
<p></p> 
<p></p> 
<h3 id="%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2015">三数之和 15</h3> 
<p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请</p> 
<p>你返回所有和为 0 且不重复的三元组。</p> 
<p>注意：答案中不可以包含重复的三元组。</p> 
<p></p> 
<p>示例 1：</p> 
<p>输入：nums = [-1,0,1,2,-1,-4]<br> 输出：[[-1,-1,2],[-1,0,1]]<br> 解释：<br> nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。<br> nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。<br> nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。<br> 不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。<br> 注意，输出的顺序和三元组的顺序并不重要。</p> 
<div> 
 <pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {
        int left=0,right=0;
        vector&lt;vector&lt;int&gt;&gt; result;//定义返回的数组
        sort(nums.begin(),nums.end());
        for(int i = 0;i&lt;nums.size();i++){
            if(nums[i]&gt;0){
                break;//说明已经不可能存在了
            }

            if(i&gt;0 &amp;&amp; nums[i] == nums[i-1]){
                continue;//去重，该数字如果已经用过了，就不再用了
            }

            left = i+1;
            right = nums.size()-1;
             
             
            //基于当前的nums[i]进行后面所有可能的存入result 
            while(left &lt; right){
                int sumNum = nums[i]+nums[left]+nums[right]; 
                if(sumNum &gt; 0){
                    right--;
                }else if(sumNum &lt; 0){
                    left++;
                }else{
                    result.push_back(vector&lt;int&gt;{nums[i],nums[left],nums[right]});//插入一整个数组

                    //去重
                    while(right &gt; left &amp;&amp; nums[right] == nums[right-1]){
                        right--;
                    }

                    while(right &gt; left &amp;&amp; nums[left] == nums[left+1]){
                        left++;
                    }
                    
                    //当去完重之后进行原来的操作--收缩指针--原先的都已经用过了，已经为恰好满足
                    right--;
                    left++;
                }
            }
        }

        return result;
    }
};</code></pre> 
</div> 
<p><strong>题解：</strong></p> 
<p>整体上的思路是用双指针替代了哈希表的算法。因为需要返回一个二维数组，并且包括每一种可能，并且还要不重复，所以在这里使用双指针去重的思路。</p> 
<p>排序整个数组，从不重复的数字开始，作为i元素，之后在后面的区间里设置j和k两个元素在其各自去重的情况下，计算和是否满足为0，j和k两个元素作为双指针从i+1的位置和size-1的位置向中心移动，移动时检测去重，最终返回结果</p> 
<p></p> 
<p></p> 
<h3 id="%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C%2018">四数之和 18</h3> 
<p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p> 
<p>0 &lt;= a, b, c, d &lt; n<br> a、b、c 和 d 互不相同<br> nums[a] + nums[b] + nums[c] + nums[d] == target<br> 你可以按 任意顺序 返回答案 。</p> 
<p></p> 
<p>示例 1：</p> 
<p>输入：nums = [1,0,-1,0,-2,2], target = 0<br> 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</p> 
<p></p> 
<div> 
 <pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {
        sort(nums.begin(),nums.end());
        vector&lt;vector&lt;int&gt;&gt; result;
        //顺序k，i，left，right
        for(int k =0;k&lt;nums.size();k++){
            if(nums[k] &gt; target &amp;&amp; nums[k] &gt;=0){
                //剪枝处理--便于执行（只大于不等于--因为等于可能也是一种解法 target 0 0 0）
                //因为只要求k，i，left，right互不相同就可以，去重也是为了防止元素间的对应，就比如当前这个元素使用过了，就不能再使用，两个是分开的意思
                break;
            }

            if(k&gt;0 &amp;&amp; nums[k]==nums[k-1]){
                continue;//去重
            }

            for(int i=k+1;i&lt;nums.size();i++){
                if(nums[i]+nums[k] &gt; target &amp;&amp; nums[i]+nums[k] &gt;= 0){
                    //剪枝处理的原理是当前的元素大于target，并且两元素大于0，说明后面不可能成立了（都大于0）
                    break;
                }

                //去重一定是从k之后元素开始算，因为这也是i的范围
                if(i&gt;k+1 &amp;&amp; nums[i] == nums[i-1]){
                    continue;
                }

                int left = i+1;
                int right = nums.size()-1;

                while(left &lt;right){
                    long targetNum =(long)nums[k]+nums[i]+nums[left]+nums[right];

                    if(targetNum &gt; target){
                        right--;
                    }else if(targetNum &lt; target){
                        left++;
                    }else{
                        result.push_back(vector&lt;int&gt;{nums[k],nums[i],nums[left],nums[right]});

                        while(left &lt;right &amp;&amp; nums[right]== nums[right-1]){
                            right--;
                        }
                        while(left &lt;right &amp;&amp; nums[left]==nums[left+1]){
                            left++;
                        }

                        //这里再一步的原因是当前的rightleft仍为之前的rightleft
                        right--;
                        left++;
                    }
                }
            }
        }

        return result;
    }
};</code></pre> 
</div> 
<p><strong>题解：</strong></p> 
<p>总体上的思路和三数之和相似，但是外面包裹了一层K的判断，就相当于k和i都已经确定，两者分别要进行剪枝和去重的操作，内部仍然是双指针的循环判断</p> 
<p><strong>注意：剪枝和处理的原理</strong></p> 
<p>剪枝处理--便于执行（只大于不等于--因为等于可能也是一种解法 target 0 0 0）<br> 因为只要求k，i，left，right互不相同就可以，去重也是为了防止元素间的对应，就比如当前这个元素使用过了，就不能再使用，两个是分开的意思</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c919ab4b16493509c001ef650265792e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">详解Leetcode中关于malloc模拟开辟二维数组问题，涉及二维数组的题目所给函数中的各个参数的解读</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9cae95064c77e27f85659d9318c7af9b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">手把手带你用Python和文心一言搭建《AI看图写诗》网页项目（附上完整项目源码）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>