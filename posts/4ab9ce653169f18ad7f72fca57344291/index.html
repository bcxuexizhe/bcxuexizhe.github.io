<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>继承初级入门复习 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/4ab9ce653169f18ad7f72fca57344291/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="继承初级入门复习">
  <meta property="og:description" content="注意：保护和私有在类中没有区别，但是在继承中有区别，private在继承的子类不可见，protect在继承的子类可见 记忆方法：先看基类的修饰符是private，那都是不可见的。如果不是，那就用继承的修饰和基类的修饰比较谁小取谁-----&gt;public&gt;protect&gt;private
#include &lt;iostream&gt; using namespace std; class Person { protected: string _name; string _sex; int _age; }; class Student :public Person { public: int _No; }; int main() { Person p; Student s; //子类和父类之间赋值兼容规则 //1、子类对象可以赋值父类对象/指针/引用 p = s; Person* p1 = &amp;s; Person&amp; p1 = s; return 0; } 注意：父类不可以赋值给子类，有一种情况就是父类指向子类，再赋值给另一个子类
不同作用域（隐藏（重定义）） class Person { protected: string _sex; int _age=111; }; class Student :public Person { public: void f() { cout &lt;&lt; _age &lt;&lt; endl; } public: int _age=99; }; int main() { Student s; s.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-20T23:05:46+08:00">
    <meta property="article:modified_time" content="2024-05-20T23:05:46+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">继承初级入门复习</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="197" src="https://images2.imgbox.com/24/d1/wCFIpqd8_o.png" width="688"></p> 
<p><img alt="" height="323" src="https://images2.imgbox.com/94/d0/kc7jdL8b_o.png" width="745"></p> 
<blockquote> 
 <p>注意：保护和私有在类中没有区别，但是在继承中有区别，private在继承的子类不可见，protect在继承的子类可见 </p> 
 <p>记忆方法：先看基类的修饰符是private，那都是不可见的。如果不是，那就用继承的修饰和基类的修饰比较谁小取谁-----&gt;public&gt;protect&gt;private</p> 
</blockquote> 
<p><img alt="" height="404" src="https://images2.imgbox.com/4d/1f/8J18KOfi_o.png" width="746"></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
class Person
{
protected:
	string _name;
	string _sex;
	int _age;
};
class Student :public Person
{
public:
	int _No;
};
int main()
{
	Person p;
	Student s;

	//子类和父类之间赋值兼容规则
	//1、子类对象可以赋值父类对象/指针/引用
	p = s;
	Person* p1 = &amp;s;
	Person&amp; p1 =  s;
	return 0;
}</code></pre> 
<p><img alt="" height="521" src="https://images2.imgbox.com/6e/92/1iZ4kBzO_o.png" width="582"></p> 
<blockquote> 
 <p>注意：父类不可以赋值给子类，有一种情况就是父类指向子类，再赋值给另一个子类</p> 
</blockquote> 
<p><img alt="" height="228" src="https://images2.imgbox.com/ea/05/h5hmqSep_o.png" width="536"></p> 
<h3>不同作用域（隐藏（重定义））</h3> 
<pre><code class="language-cpp">class Person
{
protected:
	string _sex;
	int _age=111;
};
class Student :public Person
{
public:
	void f()
	{
		cout &lt;&lt; _age &lt;&lt; endl;
	}
public:
	int _age=99;
};
int main()
{
	Student s;
	s.f();
}

</code></pre> 
<p><img alt="" height="530" src="https://images2.imgbox.com/5a/13/7bQAxCFe_o.png" width="1092"></p> 
<p><img alt="" height="561" src="https://images2.imgbox.com/ad/0e/YFyAUo7V_o.png" width="797"></p> 
<p></p> 
<h3>面向对象的三大特性</h3> 
<p>封装（类的封装）、继承、多态</p> 
<p>实际上面向对象不只三大特性</p> 
<p><img alt="" height="199" src="https://images2.imgbox.com/44/30/2wBMJ52y_o.png" width="768"></p> 
<h3>派生类的默认成员函数</h3> 
<p><img alt="" height="251" src="https://images2.imgbox.com/58/df/5qNahRgf_o.png" width="720"></p> 
<p><img alt="" height="640" src="https://images2.imgbox.com/a6/71/iUnqVQPR_o.png" width="1200"></p> 
<blockquote> 
 <p><strong>注意：如果是自定义类型就会调用自己的默认构造函数(struct  class)</strong></p> 
</blockquote> 
<p><strong>如何在子类中初始化父类部分呢？</strong></p> 
<blockquote> 
 <pre><code class="language-cpp">class Person
{
public:
	Person(const char* name)
		:_name(name)
	{

		cout &lt;&lt; "Person()" &lt;&lt; _name&lt;&lt; endl;
	}
	~Person()
	{
		cout &lt;&lt; "~Person()" &lt;&lt; endl;
	}
private:
	string _name;
};
class Student : public Person
{
public:
	Student(const char* name,int age)//所以要加const这个块空间是只读
		:Person(name),
		_stuid(age)

	{

	}
protected:
	int _stuid;
};
int main()
{
	Student a("joker",1);//传入常量字符串
	return 0;
}
</code></pre> 
 <p><img alt="" height="206" src="https://images2.imgbox.com/ed/5b/rclq6jSV_o.png" width="613"></p> 
</blockquote> 
<blockquote> 
 <p><strong>父类继承部分一定要调用父类去完成，如果不显示调用的话也会自动调用父类的构造函数</strong></p> 
</blockquote> 
<p>假设1：</p> 
<p><img alt="" height="717" src="https://images2.imgbox.com/f2/ea/e46rtaSS_o.png" width="1200"></p> 
<blockquote> 
 <p>默认构造函数包括无参、全缺省、系统默认生成的</p> 
 <p>如果是系统调用的默认构造函数内置类型是不会处理的，只有自定义类型才会处理</p> 
</blockquote> 
<p>假设2：</p> 
<p><img alt="" height="824" src="https://images2.imgbox.com/66/e3/cjY9JohQ_o.png" width="971"></p> 
<h3><strong>如何完成子类拷贝构造呢？</strong></h3> 
<p>什么是拷贝构造？</p> 
<p>1、拷贝构造的参数只有一个，该参数的类型是对象类型的引用，为什么要引用？因为防止无限的调用拷贝构造去递归，一般用const修饰</p> 
<p>2、要区分深拷贝和浅拷贝的问题，系统默认生成的拷贝函数的内存存储方式是字节序存储所以要注意成员变量类型的，防止释放两次同一个空间</p> 
<p>复习完成</p> 
<pre><code class="language-cpp">class Person
{
public:
	Person(const char*name="")
		:_name(name)
	{
		cout &lt;&lt;_name &lt;&lt; "Person()" &lt;&lt; endl;
	}
	Person(const Person&amp; p1)
		:_name(p1._name)
	{
		cout &lt;&lt; "Person(const Person&amp; p1)" &lt;&lt; endl;
	}
private:
	string _name;
};
class Student :Person
{
public:
	Student(const char*name,int id)
		:Person(name),//要以父类名()的方式调用父类构造函数初始化子类中的父类部分
		_stuid(id)
	{
		cout &lt;&lt; "student()" &lt;&lt; endl;
	}
	Student(const Student&amp; s1)
		:Person(s1)//要以父类名()的方式调用父类的拷贝构造函数  复制子类中的父类部分
	{
		_stuid = s1._stuid;
		cout &lt;&lt; "Student(const Student&amp; s1)" &lt;&lt; endl;
	}
private:
	int _stuid;
};

int main()
{
	//Person p1("aaa");
	Student s1("bbb",9);//初始化
	Student s2(s1);//拷贝构造
	//Student s3 ("gg",30);//初始化
	//s1 = s3;//s1.operator=(s3)

	return 0;
}</code></pre> 
<blockquote> 
 <p><strong>注意：只有显示的用父类(子类对象)的显示调用方式才可以调用父类的拷贝构造，系统不会自动调用父类的拷贝构造这个和初始化构造不一样</strong></p> 
</blockquote> 
<h3>子类的operator=：</h3> 
<pre><code class="language-cpp">class Person
{
public:
//初始化
	Person(const char*name="")
		:_name(name)
	{
		cout &lt;&lt;_name &lt;&lt; "Person()" &lt;&lt; endl;
	}
//拷贝
	Person(const Person&amp; p1)
		:_name(p1._name)
	{
		cout &lt;&lt; "Person(const Person&amp; p1)" &lt;&lt; endl;
	}
//父类的operator=函数
	Person&amp; operator=(const Person&amp; s1)
	{
		if (this != &amp;s1)
		{
			_name = s1._name;
			cout &lt;&lt; "Person&amp; operator=(const Person&amp; s1)" &lt;&lt; endl;
		}
		return *this;
	}
private:
	string _name;//string(const char*s1)
};
class Student :Person
{
public:
	Student(const char*name,int id)
		:Person(name),
		_stuid(id)
	{
		cout &lt;&lt; "student()" &lt;&lt; endl;
	}
	Student(const Student&amp; s1)
		:Person(s1)//要以父类名()的方式调用父类的拷贝初始化子类中的父类部分
	{
		_stuid = s1._stuid;
		cout &lt;&lt; "Student(const Student&amp; s1)" &lt;&lt; endl;
	}
//operator=
	Student&amp; operator=(const Student&amp; s1)
	{
		if (this != &amp;s1)//防止赋值时，两个对象时一个对象，浪费时间
		{
			Person::operator=(s1);//显示调用父类的operator=，将父类的部分赋值
			_stuid = s1._stuid;
			cout &lt;&lt; "Student&amp; operator=(const Student&amp; s1)" &lt;&lt; endl;
		}
		return *this;//返回子类的对象
	}
private:
	int _stuid;
};

int main()
{
	//Person p1("aaa");
	Student s1("bbb",9);//初始化
	Student s2(s1);//拷贝构造
	//Student s3 ("gg",30);//初始化
	//s1 = s3;//s1.operator=(s3)

	return 0;
}</code></pre> 
<h3><strong>子类的析构函数 </strong></h3> 
<blockquote> 
 <p><strong>注意：</strong></p> 
 <p><strong>1、子类的初始化时先父后子，所以析构就是先子后父，类似于stack</strong></p> 
 <p><strong>2、虽然父类的析构和子类的析构名字不相同，但是子类和父类的析构会被统一的处理成destructor构成隐藏</strong></p> 
 <p><strong>3、系统已经实现好当子类析构完成了，就会自动调用父类的析构</strong></p> 
</blockquote> 
<p><img alt="" height="756" src="https://images2.imgbox.com/9a/38/h14fgARq_o.png" width="719"></p> 
<h3></h3> 
<h3>面试题</h3> 
<h4>如何构建一个不可以继承的类</h4> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class A
{
private:   //将父类的初始化私有化
   A()
   {
   }
}
class B:public A
{
  
}
int main()
{
   B b;//初始化不了对象
   return 0;
}</code></pre> 
<h3> 友元关系不能被继承(了解就好)</h3> 
<p>会报错，要是想用只可以手动添加</p> 
<p><img alt="" height="448" src="https://images2.imgbox.com/35/5a/N9JyyXDQ_o.png" width="490"></p> 
<p></p> 
<h3>静态成员在父类中被继承会发生什么？</h3> 
<pre><code class="language-cpp">
class Person
{
public:
	Person()
	{
		_count++;
	}

public:
	string _name;
	static int _count;
};

int Person::_count = 0;//静态成员必须初始化

class Student:public Person
{
public:
private:
	int id;
};

int main()
{
	Person p1;
	Student s1; 
	p1._name = "jack";
	s1._name = "rose";
	p1._count = 1;
	s1._count = 2;
	cout &lt;&lt; Person::_count &lt;&lt; endl;//静态成员属于对象也属于类所以可以Person::_count
	return 0;
}</code></pre> 
<p><img alt="" height="547" src="https://images2.imgbox.com/ee/56/Z81gUaK1_o.png" width="1200"></p> 
<p><img alt="" height="411" src="https://images2.imgbox.com/40/d8/ezRagO8T_o.png" width="863"></p> 
<blockquote> 
 <p><strong>static 成员属于对象也是属于类的，子类继承下来的静态成员和父类是一样的它们调用同一个静态成员变量</strong></p> 
</blockquote> 
<h3></h3> 
<h3>多继承</h3> 
<blockquote> 
 <p><strong>什么叫单继承：只有一个父类</strong></p> 
 <p><strong>所以多继承：就是有多个父类</strong></p> 
</blockquote> 
<p><img alt="" height="862" src="https://images2.imgbox.com/ef/2b/AJtfSwjJ_o.png" width="778"></p> 
<p><strong>多继承会造成很多问题的，所以后来的语言是没有多继承的，多继承是一个大坑</strong></p> 
<p><strong>为什么是大坑？</strong></p> 
<blockquote> 
 <p>因为多继承的一种特殊的继承菱形继承，会造成数据冗余和二义性</p> 
</blockquote> 
<pre><code class="language-cpp">class Person
{
public:
	string _name; // 姓名
};
class Student : public Person
{
protected:
	int _num; //学号
};
class Teacher : public Person
{
protected:
	int _id; // 职工编号
};
class Assistant : public Student, public Teacher
{
protected:
	string _majorCourse; // 主修课程
};
void Test()
{
	// 这样会有二义性无法明确知道访问的是哪一个
	Assistant a;
	a._name = "peter";//菱形继承会导致二义性不知道是那个的_name
	// 需要显示指定访问哪个父类的成员可以解决二义性问题，但是数据冗余问题无法解决
	a.Student::_name = "xxx";
	a.Teacher::_name = "yyy";
}</code></pre> 
<p>菱形继承：</p> 
<p><img alt="" height="344" src="https://images2.imgbox.com/7d/1e/gaekfeII_o.png" width="584"></p> 
<p><img alt="" height="59" src="https://images2.imgbox.com/e3/2e/ozbtHoua_o.png" width="705"></p> 
<h4>菱形继承原理</h4> 
<p>experiment：</p> 
<pre><code class="language-cpp">class A
{
public:
	int _a;
};
class B:public A
{
public:
	int _b;
};
class C :public A
{
public:
	int _c;
};
class D:public B , public C
{
public:
	int _d;
};
int main()
{
	D d;
	d.B::_a = 1;
	d.C::_a = 2;
	d._b = 3;
	d._c = 4;
	d._d = 5;
	return 0;
}</code></pre> 
<p><strong>进入调试看内存</strong></p> 
<p><img alt="" height="433" src="https://images2.imgbox.com/5c/c3/FSNIeXq8_o.png" width="1200"></p> 
<p><strong>这是内存模型，存在数据冗余和二义性</strong></p> 
<p><strong>但是我们要看虚继承的内存模型</strong></p> 
<pre><code class="language-cpp">using namespace std;
class A
{
public:
	int _a;
};
class B:virtual public A//添加了virtual
{
public:
	int _b;
};
class C :virtual public A
{
public:
	int _c;
};
class D:public B , public C
{
public:
	int _d;
};
int main()
{
	D d;
	d.B::_a = 1;
	d.C::_a = 2;
	d._b = 3;
	d._c = 4;
	d._d = 5;
	return 0;
}
</code></pre> 
<p><strong>进入调试内存</strong></p> 
<p><img alt="" height="457" src="https://images2.imgbox.com/d0/a7/mCneiWeU_o.png" width="1200"></p> 
<p><strong>接下来看看这些是什么？</strong></p> 
<p><strong>好像是地址</strong></p> 
<p><strong>再次进入内存</strong></p> 
<blockquote> 
 <p><strong>存在偏移量，存放偏移量的地方又叫虚基表</strong></p> 
</blockquote> 
<p><img alt="" height="564" src="https://images2.imgbox.com/a1/93/xu202IvZ_o.png" width="1200"></p> 
<p><img alt="" height="89" src="https://images2.imgbox.com/e7/16/LFHHaqJo_o.png" width="754"></p> 
<p><strong>为什么要设计出来呢？</strong></p> 
<blockquote> 
 <p><strong>因为菱形继承会出现数据冗余和二义性，所以virtual继承是为了解决二义性和数据冗余</strong></p> 
</blockquote> 
<p><strong>菱形继承：</strong></p> 
<p><img alt="" height="595" src="https://images2.imgbox.com/82/1b/gW5AIZty_o.png" width="819"></p> 
<p><strong>虚继承：</strong></p> 
<p><img alt="" height="612" src="https://images2.imgbox.com/8c/e5/8Vlc4onh_o.png" width="1015"></p> 
<h5><strong>为什么虚继承会比菱形继承还大呢？</strong></h5> 
<p><strong>是因为多了两个指针 </strong></p> 
<p><img alt="" height="121" src="https://images2.imgbox.com/d0/cc/OQxhjCdC_o.png" width="224"></p> 
<p><strong>我相信很多同学会问不是解决数据冗余吗？为什么越来越大了</strong></p> 
<p><strong>因为基类太小了</strong></p> 
<p></p> 
<p><strong>菱形继承：</strong></p> 
<p><img alt="" height="614" src="https://images2.imgbox.com/13/01/IMRQeV9D_o.png" width="821"></p> 
<p><strong>虚继承：</strong></p> 
<p><img alt="" height="639" src="https://images2.imgbox.com/d9/34/wvIUhDY9_o.png" width="777"></p> 
<p><strong>少了一倍</strong></p> 
<p></p> 
<p><strong>这就是虚继承的基本概念</strong></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ae16804d338d59496fab18dd56debe15/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">题解：CF1969B（Shifts and Sorting）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8f2f0a6a5dc8a49290d2f13877be79b0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">代码随想录算法训练营第五十九天</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>