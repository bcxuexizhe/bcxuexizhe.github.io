<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>链表经典面试题 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/3e640d9381ab3e02e42a4ba34fb817db/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="链表经典面试题">
  <meta property="og:description" content="以下的每个题都配有链接，大家可以点击进入进行练习，想了解更多知识可以关注以下个人主页
敲上瘾-CSDN博客
目录
1.反转链表
2.回文链表
3.相交链表
4.环形链表
5.合并两个有序链表
1.反转链表 分析：首先确定函数的返回值，需要返回的是反转后的头节点，显然，返转后的头结点是原链表的尾结点，而原链表的头结点应该指向NULL。
方法一：使用一个结构体指针数组，将每一个结点存入数组内，然后把arr[0]的下一个结点指向NULL，arr[1]的下一个结点指向arr[0]，以此类推。然后把数组最后一个元素返回。此方法空间复杂度为O(n)，时间复杂度为O(n)。
方法二：这个题就是让我们把头结点的next指向NULL，然后把后面的每个结点的next都指向前一个结点，可以使用三个指针变量比如n1，n2，n3。n1=NULL，n2=head，n3=head-&gt;next。n2存放的是需要改变的结点，n1存放的是前一个结点(防止前结点找不到)，n3存放后一个结点(防止后结点丢失)，然后每完成一次反转，这三个指针同时往右移一位。空间复杂度为O(1)，时间复杂度为O(n)。如下图：
代码演示： struct ListNode* reverseList(struct ListNode* head) { if(head==NULL||head-&gt;next==NULL) return head; struct ListNode* n1=NULL,*n2=head,*n3=head-&gt;next; while(n2) { n2-&gt;next=n1; n1=n2; n2=n3; if(n3) n3=n3-&gt;next; } return n1; } 2.回文链表 分析：回文链表的特性是对称性，也就是它关于中间结点对称，即链表节点序列从后往前看和从前往后看是相同的，实例1从前往后看和从后往前看都是1,2,3,3,2,1。是一个回文链表。 方法一：使用结构体指针数组储存各节点(也可用整型数组直接储存各节点对应的值)，然后从最左边和最右边开始比较它们对应的值，然后两边同时往中间移，直到比较到最中间元素都相等为止，则为回文链表。空间复杂度为O(n)，时间复杂度为O(n)。因为该方法空间复杂度为O(n)，效率比较低，在这里就不在展示，来看方法二。
方法二：因为回文链表具有对称性，所以把链表从中间分为两段，后半段反转后是和前半段相同的。所以现在要做的是把后半段反转，首先就需要找到中间节点，如何来找呢？，有一个巧妙的方法，就是用快慢指针，快指针每次走两步，慢指针每次走一步。这样快指针走完整个链表，慢指针刚好走完链表的一半，此时慢指针指向的位置就是链表的中间节点。然后把该节点当做头节点进行反转变成新的链表最后与前半段进行比较。空间复杂度为O(1)，时间复杂度为O(n)。
struct ListNode* Fnod(struct ListNode* head)//反转链表 { struct ListNode* n1=NULL,*n2=head,*n3=head-&gt;next; while(n2) { n2-&gt;next=n1; n1=n2; n2=n3; if(n3) n3=n3-&gt;next; } return n1; } bool isPalindrome(struct ListNode* head) { if(!head) return false; if(head-&gt;next==NULL) return true; struct ListNode* p1=head,*p2=head; while(p2&amp;&amp;p2-&gt;next)//找中间节点 { p1=p1-&gt;next; p2=p2-&gt;next-&gt;next; } struct ListNode* fp= Fnod(p1); while(fp&amp;&amp;head)//比较 { if(fp-&gt;val!">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-06T11:51:01+08:00">
    <meta property="article:modified_time" content="2024-05-06T11:51:01+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">链表经典面试题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>以下的每个题都配有链接，大家可以点击进入进行练习，想了解更多知识可以关注以下个人主页</p> 
 <p><a href="https://blog.csdn.net/2302_80105876?spm=1000.2115.3001.5343" title="敲上瘾-CSDN博客">敲上瘾-CSDN博客</a></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#1.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8" rel="nofollow">1.反转链表</a></p> 
<p id="2.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#2.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8" rel="nofollow">2.回文链表</a></p> 
<p id="3.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#3.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8" rel="nofollow">3.相交链表</a></p> 
<p id="4.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#4.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8" rel="nofollow">4.环形链表</a></p> 
<p id="5.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%C2%A0-toc" style="margin-left:0px;"><a href="#5.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%C2%A0" rel="nofollow">5.合并两个有序链表</a></p> 
<hr id="hr-toc"> 
<h2>1.<a class="link-info" href="https://leetcode.cn/problems/reverse-linked-list/description/" rel="nofollow" title="反转链表">反转链表</a></h2> 
<p><img alt="" height="699" src="https://images2.imgbox.com/04/23/YxXPihQj_o.png" width="984"></p> 
<p>        分析：首先<span style="color:#fe2c24;">确定函数的返回值</span>，需要返回的是反转后的头节点，显然，返转后的头结点是原链表的尾结点，而原链表的头结点应该指向NULL。</p> 
<p>        方法一：使用一个<span style="color:#ff9900;">结构体指针数组</span>，将每一个结点存入数组内，然后把arr[0]的下一个结点指向NULL，arr[1]的下一个结点指向arr[0]，以此类推。然后把数组最后一个元素返回。此方法<u>空间复杂度为O(n)，时间复杂度为O(n)</u>。</p> 
<p>        方法二：这个题就是让我们把头结点的next指向NULL，然后把后面的每个结点的next都指向前一个结点，可以<span style="color:#a2e043;">使用三个指针变量</span>比如n1，n2，n3。n1=NULL，n2=head，n3=head-&gt;next。<span style="color:#ff9900;"><u>n2存放的是需要改变的结点，n1存放的是前一个结点(防止前结点找不到)，n3存放后一个结点(防止后结点丢失)</u></span>，然后每完成一次反转，<span style="color:#a2e043;">这三个指针同时往右移一位</span>。<u>空间复杂度为O(1)，时间复杂度为O(n)</u>。如下图：</p> 
<p><img alt="" height="405" src="https://images2.imgbox.com/58/85/smgCWRZd_o.png" width="751"></p> 
<p><img alt="" height="452" src="https://images2.imgbox.com/2b/87/UvKA1v0d_o.png" width="761"></p> 
<p><img alt="" height="392" src="https://images2.imgbox.com/9f/44/qdbTgKgO_o.png" width="751"></p> 
<p>代码演示： </p> 
<pre><code class="language-cpp">struct ListNode* reverseList(struct ListNode* head) {
    if(head==NULL||head-&gt;next==NULL)
        return head;
    struct ListNode* n1=NULL,*n2=head,*n3=head-&gt;next;
    while(n2)
    {
        n2-&gt;next=n1;
        n1=n2;
        n2=n3;
        if(n3)
            n3=n3-&gt;next;
    }
    return n1;
}</code></pre> 
<h2 id="2.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8">2.<a class="link-info" href="https://leetcode.cn/problems/palindrome-linked-list/description/" rel="nofollow" title="回文链表">回文链表</a></h2> 
<p><img alt="" height="996" src="https://images2.imgbox.com/a9/93/3O2djLk7_o.png" width="976"></p> 
<p>        分析：回文链表的特性是<span style="color:#fe2c24;">对称性</span>，也就是它关于中间结点对称，即链表节点序列从后往前看和从前往后看是相同的，实例1从前往后看和从后往前看都是1,2,3,3,2,1。是一个回文链表。 </p> 
<p>        方法一：使用<span style="color:#fe2c24;">结构体指针数组</span>储存各节点(也可用整型数组直接储存各节点对应的值)，然后从<u><span style="color:#a2e043;">最左边和最右边开始比较它们对应的值，然后两边同时往中间移</span></u>，直到比较到最中间元素都相等为止，则为回文链表。空间复杂度为O(n)，时间复杂度为O(n)。因为该方法空间复杂度为O(n)，效率比较低，在这里就不在展示，来看方法二。</p> 
<p>        方法二：因为回文链表具有对称性，所以把链表<span style="color:#ff9900;">从中间分为两段</span>，后半段反转后是和前半段相同的。所以现在要做的是<span style="color:#ff9900;">把后半段反转</span>，首先就需要<strong>找到<a class="link-info" href="https://leetcode.cn/problems/middle-of-the-linked-list/description/" rel="nofollow" title="中间节点">中间节点</a></strong>，如何来找呢？，有一个巧妙的方法，就是用快慢指针，<span style="color:#fe2c24;">快指针每次走两步，慢指针每次走一步</span>。这样快指针走完整个链表，慢指针刚好走完链表的一半，此时慢指针指向的位置就是链表的中间节点。然后把该节点当做头节点进行反转变成新的链表最后与前半段进行比较。<u>空间复杂度为O(1)，时间复杂度为O(n)</u>。</p> 
<pre><code class="language-cpp">struct ListNode* Fnod(struct ListNode* head)//反转链表
{
    struct ListNode* n1=NULL,*n2=head,*n3=head-&gt;next;
    while(n2)
    {
        n2-&gt;next=n1;
        n1=n2;
        n2=n3;
        if(n3)
            n3=n3-&gt;next;
    }
    return n1;
}
bool isPalindrome(struct ListNode* head) {
    if(!head)
        return false;
    if(head-&gt;next==NULL)
        return true;
    struct ListNode* p1=head,*p2=head;
    while(p2&amp;&amp;p2-&gt;next)//找中间节点
    {
        p1=p1-&gt;next;
        p2=p2-&gt;next-&gt;next;
    }
    struct ListNode* fp= Fnod(p1);
    while(fp&amp;&amp;head)//比较
    {
        if(fp-&gt;val!=head-&gt;val)
            return false;
        fp=fp-&gt;next;
        head=head-&gt;next;
    }
    return true;
}</code></pre> 
<h2 id="3.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8">3.<a class="link-info" href="https://leetcode.cn/problems/3u1WK4/description/" rel="nofollow" title="相交链表">相交链表</a></h2> 
<p><img alt="" height="1151" src="https://images2.imgbox.com/83/35/ndiEEob7_o.png" width="965"></p> 
<p>        方法一(暴力算法)：用<span style="color:#fe2c24;">链表A的每一个元素与链表B比较一遍</span>，如果出现相同的地方则链表相交，并返回该节点。<u>空间复杂度为O(1)，时间复杂度为O(nm)</u>。</p> 
<p>        方法二(构造栈空间)：我们观察到的第2个特点是如果两个链表有重合节点，那么这些重合节点一定只出现在链表的尾部。如果两个单向链表有重合节点，那么从某个节点开始这两个链表的next指针都指向同一个节点。在单向链表中，每个节点只有一个 next指针，因此在第1个重合节点开始之后它们的所有节点都是重合的，不可能再出现分叉。<br>         <u><strong>由于重合节点只可能出现在链表的尾部，因此可以从两个链表的尾部开始向前比较，最后一个相同节点就是我们要找的节点。</strong></u>但是在单向链表中，只能从头节点开始向后遍历，直至到达尾节点。最后到达的尾节点却要最先被比较，这就是通常所说的<span style="color:#ff9900;">"后进先出"</span>。至此不难想到可以用栈来解决这个问题：<u><span style="color:#fe2c24;">分别把两个链表的节点放入两个栈，这样两个链表的尾节点就位于两个栈的栈顶。接下来比较两个栈的栈顶节点是否相同。如果相同，则把栈顶节点弹出，然后比较下一个栈顶节点，直到找到最后一个相同的节点</span></u><span style="color:#fe2c24;">。</span><u>空间复杂度为O(n+m)，时间复杂度为O(n+m)</u>。</p> 
<p>        方法三(双指针)：首先遍历两个链表得到它们的长度，比如<span style="color:#fe2c24;">长度差</span>为n，则比较长的链表先走n步使它们<span style="color:#fe2c24;">长度对齐</span>，然后两个链表再一起走，如果有交点的话它们必然会相遇。<u>空间复杂度为O(1)，时间复杂度为O(n+m)</u>。</p> 
<p>        方法四(双指针)：基于方法三还有一个更巧妙的方法，使用两个速度相同的指针p1和p2，<span style="color:#ff9900;">指针p1从链表A跑完后跑链表B，指针p2从链表B跑完后跑链表A，每跑一次比较一次</span>，因为它们路程相同，速度相同，当它们有节点的时候必然会相遇。空间复杂度为O(1)，时间复杂度为O(n+m)。</p> 
<pre><code class="language-cpp">struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    struct ListNode*p1=headA,*p2=headB;
    while(p1!=p2)
    {
        p1=p1!=NULL?p1-&gt;next:headB;
        p2=p2!=NULL?p2-&gt;next:headA;
    }
    return p1;
}</code></pre> 
<h2 id="4.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8">4.<a class="link-info" href="https://leetcode.cn/problems/linked-list-cycle-ii/description/" rel="nofollow" title="环形链表">环形链表</a></h2> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/a4/10/B6x7SP4W_o.png" width="962"></p> 
<p>        分析：首先我们用<span style="color:#fe2c24;">快慢指针来判断是否有环</span>，快指针p2每次走两步，慢指针p1每次走一步，如果有环他们必然相遇。看似很显然，不过我们依然需要证明一下，进行深入理解(在后面图中给出证明)。</p> 
<p>        如果没有环，即快指针会先走到NULL，直接返回NULL即可。如果有环，我们<span style="color:#ff9900;">求一下环的长度</span>，即让快指针停留在他们相遇的位置，只让慢指针走，每走一步计一次数，直到他们再次相遇，所计的数即为环的长度，记为c。</p> 
<p>   <em>     </em>最后再用两个指针从头开始跑，第1个指针<span style="color:#ff9900;">先跑c步</span>以后，第二个指针再开始跑，因为环的长度为c，所以<u>第2个指针跑完一圈环后，刚好回到环的入口点与第1个指针相遇</u>。那么这样就找到环的入口点了。</p> 
<p>        该方法可以把它优化一下，不用计算环的长度，当快慢指针相遇时，假设慢指针走了m步，那么快指针就走了2m步。那么它们的差值(即m)就是<span style="color:#fe2c24;">环长度的整数倍</span>。现在相当于慢指针p1提前走了m步，只需要再找一个慢指针p3，从头节点开始，两慢指针同时走，到它们相遇时即为环的入口点。</p> 
<p>        当然这个题我们不能止步于此，我们试着给出以上证明，并且分析更复杂的情况(即快指针一次走3步，4步，甚至更多可不可以解决这个问题)。</p> 
<p><img alt="" height="554" src="https://images2.imgbox.com/fb/50/mIubAKlh_o.png" width="999"></p> 
<p>慢指针一次走1步，快指针一次走3步的情况(其它情况与这个类似分析，就不在赘述)：</p> 
<p><img alt="" height="549" src="https://images2.imgbox.com/09/5c/LU9FO0BG_o.png" width="718"></p> 
<p>现在要考虑的是n为奇数c为偶数这种情况有没有可能不会同时出现？</p> 
<p>答案是确实不会的，证明如下：</p> 
<p><img alt="" height="250" src="https://images2.imgbox.com/41/05/Qu9VfVCl_o.png" width="745"></p> 
<p>以上只是证明了用快慢指针来判断是否有环的问题。下面来证明环的入口的查找。</p> 
<p><img alt="" height="398" src="https://images2.imgbox.com/9e/5b/2BqoThFB_o.png" width="738"></p> 
<p>代码演示：</p> 
<pre><code class="language-cpp">struct ListNode *detectCycle(struct ListNode *head) {
    if(!head||!head-&gt;next)
        return NULL;
    struct ListNode* s1=head,*s2=head,*k1=head;
    while(s2&amp;&amp;s2-&gt;next)
    {
        s1=s1-&gt;next;
        s2=s2-&gt;next-&gt;next;
        if(s1==s2)
        {
            while(k1!=s1)
            {
                k1=k1-&gt;next;
                s1=s1-&gt;next;
            }
            return k1;
        }
    }
    return NULL;
}</code></pre> 
<h2 id="5.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%C2%A0" style="background-color:transparent;">5.<a class="link-info" href="https://leetcode.cn/problems/merge-sorted-array/description/" rel="nofollow" title="合并两个有序链表 ">合并两个有序链表 </a></h2> 
<p><img alt="" height="857" src="https://images2.imgbox.com/08/7a/q6213fXp_o.png" width="732">        方法一：使用<span style="color:#fe2c24;">结构体指针数组</span>将它们有序的储存到同一个数组当中，然后在把数组的从头至尾的元素链接在一起。</p> 
<p>         方法二：创建一个新的结构体指针变量，然后遍历两个链表，将两个链表中的节点有序的连接到新创建的节点中，构成一个<span style="color:#fe2c24;">新的带头链表</span>，然后返回头结点的next。</p> 
<pre><code class="language-cpp">typedef struct ListNode ListNode;
struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {
    if(list1==NULL||list2==NULL)
        return list1==NULL?list2:list1;
    ListNode* ph=(ListNode*)malloc(sizeof(ListNode));
    ListNode* head=ph;
    while(list1&amp;&amp;list2)
    {
        if(list1-&gt;val&lt;=list2-&gt;val)
        {
            ph-&gt;next=list1;
            list1=list1-&gt;next;
        }
        else
        {
            ph-&gt;next=list2;
            list2=list2-&gt;next;
        }
        ph=ph-&gt;next;
    }
    if(list1)
        ph-&gt;next=list1;
    if(list2)
        ph-&gt;next=list2;
    ph=head-&gt;next;
    free(head);
    return ph;
}</code></pre> 
<p>        <u>总结以上方法我们可以发现每个链表相关的题几乎都可以构造一个<span style="color:#fe2c24;">结构体指针数组</span>来解决，确实这个方法逻辑简单，更容易被我们想到，不过这种<span style="color:#ff9900;">空间复杂度为O(n)</span>的算法，不足以拿到offer。只适合像<span style="color:#4da8ee;">暴力算法</span>一样把它当做为最后的选择。</u></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/815a919ecadf08f015b4165c4c04b8b1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ChatGPT 4.0 直接用 ！！！Code Copilot编程大模型、DALL-E AI绘图、绘制流程图、上传文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fbe43324ab3517f589a1028f81638e32/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">揭秘实时渲染技术在AI去衣中的神奇魔法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>