<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;初阶学习第九弹——探索STL奥秘（四）——vector的深层挖掘和模拟实现 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/e1e483cfca8ee54cf497c8aa89292878/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="C&#43;&#43;初阶学习第九弹——探索STL奥秘（四）——vector的深层挖掘和模拟实现">
  <meta property="og:description" content="string（上）：C&#43;&#43;初阶学习第六弹——探索STL奥秘（一）——标准库中的string类-CSDN博客
string（下）：C&#43;&#43;初阶学习第七弹——探索STL奥秘（二）——string的模拟实现-CSDN博客
vector（上）：C&#43;&#43;初阶学习第八弹——探索STL奥秘（三）——深入刨析vector的使用-CSDN博客
前言：
在前面我们已经学习了string的使用及其模拟实现，并且我们也已经学习了vector的使用，今天我们就来学习一下vector的模拟实现
目录
一、 vector的基本成员变量
二、 vector的逐步实现
1、构造和销毁
2、迭代器相关
3、容量相关
4、元素访问
5、vector的修改操作
三、总结
一、 vector的基本成员变量 我们之前已经学习了vector的使用，所以也基本了解了其机制，现在我们来看一下vector工作的基本机制
从图中我们可以看出，vector的操作机制实际上是通过三个指针来实现的：
_start、_finish、_endOfStorage
所以vector的基本成员变量为：
#include&lt;iostream&gt; using namespace std; //命名一个命名空间，在这个命名空间中实现我们自己的vector，这样能避免受库中vector的影响 namespace zda { template&lt;class T&gt; class vector { privated: T* _start; //指向有效数据的头 T* _finish; //指向有效数据的尾 T* _endOfStorage; //指向容量的尾 }; } 因为vector的本质上与顺序表很相似，只是存储的数据上变的更加多元化了，所以我们可以对基本成员做一些调整，将其改成迭代器相关的，方便我们后面写类成员函数
改进后：
#include&lt;iostream&gt; using namespace std; //命名一个命名空间，在这个命名空间中实现我们自己的vector，这样能避免受库中vector的影响 namespace zda { template&lt;class T&gt; class vector { public: // Vector的迭代器是一个原生指针 typedef T* iterator; typedef const T* const_iterator; privated: iterator _start; //指向有效数据的头 iterator _finish; //指向有效数据的尾 iterator _endOfStorage; //指向容量的尾 }; } 接下来，我们就开始进入今天的正题，模拟vector的五大步骤：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-22T22:08:15+08:00">
    <meta property="article:modified_time" content="2024-05-22T22:08:15+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;初阶学习第九弹——探索STL奥秘（四）——vector的深层挖掘和模拟实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>string（上）：</strong><a href="https://blog.csdn.net/2301_80220607/article/details/138662335?spm=1001.2014.3001.5502" title="C++初阶学习第六弹——探索STL奥秘（一）——标准库中的string类-CSDN博客">C++初阶学习第六弹——探索STL奥秘（一）——标准库中的string类-CSDN博客</a></p> 
<p><strong>string（下）：</strong><a href="https://blog.csdn.net/2301_80220607/article/details/138785146?spm=1001.2014.3001.5502" title="C++初阶学习第七弹——探索STL奥秘（二）——string的模拟实现-CSDN博客">C++初阶学习第七弹——探索STL奥秘（二）——string的模拟实现-CSDN博客</a></p> 
<p><strong>vector（上）：</strong><a href="https://blog.csdn.net/2301_80220607/article/details/139008935?spm=1001.2014.3001.5502" title="C++初阶学习第八弹——探索STL奥秘（三）——深入刨析vector的使用-CSDN博客">C++初阶学习第八弹——探索STL奥秘（三）——深入刨析vector的使用-CSDN博客</a></p> 
<p><strong>前言：</strong></p> 
<blockquote> 
 <p>在前面我们已经学习了string的使用及其模拟实现，并且我们也已经学习了vector的使用，今天我们就来学习一下vector的模拟实现</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80%E3%80%81%20vector%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%20vector%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F" rel="nofollow">一、 vector的基本成员变量</a></p> 
<p id="%E4%BA%8C%E3%80%81%20vector%E7%9A%84%E9%80%90%E6%AD%A5%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%20vector%E7%9A%84%E9%80%90%E6%AD%A5%E5%AE%9E%E7%8E%B0" rel="nofollow">二、 vector的逐步实现</a></p> 
<p id="1%E3%80%81%E6%9E%84%E9%80%A0%E5%92%8C%E9%94%80%E6%AF%81-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E6%9E%84%E9%80%A0%E5%92%8C%E9%94%80%E6%AF%81" rel="nofollow">1、构造和销毁</a></p> 
<p id="2%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%85%B3-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%85%B3" rel="nofollow">2、迭代器相关</a></p> 
<p id="3%E3%80%81%E5%AE%B9%E9%87%8F%E7%9B%B8%E5%85%B3-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E5%AE%B9%E9%87%8F%E7%9B%B8%E5%85%B3" rel="nofollow">3、容量相关</a></p> 
<p id="4%E3%80%81%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE" rel="nofollow">4、元素访问</a></p> 
<p id="5%E3%80%81vector%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#5%E3%80%81vector%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C" rel="nofollow">5、vector的修改操作</a></p> 
<p id="%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93" rel="nofollow">三、总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E4%B8%80%E3%80%81%20vector%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">一、 vector的基本成员变量</h3> 
<blockquote> 
 <p>我们之前已经学习了vector的使用，所以也基本了解了其机制，现在我们来看一下vector工作的基本机制</p> 
</blockquote> 
<p><img alt="" height="1113" src="https://images2.imgbox.com/69/4d/nzV2h5pD_o.png" width="1045"></p> 
<p><strong>从图中我们可以看出，vector的操作机制实际上是通过三个指针来实现的：</strong></p> 
<p><strong><span style="background-color:#ffd900;">_start、_finish、_endOfStorage</span></strong></p> 
<p>所以vector的基本成员变量为：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
//命名一个命名空间，在这个命名空间中实现我们自己的vector，这样能避免受库中vector的影响
namespace zda
{
	template&lt;class T&gt;
	class vector
	{
	privated:
		T* _start;      //指向有效数据的头
		T* _finish;     //指向有效数据的尾
		T* _endOfStorage;    //指向容量的尾
	};
}</code></pre> 
<blockquote> 
 <p>因为vector的本质上与顺序表很相似，只是存储的数据上变的更加多元化了，所以我们可以对基本成员做一些调整，将其改成迭代器相关的，方便我们后面写类成员函数</p> 
</blockquote> 
<p><strong>改进后：</strong></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
//命名一个命名空间，在这个命名空间中实现我们自己的vector，这样能避免受库中vector的影响
namespace zda
{
	template&lt;class T&gt;
	class vector
	{
	public:
		// Vector的迭代器是一个原生指针
		typedef T* iterator;
		typedef const T* const_iterator;

	privated:
		iterator _start;      //指向有效数据的头
		iterator _finish;     //指向有效数据的尾
		iterator _endOfStorage;    //指向容量的尾
	};
}</code></pre> 
<p><strong>接下来，我们就开始进入今天的正题，模拟vector的五大步骤：</strong></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>1、构造和销毁</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>2、迭代器相关</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>3、容量相关</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>4、元素访问</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>5、vector的修改操作</strong></span></p> 
</blockquote> 
<h3 id="%E4%BA%8C%E3%80%81%20vector%E7%9A%84%E9%80%90%E6%AD%A5%E5%AE%9E%E7%8E%B0"><span style="color:#0d0016;">二、 vector的逐步实现</span></h3> 
<h4 id="1%E3%80%81%E6%9E%84%E9%80%A0%E5%92%8C%E9%94%80%E6%AF%81"><span style="color:#0d0016;">1、构造和销毁</span></h4> 
<p><span style="color:#0d0016;"><span style="background-color:#ffd900;">构造的方法主要有以下五种：</span></span></p> 
<blockquote> 
 <p><strong>·  默认构造</strong></p> 
 <p><strong>· 构造同时将前n个初始化</strong></p> 
 <p><strong>· 迭代器构造法</strong></p> 
 <p><strong>· 拷贝构造</strong></p> 
 <p><strong>· operator=运算符重载</strong></p> 
</blockquote> 
<pre><code class="language-cpp">		//一、vector的构造销毁
		//1、默认构造
		vector()
			:_start(nullptr)
			,__finish(nullptr)
			,_endOfStorage(nullptr)
		{}

		//2、构造同时将前n个初始化
		vector(size_t n, const T&amp; m = T())
			:_start(nullptr)
			, __finish(nullptr)
			, _endOfStorage(nullptr)
		{
			reserve(n);     //开辟n个大小的空间，这个函数在后面
			while (n--)
			{
				push_back(m);     //尾插，也在后面讲
			}
		}
		//但是上面这个函数会有一个特殊情况出现
		//例如对于vector&lt;int&gt; v(5,3)
		//由于v中的参数是(int，int)，所以编译器容易把它与迭代器相关的函数去配对
		//所以对于上面这个函数我们又写了一个vector(int n, const T&amp; m = T())类型的来避免错误发生
		//这种情况下参数一定都为int型的，所以我们可以按顺序表的方式来写这个函数
		vector(int n, const T&amp; m = T())
			:_start(new T[n])
			, __finish(nullptr)
			, _endOfStorage(nullptr)
		{
			for (int i = 0; i &lt; n; i++)
			{
				_start[i] = m;
			}
		}

		//3、迭代器构造法
		//为了实现不同迭代器的传参构造，我们这里再创建一个迭代器模板
		template&lt;class InputInterator&gt;
		vector(InputInterator first, InputInterator last)
		{
			while (fast != last)
			{
				push_back(*first);     //尾插的时候会检查扩容，所以也可以不写reserve函数
				first++;
			}
		}

		//4、拷贝构造
		vector(const vector&lt;T&gt;&amp; v)
			:_start(nullptr)
			,_finish(nullptr)
			,_endOfStorage(nullptr)
		{
			reserve(v.capacity());
			iterator it = begin();
			const_iterator vit = v.cbegin();       //这里涉及到const迭代器的内容，也是在后面讲
			while (vit != v.cend())
			{
				*it++ = *vit++;
			}
			_finish = it;
		}

		//5、operator=运算符重载
		vector&lt;T&gt;&amp; operator=(vector&lt;T&gt; v)
		{
			swap(v);    //由于这里的v是对目标对象的复制，是开辟的新空间，所以我们完全可以swap直接交换而得
			return *this;
		}

		//析构
		~vector()
		{
			if (_start)
			{
				delete _start;
				_start = _finish = _endOfStorage = nullptr;
			}
		}
</code></pre> 
<h4 id="2%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%85%B3">2、迭代器相关</h4> 
<pre><code class="language-cpp">		// 迭代器相关(迭代器主要就是找到头尾）
		iterator begin()
		{
			return _start;
		}

		iterator end()
		{
			return _finish;
		}

		const_iterator cbegin() const
		{
			return _start;
		}

		const_iterator cend() const
		{
			return _finish;
		}
</code></pre> 
<h4 id="3%E3%80%81%E5%AE%B9%E9%87%8F%E7%9B%B8%E5%85%B3">3、容量相关</h4> 
<p>容量相关的最重要的就是扩容，就是reserve函数，同时我们也需要注意一下resize函数，这两者各自的特点需要记清，这些前面文章有讲到，我们这里只<strong>强调一下：</strong></p> 
<blockquote> 
 <p>resize函数即可以扩容，也可以缩容，同时还可以初始化，这个函数创造性挺大</p> 
</blockquote> 
<pre><code class="language-cpp">size_t size() const
{
	return _finish - _start;
}

size_t capacity() const
{
	return _endOfStorage - _start;
}

bool empty() const
{
	return _start == _finish;
}

void reserve(size_t n)
{
	if (n &gt; capacity())
	{
		size_t oldSize = size();
		// 1. 开辟新空间
		T* tmp = new T[n];

		// 2. 拷贝元素
		// 这里不能直接使用memcpy，原因我们将放到下面专门讲
		//if (_start)
		//	memcpy(tmp, _start, sizeof(T)*size);

		if (_start)
		{
			for (size_t i = 0; i &lt; oldSize; ++i)
				tmp[i] = _start[i];

			// 3. 释放旧空间
			delete[] _start;
		}

		_start = tmp;
		_finish = _start + oldSize;
		_endOfStorage = _start + n;
	}
}

void resize(size_t n, const T&amp; value = T())
{
	// 1.如果n小于当前的size，则数据个数缩小到n
	if (n &lt;= size())
	{
		_finish = _start + n;
		return;
	}

	// 2.空间不够则增容
	if (n &gt; capacity())
		reserve(n);

	// 3.将size扩大到n
	iterator it = _finish;
	_finish = _start + n;
	while (it != _finish)
	{
		*it = value;
		++it;
	}
}</code></pre> 
<h4 id="4%E3%80%81%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE">4、元素访问</h4> 
<blockquote> 
 <p>元素访问关键就是运算符重载（operator[ ]），由于我们定义的类成员变量是以指针形式的，所以我们其实很容易实现这个重载</p> 
</blockquote> 
<pre><code class="language-cpp">// 元素访问
T&amp; operator[](size_t pos)
{
	assert(pos &lt; size());
	return _start[pos];
}

const T&amp; operator[](size_t pos)const
{
	assert(pos &lt; size());
	return _start[pos];
}

T&amp; front()
{
	return *_start;
}

const T&amp; front()const
{
	return *_start;
}

T&amp; back()
{
	return *(_finish - 1);
}

const T&amp; back()const
{
	return *(_finish - 1);
}</code></pre> 
<h4 id="5%E3%80%81vector%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C">5、vector的修改操作</h4> 
<blockquote> 
 <p>vector的修改操作最关键的就是insert函数和erase函数，就是在任意位置插入和删除，尾插尾删可以直接调用这两个函数来实现，但这两个函数细节也挺多，具体实现细节看下面实现过程</p> 
</blockquote> 
<p><img alt="" height="281" src="https://images2.imgbox.com/86/db/wgwnRsYp_o.png" width="1200"></p> 
<pre><code class="language-cpp">// vector的修改操作
void push_back(const T&amp; x)      //尾插，可以直接调用insert函数
{
	insert(end(), x);
}

void pop_back()         //尾删，跟尾插一样，可以调用erase函数
{
	erase(end() - 1);
}

void swap(vector&lt;T&gt;&amp; v)      //这个交换函数在上面构造时是有用到的
{
	std::swap(_start, v._start);
	std::swap(_finish, v._finish);
	std::swap(_endOfStorage, v._endOfStorage);
}

iterator insert(iterator pos, const T&amp; x)
{
	assert(pos &lt;= _finish);

	// 空间不够先进行增容
	if (_finish == _endOfStorage)
	{
		//size_t size = size();
		size_t newCapacity = (0 == capacity()) ? 1 : capacity() * 2;
		reserve(newCapacity);

		// 如果发生了增容，需要重置pos
		pos = _start + size();
	}

	iterator end = _finish - 1;
	while (end &gt;= pos)
	{
		*(end + 1) = *end;
		--end;
	}

	*pos = x;
	++_finish;
	return pos;
}

// 返回删除数据的下一个数据
// 方便解决:一边遍历一边删除的迭代器失效问题
// （迭代器失效问题在vector中会发生，不知道的可以看我之前文章）
iterator erase(iterator pos)
{
	// 挪动数据进行删除
	iterator begin = pos + 1;
	while (begin != _finish) {
		*(begin - 1) = *begin;
		++begin;
	}

	--_finish;
	return pos;
}</code></pre> 
<h2 id="%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93">三、总结</h2> 
<blockquote> 
 <p>上面的就是vector的模拟实现的全部代码段，这些还不是vector的全部内容，还有vector复制等几个细节我们还没讲，这个感兴趣的可以关注一下，将在下一篇讲解这些细小知识点</p> 
</blockquote> 
<p><strong><span style="background-color:#ff9900;">感谢各位大佬观看，创作不易，还请各位大佬点赞支持！！！</span></strong></p> 
<p style="text-align:center;"><strong><span style="background-color:#ff9900;"><img alt="" src="https://images2.imgbox.com/d7/83/LfiT9lDK_o.jpg"></span></strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7989f740b774128f9bb2e805729d7735/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">STM32 入门教程（江科大教材）#笔记1</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c41378bfae37b06648cf5b570b59a9f9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【MySQL】——用户和权限管理（一）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>