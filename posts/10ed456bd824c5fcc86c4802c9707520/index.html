<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>光速入门python的OpenCV - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/10ed456bd824c5fcc86c4802c9707520/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="光速入门python的OpenCV">
  <meta property="og:description" content="前言 欢迎来到我的博客
个人主页:北岭敲键盘的荒漠猫-CSDN博客
本文整理python的OpenCV模块的关键知识点
争取用最短的时间入门OpenCV
并且做到笔记功能直接复制使用
OpenCV简介 不浪费时间的介绍:
就是类似于ps操作图片。
至于为什么不直接用ps，因为只有程序能完成ps的操作，这样才能完全自动化2小时不间断的执行一些程序，总不能执行到一定地方要等你人为的在ps中做好图片再来执行程序吧。
功能点罗列:
画图，图片高斯模糊，腐蚀膨胀等处理，开启摄像头。
最基本的使用 导入模块:import cv2 方法作用cv2.getVersionString()返回OpenCV的版本cv2.imread(文件地址,图片灰彩类型) 读取文件,用于实例化对象
灰彩类型:(可以不写)
cv2.IMREAD_COLOR读入彩色图像cv2.IMREAD_GRAYSCALE读入灰色图像
对象.shape返回图片的大小(像素)cv2.imshow(窗口名,图片对象)返回个窗口用于展示这个图片cv2.waitKey(自动关闭时间) 窗口不自动关闭，知道按下任意键或者到规定时间(时间为微秒)
返回他按得键的代号数字
到时间返回-1
cv2.imwrite(保存路径和文件名,保存的图片)保存编辑的图片 注意:
这个库不支持任何中文!!!!!
不管是图片文件命名还是窗口等
一律别用中文！！！！！！！
（至少我的版本不支持任何中文）
案例演示:
import cv2#导入库 print(cv2.getVersionString())#返回版本号 image=cv2.imread(&#34;konglong.jpg&#34;)#导入图片，实例化 print(image.shape)#返回图片的大小和通道 cv2.imshow(&#34;阿萨德&#34;,image)#展示图片 cv2.waitKey(1000)#设置暂停 cv2.imwrite(&#34;okok.jpg&#34;,image)#保存图片 结果:
打印信息
保存okok图片
展示图片(代码中用中文做窗口所以会乱码)
视频的打开方式 我们视频有两种：摄像头，视频文件
用到的函数:
读取视频或摄像头:cv2.VideoCapture(视频或者摄像头的指针) 返回视频读取的照片:cap.read() 开启摄像头
思路:原理就是对这摄像头一遍遍截图。然后我们不断的刷新显示的图片。
代码如下:
import cv2#导入库 cap=cv2.VideoCapture(0)#读取摄像头 while True:#循环 valu,video=cap.read()#读取摄像头内容 show=cv2.imshow(&#34;video&#34;,video)#展示摄像头 key=cv2.waitKey(1)#设置等待0.001秒刷新一次 print(key) if key!=-1:#如果不是到时间刷新的视频就退出视频 break 结果如下:
按下别的键就关闭了。(字母有时候不行，数字或者特殊按键相对靠谱点)
视频打开方式
代码:
import cv2#导入库 cap=cv2.VideoCapture(&#34;bingdu.mp4&#34;) while True: valu,video=cap.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-26T00:06:15+08:00">
    <meta property="article:modified_time" content="2024-05-26T00:06:15+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">光速入门python的OpenCV</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <h2 style="text-align:center;"><span style="color:#faa572;"><strong>前言</strong></span></h2> 
 <p style="text-align:center;"><span style="color:#9c8ec1;">欢迎来到我的博客</span></p> 
 <p style="text-align:center;">个人主页:<a href="https://blog.csdn.net/2302_79590880?spm=1000.2115.3001.5343" title="北岭敲键盘的荒漠猫-CSDN博客">北岭敲键盘的荒漠猫-CSDN博客</a></p> 
 <p><img alt="" src="https://images2.imgbox.com/dc/61/CkYVbMCV_o.png"></p> 
</blockquote> 
<p style="text-align:center;"> 本文整理python的OpenCV模块的关键知识点</p> 
<p style="text-align:center;">争取用最短的时间入门OpenCV</p> 
<p style="text-align:center;">并且做到笔记功能直接复制使用</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/8d/d4/UvhFnFQt_o.gif"></p> 
<h2>OpenCV简介</h2> 
<p>不浪费时间的介绍:</p> 
<p>就是类似于ps操作图片。</p> 
<p>至于为什么不直接用ps，因为只有程序能完成ps的操作，这样才能完全自动化2小时不间断的执行一些程序，总不能执行到一定地方要等你人为的在ps中做好图片再来执行程序吧。</p> 
<p>功能点罗列:</p> 
<p>画图，图片高斯模糊，腐蚀膨胀等处理，开启摄像头。</p> 
<p></p> 
<h2>最基本的使用</h2> 
<pre><code class="language-python">导入模块:import cv2</code></pre> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>cv2.getVersionString()</td><td>返回OpenCV的版本</td></tr><tr><td>cv2.imread(文件地址,图片灰彩类型)</td><td> <p>读取文件,用于实例化对象</p> <p>灰彩类型:(可以不写)</p> <p>cv2.IMREAD_COLOR读入彩色图像cv2.IMREAD_GRAYSCALE读入灰色图像</p> </td></tr><tr><td>对象.shape</td><td>返回图片的大小(像素)</td></tr><tr><td>cv2.imshow(窗口名,图片对象)</td><td>返回个窗口用于展示这个图片</td></tr><tr><td>cv2.waitKey(自动关闭时间)</td><td> <p>窗口不自动关闭，知道按下任意键或者到规定时间(时间为微秒)</p> <p>返回他按得键的代号数字</p> <p>到时间返回-1</p> </td></tr><tr><td>cv2.imwrite(保存路径和文件名,保存的图片)</td><td>保存编辑的图片</td></tr></tbody></table> 
<p>注意:</p> 
<p>这个库不支持任何中文!!!!!</p> 
<p>不管是图片文件命名还是窗口等</p> 
<p><span style="color:#fe2c24;">一律别用中文！！！！！！！</span></p> 
<p><span style="color:#fe2c24;">（至少我的版本不支持任何中文）</span></p> 
<p>案例演示:</p> 
<pre><code class="language-python">import cv2#导入库
print(cv2.getVersionString())#返回版本号
image=cv2.imread("konglong.jpg")#导入图片，实例化
print(image.shape)#返回图片的大小和通道

cv2.imshow("阿萨德",image)#展示图片
cv2.waitKey(1000)#设置暂停
cv2.imwrite("okok.jpg",image)#保存图片</code></pre> 
<p>结果:</p> 
<p>打印信息</p> 
<p><img alt="" height="169" src="https://images2.imgbox.com/40/f2/Ut0RfL8h_o.png" width="363"></p> 
<p>保存okok图片</p> 
<p><img alt="" height="256" src="https://images2.imgbox.com/04/9c/pNMKqYOE_o.png" width="288"></p> 
<p>展示图片(代码中用中文做窗口所以会乱码)</p> 
<h2><img alt="" height="389" src="https://images2.imgbox.com/93/ab/d8eoApP0_o.png" width="994"></h2> 
<h2> 视频的打开方式</h2> 
<p>我们视频有两种：摄像头，视频文件</p> 
<p>用到的函数:</p> 
<pre><code class="language-python">读取视频或摄像头:cv2.VideoCapture(视频或者摄像头的指针)
返回视频读取的照片:cap.read()
</code></pre> 
<p><strong>开启摄像头</strong></p> 
<p>思路:原理就是对这摄像头一遍遍截图。然后我们不断的刷新显示的图片。</p> 
<p>代码如下:</p> 
<pre><code class="language-python">import cv2#导入库
cap=cv2.VideoCapture(0)#读取摄像头
while True:#循环
    valu,video=cap.read()#读取摄像头内容
    show=cv2.imshow("video",video)#展示摄像头
    key=cv2.waitKey(1)#设置等待0.001秒刷新一次
    print(key)
    if key!=-1:#如果不是到时间刷新的视频就退出视频
        break
</code></pre> 
<p>结果如下:</p> 
<p><img alt="" height="632" src="https://images2.imgbox.com/1b/90/K8NccWgG_o.png" width="798"></p> 
<p> 按下别的键就关闭了。(字母有时候不行，数字或者特殊按键相对靠谱点)</p> 
<p><strong>视频打开方式</strong></p> 
<p>代码:</p> 
<pre><code class="language-python">import cv2#导入库
cap=cv2.VideoCapture("bingdu.mp4")
while True:
    valu,video=cap.read()
    show=cv2.imshow("video",video)
    key=cv2.waitKey(1)
    print(key)
    if key!=-1:
        break</code></pre> 
<p>基本一样不截图了</p> 
<p></p> 
<h2>灰度图获取与处理</h2> 
<p>介绍:OpenCV储存图片实际上是储存三原色的三张图片，最后整合在一起。采用bgr图像。</p> 
<p>灰度加权平均:</p> 
<pre><code class="language-python">cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)</code></pre> 
<p>展示隔色彩图像:</p> 
<pre><code class="language-python">cv2.imshow("blue",image[:,:,0])
cv2.imshow("green",image[:,:,1])
cv2.imshow("red",image[:,:,2])
</code></pre> 
<p>用法演示:(图片太大不展示效果了)</p> 
<pre><code class="language-python">import cv2
image=cv2.imread("konglong.jpg")
cv2.imshow("blue",image[:,:,0])
cv2.imshow("green",image[:,:,1])
cv2.imshow("red",image[:,:,2])
gray=cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)
cv2.imshow("gray",gray)
cv2.waitKey()</code></pre> 
<p></p> 
<h2>裁剪图像</h2> 
<pre><code class="language-python">crop=image[y轴开始裁剪位置:结束位置,x轴开始裁剪位置:结束位置]</code></pre> 
<p>水平为x，垂直为y</p> 
<p>案例演示:</p> 
<pre><code class="language-python">import cv2
image=cv2.imread("konglong.jpg")
print(image.shape)
y,h,x,w=100,300,100,600
crop=image[y:h,x:w]
cv2.imshow("crop",crop)
cv2.waitKey()</code></pre> 
<p><img alt="" height="293" src="https://images2.imgbox.com/a0/f2/X93li2mA_o.png" width="628"></p> 
<p></p> 
<h2>图形绘制</h2> 
<p>可用于标记识别的物品</p> 
<p>(注意，所有的粗细参数输入负数后就是填充图像)</p> 
<p><strong>绘制直线</strong></p> 
<pre><code class="language-python">cv2.line(图片, 起点坐标, 终点坐标, 颜色, 粗细)</code></pre> 
<p>案例演示</p> 
<pre><code class="language-python">import cv2
image=cv2.imread("okok.jpg")
cv2.line(image,(0,0),(700,600),(255,45,65),4)
cv2.imshow("image",image)
cv2.waitKey()</code></pre> 
<p>效果演示:</p> 
<p><img alt="" height="833" src="https://images2.imgbox.com/e2/e3/wZDw4EZB_o.png" width="982"></p> 
<p><strong>绘制方形</strong></p> 
<pre><code class="language-python">cv2.rectangle(图片, 起点坐标, 终点坐标, 颜色, 粗细)</code></pre> 
<p>案例演示</p> 
<pre><code class="language-python">import cv2
image=cv2.imread("okok.jpg")
cv2.rectangle(image,(309,310),(344,352),(255,45,65),4)
cv2.imshow("image",image)
cv2.waitKey()</code></pre> 
<p><img alt="" height="435" src="https://images2.imgbox.com/d2/a9/YkI9TLjP_o.png" width="735"></p> 
<p><strong>绘制圆形 </strong></p> 
<pre><code class="language-python">cv2.circle(image,原点坐标,半径,颜色,粗细)</code></pre> 
<p>案例演示:</p> 
<pre><code class="language-python">import cv2
image=cv2.imread("okok.jpg")
cv2.circle(image,(329,329),30,(255,45,65),4)
cv2.imshow("image",image)
cv2.waitKey()</code></pre> 
<p><img alt="" height="666" src="https://images2.imgbox.com/4f/0b/V5JBVckg_o.png" width="995"></p> 
<p><strong> 椭圆绘制</strong></p> 
<pre><code class="language-python">cv2.ellipse(图片, 中心点坐标, 横纵轴长度(元组), 旋转角度, 起始角度, 结束角度, 颜色, 粗细)</code></pre> 
<p>案例演示:</p> 
<pre><code class="language-python">import cv2
image=cv2.imread("okok.jpg")
cv2.ellipse(image, (256, 256), (100, 50), 60, 0, 360, (0, 255, 0), -1)
cv2.imshow("image",image)
cv2.waitKey()
</code></pre> 
<p><img alt="" height="452" src="https://images2.imgbox.com/72/d9/e6DnsK39_o.png" width="818"></p> 
<p><strong>绘制文字</strong></p> 
<pre><code class="language-python">cv2.putText(图片, 文字, 位置, 字体, 文字大小, 颜色, 粗细)</code></pre> 
<p>案例演示:</p> 
<pre><code class="language-python">import cv2
image=cv2.imread("okok.jpg")
cv2.putText(image, "how cool am i!", (250, 350), cv2.FONT_HERSHEY_SIMPLEX, 2, (65,54,87), 2)
cv2.imshow("image",image)
cv2.waitKey()</code></pre> 
<p></p> 
<h2>噪点处理</h2> 
<p>噪点描述:拍摄时信号传输收到干扰产生的杂色，如下：</p> 
<p><img alt="" height="734" src="https://images2.imgbox.com/6f/39/JE4ERUaH_o.png" width="501"></p> 
<p>噪点处理，其实就是让他变模糊，模糊之后边界就会不明显。但是也会影响一定的画面。</p> 
<p>所以一般情况下，是对图像的局部噪点严重的区域进行区域内的噪点处理。</p> 
<p>注意下面的核必须是奇数。</p> 
<p><strong>高斯模糊</strong></p> 
<pre><code class="language-python">cv2.GaussianBlur（图像,高斯核,sigmaX,sigmaY,边界样式）
x与y差越大越模糊，0的话就是自行计算
实际上一般可以用下面形式进行使用
cv2.GaussianBlur(image,(5,5),0)</code></pre> 
<p><strong>中值滤过（像素排序取中值平滑处理）</strong></p> 
<pre><code class="language-python">cv2.medianBlur(图片,核)</code></pre> 
<p><strong>案例演示</strong></p> 
<pre><code class="language-python">import cv2
image=cv2.imread("zaodian.jpeg")
cv2.imshow("image",image)
gauss=cv2.GaussianBlur(image,(5,5),0,11)
cv2.imshow("gauss",gauss)
median=cv2.medianBlur(image,5)
cv2.imshow("median",median)
cv2.waitKey()</code></pre> 
<p><strong>效果演示</strong></p> 
<p><img alt="" height="509" src="https://images2.imgbox.com/c7/16/jNNAids7_o.png" width="1200"></p> 
<p></p> 
<h2>图片特征提取</h2> 
<p>(但是OpenCV提取图像特征的水平有限，如果需要特别的精准可以尝试别的库)</p> 
<p>提取图片的特征，比如说转角，边缘，纹理啥的。</p> 
<p>提取思路:先把图像给转化为灰度图，然后在灰度图中匹配转角这类的特征。</p> 
<p>函数：</p> 
<pre><code class="language-python">cv2.cvtColor(图片,cv2.COLOR_BGR2GRAY) #灰度处理
cv2.goodFeaturesToTrack(图片,最大特征数,点的质量,特征最小的距离)
.ravel()#点的坐标</code></pre> 
<p>案例演示</p> 
<pre><code class="language-python">import cv2
image=cv2.imread("okok.jpg")
gray=cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)
corners=cv2.goodFeaturesToTrack(gray,500,0.1,10)
for corner in corners:
    x,y=corner.ravel()
    cv2.circle(image,(int(x),int(y)),2,(255,0,255),-1)
cv2.imshow("corners",image)
cv2.waitKey()</code></pre> 
<p><img alt="" height="586" src="https://images2.imgbox.com/01/1c/nNPpGh17_o.png" width="947"></p> 
<p></p> 
<p>其实这些特征提取也不是特别的精准，看图中的特征点也能看出来，这些特征点也不足以准确的识别这个画面。</p> 
<p></p> 
<h2>图片匹配</h2> 
<p>原理:</p> 
<p>也是把指定的图片转化为灰度图，然后找特征点，之后在指定的图片中匹配有没有相似的特征点。</p> 
<p>缺点:</p> 
<p>对图片的大小敏感。也就是说我们给的图片距离镜头20m，但是在指定的图片中，这个图片在镜头50m的地方，就会因为大小不同而匹配不到。</p> 
<p>解决思路:</p> 
<p>可以改变图像的大小进行多次匹配，或者减少匹配的精度要求(误判多)。</p> 
<p>(用到了numpy模块)</p> 
<p>函数</p> 
<pre><code>灰度处理:cv2.cvtColor(图片,cv2.COLOR_BGR2GRAY)
匹配图像:cv2.matchTemplate(gray_video, target, cv2.TM_CCOEFF_NORMED)
获取坐标:numpy.where(match &gt;= 匹配相似度)

</code></pre> 
<p>案例演示</p> 
<p>(我写的这个识别度不是很高，不过能识别基本的功能，有点人工智障)</p> 
<p>调用摄像头实时识别书本上的java。</p> 
<p>代码案例</p> 
<pre><code class="language-python">import cv2
import numpy as np
image=cv2.imread("java.jpg")
video=cv2.VideoCapture(0)
gray=cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)
x1,y1=617,608
x2,y2=967,734
target=gray[y1:y2,x1:x2]
cv2.imshow("okk",target)
h,w=target.shape[0:2]
print("{},{}".format(h,w))
a=1
while True:#循环
    valu,video1=video.read()#读取摄像头内容
    gray_video=cv2.cvtColor(video1,cv2.COLOR_BGR2GRAY)
    if a==1:
        a=2
        cv2.imshow("okkk",gray_video)
    match = cv2.matchTemplate(gray_video, target, cv2.TM_CCOEFF_NORMED)
    place = np.where(match &gt;= 0.9)
    print(place)
    for p in zip(*place[::-1]):
        x_1, y_1 = p[0], p[1]
        x_2, y_2 = x_1 + w, y_1 + h
        print(x_1,x_2)
        cv2.rectangle(video1,(x_1, y_2),(x_2, y_2),(156, 124, 21), 1)
    show=cv2.imshow("video",video1)#展示摄像头
    key=cv2.waitKey(1)#设置等待0.001秒刷新一次
    if key!=-1:#如果不是到时间刷新的视频就退出视频
        break

</code></pre> 
<p>效果演示</p> 
<p><img alt="" height="661" src="https://images2.imgbox.com/e6/22/EoiBVD4S_o.png" width="1200"></p> 
<p>嗯人工智障，识别条件特别苛刻。</p> 
<p>不过也算是能够完成实时识别的功能了。</p> 
<p></p> 
<h2>图像梯度算法</h2> 
<p>简介一下图像梯度:</p> 
<p>图像梯度就像地理地图的等高线一样。</p> 
<p>给我们分辨一个区域的图像像素变化的强度，如果他变化强度比较大，那么他大概率是图形的边缘。可以利用图像的梯度来分辨图像中的不同的物体。</p> 
<h3>拉普拉斯算子</h3> 
<p>作用:利用梯度的方法检测图像边缘，轮廓以及纹理。</p> 
<p>函数:</p> 
<pre><code class="language-python">常用写法:cv2.Laplacian(图片,cv2.CV_64F)
完整写法:cv2.Laplacian(image, dest, ddepth, ksize, scale, delta, borderType)
image是输入图像，dest是输出图像，ddepth是输出图像的深度，ksize是卷积核的大小，scale是拉普拉斯算子的系数</code></pre> 
<p>案例演示:</p> 
<pre><code class="language-python">import cv2
image=cv2.imread("java.jpg")
gray=cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)
laplacian=cv2.Laplacian(gray,cv2.CV_64F)
cv2.imshow("yuantu",image)
cv2.imshow("suanfa",laplacian)
cv2.waitKey()</code></pre> 
<p>效果演示:</p> 
<p><img alt="" height="980" src="https://images2.imgbox.com/ba/6d/PZO7VQCM_o.png" width="1200"></p> 
<h3> canny算子</h3> 
<p>函数:</p> 
<pre><code class="language-python">cv2.Canny(gray,边缘1,边缘2)
</code></pre> 
<p>原理:</p> 
<p>像素变化强度大于边缘2被判定为是边界，小于边界1被判定为不是边界。在两者之间的区域根据已经判断的区域进行判断。</p> 
<p>源码如下:</p> 
<pre><code class="language-python">import cv2
image=cv2.imread("java.jpg")
gray=cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)
canny=cv2.Canny(gray,100,200)
canny2=cv2.Canny(gray,50,100)
cv2.imshow("yuantu",image)
cv2.imshow("canny",canny)
cv2.imshow("canny2",canny2)
cv2.waitKey()</code></pre> 
<p>效果演示:</p> 
<p><img alt="" height="968" src="https://images2.imgbox.com/35/f0/koDjIKhX_o.png" width="1200"></p> 
<p>好处就是自己能规定他判断的严格程度。</p> 
<p></p> 
<h2>阈值算法（二值化）</h2> 
<h3>普通算法</h3> 
<p>描述:众所周知，我们世界的颜色并不是绝对的黑白，我们由黑白之间可以配出很多种灰色。</p> 
<p>我们就可以用这个原理来把这些灰色绝对化。满足某个值的就变成黑色，不满足的就是白色。</p> 
<p>这样就可以识别一些黑暗环境中的文字或者物品。</p> 
<p>(但也别指望太准，要是拿个你自己都分辨不出来的图片，用这个也不容易。。。)</p> 
<p><strong>函数</strong></p> 
<pre><code class="language-python">cv2.threshold(图片,阈值,最大灰度,处理方法)
本案例用的函数:cv2.threshold(gray,100,255,cv2.THRESH_BINARY)
(因为这张照片环境明堂堂的。。。)</code></pre> 
<p>案例演示</p> 
<pre><code class="language-python">import cv2
image=cv2.imread("java.jpg")
gray=cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)
ret,binary=cv2.threshold(gray,100,255,cv2.THRESH_BINARY)
cv2.imshow("binary",binary)
cv2.waitKey()</code></pre> 
<p>效果演示</p> 
<p><img alt="" height="1018" src="https://images2.imgbox.com/10/0e/d5YJs2Pv_o.png" width="1200"></p> 
<h3><strong>分区二值化算法 </strong></h3> 
<p>OpenCV有内置的分区二值化算法，自动计算这个小区域的阈值，并设定合适的阈值。</p> 
<p><strong>函数</strong></p> 
<pre><code class="language-python">函数：(案例)
cv2.adaptiveThreshold(gray,255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY,115,1)

该函数有以下参数：

    src: 要二值化的原始图像。

    maxval: 阈值的最大值。

    adaptiveMethod: 用于计算阈值的方法。有两个选项可供选择：cv2.ADAPTIVE_THRESH_MEAN_C和cv2.ADAPTIVE_THRESH_GAUSSIAN_C。推荐使用默认的cv2.ADAPTIVE_THRESH_GAUSSIAN_C。

    thresholdType: 阈值类型。可以是cv2.THRESH_BINARY或cv2.THRESH_BINARY_INV。推荐使用默认的cv2.THRESH_BINARY。

    blockSize: 每个局部区域的大小，用来计算局部阈值。

    C: 从平均值或加权平均值中减去的常数。该参数在计算局部阈值时起到调整阈值的作用。

</code></pre> 
<p>案例演示</p> 
<pre><code class="language-python">import cv2
image=cv2.imread("java.jpg")
gray=cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)
binary_adaptive=cv2.adaptiveThreshold(gray,255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY,115,1)
cv2.imshow("binary",binary_adaptive)
cv2.waitKey()</code></pre> 
<p>结果演示</p> 
<p><img alt="" height="1014" src="https://images2.imgbox.com/45/1e/5etkpxaV_o.png" width="1200"></p> 
<p>可以看到，明显的比自己写的那个好用。</p> 
<h3>大金算法</h3> 
<p>算法原理:找两个最大的值，然后取两个值的中心。让黑白差异最大化。</p> 
<p>函数</p> 
<pre><code class="language-python">cv2.threshold(gray,0,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU)</code></pre> 
<p>好处</p> 
<p>完全不用咱们自己设置阈值，他自己就可以设置的明明白白的。</p> 
<p>但是也有缺点，不如自己设置的完美，有时候可能不是很好用。</p> 
<p>案例演示</p> 
<pre><code class="language-python">import cv2
image=cv2.imread("java.jpg")
gray=cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)
ret1,binary_otsu=cv2.threshold(gray,0,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU)
cv2.imshow("binary",binary_otsu)
cv2.waitKey()</code></pre> 
<p>效果演示</p> 
<p><img alt="" height="1004" src="https://images2.imgbox.com/a0/a3/JV4KzSDq_o.png" width="1200"></p> 
<p></p> 
<h2>腐蚀与膨胀</h2> 
<p>腐蚀:就是给图像变瘦一点（减少白色）</p> 
<p>膨胀:相反，给图像变胖一点(增加白色)</p> 
<p>作用:可以处理图像边缘，放大或者缩小图像的细节。</p> 
<p><strong>函数</strong></p> 
<p>他们都需要创建一个核</p> 
<pre><code class="language-python">np.ones((5, 5), np.uint8)</code></pre> 
<p><strong>膨胀与腐蚀</strong></p> 
<pre><code class="language-python">cv2.erode(图像, kernel)  # 腐蚀
cv2.dilate(图像, kernel)  # 膨胀</code></pre> 
<p>案例演示：</p> 
<pre><code class="language-python">import cv2
import numpy as np
image=cv2.imread("java.jpg")
gray=cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)
ret1,binary_otsu=cv2.threshold(gray,0,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU)
kernel = np.ones((5, 5), np.uint8)
erosion = cv2.erode(binary_otsu, kernel)  # 腐蚀
dilate = cv2.dilate(binary_otsu, kernel)  # 膨胀
cv2.imshow("binary",binary_otsu)
cv2.imshow("er",erosion)
cv2.imshow("di",dilate)
cv2.waitKey()</code></pre> 
<p>效果演示:</p> 
<p>腐蚀</p> 
<p><img alt="" height="1026" src="https://images2.imgbox.com/f1/fc/zhH8ajmL_o.png" width="1200"></p> 
<p>膨胀</p> 
<p><img alt="" height="1006" src="https://images2.imgbox.com/8e/af/kdQvExDW_o.png" width="1200"></p> 
<p> 这里看到，明明是腐蚀但是感觉像是做出膨胀的效果，这是因为这个是腐蚀白色。所以对于黑色来说是膨胀了。</p> 
<p></p> 
<h2>总结</h2> 
<p>OK，这些就是OpenCV的基础了。</p> 
<p>他还有很多深入的算法，需要自己挖掘。</p> 
<p>掌握了这些就能实现一些基本的功能了。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ada0bf4bbc94f6322880d7149e8f68e8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java---图书管理系统(练习版)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4004ab285be0ebf409e0d18e9ad5a3dd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MyBatis复习笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>