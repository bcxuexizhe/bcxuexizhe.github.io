<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】顺序表：与时俱进的结构解析与创新应用 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/3fb0526ec464e9242ddcf5a0420d2fa6/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【数据结构】顺序表：与时俱进的结构解析与创新应用">
  <meta property="og:description" content="欢迎来到白刘的领域 Miracle_86.-CSDN博客 系列专栏 数据结构与算法 先赞后看，已成习惯 创作不易，多多支持！ 目录
一、数据结构的概念
二、顺序表（Sequence List）
2.1 线性表的概念以及结构
2.2 顺序表分类
2.2.1 顺序表和数组的区别
2.2.2 顺序表的分类
2.3 顺序表的实现
2.3.1 初始化
2.3.2 销毁
2.3.3 尾插
2.3.4 头插
2.3.5 尾删
2.3.6 头删
2.3.7 在指定位置插入
2.3.8 在指定位置删除
2.3.9 查找
2.4 总代码
2.4.1 SeqList.h
2.4.2 SeqList.c
一、数据结构的概念 数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。数据结构反映数据的内部构成，即数据由哪部分构成，以什么方式构成，以及数据之间存在的相互关系。
数据结构可以分为两类：线性数据结构和非线性数据结构。线性数据结构以线性的方式组织数据，例如数组、链表和栈。非线性数据结构是一种通过多个节点之间的关联来组织数据的方式，例如树和图。数据结构的选取和设计对于解决特定问题和提高算法效率非常重要。
我们可以将这个词拆分成“数据”和“结构”两部分。
什么是数据？数据可以是数字、文字、图像等。比如超市购物时的价格、数量，天气预报中的温度、湿度，或是社交媒体上的浏览量、点赞数，都是数据。它们为我们提供信息，帮助我们做出决策，让生活更加便捷。
什么是结构？当我们想要使用大量使用同类型的数据时，通过手动定义大量的独立的变量对于程序来说，可读性非常差，我们可以借助数组这样的数据结构将大量的数据组织在一起，结构也可以理解为组织数据的方式。
比如，想要在世界上找到“喜羊羊”的这只羊很难，但是我告诉你在青青草原找，那就特别好找。青青草原这一块地方就可以看成一个结构，有效地将羊群组织起来。
总结：
1.数据结构可以存储数据。
2.存储的数据能够方便查找。
那为什么我们需要数据结构呢？
在生活中，假如我们开了个餐馆，不借助排队的方式来管理客户，会导致客户就餐感受差、等餐时间长、餐厅营业混乱等情况。同理，程序中如果不对数据进行管理，可能会导致数据丢失、操作数据困难、野指针等情况。
良好的数据结构和算法设计对于确保程序的稳定性和效率至关重要。通过合理地组织和管理数据，我们可以提高程序的性能，减少错误，并为用户提供更好的体验。
我们曾学过最基础的数据结构：数组。
C语言中的百宝箱——数组（1）-CSDN博客
C语言中的百宝箱——数组（2）-CSDN博客
既然我们已经学过数组这种数据结构了，那我们还需要学其它的数据结构嘛？存在即合理，显然数组是有一定的局限性的。
假定数组有10个空间，已经使用了5个，向数组中插入数据的步骤应该是：
1. 求数组的长度（这里是10）。
2. 求数组的有效数据个数（这里是5）。
3. 判断数组是否已满（如果有效数据个数等于数组长度，则数组已满）。
4. 如果数组未满，向下标为有效数据个数的位置插入数据。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-21T23:12:13+08:00">
    <meta property="article:modified_time" content="2024-04-21T23:12:13+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】顺序表：与时俱进的结构解析与创新应用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 id="%C2%A0%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E7%99%BD%E5%88%98%E7%9A%84%E9%A2%86%E5%9F%9F%C2%A0%C2%A0%C2%A0Miracle_86.-CSDN%E5%8D%9A%E5%AE%A2" style="text-align:center;"><strong> <span style="color:#38d8f0;">欢迎来到白刘的领域</span>   </strong><a href="https://blog.csdn.net/Miracle_86?type=blog" title="Miracle_86.-CSDN博客">Miracle_86.-CSDN博客</a></h4> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%E7%B3%BB%E5%88%97%E4%B8%93%E6%A0%8F%C2%A0%20%C2%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95" style="text-align:center;"><strong>         <span style="color:#ff9900;">系列专栏</span>   </strong><a href="https://blog.csdn.net/miracle_86/category_12649583.html?spm=1001.2014.3001.5482" title="数据结构与算法">数据结构与算法</a></h4> 
<h4 id="%E5%85%88%E8%B5%9E%E5%90%8E%E7%9C%8B%EF%BC%8C%E5%B7%B2%E6%88%90%E4%B9%A0%E6%83%AF" style="background-color:transparent;text-align:center;"><span style="color:#a2e043;"><strong>先赞后看，已成习惯</strong></span></h4> 
<h4 id="%C2%A0%20%C2%A0%E5%88%9B%E4%BD%9C%E4%B8%8D%E6%98%93%EF%BC%8C%E5%A4%9A%E5%A4%9A%E6%94%AF%E6%8C%81%EF%BC%81" style="text-align:center;"><span style="color:#956fe7;">   创作不易，多多支持！</span></h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5a/3a/5osoLYPq_o.gif"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">一、数据结构的概念</a></p> 
<p id="%E4%BA%8C%E3%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%EF%BC%88Sequence%20List%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%EF%BC%88Sequence%20List%EF%BC%89" rel="nofollow">二、顺序表（Sequence List）</a></p> 
<p id="2.1%20%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#2.1%20%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E7%BB%93%E6%9E%84" rel="nofollow">2.1 线性表的概念以及结构</a></p> 
<p id="2.2%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%88%86%E7%B1%BB-toc" style="margin-left:80px;"><a href="#2.2%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%88%86%E7%B1%BB" rel="nofollow">2.2 顺序表分类</a></p> 
<p id="2.2.1%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:120px;"><a href="#2.2.1%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">2.2.1 顺序表和数组的区别</a></p> 
<p id="2.2.2%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB-toc" style="margin-left:120px;"><a href="#2.2.2%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB" rel="nofollow">2.2.2 顺序表的分类</a></p> 
<p id="2.3%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#2.3%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">2.3 顺序表的实现</a></p> 
<p id="2.3.1%20%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:120px;"><a href="#2.3.1%20%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">2.3.1 初始化</a></p> 
<p id="%C2%A02.3.2%20%E9%94%80%E6%AF%81-toc" style="margin-left:120px;"><a href="#%C2%A02.3.2%20%E9%94%80%E6%AF%81" rel="nofollow"> 2.3.2 销毁</a></p> 
<p id="2.3.3%20%E5%B0%BE%E6%8F%92-toc" style="margin-left:120px;"><a href="#2.3.3%20%E5%B0%BE%E6%8F%92" rel="nofollow">2.3.3 尾插</a></p> 
<p id="2.3.4%20%E5%A4%B4%E6%8F%92-toc" style="margin-left:120px;"><a href="#2.3.4%20%E5%A4%B4%E6%8F%92" rel="nofollow">2.3.4 头插</a></p> 
<p id="2.3.5%20%E5%B0%BE%E5%88%A0-toc" style="margin-left:120px;"><a href="#2.3.5%20%E5%B0%BE%E5%88%A0" rel="nofollow">2.3.5 尾删</a></p> 
<p id="2.3.6%20%E5%A4%B4%E5%88%A0-toc" style="margin-left:120px;"><a href="#2.3.6%20%E5%A4%B4%E5%88%A0" rel="nofollow">2.3.6 头删</a></p> 
<p id="2.3.7%20%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5-toc" style="margin-left:120px;"><a href="#2.3.7%20%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5" rel="nofollow">2.3.7 在指定位置插入</a></p> 
<p id="2.3.8%20%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E5%88%A0%E9%99%A4-toc" style="margin-left:120px;"><a href="#2.3.8%20%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E5%88%A0%E9%99%A4" rel="nofollow">2.3.8 在指定位置删除</a></p> 
<p id="2.3.9%20%E6%9F%A5%E6%89%BE-toc" style="margin-left:120px;"><a href="#2.3.9%20%E6%9F%A5%E6%89%BE" rel="nofollow">2.3.9 查找</a></p> 
<p id="%C2%A02.4%20%E6%80%BB%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%C2%A02.4%20%E6%80%BB%E4%BB%A3%E7%A0%81" rel="nofollow"> 2.4 总代码</a></p> 
<p id="2.4.1%20SeqList.h-toc" style="margin-left:120px;"><a href="#2.4.1%20SeqList.h" rel="nofollow">2.4.1 SeqList.h</a></p> 
<p id="2.4.2%20SeqList.c-toc" style="margin-left:120px;"><a href="#2.4.2%20SeqList.c" rel="nofollow">2.4.2 SeqList.c</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%A6%82%E5%BF%B5" style="background-color:transparent;">一、数据结构的概念</h3> 
<blockquote> 
 <p>数据结构是<strong>计算机存储、组织数据的方式</strong>。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。数据结构反映数据的内部构成，即数据由哪部分构成，以什么方式构成，以及数据之间存在的相互关系。</p> 
 <p>数据结构可以分为两类：线性数据结构和非线性数据结构。线性数据结构以线性的方式组织数据，例如数组、链表和栈。非线性数据结构是一种通过多个节点之间的关联来组织数据的方式，例如树和图。数据结构的选取和设计对于解决特定问题和提高算法效率非常重要。</p> 
</blockquote> 
<p>我们可以将这个词拆分成“数据”和“结构”两部分。</p> 
<p>什么是数据？数据可以是数字、文字、图像等。比如超市购物时的价格、数量，天气预报中的温度、湿度，或是社交媒体上的浏览量、点赞数，都是数据。它们为我们提供信息，帮助我们做出决策，让生活更加便捷。</p> 
<p>什么是结构？当我们想要使用大量使用同类型的数据时，通过手动定义大量的独立的变量对于程序来说，可读性非常差，我们可以借助数组这样的数据结构将大量的数据组织在一起，结构也可以理解为组织数据的方式。</p> 
<p>比如，想要在世界上找到“喜羊羊”的这只羊很难，但是我告诉你在青青草原找，那就特别好找。青青草原这一块地方就可以看成一个结构，有效地将羊群组织起来。</p> 
<p><img alt="" height="377" src="https://images2.imgbox.com/98/84/OkeJHJjC_o.png" width="404"></p> 
<blockquote> 
 <p><strong>总结：</strong></p> 
 <p>1.数据结构可以存储数据。</p> 
 <p>2.存储的数据能够方便查找。</p> 
</blockquote> 
<p>那为什么我们需要数据结构呢？</p> 
<p>在生活中，假如我们开了个餐馆，不借助排队的方式来管理客户，会导致客户就餐感受差、等餐时间长、餐厅营业混乱等情况。同理，程序中如果不对数据进行管理，可能会导致数据丢失、操作数据困难、野指针等情况。</p> 
<p>良好的数据结构和算法设计对于确保程序的稳定性和效率至关重要。通过合理地组织和管理数据，我们可以提高程序的性能，减少错误，并为用户提供更好的体验。</p> 
<p>我们曾学过最基础的数据结构：数组。</p> 
<p><img alt="" height="116" src="https://images2.imgbox.com/32/f4/g9ziMhua_o.png" width="497"> </p> 
<blockquote> 
 <p><a href="https://blog.csdn.net/Miracle_86/article/details/135035265?spm=1001.2014.3001.5502" title="C语言中的百宝箱——数组（1）-CSDN博客">C语言中的百宝箱——数组（1）-CSDN博客</a></p> 
 <p><a href="https://blog.csdn.net/Miracle_86/article/details/135048592?spm=1001.2014.3001.5502" title="C语言中的百宝箱——数组（2）-CSDN博客">C语言中的百宝箱——数组（2）-CSDN博客</a></p> 
</blockquote> 
<p>既然我们已经学过数组这种数据结构了，那我们还需要学其它的数据结构嘛？存在即合理，显然数组是有一定的局限性的。</p> 
<p>假定数组有10个空间，已经使用了5个，向数组中插入数据的步骤应该是：</p> 
<blockquote> 
 <p>1. 求数组的长度（这里是10）。</p> 
 <p>2. 求数组的有效数据个数（这里是5）。</p> 
 <p>3. 判断数组是否已满（如果有效数据个数等于数组长度，则数组已满）。</p> 
 <p>4. 如果数组未满，向下标为有效数据个数的位置插入数据。</p> 
</blockquote> 
<p>注意：在插入数据之前，必须判断数组是否已满。如果数组已满，则不能再继续插入数据，否则可能会导致数据覆盖或程序崩溃等严重问题。</p> 
<p>假设数据量非常大，频繁的获取数组有效数据个数确实可能会影响程序执行效率。</p> 
<p>所以我们可以得出<strong>结论</strong>：最基础的数据结构能提供的操作不能满足复杂算法的实现。</p> 
<h3 id="%E4%BA%8C%E3%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%EF%BC%88Sequence%20List%EF%BC%89">二、顺序表（Sequence List）</h3> 
<h4 id="2.1%20%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E7%BB%93%E6%9E%84">2.1 线性表的概念以及结构</h4> 
<p>线性表（linear list）是n个具有相同特性的数据元素的有限序列。线性表是一种在实际中广泛使用的数据结构，常见的线性表包括<strong>顺序表（</strong>Sequence List<strong>）</strong>、链表、栈、队列、字符串等。</p> 
<p>线性表在逻辑上是线性结构，也就是说它表现为一条连续的直线。然而，在物理结构上，线性表并不一定是连续的。线性表在物理上存储时，通常以数组和链式结构的形式存在。数组存储方式使得元素在内存中连续排列，便于通过下标快速访问；而链式存储方式则通过指针或引用将元素链接在一起，允许在动态环境中灵活地进行插入和删除操作。</p> 
<blockquote> 
 <p>如何来理解逻辑结构和物理结构呢？</p> 
</blockquote> 
<p>简单来说，逻辑结构关注的是数据元素之间的逻辑关系，它描述的是数据应该如何被组织，而不关心数据具体是如何在计算机内存中存放的。例如，我们可以说一个列表是一系列有序的元素，这就是它的逻辑结构。</p> 
<p>而物理结构，或者叫存储结构，则关心数据在计算机内存中的具体存放方式。比如，这个列表是用数组的形式连续存储在内存中，还是用链表的形式分散存储在内存中，这就是物理结构所关心的问题。</p> 
<h4 id="2.2%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%88%86%E7%B1%BB">2.2 顺序表分类</h4> 
<h5 id="2.2.1%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB">2.2.1 顺序表和数组的区别</h5> 
<p>其实顺序表的<strong>底层逻辑是数组，</strong>对数组进行了封装，并且实现了常用的<strong>增删查改</strong>等接口。</p> 
<h5 id="2.2.2%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB">2.2.2 顺序表的分类</h5> 
<p>顺序表分为静态顺序表和动态顺序表，顾名思义，一个静态动不了，一个动态可调节。</p> 
<p><span style="color:#1456f0;">• </span><strong>静态顺序表</strong>：</p> 
<p>刚刚我们说了，顺序表是基于数组实现的，那静态顺序表就是基于<strong>定长数组</strong>实现的。</p> 
<pre><code class="language-cpp">//静态顺序表
typedef int SLDataType;
#define N 7
typedef struct SeqList{
    SLDataType a[N];
    int size;
}SL;</code></pre> 
<p><img alt="" height="356" src="https://images2.imgbox.com/40/59/XlvV3ZEB_o.png" width="533"></p> 
<p><span style="color:#1456f0;">• </span><strong>动态顺序表：</strong></p> 
<p>动态一词，我们不由得想起之前提到的动态内存管理，没错动态顺序表确实是需要动态申请的。</p> 
<blockquote> 
 <p><a href="https://blog.csdn.net/Miracle_86/article/details/137629141?spm=1001.2014.3001.5502" title="内存地产风云录：malloc、free、calloc、realloc演绎动态内存世界的楼盘开发与交易大戏-CSDN博客">内存地产风云录：malloc、free、calloc、realloc演绎动态内存世界的楼盘开发与交易大戏-CSDN博客</a></p> 
</blockquote> 
<pre><code class="language-cpp">// 动态顺序表 -- 按需申请
typedef struct SeqList
{
 SLDataType* a;
 int size; // 有效数据个数
 int capacity; // 空间容量
}SL;</code></pre> 
<p> <img alt="" height="346" src="https://images2.imgbox.com/05/c5/2Ue97Ne3_o.png" width="520"></p> 
<h4 id="2.3%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0">2.3 顺序表的实现</h4> 
<p>还记得扫雷嘛各位，当时我们创建了三个文件，分别是：game.c，game.h和test.c。game.c用来存放函数的实现，game.h用来存放头文件以及宏，而test.c用来测试。写完函数进行测试，这是一个良好的习惯，今天我们实现顺序表也会这样操作，但这里不介绍test.c文件，<strong>着重讲解函数的实现。</strong></p> 
<p>首先，我们需要定义一个动态顺序表，我们将定义放在头文件中。</p> 
<pre><code class="language-cpp">//定义顺序表中的数据类型，可以随时修改int
typedef int SLDataType;

//动态
typedef struct SeqList
{
	SLDataType *arr;
	int size; //有效数据个数
	int capacity; //空间大小
}SL;</code></pre> 
<h5 id="2.3.1%20%E5%88%9D%E5%A7%8B%E5%8C%96">2.3.1 初始化</h5> 
<p>接下来我们需要对这个顺序表进行初始化（initialize）。</p> 
<p>这个函数没什么好解释的，只需要将顺序表的成员，指针指向NULL，数变成0。唯一一点重要的是：我们传参的时候，需要传<strong>顺序表的地址。</strong></p> 
<p>要区别传值和传址，我们在这篇文章中解释过：</p> 
<blockquote> 
 <p><a href="https://blog.csdn.net/Miracle_86/article/details/136513969?spm=1001.2014.3001.5502" title="灵魂指针，教给（一）-CSDN博客">灵魂指针，教给（一）-CSDN博客</a></p> 
</blockquote> 
<p>实参传递给形参的时候，形参会单独创建⼀份临时空间来接收实参，对形参的修改不影响实参。如果我们想修改顺序表里的值，那必然得传它的地址。代码如下：</p> 
<pre><code class="language-cpp">//初始化,注意传址
void SLInit(SL* ps)
{
	ps-&gt;arr = NULL;
	ps-&gt;capacity = ps-&gt;size = 0;

}</code></pre> 
<h5 id="%C2%A02.3.2%20%E9%94%80%E6%AF%81"> 2.3.2 销毁</h5> 
<p>这个函数也很简单，我们既然是动态申请的空间，就需要将其free掉。</p> 
<p>函数实现：</p> 
<pre><code class="language-cpp">//销毁
void SLDestroy(SL* ps)
{
	if (ps-&gt;arr)
	{
		free(ps-&gt;arr);
	}
	ps-&gt;arr = NULL;
	ps-&gt;capacity = ps-&gt;size = 0;
}
</code></pre> 
<h5 id="2.3.3%20%E5%B0%BE%E6%8F%92">2.3.3 尾插</h5> 
<p>我们在尾插的时候，试想一下，如果空间不够，是不是就没位置插了，这个时候我们要重新开辟空间，并且，我们在初始化后，空间是0，肯定需要申请。所以这里我们需要一个函数来进行扩容：</p> 
<pre><code class="language-cpp">//扩容
void SLCheckCapacity(SL* ps)
{
	assert(ps);
	//先判断空间是否足够，不够需要扩容

	if (ps-&gt;capacity == ps-&gt;size) //不够扩容
	{
		//申请空间
		//三目判断初始空间大小
		int NewCapacity = ps-&gt;capacity == 0 ? 4 : ps-&gt;capacity * 2;
		SLDataType* tmp = (SLDataType*)realloc(ps-&gt;arr, NewCapacity * sizeof(SLDataType));
		if (tmp == NULL)
		{
			perror("realloc fail");
			exit(1);
		}
		ps-&gt;arr = tmp;
		ps-&gt;capacity = NewCapacity;
	}
}</code></pre> 
<p>首先我们用assert断言防止空指针，之后我们用到了if语句来判断空间是否足够，如果不够则进入if扩容。判断条件我们仔细想想，什么情况是空间不够，是不是<strong>当空间大小和有效数据个数相等时</strong>，就没法插入了，所以我们将这个作为判断条件。</p> 
<p>扩容搞定后，我们就可以进行插入操作了，在尾插中，我们需要传入两个参数：一个是顺序表的地址，另一个是要插入的元素。</p> 
<p>尾插其实很简单，我们只需要将最后的位置赋值为要插入的元素就可以了，最后别忘了既然插进去了一个元素，<strong>有效数据个数肯定要++。</strong></p> 
<pre><code class="language-cpp">//尾插
void SLPushBack(SL* ps, SLDataType x)
{
	SLCheckCapacity(ps);
	 //足够尾插
	ps-&gt;arr[ps-&gt;size++] = x;
	/*ps-&gt;arr[ps-&gt;size] = x;
	ps-&gt;size++;*/
	
}</code></pre> 
<h5 id="2.3.4%20%E5%A4%B4%E6%8F%92">2.3.4 头插</h5> 
<p>尾插我们直接在尾巴后面插入元素即可，头插意味着我们要在头部插入一个元素，那么我们就需要在头部为其留出位置，同时原有元素还不可以改变。有了位置再进行插入，思路清晰，直接上代码。</p> 
<pre><code class="language-cpp">//头插
void SLPushFront(SL* ps, SLDataType x)
{
	SLCheckCapacity(ps);
	//整体挪动，再插入
	for (int i = ps-&gt;size; i &gt; 0; i--)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i - 1];
	}
	ps-&gt;arr[0] = x;
	ps-&gt;size++;
}</code></pre> 
<p>这里注意，for循环遍历时，从后往前遍历，防止覆盖。</p> 
<h5 id="2.3.5%20%E5%B0%BE%E5%88%A0">2.3.5 尾删</h5> 
<p>大家想想，怎么删，将最后一个元素置为-1？还是别的什么数字？其实我们根本不需要管最后一个元素，我们直接将size进行 - - 即可。因为不影响其它功能，所以我们不用考虑那么复杂。</p> 
<pre><code class="language-cpp">//尾删
void SLPopBack(SL* ps)
{
	assert(ps);
	assert(ps-&gt;size);
	//删完数据，size--
	//ps-&gt;arr[ps-&gt;size - 1] = -1;要不要这行都可以
	ps-&gt;size--;
}</code></pre> 
<h5 id="2.3.6%20%E5%A4%B4%E5%88%A0">2.3.6 头删</h5> 
<p>头删也很简单，直接覆盖即可。</p> 
<pre><code class="language-cpp">//头删
void SLPopFront(SL* ps)
{
	assert(ps);
	assert(ps-&gt;size);
	//直接覆盖即可
	for (int i = 1; i &lt; ps-&gt;size; i++)
	{
		ps-&gt;arr[i - 1] = ps-&gt;arr[i];
	}
	ps-&gt;size--;
}</code></pre> 
<h5 id="2.3.7%20%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5">2.3.7 在指定位置插入</h5> 
<p>我们效仿头插遍历，为元素留位置，在指定位置插入也是如此。</p> 
<pre><code class="language-cpp">//在指定位置插入
void SLInsert(SL* ps, int pos, SLDataType x)//注意pos是下标
{
	assert(ps);
	assert(pos &gt;= 0 &amp;&amp; pos &lt;= ps-&gt;size);
	SLCheckCapacity(ps);
	for (int i = ps-&gt;size; i &gt; pos; i--)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i - 1];//arr[pos+1]=arr[pos];
	}
	ps-&gt;arr[pos] = x;
	ps-&gt;size++;
}</code></pre> 
<h5 id="2.3.8%20%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E5%88%A0%E9%99%A4">2.3.8 在指定位置删除</h5> 
<p>同样是遍历，同样是覆盖，不多解释，直接上代码。</p> 
<pre><code class="language-cpp">//在指定位置删除
void SLErase(SL* ps, int pos)
{
	assert(ps);
	assert(pos &gt;= 0 &amp;&amp; pos &lt; ps-&gt;size);
	for (int i = pos; i &lt; ps-&gt;size - 1; i++)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i + 1];//arr[size-2]=arr[size-1]
	}
	ps-&gt;size--;
}</code></pre> 
<h5 id="2.3.9%20%E6%9F%A5%E6%89%BE">2.3.9 查找</h5> 
<p>其实查找也是遍历，我们可以发现，但凡我们弄清原理之后，顺序表还是蛮简单的。</p> 
<pre><code class="language-cpp">//查找
int SLFind(SL* ps, SLDataType x)
{
	assert(ps);
	for (int i = 0; i &lt; ps-&gt;size; i++)
	{
		if (ps-&gt;arr[i] == x)
		{
			return i;
		}
	}
	return -1;
}</code></pre> 
<h4 id="%C2%A02.4%20%E6%80%BB%E4%BB%A3%E7%A0%81"> 2.4 总代码</h4> 
<h5 id="2.4.1%20SeqList.h">2.4.1 SeqList.h</h5> 
<pre><code class="language-cpp">#pragma once
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
//定义顺序表的结构

//#define N 100


//静态顺序表
//struct SeqList
//{
//	int arr[N];
//	int size;//有效数据个数
//};

//定义顺序表中的数据类型，可以随时修改int
typedef int SLDataType;

//动态
typedef struct SeqList
{
	SLDataType *arr;
	int size; //有效数据个数
	int capacity; //空间大小
}SL;

//typedef struct SeqList SL;

//初始化
void SLInit(SL* ps);
//销毁
void SLDestroy(SL* ps);
//打印
void SLPrint(SL* ps);
//扩容
void SLCheckCapacity(SL* ps);
//尾部插入删除 / 头部插入删除
void SLPushBack(SL* ps, SLDataType x);
void SLPushFront(SL* ps, SLDataType x);

void SLPopBack(SL* ps);
void SLPopFront(SL* ps);
//指定位置之前插入/删除数据
void SLInsert(SL* ps, int pos, SLDataType x);
void SLErase(SL* ps, int pos);
//查找
int SLFind(SL* ps, SLDataType x);</code></pre> 
<h5 id="2.4.2%20SeqList.c" style="background-color:transparent;">2.4.2 SeqList.c</h5> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#include"SeqList.h"

//初始化,注意传址
void SLInit(SL* ps)
{
	ps-&gt;arr = NULL;
	ps-&gt;capacity = ps-&gt;size = 0;

}
//销毁
void SLDestroy(SL* ps)
{
	if (ps-&gt;arr)
	{
		free(ps-&gt;arr);
	}
	ps-&gt;arr = NULL;
	ps-&gt;capacity = ps-&gt;size = 0;
}
//打印
void SLPrint(SL* ps)
{
	for (int i = 0; i &lt; ps-&gt;size; i++)
	{
		printf("%d ", ps-&gt;arr[i]);
	}
	printf("\n");
}
//扩容
void SLCheckCapacity(SL* ps)
{
	assert(ps);
	//先判断空间是否足够，不够需要扩容

	if (ps-&gt;capacity == ps-&gt;size) //不够扩容
	{
		//申请空间
		//三目判断初始空间大小
		int NewCapacity = ps-&gt;capacity == 0 ? 4 : ps-&gt;capacity * 2;
		SLDataType* tmp = (SLDataType*)realloc(ps-&gt;arr, NewCapacity * sizeof(SLDataType));
		if (tmp == NULL)
		{
			perror("realloc fail");
			exit(1);
		}
		ps-&gt;arr = tmp;
		ps-&gt;capacity = NewCapacity;
	}
}
//尾插
void SLPushBack(SL* ps, SLDataType x)
{
	SLCheckCapacity(ps);
	 //足够尾插
	ps-&gt;arr[ps-&gt;size++] = x;
	/*ps-&gt;arr[ps-&gt;size] = x;
	ps-&gt;size++;*/
	
}
//头插
void SLPushFront(SL* ps, SLDataType x)
{
	SLCheckCapacity(ps);
	//整体挪动，再插入
	for (int i = ps-&gt;size; i &gt; 0; i--)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i - 1];
	}
	ps-&gt;arr[0] = x;
	ps-&gt;size++;
}
//尾删
void SLPopBack(SL* ps)
{
	assert(ps);
	assert(ps-&gt;size);
	//删完数据，size--
	//ps-&gt;arr[ps-&gt;size - 1] = -1;要不要这行都可以
	ps-&gt;size--;
}
//头删
void SLPopFront(SL* ps)
{
	assert(ps);
	assert(ps-&gt;size);
	//直接覆盖即可
	for (int i = 1; i &lt; ps-&gt;size; i++)
	{
		ps-&gt;arr[i - 1] = ps-&gt;arr[i];
	}
	ps-&gt;size--;
}
//在指定位置插入
void SLInsert(SL* ps, int pos, SLDataType x)//注意pos是下标
{
	assert(ps);
	assert(pos &gt;= 0 &amp;&amp; pos &lt;= ps-&gt;size);
	SLCheckCapacity(ps);
	for (int i = ps-&gt;size; i &gt; pos; i--)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i - 1];//arr[pos+1]=arr[pos];
	}
	ps-&gt;arr[pos] = x;
	ps-&gt;size++;
}
//在指定位置删除
void SLErase(SL* ps, int pos)
{
	assert(ps);
	assert(pos &gt;= 0 &amp;&amp; pos &lt; ps-&gt;size);
	for (int i = pos; i &lt; ps-&gt;size - 1; i++)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i + 1];//arr[size-2]=arr[size-1]
	}
	ps-&gt;size--;
}
//查找
int SLFind(SL* ps, SLDataType x)
{
	assert(ps);
	for (int i = 0; i &lt; ps-&gt;size; i++)
	{
		if (ps-&gt;arr[i] == x)
		{
			return i;
		}
	}
	return -1;
}</code></pre> 
<hr> 
<p>完</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/617a8b29a312d20beb181c40504409ee/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">离线数仓（五）【数据仓库建模】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1eacc761b070bdb7d9dae9ff626d9c7b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android Studio超级详细讲解下载、安装配置教程（建议收藏）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>