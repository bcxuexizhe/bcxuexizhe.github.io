<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C语言视角】数据结构之~二叉树 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/e72d6491d0c830e24cf037c1a223db35/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【C语言视角】数据结构之~二叉树">
  <meta property="og:description" content="前言：总所周知~数据结构的二叉树对于初学者来说是一个十分难理解的知识点。接下来，请阅读本人对二叉树拙劣的理解~
目录
1.二叉树概念及结构 和性质 二叉树的结构 二叉树的存储结构
2.二叉树顺序结构
3.二叉树链式结构的实现
二叉树层序遍历
1.二叉树概念及结构 和性质 1.1二叉树的概念 二叉树(Binary Tree)：是n(n≥0)个结点的有限集合，该集合或者为空集(称为空二叉树)，或者由一个根结点和两颗互不相交的、分别称为根结点的左子树和右子树的二叉树组成。
总而言之 满足以下两个条件的树就是二叉树：
1、本身是有序树；
2、树中包含的各个结点的度不能超过 2，即只能是 0、1 或者 2；
1.2二叉树的结构 由上图可得：
1. 二叉树不存在度大于2的结点 2. 二叉树的子树有左右之分，次序不能颠倒，因此二叉树是有序树 注意：对于任意的二叉树都是由以下几种情况复合而成的： 1.3二叉树的性质 1：在二叉树的第i层上最多有2^(i-1)个结点（i≥1）。
第一层是根结点，只有一个，所以2(1-1）=20=1。 第二层有两个，2(2-1)=21=2。 第三层有四个，2(3-1)=22=4。 第四层有八个，2(4-1)=2^3=8。
2：深度为k的二叉树至多有2^k-1个结点（k≥1）。
注意这里一定要看清楚，是2k后再减去1，而不是2(k-1)。以前很多同学不能完全理解，这样去记忆，就容易把性质2与性质1给弄混淆了。 深度为k意思就是有k层的二叉树，我们先来看看简单的。 如果有一层，至多1=21-1个结点。 如果有二层，至多1&#43;2=3=22-1个结点。 如果有三层，至多1&#43;2&#43;4=7=23-1个结点。 如果有四层，至多1&#43;2&#43;4&#43;8=15=2^4-1个结点。
3：对任何一棵二叉树，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2&#43;1。
终端结点数其实就是叶子结点数，而一棵二叉树，除了叶子结点外，剩下的就是度为1或2的结点数了，我们设n1为度是1的结点数。则树T结点总数n=n0&#43;n1&#43;n2
终端结点数其实就是叶子结点数，而一棵二叉树，除了叶子结点外，剩下的就是度为1或2的结点数了，我们设n1为度是1的结点数。则树T结点总数n=n0&#43;n1&#43;n2 。
4：具有n个结点的完全二叉树的深度为|log（2^n）&#43;1| (向下取整)。
由满二叉树的定义我们可以知道，深度为k的满二叉树的结点数n一定是2k-1。因为这是最多的结点个数。那么对于n=2k-1倒推得到满二叉树的深度为k=log2(n＋1)，比如结点数为15的满二叉树，深度为4。
5：如果对一棵有n个结点的完全二叉树（其深度为|log（2^n）&#43;1|）的结点按层序编号（从第一层到第层，每层从左到右），对任一结点i（1&lt;=i&lt;=n），有
1．如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点。
2．如果2i&gt;n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i。
3．如果2i&#43;1&gt;n，则结点i无右孩子；否则其右孩子是结点2i&#43;1
二叉树的存储结构 二叉树一般可以使用两种结构存储，一种顺序结构，一种链式结构。 1. 顺序存储 顺序结构存储就是使用数组来存储，一般使用数组只适合表示完全二叉树，因为不是完全二叉树会有空 间的浪费。而现实中使用中只有堆才会使用数组来存储，关于堆我们后面的章节会专门讲解。二叉树顺 序存储在物理上是一个数组，在逻辑上是一颗二叉树。 2. 链式存储 二叉树的链式存储结构是指，用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。 通常的方法是 链表中每个结点由三个域组成，数据域和左右指针域，左右指针分别用来给出该结点左孩子和右孩子所 在的链结点的存储地址 。链式结构又分为二叉链和三叉链，当前我们学习中一般都是二叉链，后面课程 学到高阶数据结构如红黑树等会用到三叉链。 2.二叉树顺序结构 普通的二叉树是不适合用数组来存储的，因为可能会存在大量的空间浪费。而完全二叉树更适合使用顺序结 构存储。现实中我们通常把堆( 一种二叉树 ) 使用顺序结构的 数组 来存储，需要注意的是这里的堆和操作系统 虚拟进程地址空间中的堆是两回事，一个是数据结构，一个是操作系统中管理内存的一块区域分段。 3.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-04T19:31:30+08:00">
    <meta property="article:modified_time" content="2024-05-04T19:31:30+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C语言视角】数据结构之~二叉树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#fe2c24;"><em>前言：总所周知~数据结构的二叉树对于初学者来说是一个十分难理解的知识点。接下来，请阅读本人对二叉树拙劣的理解~</em></span></p> 
<div></div> 
<div> 
 <p></p> 
</div> 
<div> 
 <p id="main-toc"><strong>目录</strong></p> 
 <p id="1.%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84%C2%A0%20%C2%A0%C2%A0-toc" style="margin-left:80px;"><a href="#1.%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84%C2%A0%20%C2%A0%C2%A0" rel="nofollow">1.二叉树概念及结构 和性质   </a></p> 
 <p id="1.2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84%C2%A0-toc" style="margin-left:120px;"><a href="#1.2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84%C2%A0" rel="nofollow">二叉树的结构 </a></p> 
 <p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-toc" style="margin-left:120px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84" rel="nofollow">二叉树的存储结构</a></p> 
 <p id="2.%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#2.%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84" rel="nofollow">2.二叉树顺序结构</a></p> 
 <p id="3.%E4%BA%8C%E5%8F%89%E6%A0%91%E9%93%BE%E5%BC%8F%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#3.%E4%BA%8C%E5%8F%89%E6%A0%91%E9%93%BE%E5%BC%8F%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">3.二叉树链式结构的实现</a></p> 
 <p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:120px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow">二叉树层序遍历</a></p> 
 <hr id="hr-toc"> 
 <p></p> 
 <p></p> 
</div> 
<h4 id="1.%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84%C2%A0%20%C2%A0%C2%A0"><span style="color:#333333;"><strong>1.二叉树概念及结构</strong></span><span style="color:#333333;"><strong> 和性质   </strong></span></h4> 
<p><span style="color:#333333;"><strong>1.1二叉</strong></span><span style="color:#333333;"><strong>树的概念 </strong></span></p> 
<blockquote> 
 <div> 
  <span style="color:#0d0016;">      </span> 
  <p><span style="color:#0d0016;">二叉树(Binary Tree)：是n(n≥0)个结点的有限集合，该集合或者为空集(称为空二叉树)，或者由一个根结点和两颗互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</span></p> 
  <p><span style="color:#0d0016;">总而言之 满足以下两个条件的树就是二叉树：</span></p> 
  <p><span style="color:#0d0016;">        1、本身是有序树；<br>         2、树中包含的各个结点的度不能超过 2，即只能是 0、1 或者 2；</span></p> 
  <p></p> 
 </div> 
 <div></div> 
</blockquote> 
<h5 id="1.2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84%C2%A0"><span style="color:#333333;"><strong>1.2二叉树的结构</strong></span><span style="color:#333333;"><strong> </strong></span></h5> 
<p><img alt="" height="424" src="https://images2.imgbox.com/55/48/HhuJ9ySS_o.png" width="876">由上图可得：</p> 
<div> 
 <span style="color:#fe2c24;">1. 二叉树不存在度大于2的结点 </span> 
</div> 
<div> 
 <span style="color:#fe2c24;">2. 二叉树的子树有左右之分，次序不能颠倒，因此二叉树是有序树 </span> 
</div> 
<div></div> 
<div> 
 <span style="color:#777777;">注意：对于任意的二叉树都是由以下几种情况复合而成的： </span> 
</div> 
<div> 
 <img alt="" height="235" src="https://images2.imgbox.com/b1/40/IyLeG8H3_o.png" width="769"> 
</div> 
<div></div> 
<div>
  1.3二叉树的性质 
</div> 
<div></div> 
<div> 
 <blockquote> 
  <p><strong><span style="color:#fe2c24;">1：在二叉树的第i层上最多有2^(i-1)个结点（i≥1）。</span></strong><br> 第一层是根结点，只有一个，所以2(1-1）=20=1。 第二层有两个，2(2-1)=21=2。 第三层有四个，2(3-1)=22=4。 第四层有八个，2(4-1)=2^3=8。</p> 
  <p><strong><span style="color:#fe2c24;">2：深度为k的二叉树至多有2^k-1个结点（k≥1）。</span></strong><br> 注意这里一定要看清楚，是2k后再减去1，而不是2(k-1)。以前很多同学不能完全理解，这样去记忆，就容易把性质2与性质1给弄混淆了。 深度为k意思就是有k层的二叉树，我们先来看看简单的。 如果有一层，至多1=21-1个结点。 如果有二层，至多1+2=3=22-1个结点。 如果有三层，至多1+2+4=7=23-1个结点。 如果有四层，至多1+2+4+8=15=2^4-1个结点。</p> 
  <p><strong><span style="color:#fe2c24;">3：对任何一棵二叉树，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。</span></strong><br> 终端结点数其实就是叶子结点数，而一棵二叉树，除了叶子结点外，剩下的就是度为1或2的结点数了，我们设n1为度是1的结点数。则树T结点总数n=n0+n1+n2<br> 终端结点数其实就是叶子结点数，而一棵二叉树，除了叶子结点外，剩下的就是度为1或2的结点数了，我们设n1为度是1的结点数。则树T结点总数n=n0+n1+n2 。</p> 
  <p><span style="color:#fe2c24;"><strong>4：具有n个结点的完全二叉树的深度为|log（2^n）+1|  (向下取整)。</strong></span><br> 由满二叉树的定义我们可以知道，深度为k的满二叉树的结点数n一定是2k-1。因为这是最多的结点个数。那么对于n=2k-1倒推得到满二叉树的深度为k=log2(n＋1)，比如结点数为15的满二叉树，深度为4。</p> 
  <p><span style="color:#fe2c24;">5：如果对一棵有n个结点的完全二叉树（其深度为|log（2^n）+1|）的结点按层序编号（从第一层到第层，每层从左到右），对任一结点i（1&lt;=i&lt;=n），有<br> 1．如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点。<br> 2．如果2i&gt;n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i。<br> 3．如果2i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2i+1</span></p> 
 </blockquote> 
</div> 
<h5 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span style="color:#333333;"><strong>二叉树的存储结构 </strong></span></h5> 
<div> 
 <em><span style="color:#777777;">二叉树一般可以使用两种结构存储，一种顺序结构，一种链式结构。 </span></em> 
</div> 
<div> 
 <em><span style="color:#777777;">1. </span><span style="color:#777777;"><strong>顺序存储 </strong></span></em> 
</div> 
<div> 
 <em><span style="color:#777777;">        顺序结构存储就是使用<strong>数组来存储</strong></span><span style="color:#777777;">，一般使用数组</span><span style="color:#777777;"><strong>只适合表示完全二叉树</strong></span><span style="color:#777777;">，因为不是完全二叉树会有空 间的浪费。而现实中使用中只有堆才会使用数组来存储，关于堆我们后面的章节会专门讲解。<strong>二叉树顺 </strong></span><span style="color:#777777;"><strong>序存储在物理上是一个数组，在逻辑上是一颗二叉树。 </strong></span></em> 
</div> 
<div></div> 
<div> 
 <div> 
  <em><span style="color:#777777;">2. </span><span style="color:#777777;"><strong>链式存储 </strong></span></em> 
 </div> 
 <div> 
  <em><span style="color:#777777;">        二叉树的链式存储结构是指，用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。 通常的方法是 链表中每个结点由三个域组成，数据域和左右指针域，左右指针分别用来给出该结点左孩子和右孩子所 在的链结点的存储地址 。链式结构又分为二叉链和三叉链，当前我们学习中一般都是二叉链，后面课程 学到高阶数据结构如红黑树等会用到三叉链。</span></em> 
 </div> 
 <div></div> 
</div> 
<h4 id="2.%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span style="color:#333333;"><strong>2.二叉树顺序结构</strong></span></h4> 
<div> 
 <span style="color:#777777;">        普通的二叉树是不适合用数组来存储的，因为可能会存在大量的空间浪费。而完全二叉树更适合使用顺序结 构存储。<strong>现实中我们通常把堆(</strong></span> 
 <span style="color:#777777;"><strong>一种二叉树</strong></span> 
 <span style="color:#777777;"><strong>)</strong></span> 
 <span style="color:#777777;"><strong>使用顺序结构的</strong></span> 
 <span style="color:#fe2c24;"><strong>数组</strong></span> 
 <span style="color:#777777;"><strong>来存储，需要注意的是这里的堆和操作系统 </strong></span> 
 <span style="color:#777777;"><strong>虚拟进程地址空间中的堆是两回事，一个是数据结构，一个是操作系统中管理内存的一块区域分段。</strong></span> 
</div> 
<div></div> 
<div></div> 
<h4 id="3.%E4%BA%8C%E5%8F%89%E6%A0%91%E9%93%BE%E5%BC%8F%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0"><span style="color:#333333;"><strong>3.二叉树链式结构的实现</strong></span></h4> 
<div> 
 <span style="color:#777777;"><strong>从概念出发，二叉树是： </strong></span> 
</div> 
<div> 
 <span style="color:#777777;">1. </span> 
 <span style="color:#777777;"><strong>空树 </strong></span> 
</div> 
<div> 
 <span style="color:#777777;">2. </span> 
 <span style="color:#777777;"><strong>非空：根节点，根节点的左子树、根节点的右子树组成的。 </strong></span> 
</div> 
<div> 
 <img alt="" height="424" src="https://images2.imgbox.com/5e/9a/bF9fRvCS_o.png" width="876"> 
</div> 
<p><span style="color:#0d0016;">从概念中可以看出，二叉树定义是递归式的，因此后序基本操作中基本都是按照该概念实现的。 </span></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span style="color:#333333;"><strong>二叉树的遍历 </strong></span></p> 
<div> 
 <span style="color:#0d0016;">二叉树遍历分有三种遍历，分别是<strong>前序、中序以及后序遍历</strong></span> 
</div> 
<div> 
 <span style="color:#0d0016;">        所谓<strong>二叉树遍历(Traversal)是按照某种特定的规则，依次对二叉 树中的节点进行相应的操作，并且每个节点只操作一次</strong>。访问结点所做的操作依赖于具体的应用问题。 遍历 是二叉树上最重要的运算之一，也是二叉树上进行其它运算的基础。</span> 
</div> 
<div> 
 <p class="img-center"><img alt="" height="264" src="https://images2.imgbox.com/96/1b/jgdR7fgZ_o.png" width="481"></p> 
 <div> 
  <span style="color:#0d0016;">按照规则，二叉树的遍历有：<strong>前序/中序/后序的递归结构遍历</strong>： </span> 
 </div> 
 <div> 
  <span style="color:#0d0016;">1. 前序遍历(Preorder Traversal 亦称先序遍历)——访问根结点的操作发生在遍历其左右子树之前。 </span> 
 </div> 
 <div> 
  <span style="color:#0d0016;">2. 中序遍历(Inorder Traversal)——访问根结点的操作发生在遍历其左右子树之中（间）。 </span> 
 </div> 
 <div> 
  <span style="color:#0d0016;">3. 后序遍历(Postorder Traversal)——访问根结点的操作发生在遍历其左右子树之后。</span> 
 </div> 
 <div> 
  <div> 
   <span style="color:#0d0016;"><strong>由于被访问的结点必是某子树的根，所以N(Node）、L(Left subtree）和R(Right subtree）又可解释为 </strong></span> 
   <span style="color:#0d0016;"><strong>根、根的左子树和根的右子树。NLR、LNR和LRN分别又称为先根遍历、中根遍历和后根遍历。</strong></span> 
  </div> 
  <div> 
   <pre><code>// 二叉树前序遍历
void PreOrder(BTNode* root);
// 二叉树中序遍历
void InOrder(BTNode* root);
// 二叉树后序遍历
void PostOrder(BTNode* root);</code></pre> 
   <p><strong><em>我们从图片分析二叉树是如何进行前序遍历的~</em></strong></p> 
   <p><img alt="" height="451" src="https://images2.imgbox.com/49/cb/QyrgqDx7_o.png" width="861"></p> 
   <blockquote> 
    <p>前序遍历的代码如下：</p> 
    <pre><code class="language-cpp">//前序遍历
void PreOrderTraverse(BTree T){
	if(T == NULL)
		return;
	printf("%d",T-&gt;data);
	PreOrderTraverse(T-&gt;LChild);
	PreOrderTraverse(T-&gt;RChild);
}
</code></pre> 
   </blockquote> 
  </div> 
 </div> 
</div> 
<p> 中序/后序遍历跟前序遍历差不多，差异点就在如何显示根的位置~</p> 
<h5 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><strong>二叉树层序遍历</strong></h5> 
<p></p> 
<div> 
 <span style="color:#0d0016;"><strong>层序遍历</strong>：除了先序遍历、中序遍历、后序遍历外，还可以对二叉树进行层序遍历。设二叉树的根节点所在层数为1，层序遍历就是从所在二叉树的根节点出发，首先访问第一层的树根节点，然后从左到右访问第2层上的节点，接着是第三层的节点，以此类推，自上而下，自左至右逐层访问树的结点的过程就是层序遍历。</span> 
</div> 
<div> 
 <p class="img-center"><img alt="" height="280" src="https://images2.imgbox.com/34/b8/dQz74u2p_o.png" width="309"></p> 
</div> 
<div>
  以下有几道题目可供大家进一步理解哦~ 
</div> 
<div> 
 <blockquote> 
  <div> 
   <span style="color:#777777;"><strong>练习</strong></span> 
   <span style="color:#777777;">：请写出下面的前序</span> 
   <span style="color:#777777;">/</span> 
   <span style="color:#777777;">中序</span> 
   <span style="color:#777777;">/</span> 
   <span style="color:#777777;">后序</span> 
   <span style="color:#777777;">/</span> 
   <span style="color:#777777;">层序遍历</span> 
  </div> 
  <div> 
   <p></p> 
   <div> 
    <span style="color:#777777;">1.</span> 
    <span style="color:#777777;">某完全二叉树按层次输出（同一层从左到右）的序列为</span> 
    <span style="color:#777777;"> ABCDEFGH </span> 
    <span style="color:#777777;">。该完全二叉树的前序序列为（） </span> 
   </div> 
   <div> 
    <span style="color:#777777;">A ABDHECFG </span> 
   </div> 
   <div> 
    <span style="color:#777777;">B ABCDEFGH </span> 
   </div> 
   <div> 
    <span style="color:#777777;">C HDBEAFCG </span> 
   </div> 
   <div> 
    <span style="color:#777777;">D HDEBFGCA </span> 
   </div> 
   <div> 
    <span style="color:#777777;">2.</span> 
    <span style="color:#777777;">二叉树的先序遍历和中序遍历如下：先序遍历：</span> 
    <span style="color:#777777;">EFHIGJK;</span> 
    <span style="color:#777777;">中序遍历：</span> 
    <span style="color:#777777;">HFIEJKG.</span> 
    <span style="color:#777777;">则二叉树根结点为（） </span> 
   </div> 
   <div> 
    <span style="color:#777777;">A E </span> 
   </div> 
   <div> 
    <span style="color:#777777;">B F </span> 
   </div> 
   <div> 
    <span style="color:#777777;">C G </span> 
   </div> 
   <div> 
    <span style="color:#777777;">D H </span> 
   </div> 
   <div> 
    <span style="color:#777777;">3.</span> 
    <span style="color:#777777;">设一课二叉树的中序遍历序列：</span> 
    <span style="color:#777777;">badce</span> 
    <span style="color:#777777;">，后序遍历序列：</span> 
    <span style="color:#777777;">bdeca</span> 
    <span style="color:#777777;">，则二叉树前序遍历序列为</span> 
    <span style="color:#777777;">____</span> 
    <span style="color:#777777;">。 </span> 
   </div> 
   <div> 
    <span style="color:#777777;">A adbce </span> 
   </div> 
   <div> 
    <span style="color:#777777;">B decab </span> 
   </div> 
   <div> 
    <span style="color:#777777;">C debac </span> 
   </div> 
   <div> 
    <span style="color:#777777;">D abcde </span> 
   </div> 
   <div> 
    <span style="color:#777777;">4.</span> 
    <span style="color:#777777;">某二叉树的后序遍历序列与中序遍历序列相同，均为</span> 
    <span style="color:#777777;"> ABCDEF </span> 
    <span style="color:#777777;">，则按层次输出（同一层从左到右）的序列</span> 
   </div> 
   <div> 
    <span style="color:#777777;">为 </span> 
   </div> 
   <div> 
    <span style="color:#777777;">A FEDCBA </span> 
   </div> 
   <div> 
    <span style="color:#777777;">B CBAFED </span> 
   </div> 
   <div> 
    <span style="color:#777777;">C DEFCBA </span> 
   </div> 
   <div> 
    <span style="color:#777777;">D ABCDE</span> 
   </div> 
   <div></div> 
  </div> 
 </blockquote> 
</div> 
<p>答案： <span style="color:#777777;">1.A  2.A  3.D  4.A</span></p> 
<hr> 
<p><strong><em><span style="color:#fe2c24;">以上就是鄙人对二叉树的小小拙见~，接下来让我们继续努力，共同进步~一起成为编程高手！！</span></em></strong></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ff35ea70cda1caebeb0b2ab7ffea590e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spark01 —— Spark基础</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3181b037997c72d557f46feb5326df9b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构】第四讲：双向链表</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>