<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构十三：八大排序算法 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/b24459880bf84d2861d0a41726a91cfc/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="数据结构十三：八大排序算法">
  <meta property="og:description" content="排序算法（sorting algorithm）是用于对一组数据按照特定顺序进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更高效地查找、分析和处理。排序算法中的数据类型可以是整数、浮点数、字符或字符串等。排序的判断规则可根据需求设定，如数字大小、字符 ASCII 码顺序或自定义规则，本篇博客详细介绍常见的八大排序算法的基本思想以及实现过程，以及对于算法效率的分析和比较，希望通过本篇博客，能够深入掌握排序算法！
目录
一、排序简介
1.1 什么是排序？
1.2 排序的目的是什么？
1.3 排序的应用场景
1.4 排序算法好坏的度量指标
1.5 排序算法的分类
二、常见排序算法的实现（以升序为例）
2.1 插入类排序—&gt;直接插入排序
2.1.1 基本思想
2.1.2 算法步骤
2.1.3 图解算法 2.1.4 代码实现
2.1.5 测试
2.1.6 算法分析
2.1.7 优缺点
2.1.8 如何优化
2.2 插入类排序—&gt;希尔排序（难）
2.2.1 基本思想
2.2.2 希尔排序的增量数组
2.2.3 算法步骤
2.2.4 图解算法(有横线的值认为已经有序)
2.2.5 代码实现
2.2.6 核心代码分析
​2.2.7 测试
2.2.8 算法分析
2.2.9 总结
2.3 选择类排序—&gt;简单选择排序
2.3.1基本思想
2.3.2算法步骤
2.3.3图解算法
2.3.4代码实现
2.3.5测试
2.3.6算法分析
2.4 选择类排序—&gt;堆排序（难）
2.4.0 铺垫知识 2.4.1 大小堆介绍">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-13T20:22:17+08:00">
    <meta property="article:modified_time" content="2024-05-13T20:22:17+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构十三：八大排序算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>       排序算法（sorting algorithm）是用于对一组数据按照特定顺序进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更高效地查找、分析和处理。排序算法中的数据类型可以是整数、浮点数、字符或字符串等。排序的判断规则可根据需求设定，如数字大小、字符 ASCII 码顺序或自定义规则，本篇博客详细介绍常见的八大排序算法的基本思想以及实现过程，以及对于算法效率的分析和比较，希望通过本篇博客，能够深入掌握排序算法！</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%80%E4%BB%8B" rel="nofollow">一、排序简介</a></p> 
<p id="1.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%92%E5%BA%8F%EF%BC%9F-toc" style="margin-left:40px;"><a href="#1.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%92%E5%BA%8F%EF%BC%9F" rel="nofollow">1.1 什么是排序？</a></p> 
<p id="1.2%20%E6%8E%92%E5%BA%8F%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:40px;"><a href="#1.2%20%E6%8E%92%E5%BA%8F%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">1.2 排序的目的是什么？</a></p> 
<p id="1.3%20%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#1.3%20%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">1.3 排序的应用场景</a></p> 
<p id="1.4%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A5%BD%E5%9D%8F%E7%9A%84%E5%BA%A6%E9%87%8F%E6%8C%87%E6%A0%87-toc" style="margin-left:40px;"><a href="#1.4%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A5%BD%E5%9D%8F%E7%9A%84%E5%BA%A6%E9%87%8F%E6%8C%87%E6%A0%87" rel="nofollow">1.4 排序算法好坏的度量指标</a></p> 
<p id="1.5%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB-toc" style="margin-left:40px;"><a href="#1.5%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB" rel="nofollow">1.5 排序算法的分类</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BB%A5%E5%8D%87%E5%BA%8F%E4%B8%BA%E4%BE%8B%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BB%A5%E5%8D%87%E5%BA%8F%E4%B8%BA%E4%BE%8B%EF%BC%89" rel="nofollow">二、常见排序算法的实现（以升序为例）</a></p> 
<p id="2.1%20%E6%8F%92%E5%85%A5%E7%B1%BB%E6%8E%92%E5%BA%8F%E2%80%94%3E%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#2.1%20%E6%8F%92%E5%85%A5%E7%B1%BB%E6%8E%92%E5%BA%8F%E2%80%94%3E%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" rel="nofollow">2.1 插入类排序—&gt;直接插入排序</a></p> 
<p id="2.1.1%20%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-toc" style="margin-left:80px;"><a href="#2.1.1%20%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" rel="nofollow">2.1.1 基本思想</a></p> 
<p id="2.1.2%20%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-toc" style="margin-left:80px;"><a href="#2.1.2%20%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4" rel="nofollow">2.1.2 算法步骤</a></p> 
<p id="2.1.3%20%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95%C2%A0-toc" style="margin-left:80px;"><a href="#2.1.3%20%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95%C2%A0" rel="nofollow">2.1.3 图解算法 </a></p> 
<p id="2.1.4%C2%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#2.1.4%C2%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">2.1.4 代码实现</a></p> 
<p id="2.1.5%C2%A0%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#2.1.5%C2%A0%E6%B5%8B%E8%AF%95" rel="nofollow">2.1.5 测试</a></p> 
<p id="2.1.6%C2%A0%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#2.1.6%C2%A0%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90" rel="nofollow">2.1.6 算法分析</a></p> 
<p id="2.1.7%C2%A0%E4%BC%98%E7%BC%BA%E7%82%B9-toc" style="margin-left:80px;"><a href="#2.1.7%C2%A0%E4%BC%98%E7%BC%BA%E7%82%B9" rel="nofollow">2.1.7 优缺点</a></p> 
<p id="2.1.8%C2%A0%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-toc" style="margin-left:80px;"><a href="#2.1.8%C2%A0%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96" rel="nofollow">2.1.8 如何优化</a></p> 
<p id="2.2%20%E6%8F%92%E5%85%A5%E7%B1%BB%E6%8E%92%E5%BA%8F%E2%80%94%3E%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E9%9A%BE%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.2%20%E6%8F%92%E5%85%A5%E7%B1%BB%E6%8E%92%E5%BA%8F%E2%80%94%3E%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E9%9A%BE%EF%BC%89" rel="nofollow">2.2 插入类排序—&gt;希尔排序（难）</a></p> 
<p id="2.2.1%20%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-toc" style="margin-left:80px;"><a href="#2.2.1%20%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" rel="nofollow">2.2.1 基本思想</a></p> 
<p id="2.2.2%20%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E5%A2%9E%E9%87%8F%E6%95%B0%E7%BB%84-toc" style="margin-left:80px;"><a href="#2.2.2%20%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E5%A2%9E%E9%87%8F%E6%95%B0%E7%BB%84" rel="nofollow">2.2.2 希尔排序的增量数组</a></p> 
<p id="2.2.3%20%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-toc" style="margin-left:80px;"><a href="#2.2.3%20%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4" rel="nofollow">2.2.3 算法步骤</a></p> 
<p id="2.2.4%20%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95(%E6%9C%89%E6%A8%AA%E7%BA%BF%E7%9A%84%E5%80%BC%E8%AE%A4%E4%B8%BA%E5%B7%B2%E7%BB%8F%E6%9C%89%E5%BA%8F)-toc" style="margin-left:80px;"><a href="#2.2.4%20%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95%28%E6%9C%89%E6%A8%AA%E7%BA%BF%E7%9A%84%E5%80%BC%E8%AE%A4%E4%B8%BA%E5%B7%B2%E7%BB%8F%E6%9C%89%E5%BA%8F%29" rel="nofollow">2.2.4 图解算法(有横线的值认为已经有序)</a></p> 
<p id="2.2.5%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#2.2.5%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">2.2.5 代码实现</a></p> 
<p id="2.2.6%C2%A0%C2%A0%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#2.2.6%C2%A0%C2%A0%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90" rel="nofollow">2.2.6  核心代码分析</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%912.2.7%20%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%912.2.7%20%E6%B5%8B%E8%AF%95" rel="nofollow">​2.2.7 测试</a></p> 
<p id="2.2.8%20%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#2.2.8%20%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90" rel="nofollow">2.2.8 算法分析</a></p> 
<p id="%C2%A02.2.9%20%E6%80%BB%E7%BB%93-toc" style="margin-left:80px;"><a href="#%C2%A02.2.9%20%E6%80%BB%E7%BB%93" rel="nofollow"> 2.2.9 总结</a></p> 
<p id="2.3%20%E9%80%89%E6%8B%A9%E7%B1%BB%E6%8E%92%E5%BA%8F%E2%80%94%3E%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#2.3%20%E9%80%89%E6%8B%A9%E7%B1%BB%E6%8E%92%E5%BA%8F%E2%80%94%3E%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" rel="nofollow">2.3 选择类排序—&gt;简单选择排序</a></p> 
<p id="2.3.1%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-toc" style="margin-left:80px;"><a href="#2.3.1%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" rel="nofollow">2.3.1基本思想</a></p> 
<p id="2.3.2%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-toc" style="margin-left:80px;"><a href="#2.3.2%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4" rel="nofollow">2.3.2算法步骤</a></p> 
<p id="2.3.3%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;"><a href="#2.3.3%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95" rel="nofollow">2.3.3图解算法</a></p> 
<p id="2.3.4%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#2.3.4%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">2.3.4代码实现</a></p> 
<p id="2.3.5%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#2.3.5%E6%B5%8B%E8%AF%95" rel="nofollow">2.3.5测试</a></p> 
<p id="2.3.6%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#2.3.6%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90" rel="nofollow">2.3.6算法分析</a></p> 
<p id="2.4%20%E9%80%89%E6%8B%A9%E7%B1%BB%E6%8E%92%E5%BA%8F%E2%80%94%3E%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E9%9A%BE%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.4%20%E9%80%89%E6%8B%A9%E7%B1%BB%E6%8E%92%E5%BA%8F%E2%80%94%3E%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E9%9A%BE%EF%BC%89" rel="nofollow">2.4 选择类排序—&gt;堆排序（难）</a></p> 
<p id="2.4.0%20%E9%93%BA%E5%9E%AB%E7%9F%A5%E8%AF%86%C2%A0-toc" style="margin-left:80px;"><a href="#2.4.0%20%E9%93%BA%E5%9E%AB%E7%9F%A5%E8%AF%86%C2%A0" rel="nofollow">2.4.0 铺垫知识 </a></p> 
<p id="2.4.1%20%E5%A4%A7%E5%B0%8F%E5%A0%86%E4%BB%8B%E7%BB%8D-toc" style="margin-left:80px;"><a href="#2.4.1%20%E5%A4%A7%E5%B0%8F%E5%A0%86%E4%BB%8B%E7%BB%8D" rel="nofollow">2.4.1 大小堆介绍</a></p> 
<p id="2.4.2%20%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-toc" style="margin-left:80px;"><a href="#2.4.2%20%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" rel="nofollow">2.4.2 基本思想</a></p> 
<p id="%C2%A02.4.3%20%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-toc" style="margin-left:80px;"><a href="#%C2%A02.4.3%20%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4" rel="nofollow"> 2.4.3 算法步骤</a></p> 
<p id="2.4.4%20%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;"><a href="#2.4.4%20%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95" rel="nofollow">2.4.4 图解算法</a></p> 
<p id="2.4.5%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#2.4.5%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">2.4.5 代码实现</a></p> 
<p id="2.4.6%C2%A0%E6%A0%B8%E5%BF%83%E9%9A%BE%E7%82%B9%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#2.4.6%C2%A0%E6%A0%B8%E5%BF%83%E9%9A%BE%E7%82%B9%E5%88%86%E6%9E%90" rel="nofollow">2.4.6 核心难点分析</a></p> 
<p id="2.4.7%20%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#2.4.7%20%E6%B5%8B%E8%AF%95" rel="nofollow">2.4.7 测试</a></p> 
<p id="2.4.8%20%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#2.4.8%20%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90" rel="nofollow">2.4.8 算法分析</a></p> 
<p id="2.5%20%E5%BD%92%E5%B9%B6%E7%B1%BB%E6%8E%92%E5%BA%8F%E2%80%94%3E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88%E9%9A%BE%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.5%20%E5%BD%92%E5%B9%B6%E7%B1%BB%E6%8E%92%E5%BA%8F%E2%80%94%3E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88%E9%9A%BE%EF%BC%89" rel="nofollow">2.5 归并类排序—&gt;归并排序（难）</a></p> 
<p id="2.5.1%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-toc" style="margin-left:80px;"><a href="#2.5.1%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" rel="nofollow">2.5.1基本思想</a></p> 
<p id="2.5.2%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-toc" style="margin-left:80px;"><a href="#2.5.2%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4" rel="nofollow">2.5.2算法步骤</a></p> 
<p id="2.5.3%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;"><a href="#2.5.3%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95" rel="nofollow">2.5.3图解算法</a></p> 
<p id="%C2%A02.5.4%20%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E9%9A%BE%E7%82%B9-toc" style="margin-left:80px;"><a href="#%C2%A02.5.4%20%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E9%9A%BE%E7%82%B9" rel="nofollow"> 2.5.4 归并排序的难点</a></p> 
<p id="2.5.5%20%E9%9D%9E%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#2.5.5%20%E9%9D%9E%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">2.5.5 非递归方式代码实现</a></p> 
<p id="2.5.6%20%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#2.5.6%20%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">2.5.6 递归方式代码实现</a></p> 
<p id="2.5.7%20%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#2.5.7%20%E6%B5%8B%E8%AF%95" rel="nofollow">2.5.7 测试</a></p> 
<p id="2.5.6%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#2.5.6%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90" rel="nofollow">2.5.8 算法分析</a></p> 
<p id="2.6%20%E4%BA%A4%E6%8D%A2%E7%B1%BB%E6%8E%92%E5%BA%8F%E2%80%94%3E%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#2.6%20%E4%BA%A4%E6%8D%A2%E7%B1%BB%E6%8E%92%E5%BA%8F%E2%80%94%3E%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" rel="nofollow">2.6 交换类排序—&gt;冒泡排序</a></p> 
<p id="2.6.1%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-toc" style="margin-left:80px;"><a href="#2.6.1%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" rel="nofollow">2.6.1基本思想</a></p> 
<p id="2.6.2%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-toc" style="margin-left:80px;"><a href="#2.6.2%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4" rel="nofollow">2.6.2算法步骤</a></p> 
<p id="2.6.3%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;"><a href="#2.6.3%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95" rel="nofollow">2.6.3图解算法</a></p> 
<p id="2.6.4%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#2.6.4%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">2.6.4代码实现</a></p> 
<p id="2.6.5%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#2.6.5%E6%B5%8B%E8%AF%95" rel="nofollow">2.6.5测试</a></p> 
<p id="2.6.6%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#2.6.6%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90" rel="nofollow">2.6.6算法分析</a></p> 
<p id="2.6.8%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-toc" style="margin-left:80px;"><a href="#2.6.8%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96" rel="nofollow">2.6.7如何优化</a></p> 
<p id="2.7%C2%A0%E4%BA%A4%E6%8D%A2%E7%B1%BB%E6%8E%92%E5%BA%8F%E2%80%94%3E%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F(%E9%9A%BE%EF%BC%8C%E7%AC%94%E8%AF%95%E6%9C%80%E5%B8%B8%E8%80%83)-toc" style="margin-left:40px;"><a href="#2.7%C2%A0%E4%BA%A4%E6%8D%A2%E7%B1%BB%E6%8E%92%E5%BA%8F%E2%80%94%3E%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%28%E9%9A%BE%EF%BC%8C%E7%AC%94%E8%AF%95%E6%9C%80%E5%B8%B8%E8%80%83%29" rel="nofollow">2.7 交换类排序—&gt;快速排序(难，笔试最常考)</a></p> 
<p id="2.7.%201%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-toc" style="margin-left:80px;"><a href="#2.7.%201%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" rel="nofollow">2.7.1 基本思想</a></p> 
<p id="2.7.2%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-toc" style="margin-left:80px;"><a href="#2.7.2%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4" rel="nofollow">2.7.2 算法步骤</a></p> 
<p id="2.7.3%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;"><a href="#2.7.3%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95" rel="nofollow">2.7.3 图解算法</a></p> 
<p id="2.7.4%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#2.7.4%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">2.7.4 递归方式的代码实现</a></p> 
<p id="2.7.5%20%E9%9D%9E%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#2.7.5%20%E9%9D%9E%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">2.7.5 非递归方式的代码实现</a></p> 
<p id="2.7.5%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#2.7.5%E6%B5%8B%E8%AF%95" rel="nofollow">2.7.6 测试</a></p> 
<p id="2.7.7%20%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#2.7.7%20%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90" rel="nofollow">2.7.7 算法分析</a></p> 
<p id="2.7.7%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-toc" style="margin-left:80px;"><a href="#2.7.7%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96" rel="nofollow">2.7.8 快速排序的特点以及如何优化</a></p> 
<p id="2.7.9%C2%A0%20%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#2.7.9%C2%A0%20%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95" rel="nofollow">2.7.9  优化方法</a></p> 
<p id="2.8%C2%A0%20%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%C2%A0-toc" style="margin-left:40px;"><a href="#2.8%C2%A0%20%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%C2%A0" rel="nofollow">2.8  基数排序 </a></p> 
<p id="2.8.1%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-toc" style="margin-left:80px;"><a href="#2.8.1%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" rel="nofollow">2.8.1基本思想</a></p> 
<p id="2.8.2%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-toc" style="margin-left:80px;"><a href="#2.8.2%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4" rel="nofollow">2.8.2算法步骤</a></p> 
<p id="2.8.3%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;"><a href="#2.8.3%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95" rel="nofollow">2.8.3图解算法</a></p> 
<p id="2.8.4%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#2.8.4%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">2.8.4代码实现</a></p> 
<p id="2.8.5%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#2.8.5%E6%B5%8B%E8%AF%95" rel="nofollow">2.8.5测试</a></p> 
<p id="2.8.6%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#2.8.6%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90" rel="nofollow">2.8.6算法分析</a></p> 
<p id="2.8.7%E4%BC%98%E7%BC%BA%E7%82%B9-toc" style="margin-left:80px;"><a href="#2.8.7%E4%BC%98%E7%BC%BA%E7%82%B9" rel="nofollow">2.8.7优缺点</a></p> 
<p id="%E4%B8%89%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%8A%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%8A%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90" rel="nofollow">三、排序算法复杂度及稳定性分析</a></p> 
<p id="%E5%9B%9B%E3%80%81%E9%80%89%E6%8B%A9%E9%A2%98%E7%BB%83%E4%B9%A0-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E9%80%89%E6%8B%A9%E9%A2%98%E7%BB%83%E4%B9%A0" rel="nofollow">四、选择题练习</a></p> 
<p id="4.1-toc" style="margin-left:40px;"><a href="#4.1" rel="nofollow">4.1</a></p> 
<p id="4.2-toc" style="margin-left:40px;"><a href="#4.2" rel="nofollow">4.2</a></p> 
<p id="4.3-toc" style="margin-left:40px;"><a href="#4.3" rel="nofollow">4.3</a></p> 
<p id="4.4-toc" style="margin-left:40px;"><a href="#4.4" rel="nofollow">4.4</a></p> 
<p id="4.5-toc" style="margin-left:40px;"><a href="#4.5" rel="nofollow">4.5</a></p> 
<p id="4.6-toc" style="margin-left:40px;"><a href="#4.6" rel="nofollow">4.6</a></p> 
<p id="4.7-toc" style="margin-left:40px;"><a href="#4.7" rel="nofollow">4.7</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%80%E4%BB%8B">一、排序简介</h2> 
<h3 id="1.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%92%E5%BA%8F%EF%BC%9F">1.1 什么是排序？</h3> 
<p>      <span style="color:#1c7331;"><strong>所谓排序，就是使一串记录/数据，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。排序算法，就是如何使得记录按照要求排列的方法。</strong></span>排序算法在很多领域得到相当地重视，尤其是在大量数据的处理方面。一个优秀的算法可以节省大量的资源。在各个领域中考虑到数据的各种限制和规范，要得到一个符合实际的优秀算法，得经过大量的推理和分析。</p> 
<h3 id="1.2%20%E6%8E%92%E5%BA%8F%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">1.2 排序的目的是什么？</h3> 
<p>         便于查找，有序的数据，查找时，直接使用<span style="color:#be191c;"><strong>二分查找</strong></span>。</p> 
<h3 id="1.3%20%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">1.3 排序的应用场景</h3> 
<p>        排序有非常多的应用场景，这里简单举例。</p> 
<p class="img-center"><img alt="" height="268" src="https://images2.imgbox.com/12/98/z4Y5m4WV_o.png" width="531"></p> 
<p style="text-align:center;"><img alt="" height="276" src="https://images2.imgbox.com/cf/b9/p6tvrFyz_o.png" width="529"></p> 
<h3 id="1.4%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A5%BD%E5%9D%8F%E7%9A%84%E5%BA%A6%E9%87%8F%E6%8C%87%E6%A0%87">1.4 排序算法好坏的度量指标</h3> 
<blockquote> 
 <ol><li>时间复杂度：排序速度(比较次数和移动次数)</li><li>空间复杂度：占内存辅助空间的大小</li><li>稳定性：A和B的关键字相等，排序后A，B的先后次序保持不变，则称这种排序算法是稳定。（相同值的先后顺序和初始状态下的先后顺序一致， 则认为是稳定的）</li></ol> 
</blockquote> 
<p><span style="color:#be191c;"><strong>         判断稳定性的小技巧：看是否存在跳跃交换，若存在跳跃交换，则不稳定，反之稳定。</strong></span></p> 
<h3 id="1.5%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB">1.5 排序算法的分类</h3> 
<p>         根据在排序过程中待排序的记录是否全部存放在内存中，分为内部排序和外部排序。若待排序记录都在内存中，称为内部排序， 若待排序记录一部分在内存，一部分在外存，则称为外部排序。 注意：外部排序时，要将数据分批调入内存中来排序，中间结果还要几时放入外存，显然外部 排序要复杂很多。本篇博客只介绍常见的内部排序算法，主要有：<strong>直接插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序</strong>。用一张表概括如下：</p> 
<p class="img-center"><img alt="" height="439" src="https://images2.imgbox.com/53/a5/gVrABRM0_o.png" width="471"></p> 
<blockquote> 
 <p><span style="color:#be191c;"><strong>术语解释：</strong></span></p> 
 <ul><li><strong>n</strong>：数据规模，表示待排序的数据量大小。</li><li><strong>k</strong>：“桶” 的个数，在某些特定的排序算法中（如基数排序、桶排序等），表示分割成的独立的排序区间或类别的数量。</li><li><strong>内部排序</strong>：所有排序操作都在内存中完成，不需要额外的磁盘或其他存储设备的辅助。这适用于数据量小到足以完全加载到内存中的情况。</li><li><strong>外部排序</strong>：当数据量过大，不可能全部加载到内存中时使用。外部排序通常涉及到数据的分区处理，部分数据被暂时存储在外部磁盘等存储设备上。</li><li><strong>稳定</strong>：如果 A 原本在 B 前面，而 A=B，排序之后 A 仍然在 B 的前面。</li><li><strong>不稳定</strong>：如果 A 原本在 B 的前面，而 A=B，排序之后 A 可能会出现在 B 的后面。</li><li><strong>时间复杂度</strong>：定性描述一个算法执行所耗费的时间。</li><li><strong>空间复杂度</strong>：定性描述一个算法执行所需内存的大小。</li></ul> 
</blockquote> 
<p>十种常见排序算法按照算法的思想可以分类两大类别：<strong>比较类排序</strong>和<strong>非比较类排序</strong>。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/46/6e/OtETq3T0_o.png"></p> 
<p>       常见的<strong>快速排序</strong>、<strong>归并排序</strong>、<strong>堆排序</strong>以及<strong>冒泡排序</strong>等都属于<strong>比较类排序算法</strong>。比较类排序是通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 <code>O(nlogn)</code>，因此也称为非线性时间比较类排序。在冒泡排序之类的排序中，问题规模为 <code>n</code>，又因为需要比较 <code>n</code> 次，所以平均时间复杂度为 <code>O(n²)</code>。在<strong>归并排序</strong>、<strong>快速排序</strong>之类的排序中，问题规模通过<strong>分治法</strong>消减为 <code>logn</code> 次，所以时间复杂度平均 <code>O(nlogn)</code>。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/7e/c8/JtJXOYrQ_o.png"></p> 
<p>         比较类排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。而<strong>计数排序</strong>、<strong>基数排序</strong>、<strong>桶排序</strong>则属于<strong>非比较类排序算法</strong>。非比较排序不通过比较来决定元素间的相对次序，而是通过确定每个元素之前，应该有多少个元素来排序。由于它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。 非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度 O(n)。非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BB%A5%E5%8D%87%E5%BA%8F%E4%B8%BA%E4%BE%8B%EF%BC%89">二、常见排序算法的实现（以升序为例）</h2> 
<blockquote> 
 <p><strong>比较类排序算法</strong></p> 
</blockquote> 
<h3 id="2.1%20%E6%8F%92%E5%85%A5%E7%B1%BB%E6%8E%92%E5%BA%8F%E2%80%94%3E%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">2.1 插入类排序—&gt;直接插入排序</h3> 
<h4 id="2.1.1%20%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">2.1.1 基本思想</h4> 
<blockquote> 
 <p>      插入排序是一种简单直观的排序算法。它的工作原理是<span style="color:#be191c;"><strong>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 O(1) 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</strong></span></p> 
 <p>        插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" height="249" src="https://images2.imgbox.com/1e/5d/sNX1WBLi_o.png" width="472"></p> 
<h4 id="2.1.2%20%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4">2.1.2 算法步骤</h4> 
<blockquote> 
 <p>插入的规则如下：</p> 
 <ol><li><strong>从第一个元素开始，该元素可以认为已经被排序；</strong></li><li><strong>取出下一个元素，在已经排序的元素序列中<span style="color:#fe2c24;">从后向前</span>扫描；</strong></li><li><strong>如果该元素（已排序）大于将要插入的元素，将该元素移到下一位置；</strong></li><li><strong>重复步骤 3，直到找到已排序的元素小于或者等于将要插入的元素的位置，则停下来；</strong></li><li><strong>将该待插入元素元素插入到该位置的后面；</strong></li><li><strong>重复步骤 2~5，直到将所有元素插入完毕。</strong></li></ol> 
</blockquote> 
<p style="text-align:center;"> <img alt="" height="242" src="https://images2.imgbox.com/fe/71/UCRbUvwz_o.png" width="670"></p> 
<h4 id="2.1.3%20%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95%C2%A0">2.1.3 图解算法 </h4> 
<blockquote> 
 <p>    下面这张图生动的描述了每个元素的插入过程。</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" height="370" src="https://images2.imgbox.com/79/07/7ZscYuwc_o.gif" width="594"></p> 
<h4 id="2.1.4%C2%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">2.1.4 代码实现</h4> 
<pre><code class="language-cpp">//直接插入排序    
void Insert_Sort(int arr[], int len)
{
	//for(int i=0; i&lt;len-1; i++)//控制趟数
	for (int i = 1; i &lt; len; i++)//控制趟数
	{
		int tmp = arr[i];    //保存待插入的元素，防止移动元素发生元素覆盖
		int j;               //*j申请在外面，要不跳出内层for循环，j失效了
		for (j = i - 1; j &gt;= 0; j--)//找到这一趟已排序好的序列中的合适的插入位置
		{
			if (arr[j] &gt; tmp)
			{
				arr[j + 1] = arr[j];
			}
			else                  //arr[j] &lt;= tmp
			{
				break;           //arr[j+1] = tmp; //找到一个小于或者等于tmp的值
			}
		}
		arr[j + 1] = tmp;    //找到位置，插入元素
	}

}</code></pre> 
<h4 id="2.1.5%C2%A0%E6%B5%8B%E8%AF%95">2.1.5 测试</h4> 
<pre><code class="language-cpp">//打印数组元素
void Show(int* arr, int len)
{
	for (int i = 0; i &lt; len; i++)
	{
		printf("%d ", arr[i]);
	}
	printf("\n");
}



int main()
{
	int arr[] = { 12,83,78,91,57,91,72,40,91,79,5,70,12,97,49,1,75,9,71,9,24,73,21 };
	int len = sizeof(arr) / sizeof(arr[0]);
    //打印排序之前数组元素顺序
	Show(arr, len);
	Insert_Sort(arr, len);
	//打印排序之后数组元素顺序
	Show(arr, len);

    return 0;
}</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2f/c7/3nKDevnN_o.png"></p> 
<h4 id="2.1.6%C2%A0%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90">2.1.6 算法分析</h4> 
<blockquote> 
 <ol><li><span style="color:#be191c;"><strong>时间复杂度：</strong></span>O(N^2)  ，双层for循环；</li><li><span style="color:#be191c;"><strong>空间复杂度：</strong></span>O(1) ；</li><li> <span style="color:#be191c;"><strong>稳定性：</strong></span>由于他只要找到小于等于插入的元素的位置便停下来，未发生跳跃交换，所以它是一种稳定的排序算法；</li></ol> 
 <p><span style="color:#fe2c24;"><strong>特点：元素较少或者元素越接近有序，直接插入排序算法的时间复杂度越低，反过来，元素越接近逆序，时间复杂度越高。</strong></span><span style="color:#1c7331;"><strong>因为元素越有序，则移动元素的次数便越少，因此时间复杂度便越低。</strong></span></p> 
</blockquote> 
<h4 id="2.1.7%C2%A0%E4%BC%98%E7%BC%BA%E7%82%B9">2.1.7 优缺点</h4> 
<blockquote> 
 <ul><li><strong>优点：<br> 1.如果n较小，那么n^2也不会太大（当数据量较小时，可以直接使用直接插入法）<br> 2.较为稳定</strong></li><li><strong>缺点<br> 时间复杂度过高（n^2）</strong></li></ul> 
</blockquote> 
<h4 id="2.1.8%C2%A0%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96">2.1.8 如何优化</h4> 
<blockquote> 
 <p>通过上面的分析，我们可以知道：如果数据量特别少，或者数据量较为有序，直接插入法效率极高，<span style="color:#be191c;"><strong>关键点就是如何让待排序列数量降低，又如何让它变得接近有序呢</strong></span>？下面的希尔排序就是直接插入法的优化</p> 
</blockquote> 
<h3 id="2.2%20%E6%8F%92%E5%85%A5%E7%B1%BB%E6%8E%92%E5%BA%8F%E2%80%94%3E%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E9%9A%BE%EF%BC%89">2.2 插入类排序—&gt;希尔排序（难）</h3> 
<p>       希尔排序(也称缩小增量排序)是D.L.Shell于1959年剔除的一种排序算法，在这之前人们认为排序算 法的时间复杂度基本都是O(n2 )，而希尔排序是突破这个时间复杂度的第一批算法之一，希尔排序是对于 直接插入排序的优化。</p> 
<blockquote> 
 <p><span style="color:#1c7331;"><strong>希尔排序的算法思想的出发点：</strong></span></p> 
 <ol><li><span style="color:#fe2c24;"><strong>直接插入排序在基本有序时，只需要少量的插入操作，就可以完成整个数据的有序，效率很高；</strong></span></li><li><span style="color:#fe2c24;"><strong>直接插入排序在数据个数较少时，效率很高；</strong></span></li></ol> 
</blockquote> 
<p> 可问题在于，这两个条件本身过于苛刻，现实中数据集能保证基本有序都属于特殊情况了。不过不 需要急，有条件当然最好，没有条件，则创造条件就好了，于是科学家希尔研究出了一种排序方法，对直接插入排序改进后可以提高效率。针对上述两个出发点，应该如何针对性的解决呢？来看看希尔怎么分析的。 </p> 
<h4 id="2.2.1%20%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">2.2.1 基本思想</h4> 
<blockquote> 
 <p>1. 如何让待排序数据变少？</p> 
 <p>      <span style="color:#be191c;"><strong> 对数据进行分组。分割成若干个子序列，再对这些个子序列分别进行直接插入排序；</strong></span></p> 
 <p>2.如何让数据变得基本有序？</p> 
 <p>       <span style="color:#be191c;"><strong>当经过上面的分组然后进行直接插入排序后（预排序步骤），整个序列就会变得基本有序，再对全体数据进行一次直接插入排 序，这时就可以保证全体数据完全有序了。</strong></span></p> 
</blockquote> 
<p><span style="color:#1c7331;"><strong>怎么样进行分组呢？ </strong></span></p> 
<p style="text-align:center;"><span style="color:#1c7331;"><strong><img alt="" height="351" src="https://images2.imgbox.com/9c/2d/13oYYttq_o.png" width="674"></strong></span></p> 
<p>        对比上面的两种分割方式，可以知道，利用分割方式2进行直接插入排序，会让原数据变得更加有序:大的数据主要分布在后面，小的数据分布在前面。并且每选择一次增量排序，整个数据就会变得越来越有序，因此，应采用方式2.   <span style="color:#be191c;"><strong>对插入排序的优化，让元素更快速地交换到最终位置.</strong></span></p> 
<p><img alt="" src="https://images2.imgbox.com/c4/a1/HtC8nhaC_o.png"></p> 
<blockquote> 
 <p><strong>因此，它的思想如下：</strong></p> 
 <p><strong>      </strong> <strong><span style="color:#fe2c24;">对于n个待排序的数据，取一个小于n的整数gap(gap被称为步长或增量)将待排序元素分成若干个组子序列，所有距离为gap的倍数的数据放在同一个组中；然后，对各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，整个数据就会变得基本有序，然后最后一次，取gap=1时，进行一次插入排序，整个数据就是有序的。</span></strong></p> 
</blockquote> 
<h4 id="2.2.2%20%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E5%A2%9E%E9%87%8F%E6%95%B0%E7%BB%84">2.2.2 希尔排序的增量数组</h4> 
<p>        希尔排序也叫最小增量排序，有一个最重要的标志——增量数组,希尔排序的关键并不是随便分组后各自排序，而是将相隔某个“增量”的记录组成一个子序列，实现跳跃式的移动，使得排序的效率提高。那么这里“增量”的选取就非常关键了。 只不过迄今为止还没有人找到一种最好的增量序列，目前还是一个世界难题，但是增量序列的最后 一个增量值必须等于1才能。</p> 
<blockquote> 
 <p><span style="color:#be191c;"><strong>         增量数组一般取 [5,3,1]，尽可能保证增量数组里面的值互素，并且最后一个的增量一定是1 （只有最后以增量为1排序一次，才能保证数据全部有序）</strong></span></p> 
</blockquote> 
<h4 id="2.2.3%20%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4">2.2.3 算法步骤</h4> 
<blockquote> 
 <ol><li>选择增量数组，分组实现直接插入，每组元素间隙称为 gap</li><li>每轮排序后 gap 逐渐变小，直至 gap 为 1 完成排序，（增量元素个数k, 决定对数据进行 k 趟排序；</li></ol> 
</blockquote> 
<h4 id="2.2.4%20%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95(%E6%9C%89%E6%A8%AA%E7%BA%BF%E7%9A%84%E5%80%BC%E8%AE%A4%E4%B8%BA%E5%B7%B2%E7%BB%8F%E6%9C%89%E5%BA%8F)">2.2.4 图解算法(有横线的值认为已经有序)</h4> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%91" style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e0/d0/ljrKkBrb_o.png"></h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d5/33/x9EpggJk_o.png"></p> 
<h4 id="2.2.5%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">2.2.5 代码实现</h4> 
<pre><code class="language-cpp">//这一趟排序 对arr数组中的数据来说 以gap为增量进行分组
void Shell(int arr[], int len, int gap)
{
    //假设gap=5，则认为前5个值已经有序，则让i直接指向第一个组的第二个值下标
	for (int i = gap; i &lt; len; i++)//控制趟数  //********//
	{
		int tmp = arr[i];
		int j; //*j申请在外面，要不跳出内层for循环，j失效了

       //这里修改了，找到这一趟已排序好的序列中的合适的插入位置
		for (j = i - gap; j &gt;= 0; j -= gap)
		{
			if (arr[j] &gt; tmp)
			{
				arr[j + gap] = arr[j];  //这里修改了
			}
			else
			{
				break;
			}
		}
		arr[j + gap] = tmp;   //这里修改了
	}
}

//希尔排序  时间复杂度O(1.5)   空间复杂度O(1)
void Shell_Sort(int arr[], int len)
{
	int gap[] = { 5, 3 ,1 };  //缩小增量数组
	int gap_len = sizeof(gap) / sizeof(gap[0]);

	for (int i = 0; i &lt; gap_len; i++)
	{
		Shell(arr, len, gap[i]);
	}
}</code></pre> 
<h4 id="2.2.6%C2%A0%C2%A0%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90">2.2.6  核心代码分析</h4> 
<p>     我们发现分割后的多个子序列，分别需要进行直接插入排序，但是我们代码中只用了一个for循环就 搞定了，核心要点在于并不是一个子序列处理完后才处理下一个子序列，而是所有子序列同步进行，如下图所示：<span style="color:#fe2c24;"><strong>(将所有组看成一个整体，每次处理每个组的一部分， 这样可以只需要一个双重for循环)</strong></span></p> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%912.2.7%20%E6%B5%8B%E8%AF%95"><img alt="" src="https://images2.imgbox.com/03/01/h98FG7YE_o.png"><br> 2.2.7 测试</h4> 
<pre><code class="language-cpp">void Show(int* arr, int len)
{
	for (int i = 0; i &lt; len; i++)
	{
		printf("%d ", arr[i]);
	}
	printf("\n");
}


int main()
{
	int arr[] = { 12,83,78,91,57,91,72,40,91,79,5,70,12,97,49,1,75,9,71,9,24,73,21 };
	int len = sizeof(arr) / sizeof(arr[0]);

	Show(arr, len);
	Shell_Sort(arr, len);
	Show(arr, len);
    
    return 0;
}</code></pre> 
<p><img alt="" src="https://images2.imgbox.com/be/c6/tHp495ZL_o.png"></p> 
<h4 id="2.2.8%20%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90">2.2.8 算法分析</h4> 
<blockquote> 
 <ol><li><span style="color:#be191c;"><strong>时间复杂度：</strong></span>希尔排序的时间复杂度比较特殊，受限于“增量”的选取，时间复杂度大约为O(n^1.5 )，也可以认为在 O(n^1.3 ~ n^1.7 )之间。</li><li><span style="color:#be191c;"><strong>空间复杂度：</strong></span>O(1) ；</li><li> <span style="color:#be191c;"><strong>稳定性：</strong></span>另外由于发生跳跃式的移动，所以希尔排序并不是一种稳定的排序算法。</li></ol> 
</blockquote> 
<h4 id="%C2%A02.2.9%20%E6%80%BB%E7%BB%93"> 2.2.9 总结</h4> 
<blockquote> 
 <p>      希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比O(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p> 
</blockquote> 
<p>         每组数据是在前一轮排序后重新分组的，也就是说第二轮排序是在第一轮排序的基础之上，那么组内元素就有第一轮排序的前提，也就是局部有序的，这<strong>充分了利用了<span style="color:#be191c;">插入排序对于局部有序数据排序的高效性</span>。</strong>后序轮次以此类推，直到 gap 缩小为 1，也就是只分一组，对所有元素进行最后一轮排序。 </p> 
<h3 id="2.3%20%E9%80%89%E6%8B%A9%E7%B1%BB%E6%8E%92%E5%BA%8F%E2%80%94%3E%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">2.3 选择类排序—&gt;简单选择排序</h3> 
<p>         选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n2) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p> 
<h4 id="2.3.1%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">2.3.1基本思想</h4> 
<blockquote> 
 <p>     每一趟从待排序序列中找到最小值，和待排序序列第一个值进行交换，从而让待排序序列个数-1，重复执行，直到数据完全有序。</p> 
</blockquote> 
<h4 id="2.3.2%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4">2.3.2算法步骤</h4> 
<blockquote> 
 <ol><li><strong>首先在待排序序列中找到最小元素，存放到已排序序列的第一个位置</strong></li><li><strong>再从剩余待排序元素中继续寻找最小元素，然后放到已排序序列的第一个位置。</strong></li><li><strong>重复第 2 步，直到所有元素均排序完毕。</strong></li></ol> 
</blockquote> 
<p class="img-center"><img alt="" height="442" src="https://images2.imgbox.com/3e/0c/BIKB2feb_o.png" width="519"></p> 
<blockquote> 
 <p> <span style="color:#be191c;"><strong>注意：</strong></span>为防止数据交换时发生覆盖，跑完一趟，需要用两个变量记录的是待排序序列最小值和待排序序列第一个值的<span style="color:#fe2c24;"><strong>下标！！！</strong></span></p> 
</blockquote> 
<h4 id="2.3.3%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95">2.3.3图解算法</h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/bc/91/CQFwFsAr_o.gif"></p> 
<h4 id="2.3.4%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">2.3.4代码实现</h4> 
<pre><code class="language-cpp">//选择排序  
void Select_Sort(int *arr, int len)
{
	for(int i=0; i&lt;len-1; i++)//控制循环的趟数   len-1趟
	{
		int min = i;//让min 保存 这一趟循环中"待排序序列"的第一个值的下标
		for(int j=i+1; j&lt;len; j++)//找到这一趟排序中，待排序序列的最小值的下标，用min保存
		{
			if(arr[j] &lt; arr[min])//如果发现了比min指向的值还要小的值，则min修改指向
			{
				min = j;
			}
		}
		//此时，里面这一层for循环跑完，代表着min正保存着待排序序列的最小值的下标
		// 而此时待排序序列的第一个值的下标，由变量i保存

		if(min != i)//如果min==i， 代表着待排序序列最小值就是待排序序列第一个值
		{
			int tmp = arr[min];
			arr[min] = arr[i];
			arr[i] = tmp;
		}
	}
}
</code></pre> 
<h4 id="2.3.5%E6%B5%8B%E8%AF%95">2.3.5测试</h4> 
<pre><code class="language-cpp">void Show(int* arr, int len)
{
	for (int i = 0; i &lt; len; i++)
	{
		printf("%d ", arr[i]);
	}
	printf("\n");
}


int main()
{
	int arr[] = { 12,83,78,91,57,91,72,40,91,79,5,70,12,97,49,1,75,9,71,9,24,73,21 };
	int len = sizeof(arr) / sizeof(arr[0]);

	Show(arr, len);
	Select_Sort(arr, len);
	Show(arr, len);

}</code></pre> 
<h4 style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c7/08/U9XnABEd_o.png"></h4> 
<h4 id="2.3.6%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90">2.3.6算法分析</h4> 
<blockquote> 
 <ol><li><span style="color:#be191c;"><strong>时间复杂度：</strong></span>O(n^2 )</li><li><span style="color:#be191c;"><strong>空间复杂度：</strong></span>O(1) ；</li><li> <span style="color:#be191c;"><strong>稳定性：</strong></span>发生跳跃移动交换，属于不稳定算法</li></ol> 
</blockquote> 
<p>如下图所示，元素 <em>nums[ i ]</em><em> </em>有可能被交换至与其相等的元素的右边，导致两者的相对顺序发生改变。 </p> 
<h4 style="text-align:center;"><img alt="" height="516" src="https://images2.imgbox.com/28/55/oIRICh5l_o.png" width="415"></h4> 
<h3 id="2.4%20%E9%80%89%E6%8B%A9%E7%B1%BB%E6%8E%92%E5%BA%8F%E2%80%94%3E%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E9%9A%BE%EF%BC%89">2.4 选择类排序—&gt;堆排序（难）</h3> 
<p>        堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子结点的值总是小于（或者大于）它的父节点。我们可以利用“建堆操作”和“元素出堆操作”实现堆排序。输入数组并建立大顶堆，此时最大元素位于堆顶。不断执行出堆操作，依次记录出堆元素，即可得到从小到大排序的序列。为什么堆排序属于选择类排序的一种呢？</p> 
<blockquote> 
 <p>       因为堆排序在一定程度上有着与选择排序类似的思想，<span style="color:#1c7331;"><strong>也是每次在数组中选择最大的元素的值然后交换到数组的最后一位，最终实现有序，但是传统的选择排序在选择最大值的过程中采用的是遍历比较，每次选择最大值都需要遍历未排序区域，但是，想要选择最大值，堆数据结构是一个非常合适的解决方法，我们将数据构建为堆数据结构，每次选择最大值只需要拿到堆顶元素即可，然后对堆做一次下潜操作，继续构建堆结构。</strong></span></p> 
</blockquote> 
<h4 id="2.4.0%20%E9%93%BA%E5%9E%AB%E7%9F%A5%E8%AF%86%C2%A0">2.4.0 铺垫知识 </h4> 
<blockquote> 
 <ol><li><span style="color:#be191c;"><strong>二叉树</strong></span>：每个节点<strong>最多</strong>只能有两棵子树，且有左右之分。</li><li><span style="color:#be191c;"><strong>完全二叉树</strong></span>：可以少节点，并且只能在最后一层缺少节点，不能出现右边存在节点，而左边缺少节点的情况，因为节点是从左到右的排列的，则此二叉树成为完全二叉树。</li><li><span style="color:#be191c;"><strong>满二叉树</strong></span>： 除了叶子节点以外，其余每个节点都有两个子节点。每一层完全放满，满足等比数列，公比为2。特殊的完全二叉树</li><li><span style="color:#be191c;"><strong>树高 </strong></span>：树的层数。</li><li><span style="color:#be191c;"><strong>叶子节点</strong></span>：度为0的节点，也就是最外层的节点。</li><li><span style="color:#be191c;"><strong>非叶子节点</strong></span>：度不为0的节点。</li></ol> 
</blockquote> 
<h4 id="2.4.1%20%E5%A4%A7%E5%B0%8F%E5%A0%86%E4%BB%8B%E7%BB%8D">2.4.1 大小堆介绍</h4> 
<blockquote> 
 <p>堆是具有下列性质的完全二叉树：</p> 
 <ol><li><span style="color:#be191c;"><strong>每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆。</strong></span></li><li><span style="color:#be191c;"><strong>每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</strong></span></li></ol> 
</blockquote> 
<p style="text-align:center;"><img alt="" height="275" src="https://images2.imgbox.com/d6/6b/MmKXb8M3_o.png" width="499"></p> 
<p style="text-align:center;"><img alt="" height="204" src="https://images2.imgbox.com/41/96/CJKCRovG_o.png" width="564"></p> 
<p>       很明显，我们可以发现它们都是二叉树，再具体点都是完全二叉树。<span style="color:#fe2c24;"><strong>左图中根结点是所有元素中最大的，右图的根结点是所有元素中最小的。</strong></span>再细看，发现左图每个结点都比它的左右孩子要大，右图每 个结点都比它的左右孩子要小。这就是要讲的堆结构。 </p> 
<h4 id="2.4.2%20%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">2.4.2 基本思想</h4> 
<blockquote> 
 <p>       <span style="color:#1c7331;"><strong>将待排序序列构造一个完全二叉树，然后调整成大顶堆(升序)，此时堆顶根结点的值可以保证为整个序列中的最大值，接下来，将其和堆数组的末尾元素进行交换，此时末尾元素就 是最大值，然后将剩余的n-1个序列重新调整成大顶堆，这样就会得到n-1个数据元素中的最大值。反复上述操作，直到这个大顶堆只剩下一个结点时，则可以得到一个有序序列了。</strong></span></p> 
 <ol><li><strong>升序使用大顶堆 </strong></li><li><strong>降序使用小顶堆</strong></li></ol> 
</blockquote> 
<h4 id="%C2%A02.4.3%20%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"> 2.4.3 算法步骤</h4> 
<blockquote> 
 <ol><li><span style="color:#fe2c24;"><strong>先将数组中的值构造成一一个完全二叉树(臆想，数据还在数组中)；</strong></span></li><li><span style="color:#fe2c24;"><strong>将第一步臆想出来的完全二叉树调整为大顶堆，调整规则为：从最后一个非叶子结点开始，从右向左，从下向上进行调整；</strong></span></li><li><span style="color:#fe2c24;"><strong>因为大顶堆的特点:根节点是最大值，将根结点的值和当前尾结点进行交换，然后让</strong></span><span style="color:#fe2c24;"><strong>尾结点剔除出去，后面进行调整时，这个尾结点不参与后续调整；</strong></span></li><li><span style="color:#fe2c24;"><strong>再次对完全二叉树进行调整，因为只有根节点发生了改变（根节点和尾节点进行交换导致不再是大顶堆，其它的小的大顶堆没有发生变化）,则这时调整只需要调整最外层的框（以根节点构成的最大的二叉树）即可；</strong></span></li><li><span style="color:#fe2c24;"><strong>反复执行3, 4操作，直到完全二叉树只剩下一个结点的时候,停止，不再继续!</strong></span></li></ol> 
</blockquote> 
<h4 id="2.4.4%20%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95">2.4.4 图解算法</h4> 
<blockquote> 
 <p>第一步：臆想成完全二叉树，没有代码。</p> 
</blockquote> 
<h4 style="text-align:center;"><img alt="" height="307" src="https://images2.imgbox.com/5a/4c/jQ9PwAea_o.png" width="582"></h4> 
<blockquote> 
 <p>第二步：第一次调整为大顶堆 </p> 
</blockquote> 
<h4><img alt="" src="https://images2.imgbox.com/b2/70/dogTDHXh_o.png"></h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e8/2d/bx61WZNE_o.png"></p> 
<p style="text-align:center;"><img alt="" height="615" src="https://images2.imgbox.com/59/77/k1S5mAUD_o.png" width="557"></p> 
<p class="img-center"><img alt="" height="681" src="https://images2.imgbox.com/dd/ea/fip3jNcS_o.png" width="582"></p> 
<blockquote> 
 <p>调整过程描述如下：</p> 
 <p>       以第1个非叶子节点8为根节点构成的二叉树（红色框）开始，申请一个临时变量保存根节点8，将此根节点的值8与左右孩子的较大值12比较，8小于12，因此12往上移，出现空白格子（12节点的位置），开始调整以空白格子12为根节点的二叉树继续调整，从图上可知：12没有左右孩子（触底了），因此它不需要调整，直接将8挪下来放到原来12的位置。红色框调整完毕；</p> 
 <p>       接下来调整绿色框，以6为根节点构成的二叉树（绿色框）开始，申请一个临时变量保存根节点6（出现空白格子），将此根节点的值6与左右孩子的较大值21比较，6小于21，因此21往上移，出现空白格子（21节点的位置），开始调整以空白格子21为根节点的二叉树继续调整，从图上可知：21没有左右孩子（触底了），因此它不需要调整，直接将6挪下来放到原来21的位置。绿色框调整完毕；</p> 
 <p>      接下来调整蓝色框，以15为根节点构成的二叉树（蓝色框）开始，申请一个临时变量保存根节点15（出现空白格子），将此根节点的值15与左右孩子的较大值21比较，15小于21，因此21往上移，出现空白格子（21节点的位置），开始调整以空白格子21为根节点的二叉树继续调整，从图上可知：21的左右孩子为11和6，二者的较大者为11，21大于16，因此，直接将15放到21的位置即可，蓝色框调整完毕。</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" height="606" src="https://images2.imgbox.com/b5/51/eUnR23Ke_o.png" width="621"></p> 
<blockquote> 
 <p>第三步：将根结点的值和当前尾结点进行交换，然后让尾结点剔除出去，后面进行调整时，这个尾结点不参与后续调整，图上展示就是断开那条线；</p> 
</blockquote> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/17/f9/Wdr2lh7N_o.png"></p> 
<blockquote> 
 <p> 第四步：再次对完全二叉树进行调整，则这时调整只需要调整最外层的框（以根节点构成的最大的二叉树）即可；</p> 
</blockquote> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/fc/c7/GHcblCEW_o.png"></p> 
<blockquote> 
 <p>第五步： 反复执行第3和第4步操作，直到完全二叉树只剩下一个结点的时候,停止，不再继续!</p> 
</blockquote> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6e/22/jksxJmvJ_o.png"></p> 
<p>       此时，数组中的元素已经完全有序！</p> 
<blockquote> 
 <p>总结：</p> 
 <p><span style="color:#fe2c24;"><strong>       第一次刚进来的时候，对完全二叉树进行调整为大顶堆，需要从内到外调整一遍<br> 而对于接下里头尾节点交换之后的调整就只需要调整一下最外层的框即可！</strong></span></p> 
</blockquote> 
<h4 id="2.4.5%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">2.4.5 代码实现</h4> 
<pre><code class="language-cpp">堆排序的单次调整  (通过start和end来限定大顶堆中要处理的框框) Heap_Adjust是O(logn) 
void Heap_Adjust(int *arr, int len, int start, int end)
{
	int tmp = arr[start]; //将start这个下标的值 拷贝到tmp
    难点4: 如何控制是否触底？i=start*2+1：  //**i指向空白格子的左孩子
	for(int i=start*2+1; i&lt;=end; i=i*2+1) 
	{
		//判断，当前空白格子是否存在右孩子，如果右孩子存在且大于左孩子，则让i指向较大孩子
		if(i+1&lt;=end &amp;&amp; arr[i+1] &gt; arr[i])
		{
			i++;   //目的是让i一直指向左右孩子中的较大值
		}
		//这个if执行结束，i肯定指向空白格子的较大孩子
		if(arr[i] &gt; tmp)//较大孩子值还大于父节点，向上挪动
		{
			arr[start] = arr[i];//将较大孩子值挪动到当前空白格子，则出现新的空白格子
			
难点5：start要指向新的空白格子start一开始指向空白格子，当较大孩子向上挪动，出现了新的空白格子， 
这时start随之更新一下
             start = i;
		}   
		else
		{
			arr[start] = tmp;   难点6：退出情况2：左右孩子较大值小于tmp
			break;
		}
	}

	难点6：退出情况1：触底了，tmp的值，也需要放回来，放回到arr[start]
	arr[start] = tmp;
	}

//堆排序 升序（大顶堆） 降序（小顶堆）
//时间复杂度O(nlogn) 空间复杂度O(1) 稳定性：不稳定
void Heap_Sort(int *arr, int len)
{
	//1.将数组中的数据臆想成完全二叉树，代码层次不用管 
	//2.第一次调整比较麻烦（从最后一个非叶子节点框框开始，从右向左，从下向上去调整）
	难点1：最后一个非叶子节点下标怎么求？  解：通过尾结点的下标(len-1)，子推父((i-1)/2)，从而得到最后一个非叶子节点下标((len-1-1)/2)

    进行第一次调整，全部的框都要调整，直到只有一个根节点
	for(int i=(len-1-1)/2; i&gt;=0; i--)//i指向框框的开始节点的下标
	{
         难点2：第四个参数没有规律，则直接给最大值len-1即可
		Heap_Adjust(arr, len, i, len-1); 
	}
 
	//3.此时，经过第2步的调整，已经是一个大顶堆了
//将根节点的值和当前尾结点的值进行交换，然后将尾结点剔除出排序。

  //将顶部根结点的值（0号下标）和当前最后一个结点值（len-1-i号下标）进行交换
	for(int i=0; i&lt;len-1; i++)//i代表次数 也代表当前根节点的下标
	{
		//根节点和当前尾结点进行交换
		int tmp = arr[0];
		arr[0] = arr[len-1-i];
		arr[len-1-i] = tmp;
				
     //第4步：重复2,3，调整简单，只需要调整最大的框框
         难点3:最后一个参数如何写？即每次调整后尾节点的下标如何确定？
		len-1-i代表这一趟排序中尾节点的下标，
		这一趟结束的时候，需要将尾结点剔除出排序，所以需要(len-1-i)-1
		Heap_Adjust(arr, len, 0, (len-1-i)-1);
	}
}
</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/87/00/sCjxYeLG_o.png"></p> 
<h4 id="2.4.6%C2%A0%E6%A0%B8%E5%BF%83%E9%9A%BE%E7%82%B9%E5%88%86%E6%9E%90">2.4.6 核心难点分析</h4> 
<p><span style="color:#be191c;"><strong>难点一：如何找到非叶子节点？</strong></span></p> 
<blockquote> 
 <p>    最后一个非叶子节点就是最后一个叶子结点的父节点</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/74/9b/dSM8aBpT_o.png"></p> 
<p><span style="color:#be191c;"><strong>难点二：调整函数的第四个参数如何确定？</strong></span></p> 
<blockquote> 
 <p>第一次调整为最大堆时最麻烦，需要从倒数第一个非叶子节点开始直到根节点，调整函数的参数 start和end分别是这个框的根节点和孩子节点，start很好确定就是：（len-1-1)/2，end如何确定呢？</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b7/a6/1ZJ4F1C1_o.png"></p> 
<p><span style="color:#be191c;"><strong>难点三：只进行调整最大框时的第四个参数如何写？</strong></span></p> 
<blockquote> 
 <p>len-1-i代表这一趟排序时的尾节点的下标，这一趟结束的时候，需要将尾结点剔除出排序，所以需要(len-1-i)-1</p> 
</blockquote> 
<p><span style="color:#be191c;"><strong>难点四：如何控制是否触底？</strong></span></p> 
<blockquote> 
 <p>      定义变量i指向空白格子的左孩子，判断是否小于当前框的结束下标即end, 如果它小于end,说明左孩子下标存在，未越界（合法下标）；如果大于end，说明左孩子下标不存在，发生越界（不合法下标），让i每次指向空白格子的左孩子i=start*2+1，让他与end比较即可！</p> 
</blockquote> 
<p><span style="color:#be191c;"><strong>难点五：空白格子的更新</strong></span></p> 
<blockquote> 
 <p>      start要指向新的空白格子start一开始指向空白格子，当较大孩子向上挪动，出现了新的空白格子， 这时start随之更新一下</p> 
</blockquote> 
<p><span style="color:#be191c;"><strong>难点六：调整的退出条件（特殊情况）</strong></span></p> 
<blockquote> 
 <p> 两种情况： 1.空白格子没有孩子结点    2.有孩子结点，但是孩子结点值小于tmp</p> 
</blockquote> 
<h4 id="2.4.7%20%E6%B5%8B%E8%AF%95">2.4.7 测试</h4> 
<pre><code class="language-cpp">void Show(int* arr, int len)
{
		for (int i = 0; i &lt; len; i++)
		{
			printf("%d ", arr[i]);
		}
		printf("\n");
}



int main()
{
	int arr[] = { 12,83,78,91,57,91,72,40,91,79,5,70,12,97,49,1,75,9,71,9,24,73,21 };
	int len = sizeof(arr) / sizeof(arr[0]);
	Show(arr, len);
	Heap_Sort(arr, len);
	Show(arr, len);
	return 0;
}</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3c/fb/ea9yLbCu_o.png"></p> 
<h4 id="2.4.8%20%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90">2.4.8 算法分析</h4> 
<p>        堆排序的运行时间主要初始构建堆和再重建堆时的反复筛选上。 在构建堆的过程中，因为我们是从完全二叉树的最后一个非叶子结点开始进行构建，将它与其孩子结点进行比较和若有必要的交换，因此整个构建堆的时间复杂度为O(n)。 在正式排序时，第i次取堆顶元素重建堆需要用O(logi)的时间，并且需要取n-1次堆顶数据，所以重建堆的时间复杂度为O(nlog2n)。<span style="color:#be191c;"><strong> 所以总体来看，堆排序的时间复杂度为O(nlog2n)。</strong></span>并且由于堆排序对于原始数据的排序状态并不敏感，所以堆排序的时间复杂度无论是最好，最坏，还是平均时间复杂度都是O(nlog2n)。从这点来说， 性能显然要远远好过冒泡，简单选择，直接插入排序的(n^2 )的时间复杂度了。 空间复杂度上，它只有一个用于交换的临时变量，所以空间复杂度为O(1)。 不过由于堆排序中的数据交换是跳跃式的进行，因此堆排序的稳定性是不稳定的。 另外，由于构建初始堆所需的比较次数比较多，所以对于数据量较少的情况不适合。</p> 
<blockquote> 
 <ol><li><span style="color:#be191c;"><strong>时间复杂度：O(nlog2n)</strong></span></li><li><span style="color:#be191c;"><strong>空间复杂度：O(1)</strong></span></li><li><span style="color:#be191c;"><strong>稳定性：不稳定</strong></span></li></ol> 
</blockquote> 
<h3 id="2.5%20%E5%BD%92%E5%B9%B6%E7%B1%BB%E6%8E%92%E5%BA%8F%E2%80%94%3E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88%E9%9A%BE%EF%BC%89">2.5 归并类排序—&gt;归并排序（难）</h3> 
<p>        归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法 (Divide and Conquer) 的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2 - 路归并。</p> 
<h4 id="2.5.1%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">2.5.1基本思想</h4> 
<p></p> 
<blockquote> 
 <p>      <span style="color:#be191c;"><strong> 假设有n个数据的序列，就可以将其看作是n个有序的子序列，每一个子序列个数为一（分解思想），然后开始两两合并，这时子序列个数/2(此时，每一个子序列元素个数为2)，然后再开始两两合并，以此类推，直到所有的数据都在同一个序列内才停止（两两合并指的是两个子序列进行排序合并）</strong></span></p> 
</blockquote> 
<h4 id="2.5.2%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4">2.5.2算法步骤</h4> 
<blockquote> 
 <ol><li>如果输入内只有一个元素，则直接返回，否则将长度为 n 的输入序列分成两个长度为 n/2 的子序列；</li><li>分别对这两个子序列进行归并排序，使子序列变为有序状态；</li><li>设定两个指针，分别指向两个已经排序子序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间（用于存放排序结果），并移动指针到下一位置；</li><li>重复步骤 3 ~ 4 直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ol> 
</blockquote> 
<h4 id="2.5.3%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95">2.5.3图解算法</h4> 
<h4><img alt="" height="406" src="https://images2.imgbox.com/e8/37/qYem33jB_o.png" width="629"></h4> 
<h4 id="%C2%A02.5.4%20%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E9%9A%BE%E7%82%B9"> 2.5.4 归并排序的难点</h4> 
<p>       首先需要一个额外的数组用来存储合并后有序的数组，另外还需要四个指针——low1，high1，low2，high2，分别用来指向两个子序列的首尾，通过比较两个指针所指向的值来控制合并的顺序进而继续移动指针，实现合并。</p> 
<blockquote> 
 <p><span style="color:#1c7331;"><strong>合并规则:</strong></span><span style="color:#be191c;"><strong>将两个组的首位元素进行比较，小的挪动下来，若两个值相等，则将左边组的值挪下来，出现一组数据为空，则需要直接将另一组剩余数据依次挪下来。</strong></span></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9f/f5/HqUz5QOy_o.png"></p> 
<h4 id="2.5.5%20%E9%9D%9E%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">2.5.5 非递归方式代码实现</h4> 
<p>       注意：   非递归没有分解的过程，数据存放在数组中，将每个格子默认为一个组，也就是说N个数据，默认分为N个组，便只有合并的过程。</p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>非递归实现的难点在于：左右手抓取的情况的讨论及左右手抓取的边界控制！！！</strong></span></p> 
 <p><span style="color:#1c7331;"><strong>基本思路如下：</strong></span></p> 
 <ol><li><span style="color:#be191c;"><strong> 判断需要合并多少趟，第一趟一一合并，第二趟二二合并，...八八合并已经是最后一趟了（因为下一次的话是十六十六合并，左边的手一次就抓满了数组全部元素），也就是必须小于数组长度，每次合并数变为上一次的二倍。</strong></span></li><li><span style="color:#be191c;"><strong> 每一趟的合并中，左右手抓取然后合并，然后左右手再抓取下两组进行合并，如何控制左右的边界呢？定义四个整形变量用来标记四个位置：low1(左手左边界)，high1(左手右边界)，low2（右手左边界），high2（右手右边界），并且需要注意，每一趟的左右手抓取会出现以下四种情况，导致需要处理边界！</strong></span></li></ol> 
 <p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/95/9b/nIJRN3Q1_o.png"></strong></p> 
</blockquote> 
<p><img alt="" height="424" src="https://images2.imgbox.com/4c/db/mLfKPqK5_o.png" width="644"></p> 
<pre><code class="language-cpp">void Merge_feidigui(int *arr, int len, int gap)
{
    //1.先申请辅助空间
	int *brr = (int *)malloc(sizeof(int) * len);   //额外辅助空间brr等长
	int k = 0;//k是brr的开始下标

    //左右手边界控制
	int low1 = 0;
	int high1 = low1+gap-1; 
    int low2 = high1+1;
	int high2 = low2+gap-1&lt;len ? low2+gap-1 : len-1;  难点1

   难点2 ：控制左右手都抓到了组，才有合并必要性，用右手左边界即可
	while(low2 &lt; len)  
	{
		while(low1&lt;=high1 &amp;&amp; low2&lt;=high2)//保障两个组内都有数据
		{
			if(arr[low1] &lt;= arr[low2])
			{
				brr[k++] = arr[low1++];
			}
			else
			{
				brr[k++] = arr[low2++];
			}
		}

	难点3：	这时，while结束，则一定有一个组空了
        此时需要，将另一个不空的子序列的剩余值，依次挪动到辅助空间brr内 

		//先处理左半边组空了这种情况
		while(low2&lt;=high2)
		{
			brr[k++] = arr[low2++];
		}
		//先处理右半边组空了这种情况
		while(low1&lt;=high1)
		{
			brr[k++] = arr[low1++];
		}


   难点4：将四个指针，向右平移， 处理接下来的两个子序列   
		low1 = high2+1;
		high1 = low1+gap-1; 
		low2 = high1+1;
		high2 = low2+gap-1&lt;len ? low2+gap-1 : len-1;

	}

	//最外层的while退出，代表有两种情况需要处理，哪两种？
	//左手没抓到或者抓满，右手没抓到

	//这时，只需要将左手的数据处理一下

	难点5：
	while(low1 &lt;= len-1)//while(low1 &lt;= high1)错误写法
	{
		brr[k++] = arr[low1++];
	}

	//这时，这一趟所有的数据全部融合到了brr里
	//最后再讲brr覆盖到arr上
	for(int m=0; m&lt;len; m++)
	{
		arr[m] = brr[m];
	}

	free(brr);
	brr = NULL;
}


//归并排序 时间复杂度O(nlogn) 空间复杂度O(n)
void Merge_Sort_feidigui(int arr[], int len)
{
    //i代表几几合并，下次合并数是上次的二倍，大于数组长度则结束合并
	for(int i=1; i&lt;len; i*=2)
	{
		Merge_feidigui(arr, len, i);
	}
}</code></pre> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>难点1：由于抓取存在四种情况，因此右手的右边界如何写？</strong></span></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/58/5c/q3fQARqF_o.png"></p> 
<p><span style="color:#1c7331;"><strong>如何解决呢？</strong></span></p> 
<blockquote> 
 <p><span style="color:#be191c;"><strong>只对右手右边界high2进行判断，因为只要右手的右边界合法，前面的边界肯定也合法。</strong></span></p> 
 <p>           int high2 = low2 + gap - 1 &lt; len ? low2 + gap - 1 : len - 1; </p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>难点5：</strong></span><span style="color:#fe2c24;"><strong>左手没抓到或者抓满，右手没抓到，这时，只需要将左手的数据处理一下，怎么样控制边界？  注意：while(low1 &lt;= high1)是错误写法！！因为high1不一定合法</strong></span></p> 
</blockquote> 
<blockquote> 
 <p>（1）最后一次抓取，左手抓满，右手没抓到的情况，此时high1是合法位置。</p> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ee/b3/8fMAWKcs_o.png"></p> 
 <p>（2）最后一次抓取，左手没抓满，右手没抓到的情况，此时high1是非法位置。<strong>但是，此时high1是最后一个元素的下标，即high1=len-1。</strong></p> 
 <p><img alt="" src="https://images2.imgbox.com/de/bc/HKzBWhIg_o.png"></p> 
 <p><span style="color:#be191c;"><strong>综合以上两种情况：while(low1 &lt;= len-1)即可！</strong></span></p> 
</blockquote> 
<h4 id="2.5.6%20%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">2.5.6 递归方式代码实现</h4> 
<blockquote> 
 <p>归并排序（merge sort）是一种基于分治策略的排序算法，利用递归实现，主要包含“划分”和“合并”阶段。</p> 
 <ol><li><span style="color:#fe2c24;"><strong>划分阶段：</strong></span>通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题。</li><li><span style="color:#fe2c24;"><strong>合并阶段：</strong></span>当子数组长度为 1 时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束。</li></ol> 
</blockquote> 
<p style="text-align:center;"><img alt="" height="464" src="https://images2.imgbox.com/04/e4/Zg83AagZ_o.png" width="646"></p> 
<blockquote> 
 <p>基本包括3步:</p> 
 <ol><li><span style="color:#be191c;"><strong>分 - 将当前区间一分为二，即求分裂点 mid = (low + right)/2;</strong></span></li><li><span style="color:#be191c;"><strong>治 - 递归地对两个子区间arr[low...mid] 和 arr[mid+1...right]进行分解成多个子序列（多个组）。递归的终结条件是子序列长度为1。</strong></span></li><li><span style="color:#be191c;"><strong>合 - 将已分解后的的两个子区间arr[low...mid]和 arr[mid+1...right]归并为一个有序的区间arr[low...right]。</strong></span></li></ol> 
</blockquote> 
<p> <img alt="" src="https://images2.imgbox.com/62/a0/PlvdkSpe_o.png"></p> 
<blockquote> 
 <p>上图红色箭头为递推分解的过程，直到子序列只有一个元素，递归结束，绿色箭头为回归过程，将分解后的两个组，按照合并规则进行合并，然后构成一个组，依次递推下去，最后再回归一个大的数组，这时原数组便有序了。</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>核心代码：</strong></span></p> 
 <p><img alt="" src="https://images2.imgbox.com/f1/ee/7fIreP6l_o.png"></p> 
</blockquote> 
<pre><code class="language-cpp">//封装函数实现对两个数组的合并（利用合并规则）

left代表需要左边组的开始位置，mid代表需要组的中间位置 right代表组的最右边位置
void Re_Merge(int *arr, int *brr, int left, int mid, int right)
{
	int i = left;//i指向左半边的开始位置（左边的组开始位置）
	int j = mid+1;//j指向右半边的开始位置 （右边的组的开始位置）
	int k = left;//k是brr的开始位置 （存放到额外数组的相对应的下标）

	while(i&lt;=mid &amp;&amp; j&lt;=right)//保证两个组内都有数据
	{
		if(arr[i] &lt;= arr[j])
		{
			brr[k++] = arr[i++];
		}
		else
		{
			brr[k++] = arr[j++];
		}
	}

	//这时，while结束，则一定有一个组空了

	//处理左半边组空了这种情况
	while(j&lt;=right)
	{
		brr[k++] = arr[j++];
	}

	//处理右半边组空了这种情况
	while(i&lt;=mid)
	{
		brr[k++] = arr[i++];
	}

	//最后，记着将brr中的数据，再重新覆盖到arr内

	for(int m=left; m&lt;=right; m++)
	{
		arr[m] = brr[m];
	}

}



void Re_Divide(int *arr, int *brr, int left, int right)
{
	int mid = (left+right)/2;
    // left==right：只有一个值      left&lt;right：至少两个值     left&gt;right：没有值
    //只要有两个数据或以上，就可以继续分

	if(left &lt; right)//这里left&lt;right  保证left到right之间 不止一个数据
	{
		Re_Divide(arr, brr, left, mid); //1.分左半边
		Re_Divide(arr, brr, mid+1, right); //2.分右半边
		Re_Merge(arr, brr, left, mid, right);   //3. 对分割后的两个组进行合并
	}

}

void Merge_Sort(int arr[], int len)
{
	int *brr = (int *)malloc(sizeof(int) * len);
	Re_Divide(arr, brr, 0, len-1);
	free(brr);
}</code></pre> 
<h4 id="2.5.7%20%E6%B5%8B%E8%AF%95">2.5.7 测试</h4> 
<p><img alt="" src="https://images2.imgbox.com/db/2b/OamArPkU_o.png"></p> 
<h4 id="2.5.6%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90">2.5.8 算法分析</h4> 
<p>       归并排序中，一趟归并需要将所有数据遍历一遍，一次耗费时间O(n)，而由完全二叉树的深度可知，整个归并排序需要进行log2n次，因此总的时间复杂度为O(nlog2n)。 空间复杂度的话，因为归并排序在归并过程中需要与原始数据序列同等数量的辅助存储空间存放归 并结果以及递归时深度为log2n的栈空间，因此空间复杂度为O(n+log2n)，不过如果使用的是非递归写法，则无序考虑递归时消耗的栈空间，则空间复杂度是O(n)。 稳定性的话，我们可以发现Merge函数在进行合并两个有序序列时，其实是通过两两比较的方式， 不存在跳跃，因此归并排序是一种稳定的排序算法。 值得注意的是，递归形式的算法在形式上较简洁，但实用性很差。</p> 
<blockquote> 
 <ol><li><span style="color:#be191c;"><strong>时间复杂度：O(nlog2n)</strong></span></li><li><span style="color:#be191c;"><strong>空间复杂度：O(n) </strong></span></li><li><span style="color:#be191c;"><strong>稳定性：稳定</strong></span></li></ol> 
</blockquote> 
<h3 id="2.6%20%E4%BA%A4%E6%8D%A2%E7%B1%BB%E6%8E%92%E5%BA%8F%E2%80%94%3E%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">2.6 交换类排序—&gt;冒泡排序</h3> 
<h4 id="2.6.1%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">2.6.1基本思想</h4> 
<blockquote> 
 <p>每一趟排序，两两比较相邻数据，如果左边值大于右边值，则交换，一轮跑完，则将当前最大值放到了最后边，直到把每个数据排好位置。n个数据需要n-1轮。</p> 
 <ul><li id="u00d47f50">每轮冒泡不断地比较<strong>相邻</strong>的两个元素，如果它们是逆序的，则交换它们的位置</li><li id="udc94223e">下一轮冒泡，可以调整未排序的右边界，减少不必要比较</li></ul> 
</blockquote> 
<h4 id="2.6.2%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4">2.6.2算法步骤</h4> 
<blockquote> 
 <ol><li id="u0fe38afd">比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li id="u0c8048f8">对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li id="ufb92ce4e">针对所有的元素重复以上的步骤，除了最后一个。</li><li id="ub912a1c7">持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/24/23/EE9MS0Dv_o.png"></p> 
<h4 id="2.6.3%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95">2.6.3图解算法</h4> 
<h4 style="text-align:center;"><img alt="" src="https://images2.imgbox.com/90/fe/9mVuuDIm_o.gif"></h4> 
<h4 id="2.6.4%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><br> 2.6.4代码实现</h4> 
<pre><code class="language-cpp">//冒泡排序  时间复杂度O(n^2)  空间复杂度O(1)   稳定性：稳定
void Bubble_Sort(int *arr, int len)
{
	for(int i=0; i&lt;len-1; i++)//控制循环趟数  len-1趟
	{
        //控制每一趟具体的比较过程   j代表两两比较的左值下标 两两比较的右值下标j+1
       //for (int j = 0; j &lt; len - 1 - i; j++)
		for(int j=0; j+1&lt;len-i; j++)
（j+1是相邻比较的两个元素的右边那个元素下标，它的最大值为len-i,即减去每次已排序好的元素个数）

		{
			//从左向右 两两比较，如果左值大于右值 则交换
			if(arr[j] &gt; arr[j+1])
			{
				int tmp = arr[j];
				arr[j] = arr[j+1];
				arr[j+1] = tmp;
			}
		}
	}
}
</code></pre> 
<h4 id="2.6.5%E6%B5%8B%E8%AF%95">2.6.5测试</h4> 
<pre><code class="language-cpp">void Show(int* arr, int len)
{
	for (int i = 0; i &lt; len; i++)
	{
		printf("%d ", arr[i]);
	}
	printf("\n");
}


int main()
{
	int arr[] = { 12,83,78,91,57,91,72,40,91,79,5,70,12,97,49,1,75,9,71,9,24,73,21 };
	int len = sizeof(arr) / sizeof(arr[0]);
	Show(arr, len);
	BubbleSort(arr, len);
	Show(arr, len);
	return 0;
}</code></pre> 
<h4 style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3a/1d/aF9cDRqg_o.png"></h4> 
<h4 id="2.6.6%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><br> 2.6.6算法分析</h4> 
<blockquote> 
 <ol><li><span style="color:#be191c;"><strong>时间复杂度为O(n^2 )</strong></span></li><li><span style="color:#be191c;"><strong>空间复杂度为O(1) </strong></span></li><li><span style="color:#be191c;"><strong>稳定性：稳定 （未发生跳跃交换）</strong></span></li></ol> 
</blockquote> 
<h4 id="2.6.8%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96">2.6.7如何优化</h4> 
<blockquote> 
 <p>如果在第i次比较后，整个排序序列为有序序列时，按上述代码，仍然要将剩余轮数比较结束，这就是可以优化的点。<br><span style="color:#be191c;"><strong>设置一个标记flag，当循环中没有元素相互交换时就跳出循环</strong></span></p> 
</blockquote> 
<pre><code class="language-cpp">void BubbleSort(int* arr, int len)
{
	assert(arr != NULL);
	for (int i = 0; i &lt; len - 1; i++)    //外层循环控制趟数
	{
		bool flag = true;
		//for (int j = 0; j &lt; len - 1 - i; j++)

		for (int j = 0; j+1 &lt; len - i; j++)   //内层循环控制每趟的元素比较   （j+1是相邻比较的两个元素的右边那个元素下标，它的最大值为len-1,再减去每次已排序好的元素个数）
		{
			if (arr[j] &gt; arr[j + 1])
			{
				flag = false;
				int tmp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = tmp;
			}
		}
		if (flag == true)  //这一趟未发生交换，代表完全有序，直接跳出外层循环，不会进行下一趟排序
		{
			break;
		}
	}
}</code></pre> 
<h3 id="2.7%C2%A0%E4%BA%A4%E6%8D%A2%E7%B1%BB%E6%8E%92%E5%BA%8F%E2%80%94%3E%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F(%E9%9A%BE%EF%BC%8C%E7%AC%94%E8%AF%95%E6%9C%80%E5%B8%B8%E8%80%83)">2.7 交换类排序—&gt;快速排序(难，笔试最常考)</h3> 
<p>        快速排序算法最早有图灵奖获得者Tony Hoare设计出来的，他是上世界最伟大的计算机科学家之一。而这快速排序算法只是他众多贡献中的一个小发明而已，但是也被列为20世纪十大算法之一。 我们前面学过的希尔排序相当于直接插入排序的升级，它们同属于插入排序类。堆排序相当于选择 排序的升级，它们同属于选择排序类。而快速排序其实就是我们之前学过的最简单的排序冒泡排序的升 级，它们同属于交换排序类。 即快速排序是通过不断的比较和移动交换来实现排序的，只不过它的实现，增大了数据的比较和移动的距离，将较大的数据从前面直接移动到后面，较小的数据从后面直接移动到前面，从而减少了总的比较次数和移动交换次数。</p> 
<h4 id="2.7.%201%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">2.7.1 基本思想</h4> 
<blockquote> 
 <p>          通过一趟排序以基准值为标准将所有待排序序列分成两部分，其中左边部分的数据都小于基准值，而另右边部分的数据都大于基准值，然后再分别对这两部分进行快速排序，直到所有的值都全部有序（当子序列只有一个值的时候，不用对其再进行划分，默认其有序）即函数调函数，使用了递归的思想。<br><span style="color:#fe2c24;"><strong>        排序的具体规则:先从右向左找比基准值小的值，找到后放到左边空位上，然后从左向右找比基准值大的值，放到右边的空位上，然后再从右向左，直到左右指针相遇。</strong></span></p> 
</blockquote> 
<h4 id="2.7.2%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4">2.7.2 算法步骤</h4> 
<blockquote> 
 <p>因为可以使用递归，所以递归函数具体做的事情如下：<span style="color:#be191c;"><strong>每一趟排序，让left和right分别指向序列的最左端和最右端，且将第一个值看做基准值放入tmp中，然后以right--的方式从右向左找一个比基准值 小的值，放到左边空位，然后再以left++的方式从左向右找一个比基准值大的值，放到右边空位，循环 往复，让left和right向中间逼近，直到left和right相遇，再将刚才临时保存在tmp中的基准值放回来，此 时会发现，以基准值为分界线，将序列分成了两部分，左边部分都小于基准值，而右边部分都大于基准值。</strong></span></p> 
</blockquote> 
<h4 id="2.7.3%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95"><br> 2.7.3 图解算法</h4> 
<p style="text-align:center;"><img alt="" height="395" src="https://images2.imgbox.com/d5/29/onej16mx_o.png" width="602"></p> 
<h4 id="2.7.4%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">2.7.4 递归方式的代码实现</h4> 
<pre><code class="language-cpp">int Partition(int arr[], int left, int right)
{
	int tmp = arr[left];  //1.将第一个值看做基准值，用tmp保存

	while(left &lt; right)//确保两个指针未相遇
	{
		//从右向左找比基准值小的
//如果两个指针还未相遇，且right指向的值大于tmp，则right--
		while(left&lt;right &amp;&amp; arr[right]&gt;tmp)
		{
			right--;
		}

//此时while循环结束，只有两个可能：1.两个指针相遇 2.找到了小于tmp的值，由right指向
		if(left == right)//指针相遇
		{
           arr[left] = tmp; //或者arr[right] = tmp;  
			return left; //或者return right;
			//break;
		}
        //找到比基准值小的
		arr[left] = arr[right];


		//从左向右比基准值大的
//如果两个指针还未相遇，且left指向的值小于等于于tmp，则left++
		while(left&lt;right &amp;&amp; arr[left] &lt;= tmp)//**这里是小于等于
		{
			left++;
		}

//此时while循环结束，只有两个可能：1.两个指针相遇 2.找到了大于tmp的值，由left指向
		if(left == right)
		{
            //arr[left] = tmp; 或者arr[right] = tmp;  
			//return left; 或者return right;
			break;
		}

		arr[right] = arr[left];
	}

//此时，代码到这一行，代表着最大的while结束了，也就是说两个指针相遇了
//将tmp的值，重新放回来，然后返回基准值的下标
	arr[left] = tmp;
	return left;

}

void Quick(int arr[], int left, int right)
{

	int par = Partition(arr, left, right);

	//先看基准值所在下标的左半边 是否不止一个值
	if(left &lt; par-1)
	{
		Quick(arr, left, par-1);
	}
	//再看基准值所在下标的右半边 是否不止一个值
	if(par+1 &lt; right)
	{
		Quick(arr, par+1, right);
	}
}

//快速排序 时间复杂度O(nlogn) 空间复杂度O(logn)
void Quick_Sort(int arr[], int len)
{

	Quick(arr, 0, len-1);
}</code></pre> 
<h4 id="2.7.5%20%E9%9D%9E%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" style="background-color:transparent;">2.7.5 非递归方式的代码实现</h4> 
<blockquote> 
 <p>       利用到了栈这一种数据结构，合理利用栈的特点，将每一次的 left 和 right 入栈，然后出栈调用分割函数。</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/6b/55/YKrKMM6C_o.png"> </p> 
<pre><code class="language-cpp">#include &lt;stack&gt;
int Partition(int arr[], int left, int right)
{
	int tmp = arr[left];

	while(left &lt; right)//确保两个指针未相遇
	{
		//从右向左找比基准值小的
		while(left&lt;right &amp;&amp; arr[right]&gt;tmp)
		{
			right--;
		}
		if(left == right)
		{
			break;
		}
		arr[left] = arr[right];


		//从左向右比基准值大的
		while(left&lt;right &amp;&amp; arr[left] &lt;= tmp)//**这里是小于等于
		{
			left++;
		}
		if(left == right)
		{
			break;
		}
		arr[right] = arr[left];
	}

	arr[left] = tmp;
	return left;

}



void Quick_Stack(int arr[], int left, int right)
{
	//1.申请一个栈，利用系统提供的栈
	std::stack&lt;int&gt; st;

	//2.调用一次划分函数，返回5，将数据划分为两部分，0-4和6-9
	int par = Partition(arr, left, right);

	//左半部分不止一个元素，进行入栈
	if(left &lt; par-1)
	{
		st.push(left);   //将0压入栈
		st.push(par-1);  //将4压入栈
	}

	//右半部分不止一个元素，进行入栈
	if(par+1 &lt; right)
	{
		st.push(par+1);  //将6压入栈
		st.push(right);  //将9压入栈
	}

	//栈不为空
	while(!st.empty())
	{
		right = st.top(); //获取栈顶元素9
		st.pop();         //将栈顶元素9出栈，
		left = st.top();  //获取栈顶元素6
		st.pop();        //将栈顶元素6出栈

		//对6-9这部分，调用划分函数，返回基准值下标，此时将右边划分两个部分
		par = Partition(arr, left, right);

		//左半部分不止一个元素，进行入栈
		if(left &lt; par-1)
		{
			st.push(left);
			st.push(par-1);
		}

		//右半部分不止一个元素，进行入栈
		if(par+1 &lt; right)
		{
			st.push(par+1);
			st.push(right);
		}

	}
	//退出循环说明将一开始的右半部分和左半部分都调用划分函数处理完毕！

}

void Quick_Sort_Stack(int arr[], int len)
{
	Quick_Stack(arr, 0, len-1);
}</code></pre> 
<h4>2.7.6 测试</h4> 
<pre><code class="language-cpp">void Show(int* arr, int len)
{
	for (int i = 0; i &lt; len; i++)
	{
		printf("%d ", arr[i]);
	}
	printf("\n");
}

int main()
{
	int arr[] = { 12,83,78,91,57,91,72,40,91,79,5,70,12,97,49,1,75,9,71,9,24,73,21 };
	int len = sizeof(arr) / sizeof(arr[0]);
	Show(arr, len);
	Quick_Sort(arr, len);
	Show(arr, len);

}</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/49/08/Zc2u7s6l_o.png"></p> 
<h4 id="2.7.7%20%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90">2.7.7 算法分析</h4> 
<blockquote> 
 <ol><li><span style="color:#be191c;"><strong>时间复杂度：O(n<em>logn)  </em></strong></span></li><li><span style="color:#be191c;"><strong>空间复杂度：</strong></span>如果快速排序采用递归写法，需要有一个栈用来存放每层递归调用时的参数(新的 left和right等)，且最大递归调用层数与递归树的深度一致，因此，空间开销为<span style="color:#be191c;"><strong>O(log2n)</strong></span></li><li><span style="color:#be191c;"><strong>稳定性：不稳定</strong></span>（发生了跳跃交换）</li></ol> 
</blockquote> 
<h4 id="2.7.7%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96">2.7.8 快速排序的特点以及如何优化</h4> 
<p><br>         考虑下面这组数据，完全有序，每次遍历数组时，只有基准值在一边，其余数据都在另一边，因此，这样如果递归的的话，树的深度非常深就等于数据个数，时间复杂度为O(n^2),因为它是等差数列的求和。</p> 
<p style="text-align:center;"><img alt="" height="567" src="https://images2.imgbox.com/eb/ac/MZeapFVY_o.png" width="512"></p> 
<blockquote> 
 <p>从上面我们可以知道：<span style="color:#fe2c24;"><strong>数据越有序，递归的深度越深，时间复杂度越高，反过来，数据越乱，递归的深度就越浅，时间复杂度越低</strong></span>，因此，这也是我们优化思路的出发点！</p> 
</blockquote> 
<h4 id="2.7.9%C2%A0%20%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95">2.7.9  优化方法</h4> 
<blockquote> 
 <p>因为快排数据越乱跑起来越快（数据越乱，就有更大的可能将数据均分为两个部分，时间复杂度接近 n*logn），所以优化的目的都是将数据尽可能地弄乱。优化的思路如下：</p> 
 <ol><li><span style="color:#be191c;"><strong>如果数据量过小，则可以直接转向调用直接插入排序，因为n小的话，n^2也不会太大。或者递归时，如果子序列数据量过小，也可以直接调用直接插入排序。 </strong></span></li><li><span style="color:#be191c;"><strong>三数取中法，取最左端值，最右端值，中间值，三者中的不大不小的作为基准值。</strong></span></li><li><span style="color:#be191c;"><strong>随机数法，通过使用随机函数，将数据打乱。</strong></span></li></ol> 
</blockquote> 
<blockquote> 
 <p><span style="color:#1c7331;"><strong>1.直接调用插入排序 ：</strong></span></p> 
</blockquote> 
<pre><code class="language-cpp">//快速排序 进入后先判断数据的个数，数据量较少，直接调用插入排序
void Quick_Sort(int arr[], int len)
{
	if(len &lt; 1000)//优化1
	{
		Insert_Sort(arr, len);
		return;
	}

	Quick(arr, 0, len-1);
}</code></pre> 
<blockquote> 
 <p><span style="color:#1c7331;"><strong>2.三数取中法 ：</strong></span>在调用划分函数之前先调用三数取中函数，找到数组中最左边的数，最右边的数，和中间的数，将不大不小的数放在最左边，目的还是为了让有序的数组变得无序。</p> 
</blockquote> 
<pre><code class="language-cpp">//三数取中函数
void Three_nums_Get_Mid(int* arr, int left, int right)
{
	int mid = (left + right) / 2;

	//核心代码：3个if判断

	//如果左边大于中间，则交换
	if (arr[left] &gt; arr[mid])//这个if保证左中较大值，放到中间位置
	{
		int tmp = arr[left];
		arr[left] = arr[mid];
		arr[mid] = tmp;
	}

	if (arr[mid] &gt; arr[right])//这个if保证中右较大值，放到右边位置
	{
		int tmp = arr[left];
		arr[left] = arr[mid];
		arr[mid] = tmp;
	}
    //执行到这里，最大的值已被我们放到最右边

	if (arr[left] &lt; arr[mid])//这个if保证左中较大值，放到左边位置
	{
		int tmp = arr[left];
		arr[left] = arr[mid];
		arr[mid] = tmp;
	}
}




void Quick(int arr[], int left, int right)
{
	Three_nums_Get_Mid(arr, left, right);  //调用三数取中函数
	int par = Partition(arr, left, right);

	//先看基准值所在下标的左半边 是否不止一个值
	if(left &lt; par-1)
	{
		Quick(arr, left, par-1);
	}
	//再看基准值所在下标的右半边 是否不止一个值
	if(par+1 &lt; right)
	{
		Quick(arr, par+1, right);
	}
}</code></pre> 
<h3>2.8  基数排序 </h3> 
<blockquote> 
 <p><strong>非比较类排序算法</strong></p> 
</blockquote> 
<h4 id="2.8.1%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">2.8.1基本思想</h4> 
<blockquote> 
 <p>        基数排序是非比较的排序算法，是一种借助多关键字排序的思想!   最低位优先法:<span style="color:#be191c;"><strong>规定先以最低位关键字对所有数据进行排序，再以次最低位对所有数据进行排序，依次重复，直接最高位对所有数据进行了一趟排序</strong></span>，这时所有数据则完全有序</p> 
</blockquote> 
<h4 id="2.8.2%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4">2.8.2算法步骤</h4> 
<blockquote> 
 <p id="u67108cc8">以年龄数据为例，假设数字的最低位是第1位，最高位是第3位.；</p> 
 <ol><li id="ub0256325">先按照个位进行排序，放入10个队列，再出队，得到第一次排序结果；</li><li id="u5a06bf24">再按照十位进行排序，放入10个队列，再出队，得到第二次排序结果；</li><li id="ua480dc83">最后按照百位进行排序，放入10个队列，再出队，得到最终的排序结果；</li></ol> 
</blockquote> 
<h4 id="2.8.3%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95">2.8.3图解算法</h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/bc/1f/FDK2291g_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/13/6f/Ahl8AxAG_o.png"></p> 
<h4 style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a9/5f/6YIFCNpl_o.png"></h4> 
<p><img alt="" src="https://images2.imgbox.com/b2/d5/RvWrSZxl_o.png"></p> 
<h4 id="2.8.4%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><br> 2.8.4代码实现</h4> 
<pre><code class="language-cpp">//获取num对应位是多少？例如：12345,0 -&gt;5      //123,4-&gt; 0
int Get_Num_finger_shiduoshao(int num, int fin)
{
	for(int i=0; i&lt;fin; i++)
	{
		num = num/10;
	}
	return num%10;
}


//基数排序主要函数
void Radix(int arr[], int len, int finger)
{
	std::queue&lt;int&gt; bucket[10]; //10个桶（队列）申请好了

	//将所有值，依次按照对应位的值放到对应的桶内
	for(int i=0; i&lt;len; i++)
	{  
        //先判断arr[i]应该存放哪一个桶
	    int fin = Get_Num_finger_shiduoshao(arr[i], finger);  
		bucket[fin].push(arr[i]);     //在将这个值插入到对应的队列内
	}
	//此时，for循环结束，代表着所有的值，都放到了对应的桶内(队列内)

	int k = 0;//k代表 桶内数据重新向arr写入的时候，写入的位置下标
	//从0~9号桶（队列），依次将桶内值取出来放到arr中（按队列的规则）
	for(int i=0; i&lt;=9; i++)
	{
		while(!bucket[i].empty())
		{
			arr[k++] = bucket[i].front();//获取队头元素值存放到对应数组位置
			bucket[i].pop();     //出队，把存放过的数据出队（删除）
		}

	}
	//此时，for循环结束，代表着所有的值,都从桶内，重新放回了arr

}


//基数排序 时间复杂度O(d*n) 空间复杂度O(n)
void Radix_Sort(int arr[], int len)
{
	int finger = Get_Num_Finger(arr, len);

	for(int i=0; i&lt;finger; i++)
	{
		Radix(arr, len, i); //当i=0，代表以个位进行一次排序 
	}

}</code></pre> 
<h4 id="2.8.5%E6%B5%8B%E8%AF%95">2.8.5测试</h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/25/06/Gngt37KB_o.png"></p> 
<h4 id="2.8.6%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90">2.8.6算法分析</h4> 
<blockquote> 
 <p>假设最大值的位数是d：</p> 
 <ol><li><span style="color:#be191c;"><strong>时间复杂度O(d*n) </strong></span></li><li><span style="color:#be191c;"><strong>空间复杂度O(n) </strong></span></li><li><span style="color:#be191c;"><strong>稳定性：稳定，队列先入先出，未改变数据的顺序</strong></span></li></ol> 
</blockquote> 
<h4 id="2.8.7%E4%BC%98%E7%BC%BA%E7%82%B9">2.8.7优缺点</h4> 
<blockquote> 
 <p>      很明显，基数排序与数据的位数有关，位数越多，排序的趟数就会越大，因此基数排序适用于数据的位数相差不大的情况下。</p> 
</blockquote> 
<h2 id="%E4%B8%89%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%8A%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90">三、排序算法复杂度及稳定性分析</h2> 
<p><img alt="" src="https://images2.imgbox.com/88/1b/UbM3RaYx_o.png"></p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/95/c1/swZas0jC_o.png"></p> 
<h2 id="%E5%9B%9B%E3%80%81%E9%80%89%E6%8B%A9%E9%A2%98%E7%BB%83%E4%B9%A0" style="background-color:transparent;">   </h2> 
<p style="background-color:transparent;">        以上便是我为大家带来的八大排序算法精彩内容，若有不足，望各位大佬在评论区指出，谢谢大家！感兴趣可以留下你们的点赞、收藏和关注，这是对我极大的鼓励，我也会更加努力创作更优质的作品。再次感谢大家！</p> 
<p></p> 
<p style="text-align:center;"></p> 
<p style="text-align:center;"></p> 
<p style="text-align:center;"></p> 
<p style="text-align:center;"></p> 
<p style="text-align:center;"></p> 
<p style="text-align:center;"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/acd644bb8713e3d99622e2e9a60ae90b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">详解循环队列——链表与数组双版本</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d3d17756040a24906017310e1077cd47/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">DS高阶：B树系列</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>