<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>javaSE-----继承和多态 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/a60bed5e26bd5768db0b135b3200acb3/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="javaSE-----继承和多态">
  <meta property="og:description" content="目录
一.初识继承：
1.1什么是继承，为什么需要继承：
1.2继承的概念与语法：
二.成员的访问：
2.1super关键字
2.2this和super的区别：
三.再谈初始化:
小结：
四.初识多态：
4.1多态的概念：
4.2多态的实现条件：
一.初识继承： 1.1什么是继承，为什么需要继承： Java中使用类对现实世界中实体来进行描述，类经过实例化之后的产物对象，则可以用来表示现实中的实体，但是现实世界错综复杂，事物之间可能会存在一些关联，那在设计程序是就需要考虑。👌👌👌 那具体来说是怎么样的呢？🧐🧐🧐举个例子，比如猫狗，他们都是一个动物： 用Java语言来描述就是：
class Cat{ public String name; public int age; public Cat(String name, int age) { this.name = name; this.age = age; } public void eat(){ System.out.println(this.name&#43;&#34;正在吃！&#34;); } } class Dog{ public String name; public int age; public Dog(String name, int age) { this.name = name; this.age = age; } public void eat(){ System.out.println(this.name&#43;&#34;正在吃！&#34;); } } public class Test1 { public static void main(String[] args){ Dog dog = new Dog(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-19T19:24:52+08:00">
    <meta property="article:modified_time" content="2024-03-19T19:24:52+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">javaSE-----继承和多态</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.%E5%88%9D%E8%AF%86%E7%BB%A7%E6%89%BF%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E5%88%9D%E8%AF%86%E7%BB%A7%E6%89%BF%EF%BC%9A" rel="nofollow">一.初识继承：</a></p> 
<p id="1.1%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BB%A7%E6%89%BF%EF%BC%9A-toc" style="margin-left:40px;"><a href="#1.1%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BB%A7%E6%89%BF%EF%BC%9A" rel="nofollow">1.1什么是继承，为什么需要继承：</a></p> 
<p id="1.2%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E8%AF%AD%E6%B3%95%EF%BC%9A-toc" style="margin-left:40px;"><a href="#1.2%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E8%AF%AD%E6%B3%95%EF%BC%9A" rel="nofollow">1.2继承的概念与语法：</a></p> 
<p id="%C2%A0%E4%BA%8C.%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BA%8C.%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%EF%BC%9A" rel="nofollow"> 二.成员的访问：</a></p> 
<p id="super%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:40px;"><a href="#super%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">2.1super关键字</a></p> 
<p id="this%E5%92%8Csuper%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A-toc" style="margin-left:40px;"><a href="#this%E5%92%8Csuper%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A" rel="nofollow">2.2this和super的区别：</a></p> 
<p id="%E4%B8%89.%E5%86%8D%E8%B0%88%E5%88%9D%E5%A7%8B%E5%8C%96%3A-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%E5%86%8D%E8%B0%88%E5%88%9D%E5%A7%8B%E5%8C%96%3A" rel="nofollow">三.再谈初始化:</a></p> 
<p id="%E5%B0%8F%E7%BB%93%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%B0%8F%E7%BB%93%EF%BC%9A" rel="nofollow">小结：</a></p> 
<p id="%E5%9B%9B.%E5%88%9D%E8%AF%86%E5%A4%9A%E6%80%81%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%9B%9B.%E5%88%9D%E8%AF%86%E5%A4%9A%E6%80%81%EF%BC%9A" rel="nofollow">四.初识多态：</a></p> 
<p id="4.1%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9A-toc" style="margin-left:40px;"><a href="#4.1%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9A" rel="nofollow">4.1多态的概念：</a></p> 
<p id="4.2%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6%EF%BC%9A-toc" style="margin-left:40px;"><a href="#4.2%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6%EF%BC%9A" rel="nofollow">4.2多态的实现条件：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80.%E5%88%9D%E8%AF%86%E7%BB%A7%E6%89%BF%EF%BC%9A">一.初识继承：</h2> 
<h3 id="1.1%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BB%A7%E6%89%BF%EF%BC%9A">1.1什么是继承，为什么需要继承：</h3> 
<div> 
 <strong><span style="color:#333333;"><span style="background-color:#ff9900;">Java</span></span><span style="color:#333333;"><span style="background-color:#ff9900;">中使用类对现实世界中实体来进行描述，类经过实例化之后的产物对象，则可以用来表示现实中的实体</span>，但是现实世界错综复杂，事物之间可能会存在一些关联，那在设计程序是就需要考虑。👌👌👌</span></strong> 
</div> 
<div> 
 <strong><span style="color:#333333;">那具体来说是怎么样的呢？🧐🧐🧐举个例子，比如猫狗，他们都是一个动物：</span></strong> 
</div> 
<div> 
 <img alt="" height="1200" src="https://images2.imgbox.com/f3/88/CjhyxAi8_o.png" width="1200"> 
</div> 
<p> 用Java语言来描述就是：</p> 
<pre><code class="language-java">class Cat{
    public String name;
    public int age;

     public Cat(String name, int age) {
         this.name = name;
         this.age = age;
     }

     public void eat(){
         System.out.println(this.name+"正在吃！");
     }
 }

 class Dog{
     public String name;
     public int age;

     public Dog(String name, int age) {
         this.name = name;
         this.age = age;
     }

     public void eat(){
         System.out.println(this.name+"正在吃！");
     }
 }
 
public class Test1 {
    public static void main(String[] args){
        Dog dog = new Dog("小黄",5);
        dog.eat();
        Cat cat = new Cat("小花",6);
        cat.eat();
    }
}</code></pre> 
<p>通过观察，我们可以发现，其中有诸多的地方重复，但是两个对象都从属于动物，<span style="color:#333333;">那能否将这些共性抽取呢？</span><span style="color:#333333;"><strong>面向对象思想中提出了继承的概念，专门用来进行共性抽取，实现代码复用</strong></span><span style="color:#333333;">。😀😀😀</span></p> 
<h3 id="1.2%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E8%AF%AD%E6%B3%95%EF%BC%9A"><span style="color:#333333;">1.2继承的概念与语法：</span></h3> 
<p><span style="color:#333333;"><strong>继承</strong></span><span style="color:#333333;"><strong>(inheritance)</strong></span><span style="color:#333333;"><strong>机制</strong></span><span style="color:#333333;">：<span style="background-color:#ff9900;">是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行</span><strong><span style="background-color:#ff9900;">扩展，增加新功能</span></strong></span><span style="color:#333333;">，这样产生新的类，称</span><span style="color:#333333;"><strong>派生类</strong></span><span style="color:#333333;">。继承呈现了面向对象程序设计的层次结构， 体现了由简单到复杂的认知过程。继承主要解决的问题是：<strong><span style="background-color:#ffd900;">共性的抽取，实现代码复用</span></strong></span><span style="color:#333333;"><span style="background-color:#ffd900;">。🧐🧐🧐🧐</span></span></p> 
<p><img alt="" height="706" src="https://images2.imgbox.com/05/9d/fB5JSXOa_o.png" width="1200"></p> 
<p><strong><span style="color:#333333;">语法实现：</span></strong></p> 
<pre><code class="language-java">修饰符 class 子类 extends 父类 {
// ... 
}</code></pre> 
<p><strong>具体来说：</strong></p> 
<pre><code class="language-java">
class Animal{
    public String name;
    public int age;

    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void eat(){
        System.out.println(this.name+"正在吃！");
    }
}
//子类会继承父类的内容，所以子类无需自己定义其他内容
class Dog extends Animal {

    public Dog(String name, int age) {
        super(name, age);
                        //当子类继承父类之后，要先帮助父类进行成员的初始化
    }                    //此时需要通过super关键字来实现
    public void bark(){//子类中特有的方法
        System.out.println(this.name+"正在汪汪汪~");
    }
}
 class Cat extends Animal{

     public Cat(String name, int age) {
         super(name, age);//当子类继承父类之后，要先帮助父类进行成员的初始化
     }                    //此时需要通过super关键字来实现

     public void miaomiao(){//子类中特有的方法
         System.out.println(this.name+"正在喵喵叫~");
     }
 }
 //测试方法
public class Test1 {
    public static void main(String[] args){
        Dog dog = new Dog("小黄",5);
        dog.eat();//dog类中并没有定义任何成员变量，name和age属性肯定是从父类Animal中继承下来的
        dog.bark();
        System.out.println("=======================================");
        Cat cat = new Cat("小花",6);
        cat.eat();//cat类中并没有定义任何成员变量，name和age属性肯定是从父类Animal中继承下来的
        cat.miaomiao();
    }
}
</code></pre> 
<p>输出结果：</p> 
<p> <img alt="" height="259" src="https://images2.imgbox.com/f7/ac/gkLBAoCK_o.png" width="576"></p> 
<blockquote> 
 <p><strong> 注意：</strong></p> 
 <ul><li><strong><span style="color:#333333;"> 🐻子类会将父类中的成员变量或者成员方法继承到子类中</span></strong></li><li> 
   <div> 
    <strong><span style="color:#333333;">🐻子类继承父类之后，必须要新添加自己特有的成员，体现出与基类的不同，否则就没有必要继承了</span></strong> 
   </div> </li><li><strong>🐻当子类继承父类之后，要先帮助父类进行成员的初始化，此时需要通过super关键字来实现。（后面介绍super关键字）</strong></li></ul> 
</blockquote> 
<h2 id="%C2%A0%E4%BA%8C.%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%EF%BC%9A"> 二.成员的访问：</h2> 
<div> 
 <span style="color:#333333;">在继承体系中，子类将父类中的方法和字段继承下来了，那在子类中能否直接访问父类中继承下来的成员呢？🧐🧐🧐答案是可以的，这时就需要用到super关键字：</span> 
</div> 
<h3 id="super%E5%85%B3%E9%94%AE%E5%AD%97"><span style="color:#333333;">2.1super关键字</span></h3> 
<blockquote> 
 <p><span style="background-color:#ffd900;">🐻super.data:访问父类的成员变量</span></p> 
 <p><span style="background-color:#ffd900;">🐻super.func()：访问父类的方法</span></p> 
 <p><span style="background-color:#ffd900;">🐻super():访问父类的构造方法</span></p> 
</blockquote> 
<pre><code class="language-java">class Base{
    protected int a;
    protected int b;
    protected int c;
    protected int d;

    public Base(int a, int b, int c, int d) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
    }
    public void methodA(){
        System.out.println("父类的方法!");
    }
}
class Drived extends Base{
    int c;
    int d;

    public Drived(int a, int b, int c, int d) {
        super(a, b, c, d);//访问父类的构造方法
    }

    @Override
    public String toString() {
        return "Drived{" +
                "a=" + a +
                ", b=" + b +
                ", c=" + c +
                ", d=" + d +
                '}';
    }

    public void method(){
        super.a = 10;
        super.b = 20;//supr.data直接访问父类成员变量
        d = 30;//访问从父类继承下来的d
        this.c = 40;
        this.a = 20;//覆盖了刚才调用的父类成员变量
    }
    public void methodB(){
        super.methodA();//调用父类的方法
        System.out.println("子类的方法！");
    }

}
public class Test1 {
    public static void main(String[] args){
        Drived d = new Drived(0,0,0,0);
        d.methodB();
        d.method();
        System.out.println(d);
    }
}
</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="221" src="https://images2.imgbox.com/ec/a4/Gf0Ssbki_o.png" width="1100"></p> 
<p><strong>🐻 其中成员的访问顺序是：先看子类有没有，子类有，优先访问子类的成员，子类没有，去父类中找，父类中也没有，就报错。</strong></p> 
<h3 id="this%E5%92%8Csuper%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><strong>2.2this和super的区别：</strong></h3> 
<div> 
 <span style="color:#333333;">super</span> 
 <span style="color:#333333;">和</span> 
 <span style="color:#333333;">this</span> 
 <span style="color:#333333;">都可以在成员方法中用来访问：成员变量和调用其他的成员函数，都可以作为构造方法的第一条语句，那他们之间有什么区别呢？</span> 
</div> 
<blockquote> 
 <div> 
  <span style="color:#333333;">相同点：</span> 
 </div> 
 <div> 
  <div> 
   <span style="color:#333333;">1.😺 </span> 
   <span style="color:#333333;">都是</span> 
   <span style="color:#333333;">Java</span> 
   <span style="color:#333333;">中的关键字 </span> 
  </div> 
  <div> 
   <span style="color:#333333;">2.😺 </span> 
   <span style="color:#333333;">只能在类的非静态方法中使用，用来访问非静态成员方法和字段 </span> 
  </div> 
  <div> 
   <span style="color:#333333;">3. 😺</span> 
   <span style="color:#333333;">在构造方法中调用时，必须是构造方法中的第一条语句，并且不能同时存在 </span> 
  </div> 
 </div> 
</blockquote> 
<blockquote> 
 <p><img alt="" height="599" src="https://images2.imgbox.com/e5/5b/wQWXXAMY_o.png" width="1200"> 不同点：</p> 
 <div> 
  <span style="color:#333333;">1. 🐻this</span> 
  <span style="color:#333333;">是当前对象的引用，当前对象即调用实例方法的对象，</span> 
  <span style="color:#333333;">super</span> 
  <span style="color:#333333;">相当于是子类对象中从父类继承下来部分成员的引用</span> 
 </div> 
 <div> 
  <div> 
   <span style="color:#333333;">2. 🐻</span> 
   <span style="color:#333333;">在非静态成员方法中，</span> 
   <span style="color:#333333;">this</span> 
   <span style="color:#333333;">用来访问本类的方法和属性，</span> 
   <span style="color:#333333;">super</span> 
   <span style="color:#333333;">用来访问父类继承下来的方法和属性</span> 
  </div> 
  <div> 
   <div> 
    <span style="color:#333333;">3. 🐻</span> 
    <span style="color:#333333;">在构造方法中：</span> 
    <span style="color:#333333;">this(...)</span> 
    <span style="color:#333333;">用于调用本类构造方法，</span> 
    <span style="color:#333333;">super(...)</span> 
    <span style="color:#333333;">用于调用父类构造方法，两种调用不能同时在构造方法中出现</span> 
   </div> 
   <div> 
    <div> 
     <span style="color:#333333;">4. 🐻</span> 
     <span style="color:#333333;">构造方法中一定会存在</span> 
     <span style="color:#333333;">super(...)</span> 
     <span style="color:#333333;">的调用，用户没有写编译器也会增加，但是</span> 
     <span style="color:#333333;">this(...)</span> 
     <span style="color:#333333;">用户不写则没有 </span> 
    </div> 
   </div> 
  </div> 
 </div> 
</blockquote> 
<h2 id="%E4%B8%89.%E5%86%8D%E8%B0%88%E5%88%9D%E5%A7%8B%E5%8C%96%3A">三.再谈初始化:</h2> 
<div>
  在对成员变量进行初始化的过程中，我们会用到静态代码块，实例代码块和构造方法，那在实际的运行过程中，他们的运行次序是怎样的呢？我们先看以下代码： 
</div> 
<div> 
 <pre><code class="language-java">class Animal {
    public String name;
    public int age;
    public String color;

    static {
        System.out.println("父类的静态代码块，Animal::static{}");
    }

    {
        System.out.println("父类的实例代码块，Animal::{}");
    }

    public Animal(String name, int age, String color) {
        this.name = name;
        this.age = age;
        this.color = color;
        System.out.println("父类的构造方法，Animal(String,int,String)");
    }

    public void eat() {
        System.out.println(this.name +" 正在吃饭！");
    }
}
class Dog extends Animal{
    static {
        System.out.println("子类的静态代码块，Dog::static{}");
    }
    {
        System.out.println("子类的实例代码块,Dog::{}");
    }
    public Dog() {
        super("haha",10,"黄色");//虽然 调用了父类的构造方法 ，
        System.out.println("子类的构造方法，Dog()"); // 但是 并没有产生父类对象，此时 只是帮你进行初始化父类的成员
    }
    public void bark() {
        System.out.println(this.name +" 正在汪汪汪！");
    }
}

public class Test1 {
    public static void main(String[] args) {
        Dog dog1 = new Dog();
        System.out.println("==============");
        Dog dog2 = new Dog();
    }
}
</code></pre> 
</div> 
<div>
  运行结果： 
</div> 
<div></div> 
<p><img alt="" height="342" src="https://images2.imgbox.com/6a/bc/A6al99h9_o.png" width="553"></p> 
<blockquote> 
 <p>由此，我们可以得出（执行顺序的）结论：</p> 
 <p><span style="background-color:#ffd900;">1.父类的静态代码块，子类的静态代码块</span></p> 
 <p><span style="background-color:#ffd900;">2.父类的实例代码块，父类的构造方法</span></p> 
 <p><span style="background-color:#ffd900;">3.子类的实例代码块，子类的构造方法</span></p> 
 <p><span style="background-color:#ff9900;">----------》静态代码块在整个程序中只执行一次</span></p> 
</blockquote> 
<p></p> 
<h3 id="%E5%B0%8F%E7%BB%93%EF%BC%9A">小结：</h3> 
<p><strong>继承的好处：<br> 1.提高了代码的复用性（多个类相同的成员可以放在同一个类中）<br> 2.提高了代码的维护性（如果方法的代码需要修改，只修改一处即可）<br> 继承的坏处：<br> 1.继承让类与类建立了关系，类的耦合性增强<br> 2.当父类发生变化时，子类实现也不得不跟着变化，削弱了子类的独立性</strong></p> 
<h2 id="%E5%9B%9B.%E5%88%9D%E8%AF%86%E5%A4%9A%E6%80%81%EF%BC%9A">四.初识多态：</h2> 
<h3 id="4.1%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9A">4.1<span style="color:#333333;">多态的概念：</span></h3> 
<p><span style="color:#333333;">通俗来说，就是多种形态，<strong>具体点就是去完成某个行为，当不同的对象去完成时会产生出不同的状</strong></span><span style="color:#333333;"><strong>态。🧐🧐🧐🧐</strong></span></p> 
<p>举例来说就是我们日常生活中的打印机，分为黑白打印和彩印，完成打印这个行为，黑白打印机和彩印机所展现的打印状态完全不同。或则上面的猫狗完成吃东西这个行为，不同的动物也会导致吃东西的状态不同。</p> 
<h3 id="4.2%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6%EF%BC%9A" style="background-color:transparent;">4.2多态的实现条件：</h3> 
<div> 
 <span style="color:#333333;">在</span> 
 <span style="color:#333333;">java</span> 
 <span style="color:#333333;">中要实现多态，必须要满足如下几个条件，缺一不可：</span> 
</div> 
<div> 
 <blockquote> 
  <div> 
   <span style="color:#333333;">1. </span> 
   <span style="color:#333333;"><strong><span style="background-color:#ffd900;">必须在继承体系下 </span></strong></span> 
  </div> 
  <div> 
   <span style="color:#333333;">2.<span style="background-color:#ffd900;"> </span></span> 
   <span style="color:#333333;"><strong><span style="background-color:#ffd900;">子类必须要对父类中方法进行重写 </span></strong></span> 
  </div> 
  <div> 
   <span style="color:#333333;">3.<span style="background-color:#ffd900;"> </span></span> 
   <span style="color:#333333;"><strong><span style="background-color:#ffd900;">通过父类的引用调用重写的方法</span></strong></span> 
  </div> 
 </blockquote> 
 <div>
   4.2.1那么什么是重写？😺 
  <div> 
   <span style="color:#333333;">重写</span> 
   <span style="color:#333333;">(override)</span> 
   <span style="color:#333333;">：也称为覆盖。重写是子类对父类非静态、非</span> 
   <span style="color:#333333;">private</span> 
   <span style="color:#333333;">修饰，非</span> 
   <span style="color:#333333;">final</span> 
   <span style="color:#333333;">修饰，非构造方法等的实现过程 进行重新编写, </span> 
   <span style="color:#333333;"><strong><span style="background-color:#ffd900;">返回值和形参都不能改变</span></strong></span> 
   <span style="color:#333333;"><span style="background-color:#ffd900;">。</span></span> 
   <span style="color:#333333;"><strong><span style="background-color:#ffd900;">即外壳不变，核心重写</span>！</strong></span> 
   <span style="color:#333333;">重写的好处在于子类可以根据需要，定义特定于自己的行为。也就是说子类能够根据需要实现父类的方法。</span> 
  </div> 
  <div>
    简单总结重写就是： 
  </div> 
  <blockquote> 
   <div> 
    <strong>1.方法名相同</strong> 
   </div> 
   <div> 
    <strong>2.方法的参数列表相同（个数，顺序，类型）</strong> 
   </div> 
   <div> 
    <strong>3.方法的返回值类型相同</strong> 
   </div> 
  </blockquote> 
  <div>
    4.2.2那什么是向上转型？ 
  </div> 
  <div> 
   <div> 
    <span style="color:#333333;">向上转型：实际就是创建一个子类对象，将其当成父类对象来使用</span> 
   </div> 
   <div> 
    <div> 
     <span style="color:#333333;">语法格式：父类类型 对象名</span> 
     <span style="color:#333333;"> = new </span> 
     <span style="color:#333333;">子类类型</span> 
     <span style="color:#333333;">()</span> 
    </div> 
    <div> 
     <img alt="" height="85" src="https://images2.imgbox.com/21/08/81VA7Y4O_o.png" width="682"> 
    </div> 
    <div> 
     <div> 
      <span style="color:#333333;">animal</span> 
      <span style="color:#333333;">是父类类型，但可以引用一个子类对象，因为是从小范围向大范围的转换。</span> 
     </div> 
     <div> 
      <img alt="" height="852" src="https://images2.imgbox.com/5f/c8/oeqm3E9o_o.png" width="1200"> 
     </div> 
     <div>
       实现多态的代码： 
     </div> 
     <div> 
      <pre><code class="language-java">class Shape {

    public void draw() {
        System.out.println("画图形！");
    }
}

class Rect extends Shape {
    @Override
    public void draw() {
        System.out.println("画一个矩形！");//重写父类方法
    }
}
class Cycle extends Shape{
    @Override
    public void draw() {
        System.out.println("画一个圆圈！");
    }
}

class Triangle extends Shape {
    @Override
    public void draw() {
        System.out.println("画一个三角形！");
    }
}

class Flower extends Shape {
    @Override
    public void draw() {
        System.out.println("画一朵花！");
    }
}

public class Test1 {

    public static void drawMaps1() {
        Rect rect = new Rect();
        Shape shapeCycle = new Cycle();//通过父类的引用调用重写的方法-》向上转型
        Triangle triangle = new Triangle();
        Flower flower = new Flower();
         
        Shape[] shapes = {shapeCycle,rect,rect,//通过父类的引用调用重写的方法-》向上转型
                shapeCycle,triangle,flower};
        for(Shape shape : shapes) {
            shape.draw();//调用同一个方法，不同的对象会有不同的结果
        }
    }
    //测试方法
    public static void main(String[] args) {
        drawMaps1();
    }
}
</code></pre> 
      <p>运行结果（这里调用了同一个方法，但是不同的对象会产生不同的结果）：</p> 
      <p><img alt="" height="386" src="https://images2.imgbox.com/6c/73/2d6Mf54U_o.png" width="1200"></p> 
      <p>小结：</p> 
      <blockquote> 
       <p>1，多态是<strong>方法的多态</strong>，不是属性的多态（多态和属性无关）</p> 
       <p>2，多态的存在要有3个必要的条件：<strong>继承 | 接口的实现</strong>，<strong>方法重写</strong>，<strong>父类引用指向子类对象。</strong></p> 
       <p>3，父类引用指向子类对象后，<strong>用该父类引用调用子类重写的方法（ 父类类型 引用名 = new 子类类型（）； ）</strong>，此时多态就出现了。</p> 
      </blockquote> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</div> 
<p><strong>结语：</strong> <strong>写博客不仅仅是为了分享学习经历，同时这也有利于我巩固自己的知识点，总结该知识点，由于作者水平有限，对文章有任何问题的还请指出，接受大家的批评，让我改进。同时也希望读者们不吝啬你们的点赞+收藏+关注，你们的鼓励是我创作的最大动力！</strong></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/58/db/WJBfTF1Q_o.jpg"></strong></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/893dc15f48834e627eec80de210df9a2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">此应用与最新版Android不兼容。请检查是否有更新，或与应用开发者联系。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1d5340d114fad4f3d2ddd61dc717981e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux 安装 MySQL【CentOS】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>