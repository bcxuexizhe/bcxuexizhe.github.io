<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【高阶数据结构(三)】图的遍历&amp;最小生成树问题 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/715ef15cea32c8beeeb38e749d64e5c0/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【高阶数据结构(三)】图的遍历&amp;最小生成树问题">
  <meta property="og:description" content="💓博主CSDN主页:杭电码农-NEO💓
⏩专栏分类:高阶数据结构专栏⏪
🚚代码仓库:NEO的学习日记🚚
🌹关注我🫵带你学习更多Go语言知识
🔝🔝
高阶数据结构 1. 前言2. 图的遍历3. 图的广度优先遍历4. 图的深度优先遍历5. 图的最小生成树6. Kruskal算法讲解7. prim算法讲解8. 总结以及拓展 1. 前言 如果你还不知道什么是图论,以及关于图的存储结构和一些专有名词, 请先阅读这篇文章: 初识图论.
本章重点:
本篇文章着重讲解图的两种遍历方式: 深度优先遍历和广度优先遍历. 并会模拟实现这两种遍历方法. 其次,会讲解关于图的最小生成树的概念,以及关于最小生成树的两个算法: Kruskal算法和Prim算法
2. 图的遍历 给定一个图G和其中任意一个顶点v0，从v0出发，沿着图中各边访问图中的所有顶点，且每个顶点仅被遍历一次。
这道面试题就是典型的图论的遍历
3. 图的广度优先遍历 正如其名, 广度优先遍历就是先遍历完一个顶点的所有相邻顶点
比如现在要找东西，假设有三个抽屉，东西在那个抽屉不清楚，现在要将其找到，广度优先遍历的做法是:
先将三个抽屉打开，在最外层找一遍将每个抽屉中红色的盒子打开，再找一遍将红色盒子中绿色盒子打开，再找一遍直到找完所有的盒子 注意:每个盒子只能找一次，不能重复找
具体到一个图中就是这样的:
广度优先遍历看似很简单, 对于顶点A来说, 先走B,C,D. 然后再看B顶点, 走A,C,E, 但是A和C已经走过了,所以不能再此将它们算进去. 做法很简单, 使用一个队列和一个数组, 数组用来存储一个顶点是否已经入过队列了. 对于队列而言, 它的功能相信我不说大家也能明白: 最开始只有A在队列中, A出队, BCD入队, B出队, AC不用入队, 只入E. C出队…
话不多说,直接上代码:
void BFS(const V&amp; src) //图的广度优先遍历 { size_t srci = _index[src];//找到值src对应在数组中的下标 queue&lt;int&gt; q; vector&lt;bool&gt; check(_vertex.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-13T09:15:00+08:00">
    <meta property="article:modified_time" content="2024-05-13T09:15:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【高阶数据结构(三)】图的遍历&amp;最小生成树问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>💓博主CSDN主页:<a href="https://blog.csdn.net/m0_61982936?spm=1000.2115.3001.5343">杭电码农-NEO</a>💓<br>   <br> ⏩专栏分类:<a href="https://blog.csdn.net/m0_61982936/category_12660316.html?spm=1001.2014.3001.5482">高阶数据结构专栏</a>⏪<br>   <br> 🚚代码仓库:<a href="https://gitee.com/NEO_kou" rel="nofollow">NEO的学习日记</a>🚚<br>   <br> 🌹关注我🫵带你学习更多Go语言知识<br>   🔝🔝</p> 
</blockquote> 
<hr> 
<p><img src="https://images2.imgbox.com/96/89/WGOtzpcx_o.gif" alt="在这里插入图片描述"></p> 
<p></p> 
<div class="toc"> 
 <h4>高阶数据结构</h4> 
 <ul><li><a href="#1__15" rel="nofollow">1. 前言</a></li><li><a href="#2__23" rel="nofollow">2. 图的遍历</a></li><li><a href="#3__32" rel="nofollow">3. 图的广度优先遍历</a></li><li><a href="#4__84" rel="nofollow">4. 图的深度优先遍历</a></li><li><a href="#5__122" rel="nofollow">5. 图的最小生成树</a></li><li><a href="#6_Kruskal_137" rel="nofollow">6. Kruskal算法讲解</a></li><li><a href="#7_prim_201" rel="nofollow">7. prim算法讲解</a></li><li><a href="#8__257" rel="nofollow">8. 总结以及拓展</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1__15"></a>1. 前言</h2> 
<p>如果你还不知道什么是图论,以及关于图的存储结构和一些专有名词, 请先阅读这篇文章: <a href="https://blog.csdn.net/m0_61982936/article/details/138448683?spm=1001.2014.3001.5501">初识图论</a>.</p> 
<p><mark>本章重点:</mark></p> 
<blockquote> 
 <p><font color="purple"><strong>本篇文章着重讲解图的两种遍历方式: 深度优先遍历和广度优先遍历. 并会模拟实现这两种遍历方法. 其次,会讲解关于图的最小生成树的概念,以及关于最小生成树的两个算法: Kruskal算法和Prim算法</strong></font></p> 
</blockquote> 
<hr> 
<h2><a id="2__23"></a>2. 图的遍历</h2> 
<p>给定一个图G和其中任意一个顶点v0，从v0出发，沿着图中各边访问图中的所有顶点，且每个顶点仅被遍历一次。</p> 
<p><img src="https://images2.imgbox.com/8d/8d/WTA9VHnn_o.png" alt="在这里插入图片描述"></p> 
<p>这道面试题就是典型的图论的遍历</p> 
<hr> 
<h2><a id="3__32"></a>3. 图的广度优先遍历</h2> 
<p>正如其名, 广度优先遍历就是先遍历完一个顶点的所有相邻顶点</p> 
<p><img src="https://images2.imgbox.com/59/da/qg8UhAlL_o.png" alt="在这里插入图片描述"></p> 
<p>比如现在要找东西，假设有三个抽屉，东西在那个抽屉不清楚，现在要将其找到，广度优先遍历的做法是:</p> 
<ol><li>先将三个抽屉打开，在最外层找一遍</li><li>将每个抽屉中红色的盒子打开，再找一遍</li><li>将红色盒子中绿色盒子打开，再找一遍直到找完所有的盒子</li></ol> 
<p>注意:每个盒子只能找一次，不能重复找</p> 
<p><mark>具体到一个图中就是这样的:</mark></p> 
<p><img src="https://images2.imgbox.com/ee/9b/9OKCjVj1_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><font color="orange"><strong>广度优先遍历看似很简单, 对于顶点A来说, 先走B,C,D. 然后再看B顶点, 走A,C,E, 但是A和C已经走过了,所以不能再此将它们算进去. 做法很简单, 使用一个队列和一个数组, 数组用来存储一个顶点是否已经入过队列了. 对于队列而言, 它的功能相信我不说大家也能明白: 最开始只有A在队列中, A出队, BCD入队, B出队, AC不用入队, 只入E. C出队…</strong></font></p> 
</blockquote> 
<p><strong><code>话不多说,直接上代码:</code></strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">BFS</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> src<span class="token punctuation">)</span> <span class="token comment">//图的广度优先遍历</span>
<span class="token punctuation">{<!-- --></span>
	size_t srci <span class="token operator">=</span> _index<span class="token punctuation">[</span>src<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//找到值src对应在数组中的下标</span>
	queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> q<span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">check</span><span class="token punctuation">(</span>_vertex<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//用来标记哪些元素已经入过队列了</span>
	q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>srci<span class="token punctuation">)</span><span class="token punctuation">;</span>
	check<span class="token punctuation">[</span>srci<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> front <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> front <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> _vertex<span class="token punctuation">[</span>front<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//把这个顶点的朋友带入队列,并更新check数组</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> _vertex<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//_edge[front][i]代表front-&gt;i是否有边,数组值不等于MAX_W就代表它们之间直接相连</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_edge<span class="token punctuation">[</span>front<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> MAX_W <span class="token operator">&amp;&amp;</span> check<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				check<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
				q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>注意,此函数是在graph类中实现的成员函数, 其中使用到了成员变量</p> 
<hr> 
<h2><a id="4__84"></a>4. 图的深度优先遍历</h2> 
<p>正如其名, 深度优先遍历就是先一条路走到底</p> 
<p><img src="https://images2.imgbox.com/4b/af/pBnL7zTq_o.png" alt="在这里插入图片描述"><br> 比如现在要找东西，假设有三个抽屉，东西在那个抽屉不清楚，现在要将其找到，广度优先遍历的做法是:</p> 
<ol><li>先将第一个抽屉打开，在最外层找一遍</li><li>将第一个抽屉中红盒子打开，在红盒子中找一遍</li><li>将红盒子中绿盒子打开，在绿盒子中找一遍</li><li>递归查找剩余的两个盒子</li></ol> 
<p>深度优先遍历:将一个抽屉一次性遍历完(包括该抽屉中包含的小盒子)，再去递归遍历其他盒子</p> 
<p><mark>具体到一个图中就是这样:</mark></p> 
<p><img src="https://images2.imgbox.com/d4/5c/5ldFaScD_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><font color="gree"><strong>如果之前学习过递归,回溯算法的同学,相信深度优先遍历对你来说也不是什么难题, 下面就直接上手写代码了!</strong></font></p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> src<span class="token punctuation">)</span><span class="token comment">//图的深度优先遍历</span>
<span class="token punctuation">{<!-- --></span>
	size_t srci <span class="token operator">=</span> _index<span class="token punctuation">[</span>src<span class="token punctuation">]</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">check</span><span class="token punctuation">(</span>_vertex<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">_DFS</span><span class="token punctuation">(</span>srci<span class="token punctuation">,</span> check<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">_DFS</span><span class="token punctuation">(</span>size_t srci<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> check<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> srci <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> _vertex<span class="token punctuation">[</span>srci<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	check<span class="token punctuation">[</span>srci<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> _vertex<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//遍历与此点相邻的所有点</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_edge<span class="token punctuation">[</span>srci<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> MAX_W <span class="token operator">&amp;&amp;</span> check<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
			<span class="token function">_DFS</span><span class="token punctuation">(</span>_vertex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> check<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h2><a id="5__122"></a>5. 图的最小生成树</h2> 
<p>若连通图由n个顶点组成，则其生成树必含n个顶点和n-1条边。因此构造最小生成树的准则有三条：</p> 
<ol><li><strong>只能使用图中的边来构造最小生成树</strong></li><li><strong>只能使用恰好n-1条边来连接图中的n个顶点</strong></li><li><strong>选用的n-1条边不能构成回路</strong></li></ol> 
<p><strong><code>最小生成树其实就是子图是最简单的连通图, n-1条边刚好可以连接n个顶点</code></strong></p> 
<p><img src="https://images2.imgbox.com/de/24/n5RTVTQk_o.png" alt="一个图"></p> 
<p>每一个图的最小生成树是不唯一的. 一般通过<a href="https://zh.wikipedia.org/wiki/%E5%85%8B%E9%B2%81%E6%96%AF%E5%85%8B%E5%B0%94%E6%BC%94%E7%AE%97%E6%B3%95" rel="nofollow">Kruskal算法</a>和<a href="https://zh.wikipedia.org/wiki/%E6%99%AE%E6%9E%97%E5%A7%86%E7%AE%97%E6%B3%95" rel="nofollow">prim算法</a>来构造最小生成树</p> 
<hr> 
<h2><a id="6_Kruskal_137"></a>6. Kruskal算法讲解</h2> 
<p>首先构造一个由这n个顶点组成、不含任何边的图G={V,NULL}，其中每个顶点自成一个连通分量，其次不断从E中取出权值最小的一条边(若有多条任取其一)，若该边的两个顶点来自不同的连通分量，则将此边加入到G中。如此重复，直到所有顶点在同一个连通分量上为止。</p> 
<p>核心：每次迭代时，选出一条具有最小权值，且两端点不在同一连通分量上的边，加入生成树</p> 
<p><img src="https://images2.imgbox.com/03/2a/p3vqHrBT_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><font color="purple"><strong>克鲁斯卡尔算法的核心就是每次都找最小的权值边, 只要这次选的边没有构成环, 就接着往下走. 比如此图中先选1,再选2,再选2,再选4,依次向后选. 可是问题是, 我怎么知道我选出来的边是否成环了. 这里就需要使用到之前的数据结构: 并查集. 即如果一条边关联的两个点在同一集合, 那么他们就成环了, 反之则不成环. 还有一点, 怎样知道图中哪条边的权值最小? 这里可以使用优先级队列</strong></font></p> 
</blockquote> 
<p><mark>代码案例:</mark></p> 
<pre><code class="prism language-cpp"><span class="token keyword">typedef</span> Graph<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> W<span class="token punctuation">,</span> MAX_W<span class="token punctuation">,</span> Direction<span class="token operator">&gt;</span> Self<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">EDGE</span> <span class="token comment">//仿函数用于优先级队列</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> _srci<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _desti<span class="token punctuation">;</span>
	W _w<span class="token punctuation">;</span>
	<span class="token function">EDGE</span><span class="token punctuation">(</span><span class="token keyword">int</span> srci<span class="token punctuation">,</span> <span class="token keyword">int</span> desti<span class="token punctuation">,</span> W w<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">_srci</span><span class="token punctuation">(</span>srci<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_desti</span><span class="token punctuation">(</span>desti<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_w</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> EDGE<span class="token operator">&amp;</span> e<span class="token punctuation">)</span> <span class="token keyword">const</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _w <span class="token operator">&gt;</span> e<span class="token punctuation">.</span>_w<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
W <span class="token function">Kruskal</span><span class="token punctuation">(</span>Self<span class="token operator">&amp;</span> mintree<span class="token punctuation">)</span><span class="token comment">克鲁斯卡尔算法,返回权重总和</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> _vertex<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	mintree<span class="token punctuation">.</span>_vertex <span class="token operator">=</span> _vertex<span class="token punctuation">;</span><span class="token comment">//最开始传入的最小生成树是没有初始化的,没有点和边的关系,若直接使用add会报错</span>
	mintree<span class="token punctuation">.</span>_edge<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	mintree<span class="token punctuation">.</span>_index <span class="token operator">=</span> _index<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		mintree<span class="token punctuation">.</span>_edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> MAX_W<span class="token punctuation">)</span><span class="token punctuation">;</span>
	priority_queue<span class="token operator">&lt;</span>EDGE<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>EDGE<span class="token operator">&gt;</span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span>EDGE<span class="token operator">&gt;&gt;</span> minqueue<span class="token punctuation">;</span><span class="token comment">//利用优先级队列来存储边的权重大小</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> _edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> MAX_W<span class="token punctuation">)</span><span class="token comment">//i&lt;j,只用走一半,不然如果是有向图,可能会重复插入边</span>
				minqueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">EDGE</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> _edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将所有的边都插入优先级队列</span>
	<span class="token keyword">int</span> minsize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//选出n-1条边</span>
	UnionFindSet <span class="token function">ufs</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//利用并查集来判断生成树中是否有环</span>
	W totalvalue <span class="token operator">=</span> <span class="token function">W</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//最后的返回结果</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>minqueue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		EDGE min <span class="token operator">=</span> minqueue<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		minqueue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ufs<span class="token punctuation">.</span><span class="token function">SameSet</span><span class="token punctuation">(</span>min<span class="token punctuation">.</span>_srci<span class="token punctuation">,</span> min<span class="token punctuation">.</span>_desti<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//如果这条边关联的两个点不在一个集合,再继续下面的操作</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> _vertex<span class="token punctuation">[</span>min<span class="token punctuation">.</span>_srci<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"-&gt;"</span> <span class="token operator">&lt;&lt;</span> _vertex<span class="token punctuation">[</span>min<span class="token punctuation">.</span>_desti<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> min<span class="token punctuation">.</span>_w <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			mintree<span class="token punctuation">.</span><span class="token function">_AddEdge</span><span class="token punctuation">(</span>min<span class="token punctuation">.</span>_srci<span class="token punctuation">,</span> min<span class="token punctuation">.</span>_desti<span class="token punctuation">,</span> min<span class="token punctuation">.</span>_w<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//增加一条边</span>
			ufs<span class="token punctuation">.</span><span class="token function">Union</span><span class="token punctuation">(</span>min<span class="token punctuation">.</span>_srci<span class="token punctuation">,</span> min<span class="token punctuation">.</span>_desti<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将这条边的两个顶点加入同一集合</span>
			minsize<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//边数一直要到n-1</span>
			totalvalue <span class="token operator">+=</span> min<span class="token punctuation">.</span>_w<span class="token punctuation">;</span><span class="token comment">//最后的结果也需要更新</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>minsize <span class="token operator">==</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> totalvalue<span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token function">W</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p><strong>可能大家是第一次见这样写函数, 传入一个空的图, 由于图论的复杂性和算法的特别,所以使用这种方式已经是很优解了,关于代码的解释都在注释中,若还有不懂,欢迎私信</strong></p> 
</blockquote> 
<hr> 
<h2><a id="7_prim_201"></a>7. prim算法讲解</h2> 
<p>prim算法的思想是,既然最小生成树包含所有的顶点. 所以我可以从任意顶点开始, 一直沿着此点向外做拓展,直到覆盖了图中所有的顶点. 算法每一步在连接集合A和A之外的结点的边中, 选择一条权值最小的加入A集合, 下图是步骤图,可以参考一下:</p> 
<p><img src="https://images2.imgbox.com/15/ca/2dmOT8LW_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><font color="orange"><strong>可以看见算法的每一步都在选择,当前集合A中的边的最小值,并且不会走让图成环的路径. 这个算法的实现呢,首先我们需要两个集合, A:已被选择过的点. B: 未被选择过的点. 要做的就是在已被选择的点中找权值最小,且还没选择过的点的边. 这里需要利用优先级队列,将与A集合中顶点相连的边都加入优先级队列中. 在添加边关系前,只需要判断这条边的两个顶点是否都在A集合, 如果都在,相连后就会成环. 需要pop掉这条边</strong></font></p> 
</blockquote> 
<p><mark>直接上代码:</mark></p> 
<pre><code class="prism language-cpp">W <span class="token function">Prim</span><span class="token punctuation">(</span>Self<span class="token operator">&amp;</span> mintree<span class="token punctuation">,</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> src<span class="token punctuation">)</span><span class="token comment">//普里姆算法,返回权重总和</span>
<span class="token punctuation">{<!-- --></span>
	size_t srci <span class="token operator">=</span> <span class="token function">GetIndex</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//找到最初点的下标</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> _vertex<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	mintree<span class="token punctuation">.</span>_vertex <span class="token operator">=</span> _vertex<span class="token punctuation">;</span><span class="token comment">//最开始传入的最小生成树是没有初始化的,没有点和边的关系,若直接使用add会报错</span>
	mintree<span class="token punctuation">.</span>_edge<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	mintree<span class="token punctuation">.</span>_index <span class="token operator">=</span> _index<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		mintree<span class="token punctuation">.</span>_edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> MAX_W<span class="token punctuation">)</span><span class="token punctuation">;</span>
	unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> x<span class="token punctuation">;</span><span class="token comment">//已被选过的顶点集合</span>
	unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> y<span class="token punctuation">;</span><span class="token comment">//未被选过的顶点集合</span>
	x<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>srci<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> srci<span class="token punctuation">)</span>
			y<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//从X集合中找到权值最小,并且在Y集合中的边</span>
	priority_queue<span class="token operator">&lt;</span>EDGE<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>EDGE<span class="token operator">&gt;</span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span>EDGE<span class="token operator">&gt;&gt;</span> minqueue<span class="token punctuation">;</span><span class="token comment">//利用优先级队列,将与X集合中相关联的边都放入优先级队列,在添加边时只需要判断这条边的两个顶点是否都在X集合,若都在X集合,添加后会形成环,不可取</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_edge<span class="token punctuation">[</span>srci<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> MAX_W<span class="token punctuation">)</span>
			minqueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">EDGE</span><span class="token punctuation">(</span>srci<span class="token punctuation">,</span> i<span class="token punctuation">,</span> _edge<span class="token punctuation">[</span>srci<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先把srci连接的边添加到队列当中</span>
	W totalvalue <span class="token operator">=</span> <span class="token function">W</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>minqueue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>minqueue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> x<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>minqueue<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>_srci<span class="token punctuation">)</span> <span class="token operator">!=</span> x<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> x<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>minqueue<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>_desti<span class="token punctuation">)</span> <span class="token operator">!=</span> x<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//把不符合要求的边给去掉</span>
			minqueue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		EDGE min <span class="token operator">=</span> minqueue<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		minqueue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		mintree<span class="token punctuation">.</span><span class="token function">_AddEdge</span><span class="token punctuation">(</span>min<span class="token punctuation">.</span>_srci<span class="token punctuation">,</span> min<span class="token punctuation">.</span>_desti<span class="token punctuation">,</span> min<span class="token punctuation">.</span>_w<span class="token punctuation">)</span><span class="token punctuation">;</span>
		size<span class="token operator">++</span><span class="token punctuation">;</span>
		x<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>min<span class="token punctuation">.</span>_desti<span class="token punctuation">)</span><span class="token punctuation">;</span>
		y<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>min<span class="token punctuation">.</span>_desti<span class="token punctuation">)</span><span class="token punctuation">;</span>
		totalvalue <span class="token operator">+=</span> min<span class="token punctuation">.</span>_w<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> x<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> _edge<span class="token punctuation">[</span>min<span class="token punctuation">.</span>_desti<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> MAX_W<span class="token punctuation">)</span>
				minqueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">EDGE</span><span class="token punctuation">(</span>min<span class="token punctuation">.</span>_desti<span class="token punctuation">,</span> i<span class="token punctuation">,</span> _edge<span class="token punctuation">[</span>min<span class="token punctuation">.</span>_desti<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将与dest连接的所有的边都添加到优先级队列</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> totalvalue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>若有不懂,欢迎私信</code></p> 
<hr> 
<h2><a id="8__257"></a>8. 总结以及拓展</h2> 
<p>关于图的最小生成树的两个算法其实都是使用的贪心策略,用局部最优找到全局最优. 但是关于这两个算法的正确性的验证这里由于篇幅有限就不多讲解了</p> 
<hr> 
<center>
  🔎 
 <font color="#4b0080"> 下期预告:最短路径问题 </font>🔍 
</center>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2e96e22a1585929ee6682d55a42d3220/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">高校普法|基于SSM＋vue的高校普法系统的设计与实现(源码&#43;数据库&#43;文档)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5089fd683ac3fe1866cf760627f75b31/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">限流算法(令牌桶&amp;漏桶&amp;计数器)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>