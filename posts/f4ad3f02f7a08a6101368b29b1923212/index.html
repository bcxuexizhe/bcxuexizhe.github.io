<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】链表经典OJ题目练习（2） - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/f4ad3f02f7a08a6101368b29b1923212/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【数据结构】链表经典OJ题目练习（2）">
  <meta property="og:description" content="面试题 02.02. 返回倒数第 k 个节点 - 力扣（LeetCode） 思路1：先计算出链表的长度，在将链表中的值存在数组中，在返回第k个节点。
思路2：利用快慢指针，先让快指针走k步，在让快慢指针分别同时走，当快指针走到空的时候，慢指针就是倒数第k个节点。
链表的回文结构_牛客题霸_牛客网 (nowcoder.com) 思路：先使用快慢指针找到来链表的中间节点，在将中间节点之后的链表倒置（注意倒置之后，中间链表的前一个节点依然指向尾结点），最后遍历链表，判断链表是否是回文结构。
160. 相交链表 - 力扣（LeetCode） 思路：先分别计算出两个链表的长度，算出它们长度之间的差值deference，再让长度较长的链表先走deference步，这样两个链表的长度就会相等，再进行遍历链表，找出相交点（注意，在寻找相交点的时候要找节点的地址，不能找节点的val值）。
141. 环形链表 - 力扣（LeetCode） 思路：使用快慢指针，如果fast或者fast-&gt;next为空的话说明链表不是一个环形链表，如果fast节点等于slow节点的话，说明fast追上了slow节点（fast一定会追上slow节点，这个结论会在下文解释到），也就说明了链表会进入一个环形的链表。
环形链表的几种情况：
那么，我们就要提出几个问题：
1.为什么一定会相遇，有没有可能错过，永远也追不上？
2.fast节点走3步，4步，或者n步是否可以与slow指针相遇？
先来解答第一个问题：
假设slow进入环的时候slow与fast节点的距离为N，fast节点每次走两步，slow节点每次走一步，所以每当slow节点走一步的时候，快慢指针之间的距离就会缩小1，直到它们之间的距离变为0.
slow走的步数 fast与slow之间的距离
0 N
1 N-1
2 N-2
…… ……
x 0
第二个问题：
我们先来观察slow节点每次走1步和fast节点每次走3步时候的情况
这时候，我们需要分两种情况来分析两个指针：
a.当slow节点进入环的时候，快慢指针之间的距离N是一个偶数
b.当slow节点进入环的时候，快慢指针之间的距离N是一个奇数
slow走的步数 快慢指针之间的距离(N为偶数) 快慢指针之间的距离(N为奇数)
0 N N
1 N-2 N-2
2 N-4 N-4
…… …… ……
x-1 2 1
x 0 -1
在这里，我们发现快慢指针之间的距离N是一个奇数时，fast与slow会错过，永远也不会相遇。
但是，先别急，这个结论真的正确吗？或者我们说快慢指针之间的距离N有可能是一个奇数吗？这就需要我们再次证明一下：
我们分析一下追上与追不上的情况：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-07T22:49:36+08:00">
    <meta property="article:modified_time" content="2024-05-07T22:49:36+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】链表经典OJ题目练习（2）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2></h2> 
<h2><a href="https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/submissions/528982848/" rel="nofollow" title="面试题 02.02. 返回倒数第 k 个节点 - 力扣（LeetCode）">面试题 02.02. 返回倒数第 k 个节点 - 力扣（LeetCode）</a></h2> 
<p>思路1：先计算出链表的长度，在将链表中的值存在数组中，在返回第k个节点。</p> 
<p><img alt="" height="538" src="https://images2.imgbox.com/0c/2c/hUBWADvx_o.png" width="890"></p> 
<p>思路2：利用快慢指针，先让快指针走k步，在让快慢指针分别同时走，当快指针走到空的时候，慢指针就是倒数第k个节点。</p> 
<p><img alt="" height="338" src="https://images2.imgbox.com/30/b0/0aEE0HKJ_o.png" width="893"></p> 
<h2><a href="https://www.nowcoder.com/practice/d281619e4b3e4a60a2cc66ea32855bfa?tpId=49&amp;&amp;tqId=29370&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/2016test/question-ranking" rel="nofollow" title="链表的回文结构_牛客题霸_牛客网 (nowcoder.com)">链表的回文结构_牛客题霸_牛客网 (nowcoder.com)</a></h2> 
<p>思路：先使用快慢指针找到来链表的中间节点，在将中间节点之后的链表倒置（注意倒置之后，中间链表的前一个节点依然指向尾结点），最后遍历链表，判断链表是否是回文结构。</p> 
<p><img alt="" height="479" src="https://images2.imgbox.com/65/cc/2o8MDnKa_o.png" width="458"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/f5/7d/Jx6OuUcd_o.png" width="820"></p> 
<p></p> 
<h2><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/" rel="nofollow" title="160. 相交链表 - 力扣（LeetCode）">160. 相交链表 - 力扣（LeetCode）</a></h2> 
<p>思路：先分别计算出两个链表的长度，算出它们长度之间的差值deference，再让长度较长的链表先走deference步，这样两个链表的长度就会相等，再进行遍历链表，找出相交点（注意，在寻找相交点的时候要找节点的地址，不能找节点的val值）。</p> 
<p><img alt="" height="172" src="https://images2.imgbox.com/50/96/ALcnJT0O_o.png" width="480"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/19/6d/lSyatLD3_o.png" width="885"></p> 
<h2><a href="https://leetcode.cn/problems/linked-list-cycle/description/" rel="nofollow" title="141. 环形链表 - 力扣（LeetCode）">141. 环形链表 - 力扣（LeetCode）</a></h2> 
<p>思路：使用快慢指针，如果fast或者fast-&gt;next为空的话说明链表不是一个环形链表，如果fast节点等于slow节点的话，说明fast追上了slow节点（fast一定会追上slow节点，这个结论会在下文解释到），也就说明了链表会进入一个环形的链表。</p> 
<p><img alt="" height="335" src="https://images2.imgbox.com/63/12/Q77zCjZN_o.png" width="888"></p> 
<p>环形链表的几种情况：</p> 
<p><img alt="" height="403" src="https://images2.imgbox.com/b4/44/os2DWux0_o.png" width="525"></p> 
<p>那么，我们就要提出几个问题：</p> 
<p>1.为什么一定会相遇，有没有可能错过，永远也追不上？</p> 
<p>2.fast节点走3步，4步，或者n步是否可以与slow指针相遇？</p> 
<p>先来解答第一个问题：</p> 
<p><img alt="" height="223" src="https://images2.imgbox.com/15/98/rUAwvuaR_o.png" width="441"></p> 
<p>假设slow进入环的时候slow与fast节点的距离为N，fast节点每次走两步，slow节点每次走一步，所以每当slow节点走一步的时候，快慢指针之间的距离就会缩小1，直到它们之间的距离变为0.</p> 
<blockquote> 
 <p>slow走的步数                  fast与slow之间的距离</p> 
 <p>0                                      N</p> 
 <p>1                                      N-1</p> 
 <p>2                                      N-2</p> 
 <p>……                                 ……</p> 
 <p>x                                      0</p> 
</blockquote> 
<p>第二个问题：</p> 
<p>我们先来观察slow节点每次走1步和fast节点每次走3步时候的情况</p> 
<p>这时候，我们需要分两种情况来分析两个指针：</p> 
<p>a.当slow节点进入环的时候，快慢指针之间的距离N是一个偶数</p> 
<p>b.当slow节点进入环的时候，快慢指针之间的距离N是一个奇数</p> 
<blockquote> 
 <p>slow走的步数         快慢指针之间的距离(N为偶数)       快慢指针之间的距离(N为奇数)</p> 
 <p>0                             N                                                     N</p> 
 <p>1                             N-2                                                  N-2</p> 
 <p>2                             N-4                                                  N-4</p> 
 <p>……                        ……                                                ……</p> 
 <p>x-1                          2                                                      1</p> 
 <p>x                             0                                                       -1</p> 
</blockquote> 
<p>在这里，我们发现快慢指针之间的距离N是一个奇数时，fast与slow会错过，永远也不会相遇。</p> 
<p>但是，先别急，这个结论真的正确吗？或者我们说快慢指针之间的距离N有可能是一个奇数吗？这就需要我们再次证明一下：</p> 
<p>我们分析一下追上与追不上的情况：</p> 
<blockquote> 
 <p>1.N是偶数，第一轮就可以追上</p> 
 <p>2.N是奇数，第一轮追击就会错过，距离变成C-1</p> 
 <p>    a.如果C-1是偶数，下一轮就追上了</p> 
 <p>    b.如果C-1是奇数，那么就永远也追不上了</p> 
</blockquote> 
<p>综上所述：同时存在N是奇数并且C是偶数，那么就永远也追不上了，我们接下来探讨的就是是否存在这种情况。</p> 
<p>假设在slow节点进环时，slow节点走的长度为L ，fast节点走的距离为L+x*N+C-N,  整个环的长度为C。</p> 
<p><img alt="" height="206" src="https://images2.imgbox.com/94/b9/XJ1duwWV_o.png" width="438"></p> 
<p>在slow节点进环时，fast与slow节点分别走过的距离为：</p> 
<blockquote> 
 <p><span style="background-color:#fe2c24;"><span style="color:#0d0016;">fast：L+x*N+C-N</span></span><span style="color:#0d0016;"><span style="background-color:#ffd900;">  (x为快指针绕环走的圈数)</span></span></p> 
 <p><span style="background-color:#fe2c24;"><span style="color:#0d0016;">slow：L</span></span></p> 
</blockquote> 
<p><span style="color:#0d0016;">接下来，因为fast节点走过的距离是slow节点走过的距离的3倍，所以我们会得到一个等式：</span></p> 
<blockquote> 
 <p><span style="background-color:#fe2c24;">    3*L=L+x*C+C-N</span></p> 
 <p><span style="background-color:#fe2c24;">→2*L=x*C+C-N</span></p> 
 <p><span style="background-color:#fe2c24;">→2*L=(x+1)*C-N</span></p> 
</blockquote> 
<p>等式的左边一定是一个偶数，右边如果N是一个奇数，那么C一定也是一个奇数；右边如果是一个偶数，那么C一定也是一个偶数。所以就不会存在N是奇数并且C是偶数的情况。所以fast节点每次走3步的情况下，就不存在fast节点追不上slow节点的情况。</p> 
<p>按这种方法证明其他fast节点走n步的情况，依然可以证明出fast节点一定可以追上slow节点的结论。</p> 
<h2><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/" rel="nofollow" title="142. 环形链表 II - 力扣（LeetCode）">142. 环形链表 II - 力扣（LeetCode）</a></h2> 
<p><img alt="" height="148" src="https://images2.imgbox.com/81/fd/nEcZkTFE_o.png" width="474"></p> 
<p>这道题目要求我们找到进入环形链表的节点，并且返回节点。</p> 
<p>思路：首先找到快慢指针相遇的节点，此时，meet节点就是slow指针。meet指针到环形链表入口与head节点到环形链表的距离相等。</p> 
<p><img alt="" height="195" src="https://images2.imgbox.com/65/d8/krdEW4aX_o.png" width="415"></p> 
<p>那么，为什么meet指针到环形链表入口与head节点到环形链表的距离相等呢？</p> 
<p>证明：</p> 
<p>我们假设head到入口的距离为L，入口到meet节点的距离为N，整个环的长度为C。</p> 
<p>在相遇时，fast与slow节点分别走过的距离为：</p> 
<blockquote> 
 <p><span style="background-color:#fe2c24;"><span style="color:#0d0016;">fast：L+x*C+N</span></span><span style="color:#0d0016;"><span style="background-color:#ffd900;">  (x为快指针绕环走的圈数)</span></span></p> 
 <p><span style="background-color:#fe2c24;"><span style="color:#0d0016;">slow：L+N</span></span><span style="color:#0d0016;"><span style="background-color:#ffd900;">（slow指针在没有走完第一圈的时候就会被追上，因为当slow节点进入环的时候，fast指针已经在环中走了一段时间，二fast节点的速度有是slow节点的两倍，所以slow节点会在走完一圈之前就被fast节点追上）</span></span></p> 
</blockquote> 
<p><span style="color:#0d0016;">接下来，因为fast节点走过的距离是slow节点走过的距离的两倍，所以我们会得到一个等式：</span></p> 
<blockquote> 
 <p><span style="background-color:#fe2c24;">        2*fast=slow</span></p> 
 <p><span style="background-color:#fe2c24;">→2*L+2*N=L+x*C+N</span></p> 
 <p><span style="background-color:#fe2c24;">→       L+N=x*C</span></p> 
 <p><span style="background-color:#fe2c24;">→            L=x*C-N</span></p> 
 <p><span style="background-color:#fe2c24;">→            L=(x-1)*C+C-N</span></p> 
</blockquote> 
<p>到这里我们会发现C-N的距离其实就是meet节点到环入口的距离，这个距离加上若干个环的长度就是L的长度。所以让meet节点和head节点分别同时走，它们一定会在环的入口处相遇。</p> 
<p><img alt="" height="474" src="https://images2.imgbox.com/a6/21/niwm9JET_o.png" width="892"></p> 
<p></p> 
<h2><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/description/" rel="nofollow" title="138. 随机链表的复制 - 力扣（LeetCode）">138. 随机链表的复制 - 力扣（LeetCode）</a></h2> 
<p>思路：在每个节点之后创建一个节点并将节点的值赋给创建的节点，再将random指向cur-&gt;random-&gt;next。最后将创建出的链表尾插到一个新的链表中。</p> 
<p><img alt="" height="208" src="https://images2.imgbox.com/c5/37/puDcpHrH_o.png" width="550"></p> 
<p><img alt="" height="1085" src="https://images2.imgbox.com/e5/af/EbgJMibk_o.png" width="888"></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/27466709bfec61c5d0fe7ba0d59cef95/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Go语言fmt包深度探索：格式化输入输出的利器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c6b51c078a3ff7d16d97f1ec6dba6e48/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">红黑树（RBTree）认识总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>