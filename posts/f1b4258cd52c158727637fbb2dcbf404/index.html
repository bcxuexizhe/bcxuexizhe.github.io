<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法——双指针 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/f1b4258cd52c158727637fbb2dcbf404/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="算法——双指针">
  <meta property="og:description" content="双指针经常服务于需要一边遍历数组，一边对数组元素进行改动的题目，有些人也称双指针为快慢指针。
同时双指针只是一种思想，实际做题时并不一定会真的采用指针。
移动零 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
请注意 ，必须在不复制数组的情况下原地对数组进行操作。
示例 1:
输入: nums = [0,1,0,3,12] 输出: [1,3,12,0,0] 本题的思路，并非是着重于将0往后移，实际上是要将非0数按顺序往前移。
由题意，我们可以将数据分成两大类：0和非0，那么我们的两个指针，一个就去找0，一个就去找非0。
两个指针均从0下标开始，其中cur找0，dest找非0。cur找到0即停下，dest找到非0即停下。
这样，dest总会走在cur的前面，两者将数据进行交换，就可以将非0元素前移，0元素后移。直至dest走到数组末尾。
class Solution { public: void moveZeroes(vector&lt;int&gt;&amp; nums) { int size = nums.size(); int cur = 0; int dest = 0; while(dest &lt; size) { if(nums[cur] == 0 &amp;&amp; nums[dest] == 0) { dest&#43;&#43;; } else { swap(nums[cur&#43;&#43;],nums[dest&#43;&#43;]); } } } }; 快乐数 「快乐数」 定义为：
对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果这个过程 结果为 1，那么这个数就是快乐数。 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-28T20:07:40+08:00">
    <meta property="article:modified_time" content="2024-04-28T20:07:40+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法——双指针</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#fe2c24;"><strong>双指针</strong></span>经常服务于需要<strong>一边遍历数组，一边对数组元素进行改动的题目</strong>，有些人也称双指针为<strong>快慢指针</strong>。</p> 
<p>同时<strong>双指针只是一种思想，实际做题时并不一定会真的采用指针</strong>。</p> 
<hr> 
<h2>移动零</h2> 
<blockquote> 
 <p>给定一个数组 <code>nums</code>，编写一个函数将<strong>所有 <code>0</code> 移动到数组的末尾</strong>，同时<strong>保持非零元素的相对顺序</strong>。</p> 
 <p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p> 
</blockquote> 
<blockquote> 
 <p><strong>示例 1:</strong></p> 
 <pre><strong>输入:</strong> nums = <code>[0,1,0,3,12]</code>
<strong>输出:</strong> <code>[1,3,12,0,0]</code></pre> 
</blockquote> 
<p>本题的思路，<strong>并非是着重于将0往后移，实际上是要将非0数按顺序往前移</strong>。</p> 
<p>由题意，我们可以将数据分成两大类：<strong>0和非0</strong>，那么我们的两个指针，<strong>一个就去找0，一个就去找非0</strong>。</p> 
<p>两个指针均<span style="color:#fe2c24;"><strong>从0下标开始</strong></span>，其中<strong><span style="background-color:#ffd900;">cur找0，dest找非0。cur找到0即停下，dest找到非0即停下</span></strong>。</p> 
<p>这样，<span style="color:#fe2c24;"><strong>dest总会走在cur的前面，</strong></span><strong><span style="background-color:#ffd900;">两者将数据进行交换，就可以将非0元素前移，0元素后移</span></strong>。直至dest走到数组末尾。</p> 
<pre><code class="language-cpp">class Solution {
public:
    void moveZeroes(vector&lt;int&gt;&amp; nums) {
        int size = nums.size();
        int cur = 0;
        int dest = 0;
        while(dest &lt; size)
        {
            if(nums[cur] == 0 &amp;&amp; nums[dest] == 0)
            {
                dest++;
            }
            else
            {
                swap(nums[cur++],nums[dest++]);
            }
        }
    }
};</code></pre> 
<hr> 
<h2 style="background-color:transparent;"> 快乐数</h2> 
<blockquote> 
 <p><strong>「快乐数」</strong> 定义为：</p> 
 <ul><li>对于一个正整数，<span style="color:#fe2c24;"><strong>每一次将该数替换为它每个位置上的数字的平方和</strong></span>。</li><li>然后重复这个过程<span style="color:#fe2c24;"><strong>直到这个数变为 1</strong></span>，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li></ul> 
 <p><strong>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code></strong> 。</p> 
</blockquote> 
<blockquote> 
 <p><strong>示例 1：</strong></p> 
 <pre><strong>输入：</strong>n = 19
<strong>输出：</strong>true
<strong>解释：
</strong>1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
</pre> 
 <p><strong>示例 2：</strong></p> 
 <pre><strong>输入：</strong>n = 2
<strong>输出：</strong>false
</pre> 
</blockquote> 
<p>通过实例的分析，这个题目我们不难理解，值得提醒的是，<span style="color:#fe2c24;"><strong>无论这个数起始是多少，变化了多少次，他最终都一定会进入循环</strong></span>，<strong><span style="background-color:#ffd900;">比如示例2，就会在4这个数字进入死循环，这个我们不做讲解，感兴趣的小伙伴可以自己去尝试分析解惑</span></strong>。</p> 
<p>还有一点要注意的是，实际上<span style="color:#fe2c24;"><strong>当数最后变为1时，如果在进行运算，是一直以1在进行循环</strong></span>。</p> 
<p>所以这道题的关键解法就在于，<span style="color:#ff9900;"><strong>找到循环的数字，并判断是否为1</strong></span>。</p> 
<p> 不知道小伙伴们还记不记得，在链表阶段，有一种<span style="color:#fe2c24;"><strong>循环链表</strong></span>的存在：</p> 
<p><img alt="" height="163" src="https://images2.imgbox.com/89/2e/gxG6chQ1_o.png" width="951"></p> 
<p> 其中，我们就是通过使用<span style="color:#fe2c24;"><strong>快慢指针</strong></span>的方法，<strong><span style="background-color:#ffd900;">来找到这个循环的入口，也就是本题要找的快乐数</span></strong>。</p> 
<p>让<strong><span style="background-color:#ff9900;">慢指针每次走一步，快指针每次走两步，二者相等之时，即为在入口处相遇</span></strong>。</p> 
<p></p> 
<pre><code class="language-cpp">class Solution {
int sum(int n)
{
    int num = 0;
    while(n)
    {
        int x = n % 10;
        num += x * x;
        n /= 10;
    }
    return num;
}
public:
    bool isHappy(int n) {
        int slow = n;
        int fast = sum(n);
        while(slow != fast)
        {
            slow = sum(slow);
            fast = sum(sum(fast));
        }
        if(slow == 1)
            return true;
        else
            return false;
    }
};</code></pre> 
<p><strong>因为要经常进行运算，所以我们直接将其封装为函数方便调用</strong>。</p> 
<p>然后我们就<span style="color:#fe2c24;"><strong>让slow从n开始，fast从n运算后的数开始</strong></span>，<strong><span style="background-color:#ffd900;">进行循环判断，循环结束即两者相等，再判断此时值是否为1，即可完成本题的解答</span></strong>。</p> 
<hr> 
<h2 style="background-color:transparent;">查找总价格为目标值的两个商品</h2> 
<blockquote> 
 <p><strong>购物车内的商品价格按照<span style="color:#fe2c24;">升序</span>记录于数组 <code>price</code>。请在购物车中找到两个商品的价格总和刚好是 <code>target</code>。若存在多种情况，返回任一结果即可。</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>示例 1：</strong></p> 
 <pre><strong>输入：</strong>price = [3, 9, 12, 15], target = 18
<strong>输出：</strong>[3,15] 或者 [15,3]
</pre> 
 <p><strong>示例 2：</strong></p> 
 <pre><strong>输入：</strong>price = [8, 21, 27, 34, 52, 66], target = 61
<strong>输出：</strong>[27,34] 或者 [34,27]</pre> 
</blockquote> 
<p>这个题可以说是足够简单了，对于<strong>暴力解法</strong>来说，<strong><span style="background-color:#ffd900;">只需要两层for循环去依次尝试两个商品的和是否等于目标值即可，但是这样的算法复杂度为0（n^2）</span></strong>。</p> 
<p>那么是否可以有更加高效的方法呢？没错，就是<span style="color:#fe2c24;"><strong>双指针</strong></span>。</p> 
<p> 题目明确给出，数组里的值已经是<span style="color:#fe2c24;"><strong>升序</strong></span>了（<span style="color:#ff9900;"><strong>如果不是升序，我们可以利用排序使其变为升序</strong></span>），所以我们可以<span style="color:#fe2c24;"><strong>从两头出发，left指向最小值，right指向最大值，当两者的和大于目标值时，right--去找较小的值，反之让left++去找更大的值</strong></span>，<strong><span style="background-color:#ffd900;">直至两者的和等于目标值，或者不存在两个商品的和等于目标值为止</span></strong>。</p> 
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; price, int target) {
        int left = 0;
        int right = price.size() - 1;
        int sum = 0;
        vector&lt;int&gt; v;
        while(left &lt; right)
        {
            sum = price[left] + price[right];
            if(sum &gt; target)
                right--;
            else if(sum &lt; target)
                left++;
            else
            {
                v.push_back(price[left]);
                v.push_back(price[right]);
                break;
            }
        }
        return v;
    }
};</code></pre> 
<hr> 
<h2 style="background-color:transparent;">总结</h2> 
<p>不难看出，双指针算法最适用的场景即为<span style="color:#fe2c24;"><strong>线性表</strong></span>这样的数据结构类型，<strong>通过分析出问题的关键点，然后利用双指针，要么均从头开始，要么均从尾开始，要么一头一尾，逐步去解决问题</strong>。</p> 
<p>关于双指针就分享这么多，喜欢本篇文章记得一键三连，我们下期再见！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/82e47743d3c9140faa2d84f6a7a4dd05/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">无脑入单向无头链表的实现| ArrayList和LinkedList的区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f833ff52b19757eb60caaf7303d52b61/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">web网页连接MQTT，显示数据与下发控制命令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>