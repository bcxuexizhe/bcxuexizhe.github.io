<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构-之八大排序(下)，冒泡排序，快速排序，挖坑法，归并排序】 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/5d51b5690c128f4748a1f0d774a38413/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【数据结构-之八大排序(下)，冒泡排序，快速排序，挖坑法，归并排序】">
  <meta property="og:description" content="🌈个人主页：努力学编程’
⛅个人推荐：基于java提供的ArrayList实现的扑克牌游戏 |C贪吃蛇详解
⚡学好数据结构，刷题刻不容缓：点击一起刷题
🌙心灵鸡汤：总有人要赢，为什么不能是我呢
hello,这里提前祝大家五一快乐，每天都能快快乐乐，并且每天都能学到东西。
我们今天继续顺着上次没有说完的排序算法，这里简单复习一下，我们根据每种排序的方式不同，大致上将常见的排序算法分为选择排序，插入排序，交换排序，归并排序。今天就大家学习我们剩下的两个大类，交换排序和归并排序。
🌈交换排序 ⚡冒泡排序 冒泡排序算法的原理如下：
1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2.对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
3.针对所有的元素重复以上的步骤，除了最后一个。
4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
这里也给大家一个动图，帮助大家理解：
public static void bubbleSort(int[] array) { for (int i = 0; i &lt; array.length-1; i&#43;&#43;) { boolean flg = false; for (int j = 0; j &lt; array.length-1-i; j&#43;&#43;) { if(array[j] &gt; array[j&#43;1]) { swap(array,j,j&#43;1); flg = true; } } //时间复杂度为：O(N) if(!flg) { break; } } } 总体来说呢，冒泡排序是这几种排序中最简单的一种排序，容易理解，代码的逻辑也没有那么复杂，唯一需要提醒大家的，就是两个for循环里面的循环结束条件的判断，这里需要着重强调！！！
1. 冒泡排序是一种非常容易理解的排序
2. 时间复杂度：O(N^2)
3. 空间复杂度：O(1)">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-02T00:14:01+08:00">
    <meta property="article:modified_time" content="2024-05-02T00:14:01+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构-之八大排序(下)，冒泡排序，快速排序，挖坑法，归并排序】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/3f/d4/cOU7D1bv_o.png" alt="在这里插入图片描述"></p> 
<p>🌈<strong>个人主页</strong>：<a href="https://blog.csdn.net/2301_76249062?spm=1011.2441.3001.5343">努力学编程’</a><br> ⛅<strong>个人推荐</strong>：<a href="https://blog.csdn.net/2301_76249062/article/details/136971169?spm=1001.2014.3001.5501">基于java提供的ArrayList实现的扑克牌游戏</a> |<a href="https://blog.csdn.net/2301_76249062/article/details/136043177?spm=1001.2014.3001.5501">C贪吃蛇详解</a><br> ⚡<strong>学好数据结构，刷题刻不容缓</strong>：<a href="https://leetcode.cn/problems/spiral-matrix-ii/description/" rel="nofollow">点击一起刷题</a><br> 🌙<strong>心灵鸡汤</strong>：<strong>总有人要赢，为什么不能是我呢</strong><br> <img src="https://images2.imgbox.com/e8/ad/QKxaBvTG_o.gif" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>hello,这里提前祝大家五一快乐，每天都能快快乐乐，并且每天都能学到东西。</p> 
</blockquote> 
<blockquote> 
 <p>我们今天继续顺着上次没有说完的排序算法，这里简单复习一下，我们根据每种排序的方式不同，大致上将常见的排序算法分为选择排序，插入排序，交换排序，归并排序。今天就大家学习我们剩下的两个大类，交换排序和归并排序。</p> 
</blockquote> 
<h2><a id="_11"></a>🌈交换排序</h2> 
<h3><a id="_12"></a><mark>⚡冒泡排序</mark></h3> 
<p><strong>冒泡排序算法的原理如下：<br> 1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br> 2.对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。<br> 3.针对所有的元素重复以上的步骤，除了最后一个。<br> 4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</strong><br> <img src="https://images2.imgbox.com/0e/53/L6bd8DPT_o.png" alt="在这里插入图片描述"><br> <code>这里也给大家一个动图，帮助大家理解</code>：<br> <img src="https://images2.imgbox.com/4d/09/V9Ly3rcc_o.gif" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">boolean</span> flg <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token function">swap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span>j<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    flg <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            
            <span class="token comment">//时间复杂度为：O(N)</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flg<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><code>总体来说呢，冒泡排序是这几种排序中最简单的一种排序，容易理解，代码的逻辑也没有那么复杂，唯一需要提醒大家的，就是两个for循环里面的循环结束条件的判断，这里需要着重强调！！！</code></p> 
<p><strong>1. 冒泡排序是一种非常容易理解的排序<br> 2. 时间复杂度：O(N^2)<br> 3. 空间复杂度：O(1)<br> 4. 稳定性：稳定</strong></p> 
<h3><a id="_49"></a><mark>⚡快速排序</mark></h3> 
<blockquote> 
 <p>概念：快速排序是Hoare于1962年提出的一种二叉树结构的交换排序方法，其基本思想为：任取待排序元素序列中的某元素作为基准值，按照该排序码将待排序集合分割成两子序列，左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止。</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token comment">// 假设按照升序对array数组中[left, right)区间中的元素进行排序</span>
<span class="token keyword">void</span> <span class="token class-name">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">if</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token comment">// 按照基准值对array数组的 [left, right)区间中的元素进行划分</span>
<span class="token keyword">int</span> div <span class="token operator">=</span> <span class="token function">partion</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 划分成功后以div为边界形成了左右两部分 [left, div) 和 [div+1, right)</span>
<span class="token comment">// 递归排[left, div)</span>
<span class="token class-name">QuickSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> left<span class="token punctuation">,</span> div<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 递归排[div+1, right)</span>
<span class="token class-name">QuickSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> div<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>这里我们可以根据不的基准值，将快速排序划分为两个版本Hoare版本，和挖坑法。</code></p> 
<p><mark>⛅Hoare法</mark><br> Hoare法是指在对数组进行排序时，定义两个变量，与一个在单子循环中不变的key值，右值先动找比key小的数字，找到后左值动，找比key大的数字，后进行交换以完成对数组的排序。<br> <img src="https://images2.imgbox.com/cd/af/grZa4n8Y_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partitionHoare</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span>
        <span class="token keyword">int</span> tmp <span class="token operator">=</span> array<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//array[right] &gt;= tmp  这里能不能 不取等于号</span>
            <span class="token comment">//不能，自己排序会发现这里取等号排序会混乱</span>
            <span class="token comment">// right--; 为什么先走右边</span>
            <span class="token comment">//先走左边会把数值大的元素换到数组的右边</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> tmp<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                right<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span>  array<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> tmp<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                left<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//left 和 right 相遇了</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span>left<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> left<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_97"></a><mark>⚡挖坑法</mark></h3> 
<p>我们上面讲过了Hoare法，其实在一般的快速排序的构成中，我们默认它底层的其实逻辑使用的挖坑法。所以我们这里着重给大家介绍一下挖坑法。<br> <img src="https://images2.imgbox.com/ff/f8/OgMqiPsP_o.png" alt="在这里插入图片描述"></p> 
<ul><li>定义两个指针，一个在左，一个在右，</li><li>每次遍历的时候我们都以左边的值为基准值</li><li>分别利用for循环找到左边和右边需要调整的位置</li><li>然后交换左右两边需要调整的值</li><li>交换到最后，我们需要把left和right相遇的位置的值设置为基准值</li><li>最后返回这个基准值</li></ul> 
<pre><code class="prism language-java"> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> tmp <span class="token operator">=</span> array<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> tmp<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                right<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            array<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>

            <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> tmp<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                left<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            array<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        array<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
        <span class="token keyword">return</span> left<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>好了，我们这里对实现的挖坑法做一点测试。</p> 
</blockquote> 
<h2><a id="_129"></a><mark>⚡归并排序</mark></h2> 
<p>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 归并排序核心步骤：<br> <img src="https://images2.imgbox.com/5f/01/qgBNJ39x_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>这里我们使用的分而治之的方法，去求解的时候，分相对来说是比较简单的，我们使用递归的方法可以很快的对数组进行分组，然后，我们在合并数组的时候，整个过程邢队来说是比较麻烦的，我们需要先对元素进行排序，然后，申请一块新的数组将已经排好序的元素放到申请的数组当中，然后递归整个过程。</p> 
</blockquote> 
<p><mark>这里也罢代码给大家，仔细看一下注释标注的地方，会有很大收获。</mark></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">mergeSortFun</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">mergeSortFun</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">// &gt;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>right<span class="token operator">+</span>left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token function">mergeSortFun</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">mergeSortFun</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//合并</span>
        <span class="token function">merge</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span>
                              <span class="token keyword">int</span> mid<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//这里申请一块新的数组 存放排好序元素</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> s1 <span class="token operator">=</span> left<span class="token punctuation">;</span>
        <span class="token keyword">int</span> e1 <span class="token operator">=</span> mid<span class="token punctuation">;</span>
        <span class="token keyword">int</span> s2 <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> e2 <span class="token operator">=</span> right<span class="token punctuation">;</span>
        <span class="token comment">//定义整个存放元素过程的限制条件</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>s1 <span class="token operator">&lt;=</span> e1 <span class="token operator">&amp;&amp;</span> s2 <span class="token operator">&lt;=</span> e2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>s1<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> array<span class="token punctuation">[</span>s2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>s1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>s2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//走到这里，可能是左边的数组已经排完了  </span>
        <span class="token comment">//我们就把右边所有的元素是直接放到数组当中</span>
        <span class="token comment">//当右边已经拍完之后，</span>
        <span class="token comment">//我们需要将左边还剩的元素直接放到数组当中。</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>s1 <span class="token operator">&lt;=</span> e1<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>s1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>s2 <span class="token operator">&lt;=</span> e2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>s2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//走到这里 相当于tmp数组 当中 所有的元素 都有序了</span>
        <span class="token comment">//接下来把tmp数组的内容 拷贝到array数组当中</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//这里的array()里面的元素索引要加上left,拷贝到原数组</span>
        <span class="token comment">//</span>
            array<span class="token punctuation">[</span>i<span class="token operator">+</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><code>归并排序总结</code><br> <strong>1.归并的缺点在于需要O(N)的空间复杂度，归并排序的思考更多的是解决在磁盘中的外排序问题。<br> 2. 时间复杂度：O(N*logN)<br> 3. 空间复杂度：O(N)<br> 4. 稳定性：稳定</strong></p> 
<h3><a id="_193"></a><strong>🌕<mark>海量数据的排序问题</mark></strong></h3> 
<p>外部排序：排序过程需要在磁盘等外部存储进行的排序<br> <code>前提</code>：内存只有 1G，需要排序的数据有 100G<br> 因为内存中因为无法把所有数据全部放下，所以需要外部排序，而归并排序是最常用的外部排序</p> 
<ul><li>先把文件切分成 200 份，每个 512 M</li><li>分别对 512 M 排序，因为内存已经可以放的下，所以任意排序方式都可以</li><li>进行 2路归并，同时对 200 份有序文件做归并过程，最终结果就有序了</li></ul> 
<p><code>归并排序多用于海量输数据的使用，在整个过程中，我们将海量数据，分成很多一份份的，将每一小份数据单独处理，最后将所有的小数据块进行合并，完成海量数据的处理！！！</code></p> 
<h3><a id="_203"></a><mark>🌕一图带你了解所有排序算法的时间复杂度，和使用场景</mark></h3> 
<p><img src="https://images2.imgbox.com/e9/89/oAcokZOK_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/7a/f3/TYnQIRhP_o.png" alt="在这里插入图片描述"><br> 好了，今天就分享到这里，感谢你的阅读！！！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/722ddd5bc213ca1f6cbd1b94dc378e6c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【c&#43;&#43;】模板编程解密：C&#43;&#43;中的特化、实例化和分离编译</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/99945ed023ac0e9a510523e0bb6d815d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Java】JDK1.8 HashMap源码，put源码详细讲解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>