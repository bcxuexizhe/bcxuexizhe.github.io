<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java的警示之有危险的行为 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/5e998a80c2addc4caba20e59ad0432bb/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="java的警示之有危险的行为">
  <meta property="og:description" content="👨‍💻作者简介：👨🏻‍🎓告别，今天
📔高质量专栏 ：☕java趣味之旅
欢迎🙏点赞🗣️评论📥收藏💓关注
💖衷心的希望我的📙作品能给大家带来收获。
🎊前言： 让我们如大自然般🌱悠然自在😊地生活一天吧，
别因为有坚果外壳或者蚊子翅膀落在铁轨上🛤️而翻了车🚆。让我们该起床时🛏️就赶紧起床🛏️，
该休息🛏️时就安心休息🛏️，
保持安宁而没有烦扰的心态;身边的人要来就让他来，要去就让他去，
让钟声🕰️回荡，让孩子👼哭喊—
下定决心好好地过一天。
🙏希望大家都可以过好每一天。也🙏希望我的博客，能给大家带来💯收获。
1. 异常的概念与体系结构 1.1 异常的概念 身为程序员，虽然我们足不出户，但坏运气仍然会降临身边。倒霉的事就是会发生，找不到文件、服务器出故障、程序报错等。不管你多有天分，也没有办法保证不会出异常。
在程序中也是一样，程序猿是一帮办事严谨、追求完美的高科技人才。在日常开发中，绞尽脑汁将代码写的尽善尽美，在程序运行过程中，难免会出现一些奇奇怪怪的问题。有时通过代码很难去控制，比如：数据格式不对、网络不通畅、内存报警等。
在Java中，将程序执行过程中发生的不正常行为称为异常。比如之前写代码时经常遇到的： 1. 算术异常 System.out.println(10 / 0); // 执行结果 Exception in thread &#34;main&#34; java.lang.ArithmeticException: / by zero 程序报异常了，没有打印，不会再继续向下执行
2. 数组越界异常
int[] arr = {1, 2, 3}; System.out.println(arr[100]); // 执行结果 Exception in thread &#34;main&#34; java.lang.ArrayIndexOutOfBoundsException: 100 3. 空指针异常
int[] arr = null; System.out.println(arr.length); // 执行结果 Exception in thread &#34;main&#34; java.lang.NullPointerException 从上述过程中可以看到，java中不同类型的异常，都有与其对应的类来进行描述。
1.2 异常的好处 使用异常所带来的另一个相当明显的好处是，他往往能降低错误处理代码的复杂度。如果不使用异常，那么就必须检查特定的错误，并在程序中的许多地方来处理它。而如果使用异常，那就不必在方法调用处进行调查，因为异常机制将保证能够捕获这个错误。并且，只需在一个地方处理错误，即所谓的异常处理程序中。这种方式不仅节省代码，而且把描述在正常执行过程中做什么事的代码和出了问题怎么办的代码相分离。总之，与以前的错误处理方法相比，异常机制使代码的阅读，编写和调试工作更加井井有条。 -------选自于JAVA编程思想 作者Bruce Eckel">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-09T20:23:55+08:00">
    <meta property="article:modified_time" content="2024-04-09T20:23:55+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java的警示之有危险的行为</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>👨‍💻<span style="background-color:#fe2c24;">作者简介</span>：👨🏻‍🎓<a class="link-info" href="https://blog.csdn.net/qq_75024941?type=blog" title="告别，今天">告别，今天</a></p> 
 <p><strong>📔高质量专栏 ：☕<a class="link-info" href="https://blog.csdn.net/qq_75024941/category_12543687.html?spm=1001.2014.3001.5482" title="java趣味之旅">java趣味之旅</a></strong></p> 
 <p><span style="color:#ff9900;">欢迎</span>🙏<span style="color:#ffd900;">点赞</span>🗣️<span style="color:#0d0016;">评论</span>📥<span style="color:#38d8f0;">收藏</span>💓<span style="color:#fe2c24;">关注</span></p> 
 <p>💖衷心的希望我的📙作品能给大家带来收获。</p> 
</blockquote> 
<h2>🎊前言：</h2> 
<blockquote> 
 <p>让我们如大自然般🌱悠然自在😊地生活一天吧，<br> 别因为有坚果外壳或者蚊子翅膀落在铁轨上🛤️而翻了车🚆。让我们该起床时🛏️就赶紧起床🛏️，<br> 该休息🛏️时就安心休息🛏️，<br> 保持安宁而没有烦扰的心态;身边的人要来就让他来，要去就让他去，<br> 让钟声🕰️回荡，让孩子👼哭喊—<br> 下定决心好好地过一天。</p> 
 <hr> 
 <p>🙏希望大家都可以过好每一天。也🙏希望我的博客，能给大家带来💯收获。</p> 
</blockquote> 
<h2> <span style="color:#333333;"><strong>1. </strong></span><span style="color:#333333;"><strong>异常的概念与体系结构</strong></span></h2> 
<h3 style="background-color:transparent;"><span style="color:#333333;"><strong>1.1 </strong></span><span style="color:#333333;"><strong>异常的概念</strong></span></h3> 
<p>身为程序员，虽然我们足不出户，但坏运气仍然会降临身边。倒霉的事就是会发生，找不到文件、服务器出故障、程序报错等。不管你多有天分，也没有办法保证不会出异常。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/04/65/mAfyqqp6_o.png"></p> 
<p><span style="color:#333333;">在程序中也是一样，程序猿是一帮办事严谨、追求完美的高科技人才。在日常开发中，绞尽脑汁将代码写的尽善尽美，在程序运行过程中，难免会出现一些奇奇怪怪的问题。有时通过代码很难去控制，比如：数据格式不对、网络不通畅、内存报警等。</span></p> 
<p><span style="color:#333333;"><strong>在</strong></span><span style="color:#333333;"><strong>Java</strong></span><span style="color:#333333;"><strong>中，将程序执行过程中发生的不正常行为称为异常</strong></span><span style="color:#333333;">。比如之前写代码时经常遇到的： </span></p> 
<blockquote> 
 <p><span style="color:#333333;">1. </span><span style="color:#333333;"><strong>算术异常 </strong></span> </p> 
</blockquote> 
<pre><code class="language-java">System.out.println(10 / 0);
// 执行结果
Exception in thread "main" java.lang.ArithmeticException: / by zero</code></pre> 
<p> 程序报异常了，没有打印，不会再继续向下执行</p> 
<blockquote> 
 <p> <span style="color:#333333;">2. </span><span style="color:#333333;"><strong>数组越界异常</strong></span></p> 
</blockquote> 
<pre><code class="language-java">int[] arr = {1, 2, 3};
System.out.println(arr[100]);
// 执行结果
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 100 </code></pre> 
<blockquote> 
 <p><span style="color:#333333;">3. </span><span style="color:#333333;"><strong>空指针异常</strong></span></p> 
</blockquote> 
<pre><code class="language-java">int[] arr = null;
System.out.println(arr.length);
// 执行结果
Exception in thread "main" java.lang.NullPointerException</code></pre> 
<p> <span style="color:#333333;">从上述过程中可以看到，</span><span style="color:#333333;"><strong>java</strong></span><span style="color:#333333;"><strong>中不同类型的异常，都有与其对应的类来进行描述</strong></span><span style="color:#333333;">。</span></p> 
<h3><span style="color:#333333;">1.2 异常的好处</span></h3> 
<p>使用异常所带来的另一个相当明显的好处是，他往往能降低错误处理代码的复杂度。如果不使用异常，那么就必须检查特定的错误，并在程序中的许多地方来处理它。而如果使用异常，那就不必在方法调用处进行调查，因为异常机制将保证能够捕获这个错误。并且，只需在一个地方处理错误，即所谓的<strong>异常处理程序</strong>中。这种方式不仅节省代码，而且把描述在正常执行过程中<span style="background-color:#ff9900;">做什么事的代码</span>和<span style="background-color:#ffd900;">出了问题怎么办</span>的代码相分离。总之，与以前的错误处理方法相比，异常机制使代码的阅读，编写和调试工作更加井井有条。 -------选自于JAVA编程思想 作者Bruce Eckel</p> 
<h3 style="background-color:transparent;"><span style="color:#333333;"><strong>1.3 </strong></span><span style="color:#333333;"><strong>异常的体系结构 </strong></span></h3> 
<p><span style="color:#333333;">异常种类繁多，为了对不同异常或者错误进行很好的分类管理，</span><span style="color:#333333;">Java</span><span style="color:#333333;">内部维护了一个异常的体系结构：</span></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/75/36/qh33uXOt_o.jpg"></p> 
<p> 由java帮助手册可知,RuntimeException有众多子类以上只列举常见几种。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c3/81/jIPe5NVE_o.png"></p> 
<p><span style="color:#333333;">从上图中可以看到： </span></p> 
<blockquote> 
 <p><span style="color:#333333;">1. </span><span style="color:#333333;"><strong>Throwable：</strong></span><span style="color:#333333;">是异常体系的顶层类，其派生出两个重要的子类, </span><span style="color:#333333;"><strong>Error </strong></span><span style="color:#333333;">和 </span><span style="color:#333333;"><strong>Exception </strong></span></p> 
 <p><span style="color:#333333;">2. </span><span style="color:#333333;"><strong>Error</strong></span><span style="color:#333333;"><strong>：</strong></span><span style="color:#333333;">指的是</span><span style="color:#333333;">Java</span><span style="color:#333333;">虚拟机无法解决的严重问题，比如：</span><span style="color:#333333;"><strong>JVM</strong></span><span style="color:#333333;"><strong>的内部错误、资源耗尽等</strong></span><span style="color:#333333;">，典型代表：</span><span style="color:#333333;"><strong>StackOverflowError</strong></span><span style="color:#333333;"><strong>和</strong></span><span style="color:#333333;"><strong>OutOfMemoryError</strong></span><span style="color:#333333;">，一旦发生回力乏术。 </span></p> 
 <p><span style="color:#333333;">3. </span><span style="color:#333333;"><strong>Exception</strong></span><span style="color:#333333;"><strong>：</strong></span><span style="color:#333333;">异常产生后程序员可以通过代码进行处理，使程序继续执行。比如：感冒、发烧。我们平时所说的异常就是Exception</span><span style="color:#333333;">。 </span></p> 
</blockquote> 
<h3><span style="color:#333333;"><strong>1.4 </strong></span><span style="color:#333333;"><strong>异常的分类 </strong></span></h3> 
<p><span style="color:#333333;">异常可能在编译时发生，也可能在程序运行时发生，根据发生的时机不同，可以将异常分为： </span></p> 
<p><span style="color:#333333;">1. </span><span style="color:#333333;"><strong>编译时异常</strong></span></p> 
<p><span style="color:#333333;">在程序编译期间发生的异常，称为编译时异常，也称为受检查异常</span><span style="color:#333333;">(Checked Exception) </span></p> 
<pre><code class="language-java">public class Person {
private String name;
private String gender;
int age;
// 想要让该类支持深拷贝，覆写Object类的clone方法即可
@Override
public Person clone() {
return (Person)super.clone();
}
}
编译时报错：
Error:(17, 35) java: 未报告的异常错误java.lang.CloneNotSupportedException; 必须对其进行捕获或声明以便抛出</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d2/c9/ZfoTr7k9_o.png"></p> 
<p> alt+enter 抛出异常</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d3/a1/6mqu5dA6_o.png"></p> 
<p><span style="color:#333333;">2. </span><span style="color:#333333;"><strong>运行时异常 </strong></span></p> 
<p><span style="color:#333333;">在程序执行期间发生的异常，称为运行时异常，也称为非受检查异常</span><span style="color:#333333;">(Unchecked Exception) </span><span style="color:#333333;"><strong>RunTimeException</strong></span><span style="color:#333333;"><strong>以及其子类对应的异常，都称为运行时异常</strong></span><span style="color:#333333;">。比如：</span><span style="color:#333333;">NullPointerException</span><span style="color:#333333;">、 ArrayIndexOutOfBoundsException、</span><span style="color:#333333;">ArithmeticException</span><span style="color:#333333;">。 </span></p> 
<p><span style="color:#333333;">注意：编译时出现的语法性错误，不能称之为异常。例如将 System.out.println </span><span style="color:#333333;">拼写错了</span><span style="color:#333333;">, </span><span style="color:#333333;">写成了 </span></p> 
<p><span style="color:#333333;">system.out.println. </span><span style="color:#333333;">此时编译过程中就会出错</span><span style="color:#333333;">, </span><span style="color:#333333;">这是</span><span style="color:#333333;"> "</span><span style="color:#333333;">编译期</span><span style="color:#333333;">" </span><span style="color:#333333;">出错。而运行时指的是程序已经编译通过得到class 文件了</span><span style="color:#333333;">, </span><span style="color:#333333;">再由</span><span style="color:#333333;"> JVM </span><span style="color:#333333;">执行过程中出现的错误</span><span style="color:#333333;">. </span></p> 
<h2><span style="color:#333333;"><strong>2. </strong></span><span style="color:#333333;"><strong>异常的处理 </strong></span></h2> 
<p></p> 
<h3><span style="color:#333333;"><strong>2.1 </strong></span><span style="color:#333333;"><strong>防御式编程 </strong></span></h3> 
<p><span style="color:#333333;">错误在代码中是客观存在的</span><span style="color:#333333;">. </span><span style="color:#333333;">因此我们要让程序出现问题的时候及时通知程序猿</span><span style="color:#333333;">. </span><span style="color:#333333;">主要的方式</span></p> 
<p><span style="color:#333333;">例如：当你尝试拉女朋友的手会出现下列两种情况？</span></p> 
<p><span style="color:#333333;">1. </span><span style="color:#333333;"><strong>LBYL</strong></span><span style="color:#333333;">: Look Before You Leap. </span><span style="color:#333333;">在操作之前就做充分的检查</span><span style="color:#333333;">. </span><span style="color:#333333;">即：</span><span style="color:#333333;"><strong>事前防御型 </strong></span></p> 
<p>提前征求女友意见，我能拉你的手吗？</p> 
<p><span style="color:#333333;">2. </span><span style="color:#333333;"><strong>EAFP</strong></span><span style="color:#333333;">: It's Easier to Ask Forgiveness than Permission. "</span><span style="color:#333333;">事后获取原谅比事前获取许可更容易</span><span style="color:#333333;">". </span><span style="color:#333333;">也就是先操作, </span><span style="color:#333333;">遇到问题再处理</span><span style="color:#333333;">. </span><span style="color:#333333;">即：</span><span style="color:#333333;"><strong>事后认错型</strong></span></p> 
<p>先拉再说，不管那么多，事后认错，主打脸皮厚</p> 
<p><span style="color:#333333;">异常处理的核心思想就是</span><span style="color:#333333;"> EAFP</span><span style="color:#333333;">。 </span></p> 
<p><span style="color:#333333;">在</span><span style="color:#333333;">Java</span><span style="color:#333333;">中，</span><span style="color:#333333;"><strong>异常处理主要的</strong></span><span style="color:#333333;"><strong>5</strong></span><span style="color:#333333;"><strong>个关键字：</strong></span><span style="color:#333333;"><strong>throw</strong></span><span style="color:#333333;"><strong>、</strong></span><span style="color:#333333;"><strong>try</strong></span><span style="color:#333333;"><strong>、</strong></span><span style="color:#333333;"><strong>catch</strong></span><span style="color:#333333;"><strong>、</strong></span><span style="color:#333333;"><strong>finally</strong></span><span style="color:#333333;"><strong>、</strong></span><span style="color:#333333;"><strong>throws、ducking</strong></span><span style="color:#333333;">。</span></p> 
<h3><span style="color:#333333;"><strong>2.2 </strong></span><span style="color:#333333;"><strong>异常的抛出</strong></span></h3> 
<p></p> 
<p><span style="color:#333333;">在编写程序时，如果程序中出现错误，此时就需要将错误的信息告知给调用者，比如：参数检测。 </span></p> 
<p><span style="color:#333333;">在</span><span style="color:#333333;">Java</span><span style="color:#333333;">中，可以借助</span><span style="color:#333333;">throw</span><span style="color:#333333;">关键字，抛出一个指定的异常对象，将错误信息告知给调用者。具体语法如下： </span></p> 
<pre><code class="language-java">throw new XXXException("异常产生的原因");</code></pre> 
<p><span style="color:#333333;">【需求】：实现一个获取数组中任意位置元素的方法。</span></p> 
<pre><code class="language-java">public static int getElement(int[] array, int index){
if(null == array){
throw new NullPointerException("传递的数组为null");
}
if(index &lt; 0 || index &gt;= array.length){
throw new ArrayIndexOutOfBoundsException("传递的数组下标越界");
}
return array[index];
}
public static void main(String[] args) {
int[] array = {1,2,3};
getElement(array, 3);
}</code></pre> 
<p><span style="color:#333333;">【</span><span style="color:#333333;"><strong>注意事项</strong></span><span style="color:#333333;">】 </span></p> 
<blockquote> 
 <p></p> 
 <p><span style="color:#333333;">1. throw</span><span style="color:#333333;">必须写在方法体内部 </span></p> 
 <p><span style="color:#333333;">2. </span><span style="color:#333333;">抛出的对象必须是</span><span style="color:#333333;">Exception </span><span style="color:#333333;">或者</span><span style="color:#333333;"> Exception 的子类对象（只能抛异常，不能抛错误）</span></p> 
 <p><span style="color:#333333;">3. </span><span style="color:#333333;">如果抛出的是</span><span style="color:#333333;"> RunTimeException </span><span style="color:#333333;">或者</span><span style="color:#333333;"> RunTimeException </span><span style="color:#333333;">的子类，则可以不用处理，直接交给</span><span style="color:#333333;">JVM</span><span style="color:#333333;">来处理 </span></p> 
 <p><span style="color:#333333;">4. </span><span style="color:#333333;">如果抛出的是编译时异常，用户必须处理，否则无法通过编译 </span></p> 
 <p><span style="color:#333333;">5. </span><span style="color:#333333;"><strong>异常一旦抛出，其后的代码就不会执行</strong></span></p> 
 <p><span style="color:#333333;"><strong>6. 一般情况下，经过throw抛出的是自定义异常</strong></span></p> 
</blockquote> 
<h3><span style="color:#333333;"><strong>2.3 </strong></span><span style="color:#333333;"><strong>异常的捕获 </strong></span></h3> 
<p><span style="color:#333333;">异常的捕获，也就是异常的具体处理方式，主要有两种：异常声明</span><span style="color:#333333;">throws </span><span style="color:#333333;">以及</span><span style="color:#333333;"> try-catch</span><span style="color:#333333;">捕获处理。</span></p> 
<h4><span style="color:#333333;"><strong>2.3.1 </strong></span><span style="color:#333333;"><strong>异常声明</strong></span><span style="color:#333333;"><strong>throws </strong></span></h4> 
<p><span style="color:#333333;">处在方法声明时参数列表之后，当方法中抛出编译时异常，用户不想处理该异常，此时就可以借助throws</span><span style="color:#333333;">将异常抛给方法的调用者来处理。即<strong>当前方法不处理异常，提醒方法的调用者处理异常</strong>。（声明异常只是提醒方法的调用者处理异常）</span></p> 
<pre><code class="language-java">语法格式：
修饰符 返回值类型 方法名(参数列表) throws 异常类型1，异常类型2...{
}</code></pre> 
<p><span style="color:#333333;">需求：加载指定的配置文件</span><span style="color:#333333;">config.ini </span></p> 
<pre><code class="language-java">public class Config {
File file;
/*
FileNotFoundException : 编译时异常，表明文件不存在
此处不处理，也没有能力处理，应该将错误信息报告给调用者，让调用者检查文件名字是否给错误了
*/
public void OpenConfig(String filename) throws FileNotFoundException{//一般放在方法的声明的地方
if(filename.equals("config.ini")){
throw new FileNotFoundException("配置文件名字不对");
}
// 打开文件
}
public void readConfig(){
}
}</code></pre> 
<p><span style="color:#333333;">【</span><span style="color:#333333;"><strong>注意事项</strong></span><span style="color:#333333;">】 </span></p> 
<blockquote> 
 <p><span style="color:#333333;">1. throws</span><span style="color:#333333;">必须跟在方法的参数列表之后 </span></p> 
 <p><span style="color:#333333;">2. </span><span style="color:#333333;">声明的异常必须是</span><span style="color:#333333;"> Exception </span><span style="color:#333333;">或者</span><span style="color:#333333;"> Exception </span><span style="color:#333333;">的子类 </span></p> 
 <p><span style="color:#333333;">3. </span><span style="color:#333333;">方法内部如果抛出了多个异常，</span><span style="color:#333333;">throws</span><span style="color:#333333;">之后必须跟多个异常类型，之间用逗号隔开，如果抛出多个异常类型具有父子关系，直接声明父类即可。</span></p> 
</blockquote> 
<pre><code class="language-java">public class Config {
File file;
// public void OpenConfig(String filename) throws IOException,FileNotFoundException{
// FileNotFoundException 继承自 IOException
public void OpenConfig(String filename) throws IOException{
if(filename.endsWith(".ini")){
throw new IOException("文件不是.ini文件");
}
if(filename.equals("config.ini")){
throw new FileNotFoundException("配置文件名字不对");
}
// 打开文件
}
public void readConfig(){
}
}</code></pre> 
<p><span style="color:#333333;">4. </span><span style="color:#333333;">调用声明抛出异常的方法时，调用者必须对该异常进行处理，或者继续使用</span><span style="color:#333333;">throws</span><span style="color:#333333;">抛出 </span></p> 
<pre><code class="language-java">public static void main(String[] args) throws IOException {
Config config = new Config();
config.openConfig("config.ini");
}</code></pre> 
<p><span style="color:#333333;">将光标放在抛出异常方法上，</span><span style="color:#333333;">alt + Insert </span><span style="color:#333333;">快速 处理：</span></p> 
<p style="text-align:center;"><span style="color:#333333;"><img alt="" src="https://images2.imgbox.com/df/c7/pdrKgkRC_o.png"></span></p> 
<p>5.如果程序的异常，并没有被程序员处理，那么此时这个异常就会交给JVM处理，程序就会立即终止</p> 
<p><img alt="" src="https://images2.imgbox.com/9d/a8/UkDJQQ2k_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/77/22/anSLgqBG_o.png"></p> 
<p> 从第7行抛出异常，交给JVM处理，JVM处理不了，程序报错</p> 
<p>6. 由下图可知，同一时刻，只能抛出一个异常。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/62/85/P7qfU2sP_o.png"></p> 
<h4 style="background-color:transparent;"><span style="color:#333333;"><strong>2.3.2 try-catch</strong></span><span style="color:#333333;"><strong>捕获并处理</strong></span></h4> 
<p><span style="color:#333333;">throws对异常并没有真正处理，而是将异常报告给抛出异常方法的调用者，由调用者处理。如果真正要对异常进行处理，就需要try-catch</span><span style="color:#333333;">。</span></p> 
<blockquote> 
 <p><span style="color:#333333;">语法格式：<br> try{<!-- --><br> // 将可能出现异常的代码放在这里<br> }catch(要捕获的异常类型 e){<!-- --><br> // 如果try中的代码抛出异常了，此处catch捕获时异常类型与try中抛出的异常类型一致时，或者是try中抛出异常的基类<br> 时，就会被捕获到<br> // 对异常就可以正常处理，处理完成后，跳出try-catch结构，继续执行后序代码<br> }[catch(异常类型 e){<!-- --><br> // 对异常进行处理<br> }finally{<!-- --><br> // 此处代码一定会被执行到<br> }]<br> // 后序代码<br> // 当异常被捕获到时，异常就被处理了，这里的后序代码一定会执行<br> // 如果捕获了，由于捕获时类型不对，那就没有捕获到，这里的代码就不会被执行<br> 注意：<br> 1. []中表示可选项，可以添加，也可以不用添加<br> 2. try中的代码可能会抛出异常，也可能不会</span></p> 
</blockquote> 
<p>printStackTrace() 显示错误信息</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b0/c7/yHJ6oZog_o.png"></p> 
<p><span style="color:#333333;">需求：读取配置文件，如果配置文件名字不是指定名字，抛出异常，调用者进行异常处理 </span></p> 
<pre><code class="language-java">public class Config {
File file;
public void openConfig(String filename) throws FileNotFoundException{
if(!filename.equals("config.ini")){
throw new FileNotFoundException("配置文件名字不对");
}
// 打开文件
}
public void readConfig(){
}
public static void main(String[] args) {
Config config = new Config();
try {
config.openConfig("config.txt");
System.out.println("文件打开成功");
} catch (IOException e) {
// 异常的处理方式
//System.out.println(e.getMessage()); // 只打印异常信息
//System.out.println(e); // 打印异常类型：异常信息
e.printStackTrace(); // 打印信息最全面
}
// 一旦异常被捕获处理了，此处的代码会执行
System.out.println("异常如果被处理了，这里的代码也可以执行");
}
}</code></pre> 
<p> <span style="color:#333333;">方法可以抓住其他方法所抛出的异常，异常总是会丢回给调用方。<br> 会抛出异常的方法，必须要声明它有可能才会这么做</span></p> 
<blockquote> 
 <p><span style="color:#777777;"><strong>关于异常的处理方式 </strong></span></p> 
 <p><span style="color:#777777;">异常的种类有很多</span><span style="color:#777777;">, </span><span style="color:#777777;">我们要根据不同的业务场景来决定</span><span style="color:#777777;">. </span></p> 
 <ul><li><span style="color:#777777;">对于比较严重的问题</span><span style="color:#777777;">(</span><span style="color:#777777;">例如和算钱相关的场景</span><span style="color:#777777;">), </span><span style="color:#777777;">应该让程序直接崩溃</span><span style="color:#777777;">, </span><span style="color:#777777;">防止造成更严重的后果 </span></li><li><span style="color:#777777;">对于不太严重的问题</span><span style="color:#777777;">(</span><span style="color:#777777;">大多数场景</span><span style="color:#777777;">), </span><span style="color:#777777;">可以记录错误日志</span><span style="color:#777777;">, </span><span style="color:#777777;">并通过监控报警程序及时通知程序猿 </span></li><li><span style="color:#777777;">对于可能会恢复的问题</span><span style="color:#777777;">(</span><span style="color:#777777;">和网络相关的场景</span><span style="color:#777777;">), </span><span style="color:#777777;">可以尝试进行重试</span><span style="color:#777777;">. </span></li><li><span style="color:#777777;">在我们当前的代码中采取的是经过简化的第二种方式</span><span style="color:#777777;">. </span><span style="color:#777777;">我们记录的错误日志是出现异常的方法调用信息</span><span style="color:#777777;">, </span><span style="color:#777777;">能很快速的让我们找到出现异常的位置. </span><span style="color:#777777;">以后在实际工作中我们会采取更完备的方式来记录异常信息</span><span style="color:#777777;">. </span></li></ul> 
</blockquote> 
<p><span style="color:#333333;">【</span><span style="color:#333333;"><strong>注意事项</strong></span><span style="color:#333333;">】</span></p> 
<blockquote> 
 <p></p> 
 <p><span style="color:#333333;">1. try</span><span style="color:#333333;">块内抛出异常位置之后的代码将不会被执行 </span></p> 
 <p><span style="color:#333333;">2. </span><span style="color:#333333;">如果抛出异常类型与</span><span style="color:#333333;">catch</span><span style="color:#333333;">时异常类型不匹配，即异常不会被成功捕获，也就不会被处理，继续往外抛，直到JVM收到后中断程序</span><span style="color:#333333;">----</span><span style="color:#333333;">异常是按照类型来捕获的 </span></p> 
</blockquote> 
<pre><code class="language-java">public static void main(String[] args) {
try {
int[] array = {1,2,3};
System.out.println(array[3]); // 此处会抛出数组越界异常
}catch (NullPointerException e){ // 捕获时候捕获的是空指针异常--真正的异常无法被捕获到
e.printStackTrace();
}
System.out.println("后序代码");
}
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 3
at day20210917.ArrayOperator.main(ArrayOperator.java:24)</code></pre> 
<p><span style="color:#333333;">3. try</span><span style="color:#333333;">中可能会抛出多个不同的异常对象，则必须用多个</span><span style="color:#333333;">catch</span><span style="color:#333333;">来捕获</span><span style="color:#333333;">----</span><span style="color:#333333;">即多种异常，多次捕获</span></p> 
<pre><code class="language-java">public static void main(String[] args) {
int[] arr = {1, 2, 3};
try {
System.out.println("before");
// arr = null;
System.out.println(arr[100]);
System.out.println("after");
} catch (ArrayIndexOutOfBoundsException e) {
System.out.println("这是个数组下标越界异常");
e.printStackTrace();
} catch (NullPointerException e) {
System.out.println("这是个空指针异常");
e.printStackTrace();
}
System.out.println("after try catch");
}</code></pre> 
<p><span style="color:#333333;">如果多个异常的处理方式是完全相同</span><span style="color:#333333;">, </span><span style="color:#333333;">也可以写成这样：</span></p> 
<pre><code class="language-java">catch (ArrayIndexOutOfBoundsException | NullPointerException e) {
...
}</code></pre> 
<p><span style="color:#333333;">如果异常之间具有父子关系，一定是子类异常在前</span><span style="color:#333333;">catch</span><span style="color:#333333;">，父类异常在后</span><span style="color:#333333;">catch</span><span style="color:#333333;">，否则语法错误： </span></p> 
<pre><code class="language-java">public static void main(String[] args) {
int[] arr = {1, 2, 3};
try {
System.out.println("before");
arr = null;
System.out.println(arr[100]);
System.out.println("after");
} catch (Exception e) { // Exception可以捕获到所有异常
e.printStackTrace();
}catch (NullPointerException e){ // 永远都捕获执行到
e.printStackTrace();
}
System.out.println("after try catch");
}
Error:(33, 10) java: 已捕获到异常错误java.lang.NullPointerException</code></pre> 
<p><span style="color:#333333;">4. </span><span style="color:#333333;">可以通过一个</span><span style="color:#333333;">catch</span><span style="color:#333333;">捕获所有的异常，即多个异常，一次捕获(范围太大了，你根本无法确定你捕获的是哪一个异常，不推荐</span><span style="color:#333333;">)</span></p> 
<pre><code class="language-java">public static void main(String[] args) {
int[] arr = {1, 2, 3};
try {
System.out.println("before");
arr = null;
System.out.println(arr[100]);
System.out.println("after");
} catch (Exception e) {
e.printStackTrace();
}
System.out.println("after try catch");
}</code></pre> 
<p><span style="color:#333333;">由于</span><span style="color:#333333;"> Exception </span><span style="color:#333333;">类是所有异常类的父类</span><span style="color:#333333;">. </span><span style="color:#333333;">因此可以用这个类型表示捕捉所有异常</span><span style="color:#333333;">. </span></p> 
<p></p> 
<blockquote> 
 <p><span style="color:#777777;">备注</span><span style="color:#777777;">: catch </span><span style="color:#777777;">进行类型匹配的时候</span><span style="color:#777777;">, </span><span style="color:#777777;">不光会匹配相同类型的异常对象</span><span style="color:#777777;">, </span><span style="color:#777777;">也会捕捉目标异常类型的子类对象</span><span style="color:#777777;">. </span></p> 
 <p><span style="color:#777777;">如刚才的代码</span><span style="color:#777777;">, NullPointerException </span><span style="color:#777777;">和</span><span style="color:#777777;"> ArrayIndexOutOfBoundsException </span><span style="color:#777777;">都是</span><span style="color:#777777;"> Exception </span><span style="color:#777777;">的子类</span><span style="color:#777777;">,因此都能被捕获到</span></p> 
</blockquote> 
<h4 style="background-color:transparent;">2.3.3 异常的多态性 </h4> 
<blockquote> 
 <p>别忘记异常是对象，除了可以被抛出之外，并没有什么特别的。所以他向很多对象一样，异常也能够以多态的方式来引用。<span style="background-color:#a2e043;">Exception是所有异常的父类，但请注意它这个范围是所有异常，而object类是所有对象，所以千万不要搞混。</span>这样的好处是方法可以不必明确的声明，每个可能抛出的异常，可以只声明父类就行。对于catch块来说，也可以不用怼，每个可能的异常处理，只要有一个或少数几个可以处理所有的异常就够了</p> 
</blockquote> 
<p> 当我们以异常的父亲来声明会抛出的异常时。<br> 以下有两种方式</p> 
<ul><li>已所抛出的异常父类来catch异常</li><li>已所抛出的异常子类来catch异常</li></ul> 
<h4 style="background-color:transparent;"><span style="color:#333333;"><strong>2.3.4 finally </strong></span></h4> 
<p><span style="color:#333333;">在写程序时，</span><span style="color:#333333;"><strong>有些特定的代码，不论程序是否发生异常，都需要执行，比如程序中打开的资源</strong></span><span style="color:#333333;">：网络连接、数据库连接、IO</span><span style="color:#333333;">流等，</span><span style="color:#333333;"><strong>在程序正常或者异常退出时，必须要对资源进进行回收</strong></span><span style="color:#333333;">。另外，因为</span><span style="color:#333333;"><strong>异常会引发程序的跳转，可能</strong></span><span style="color:#333333;"><strong>导致有些语句执行不到</strong></span><span style="color:#333333;">，</span><span style="color:#333333;">finally</span><span style="color:#333333;">就是用来解决这个问题的。 </span></p> 
<blockquote> 
 <p><span style="color:#000000;">语法格式： </span></p> 
 <p><span style="color:#770088;">try</span><span style="color:#333333;">{ </span></p> 
 <p><span style="color:#aa5500;">// </span><span style="color:#aa5500;">可能会发生异常的代码 </span></p> 
 <p><span style="color:#333333;">}</span><span style="color:#770088;">catch</span><span style="color:#333333;">(</span><span style="color:#000000;">异常类型 </span><span style="color:#000000;">e</span><span style="color:#333333;">){ </span></p> 
 <p><span style="color:#aa5500;">// </span><span style="color:#aa5500;">对捕获到的异常进行处理 </span></p> 
 <p><span style="color:#333333;">}</span></p> 
 <p><span style="color:#333333;">return 0;//不会结束，程序会直接跳到finally;</span></p> 
 <p><span style="color:#770088;">finally</span><span style="color:#333333;">{ </span></p> 
 <p><span style="color:#aa5500;">// </span><span style="color:#aa5500;">此处的语句无论是否发生异常，都会被执行到 </span></p> 
 <p><span style="color:#333333;">} </span></p> 
 <p><span style="color:#aa5500;">// </span><span style="color:#aa5500;">如果没有抛出异常，或者异常被捕获处理了，这里的代码也会执行 </span></p> 
</blockquote> 
<ul><li> 如果try块失败了，抛出异常，流程会马上转移到catch块。当catch块完成时，会执行finally块，当finally完成时，就会继续执行其余的部分。</li><li>如果try块成功了，流程会马上跳过catch块。当finally完成时，就会继续执行其余的部分。</li><li>如果try块或catch块有return指令，还是会执行!流程会跳到finally然后再回到return指令。</li></ul> 
<div></div> 
<pre><code class="language-java">public static void main(String[] args) {
try{
int[] arr = {1,2,3};
arr[100] = 10;
arr[0] = 10;
}catch (ArrayIndexOutOfBoundsException e){
System.out.println(e);
}finally {
System.out.println("finally中的代码一定会执行");
}
System.out.println("如果没有抛出异常，或者异常被处理了，try-catch后的代码也会执行");
}</code></pre> 
<p> <span style="color:#333333;"><strong>问题：既然</strong></span><span style="color:#333333;"><strong> finally </strong></span><span style="color:#333333;"><strong>和</strong></span><span style="color:#333333;"><strong> try-catch-finally </strong></span><span style="color:#333333;"><strong>后的代码都会执行，那为什么还要有</strong></span><span style="color:#333333;"><strong>finally</strong></span><span style="color:#333333;"><strong>呢？ </strong></span></p> 
<p><span style="color:#333333;">需求：实现</span><span style="color:#333333;">getData</span><span style="color:#333333;">方法，内部输入一个整形数字，然后将该数字返回，并再</span><span style="color:#333333;">main</span><span style="color:#333333;">方法中打印 </span>​​​​​​​</p> 
<pre><code class="language-java">public class TestFinally {
public static int getData(){
Scanner sc = null;
try{
sc = new Scanner(System.in);
int data = sc.nextInt();
return data;
}catch (InputMismatchException e){
e.printStackTrace();
}finally {
System.out.println("finally中代码");
}
System.out.println("try-catch-finally之后代码");
if(null != sc){
sc.close();
}
return 0;
}
public static void main(String[] args) {
int data = getData();
System.out.println(data);
}
}
// 正常输入时程序运行结果：
100
finally中代码
100</code></pre> 
<p><span style="color:#333333;">上述程序，如果正常输入，成功接收输入后程序就返回了，</span><span style="color:#333333;">try-catch-finally</span><span style="color:#333333;">之后的代码根本就没有执行，即输入流就没有被释放，造成资源泄漏。 </span></p> 
<p><span style="color:#333333;">​​​​​​​不会被return影响，一定会被执行</span></p> 
<p><span style="color:#333333;"><strong>注意：</strong></span><span style="color:#333333;"><strong>finally</strong></span><span style="color:#333333;"><strong>中的代码一定会执行的，一般在</strong></span><span style="color:#333333;"><strong>finally</strong></span><span style="color:#333333;"><strong>中进行一些资源清理的扫尾工作</strong></span><span style="color:#333333;">。</span></p> 
<p></p> 
<p><span style="color:#383838;">finally</span><span style="color:#383838;">块是用来存放不曾有没有异常都得执行的程序</span></p> 
<pre><code class="language-java">// 下面程序输出什么？
public static void main(String[] args) {
System.out.println(func());
}
public static int func() {
try {
return 10;
} finally {
return 20;
}
}
A: 10 B: 20 C: 30 D: 编译失败</code></pre> 
<p><span style="color:#333333;">finally </span><span style="color:#333333;">执行的时机是在方法返回之前</span><span style="color:#333333;">(try </span><span style="color:#333333;">或者</span><span style="color:#333333;"> catch </span><span style="color:#333333;">中如果有</span><span style="color:#333333;"> return </span><span style="color:#333333;">会在这个</span><span style="color:#333333;"> return </span><span style="color:#333333;">之前执行</span><span style="color:#333333;"> finally). </span><span style="color:#333333;">但是如果finally 中也存在</span><span style="color:#333333;"> return </span><span style="color:#333333;">语句</span><span style="color:#333333;">, </span><span style="color:#333333;">那么就会执行</span><span style="color:#333333;"> finally </span><span style="color:#333333;">中的</span><span style="color:#333333;"> return, </span><span style="color:#333333;">从而不会执行到</span><span style="color:#333333;"> try </span><span style="color:#333333;">中原有的</span><span style="color:#333333;"> return. </span></p> 
<p><span style="color:#333333;">一般我们不建议在</span><span style="color:#333333;"> finally </span><span style="color:#333333;">中写</span><span style="color:#333333;"> return (</span><span style="color:#333333;">被编译器当做一个警告</span><span style="color:#333333;">). </span></p> 
<blockquote> 
 <p><span style="color:#333333;">【面试题】：</span></p> 
 <p><span style="color:#333333;">1. throw 和</span><span style="color:#333333;"> throws </span><span style="color:#333333;">的区别？ </span></p> 
 <p><span style="color:#333333;">2. finally</span><span style="color:#333333;">中的语句一定会执行吗？</span></p> 
</blockquote> 
<h4>2.3.5 异常的处理规则 </h4> 
<blockquote> 
 <p><span style="color:#1d1d1d;">catch 与 </span><span style="color:#1d1d1d;">finally 之间</span><span style="color:#1d1d1d;">不能没有 try</span></p> 
</blockquote> 
<pre><code class="language-java">yoid go () { 
FoO f = new Foo() ;
f.foofO;
catch (FooException ex) {
}
}</code></pre> 
<blockquote> 
 <p><span style="color:#1d1d1d;">try一</span><span style="color:#1d1d1d;">定要有</span><span style="color:#1d1d1d;">catch 或 </span><span style="color:#1d1d1d;">final</span>ly ，以下是合法的，但还是要注意第四行的写法</p> 
</blockquote> 
<pre><code class="language-java">try {
x.doStuff();
}finally {
// 清理
}</code></pre> 
<blockquote> 
 <p> t<span style="color:#0c0c0c;">ry </span><span style="color:#0c0c0c;">catc</span><span style="color:#0c0c0c;">h 之间</span><span style="color:#0c0c0c;">不能有程序</span></p> 
</blockquote> 
<pre><code class="language-java">try {
x.doStuff();
}
int x = 3;
catch (Exception ex) {

}</code></pre> 
<blockquote> 
 <p><span style="color:#0c0c0c;">只带有 f</span><span style="color:#323232;">in</span><span style="color:#0c0c0c;">ally 的 t</span><span style="color:#0c0c0c;">ry </span><span style="color:#0c0c0c;">必须要声明异常</span></p> 
</blockquote> 
<p> </p> 
<pre><code class="language-java">void go() throws FooException {
try{
x.doStuff() ; 
} finally {}
}</code></pre> 
<h3 style="background-color:transparent;"><span style="color:#333333;"><strong>2.4 </strong></span><span style="color:#333333;"><strong>异常的处理流程</strong></span></h3> 
<blockquote> 
 <p></p> 
 <p><span style="color:#777777;"><strong>关于</strong></span><span style="color:#777777;"><strong> "</strong></span><span style="color:#777777;"><strong>调用栈</strong></span><span style="color:#777777;"><strong>" </strong></span></p> 
 <p><span style="color:#777777;">方法之间是存在相互调用关系的</span><span style="color:#777777;">, </span><span style="color:#777777;">这种调用关系我们可以用</span><span style="color:#777777;"> "</span><span style="color:#777777;">调用栈</span><span style="color:#777777;">" </span><span style="color:#777777;">来描述</span><span style="color:#777777;">. </span><span style="color:#777777;">在</span><span style="color:#777777;"> JVM </span><span style="color:#777777;">中有一块内存空间称为"虚拟机栈</span><span style="color:#777777;">" </span><span style="color:#777777;">专门存储方法之间的调用关系</span><span style="color:#777777;">. </span><span style="color:#777777;">当代码中出现异常的时候</span><span style="color:#777777;">, </span><span style="color:#777777;">我们就可以使用 </span><span style="color:#777777;">e.printStackTrace(); </span><span style="color:#777777;">的 </span></p> 
 <p><span style="color:#777777;">方式查看出现异常代码的调用栈</span></p> 
</blockquote> 
<p><span style="color:#333333;">如果本方法中没有合适的处理异常的方式</span><span style="color:#333333;">, </span><span style="color:#333333;">就会沿着调用栈向上传递</span></p> 
<pre><code class="language-java">public static void main(String[] args) {
try {
func();
} catch (ArrayIndexOutOfBoundsException e) {
e.printStackTrace();
}
System.out.println("after try catch");
}
public static void func() {
int[] arr = {1, 2, 3};
System.out.println(arr[100]);
}
// 直接结果
java.lang.ArrayIndexOutOfBoundsException: 100
at demo02.Test.func(Test.java:18)
at demo02.Test.main(Test.java:9)
after try catch</code></pre> 
<p><span style="color:#333333;">如果向上一直传递都没有合适的方法处理异常</span><span style="color:#333333;">, </span><span style="color:#333333;">最终就会交给</span><span style="color:#333333;"> JVM </span><span style="color:#333333;">处理</span><span style="color:#333333;">, </span><span style="color:#333333;">程序就会异常终止</span><span style="color:#333333;">(</span><span style="color:#333333;">和我们最开始未使用</span><span style="color:#333333;"> try catch 时是一样的</span><span style="color:#333333;">). </span></p> 
<pre><code class="language-java">public static void main(String[] args) {
func();
System.out.println("after try catch");
}
public static void func() {
int[] arr = {1, 2, 3};
System.out.println(arr[100]);
}
// 执行结果
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 100
at demo02.Test.func(Test.java:14)
at demo02.Test.main(Test.java:8)</code></pre> 
<p><span style="color:#333333;">可以看到</span><span style="color:#333333;">, </span><span style="color:#333333;">程序已经异常终止了</span><span style="color:#333333;">, </span><span style="color:#333333;">没有执行到 </span><span style="color:#333333;">System.out.println("after try catch"); </span><span style="color:#333333;">这一行</span><span style="color:#333333;">. </span></p> 
<p><span style="color:#333333;">【</span><span style="color:#333333;"><strong>异常处理流程总结</strong></span><span style="color:#333333;">】 ​​​​​​​</span></p> 
<blockquote> 
 <ul><li><span style="color:#333333;">程序先执行</span><span style="color:#333333;"> try </span><span style="color:#333333;">中的代码 </span></li><li><span style="color:#333333;">如果</span><span style="color:#333333;"> try </span><span style="color:#333333;">中的代码出现异常</span><span style="color:#333333;">, </span><span style="color:#333333;">就会结束</span><span style="color:#333333;"> try </span><span style="color:#333333;">中的代码</span><span style="color:#333333;">, </span><span style="color:#333333;">看和</span><span style="color:#333333;"> catch </span><span style="color:#333333;">中的异常类型是否匹配</span><span style="color:#333333;">. </span></li><li><span style="color:#333333;">如果找到匹配的异常类型</span><span style="color:#333333;">, </span><span style="color:#333333;">就会执行</span><span style="color:#333333;"> catch </span><span style="color:#333333;">中的代码 </span></li><li><span style="color:#333333;">如果没有找到匹配的异常类型</span><span style="color:#333333;">, </span><span style="color:#333333;">就会将异常向上传递到上层调用者</span><span style="color:#333333;">. </span></li><li><span style="color:#333333;">无论是否找到匹配的异常类型</span><span style="color:#333333;">, finally </span><span style="color:#333333;">中的代码都会被执行到</span><span style="color:#333333;">(</span><span style="color:#333333;">在该方法结束之前执行</span><span style="color:#333333;">). </span></li><li><span style="color:#333333;">如果上层调用者也没有处理的了异常</span><span style="color:#333333;">, </span><span style="color:#333333;">就继续向上传递</span><span style="color:#333333;">. </span></li><li><span style="color:#333333;">一直到</span><span style="color:#333333;"> main </span><span style="color:#333333;">方法也没有合适的代码处理异常</span><span style="color:#333333;">, </span><span style="color:#333333;">就会交给</span><span style="color:#333333;"> JVM </span><span style="color:#333333;">来进行处理</span><span style="color:#333333;">, </span><span style="color:#333333;">此时程序就会异常终止</span><span style="color:#333333;">. </span></li></ul> 
</blockquote> 
<h2><span style="color:#333333;"><strong>3. </strong></span><span style="color:#333333;"><strong>自定义异常类</strong></span></h2> 
<p><span style="color:#333333;">Java </span><span style="color:#333333;">中虽然已经内置了丰富的异常类</span><span style="color:#333333;">, </span><span style="color:#333333;">但是并不能完全表示实际开发中所遇到的一些异常，此时就需要维护符合我们实际情况的异常结构. </span></p> 
<p><span style="color:#333333;">例如, </span><span style="color:#333333;">我们实现一个用户登陆功能</span><span style="color:#333333;">. </span></p> 
<pre><code class="language-java">public class LogIn {
private String userName = "admin";
private String password = "123456";
public static void loginInfo(String userName, String password) {
if (!this.userName.equals(userName)) {
}
if (!this.password.equals(password)) {
}
System.out.println("登陆成功");
}
public static void main(String[] args) {
loginInfo("admin", "123456");
}
}</code></pre> 
<p></p> 
<p><span style="color:#333333;">此时我们在处理用户名密码错误的时候可能就需要抛出两种异常</span><span style="color:#333333;">. </span><span style="color:#333333;">我们可以基于已有的异常类进行扩展</span><span style="color:#333333;">(</span><span style="color:#333333;">继承</span><span style="color:#333333;">), </span><span style="color:#333333;">创建和我们业务相关的异常类. </span></p> 
<blockquote> 
 <p><span style="color:#333333;">具体方式： </span></p> 
 <p><span style="color:#333333;">1. </span><span style="color:#333333;">自定义异常类，然后继承自</span><span style="color:#333333;">Exception </span><span style="color:#333333;">或者</span><span style="color:#333333;"> RunTimeException </span></p> 
 <p><span style="color:#333333;">2. </span><span style="color:#333333;">实现一个带有</span><span style="color:#333333;">String</span><span style="color:#333333;">类型参数的构造方法，参数含义：出现异常的原因 </span></p> 
</blockquote> 
<div> 
 <pre><code class="language-java">class UserNameException extends Exception {
public UserNameException(String message) {
super(message);
}
}
class PasswordException extends Exception {
public PasswordException(String message) {
super(message);
}
}</code></pre> 
 <p><span style="color:#333333;">此时我们的</span><span style="color:#333333;"> login </span><span style="color:#333333;">代码可以改成 </span></p> 
 <pre><code class="language-java">public class LogIn {
private String userName = "admin";
private String password = "123456";
public static void loginInfo(String userName, String password)
throws UserNameException,PasswordException{
if (!userName.equals(userName)) {
throw new UserNameException("用户名错误！");
}
if (!password.equals(password)) {
throw new PasswordException("用户名错误！");
}
System.out.println("登陆成功");
}
public static void main(String[] args) {
try {
loginInfo("admin", "123456");
} catch (UserNameException e) {
e.printStackTrace();
} catch (PasswordException e) {
e.printStackTrace();
}
}
}</code></pre> 
 <blockquote> 
  <p><span style="color:#333333;"><strong>注意事项 </strong></span></p> 
  <ul><li><span style="color:#333333;">自定义异常通常会继承自</span><span style="color:#333333;"> Exception </span><span style="color:#333333;">或者</span><span style="color:#333333;"> RuntimeException </span></li><li><span style="color:#333333;">继承自</span><span style="color:#333333;"> Exception </span><span style="color:#333333;">的异常默认是受查异常 </span></li><li><span style="color:#333333;">继承自</span><span style="color:#333333;"> RuntimeException </span><span style="color:#333333;">的异常默认是非受查异常</span></li></ul> 
 </blockquote> 
</div> 
<p></p> 
<p></p> 
<h2></h2> 
<p></p> 
<h2>🎊总结</h2> 
<blockquote> 
 <ul><li><span style="background-color:#c7e6ea;">JAVA的基本理念是"结构不佳的代码不能运行"。</span></li><li><span style="background-color:#c7e6ea;">发现错误的理想时机是在编译阶段，也就是在你试图运行程序之前。</span></li><li><span style="background-color:#c7e6ea;">改进的错误恢复机制是提供代码健壮性的最强有力的方式。</span></li><li><span style="background-color:#c7e6ea;">java中的异常处理的目的在于通过使用少于目前数量的代码来简化大型可靠的程序的生成，并且通过这种方式可以使你更加自信。你的应用中没有未处理的错误，异常的相关知识学起来并非艰涩难懂，而且他属于那种可以使你的项目受益明显立竿见影的特性之一</span></li></ul> 
 <p><span style="background-color:#c7e6ea;">                                                                    选自于JAVA编程思想 作者Bruce Eckel</span></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5477f6a588838ad8d9a3916963535906/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">苍穹外卖11（Apache ECharts前端统计，营业额统计，用户统计，订单统计，销量排名Top10）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9e0d2c10579924cfadd5d3d387f6306b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">精通SQL：数据库工程师必须掌握的UPDATE操作全解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>