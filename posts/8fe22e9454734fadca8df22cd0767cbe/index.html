<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL-----事务（详解） - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/8fe22e9454734fadca8df22cd0767cbe/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="MySQL-----事务（详解）">
  <meta property="og:description" content="目录
一.事务简介：
二.事务操作：
未控制事务：
事务的控制方法一：
事务的控制方法二：
三：事务的四大特性：
四.并发事务问题：
五.事务的隔离级别：
一.事务简介： 事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。
比如，银行转账的操作就是一个典型的事务问题，举个例子：张三给李四转账1000块钱，张三银行账户的钱减少1000，而李四银行账户的钱要增加 1000。 这一组操作就必须在一个事务的范围内，要么都成功，要么都失败。
正常情况: 转账这个操作, 需要分为以下这么三步来完成 , 三步完成之后, 张三减少1000, 而李四 增加1000, 转账成功 :
异常情况: 转账这个操作, 也是分为以下这么三步来完成 , 在执行第三步是报错了, 这样就导致张 三减少1000块钱, 而李四的金额没变, 这样就造成了数据的不一致, 就出现问题了：
为了解决上述的问题，就需要通过数据的事务来完成，我们只需要在业务逻辑执行之前开启事务，执行 完毕后提交事务。如果执行过程中报错，则回滚事务，把数据恢复到事务开始之前的状态：
注意： 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐式的提交事务。
由于MySQL的事务自动提交的这种特性，就要求我们将设置修改为手动事务，以此来发现问题并且解决问题。
二.事务操作： 未控制事务： 数据准备（这里我们根据上面的例子来说明问题）： # 数据准备 drop table if exists account; create table account( id int primary key auto_increment comment &#39;ID&#39;, name varchar(10) comment&#39;年龄&#39;, money double(10,2) comment &#39;余额&#39; )comment &#39;账户表&#39;; insert into account(name,money) values(&#39;张三&#39;,2000),(&#39;李四&#39;,2000); 1).">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-17T09:27:19+08:00">
    <meta property="article:modified_time" content="2024-05-17T09:27:19+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL-----事务（详解）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B%EF%BC%9A" rel="nofollow">一.事务简介：</a></p> 
<p id="%E4%BA%8C.%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C%EF%BC%9A" rel="nofollow">二.事务操作：</a></p> 
<p id="%E6%9C%AA%E6%8E%A7%E5%88%B6%E4%BA%8B%E5%8A%A1%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%9C%AA%E6%8E%A7%E5%88%B6%E4%BA%8B%E5%8A%A1%EF%BC%9A" rel="nofollow">未控制事务：</a></p> 
<p id="%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A" rel="nofollow">事务的控制方法一：</a></p> 
<p id="%C2%A0%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A0%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A" rel="nofollow"> 事务的控制方法二：</a></p> 
<p id="%C2%A0%E4%B8%89%EF%BC%9A%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%89%EF%BC%9A%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9A" rel="nofollow"> 三：事务的四大特性：</a></p> 
<p id="%E5%9B%9B.%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%9B%9B.%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98%EF%BC%9A" rel="nofollow">四.并发事务问题：</a></p> 
<p id="%E4%BA%94.%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%BA%94.%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9A" rel="nofollow">五.事务的隔离级别：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80.%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B%EF%BC%9A">一.事务简介：</h2> 
<p><strong><span style="background-color:#ffd900;">事务 是一组操作的集合</span></strong>，它是一个<strong><span style="background-color:#ffd900;">不可分割的工作单位</span></strong>，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即<strong><span style="background-color:#ffd900;">这些操作要么同时成功，要么同时失败</span></strong>。</p> 
<p>比如，银行转账的操作就是一个典型的事务问题，举个例子：张三给李四转账1000块钱，张三银行账户的钱减少1000，而李四银行账户的钱要增加 1000。 这一组操作就必须在一个事务的范围内，要么都成功，要么都失败。</p> 
<p><img alt="" height="202" src="https://images2.imgbox.com/70/60/6iFZD3u3_o.png" width="1200"></p> 
<p>正常情况: 转账这个操作, 需要分为以下这么三步来完成 , 三步完成之后, 张三减少1000, 而李四 增加1000, 转账成功 :</p> 
<p><img alt="" height="315" src="https://images2.imgbox.com/93/d7/Ny5MofMV_o.png" width="1200"></p> 
<p>异常情况: 转账这个操作, 也是分为以下这么三步来完成 , 在执行第三步是报错了, 这样就导致张 三减少1000块钱, 而李四的金额没变, 这样就造成了数据的不一致, 就出现问题了：</p> 
<p> <img alt="" height="190" src="https://images2.imgbox.com/b6/9e/5KCgACYz_o.png" width="552"></p> 
<p>为了解决上述的问题，就需要通过数据的事务来完成，我们只需要在业务逻辑执行之前开启事务，执行 完毕后提交事务。如果执行过程中报错，则回滚事务，把数据恢复到事务开始之前的状态：</p> 
<p><img alt="" height="226" src="https://images2.imgbox.com/81/a3/YGgE9y8m_o.png" width="606"></p> 
<blockquote> 
 <p><strong><span style="background-color:#ff9900;">注意： 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐式的提交事务。</span></strong></p> 
</blockquote> 
<p>由于MySQL的事务自动提交的这种特性，就要求我们将设置修改为手动事务，以此来发现问题并且解决问题。</p> 
<h2 id="%E4%BA%8C.%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C%EF%BC%9A">二.事务操作：</h2> 
<h3 id="%E6%9C%AA%E6%8E%A7%E5%88%B6%E4%BA%8B%E5%8A%A1%EF%BC%9A">未控制事务：</h3> 
<ul><li>数据准备（这里我们根据上面的例子来说明问题）：</li></ul> 
<pre><code class="language-sql"># 数据准备
drop table if exists account;

create table account(
id int primary key auto_increment comment 'ID',
name varchar(10) comment'年龄',
money double(10,2) comment '余额'
)comment '账户表';

insert into account(name,money) values('张三',2000),('李四',2000);</code></pre> 
<p><img alt="" height="185" src="https://images2.imgbox.com/2e/84/e6JQKj0p_o.png" width="641"></p> 
<p>1).测试正常情况：</p> 
<pre><code class="language-sql"># 未控制事务

-- 1.查询张三余额
select * from account where name = '张三';

-- 2.张三的余额减少1000
update account set money = money - 1000 where name = '张三';

-- 3.李四的余额增加1000
update account set money = money + 1000 where name = '李四';</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="248" src="https://images2.imgbox.com/df/74/2rdubY4q_o.png" width="1200"> 2).异常情况（执行前要先将数据回复原样）：</p> 
<pre><code class="language-sql">-- 将数据回复原样
update account set money = 2000 where name = '张三' or name = '李四';

-- 1.查询张三余额
select * from account where name = '张三';

-- 2.张三的余额减少1000
update account set money = money - 1000 where name = '张三';

事务异常…… -- 异常情况，第三条SQL语句不会执行

-- 3.李四的余额增加1000
update account set money = money + 1000 where name = '李四';</code></pre> 
<p>我们把数据都恢复到2000， 然后再次一次性执行上述的SQL语句(出错了.... 这句话不符合SQL语 法,执行就会报错)，检查最终的数据情况, 发现数据在操作前后不一致了。 </p> 
<p>执行结果：</p> 
<p><img alt="" height="246" src="https://images2.imgbox.com/d7/4d/rNPabQti_o.png" width="1200"></p> 
<p>为了解决这样的问题，我们引入事务的控制方法：</p> 
<h3 id="%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A">事务的控制方法一：</h3> 
<pre><code class="language-sql"># 事务的控制方式一：

1). 查看/设置事务提交方式
SELECT @@autocommit ;-- 查看事务的提交方式
                     -- 1 为事务自动提交，0为事务手动提交

SET @@autocommit = 0 ;-- 修改事务的提交方式

2). 提交事务
COMMIT;

3). 回滚事务
ROLLBACK;</code></pre> 
<p>具体实现：</p> 
<pre><code class="language-sql">-- 1). 查看/设置事务提交方式
select @@autocommit ; -- 1 为事务自动提交，0为事务手动提交
set @@autocommit = 0 ;-- 将事务设置为手动提交

-- 1.查询张三余额
select * from account where name = '张三';

-- 2.张三的余额减少1000
update account set money = money - 1000 where name = '张三';

-- 3.李四的余额增加1000
update account set money = money + 1000 where name = '李四';

-- 2). 提交事务
commit;

-- 3). 回滚事务
rollback;</code></pre> 
<p><strong><span style="background-color:#ffd900;"> 注意：上述的这种方式，我们只是修改了事务的自动提交行为, 把默认的自动提交修改为了手动提 交, 此时我们执行的DML语句都不会提交, 只有执行到commit之后才会完成提交。</span></strong></p> 
<h3 id="%C2%A0%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A"> 事务的控制方法二：</h3> 
<pre><code class="language-sql"># 事务的控制方法二：

1). 开启事务
START TRANSACTION 或 BEGIN ;

2). 提交事务
COMMIT;

3). 回滚事务
ROLLBACK</code></pre> 
<p>具体实现：</p> 
<pre><code class="language-sql"># 控制事务的方式二：---&gt;控制之前要设置为自动提交
SET @@autocommit = 1 ;

-- 1). 开启事务
start transaction;

-- 1.查询张三余额
select * from account where name = '张三';

-- 2.张三的余额减少1000
update account set money = money - 1000 where name = '张三';

-- 3.李四的余额增加1000
update account set money = money + 1000 where name = '李四';

-- 2). 提交事务
commit;

-- 3). 回滚事务
rollback;</code></pre> 
<h2 id="%C2%A0%E4%B8%89%EF%BC%9A%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9A" style="background-color:transparent;"> 三：事务的四大特性：</h2> 
<blockquote> 
 <ul><li><strong><span style="background-color:#ffd900;"> 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</span></strong></li><li><strong><span style="background-color:#ffd900;">一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</span></strong></li><li><strong><span style="background-color:#ffd900;">隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立 环境下运行。</span></strong></li><li><strong><span style="background-color:#ffd900;">持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</span></strong></li></ul> 
 <p></p> 
 <p id="u043d3ca5">上面四个属性，可以简称为 ACID 。</p> 
 <p id="uabb94213">原子性（<strong>A</strong>tomicity，或称不可分割性）</p> 
 <p id="u60542068">一致性（<strong>C</strong>onsistency）</p> 
 <p id="u0bbd971d">隔离性（<strong>I</strong>solation，又称独立性）</p> 
 <p id="ub9b60a4f">持久性（<strong>D</strong>urability）。</p> 
</blockquote> 
<h2 id="%E5%9B%9B.%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98%EF%BC%9A">四.并发事务问题：</h2> 
<ul><li><strong> 赃读：一个事务读到另外一个事务还没有提交的数据。</strong><img alt="" height="459" src="https://images2.imgbox.com/be/06/Wp9KZC0z_o.png" width="1200"></li><li> <strong>不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。 </strong></li></ul> 
<p><strong> </strong><img alt="" height="353" src="https://images2.imgbox.com/45/c4/xBinrKHo_o.png" width="1200"></p> 
<ul><li><strong>幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据 已经存在，好像出现了 "幻影"。 </strong></li></ul> 
<p><img alt="" height="348" src="https://images2.imgbox.com/a0/00/1AXU2qBl_o.png" width="1200"></p> 
<h2 id="%E4%BA%94.%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9A">五.事务的隔离级别：</h2> 
<p>为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。主要有以下几种： </p> 
<p><img alt="" height="454" src="https://images2.imgbox.com/01/42/x4J3BpI3_o.png" width="1200"></p> 
<p>注意：X表示该级别已经解决了对应问题，√ 表示该级别没有解决这个问题</p> 
<blockquote> 
 <p><strong><span style="background-color:#ffd900;">读未提交【Read Uncommitted】：</span></strong> 在该隔离级别，所有的事务都可以看到其他事务没有提交的执行结果。（实际生产中不可能使用这种隔离级别的），但是相当于没有任何隔离性，也会有很多并发问题，如脏读，幻读，不可重复读等.</p> 
 <p><strong><span style="background-color:#ffd900;">读提交【Read Committed】：</span></strong>该隔离级别是大多数数据库的默认的隔离级别（不是 MySQL 默认的）。它满足了隔离的简单定义:一个事务只能看到其他的已经提交的事务所做的改变。这种隔离级别会引起不可重复读，即一个事务执行时，如果多次 select，可能得到不同的结果。</p> 
 <p><strong><span style="background-color:#ffd900;">可重复读【Repeatable Read】：</span></strong> 这是 <strong><span style="background-color:#ffd900;">MySQL 默认的隔离级别</span></strong>，它确保同一个事务，在执行中，多次读取操作数据时，会看到同样的数据行。但是有的数据库会有幻读问题。（MySQL不会）</p> 
 <p><strong><span style="background-color:#ffd900;">串行化【Serializable】: </span></strong>这是事务的最高隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决了幻读的问题。它在每个读的数据行上面加上共享锁。但是可能会导致超时和锁竞争（这种隔离级别太极端，实际生产基本不使用）</p> 
</blockquote> 
<p>具体操作：</p> 
<pre><code class="language-sql">-- 1). 查看事务隔离级别
SELECT @@TRANSACTION_ISOLATION;

-- 2). 设置事务隔离级别
SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL { READ UNCOMMITTED |
READ COMMITTED | REPEATABLE READ | SERIALIZABLE }
</code></pre> 
<p><strong><span style="background-color:#ffd900;">注意：事务隔离级别越高，数据越安全，但是性能越低。 </span></strong></p> 
<p><strong>结语：</strong> <strong>写博客不仅仅是为了分享学习经历，同时这也有利于我巩固知识点，总结该知识点，由于作者水平有限，对文章有任何问题的还请指出，接受大家的批评，让我改进。同时也希望读者们不吝啬你们的点赞+收藏+关注，你们的鼓励是我创作的最大动力！</strong></p> 
<p><img alt="" src="https://images2.imgbox.com/78/75/DnR0eJNf_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0bf0d6a2cc171c9148acccd8148aef97/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C语言】深度解析：动态内存管理的机制与实践</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0777a222c3cd80f3d29f8f21d65d450e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C语言】指针篇-一篇搞定不同类型指针变量-必读指南（3/5）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>