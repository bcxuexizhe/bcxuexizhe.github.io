<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C/C&#43;&#43; static关键字详解（最全解析，static是什么，static如何使用，static的常考面试题） - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/959fe034d9d74281a460f94236de2007/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="C/C&#43;&#43; static关键字详解（最全解析，static是什么，static如何使用，static的常考面试题）">
  <meta property="og:description" content="目录
一、前言
二、static关键字是什么？
三、static关键字修饰的对象是什么？ 四、C 语言中的 static
🍎static的C用法
🍉static的重点概念
🍐static修饰局部变量
💦static在修饰局部变量和函数的作用
🍓static修饰全局变量和函数
💦static在修饰全局变量和函数的作用
五、C&#43;&#43;中的 static
🍌static的C&#43;&#43;用法
🍊static在C&#43;&#43;中的重点概念
💦静态成员为所有类对象所共享，不属于某个具体的实例
💦静态成员变量必须在类外定义，定义时不添加static关键字
💦静态成员函数没有隐藏的this指针，不能访问任何非静态成员
💦访问静态成员变量的特殊方式
💦静态成员和类的普通成员一样，也有public、protected、private3种访问级别，也可以具有返回值
六、static面试题
七、static OJ面试题
八、共勉
一、前言 static，中文意思是静态的，作为C/C&#43;&#43;中常用关键字中的一个很重要的关键字，其中用法多样且复杂难以理解，用起来总是丈二和尚摸不着头脑，把我折磨的一头雾水（主要是博主很菜😂）。
也许大家对于这些知识都是一知半解（除过一些大佬），没有真正的搞透澈，一问我都会（这就是我），但是真正引用的时候，就会出现很多问题，而且百度的时候，大部分都讲得不是很清楚，所以为了帮助大家解决这个问题（实际上是自己不会），在这里进行一个全面的static介绍和总结。
本文将会循序渐进，先从C语言的static讲起，慢慢延申到C&#43;&#43;，从易到难，每一步都会举一些通俗易懂的例子帮助大家理解（帮助自己理解，怕忘记😂），好了开始整活！
二、static关键字是什么？ static是 C/C&#43;&#43;中的关键字之一，是常见的函数与变量（C&#43;&#43;中还包括类）的修饰符，它常被用来控制变量的存储方式和作用范围。 在众多高级语言中都有其作为关键字或函数出现，所以这也是应当被程序员熟知其各种含义的一个单词
三、static关键字修饰的对象是什么？ 1.局部变量
2.全局变量
3.函数
四、C 语言中的 static 🍎static的C用法 1️⃣: 修饰局部变量（称为静态局部变量）
2️⃣: 修饰全局变量（称为静态全局变量）
3️⃣: 修饰函数（称为静态函数）
🍉static的重点概念 1️⃣：在函数中声明变量时， static 关键字指定变量只初始化一次，并在之后调用该函数时保留其状态。
2️⃣：在声明变量时，变量具有静态持续时间，并且除非您指定另一个值。
3️⃣ ：在全局和/或命名空间范围 (在单个文件范围内声明变量或函数时) static 关键字指定变量或函数为内部链接，即外部文件无法引用该变量或函数。
4️⃣：static 关键字 没有赋值时，默认赋值为 0 5️⃣：static修饰局部变量时，会改变局部变量的存储位置，从而使得局部变量的生命周期变长。
⭐：接下来，将重点讲解上面三个作用个五点概念的理解，和应用
🍐static修饰局部变量 1️⃣：在函数中声明变量时， static 关键字指定变量只初始化一次，并在之后调用该函数时保留其状态。
5️⃣：static修饰局部变量时，会改变局部变量的存储位置，从而使得局部变量的生命周期变长。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-11-04T18:16:39+08:00">
    <meta property="article:modified_time" content="2023-11-04T18:16:39+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C/C&#43;&#43; static关键字详解（最全解析，static是什么，static如何使用，static的常考面试题）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80" rel="nofollow">一、前言</a></p> 
<p id="%C2%A0%E4%BA%8C%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BA%8C%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow"> 二、static关键字是什么？</a></p> 
<p id="%E4%B8%89%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%C2%A0" rel="nofollow">三、static关键字修饰的对象是什么？ </a></p> 
<p id="%C2%A0%E5%9B%9B%E3%80%81C%20%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%20static-toc" style="margin-left:0px;"><a href="#%C2%A0%E5%9B%9B%E3%80%81C%20%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%20static" rel="nofollow"> 四、C 语言中的 static</a></p> 
<p id="%C2%A0%F0%9F%8D%8Estatic%E7%9A%84C%E7%94%A8%E6%B3%95-toc" style="margin-left:40px;"><a href="#%C2%A0%F0%9F%8D%8Estatic%E7%9A%84C%E7%94%A8%E6%B3%95" rel="nofollow"> 🍎static的C用法</a></p> 
<p id="%C2%A0%F0%9F%8D%89static%E7%9A%84%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%C2%A0%F0%9F%8D%89static%E7%9A%84%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5" rel="nofollow"> 🍉static的重点概念</a></p> 
<p id="%C2%A0%F0%9F%8D%90static%E4%BF%AE%E9%A5%B0%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-toc" style="margin-left:40px;"><a href="#%C2%A0%F0%9F%8D%90static%E4%BF%AE%E9%A5%B0%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F" rel="nofollow"> 🍐static修饰局部变量</a></p> 
<p id="%C2%A0%F0%9F%92%A6static%E5%9C%A8%E4%BF%AE%E9%A5%B0%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8-toc" style="margin-left:80px;"><a href="#%C2%A0%F0%9F%92%A6static%E5%9C%A8%E4%BF%AE%E9%A5%B0%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8" rel="nofollow"> 💦static在修饰局部变量和函数的作用</a></p> 
<p id="%C2%A0%F0%9F%8D%93static%E4%BF%AE%E9%A5%B0%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%C2%A0%F0%9F%8D%93static%E4%BF%AE%E9%A5%B0%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0" rel="nofollow"> 🍓static修饰全局变量和函数</a></p> 
<p id="%F0%9F%92%A6static%E5%9C%A8%E4%BF%AE%E9%A5%B0%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8-toc" style="margin-left:80px;"><a href="#%F0%9F%92%A6static%E5%9C%A8%E4%BF%AE%E9%A5%B0%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8" rel="nofollow">💦static在修饰全局变量和函数的作用</a></p> 
<p id="%C2%A0%E4%BA%94%E3%80%81C%2B%2B%E4%B8%AD%E7%9A%84%20static-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BA%94%E3%80%81C%2B%2B%E4%B8%AD%E7%9A%84%20static" rel="nofollow"> 五、C++中的 static</a></p> 
<p id="%C2%A0%F0%9F%8D%8Cstatic%E7%9A%84C%2B%2B%E7%94%A8%E6%B3%95-toc" style="margin-left:40px;"><a href="#%C2%A0%F0%9F%8D%8Cstatic%E7%9A%84C%2B%2B%E7%94%A8%E6%B3%95" rel="nofollow"> 🍌static的C++用法</a></p> 
<p id="%F0%9F%8D%8Astatic%E5%9C%A8C%2B%2B%E4%B8%AD%E7%9A%84%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%F0%9F%8D%8Astatic%E5%9C%A8C%2B%2B%E4%B8%AD%E7%9A%84%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5" rel="nofollow">🍊static在C++中的重点概念</a></p> 
<p id="%C2%A0%F0%9F%92%A6%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%BA%E6%89%80%E6%9C%89%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%89%80%E5%85%B1%E4%BA%AB%EF%BC%8C%E4%B8%8D%E5%B1%9E%E4%BA%8E%E6%9F%90%E4%B8%AA%E5%85%B7%E4%BD%93%E7%9A%84%E5%AE%9E%E4%BE%8B-toc" style="margin-left:80px;"><a href="#%C2%A0%F0%9F%92%A6%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%BA%E6%89%80%E6%9C%89%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%89%80%E5%85%B1%E4%BA%AB%EF%BC%8C%E4%B8%8D%E5%B1%9E%E4%BA%8E%E6%9F%90%E4%B8%AA%E5%85%B7%E4%BD%93%E7%9A%84%E5%AE%9E%E4%BE%8B" rel="nofollow"> 💦静态成员为所有类对象所共享，不属于某个具体的实例</a></p> 
<p id="%C2%A0%F0%9F%92%A6%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%BF%85%E9%A1%BB%E5%9C%A8%E7%B1%BB%E5%A4%96%E5%AE%9A%E4%B9%89%EF%BC%8C%E5%AE%9A%E4%B9%89%E6%97%B6%E4%B8%8D%E6%B7%BB%E5%8A%A0static%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:80px;"><a href="#%C2%A0%F0%9F%92%A6%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%BF%85%E9%A1%BB%E5%9C%A8%E7%B1%BB%E5%A4%96%E5%AE%9A%E4%B9%89%EF%BC%8C%E5%AE%9A%E4%B9%89%E6%97%B6%E4%B8%8D%E6%B7%BB%E5%8A%A0static%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow"> 💦静态成员变量必须在类外定义，定义时不添加static关键字</a></p> 
<p id="%C2%A0%F0%9F%92%A6%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%B2%A1%E6%9C%89%E9%9A%90%E8%97%8F%E7%9A%84this%E6%8C%87%E9%92%88%EF%BC%8C%E4%B8%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E4%BB%BB%E4%BD%95%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98-toc" style="margin-left:80px;"><a href="#%C2%A0%F0%9F%92%A6%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%B2%A1%E6%9C%89%E9%9A%90%E8%97%8F%E7%9A%84this%E6%8C%87%E9%92%88%EF%BC%8C%E4%B8%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E4%BB%BB%E4%BD%95%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98" rel="nofollow"> 💦静态成员函数没有隐藏的this指针，不能访问任何非静态成员</a></p> 
<p id="%C2%A0%F0%9F%92%A6%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E6%AE%8A%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%C2%A0%F0%9F%92%A6%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E6%AE%8A%E6%96%B9%E5%BC%8F" rel="nofollow"> 💦访问静态成员变量的特殊方式</a></p> 
<p id="%C2%A0%F0%9F%92%A6%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%92%8C%E7%B1%BB%E7%9A%84%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E4%B8%80%E6%A0%B7%EF%BC%8C%E4%B9%9F%E6%9C%89public%E3%80%81protected%E3%80%81private3%E7%A7%8D%E8%AE%BF%E9%97%AE%E7%BA%A7%E5%88%AB%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%85%B7%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC-toc" style="margin-left:80px;"><a href="#%C2%A0%F0%9F%92%A6%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%92%8C%E7%B1%BB%E7%9A%84%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E4%B8%80%E6%A0%B7%EF%BC%8C%E4%B9%9F%E6%9C%89public%E3%80%81protected%E3%80%81private3%E7%A7%8D%E8%AE%BF%E9%97%AE%E7%BA%A7%E5%88%AB%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%85%B7%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC" rel="nofollow"> 💦静态成员和类的普通成员一样，也有public、protected、private3种访问级别，也可以具有返回值</a></p> 
<p id="%E5%85%AD%E3%80%81static%E9%9D%A2%E8%AF%95%E9%A2%98-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81static%E9%9D%A2%E8%AF%95%E9%A2%98" rel="nofollow">六、static面试题</a></p> 
<p id="%E4%B8%83%E3%80%81static%20OJ%E9%9D%A2%E8%AF%95%E9%A2%98-toc" style="margin-left:0px;"><a href="#%E4%B8%83%E3%80%81static%20OJ%E9%9D%A2%E8%AF%95%E9%A2%98" rel="nofollow">七、static OJ面试题</a></p> 
<p id="%E5%85%AB%E3%80%81%E5%85%B1%E5%8B%89-toc" style="margin-left:0px;"><a href="#%E5%85%AB%E3%80%81%E5%85%B1%E5%8B%89" rel="nofollow">八、共勉</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80"><span style="color:#0d0016;">一、前言</span></h2> 
<blockquote> 
 <p>        <span style="color:#ed7976;"><strong>static</strong></span>，中文意思是<span style="color:#ed7976;"><strong>静态的</strong></span>，作为<strong><span style="background-color:#fbd4d0;">C/C++</span></strong>中常用关键字中的一个很重要的<strong><span style="background-color:#fbd4d0;">关键字</span></strong>，其中用法多样且复杂难以理解，用起来总是丈二和尚摸不着头脑，把我折磨的一头雾水（主要是博主很菜😂）。</p> 
 <p>        也许大家对于这些知识都是一知半解（除过一些大佬），没有真正的搞透澈，一问我都会（这就是我），但是真正引用的时候，就会出现很多问题，而且百度的时候，大部分都讲得不是很清楚，所以为了帮助大家解决这个问题（实际上是自己不会），在这里进行一个全面的static介绍和总结。</p> 
 <p>    <span style="color:#0d0016;"><strong>    本文将会循序渐进，</strong></span><span style="color:#ed7976;"><strong>先从</strong></span><span style="color:#956fe7;"><strong>C语言</strong></span><span style="color:#ed7976;"><strong>的static讲起，慢慢延申到</strong></span><span style="color:#956fe7;"><strong>C++</strong></span><span style="color:#0d0016;"><strong>，从易到难，每一步都会举一些通俗易懂的例子帮助大家理解</strong></span>（帮助自己理解，怕忘记😂），好了开始整活！</p> 
 <p class="img-center"><img alt="" height="335" src="https://images2.imgbox.com/51/cd/r2GgqSFu_o.png" width="414"></p> 
</blockquote> 
<h2 id="%C2%A0%E4%BA%8C%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span style="color:#0d0016;"><strong> 二、static关键字是什么？</strong></span></h2> 
<blockquote> 
 <p>       <span style="color:#ed7976;"><strong> static</strong></span>是 C/C++中的<strong>关键字</strong>之一，<strong>是常见的函数与变量（C++中还包括类）的修饰符</strong>，它常被用来<span style="color:#0d0016;"><strong><span style="background-color:#fbd4d0;">控制变量的存储方式和作用范围</span></strong></span>。 在众多高级语言中都有其作为关键字或函数出现，所以这也是应当被程序员熟知其各种含义的一个单词</p> 
 <p class="img-center"><img alt="" height="632" src="https://images2.imgbox.com/42/4d/CsCUrMkM_o.png" width="1009"></p> 
 <p></p> 
</blockquote> 
<h2 id="%E4%B8%89%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%C2%A0"><span style="color:#0d0016;"><strong>三、static关键字修饰的对象是什么？ </strong></span></h2> 
<blockquote> 
 <p><strong>1.局部变量</strong></p> 
 <p><strong>2.全局变量</strong></p> 
 <p><strong>3.函数</strong></p> 
</blockquote> 
<h2 id="%C2%A0%E5%9B%9B%E3%80%81C%20%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%20static"><span style="color:#0d0016;"><strong> 四、C 语言中的 static</strong></span></h2> 
<h3 id="%C2%A0%F0%9F%8D%8Estatic%E7%9A%84C%E7%94%A8%E6%B3%95"><span style="color:#0d0016;"><strong> 🍎static的C用法</strong></span></h3> 
<blockquote> 
 <p>    <strong>1️⃣: 修饰局部变量（称为静态局部变量）</strong></p> 
 <p>    <strong>2️⃣:</strong> <strong>修饰全局变量（称为静态全局变量）</strong></p> 
 <p>    <strong>3️⃣: 修饰函数（称为静态函数）</strong></p> 
</blockquote> 
<h3 id="%C2%A0%F0%9F%8D%89static%E7%9A%84%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5"><span style="color:#0d0016;"><strong> 🍉static的重点概念</strong></span></h3> 
<blockquote> 
 <p><strong>1️⃣：在函数中声明变量时， <span style="color:#be191c;">static 关键字指定变量只初始化一次</span>，并在之后调用该函数时保留其状态。<br> 2️⃣：在声明变量时，<span style="color:#be191c;">变量具有静态持续时间</span>，并且除非您指定另一个值。<br> 3️⃣ ：在全局和/或命名空间范围 (在单个文件范围内声明变量或函数时) <span style="color:#be191c;">static 关键字指定变量或函数为内部链接</span>，即外部文件无法引用该变量或函数。<br> 4️⃣：<span style="color:#be191c;">static 关键字 没有赋值时，默认赋值为 0 </span></strong></p> 
 <p><strong>5️⃣：static修饰局部变量时，<span style="color:#be191c;">会改变局部变量的存储位置</span>，从而使得局部变量的生命周期变长。</strong><br><br><strong><span style="color:#0d0016;"><span style="background-color:#fbd4d0;">⭐：接下来，将重点讲解上面三个作用个五点概念的理解，和应用</span></span></strong></p> 
</blockquote> 
<h3 id="%C2%A0%F0%9F%8D%90static%E4%BF%AE%E9%A5%B0%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span style="color:#0d0016;"><strong> 🍐static修饰局部变量</strong></span></h3> 
<blockquote> 
 <p><strong>1️⃣：在函数中声明变量时， <span style="color:#be191c;">static 关键字指定变量只初始化一次</span>，并在之后调用该函数时保留其状态。<br> 5️⃣：static修饰局部变量时，<span style="color:#be191c;">会改变局部变量的存储位置</span>，从而使得局部变量的生命周期变长。</strong></p> 
 <p></p> 
 <p>接下来用们用一段代码来进行解析：</p> 
 <pre><code class="hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void test()
{
    int x = 0;
	x++;
	printf("%d ", x);
}
int main()
{
    int i = 0;
	printf("%d\n", i);
	while (i &lt; 10)
	{
		test();
		i++;
	}
	return 0;
}</code></pre> 
 <p>        这段代码中每次调用test（）函数时创建局部变量x赋值为 0，每次局部变量x出了test（）函数后都会自行销毁。<br>         所以可以很容易得到输出结果为：1 1 1 1 1 1 1 1 1 1</p> 
 <hr> 
 <p>        接着我们用上<span style="color:#0d0016;"><strong>static关键字</strong></span>来修饰 <strong> test（）</strong>函数中的局部变量<strong> x</strong>：</p> 
 <pre><code class="hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void test()
{
    static int x = 0;
	x++;
	printf("%d ", x);
}
int main()
{
    int i = 0;
	while (i &lt; 10)
	{
		test();
		i++;
	}
	return 0;
}</code></pre> 
 <p>        输出结果变成了：1 2 3 4 5 6 7 8 9 10<br>         <strong><span style="background-color:#fbd4d0;">原因是static修饰了局部变量x，令局部变量x变成静态的，<span style="color:#0d0016;">且只能初始化一次</span>，使得每次test（）函数结束时局部变量x都不销毁，再次进入test（）函数时则保留原有数值运行，因此x++数值越来越大。</span></strong><br><img alt="" height="605" src="https://images2.imgbox.com/32/93/21jTwNfq_o.png" width="1200"></p> 
 <p></p> 
 <p><strong><span style="color:#0d0016;">⭐</span>总结：</strong></p> 
 <p><span style="color:#0d0016;"><strong><span style="background-color:#fbd4d0;">（1）static关键字修饰局部变量不改变作用域，但是生命周期变长。</span></strong></span></p> 
 <p><strong><span style="color:#0d0016;"><span style="background-color:#fbd4d0;">（2）本质上，static关键字修饰局部变量，改变了局部变量的存储位置，因为存储位置的差异，使得执行效果不一样。普通的局部变量放在栈区，这种局部变量进入作用域创建，出作用域释放。局部变量被static修饰后成为静态局部变量，这种变量放在静态区，创建好后，直到程序结束后才释放。</span></span></strong><br>  </p> 
</blockquote> 
<blockquote> 
 <p><strong>4️⃣：<span style="color:#be191c;">static 关键字 没有赋值时，默认赋值为 0 </span></strong></p> 
 <p><br> 接下来用们用一段代码来进行解析：</p> 
 <pre><code class="hljs">int a;
int main()
{
	char str[10];
	printf("integer: %d; string: (begin)%s(end)\n", a, str);
	return 0;
}</code></pre> 
 <p>        在这段代码中，我们并没有对全局变量 a 和字符串数组 str 进行赋值，所以在输出时会出现<span style="color:#0d0016;"><strong>随机值的现象</strong></span>。所以很容易得到如下的结果：</p> 
 <p><span style="color:#0d0016;"><strong>输出：</strong></span></p> 
 <pre><code class="hljs">integer: 0; string: (begin)烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫攼l(end)</code></pre> 
 <p><strong><span style="color:#fe2c24;">⚠ 注意：</span>a 输出为 0 是因为 此时 a 是全局变量，也存放在静态区，所以可以默认值为 0 .</strong></p> 
 <hr> 
 <p><strong>        接着我们用上 <span style="color:#0d0016;">static关键字</span><span style="color:#0d0016;"> </span>来修饰 <span style="color:#0d0016;">全局变量 a 和字符串数组 str </span></strong></p> 
 <pre><code class="hljs">static int a;
int main()
{
	static char str[10];
	printf("integer: %d; string: (begin)%s(end)\n", a, str);
	return 0;
}</code></pre> 
 <p><strong><span style="color:#0d0016;">  输出：</span></strong></p> 
 <pre><code class="hljs">integer: 0; string: (begin)(end)
</code></pre> 
 <p><strong>       <span style="color:#0d0016;">⭐</span>总结： </strong></p> 
 <p><strong>         <span style="color:#0d0016;"><span style="background-color:#fbd4d0;">static的另一个作用是默认初始化为0。其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加‘\0’;太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是 ‘\0’。</span></span></strong><br>  </p> 
</blockquote> 
<h4 id="%C2%A0%F0%9F%92%A6static%E5%9C%A8%E4%BF%AE%E9%A5%B0%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span style="color:#0d0016;"><strong> 💦static在修饰局部变量和函数的作用</strong></span></h4> 
<blockquote> 
 <p> <strong><span style="color:#0d0016;">⭐作用：</span></strong></p> 
 <p><strong><span style="color:#0d0016;">        保持变量内容的持久</span></strong></p> 
 <ul><li><span style="color:#0d0016;">static的第一个作用是</span><span style="color:#be191c;"><strong>保持变量内容的持久</strong></span><span style="color:#0d0016;">，即static变量中的记忆功能和全局生存期。</span></li><li><span style="color:#0d0016;">存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。之后再次运行到含有 static 关键字的初始化语句时不会再执行该语句。共有两种变量存储在静态存储区：全局变量和 static 变量，只不过和全局变量比起来，static 可以控制变量的可见范围。</span></li></ul> 
</blockquote> 
<h3 id="%C2%A0%F0%9F%8D%93static%E4%BF%AE%E9%A5%B0%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0"><span style="color:#0d0016;"><strong> 🍓static修饰全局变量和函数</strong></span></h3> 
<blockquote> 
 <p><strong>3️⃣ ：在全局和/或命名空间范围 (在单个文件范围内声明变量或函数时) <span style="color:#be191c;">static 关键字指定变量或函数为内部链接</span>，即外部文件无法引用该变量或函数。</strong><br><br>         针对上面这个概念的理解我们一次来解析以下：<br> 1. 首先说一下全局变量，全局变量的作用域十分的广，只要在一个源文件中定义后，这个程序中的所有源文件、对象以及函数都可以调用，生命周期更是贯穿整个程序。文件中的全局变量想要被另一个文件使用时就需要进行<strong>外部声明</strong>（以下用extern关键字进行声明）。----<span style="color:#ed7976;"><strong>-</strong></span><span style="color:#be191c;"><strong>也即是说全局变量既可以在源文件中使用，也可以在其他文件中使用（只需要使用extern外部链接以下即可）</strong></span></p> 
 <p>2. static修饰<strong><span style="color:#956fe7;">全局变量和函数</span></strong>时，<strong><span style="color:#be191c;">会改变全局变量和函数的链接属性-------变为只能在内部链接，从而使得全局变量的作用域变小。</span></strong><br><br>   接着我们用代码进行解析：</p> 
 <p class="img-center"><img alt="" height="309" src="https://images2.imgbox.com/89/e3/dotnYCEa_o.png" width="878"></p> 
 <p><br> 首先，在Hello.c文件中定义一个全局变量 char a 和函数 PrintfHello()，之后在test.c文件中进行extern 进行外部链接，运行代码：</p> 
 <p></p> 
 <p class="img-center"><img alt="" height="428" src="https://images2.imgbox.com/0b/bd/PJ9vfmtp_o.png" width="874"></p> 
 <p><br> 之后我们进入正题 <span style="color:#be191c;"><strong>在全局变量和函数之前用 static进行修饰</strong></span>，看看效果：</p> 
 <p class="img-center"><img alt="" height="606" src="https://images2.imgbox.com/59/40/1N5s5ZKG_o.png" width="939"></p> 
 <p><br>         会发现生成错误，<span style="color:#be191c;"><strong>无法解析外部符号a和PrintfHello()等</strong></span>，全局变量a和<span style="color:#0d0016;">PrintfHello()</span>不能被test.c文件调用了。所以我们可以很容易看出<span style="color:#ed7976;"><strong>static修饰后让全局变量a和PrintfHello()的作用域变小了，令全局变量a和PrintfHello()无法被其他文件调用。</strong></span></p> 
 <p></p> 
 <p><strong><span style="color:#0d0016;">⭐</span>总结：</strong></p> 
 <p>1. <span style="color:#0d0016;"><strong>全局变量和函数</strong></span>本身是具有<span style="color:#0d0016;"><strong>外部链接属性</strong></span>的，在Hello.c文件中定义的全局变量和函数，在test.c文件中可以通过<span style="color:#0d0016;"><strong>【链接】</strong></span>来使用；</p> 
 <p>2. 但如果全局变量被static修饰，那这个外部链接属性就会被修改成<span style="color:#0d0016;"><strong>内部链接属性</strong></span>，<span style="color:#be191c;"><strong>此时这个全局变量就只能在自己的源文件中使用；</strong></span></p> 
 <p></p> 
</blockquote> 
<h4 id="%F0%9F%92%A6static%E5%9C%A8%E4%BF%AE%E9%A5%B0%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span style="color:#0d0016;">💦static在修饰全局变量和函数的作用</span></h4> 
<blockquote> 
 <p><strong><span style="color:#0d0016;">⭐作用：</span></strong><br>         如果加了 static，就会对其它源文件隐藏。例如在 a 和 printHello 的定义前加上 static，main.c 就看不到它们了。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。<span style="color:#be191c;"><strong>static 可以修饰函数和变量，将其对其他源文件隐藏起来，从而避免命名冲突。对于函数来讲，static 的作用仅限于该隐藏功能。</strong></span></p> 
 <p></p> 
</blockquote> 
<h2 id="%C2%A0%E4%BA%94%E3%80%81C%2B%2B%E4%B8%AD%E7%9A%84%20static"><span style="color:#0d0016;"><strong> 五、C++中的 static</strong></span></h2> 
<blockquote> 
 <p>        本小节主要介绍在 <span style="color:#be191c;"><strong>C++中引入了面向对象的特性（类）</strong></span>之后，static关键字的一些用途。当然 C++ 是兼容 C 语言的，所以<span style="color:#be191c;"><strong>C语言中的 static 在C++中也是成立的</strong></span>。</p> 
</blockquote> 
<h3 id="%C2%A0%F0%9F%8D%8Cstatic%E7%9A%84C%2B%2B%E7%94%A8%E6%B3%95"><span style="color:#0d0016;"><strong> 🍌static的C++用法</strong></span></h3> 
<blockquote> 
 <p> 声明为static的类成员称为类的静态成员，分为如下两类：</p> 
 <ul><li>用static修饰的<span style="color:#956fe7;">成员变量</span>，称之为<span style="color:#fe2c24;"><strong>静态成员变量</strong></span></li><li>用static修饰的<span style="color:#956fe7;">成员函数</span>，称之为<span style="color:#fe2c24;"><strong>静态成员函数</strong></span></li></ul> 
 <p><strong><span style="color:#956fe7;">静态的成员变量一定要在类外进行初始化</span></strong></p> 
</blockquote> 
<h3 id="%F0%9F%8D%8Astatic%E5%9C%A8C%2B%2B%E4%B8%AD%E7%9A%84%E9%87%8D%E7%82%B9%E6%A6%82%E5%BF%B5"><span style="color:#0d0016;">🍊static在C++中的重点概念</span></h3> 
<blockquote> 
 <p><strong>1️⃣：静态成员为<span style="color:#be191c;">所有类对象所共享，不属于某个具体的实例</span><br> 2️⃣：静态成员变量<span style="color:#be191c;">必须在类外定义，定义时不添加static关键字</span><br> 3️⃣：静态成员函数<span style="color:#be191c;">没有隐藏的this指针，不能访问任何非静态成员</span><br> 4️⃣：访问静态成员变量的特殊方式</strong></p> 
 <p><strong>5️⃣：静态成员和类的普通成员一样，<span style="color:#be191c;">也有public、protected、private3种访问级别，也可以具有返回值</span></strong><br><br><strong><span style="color:#0d0016;"><span style="background-color:#fbd4d0;">⭐：接下来，将重点讲解上面三个作用个五点概念的理解，和应用</span></span></strong></p> 
 <p></p> 
</blockquote> 
<h4 id="%C2%A0%F0%9F%92%A6%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%BA%E6%89%80%E6%9C%89%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%89%80%E5%85%B1%E4%BA%AB%EF%BC%8C%E4%B8%8D%E5%B1%9E%E4%BA%8E%E6%9F%90%E4%B8%AA%E5%85%B7%E4%BD%93%E7%9A%84%E5%AE%9E%E4%BE%8B"><span style="color:#0d0016;"><strong> 💦静态成员为所有类对象所共享，不属于某个具体的实例</strong></span></h4> 
<blockquote> 
 <p>请看如下代码：</p> 
 <pre><code class="hljs">class A
{
private:
	static int _n;
	int _k;
	char _a;
};
int main()
{
	cout &lt;&lt; sizeof(A) &lt;&lt; endl; //8
	return 0;
}</code></pre> 
 <p>        这里的运行结果为<span style="color:#0d0016;"><strong>8</strong></span>，这里的计算规则是按照C语言那套计算结构体大小的规则。<span style="color:#be191c;"><strong>并没有把我静态成员变量_n考虑进去，因为静态成员变量属于整个类，是类的所以对象，所以静态变量成员不计入总大小。</strong></span><br>  </p> 
</blockquote> 
<h4 id="%C2%A0%F0%9F%92%A6%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%BF%85%E9%A1%BB%E5%9C%A8%E7%B1%BB%E5%A4%96%E5%AE%9A%E4%B9%89%EF%BC%8C%E5%AE%9A%E4%B9%89%E6%97%B6%E4%B8%8D%E6%B7%BB%E5%8A%A0static%E5%85%B3%E9%94%AE%E5%AD%97"><span style="color:#0d0016;"><strong> 💦静态成员变量必须在类外定义，定义时不添加static关键字</strong></span></h4> 
<blockquote> 
 <pre><code class="hljs">class A
{
private:
	//声明
	static int _n;
	static int _k;
};
//定义
int A::_n = 0;
int A::_k = 0;</code></pre> 
</blockquote> 
<h4 id="%C2%A0%F0%9F%92%A6%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%B2%A1%E6%9C%89%E9%9A%90%E8%97%8F%E7%9A%84this%E6%8C%87%E9%92%88%EF%BC%8C%E4%B8%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E4%BB%BB%E4%BD%95%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span style="color:#0d0016;"><strong> 💦静态成员函数没有隐藏的this指针，不能访问任何非静态成员</strong></span></h4> 
<blockquote> 
 <pre><code class="hljs">class A
{
public:
	static void Func()
	{
		cout &lt;&lt; ret &lt;&lt; endl;  // err错误，访问了非静态成员，因为无this指针
		cout &lt;&lt; _k &lt;&lt; endl; //正确
	}
private:
	//声明
	int ret = 0;
	static int _k;
};
//定义
int A::_k = 0;</code></pre> 
</blockquote> 
<h4 id="%C2%A0%F0%9F%92%A6%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E6%AE%8A%E6%96%B9%E5%BC%8F"><span style="color:#0d0016;"><strong> 💦访问静态成员变量的特殊方式</strong></span></h4> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong><span style="background-color:#fbd4d0;">当静态成员变量为公有时，可有如下三种进行访问：</span></strong></span></p> 
 <ol><li>通过对象.静态成员来访问</li><li>通过类名::静态成员来行访问</li><li>通过匿名对象突破类域进行访问</li></ol> 
 <pre><code class="hljs">class A
{
public:
// 声明
	static int _k;
};
// 定义
int A::_k = 0;
int main()
{
	A a;
	cout &lt;&lt; a._k &lt;&lt; endl;  //通过对象.静态成员来访问
	cout &lt;&lt; A::_k &lt;&lt; endl; //通过类名::静态成员来行访问
	cout &lt;&lt; A()._k &lt;&lt; endl;//通过匿名对象突破类域进行访问
	return 0;
}</code></pre> 
 <p><span style="color:#0d0016;"><strong><span style="background-color:#fbd4d0;">当静态成员变量变成私有时，可采用如下方式：</span></strong></span></p> 
 <ol><li>通过对象.静态成员函数来访问</li><li>通过类名::静态成员函数来行访问</li><li>通过匿名对象调用成员函数进行访问</li></ol> 
 <pre><code class="hljs">class A
{
public:
	static int GetK()
	{
		return _k;
	}
private:
	static int _k;
};
int A::_k = 0;
int main()
{
	A a;
	cout &lt;&lt; a.GetK() &lt;&lt; endl; //通过对象.静态成员函数来访问
	cout &lt;&lt; A::GetK() &lt;&lt; endl;//通过类名::静态成员函数来行访问
	cout &lt;&lt; A().GetK &lt;&lt; endl; //通过匿名对象调用成员函数进行访问
	return 0;
}</code></pre> 
</blockquote> 
<h4 id="%C2%A0%F0%9F%92%A6%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%92%8C%E7%B1%BB%E7%9A%84%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E4%B8%80%E6%A0%B7%EF%BC%8C%E4%B9%9F%E6%9C%89public%E3%80%81protected%E3%80%81private3%E7%A7%8D%E8%AE%BF%E9%97%AE%E7%BA%A7%E5%88%AB%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%85%B7%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC"> <span style="color:#0d0016;"><strong>💦</strong>静态成员和类的普通成员一样，也有public、protected、private3种访问级别，也可以具有返回值</span></h4> 
<blockquote> 
 <ul><li><span style="color:#fe2c24;"><strong>1、静态成员函数可以调用非静态成员函数吗？</strong></span></li></ul> 
 <p><u>答案：不可以，因为静态成员函数是没有this指针的，无法调用非静态成员函数。</u><br>  </p> 
 <ul><li>2、非静态成员函数可以调用类的静态成员函数吗？</li></ul> 
 <p><u>答案：可以，因为静态成员为所有类对象所共享，不受访问限制</u><br>  </p> 
</blockquote> 
<h2 id="%E5%85%AD%E3%80%81static%E9%9D%A2%E8%AF%95%E9%A2%98"><span style="color:#0d0016;"><strong>六、static面试题</strong></span></h2> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>搞清楚了static的特性，来看几道道面试题：</strong></span></p> 
 <p></p> 
 <p><span style="color:#0d0016;"><strong><span style="background-color:#fbd4d0;">面试题1：</span></strong></span></p> 
 <p><span style="color:#511b78;">实现一个类，计算中程序中创建出了多少个类对象。</span></p> 
 <ul><li>思路：</li></ul> 
 <p>假设命名该类为A，那么A类型的对象一定是经过<span style="color:#956fe7;"><strong>构造函数或拷贝构造</strong></span>的，那么我们就可以分别定义<span style="color:#956fe7;"><strong>两个静态成员变量</strong></span>，在构造函数和拷贝构造里++变量，这样，每创建一次对象，变量就++一次，自然就好求了。如下：</p> 
 <pre><code class="hljs">class A
{
public:
	A()
	{
		++_count1;
	}
	A(const A&amp; aa)
	{
		++_count2;
	}
	static int GetCount1()
	{
		return _count1;
	}
	static int GetCount2()
	{
		return _count2;
	}
private:
	static int _count1; 
	static int _count2;
};
int A::_count1 = 0;
int A::_count2 = 0;
A Func(A a)
{
	A copy(a);
	return copy;
}
int main()
{
	A a1;
	A a2 = Func(a1);
 
	cout &lt;&lt; a1.GetCount1() &lt;&lt; endl; // 1
	cout &lt;&lt; a2.GetCount2() &lt;&lt; endl; // 3
	cout &lt;&lt; A::GetCount1() + A::GetCount2() &lt;&lt; endl; // 4
}</code></pre> 
 <ul><li>分析：</li></ul> 
 <p>        A a1 调用了一次构造函数；a2 = Func(a1)，调用了一次拷贝构造；A copy(a)，调用了一次拷贝构造；return copy 返回的时候，copy会销毁，所以提前需要进行拷贝构造进行拷贝保存 。所用总共四次。</p> 
 <p></p> 
</blockquote> 
<h2 id="%E4%B8%83%E3%80%81static%20OJ%E9%9D%A2%E8%AF%95%E9%A2%98"><span style="color:#0d0016;"><strong>七、static OJ面试题</strong></span></h2> 
<blockquote> 
 <p> 1、求1+2+3+...+n</p> 
 <ul><li><span style="background-color:#fbd4d0;">题目：</span></li></ul> 
 <p><img alt="" height="590" src="https://images2.imgbox.com/b8/e4/IafvfkAL_o.png" width="917"></p> 
 <p></p> 
 <ul><li><span style="color:#0d0016;"><strong><span style="background-color:#fbd4d0;">链接直达：</span></strong></span></li></ul> 
 <p><a class="link-info" href="https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&amp;tqId=11200&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" rel="nofollow" title=" 求1+2+3+...+n"> 求1+2+3+...+n</a></p> 
 <ul><li>思路：</li></ul> 
 <p>这里我可以自己单独定义一个Sum类，专门进行求和，我定义n个对象，它就会调用n次构造函数，此时就可以在构造函数内实现累加，为了实现累加，<strong><span style="color:#fe2c24;">需要在Sum类里设定两个静态成员变量，</span></strong>因为静态成员属于整个类，以此确保每次访问的变量都是同一个，最后，返回累加的值即可。</p> 
 <ul><li>注意：</li></ul> 
 <p>如若不支持变长数组，我们只能用new来完成，在获取返回的累加值时，可以单独在类内写个函数返回私有成员变量，该函数可以是静态成员函数，这样就可以指定类域去调用，不需要借助对象了。也可以借助友元。</p> 
 <ul><li>代码：</li></ul> 
 <pre><code class="hljs">#include&lt;iostream&gt;
using namespace std;
class Sum
{
public:
    Sum() //构造函数内实现累加
    {
        _ret += _i;
        _i++;
    }
    int GetRet()  //static int GetRet() 也可以是静态成员函数
    {
        return _ret;  //返回获取的求和值
    }
private:
    //静态成员变量类内声明
    static int _i;
    static int _ret;
};
//静态成员变量类外定义
int Sum::_i = 1;
int Sum::_ret = 0;
class Solution {
public:
    int Sum_Solution(int n) {
        Sum a[n]; //支持变长数组可以这样写
        return a[1].GetRet(); //注意通过对象去调用成员函数
        //return Sum::GetRet();静态成员函数支持用类域访问
        /* 如若不支持变长数组，就用new来开辟n个空间
        Sum* ptr = new Sum[n];
        return ptr-&gt;GetRet(); 
        */
    }
};</code></pre> 
 <p></p> 
</blockquote> 
<h2 id="%E5%85%AB%E3%80%81%E5%85%B1%E5%8B%89"><span style="color:#0d0016;"><strong>八、共勉</strong></span></h2> 
<p>         <strong>以下就是我对<span style="color:#fe2c24;">C/C++ static关键字</span>的理解，如果有不懂和发现问题的小伙伴，请在评论区说出来哦，同时我还会继续更新对<span style="color:#fe2c24;">C++ 类和对象</span>的理解<span style="color:#956fe7;">，请持续关注我哦！！！</span></strong><span style="color:#956fe7;">  </span></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d1/5c/n0v2hEl7_o.png"> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/507bf8b5489cdc3682e91a42030dd620/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">微信小程序完整项目实战(前端&#43;后端)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/17aeb2cba1aa1b8bc1fe63ea29e3a01d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【JavaSE语法】类和对象（一）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>