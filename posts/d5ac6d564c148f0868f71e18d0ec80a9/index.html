<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【前端】为什么postman可以请求成功，并且GET请求没有问题，但是POST访问却是403？ - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/d5ac6d564c148f0868f71e18d0ec80a9/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【前端】为什么postman可以请求成功，并且GET请求没有问题，但是POST访问却是403？">
  <meta property="og:description" content="向后端发起GET请求成功了，POST请求却发生了403，然而再尝试Postman发送POST请求却能成功，为什么？记录一下整体过程 问题与结论解决过程 为什么GET请求可以？为什么Postman请求可以？ 问题与结论 今天和后端联调，发现了一个问题，发起的get请求没有问题，post请求都被拦截了，403forbidden，后端觉得是前端配置问题，于是用 postman发送了请求，并且成功了，这是为什么呢？
先说结论确定了前端的配置没有问题后，查看了后端代码与历史修改记录（曾经是没问题的），发现后端修改了一行代码导致的，config.addAllowedOrigin(&#34;*&#34;)，据后端所说，他们是重写了cors的拦截策略，因为安全性，所以删除了这行代码。
问题结论：没有允许非同origin下的请求
但是该行代码，同时引起了我的思考，为什么postman可以？为什么同样的GET请求可以，但是POST请求不可以？
解决过程 首先，判断并非是前端跨域问题。
在Webpack中设置反向代理通常是为了解决开发环境中的跨域请求问题。可以使用webpack-dev-server的反向代理功能来实现。且前端若配置失败，浏览器返回的错误是这样的。
于是应该是后端做了什么相关的策略。后端当时使用postman，发现并无问题。
因为之前项目是没问题的，所以去查了修改记录，所以发现是为了安全考虑，少了那一行代码。
贴上修改后的代码
import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.cors.CorsConfiguration; import org.springframework.web.cors.UrlBasedCorsConfigurationSource; import org.springframework.web.filter.CorsFilter; @Configuration public class CorsConfig { @Bean public CorsFilter corsFilter(){ //1.添加CORS配置信息 CorsConfiguration config = new CorsConfiguration(); //1) 允许的域,不要写*，否则cookie就无法使用了 // config.addAllowedOrigin(&#34;*&#34;); //这里填写请求的前端服务器 config.addAllowedOriginPattern(&#34;*&#34;); //2) 是否发送Cookie信息 config.setAllowCredentials(true); //3) 允许的请求方式 config.addAllowedMethod(&#34;OPTIONS&#34;); config.addAllowedMethod(&#34;HEAD&#34;); config.addAllowedMethod(&#34;GET&#34;); config.addAllowedMethod(&#34;PUT&#34;); config.addAllowedMethod(&#34;POST&#34;); config.addAllowedMethod(&#34;DELETE&#34;); config.addAllowedMethod(&#34;PATCH&#34;); //4) 允许的头信息 config.addAllowedHeader(&#34;*&#34;); //2.添加映射路径，我们拦截一切请求 UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource(); configSource.registerCorsConfiguration(&#34;/**&#34;, config); //3.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-12T19:00:42+08:00">
    <meta property="article:modified_time" content="2024-04-12T19:00:42+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【前端】为什么postman可以请求成功，并且GET请求没有问题，但是POST访问却是403？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>向后端发起GET请求成功了，POST请求却发生了403，然而再尝试Postman发送POST请求却能成功，为什么？记录一下整体过程</h4> 
 <ul><li><ul><li><a href="#_2" rel="nofollow">问题与结论</a></li><li><a href="#_14" rel="nofollow">解决过程</a></li></ul> 
  </li><li><a href="#GET_68" rel="nofollow">为什么GET请求可以？</a></li><li><a href="#Postman_99" rel="nofollow">为什么Postman请求可以？</a></li></ul> 
</div> 
<p></p> 
<h3><a id="_2"></a>问题与结论</h3> 
<p>今天和后端联调，发现了一个问题，<strong>发起的get请求没有问题，post请求都被拦截了，403forbidden</strong>，后端觉得是前端配置问题，于是用 <strong>postman发送了请求，并且成功了</strong>，这是为什么呢？<br> <img src="https://images2.imgbox.com/f7/9e/XXvHAYZD_o.png" alt="403错误"><br> <img src="https://images2.imgbox.com/bc/fe/hGDOjacs_o.png" alt="403错误"></p> 
<p>先说结论确定了前端的配置没有问题后，查看了后端代码与历史修改记录（曾经是没问题的），发现后端修改了一行代码导致的，<code>config.addAllowedOrigin("*")</code>，据后端所说，他们是重写了cors的拦截策略，因为安全性，所以删除了这行代码。</p> 
<p><mark><strong>问题结论：没有允许非同origin下的请求</strong></mark></p> 
<p><mark>但是该行代码，同时引起了我的思考，为什么postman可以？为什么同样的GET请求可以，但是POST请求不可以？</mark></p> 
<h3><a id="_14"></a>解决过程</h3> 
<p>首先，判断并非是前端跨域问题。</p> 
<p>在Webpack中设置反向代理通常是为了解决开发环境中的跨域请求问题。可以使用webpack-dev-server的反向代理功能来实现。且前端若配置失败，浏览器返回的错误是这样的。</p> 
<p><img src="https://images2.imgbox.com/76/9d/ny69NkJK_o.png" alt="浏览器跨域"><br> 于是应该是后端做了什么相关的策略。后端当时使用postman，发现并无问题。<br> 因为之前项目是没问题的，所以去查了修改记录，所以发现是为了安全考虑，少了那一行代码。</p> 
<p>贴上修改后的代码</p> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Bean</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>cors<span class="token punctuation">.</span></span><span class="token class-name">CorsConfiguration</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>cors<span class="token punctuation">.</span></span><span class="token class-name">UrlBasedCorsConfigurationSource</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>filter<span class="token punctuation">.</span></span><span class="token class-name">CorsFilter</span></span><span class="token punctuation">;</span>
 
<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CorsConfig</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">CorsFilter</span> <span class="token function">corsFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
 
        <span class="token comment">//1.添加CORS配置信息</span>
        <span class="token class-name">CorsConfiguration</span> config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CorsConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//1) 允许的域,不要写*，否则cookie就无法使用了</span>
        <span class="token comment">// config.addAllowedOrigin("*"); //这里填写请求的前端服务器</span>
        config<span class="token punctuation">.</span><span class="token function">addAllowedOriginPattern</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//2) 是否发送Cookie信息</span>
        config<span class="token punctuation">.</span><span class="token function">setAllowCredentials</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//3) 允许的请求方式</span>
        config<span class="token punctuation">.</span><span class="token function">addAllowedMethod</span><span class="token punctuation">(</span><span class="token string">"OPTIONS"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        config<span class="token punctuation">.</span><span class="token function">addAllowedMethod</span><span class="token punctuation">(</span><span class="token string">"HEAD"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        config<span class="token punctuation">.</span><span class="token function">addAllowedMethod</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        config<span class="token punctuation">.</span><span class="token function">addAllowedMethod</span><span class="token punctuation">(</span><span class="token string">"PUT"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        config<span class="token punctuation">.</span><span class="token function">addAllowedMethod</span><span class="token punctuation">(</span><span class="token string">"POST"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        config<span class="token punctuation">.</span><span class="token function">addAllowedMethod</span><span class="token punctuation">(</span><span class="token string">"DELETE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        config<span class="token punctuation">.</span><span class="token function">addAllowedMethod</span><span class="token punctuation">(</span><span class="token string">"PATCH"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//4) 允许的头信息</span>
        config<span class="token punctuation">.</span><span class="token function">addAllowedHeader</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token comment">//2.添加映射路径，我们拦截一切请求</span>
        <span class="token class-name">UrlBasedCorsConfigurationSource</span> configSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UrlBasedCorsConfigurationSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        configSource<span class="token punctuation">.</span><span class="token function">registerCorsConfiguration</span><span class="token punctuation">(</span><span class="token string">"/**"</span><span class="token punctuation">,</span> config<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token comment">//3.返回新的CorsFilter.</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CorsFilter</span><span class="token punctuation">(</span>configSource<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="GET_68"></a>为什么GET请求可以？</h2> 
<p><code>首先理解，请求头中的origin是什么？</code></p> 
<p>HTTP 协议中的 Origin Header <strong>存在于请求中</strong>，<strong>用于指明当前请求来自于哪个站点</strong>。</p> 
<p>经查询资料, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin" rel="nofollow">Origin</a>是<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referer" rel="nofollow">Referer</a>头的升级版, 常用于<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="nofollow">CORS</a>或者非<code>GET</code>、<code>HEAD</code>请求(<a href="https://fetch.spec.whatwg.org/#origin-header" rel="nofollow">MDN 的说法有误，不是只有 <code>POST</code></a>)相关的服务端身份检验</p> 
<blockquote> 
 <p>浏览器端<code>Origin</code>无法手动设置</p> 
</blockquote> 
<ul><li><code>Origin</code>头是浏览器保护字段，类似的有 <code>Referer</code>、<code>Host</code>、<code>Content-Length</code>、<code>Keep-alive</code>等，但是可以通过 nginx 代理修改。浏览器根据约定自动附加</li></ul> 
<blockquote> 
 <p>浏览器附加<code>Origin</code>头的规则</p> 
</blockquote> 
<ul><li>根据<a href="https://fetch.spec.whatwg.org/" rel="nofollow">fetch</a>说明, 只有当请求为跨域请求或者非<code>get</code>,<code>head</code>请求时都会自动附加。不可被编程，不可被编辑。<code>get</code>,<code>head</code>请求由于兼容性，故无法实现</li></ul> 
<blockquote> 
 <p>非 CORS 情况下, <code>Origin</code>字段框架使用情况</p> 
</blockquote> 
<ul><li>据我了解, 绝大部分框架都没有使用 Origin 字段, 我所待的几个公司也从未根据此值来判断</li></ul> 
<blockquote> 
 <p>所有符合规则的资源都会包含 Origin 头?</p> 
</blockquote> 
<ul><li>不是。例如跨域图片不会包含 Origin 头, 更多资源请<a href="https://stackoverflow.com/questions/42239643/when-do-browsers-send-the-origin-header-when-do-browsers-set-the-origin-to-null" rel="nofollow">查看</a></li></ul> 
<p><strong>比如有的浏览器（IE）能够请求成功，而有的浏览器却请求失败（Chrome）。这不是因为前一个浏览器行为正确，而是因为前一个浏览器发出请求时没有带上 <code>Origin</code> 而后一个浏览器带上了正确的 <code>Origin</code>。</strong></p> 
<p><strong>而在服务器端，因为没有 <code>Origin</code> Header，所以认为这不是一次 <code>CORS</code> 请求，所以没有进行 <code>CORS</code> 校验。这也反过来要求服务端强制请求带上 <code>Origin</code> Header，才能进一步保证服务器的安全性。</strong></p> 
<p><mark>可能当前项目后端请求中，并未校验GET（简单请求）的origin吧？因为本人只是一名前端，个人思考结果。如果有人知道具体原因，还请告知。</mark></p> 
<h2><a id="Postman_99"></a>为什么Postman请求可以？</h2> 
<p><code>首先理解下同源策略</code></p> 
<p>同源策略是浏览器的一个安全机制，限制了一个源（域名、协议、端口）的文档或脚本如何与来自另一个源的资源进行交互。这种限制是为了防止潜在的安全漏洞，比如<a href="https://www.zhihu.com/search?q=%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3332283877%7D" rel="nofollow">跨站脚本</a>（XSS）攻击。</p> 
<p>但是，<strong>Postman 并不是一个浏览器，它是一个独立的工具，不受同源策略的限制</strong>。当你在 Postman 中发送请求时，它实际上是在模拟一个 HTTP 请求，并不像浏览器一样执行 JavaScript 代码。因此，Postman 可以轻松地发送请求到不同域名的服务器，并获得响应，而不会受到同源策略的约束。</p> 
<p>而且Postman的默认请求头中，并没有<code>Origin</code>的参数。<br> <img src="https://images2.imgbox.com/34/9f/Ql1cGc4W_o.png" alt="在这里插入图片描述"></p> 
<p>理论上来说，如果我手动添加，非同源，是否也会失败，事实证明，的确如此。<br> <img src="https://images2.imgbox.com/b0/95/DQbHOaQu_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6eab294e3d993465d4650bf7dcc56db6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[Mysql] 群晖7.21 部署MySQL数据库</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d53b1026c3b76ee2caaaf16c6ab189e3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java fastJson的maven配置以及下载使用方法及相关文档</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>