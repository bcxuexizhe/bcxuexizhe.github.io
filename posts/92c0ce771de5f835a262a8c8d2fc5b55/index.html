<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis—相关背景 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/92c0ce771de5f835a262a8c8d2fc5b55/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Redis—相关背景">
  <meta property="og:description" content="Redis—相关背景 🔎Redis—特性In-memory data structures—在内存中存储数据Programmability—可编程性Extensibility—可扩展性Persistence—持久化Clustering—集群High availability—高可用 🔎Redis 为什么快🔎Redis 的使用场景Real-time data store—实时数据存储Caching—缓存session storage—会话存储Streaming&amp;messaging—消息队列 Redis官网
🔎Redis—特性 MySQL 主要是通过 “表” 的方式组织存储数据 → 关系型数据库
Redis 主要是通过 “键值对” 的方式组织存储数据 → 非关系型数据库
In-memory data structures—在内存中存储数据 在内存中存储数据
Redis 通过键值对方式组织存储数据
其中 key 都是 string 类型, value 可以是 strings, hashes, lists, sets, sorted sets, streams…
Programmability—可编程性 可编程性
针对 Redis 的操作
可直接通过简单的交互式命令进行操作
也可以通过一些脚本的方式批量执行一些操作
Extensibility—可扩展性 可扩展性
可以在 Redis 原有的功能基础上进行扩展(通过 C, C&#43;&#43;, Rust 进行扩展)
Persistence—持久化 持久化
Redis 为了能够快速访问, 将数据存储至内存中
内存中的数据是易丢失的(进程退出, 系统重启…)
因此 Redis 也会将数据存储至硬盘(硬盘中的数据相当于是对内存的数据进行备份) → 持久化">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-07-28T09:20:53+08:00">
    <meta property="article:modified_time" content="2023-07-28T09:20:53+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis—相关背景</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Redis—相关背景</h4> 
 <ul><li><a href="#Redis_4" rel="nofollow">🔎Redis—特性</a></li><li><ul><li><a href="#Inmemory_data_structures_11" rel="nofollow">In-memory data structures—在内存中存储数据</a></li><li><a href="#Programmability_22" rel="nofollow">Programmability—可编程性</a></li><li><a href="#Extensibility_34" rel="nofollow">Extensibility—可扩展性</a></li><li><a href="#Persistence_43" rel="nofollow">Persistence—持久化</a></li><li><a href="#Clustering_56" rel="nofollow">Clustering—集群</a></li><li><a href="#High_availability_67" rel="nofollow">High availability—高可用</a></li></ul> 
  </li><li><a href="#Redis__79" rel="nofollow">🔎Redis 为什么快</a></li><li><a href="#Redis__93" rel="nofollow">🔎Redis 的使用场景</a></li><li><ul><li><a href="#Realtime_data_store_104" rel="nofollow">Real-time data store—实时数据存储</a></li><li><a href="#Caching_115" rel="nofollow">Caching—缓存</a></li><li><a href="#session_storage_123" rel="nofollow">session storage—会话存储</a></li><li><a href="#Streamingmessaging_150" rel="nofollow">Streaming&amp;messaging—消息队列</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<blockquote> 
 <p><a href="https://redis.io/" rel="nofollow">Redis官网</a></p> 
</blockquote> 
<h2><a id="Redis_4"></a>🔎Redis—特性</h2> 
<br> 
<p>MySQL 主要是通过 “表” 的方式组织存储数据 → 关系型数据库<br> Redis 主要是通过 “键值对” 的方式组织存储数据 → 非关系型数据库</p> 
<h3><a id="Inmemory_data_structures_11"></a>In-memory data structures—在内存中存储数据</h3> 
<br> 
<p>在内存中存储数据</p> 
<p>Redis 通过键值对方式组织存储数据<br> 其中 key 都是 string 类型, value 可以是 strings, hashes, lists, sets, sorted sets, streams…</p> 
<p><img src="https://images2.imgbox.com/d6/fe/xrS3QlSD_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="Programmability_22"></a>Programmability—可编程性</h3> 
<br> 
<p>可编程性</p> 
<p>针对 Redis 的操作<br> 可直接通过简单的交互式命令进行操作<br> 也可以通过一些脚本的方式批量执行一些操作</p> 
<p><img src="https://images2.imgbox.com/0f/96/QdeyUJEc_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="Extensibility_34"></a>Extensibility—可扩展性</h3> 
<br> 
<p>可扩展性</p> 
<p>可以在 Redis 原有的功能基础上进行扩展(通过 C, C++, Rust 进行扩展)</p> 
<p><img src="https://images2.imgbox.com/1a/1c/Gnjpb6Ii_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="Persistence_43"></a>Persistence—持久化</h3> 
<br> 
<p>持久化</p> 
<p>Redis 为了能够快速访问, 将数据存储至内存中<br> 内存中的数据是易丢失的(进程退出, 系统重启…)<br> 因此 Redis 也会将数据存储至硬盘(硬盘中的数据相当于是对内存的数据进行备份) → 持久化<br> 例如当系统重启, 就会在重启时加载硬盘中的备份数据, 使 Redis 的内存恢复如初</p> 
<p><img src="https://images2.imgbox.com/36/fb/8ipDGUYm_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="Clustering_56"></a>Clustering—集群</h3> 
<br> 
<p>集群</p> 
<p>一个 Redis 所能存储的数据是有限的(内存空间有限)<br> 集群 → 引入多台主机, 部署多个 Redis 节点, 让每个 Redis 存储一部分数据</p> 
<p><img src="https://images2.imgbox.com/a2/3b/Kv1DAbIT_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="High_availability_67"></a>High availability—高可用</h3> 
<br> 
<p>高可用</p> 
<p>你可以将高可用理解为备份</p> 
<p>Redis 支持主从结构, 从节点相当于是主节点的备份</p> 
<p><img src="https://images2.imgbox.com/7c/b2/fA2p7knu_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Redis__79"></a>🔎Redis 为什么快</h2> 
<br> 
<p>Redis 对比 MySQL 为什么快</p> 
<ol><li>Redis 的数据存储在内存中, MySQL 的数据存储在硬盘中</li><li>Redis 的核心功能都是比较简单的操作内存结构<br> MySQL 中的一些操作较为复杂. 例如插入数据时, 如果存在约束, 需要查看具体的约束状态…</li><li>Redis 使用了 IO 多路复用的方式(一个线程管理多个 socket)</li><li>Redis 默认情况下使用单线程处理请求, 避免多线程之间的锁竞争和锁带来的开销(大多数简单的的读写操作, 使用单线程方式更高效)<br> MySQL 处理复杂查询时采用多线程处理, 导致额外的开销</li></ol> 
<h2><a id="Redis__93"></a>🔎Redis 的使用场景</h2> 
<br> 
<ol><li>Real-time data store—实时数据存储</li><li>Caching—缓存</li><li>session storage—会话存储</li><li>Streaming&amp;messaging—消息队列</li></ol> 
<p><img src="https://images2.imgbox.com/50/a8/WC2TXasT_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="Realtime_data_store_104"></a>Real-time data store—实时数据存储</h3> 
<br> 
<p>实时数据存储, 将 Redis 作为数据库</p> 
<p>大多数场景下的数据存储针对的是存储量大<br> 而一些特定场景要求的是存储速度快, Redis 针对的就是这样的情况</p> 
<p>将 Redis 作为数据库, 存储的是全部数据, 这里面的数据不能随便丢失</p> 
<h3><a id="Caching_115"></a>Caching—缓存</h3> 
<br> 
<p>根据二八原则, 将热点数据存储至 Redis, MySQL 中依旧存储全部数据<br> 即使 Redis 中的数据丢失, 也可以从 MySQL 中继续加载</p> 
<h3><a id="session_storage_123"></a>session storage—会话存储</h3> 
<br> 
<p>cookie → 浏览器存储的用户身份标识<br> session → 服务器存储的真正的用户数据</p> 
<p>只有一台应用服务器时, 会话信息就存储在该应用服务器上<br> 有多台应用服务器之后, 会话信息该如何存储呢?</p> 
<p>举个栗子🌰</p> 
<p>用户 A 登录一个网站, 输入对应的用户名和密码</p> 
<p>只有一台应用服务器时, 无需负载均衡, 会话信息存储在该服务器上<br> 此时 A 再次点击该网站, 该网站已经保存了 A 的会话信息, 无需进行登录操作</p> 
<p>当有多台应用服务器时, 如果会话信息分别保存在多台应用服务器, 那么当 A 再次点击该网站, 又需要进行登录操作<br> 万一 A 很不幸, 每次点击该网站, 负载均衡器都将其请求分配到了不同的应用服务器, 那么 A 会一直进行登录操作</p> 
<p>对于上述的问题, 解决方式有 2 种🍂</p> 
<ol><li>通过特定的算法, 让 A 用户的请求每次都指定到同一个应用服务器</li><li>将会话信息单独保存至一台独立的机器(Redis)</li></ol> 
<p><img src="https://images2.imgbox.com/7c/da/zzpoogHl_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="Streamingmessaging_150"></a>Streaming&amp;messaging—消息队列</h3> 
<br> 
<p>有很多比较知名的消息队列, 例如 RabbitMQ, Kafka, RocketMQ…</p> 
<p>Redis 也具有消息队列的功能<br> 如果当前场景中, 对于消息队列的功能依赖比较少, 并且不想引入其他依赖的情况下, 可以将 Redis 作为消息队列</p> 
<p>生产者可以将消息推送到 Redis 列表中, 然后消费者从列表中获取消息进行处理</p> 
<br> 
<p>🌸🌸🌸完结撒花🌸🌸🌸</p> 
<br> 
<p><img src="https://images2.imgbox.com/8b/23/3GQ0ACV7_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3f0c4997cf0a139a4fe7c2f193ac7da6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Resolved [org.springframework.web.HttpMediaTypeNotSupportedException: Content type ‘application/x-ww</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a0204cf4683fa756a44a38d02b70dfbe/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">超详细 mysql 主键索引、唯一索引、普通索引、联合索引的区别与实例说明</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>