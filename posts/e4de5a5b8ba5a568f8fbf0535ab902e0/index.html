<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【QT入门】 Qt槽函数五种常用写法介绍 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/e4de5a5b8ba5a568f8fbf0535ab902e0/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【QT入门】 Qt槽函数五种常用写法介绍">
  <meta property="og:description" content="声明：该专栏为本人学习Qt知识点时候的笔记汇总，希望能给初学的朋友们一点帮助(加油！)
往期回顾：
【QT入门】实现一个简单的图片查看软件-CSDN博客
【QT入门】图片查看软件(优化)-CSDN博客
【QT入门】 lambda表达式(函数)详解-CSDN博客
【QT入门】 Qt槽函数五种常用写法介绍 一、信号槽基本概念 Qt的信号槽是一种用于处理事件和通信的机制，是Qt框架中的一个重要特性。信号槽机制使得对象之间可以进行异步通信，无需显式调用对方的方法，从而实现了对象之间的解耦和灵活的交互。
1、信号（Signal）： 信号是一种特殊的成员函数，用于通知其他对象发生了某个事件或状态的改变。信号在类中声明为signals关键字，并不包含实际的实现代码。信号可以带有参数，用于传递额外的信息给槽函数。
2、槽（Slot）： 槽是用于响应信号的成员函数，可以执行相应的操作或处理逻辑。槽在类中声明为slots关键字，并实现具体的逻辑，槽函数的参数列表必须与信号的参数列表一致，或者可以接受更多参数。 通过connect函数将信号与槽连接起来，使得当信号被发射时，相关的槽函数会被调用。
连接可以是一对多的关系，即一个信号可以连接多个槽函数，也可以是多对一的关系，即多个信号可以连接到同一个槽函数。我们来看看其四个参数
connect（1.信号的发送者、2.发送的信号（函数的地址）、3.信号的接收者、4.接收后信号的处理(槽函数)的地址）
3、示例： connect(ui-&gt;pushButton,&amp;QPushButton::clicked,this,&amp;MainWindow::btnslot); 一一对应， ui里的pushButton控件时信号的发送者，发送了一个cliced点击信号，当前主窗口接收了这个信号，接收后调用当前窗口的btnslot方法，也就是所说的槽函数，进行了响应。
4、第五个参数 当然，实际上Qt的connect是五个参数，还有最后一个参数用于指定信号槽连接类型，但是我们一半不写，因为默认是自动连接类型。我们看看第五个参数类型：
AutoConnection自动连接，Qt会根据信号发送者和接收者的线程自动选择连接类型。DirectConnection直接连接，信号发送时，槽函数会立即在发送者所在的线程中执行。QueuedConnection队列连接，信号发送时，槽函数会被投递到接收者所在的线程的事件队列中，在接收者线程空闲时执行。BlockingQueuedConnection阻塞队列连接，与QueuedConnection类似，但发送者会等待槽函数执行完成后才继续执行。UniqueConnection唯一连接，确保相同的信号和槽不会被重复连接。 在Qt中使用这些连接类型来控制信号槽的行为，以确保在多线程环境下正确地处理信号和槽的执行顺序和线程关系。
二、五种槽函数写法 1、第一种: Qt4写法 connect(ui-&gt;pushButton,SIGNAL(clicked()),this,SLOT(btnslot()))
现在呢已经不推荐这种写法，因为如果SIGNAL写错了，或者信号名字、槽函数名字写错了，
编译器检查不出来，导致程序无响应，引起不必要的误解，也不便于找到问题。
2、第二种: Qt5写法 connect(ui-&gt;pushButton,&amp;QPushButton::clicked,this,&amp;MainWindow::btnslot);
推荐使用这种写法，信号名字、槽函数名字写错了，编译器会直接报错。
3、第三种：lambda表达式写法 connect(ui-&gt;pushButton,&amp;QPushButton::clicked,[=](参数){
//具体代码
QMessageBox::information(this,&#34;title&#34;,&#34;Qt5_signal_slot&#34;);
}); 推荐使用，适用于slot代码比较少的逻辑
注：槽函数里写参数，可以比实际的参数数量少，比如实际有一个形参，我们就可以不写，可以写那一个，但是不可以写两个 。
4、第四种：牵线法 这种方法就是在ui控件上，点击控件绑定一个槽函数，然后再自己写槽函数逻辑，但是看着比较混乱，不太推荐。
5、第五种：自动生成法 在ui设计界面里直接点击控件，选择转到槽，再在里面选择槽函数。(通过这个方式，还可以很直观的看到某个控件有哪些槽函数)
而且这个方法用的挺多的，很方便，同时也可以选择自己手写，命名是on_控件名_信号名；分别在.h声明和.cpp实现就是，如果是自定义的槽函数一般都是do开头
比如我对ui界面的一个pushbutton控件绑定槽函数
void MainWindow::on_pushButton_clicked()
{
QMessageBox::information(this,&#34;title&#34;,&#34;Qt5_signal&#34;);
close();
}
以上就是Qt槽函数五种常用写法介绍。
都看到这里了，点个赞再走呗朋友~
加油吧，预祝大家变得更强！">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-21T19:33:25+08:00">
    <meta property="article:modified_time" content="2024-03-21T19:33:25+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【QT入门】 Qt槽函数五种常用写法介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>声明：该专栏为本人学习<a href="https://so.csdn.net/so/search?q=java%E7%9F%A5%E8%AF%86%E7%82%B9&amp;spm=1001.2101.3001.7020" title="Qt知识点">Qt知识点</a>时候的笔记汇总，希望能给初学的朋友们一点帮助(加油！)</p> 
<hr> 
<p>往期回顾：</p> 
<blockquote> 
 <p><a href="https://blog.csdn.net/LF__plus/article/details/136847140" title="【QT入门】实现一个简单的图片查看软件-CSDN博客">【QT入门】实现一个简单的图片查看软件-CSDN博客</a></p> 
 <p><a href="https://blog.csdn.net/LF__plus/article/details/136872896" title="【QT入门】图片查看软件(优化)-CSDN博客">【QT入门】图片查看软件(优化)-CSDN博客</a></p> 
 <p><a href="https://blog.csdn.net/LF__plus/article/details/136873469?spm=1001.2014.3001.5502" title="【QT入门】 lambda表达式(函数)详解-CSDN博客">【QT入门】 lambda表达式(函数)详解-CSDN博客</a></p> 
</blockquote> 
<h2> 【QT入门】 Qt槽函数五种常用写法介绍</h2> 
<h3>一、信号槽基本概念</h3> 
<p>Qt的信号槽是一种用于处理事件和通信的机制，是Qt框架中的一个重要特性。信号槽机制使得对象之间可以进行异步通信，无需显式调用对方的方法，从而实现了对象之间的解耦和灵活的交互。</p> 
<h4>1、信号（Signal）：</h4> 
<p>信号是一种特殊的成员函数，用于通知其他对象发生了某个事件或状态的改变。信号在类中声明为signals关键字，并不包含实际的实现代码。信号可以带有参数，用于传递额外的信息给槽函数。</p> 
<h4>2、槽（Slot）：</h4> 
<p>槽是用于响应信号的成员函数，可以执行相应的操作或处理逻辑。槽在类中声明为slots关键字，并实现具体的逻辑，槽函数的参数列表必须与信号的参数列表一致，或者可以接受更多参数。 </p> 
<p>通过<span style="color:#fe2c24;"><strong>connect函数</strong></span>将信号与槽连接起来，使得当信号被发射时，相关的槽函数会被调用。<br> 连接可以是一对多的关系，即一个信号可以连接多个槽函数，也可以是多对一的关系，即多个信号可以连接到同一个槽函数。我们来看看其四个参数</p> 
<blockquote> 
 <p>connect（1.信号的发送者、2.发送的信号（函数的地址）、3.信号的接收者、4.接收后信号的处理(槽函数)的地址）</p> 
</blockquote> 
<h4>3、示例：</h4> 
<blockquote> 
 <p>connect(ui-&gt;pushButton,&amp;QPushButton::clicked,this,&amp;MainWindow::btnslot); </p> 
</blockquote> 
<p>一一对应， ui里的pushButton控件时信号的发送者，发送了一个cliced点击信号，当前主窗口接收了这个信号，接收后调用当前窗口的btnslot方法，也就是所说的槽函数，进行了响应。</p> 
<h4>4、第五个参数 </h4> 
<p>当然，实际上Qt的connect是五个参数，还有最后一个参数用于指定信号槽连接类型，但是我们一半不写，因为默认是自动连接类型。我们看看第五个参数类型：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td>AutoConnection</td><td>自动连接，Qt会根据信号发送者和接收者的线程自动选择连接类型。</td></tr><tr><td>DirectConnection</td><td>直接连接，信号发送时，槽函数会立即在发送者所在的线程中执行。</td></tr><tr><td>QueuedConnection</td><td>队列连接，信号发送时，槽函数会被投递到接收者所在的线程的事件队列中，在接收者线程空闲时执行。</td></tr><tr><td>BlockingQueuedConnection</td><td>阻塞队列连接，与QueuedConnection类似，但发送者会等待槽函数执行完成后才继续执行。</td></tr><tr><td>UniqueConnection</td><td>唯一连接，确保相同的信号和槽不会被重复连接。</td></tr></tbody></table> 
<p>在Qt中使用这些连接类型来控制信号槽的行为，以确保在多线程环境下正确地处理信号和槽的执行顺序和线程关系。</p> 
<h3>二、五种槽函数写法</h3> 
<h4>1、第一种: Qt4写法</h4> 
<blockquote> 
 <p>connect(ui-&gt;pushButton,SIGNAL(clicked()),this,SLOT(btnslot()))</p> 
</blockquote> 
<p>现在呢已经不推荐这种写法，因为如果SIGNAL写错了，或者信号名字、槽函数名字写错了，<br> 编译器检查不出来，导致程序无响应，引起不必要的误解，也不便于找到问题。</p> 
<h4>2、第二种: Qt5写法</h4> 
<blockquote> 
 <p>connect(ui-&gt;pushButton,&amp;QPushButton::clicked,this,&amp;MainWindow::btnslot);</p> 
</blockquote> 
<p>推荐使用这种写法，信号名字、槽函数名字写错了，编译器会直接报错。</p> 
<h4>3、第三种：lambda表达式写法</h4> 
<blockquote> 
 <p>connect(ui-&gt;pushButton,&amp;QPushButton::clicked,[=](参数){<!-- --><br>    //具体代码<br>    QMessageBox::information(this,"title","Qt5_signal_slot");<br>    }); </p> 
</blockquote> 
<p>推荐使用，适用于slot代码比较少的逻辑</p> 
<p>注：槽函数里写参数，可以比实际的参数数量少，比如实际有一个形参，我们就可以不写，可以写那一个，但是不可以写两个 。</p> 
<h4>4、第四种：牵线法</h4> 
<p>这种方法就是在ui控件上，点击控件绑定一个槽函数，然后再自己写槽函数逻辑，但是看着比较混乱，不太推荐。</p> 
<p><img alt="" height="525" src="https://images2.imgbox.com/c0/c0/EfCFHNZz_o.png" width="1024"></p> 
<h4> 5、第五种：自动生成法</h4> 
<p>在ui设计界面里直接点击控件，选择转到槽，再在里面选择槽函数。(通过这个方式，还可以很直观的看到某个控件有哪些槽函数)</p> 
<p><img alt="" height="1001" src="https://images2.imgbox.com/6d/f0/MC2EpIgM_o.png" width="901"></p> 
<p>而且这个方法用的挺多的，很方便，同时也可以选择自己手写，<strong>命名是on_控件名_信号名；</strong>分别在.h声明和.cpp实现就是，如果是自定义的槽函数一般都是do开头</p> 
<p>比如我对ui界面的一个pushbutton控件绑定槽函数</p> 
<blockquote> 
 <p>void MainWindow::on_pushButton_clicked()<br> {<!-- --><br>     QMessageBox::information(this,"title","Qt5_signal");<br>     close();<br> }</p> 
</blockquote> 
<p>以上就是Qt槽函数五种常用写法介绍。</p> 
<hr> 
<p><span style="background-color:#ffd900;">都看到这里了，点个赞再走呗朋友~</span></p> 
<p>加油吧，<strong>预祝大家变得更强！</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c9ecbcc99866c0ef127d6a3061a52541/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Hive自定义GenericUDF函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fed182d18aad686df0e93c18c6a9ccc3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">10分钟教你用Python爬取Baidu文库全格式内容，Flutter尽然还能有这种操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>