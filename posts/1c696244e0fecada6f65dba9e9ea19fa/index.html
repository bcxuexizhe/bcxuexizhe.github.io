<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;初阶学习第十弹——探索STL奥秘（五）——深入讲解vector的迭代器失效问题 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/1c696244e0fecada6f65dba9e9ea19fa/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="C&#43;&#43;初阶学习第十弹——探索STL奥秘（五）——深入讲解vector的迭代器失效问题">
  <meta property="og:description" content="vector（上）：C&#43;&#43;初阶学习第八弹——探索STL奥秘（三）——深入刨析vector的使用-CSDN博客
vector（中）：C&#43;&#43;初阶学习第九弹——探索STL奥秘（四）——vector的深层挖掘和模拟实现-CSDN博客
目录
一、vector的迭代器失效问题的本质
二、vector迭代器失效的原因
1、引起底层空间改变的操作
2、进行指定元素删除的时候—erase
3、在其他编译环境下的失效情况
4、string的迭代器失效
三、vector迭代器失效的解决方法
四、总结
前言：
在前面我们已经学习了vector的使用和其模拟实现，相信也帮助我们了解了vector这个容器的基本规则，但其实在我们讲解的过程中，有一些知识点我们还没提到，今天，我们就专门来讲一下vector在使用和模拟实现的过程中一个容易出错的知识点——迭代器失效问题
一、vector的迭代器失效问题的本质 迭代器的作用就是能让我们忽略变量的类型，方便我们访问，其本质其实还是指针，类如对于vector的类型的，&#43;&#43;后往后访问其实也是将指针改为指向下一个数据的指针，迭代器失效就是迭代器底层使用的指针指向的空间被释放了，这样再使用这个迭代器就会造成程序崩溃，这就是迭代器失效（迭代器失效也与编译环境有一定关系）
二、vector迭代器失效的原因 vector容器可能会发生迭代器失效的操作有以下几种：
1、引起底层空间改变的操作 比如resize、reserve、insert、assign、push_back等
例如：
#include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; v{ 1,2,3,4,5,6 }; auto it = v.begin(); while (it != v.end()) { cout &lt;&lt; *it &lt;&lt; &#34; &#34;; &#43;&#43;it; } cout &lt;&lt; endl; return 0; } 对于这样一个程序，我们定义了一个v，并用迭代器来实现全部访问，运行结果如下： 在这个程序中，我们记录下了v的begin迭代器，并一步步向后走，从而实现遍历，但我们知道vector的本质上与顺序表是类似的， 它是在内存上找一段能放下当前数据的空间，但是当我们进行扩容等操作的时候的时候，可能原空间下就不够用了，就需要找一个新的位置开辟空间并且销毁旧空间，这个时候迭代器指向的位置就会发生变化，而it还记录的原来begin指向原来的那段空间，所以就会导致程序崩溃，出现迭代器失效的现象 例如（错误示范）： #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; v{ 1,2,3,4,5,6 }; auto it = v.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-23T22:30:31+08:00">
    <meta property="article:modified_time" content="2024-05-23T22:30:31+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;初阶学习第十弹——探索STL奥秘（五）——深入讲解vector的迭代器失效问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>vector（上）：</strong><a href="https://blog.csdn.net/2301_80220607/article/details/139008935?spm=1001.2014.3001.5502" title="C++初阶学习第八弹——探索STL奥秘（三）——深入刨析vector的使用-CSDN博客">C++初阶学习第八弹——探索STL奥秘（三）——深入刨析vector的使用-CSDN博客</a></p> 
<p><strong>vector（中）：</strong><a href="https://blog.csdn.net/2301_80220607/article/details/139075910?spm=1001.2014.3001.5502" title="C++初阶学习第九弹——探索STL奥秘（四）——vector的深层挖掘和模拟实现-CSDN博客">C++初阶学习第九弹——探索STL奥秘（四）——vector的深层挖掘和模拟实现-CSDN博客</a></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81vector%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%E7%9A%84%E6%9C%AC%E8%B4%A8-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81vector%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%E7%9A%84%E6%9C%AC%E8%B4%A8" rel="nofollow">一、vector的迭代器失效问题的本质</a></p> 
<p id="%E4%BA%8C%E3%80%81vector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81vector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0" rel="nofollow">二、vector迭代器失效的原因</a></p> 
<p id="1%E3%80%81%E5%BC%95%E8%B5%B7%E5%BA%95%E5%B1%82%E7%A9%BA%E9%97%B4%E6%94%B9%E5%8F%98%E7%9A%84%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E5%BC%95%E8%B5%B7%E5%BA%95%E5%B1%82%E7%A9%BA%E9%97%B4%E6%94%B9%E5%8F%98%E7%9A%84%E6%93%8D%E4%BD%9C" rel="nofollow">1、引起底层空间改变的操作</a></p> 
<p id="2%E3%80%81%E8%BF%9B%E8%A1%8C%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4%E7%9A%84%E6%97%B6%E5%80%99%E2%80%94erase-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E8%BF%9B%E8%A1%8C%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4%E7%9A%84%E6%97%B6%E5%80%99%E2%80%94erase" rel="nofollow">2、进行指定元素删除的时候—erase</a></p> 
<p id="3%E3%80%81%E5%9C%A8%E5%85%B6%E4%BB%96%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E5%9C%A8%E5%85%B6%E4%BB%96%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5" rel="nofollow">3、在其他编译环境下的失效情况</a></p> 
<p id="4%E3%80%81string%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88-toc" style="margin-left:80px;"><a href="#4%E3%80%81string%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88" rel="nofollow">4、string的迭代器失效</a></p> 
<p id="%E4%B8%89%E3%80%81vector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81vector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95" rel="nofollow">三、vector迭代器失效的解决方法</a></p> 
<p id="%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93" rel="nofollow">四、总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p><strong>前言：</strong></p> 
<blockquote> 
 <p>在前面我们已经学习了vector的使用和其模拟实现，相信也帮助我们了解了vector这个容器的基本规则，但其实在我们讲解的过程中，有一些知识点我们还没提到，今天，我们就专门来讲一下vector在使用和模拟实现的过程中一个容易出错的知识点——迭代器失效问题</p> 
</blockquote> 
<h2 id="%E4%B8%80%E3%80%81vector%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%E7%9A%84%E6%9C%AC%E8%B4%A8">一、vector的迭代器失效问题的本质</h2> 
<blockquote> 
 <p><strong>迭代器的作用</strong>就是能让我们忽略变量的类型，方便我们访问，其<strong>本质其实还是指针</strong>，类如对于vector的类型的，++后往后访问其实也是将指针改为指向下一个数据的指针，<strong>迭代器失效就是迭代器底层使用的指针指向的空间被释放了，这样再使用这个迭代器就会造成程序崩溃，这就是迭代器失效（迭代器失效也与编译环境有一定关系）</strong></p> 
</blockquote> 
<h2 id="%E4%BA%8C%E3%80%81vector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0">二、vector迭代器失效的原因</h2> 
<p><strong>vector容器可能会发生迭代器失效的操作有以下<span style="background-color:#ffd900;">几种</span>：</strong></p> 
<h4 id="1%E3%80%81%E5%BC%95%E8%B5%B7%E5%BA%95%E5%B1%82%E7%A9%BA%E9%97%B4%E6%94%B9%E5%8F%98%E7%9A%84%E6%93%8D%E4%BD%9C"><strong><span style="color:#0d0016;"><span style="background-color:#ffd900;">1、</span></span><span style="background-color:#ffd900;">引起底层空间改变的操作</span></strong></h4> 
<blockquote> 
 <p>比如resize、reserve、insert、assign、push_back等</p> 
</blockquote> 
<p>例如：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

int main()
{
	vector&lt;int&gt; v{ 1,2,3,4,5,6 };
	auto it = v.begin();
	while (it != v.end())
	{
		cout &lt;&lt; *it &lt;&lt; " ";
		++it;
	}
	cout &lt;&lt; endl;
	return 0;
}</code></pre> 
<div>
  对于这样一个程序，我们定义了一个v，并用迭代器来实现全部访问，运行结果如下： 
</div> 
<div> 
 <img alt="" height="487" src="https://images2.imgbox.com/21/a2/tc5dI4LV_o.png" width="969"> 
</div> 
<blockquote> 
 <div>
   在这个程序中，我们记录下了v的begin迭代器，并一步步向后走，从而实现遍历，但我们知道vector的本质上与顺序表是类似的， 
  <strong>它是在内存上找一段能放下当前数据的空间，但是当我们进行扩容等操作的时候的时候，可能原空间下就不够用了，就需要找一个新的位置开辟空间并且销毁旧空间，<span style="color:#fe2c24;">这个时候迭代器指向的位置就会发生变化，而it还记录的原来begin指向原来的那段空间，所以就会导致程序崩溃</span></strong>，出现迭代器失效的现象 
 </div> 
</blockquote> 
<div> 
 <strong>例如（错误示范）：</strong> 
</div> 
<div> 
 <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

int main()
{
	vector&lt;int&gt; v{ 1,2,3,4,5,6 };
	auto it = v.begin();
	v.resize(100, 8);            //这里会扩容
	while (it != v.end())
	{
		cout &lt;&lt; *it &lt;&lt; " ";
		++it;
	}
	cout &lt;&lt; endl;
	return 0;
}</code></pre> 
 <p><strong>运行结果：</strong><img alt="" height="544" src="https://images2.imgbox.com/2a/dd/s3rAF7I6_o.png" width="1006"></p> 
 <p><img alt="" height="665" src="https://images2.imgbox.com/94/08/zqVI3eLj_o.png" width="899"></p> 
 <h4 id="2%E3%80%81%E8%BF%9B%E8%A1%8C%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4%E7%9A%84%E6%97%B6%E5%80%99%E2%80%94erase"><strong><span style="background-color:#ffd900;">2、进行指定元素删除的时候—erase</span></strong></h4> 
 <blockquote> 
  <p>当进行指定位置删除时，最终返回的是删除元素的位置，当我们访问这个位置的时候，如果删除元素后面还有值，那么就会往前挪，我们就能访问到元素，但是当删除位置pos位于最后一个元素时，删除后我们访问就会访问到begin()，就会越界</p> 
 </blockquote> 
 <p><img alt="" height="521" src="https://images2.imgbox.com/3c/3d/3JXL1i3y_o.png" width="1200"></p> 
 <p><strong>代码实例：</strong></p> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
#include &lt;vector&gt;
int main()
{
	int a[] = { 1, 2, 3, 4 };
	vector&lt;int&gt; v(a, a + sizeof(a) / sizeof(int));
	// 使用find查找3所在位置的iterator
	vector&lt;int&gt;::iterator pos = find(v.begin(), v.end(), 3);
	// 删除pos位置的数据，导致pos迭代器失效。
	v.erase(pos);
	cout &lt;&lt; *pos &lt;&lt; endl; // 此处会导致非法访问
	return 0;
}</code></pre> 
 <p><strong>运行结果：</strong></p> 
 <p><img alt="" height="541" src="https://images2.imgbox.com/5a/c5/IAzrr3sQ_o.png" width="968"></p> 
 <h4 id="3%E3%80%81%E5%9C%A8%E5%85%B6%E4%BB%96%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5">3、在其他编译环境下的失效情况</h4> 
 <blockquote> 
  <p>这一点并不是很重要，在上面我们也提到了vector的迭代器失效也与编译器环境有关，这里有关指的是报错情况及运行上，例如在Linux下，g++对于迭代器失效的检查就没有那么严格，一般迭代器失效也能运行，只不过运行结果会出错，并不会直接中断，总之，迭代器失效一定会导致错误，我们在平时使用迭代器的时候一定要注意这个问题</p> 
 </blockquote> 
 <h4 id="4%E3%80%81string%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88">4、string的迭代器失效</h4> 
 <blockquote> 
  <p>string在内存中的存储情况有一点类似vector，也是在内存上先开辟空间，所以也会出现上面的哪些情况，出现迭代器失效的问题，具体原因与上面一样，下面我们给出一个例子观察一下</p> 
 </blockquote> 
 <p><strong>代码实例：</strong></p> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main()
{
	string s("hello");
	auto it = s.begin();

	// 放开之后代码会崩溃，因为resize到20会string会进行扩容
	// 扩容之后，it指向之前旧空间已经被释放了，该迭代器就失效了
	// 后序打印时，再访问it指向的空间程序就会崩溃
	//s.resize(20, '!');

	while (it != s.end())
	{
		cout &lt;&lt; *it;
		++it;
	}
	cout &lt;&lt; endl;
	it = s.begin();
	while (it != s.end())
	{
		it = s.erase(it);
		// 按照下面方式写，运行时程序会崩溃，因为erase(it)之后
		// it位置的迭代器就失效了
		// s.erase(it);
		++it;
	}
}</code></pre> 
 <p><strong>运行结果：</strong></p> 
 <p><img alt="" height="573" src="https://images2.imgbox.com/a6/f3/K8K5wgvX_o.png" width="916"></p> 
 <h2 id="%E4%B8%89%E3%80%81vector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">三、vector迭代器失效的解决方法</h2> 
 <blockquote> 
  <p>解决方法非常简单：<strong>在使用前重新赋值即可</strong></p> 
 </blockquote> 
 <p><strong>例如1中的：</strong></p> 
 <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

int main()
{
	vector&lt;int&gt; v{ 1,2,3,4,5,6 };
	auto it = v.begin();
	v.resize(100, 8);        //这里会扩容
	it = v.begin();          //使用前重新赋值
	while (it != v.end())
	{
		cout &lt;&lt; *it &lt;&lt; " ";
		++it;
	}
	cout &lt;&lt; endl;
	return 0;
}</code></pre> 
 <p><strong>运行结果：</strong></p> 
 <p><img alt="" height="315" src="https://images2.imgbox.com/d3/4b/lZj6kn6A_o.png" width="1200"></p> 
 <h2 id="%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93">四、总结</h2> 
 <blockquote> 
  <p>以上就是vector迭代器失效的问题，这个问题还是挺容易出现的，稍不留意就可能会出错，我们平时使用迭代器的时候要注意这点</p> 
 </blockquote> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/7b/58/mqSgebkv_o.jpg"></p> 
 <p><strong><span style="background-color:#ffd900;">感谢各位大佬观看，创作不易，还请各位大佬点赞支持！！！</span></strong></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6e84feb026a23f202443bdc56f3ed599/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">docker swarm多主机之间的端口无法访问，但能ping通 问题排查及解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bf62ed4cec13b52276edb5b37b19d837/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">《Python编程从入门到实践》day37</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>