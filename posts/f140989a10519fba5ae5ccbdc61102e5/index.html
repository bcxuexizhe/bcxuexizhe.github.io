<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构之顺序表的相关知识点及应用 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/f140989a10519fba5ae5ccbdc61102e5/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="数据结构之顺序表的相关知识点及应用">
  <meta property="og:description" content="个人主页（找往期文章包括但不限于本期文章中不懂的知识点）：我要学编程(ಥ_ಥ)-CSDN博客
目录
顺序表的概念及结构
顺序表的分类
顺序表的实现 在顺序表中增加数据 在顺序表中删除数据 在顺序表中查找数据 顺序表源码
顺序表的概念及结构 在了解顺序表之前，得先知道一个东西：线性表。线性表（linear list）是n个具有相同特性的数据元素的有限序列。简单理解就是：线性表指的是具有部分相同特性的一类数据结构的集合。例如：蔬菜分为绿叶类、瓜类、菌菇类。线性表是一种在实际中广泛使用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串... 线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的， 线性表在物理上存储时，通常以数组和链式结构的形式存储。 如何理解逻辑结构和物理结构？我们去超市买东西的时候，去付款时要排队，假设有很多人，也就意味着我们需要排成一条对去付款。这是在逻辑上就是一条线性的（我们下意识认为，是理想的），但是实际上在站队时不一定是线性的（现实情况）。但是顺序表在逻辑结构和物理结构上都是线性的。这是因为顺序表的底层实现逻辑是数组。我们知道数组在内存上是连续存放的（实际情况）。
注意：顺序表的底层虽然是数组，但是却是在数组的基础之上对数组进行了封装，实现了增删查改的一些功能。
顺序表的分类 我们知道数组有两种：一种是定长数组，也就是空间大小不可变化，是固定的；还有一种是变长数组，这个变长数组是我们用动态内存开辟函数申请来的（注意区分C99中引入的变长数组）。
根据数组的不同，顺序表也分为两种：静态顺序表（大小不可变），动态顺序表（大小可变）。
顺序表的实现 这两种顺序表一比较，肯定是第二种的优势明显一些，同样在项目中，动态顺序表的应用远远大于静态顺序表。下面我们就来学习动态顺序表的实现。
首先创建三个文件：SeqList.h —— 顺序表的头文件 SeqList.c —— 顺序表的实现 test.c——&gt;测试顺序表
顺序表的创建：
typedef struct SeqList { SLDataType* arr;//数组指针 int size;//记录当前有效的空间大小 int capacity;//记录当前总空间大小 }SL;//由于struct SeqList太长，比较麻烦，因此就重新定义 由于数组的类型是暂定为int，后续如果要改动的话，不是很方便，因此也是重定义。
typedef int SLDataType;//数组不一定是int类型 顺序表创建完了之后，就得开始实现它的基本功能：增 删 查 改。
在实现上面那些基本功能之前，我们肯定得把这个顺序表进行初始化。 //初始化顺序表 void InitSeqList(SL* ps)//由于要改变顺序表，所以传地址 { ps-&gt;arr = NULL;//没为数组分配内存空间 ps-&gt;capacity = 0; ps-&gt;size = 0; } 在顺序表中增加数据 接下来就开始实现增加数据，这个增加稍微有所不同：是在指定的位置增加数据。
我们先来实现两种特殊的情况：头插和尾插。头插是在顺序表的第一个位置（数组下标为0的位置）插入（增加）数据；尾插是在顺序表的有效数据的末尾插入（增加）数据。
首先，来实现头插：（数据从后往前覆盖）">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-06T14:55:23+08:00">
    <meta property="article:modified_time" content="2024-04-06T14:55:23+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构之顺序表的相关知识点及应用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p> 个人主页（找往期文章包括但不限于本期文章中不懂的知识点）：<a href="https://blog.csdn.net/2301_80854132?type=blog" title="我要学编程(ಥ_ಥ)-CSDN博客">我要学编程(ಥ_ಥ)-CSDN博客</a></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84" rel="nofollow">顺序表的概念及结构</a></p> 
<p id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB-toc" style="margin-left:0px;"><a href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB" rel="nofollow">顺序表的分类</a></p> 
<p id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:0px;"><a href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow">顺序表的实现 </a></p> 
<p id="%E5%9C%A8%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%AD%E5%A2%9E%E5%8A%A0%E6%95%B0%E6%8D%AE%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%9C%A8%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%AD%E5%A2%9E%E5%8A%A0%E6%95%B0%E6%8D%AE%C2%A0" rel="nofollow">在顺序表中增加数据 </a></p> 
<p id="%E5%9C%A8%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%9C%A8%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%C2%A0" rel="nofollow">在顺序表中删除数据 </a></p> 
<p id="%E5%9C%A8%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%9C%A8%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE%C2%A0" rel="nofollow">在顺序表中查找数据 </a></p> 
<p id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%BA%90%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%BA%90%E7%A0%81" rel="nofollow">顺序表源码</a></p> 
<hr id="hr-toc"> 
<p> </p> 
<h2 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84" style="background-color:transparent;"><span style="color:#fe2c24;">顺序表的概念及结构</span></h2> 
<p>在了解顺序表之前，得先知道一个东西：线性表。<strong>线性表</strong>（linear list）是n个具有相同特性的数据元素的有限序列。简单理解就是：线性表指的是具有部分相同特性的一类数据结构的集合。例如：蔬菜分为绿叶类、瓜类、菌菇类。线性表是一种在实际中广泛使用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串... 线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的， 线性表在物理上存储时，通常以数组和链式结构的形式存储。 如何理解逻辑结构和物理结构？我们去超市买东西的时候，去付款时要排队，假设有很多人，也就意味着我们需要排成一条对去付款。这是在逻辑上就是一条线性的（我们下意识认为，是理想的），但是实际上在站队时不一定是线性的（现实情况）。但是顺序表在逻辑结构和物理结构上都是线性的。这是因为顺序表的底层实现逻辑是数组。我们知道数组在内存上是连续存放的（实际情况）。</p> 
<p><strong>注意</strong>：顺序表的底层虽然是数组，但是却是在数组的基础之上对数组进行了封装，实现了增删查改的一些功能。</p> 
<h2 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span style="color:#fe2c24;"><strong>顺序表的分类</strong></span></h2> 
<p>我们知道数组有两种：一种是定长数组，也就是空间大小不可变化，是固定的；还有一种是变长数组，这个变长数组是我们用动态内存开辟函数申请来的（注意区分C99中引入的变长数组）。</p> 
<p>根据数组的不同，顺序表也分为两种：静态顺序表（大小不可变），动态顺序表（大小可变）。</p> 
<h2 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%C2%A0"><span style="color:#fe2c24;">顺序表的实现</span> </h2> 
<p>这两种顺序表一比较，肯定是第二种的优势明显一些，同样在项目中，动态顺序表的应用远远大于静态顺序表。下面我们就来学习动态顺序表的实现。</p> 
<p>首先创建三个文件：SeqList.h  —— 顺序表的头文件  SeqList.c  —— 顺序表的实现  test.c——&gt;测试顺序表</p> 
<p>顺序表的创建：</p> 
<pre><code class="language-cs">typedef struct SeqList
{
	SLDataType* arr;//数组指针
	int size;//记录当前有效的空间大小
	int capacity;//记录当前总空间大小
}SL;//由于struct SeqList太长，比较麻烦，因此就重新定义</code></pre> 
<p>由于数组的类型是暂定为int，后续如果要改动的话，不是很方便，因此也是重定义。</p> 
<pre><code class="language-cs">typedef int SLDataType;//数组不一定是int类型</code></pre> 
<p>顺序表创建完了之后，就得开始实现它的基本功能：增 删 查 改。</p> 
<p>在实现上面那些基本功能之前，我们肯定得把这个顺序表进行初始化。 </p> 
<pre><code class="language-cs">//初始化顺序表
void InitSeqList(SL* ps)//由于要改变顺序表，所以传地址
{
	ps-&gt;arr = NULL;//没为数组分配内存空间
	ps-&gt;capacity = 0;
	ps-&gt;size = 0;
}</code></pre> 
<h3 id="%E5%9C%A8%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%AD%E5%A2%9E%E5%8A%A0%E6%95%B0%E6%8D%AE%C2%A0"><span style="color:#38d8f0;">在顺序表中增加数据 </span></h3> 
<p>接下来就开始实现增加数据，这个增加稍微有所不同：是在指定的位置增加数据。</p> 
<p>我们先来实现两种特殊的情况：头插和尾插。头插是在顺序表的第一个位置（数组下标为0的位置）插入（增加）数据；尾插是在顺序表的有效数据的末尾插入（增加）数据。</p> 
<p>首先，来实现头插：（数据从后往前覆盖）</p> 
<p><img alt="" height="839" src="https://images2.imgbox.com/91/db/rnzm7cE5_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/f7/fe/T7bhxixa_o.png" width="1200"></p> 
<pre><code class="language-cs">//在顺序表的头部插入数据
void SLPushFront(SL* ps, SLDataType x)
{
	assert(ps);
	//判断是否需要扩容
	if (ps-&gt;size == ps-&gt;capacity)//数组满了
	{
		int newcapacity = 0;
		if (ps-&gt;capacity == 0)
		{
			newcapacity = BASE;//如果空间为0，先给BASE(4)个空间
		}
		else
		{
			newcapacity = 2 * ps-&gt;capacity;//扩容后为扩容前的两倍
		}
		//上面这个if...else语句，也可以写成下面这样
		//int newcapacity = (ps-&gt;capacity == 0) ? 4 : 2 * ps-&gt;capacity;
		SLDataType* tmp = (SLDataType*)realloc(ps-&gt;arr, newcapacity*sizeof(SLDataType));
		if (tmp == NULL)//扩容失败
		{
			perror("realloc");
			exit(1);//直接退出程序不在执行（异常退出）
			//return 1; //这样写也是可以的
		}
		//扩容成功
		ps-&gt;arr = tmp;
		ps-&gt;capacity = newcapacity;
	}
	//头插数据
	for (int i = ps-&gt;size; i &gt; 0; i--)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i - 1];
		//size[1] = size[0]; //根据边界来推上面的判断条件
	}
	ps-&gt;arr[0] = x;
	ps-&gt;size++;
}
</code></pre> 
<p>注意：在比较大型的项目中，我们写一些功能代码时，一定要去检查功能是否完整。比如：这里我们写这个头插功能的代码时，写完之后一定要去打印结果，看看是否满足我们的要求。 </p> 
<p>头插写完就开始写尾插了。</p> 
<p><img alt="" height="1074" src="https://images2.imgbox.com/5f/f2/T4CryOUU_o.png" width="1200"></p> 
<pre><code class="language-cs">//在顺序表的末尾插入数据
void SLPushBack(SL* ps, SLDataType x)
{
	assert(ps);
	//判断是否需要扩容
	if (ps-&gt;capacity == ps-&gt;size)//数组满了
	{
		int newcapacity = 0;
		if (ps-&gt;capacity == 0)//还没分配空间
		{
			newcapacity = BASE;
		}
		else
		{
			newcapacity = 2 * ps-&gt;capacity;
		}
		SLDataType* tmp = (SLDataType*)realloc(ps-&gt;arr, newcapacity*sizeof(SLDataType));
		if (tmp == NULL)
		{
			perror("realloc");
			exit(1);
		}
		ps-&gt;arr = tmp;
		tmp = NULL;
		ps-&gt;capacity = newcapacity;
	}
	//尾插数据
	ps-&gt;arr[ps-&gt;size++] = x;
	//上面也可以转为下面的写法
	//ps-&gt;arr[ps-&gt;size] = x;
	//ps-&gt;size++;
}</code></pre> 
<p>通过观察上面两个代码，我们会发现那个判断是否需要增容的部分是一样的，因此我们就可以把这个判断是否需要增容的部分写成一个函数（可以只判断，也可以把增容的部分也写进去）。</p> 
<p>那么上面的代码就可以简化成下面的样子。 </p> 
<pre><code class="language-cs">//判断是否需要增容（如果需要，则直接自动增容）
void SLCheckCapacity(SL* ps)
{
	if (ps-&gt;size == ps-&gt;capacity)//数组满了
	{
		int newcapacity = 0;
		if (ps-&gt;capacity == 0)
		{
			newcapacity = BASE;//如果空间为0，先给4个空间
		}
		else
		{
			newcapacity = 2 * ps-&gt;capacity;//扩容后为扩容前的两倍
		}
		//上面这个if...else语句，也可以写成下面这样
		//int newcapacity = (ps-&gt;capacity == 0) ? 4 : 2 * ps-&gt;capacity;
		SLDataType* tmp = (SLDataType*)realloc(ps-&gt;arr, newcapacity*sizeof(SLDataType));
		if (tmp == NULL)//扩容失败
		{
			perror("realloc");
			exit(1);//直接退出程序不在执行（异常退出）
			//return 1; //这样写也是可以的
		}
		//扩容成功
		ps-&gt;arr = tmp;
		ps-&gt;capacity = newcapacity;
	}
}


//在顺序表的头部插入数据
void SLPushFront(SL* ps, SLDataType x)
{
	assert(ps);
	//判断是否需要扩容
	SLCheckCapacity(ps);
	//头插数据
	for (int i = ps-&gt;size; i &gt; 0; i--)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i - 1];
		//size[1] = size[0]; //根据边界来推上面的判断条件
	}
	ps-&gt;arr[0] = x;
	ps-&gt;size++;
}


//在顺序表的末尾插入数据
void SLPushBack(SL* ps, SLDataType x)
{
	assert(ps);
	SLCheckCapacity(ps);
	//尾插数据
	ps-&gt;arr[ps-&gt;size++] = x;
	//上面也可以转为下面的写法
	//ps-&gt;arr[ps-&gt;size] = x;
	//ps-&gt;size++;
}</code></pre> 
<p>两种特殊的插入写完之后，就得开始写指定插入，就是说在指定的位置插入数据。 （和头插一样，从后往前覆盖）</p> 
<p><img alt="" height="785" src="https://images2.imgbox.com/9d/ac/6StyyI0r_o.png" width="1200"></p> 
<p><img alt="" height="1092" src="https://images2.imgbox.com/8a/ca/Ej9r5NvR_o.png" width="1200"></p> 
<pre><code class="language-cs">//在指定位置插入数据
void SLInsert(SL* ps, int pos, SLDataType x)
{
	assert(ps);
	SLCheckCapacity(ps);
	for (int i = ps-&gt;size; i &gt; pos; i--)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i - 1];
		//arr[2] = arr[1]; 
	}
	ps-&gt;arr[pos] = x;
	ps-&gt;size++;
}</code></pre> 
<h3 id="%E5%9C%A8%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%C2%A0"><span style="color:#38d8f0;">在顺序表中删除数据</span> </h3> 
<p>接下来就是删除数据。同样删除数据也根据上面的方式来先实现特殊方式：头删和尾删。 </p> 
<p>注意删除数据时，一定要判断是否有数据。</p> 
<p>先来看头删。（数据从前往后覆盖）<img alt="" height="817" src="https://images2.imgbox.com/fd/d4/0sTUGN9Z_o.png" width="1057"></p> 
<pre><code class="language-cs">void SLPopFront(SL* ps)
{
    assert(ps);
    assert(ps-&gt;size);//看看有没有数据
	for (int i = 0; i &lt; ps-&gt;size - 1; i++)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i + 1];
	}
	ps-&gt;size--;
}</code></pre> 
<p>尾删就比较简单了。 </p> 
<p><img alt="" height="819" src="https://images2.imgbox.com/c1/b7/nVwL8Izm_o.png" width="1031"></p> 
<pre><code class="language-cs">void SLPopBack(SL* ps)
{
    assert(ps);
    assert(ps-&gt;size);
	//ps-&gt;arr[size-1] = 0; //这一步可有可无
	ps-&gt;size--;
}
</code></pre> 
<p>接下来就是写在指定位置删除数据。 </p> 
<p><img alt="" height="1099" src="https://images2.imgbox.com/83/ff/bLIdxzN9_o.png" width="1200"></p> 
<h3 id="%E5%9C%A8%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE%C2%A0"><span style="color:#38d8f0;">在顺序表中查找数据</span> </h3> 
<p>最后，我们就要实现在顺序表中查找数据。 </p> 
<p>找数据的话，就是简单的循环找就行了。</p> 
<pre><code class="language-cs">//在顺序表中查找数据
int SLFind(SL* ps, SLDataType x)
{
    assert(ps);
   	for (int i = 0; i &lt; ps-&gt;size; i++)
	{
		if (ps-&gt;arr[i] == x)
		{
			return i;//找到了，返回x在顺序表中的下标
		}
	}
	return -1;//没找到
}</code></pre> 
<p>上面就是顺序表的全部逻辑以及实现。</p> 
<h2 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%BA%90%E7%A0%81" style="background-color:transparent;"><span style="color:#fe2c24;">顺序表源码</span></h2> 
<p>下面是顺序表的源码：</p> 
<p>SeqList.c</p> 
<pre><code class="language-cs">#include "SeqList.h"

//初始化顺序表
void InitSeqList(SL* ps)
{
	ps-&gt;arr = NULL;//没为数组分配内存空间
	ps-&gt;capacity = 0;
	ps-&gt;size = 0;
}


//销毁顺序表
void SLDestroy(SL* ps)
{
	if (ps-&gt;arr)//有可能我们还没有使用（为空）
	{
		free(ps-&gt;arr);
	}
	ps-&gt;arr = NULL;
	ps-&gt;size = 0;
	ps-&gt;capacity = 0;
}


//打印顺序表
void SLPrint(const SL* ps)//只是打印不想被更改数据
{
	for (int i = 0; i &lt; ps-&gt;size; i++)
	{
		printf("%d ", ps-&gt;arr[i]);
	}
	printf("\n");//可以选择换行，不写也没关系
}


//判断是否需要增容（如果需要，则直接自动增容）
void SLCheckCapacity(SL* ps)
{
	if (ps-&gt;size == ps-&gt;capacity)//数组满了
	{
		int newcapacity = 0;
		if (ps-&gt;capacity == 0)
		{
			newcapacity = BASE;//如果空间为0，先给4个空间
		}
		else
		{
			newcapacity = 2 * ps-&gt;capacity;//扩容后为扩容前的两倍
		}
		//上面这个if...else语句，也可以写成下面这样
		//int newcapacity = (ps-&gt;capacity == 0) ? 4 : 2 * ps-&gt;capacity;
		SLDataType* tmp = (SLDataType*)realloc(ps-&gt;arr, newcapacity*sizeof(SLDataType));
		if (tmp == NULL)//扩容失败
		{
			perror("realloc");
			exit(1);//直接退出程序不在执行（异常退出）
			//return 1; //这样写也是可以的
		}
		//扩容成功
		ps-&gt;arr = tmp;
		ps-&gt;capacity = newcapacity;
	}
}


//在顺序表的头部插入数据
void SLPushFront(SL* ps, SLDataType x)
{
	assert(ps);
	//判断是否需要扩容
	SLCheckCapacity(ps);//ps是一个指针（没有&amp;，因此也是一个值）
	//头插数据
	for (int i = ps-&gt;size; i &gt; 0; i--)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i - 1];
		//size[1] = size[0]; //根据边界来推上面的判断条件
	}
	ps-&gt;arr[0] = x;
	ps-&gt;size++;
}


//在顺序表的末尾插入数据
void SLPushBack(SL* ps, SLDataType x)
{
	assert(ps);
	SLCheckCapacity(ps);
	//尾插数据
	ps-&gt;arr[ps-&gt;size++] = x;
	//上面也可以转为下面的写法
	//ps-&gt;arr[ps-&gt;size] = x;
	//ps-&gt;size++;
}


//在指定位置插入数据
void SLInsert(SL* ps, int pos, SLDataType x)
{
	assert(ps);
	SLCheckCapacity(ps);
	for (int i = ps-&gt;size; i &gt; pos; i--)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i - 1];
		//arr[2] = arr[1]; 
	}
	ps-&gt;arr[pos] = x;
	ps-&gt;size++;
}


//删除顺序表头部的数据
void SLPopFront(SL* ps)
{
	for (int i = 0; i &lt; ps-&gt;size - 1; i++)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i + 1];
	}
	ps-&gt;size--;
}


//删除顺序表尾部的数据
void SLPopBack(SL* ps)
{
	assert(ps);
	assert(ps-&gt;size);
	//ps-&gt;arr[size-1] = 0; //这一步可有可无
	ps-&gt;size--;
}


//删除指定位置的数据
void SLErase(SL* ps, int pos)
{
	assert(ps);
	assert(ps-&gt;size);
	for (int i = pos; i &lt; ps-&gt;size - 1; i++)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i + 1];
	}
	ps-&gt;size--;
}


//在顺序表中查找数据
int SLFind(SL* ps, SLDataType x)
{
	for (int i = 0; i &lt; ps-&gt;size; i++)
	{
		if (ps-&gt;arr[i] == x)
		{
			return i;//找到了，返回x在顺序表中的下标
		}
	}
	return -1;//没找到
}</code></pre> 
<p>SeqList.h </p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

#define BASE 4

typedef int SLDataType;//数组不一定是int类型

typedef struct SeqList
{
	SLDataType* arr;//数组指针（）
	int size;//记录当前有效的空间大小
	int capacity;//记录当前总空间大小
}SL;


void InitSeqList(SL* ps);//初始化顺序表

void SLDestroy(SL* ps);//销毁顺序表

void SLPrint(const SL* ps);//打印顺序表的数据

void SLPushFront(SL* ps, SLDataType x);//在顺序表的头部插入数据

void SLPushBack(SL* ps, SLDataType x);//在顺序表的末尾插入数据

void SLInsert(SL* ps, int pos, SLDataType x);//在指定位置插入数据

void SLPopFront(SL* ps);//删除顺序表头部的数据

void SLPopBack(SL* ps);//删除顺序表尾部的数据

void SLErase(SL* ps, int pos);//删除指定位置的数据

int SLFind(SL* ps, SLDataType x);//在顺序表中查找数据</code></pre> 
<p>好啦！本期数据结构顺序表的学习就到此为止啦！我们下一期再一起学习吧！ </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/316364288d2859184260b1b99295a1f7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前端必备技能——轮播图（原生代码&#43;插件），前端开发项目</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1531b9a14db8a815960c8e9a87e69228/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">初始Java篇（JavaSE基础语法）（6）（继承和多态）（上）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>