<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2024年网络安全最全凯哥带你从零学大数据系列之Java篇---第十七章 集合(List)(1)，2024年最新带你轻松理解网络安全-Hook机制 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/e3f0e947814c486c131605818f9370ac/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="2024年网络安全最全凯哥带你从零学大数据系列之Java篇---第十七章 集合(List)(1)，2024年最新带你轻松理解网络安全-Hook机制">
  <meta property="og:description" content="学习路线： 这个方向初期比较容易入门一些，掌握一些基本技术，拿起各种现成的工具就可以开黑了。不过，要想从脚本小子变成黑客大神，这个方向越往后，需要学习和掌握的东西就会越来越多以下是网络渗透需要学习的内容：
网上学习资料一大堆，但如果学到的知识不成体系，遇到问题时只是浅尝辄止，不再深入研究，那么很难做到真正的技术提升。
需要这份系统化资料的朋友，可以点击这里获取
一个人可以走的很快，但一群人才能走的更远！不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！
17.3. 示例代码
import java.util.ArrayList; import java.util.List; /** * @Description List接口的方法 */ public class Test1 { public static void main(String[] args) { // 1. 实例化一个ArrayList对象，向上转型为接口类型。 List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 2. 增元素 list.add(&#34;Lily&#34;); list.add(&#34;Lucy&#34;); list.add(&#34;Polly&#34;); list.add(&#34;Jim&#34;); // 3. 在集合中指定的下标位插入元素 list.add(2, &#34;Tom&#34;); // 4. 在集合中指定的下标位插入另外一个集合中所有的数据 list.addAll(2, list); // 5. 删除集合中指定下标位的元素 // 返回值：这个被删除的元素 System.out.println(list.remove(2)); // 6. 修改指定下标位的值 // 返回被覆盖的值。 System.out.println(list.set(2, &#34;AAA&#34;)); // 7* 元素替换 // 将集合中的每一个元素，带入到接口的方法中，用返回值替换原来的元素 // list.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-06T23:39:11+08:00">
    <meta property="article:modified_time" content="2024-05-06T23:39:11+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2024年网络安全最全凯哥带你从零学大数据系列之Java篇---第十七章 集合(List)(1)，2024年最新带你轻松理解网络安全-Hook机制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_2"></a>学习路线：</h3> 
<p>这个方向初期比较容易入门一些，掌握一些基本技术，拿起各种现成的工具就可以开黑了。不过，要想从脚本小子变成黑客大神，这个方向越往后，需要学习和掌握的东西就会越来越多以下是网络渗透需要学习的内容：<br> <img src="https://images2.imgbox.com/e9/ec/UcCj8hYp_o.png" alt="在这里插入图片描述"></p> 
<p><strong>网上学习资料一大堆，但如果学到的知识不成体系，遇到问题时只是浅尝辄止，不再深入研究，那么很难做到真正的技术提升。</strong></p> 
<p><strong><a href="https://bbs.csdn.net/topics/618540462">需要这份系统化资料的朋友，可以点击这里获取</a></strong></p> 
<p><strong>一个人可以走的很快，但一群人才能走的更远！不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！</strong></p> 
<p><strong>17.3. 示例代码</strong></p> 
<pre><code>import java.util.ArrayList;
import java.util.List;

/**
 * @Description List接口的方法
 */
public class Test1 {
    public static void main(String[] args) {
        // 1. 实例化一个ArrayList对象，向上转型为接口类型。
        List&lt;String&gt; list = new ArrayList&lt;&gt;();

        // 2. 增元素
        list.add("Lily");
        list.add("Lucy");
        list.add("Polly");
        list.add("Jim");

        // 3. 在集合中指定的下标位插入元素
        list.add(2, "Tom");

        // 4. 在集合中指定的下标位插入另外一个集合中所有的数据
        list.addAll(2, list);

        // 5. 删除集合中指定下标位的元素
        //    返回值：这个被删除的元素
        System.out.println(list.remove(2));

        // 6. 修改指定下标位的值
        //    返回被覆盖的值。
        System.out.println(list.set(2, "AAA"));
        
        // 7* 元素替换
        //     将集合中的每一个元素，带入到接口的方法中，用返回值替换原来的元素
        // list.replaceAll(ele -&gt; ele.concat(".txt"));

        // 8. 获取指定下标位的元素。
        System.out.println(list.get(2));

        // 9. 获取集合中的某一个元素第一次出现的下标
        System.out.println(list.indexOf("Jim"));

        // 10. 获取集合中的某一个元素最后一次出现的下标
        System.out.println(list.lastIndexOf("Jim"));

        // 11. 从一个集合中，截取一部分，作为子集合。 [from, to)
        List&lt;String&gt; sub = list.subList(2, 60);

        System.out.println(list);
        System.out.println(sub);
    }
}
</code></pre> 
<p><strong>17.4. List集合排序</strong></p> 
<p>在List接口中，提供了一个排序的方法 sort</p> 
<p><strong>方法原型</strong></p> 
<pre><code>default void sort(Comparator&lt;? super E&gt; c)
</code></pre> 
<p><strong>方法逻辑</strong></p> 
<p>这是一个系统封装好的一个用来做排序的方法，由于集合中只能存储引用数据类型的数据，因此，需要明确两个元素的大小关系。参数Comparator是一个对象大小比较的接口。在这个接口的方法中，有两个参数，分别表示参与比较的两个对象。返回值是int类型，不看具体的值，只看正负。</p> 
<pre><code>/**
 * 两个对象的大小比较方法
 * @param o1 参与比较的一个对象
 * @param o2 参与比较的另一个对象
 * @return 比较的结果
 *		&gt; 0	: o1 &gt; o2
 *	   == 0 : o1 == o2
 *		&lt; 0 : o1 &lt; o2
 */
int compare(T o1, T o2)
</code></pre> 
<p><strong>示例代码</strong></p> 
<pre><code>import java.util.ArrayList;
import java.util.List;

/**
 * @Description 集合的元素排序
 */
public class Test2 {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();

        // 2. 增元素
        list.add("Lily");
        list.add("Lucy");
        list.add("Polly");
        list.add("Jim");

        // 排序: 按照两个字符串的长度进行大小比较，升序排序
        list.sort((e1, e2) -&gt; e1.length() - e2.length());
    }
}
</code></pre> 
<p><strong>17.5. List集合遍历</strong></p> 
<p>由于List接口是继承自Collection接口的，因此在Collection部分的三种遍历方式，都可以用来遍历List集合。同时，在List集合中，还添加了两种用来遍历集合的其他方式。</p> 
<h5><a id="1751__142"></a><strong>17.5.1. 下标遍历</strong></h5> 
<p>顾名思义， 类似于数组的下标遍历。 遍历集合中的所有的下标， 依次获取指定下标位的元素。</p> 
<pre><code>import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.ListIterator;

/**
 * @Description List集合遍历
 */
public class List1 {
    public static void main(String[] args) {
        // 1. 实例化一个List集合，存储若干数据
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        Collections.addAll(list, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100);
        // 2. 遍历
        index(list);
    }
    /**
     * 下标遍历法
     * @param list 需要遍历的集合
     */
    private static void index(List&lt;Integer&gt; list) {
        for (int i = 0; i &lt; list.size(); i++) {
            // 获取每一个元素
            System.out.println(list.get(i));
        }
    }
}
</code></pre> 
<p><strong>17.5.2. 列表迭代器</strong></p> 
<p>这种方式， 类似于迭代器。 在List集合中， 有一个方法 <code>listIterator()</code>， 可以获取到一个 <code>ListIterator</code> 接口的引用。 而<code>ListIterator</code>是<code>Iterator</code>的子接口。 因此在保留了传统的迭代器的迭代方法的基础上， 还添加了若干个其他的方法。</p> 
<blockquote> 
 <p>使用ListIterator， 在遍历集合中的元素的同时， 可以向集合中添加元素、删除元素、修改元素。</p> 
 <p>但是， 这里对集合中的元素操作， 并不是使用 List 接口中的方法， 而是用 ListIterator 接口中的方法完成。</p> 
</blockquote> 
<pre><code>import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.ListIterator;

/**
 * @Description List集合遍历
 */
public class List1 {
    public static void main(String[] args) {
        // 1. 实例化一个List集合，存储若干数据
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        Collections.addAll(list, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100);
        // 2. 遍历
        listIterator(list);
    }
    /**
     * 使用列表迭代器完成遍历
     * @param list 需要遍历的集合
     */
    private static void listIterator(List&lt;Integer&gt; list) {
        // 1. 获取到 ListIterator 对象
        ListIterator&lt;Integer&gt; iterator = list.listIterator(4);
        // 2. 循环遍历
        while (iterator.hasNext()) {
            // 2.1. 获取迭代器当前指向的元素
            Integer ele = iterator.next();
            System.out.println(ele);
            // 2.2. 元素操作
            if (ele == 30) {
                // 添加：在迭代器当前指向的元素的下一位插入一个元素
                // 新增的元素，没有存在于迭代列表中，迭代器会直接指向原集合中的下一个元素
                // iterator.add(300);
                // 删除：删除迭代器当前指向的这一位元素
                // iterator.remove();
                // 修改：修改迭代器当前指向的这一位元素
                // iterator.set(300);
            }
        }
        System.out.println(list);
    }
}
</code></pre> 
<h4><a id="176_ArrayListLinkedList_239"></a><strong>17.6. ArrayList与LinkedList</strong></h4> 
<ul><li>相同点： 
  <ul><li>都是List集合的常用的实现类。</li><li>对集合中的元素操作的方法基本一致。</li></ul> </li><li>不同点： 
  <ul><li>ArrayList底层实现是数组， 使用数组这种数据结构进行数据的存储。</li><li>LinkedList底层实现是双链表， 使用双链表这种数据结构进行数据的存储。</li></ul> </li></ul> 
<p><strong>ArrayList与LinkedList的使用场景：</strong></p> 
<ul><li>如果对集合中的元素， 增删操作不怎么频繁， 查询操作比较频繁。 使用ArrayList。</li><li>如果对集合中的元素， 增删操作比较频繁， 查询操作不怎么频繁。 使用LinkedList。</li></ul> 
<h4><a id="177__257"></a><strong>17.7. 双链表数据结构</strong></h4> 
<h5><a id="1771__260"></a><strong>17.7.1. 链表简介</strong></h5> 
<p>链表， 其实是一种比较常见的数据结构。 增删效率比较高， 查询效率比较低。</p> 
<p>数据在链表中存储， 是以节点为单位进行存储的。 节点之间在内存上是不连续的。 双向链表中的每一个节点， 除了记录了当前节点存储的元素之外， 还记录了上一个节点和下一个节点的地址。</p> 
<h5><a id="1772__269"></a><strong>17.7.2. 示例代码</strong></h5> 
<pre><code>/**
 * @Description 使用链表数据结构实现一个自定义的集合(模拟LinkedList)
 */
public class MyLinkedList&lt;E&gt; {
    // 链表中，元素是以节点的形式存储的
    // 内部类，表示一个节点
    private class Node {
        E element;      // 表示这个节点需要存储的元素
        Node previous;  // 上一个节点的地址
        Node next;      // 下一个节点的地址
        Node(E element) {
            this.element = element;
        }
    }

    private Node first;     // 描述链表中的首节点
    private Node last;      // 描述链表中的尾结点
    private int count;      // 描述链表中节点数量

    /**
     * 在当前集合中添加一个元素
     * @param element 要添加的元素
     */
    public void add(E element) {
        // 1. 实例化一个节点，用来存储这个节点要存储的元素
        Node node = new Node(element);
        // 2. 判断当前的链表是否是空链表
        if (count == 0) {
            // 说明当前链表是一个空链表
            this.first = node;
        }
        else {
            // 说明当前链表不是一个空链表
            // 需要把当前节点挂在尾结点的后面
            this.last.next = node;
            node.previous = this.last;
        }
        this.last = node;   // 新增的这个节点，就是当前链表中的新的尾结点
        count++;            // 节点数量+1
    }

    /**
     * 在链表中，指定的下标位置插入一个元素
     * @param index 指定的下标位
     * @param element 需要插入的元素
     */
    public void add(int index, E element) {
        // 1. 实例化一个新的节点
        Node node = new Node(element);
        // 2. 节点关联
        if (index == 0) {
            // 说明在首位插入一个新的节点
            this.first.previous = node;
            node.next = this.first;
            // 这个节点就是新的首节点
            this.first = node;
        }
        else if (index == count) {
            // 说明在尾结点插入一个新的节点
            this.last.next = node;
            node.previous = this.last;
            // 这个新的节点就是新的尾结点
            this.last = node;
        }
        else {
            // 说明在中间节点插入一个元素
            // 1. 获取指定下标的节点
            Node target = getNode(index);
            // 节点关联
            node.next = target;
            node.previous = target.previous;
            target.previous.next = node;
            // 这个节点设置需要在后面
            target.previous = node;
        }
        count++;
    }

    /**
     * 删除指定下标位的元素
     * @param index 指定的下标位


### 给大家的福利


**零基础入门**


对于从来没有接触过网络安全的同学，我们帮你准备了详细的学习成长路线图。可以说是最科学最系统的学习路线，大家跟着这个大的方向学习准没问题。


![](https://img-blog.csdnimg.cn/img_convert/95608e9062782d28f4f04f821405d99a.png)


同时每个成长路线对应的板块都有配套的视频提供：


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/a91b9e8100834e9291cfcf1695d8cd42.png#pic_center)


因篇幅有限，仅展示部分资料

**网上学习资料一大堆，但如果学到的知识不成体系，遇到问题时只是浅尝辄止，不再深入研究，那么很难做到真正的技术提升。**

**[需要这份系统化资料的朋友，可以点击这里获取](https://bbs.csdn.net/topics/618540462)**

**一个人可以走的很快，但一群人才能走的更远！不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！**

</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/41410fb202f6d75264b7302ccbcb637b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【一步一步了解Java系列】：探索Java基本类型转换的秘密</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4942899091c7fb3946e0f9ab17765ece/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AI大模型探索之路-训练篇16：大语言模型预训练-微调技术之LoRA</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>