<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构：队列 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/dc47b0a743d6fb61a5726eaf1601a7b8/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="数据结构：队列">
  <meta property="og:description" content="一 队列的基本概念： 1.队列的定义： 队列(Queue)简称队，也是和栈一样是一种受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。向队列中插入元素称为入队或进队；删除元素称为出队或离队。这和我们日常生活中的排队是一致的，最早排队的也是对早离队的，其操作的特性就是先进先出(First In First Out FIFO)。
队头 (Front) 允许删除的一端，又称队首。
队尾(Rear) 允许插入的一端。
空队列 不含元素的空链表。
二 队列的链式存储结构： 1.队列的存储结构： typedef int QDataType; typedef struct QueueNode { int val; struct QueueNode* next; }QNode; typedef struct Queue { QNode* phead; QNode* ptail; int size; }Queue; 2.队列的所有接口： //队列的初始化、销毁 void QueueInit(Queue* pq); void QueueDestroy(Queue* pq); // 入队列、 出队列 void QueuePush(Queue* pq, QDataType x); void QueuePop(Queue* pq); //获取队头、队尾元素 QDataType QueueFront(Queue* pq); QDataType QueueBack(Queue* pq); //判断队列是否为空 bool QueueEmpty(Queue* pq); //获取队列元素个数 int QueueSize(Queue* pq); 3.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-06T15:59:43+08:00">
    <meta property="article:modified_time" content="2024-05-06T15:59:43+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构：队列</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一 队列的基本概念：</h2> 
<h4>1.队列的定义：</h4> 
<p>队列(Queue)简称队，也是和栈一样是一种<span style="color:#fe2c24;">受限的线性表</span>，只允许在表的一端进行插入，而在表的另一端进行删除。向队列中<span style="color:#0d0016;">插入元素称为</span><span style="color:#fe2c24;">入队或进队</span>；<span style="color:#0d0016;">删除元素称为</span><span style="color:#fe2c24;">出队或离队</span><span style="color:#0d0016;">。这和我们日常生活中的排队是一致的，最早排队的也是对早离队的，其操作的特性就是先进先出(First In First Out FIFO)。</span><br><span style="color:#0d0016;"><strong>队头 (Front)</strong> 允许删除的一端，又称队首。<br><strong>队尾(Rear)</strong> 允许插入的一端。<br><strong>空队列</strong> 不含元素的空链表。</span></p> 
<h2>二 队列的链式存储结构：</h2> 
<h2><img alt="" height="332" src="https://images2.imgbox.com/fe/0b/VrsSoIBI_o.png" width="886"></h2> 
<h4>1.队列的存储结构：</h4> 
<pre><code>typedef int QDataType;
typedef struct QueueNode
{
	int val;
	struct QueueNode* next;
}QNode;

typedef struct Queue
{
	QNode* phead;
	QNode* ptail;
	int size;
}Queue;</code></pre> 
<h4>2.队列的所有接口：</h4> 
<pre><code>//队列的初始化、销毁
void QueueInit(Queue* pq);
void QueueDestroy(Queue* pq);

// 入队列、 出队列
void QueuePush(Queue* pq, QDataType x);
void QueuePop(Queue* pq);

//获取队头、队尾元素
QDataType QueueFront(Queue* pq);
QDataType QueueBack(Queue* pq);

//判断队列是否为空
bool QueueEmpty(Queue* pq);

//获取队列元素个数
int QueueSize(Queue* pq);</code></pre> 
<h4>3.队列的初始化：</h4> 
<pre><code>void QueueInit(Queue* pq)
{
	pq-&gt;phead = NULL;
	pq-&gt;ptail = NULL;
	pq-&gt;size = 0;
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="163" src="https://images2.imgbox.com/44/f1/jIZcS6bt_o.png" width="1200"></p> 
<h4>4.队列的销毁：</h4> 
<pre><code>void QueueDestroy(Queue* pq)
{
	assert(pq);
	QNode* cur = pq-&gt;phead;
	while (cur)
	{
		QNode* next = cur-&gt;next;
		free(cur);
		cur = next;
	}
	pq-&gt;phead = pq-&gt;ptail = NULL;
	pq-&gt;size = 0;
}
</code></pre> 
<p>销毁：</p> 
<p><img alt="" height="118" src="https://images2.imgbox.com/c8/c4/d22F3JIv_o.png" width="1200"></p> 
<h4>5.入队列：</h4> 
<pre><code>void QueuePush(Queue* pq, QDataType x)
{
	assert(pq);
	QNode* Newnode = (QNode*)malloc(sizeof(QNode));
	if (Newnode == NULL)
	{
		perror("malloc error");
		exit(-1);
	}
	Newnode-&gt;next = NULL;
	Newnode-&gt;val = x;
	if (pq-&gt;ptail)
	{
		pq-&gt;ptail-&gt;next = Newnode;
		pq-&gt;ptail = Newnode;
	}
	else
	{
		pq-&gt;phead = pq-&gt;ptail = Newnode;//当最开始的时候我们让phead,ptail指针都指向Newnode
	}
	pq-&gt;size++;
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="334" src="https://images2.imgbox.com/65/24/uTOJP2CD_o.png" width="1200"></p> 
<h4>6.出队列：</h4> 
<pre><code>void QueuePop(Queue* pq)
{
	assert(pq);
	assert(pq-&gt;phead != NULL);

	// 一个节点
	if (pq-&gt;phead-&gt;next == NULL)
	{
		free(pq-&gt;phead);
		pq-&gt;phead = pq-&gt;ptail = NULL;
	}
	// 多个节点
	else
	{
		QNode* next = pq-&gt;phead-&gt;next;
		free(pq-&gt;phead);
		pq-&gt;phead = next;
	}

	pq-&gt;size--;
}
</code></pre> 
<p>输出：</p> 
<p><img alt="" height="256" src="https://images2.imgbox.com/70/36/p641bdGf_o.png" width="1200"></p> 
<h4>7.获取队顶元素：</h4> 
<pre><code>QDataType QueueFront(Queue* pq)
{
	return pq-&gt;phead-&gt;val;
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="133" src="https://images2.imgbox.com/72/31/ceDCyPRb_o.png" width="1200"></p> 
<h4>8.获取队尾数据：</h4> 
<pre><code>QDataType QueueBack(Queue* pq)
{
	return pq-&gt;ptail-&gt;val;
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="114" src="https://images2.imgbox.com/84/e1/WeKptqHO_o.png" width="1200"></p> 
<h4>9.获取有效数据个数：</h4> 
<pre><code>int QueueSize(Queue* pq)
{
	return pq-&gt;size;
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="119" src="https://images2.imgbox.com/ef/f2/P3YTMbEq_o.png" width="1200"></p> 
<h4>10.判断队列是否为空：</h4> 
<pre><code>bool QueueEmpty(Queue* pq)
{
	if (pq-&gt;ptail == NULL)
	{
		return false;
	}
	else
	{
		return true;
	}
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="456" src="https://images2.imgbox.com/12/61/593RL5ST_o.png" width="1200"></p> 
<h4>11.打印队列:</h4> 
<p><img alt="" height="320" src="https://images2.imgbox.com/62/fd/crOrvX3Q_o.png" width="1200"></p> 
<h2>队列与栈的总结:</h2> 
<p><strong>队列</strong>是一种遵循<span style="color:#fe2c24;">先进先出</span>（FIFO）受限的线性数据结构。<span style="color:#fe2c24;"><strong>元素从队列的尾部添加，从队列的头部移除</strong></span>。队列通常用于模拟现实世界中按到达顺序处理项目的场景。</p> 
<p><strong>栈</strong>是一种遵循后进先出（LIFO）受限的线性数据结构。<strong><span style="color:#fe2c24;">元素从栈的顶部添加，从栈的顶部移除。</span></strong>栈通常用于实现涉及回溯或解决递归问题的算法。</p> 
<p>队列和栈是基础数据结构，具有不同的特性和应用。队列适用于按顺序管理项，而栈适用于实现涉及回溯或解决递归问题的算法。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e4b31db9d34e2c6d31141e206abdcd72/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">为什么 ChatGPT 不火了？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bcbcc17429eb8ab2af78e6feba81b03b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">1. MySQL 5.7安装部署</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>