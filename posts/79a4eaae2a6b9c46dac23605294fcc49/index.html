<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【高阶数据结构(四)】图的最短路径问题 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/79a4eaae2a6b9c46dac23605294fcc49/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【高阶数据结构(四)】图的最短路径问题">
  <meta property="og:description" content="💓博主CSDN主页:杭电码农-NEO💓
⏩专栏分类:高阶数据结构专栏⏪
🚚代码仓库:NEO的学习日记🚚
🌹关注我🫵带你学习更多数据结构
🔝🔝
高阶数据结构 1. 前言2. 单源最短路径问题3. dijkstra算法讲解4. bellman-Ford算法讲解5. 多源最短路径问题6. Floyd-Warshall算法讲解7. 总结 1. 前言 关于图论,无非就是最小生成树问题和最短路径问题. 对于最短路径问题来说, 分为单源最短路径和多源最短路径, 并且图中的权值是否有负数, 对应能使用的算法也不同
本章重点:
本篇文章着重讲解图的单源最短路径之Dijkstra算法和bellman-Ford算法.以及多源最短路径之Floyd-wars hall算法. 文章会着重讲解这些算法的思路, 代码实现部分要靠大家的理解能力了
2. 单源最短路径问题 所谓的单源最短路径,也就是从图中任意一点出发, 到图中每个节点的最短路径,也就是最小的权值和
对于单源最短路径的求解. 我们一般使用输出型参数. 用两个数组来表示最短路径的权值以及最短路径的路径.
//存储任意点到图中其他点的最短路径的权值 vector&lt;W&gt;&amp; dist //记录srci-&gt;其他顶点最短路径父顶点数组 vector&lt;int&gt;&amp; parentPath 第一个数组很好理解. 图中的顶点会简化成为数组中的元素. 所以dist数组中的dist[i]=j.代表顶点i到srci的最短路径的权值. 不好理解的是第二个数组. 它存储的是最短路径的父顶点. 什么意思呢? 请看下图:
3. dijkstra算法讲解 针对一个带权有向图G，将所有结点分为两组S和Q，S是已经确定最短路径的结点集合，在初始时为空（初始时就可以将源节点s放入，毕竟源节点到自己的代价是0），Q 为其余未确定最短路径的结点集合，每次从Q 中找出一个起点到该结点代价最小的结点u ，将u 从Q 中移出，并放入S 中，对u 的每一个相邻结点v 进行松弛操作。
松弛即对每一个相邻结点v ，判断源节点s到结点u 的代价与u 到v 的代价之和是否比原来s 到v 的代价更小，若代价比原来小则要将s 到v 的代价更新为s 到u 与u 到v 的代价之和，否则维持原样。如此一直循环直至集合Q 为空，即所有节点都已经查找过一遍并确定了最短路径，至于一些起点到达不了的结点在算法循环后其代价仍为初始设定的值，不发生变化">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-16T09:15:00+08:00">
    <meta property="article:modified_time" content="2024-05-16T09:15:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【高阶数据结构(四)】图的最短路径问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>💓博主CSDN主页:<a href="https://blog.csdn.net/m0_61982936?spm=1000.2115.3001.5343">杭电码农-NEO</a>💓<br>   <br> ⏩专栏分类:<a href="https://blog.csdn.net/m0_61982936/category_12660316.html?spm=1001.2014.3001.5482">高阶数据结构专栏</a>⏪<br>   <br> 🚚代码仓库:<a href="https://gitee.com/NEO_kou" rel="nofollow">NEO的学习日记</a>🚚<br>   <br> 🌹关注我🫵带你学习更多数据结构<br>   🔝🔝</p> 
</blockquote> 
<hr> 
<p><img src="https://images2.imgbox.com/58/bd/xAXLKRtF_o.gif" alt="在这里插入图片描述"></p> 
<p></p> 
<div class="toc"> 
 <h4>高阶数据结构</h4> 
 <ul><li><a href="#1__15" rel="nofollow">1. 前言</a></li><li><a href="#2__24" rel="nofollow">2. 单源最短路径问题</a></li><li><a href="#3_dijkstra_44" rel="nofollow">3. dijkstra算法讲解</a></li><li><a href="#4_bellmanFord_101" rel="nofollow">4. bellman-Ford算法讲解</a></li><li><a href="#5__150" rel="nofollow">5. 多源最短路径问题</a></li><li><a href="#6_FloydWarshall_159" rel="nofollow">6. Floyd-Warshall算法讲解</a></li><li><a href="#7__224" rel="nofollow">7. 总结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1__15"></a>1. 前言</h2> 
<p>关于图论,无非就是最小生成树问题和最短路径问题. 对于最短路径问题来说, 分为单源最短路径和多源最短路径, 并且图中的权值是否有负数, 对应能使用的算法也不同</p> 
<p><mark>本章重点:</mark></p> 
<blockquote> 
 <p><font color="purple"><strong>本篇文章着重讲解图的单源最短路径之Dijkstra算法和bellman-Ford算法.以及多源最短路径之Floyd-wars hall算法. 文章会着重讲解这些算法的思路, 代码实现部分要靠大家的理解能力了</strong></font></p> 
</blockquote> 
<hr> 
<h2><a id="2__24"></a>2. 单源最短路径问题</h2> 
<p>所谓的单源最短路径,也就是从图中任意一点出发, 到图中每个节点的最短路径,也就是最小的权值和</p> 
<p><img src="https://images2.imgbox.com/7c/b2/oAKt4p5Y_o.png" alt="在这里插入图片描述"></p> 
<p>对于单源最短路径的求解. 我们一般使用输出型参数. 用两个数组来表示最短路径的权值以及最短路径的路径.</p> 
<pre><code class="prism language-cpp"><span class="token comment">//存储任意点到图中其他点的最短路径的权值</span>
 vector<span class="token operator">&lt;</span>W<span class="token operator">&gt;</span><span class="token operator">&amp;</span> dist
 <span class="token comment">//记录srci-&gt;其他顶点最短路径父顶点数组</span>
 vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> parentPath
</code></pre> 
<blockquote> 
 <p><font color="orange"><strong>第一个数组很好理解. 图中的顶点会简化成为数组中的元素. 所以dist数组中的dist[i]=j.代表顶点i到srci的最短路径的权值. 不好理解的是第二个数组. 它存储的是最短路径的父顶点. 什么意思呢? 请看下图:</strong></font></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/a4/69/h9nKeCAI_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h2><a id="3_dijkstra_44"></a>3. dijkstra算法讲解</h2> 
<blockquote> 
 <p>针对一个带权有向图G，<code>将所有结点分为两组S和Q</code>，S是已经确定最短路径的结点集合，在初始时为空（初始时就可以将源节点s放入，毕竟源节点到自己的代价是0），Q 为其余未确定最短路径的结点集合，每次从Q 中找出一个起点到该结点代价最小的结点u ，将u 从Q 中移出，并放入S 中，对u 的每一个相邻结点v 进行松弛操作。</p> 
</blockquote> 
<blockquote> 
 <p><font color="gree"><strong>松弛即对每一个相邻结点v ，判断源节点s到结点u 的代价与u 到v 的代价之和是否比原来s 到v 的代价更小，若代价比原来小则要将s 到v 的代价更新为s 到u 与u 到v 的代价之和，否则维持原样。如此一直循环直至集合Q 为空，即所有节点都已经查找过一遍并确定了最短路径，至于一些起点到达不了的结点在算法循环后其代价仍为初始设定的值，不发生变化</strong></font></p> 
</blockquote> 
<p><mark>定义很抽象,现在来看看实图:</mark></p> 
<p><img src="https://images2.imgbox.com/95/be/xq7o3f3t_o.png" alt="在这里插入图片描述"></p> 
<p>从S开始,s-&gt;y是最短路径了, 就以y为起点(y的值被更新为5)更新与y相连的t,z,x. 同时s-&gt;t也被更新为10. y-&gt;t小于s-&gt;t. 所以将t重新更新为8. x,z也是同理. 第二次更新完. s-&gt;z最短.就以z为起点更新与z相连的x.以此类推.直到所有顶点都在集合S中.</p> 
<p><mark>话不多说,上代码:</mark></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">Dijkstra</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> src<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>W<span class="token operator">&gt;</span><span class="token operator">&amp;</span> dist<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> pPath<span class="token punctuation">)</span><span class="token comment">//Dijkstra算法求解最短路径,两个数组,一个存储两个点之间的最小权值(从src点,到图中其他的点),另一个存父路径节点下标</span>
<span class="token punctuation">{<!-- --></span>
	size_t srci <span class="token operator">=</span> <span class="token function">GetIndex</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t n <span class="token operator">=</span> _vertex<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	dist<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> MAX_W<span class="token punctuation">)</span><span class="token punctuation">;</span>
	pPath<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	dist<span class="token punctuation">[</span>srci<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">W</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	pPath<span class="token punctuation">[</span>srci<span class="token punctuation">]</span> <span class="token operator">=</span> srci<span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">check</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//此数组中存放已经确定了的最短路劲的节点</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//n个节点,一共会更新n次,也可以判断check数组中的元素是否全为true</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//选最短路径的顶点更新其他路径(不在s中)</span>
		<span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//最小的点的下标</span>
		W minu <span class="token operator">=</span> MAX_W<span class="token punctuation">;</span><span class="token comment">//最小的点的权值</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//选择dist数组中权值最小的,作为起始点来进行松弛操作</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>check<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> minu<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				u <span class="token operator">=</span> i<span class="token punctuation">;</span>
				minu <span class="token operator">=</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
				check<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//进行松弛更新,srci-&gt;u, u-&gt;其他顶点(v), srci-&gt;v就可以更新出来</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//从0到n,把与u点相连的所有顶点都找出来更新</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_edge<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">!=</span> MAX_W <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> _edge<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//若srci-&gt;u+u-&gt;v的距离小于dist[v]的大小,则更新他</span>
			<span class="token punctuation">{<!-- --></span>
				dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> _edge<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>
				pPath<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>此算法只适用于不带负权路径的图</code><br> <code>若有不懂,欢迎私信</code></p> 
<hr> 
<h2><a id="4_bellmanFord_101"></a>4. bellman-Ford算法讲解</h2> 
<p>Dijkstra算法只适用于不带负权路径的图, 具体的原因可以参考这篇文章: <a href="https://cloud.baidu.com/article/3306984" rel="nofollow">负权路径带来的后果</a></p> 
<p><mark>显而易见, bellman算法可以解决带负权路径的图</mark></p> 
<blockquote> 
 <p>说白了此算法就是一个暴力求解的过程, 它的时间复杂度是O(N^3). 它的思路就是以所有顶点为起始点,更新所有相连的边</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/ff/81/1Hwts3e1_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><font color="purple"><strong>更新次序就是(t，z)，(t，y)，(t，z)，(y,x)，(y，z), (z,x), (z，s), (s,t), (s,y). 更新(y,z)时,由于更新后的值是7+9=16&gt;2,所以不会更新这条边. 其他更新边也是同理. 但是这样暴力更新一次并不能解决问题,因为假如只更新一次, (s,t)的值就是6, 但是显而易见, s-&gt;y-&gt;x-&gt;t的权值是2,要小于6. 出现这种情况的原因是, 还没有以x为起始点进行更新其他点时, 根本就不知道x-&gt;t这条路. 所以我们需要以所有点为起始点更新n次,n是顶点的数量</strong></font></p> 
</blockquote> 
<p><mark>上代码:</mark></p> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">BellmanFord</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> src<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>W<span class="token operator">&gt;</span><span class="token operator">&amp;</span> dist<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> pPath<span class="token punctuation">)</span><span class="token comment">//贝尔曼-福特算法求解最短路径</span>
<span class="token punctuation">{<!-- --></span>
	size_t srci <span class="token operator">=</span> <span class="token function">GetIndex</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t n <span class="token operator">=</span> _vertex<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	dist<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> MAX_W<span class="token punctuation">)</span><span class="token punctuation">;</span>
	pPath<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	dist<span class="token punctuation">[</span>srci<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">W</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//用i-&gt;j,图中的所有边去更新</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//再套一层循环的原因是,只更新一轮可能会有问题,更新K轮一定不会有问题</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">bool</span> check <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>_edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> MAX_W <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> _edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//若这条边存在,并且从i-&gt;j要少于直接0-&gt;j</span>
				<span class="token punctuation">{<!-- --></span>
					dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> _edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
					pPath<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
					check <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>check <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> breal<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//有可能K轮循环后,会形成闭环</span>
	<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>很明显它的时间复杂度是O(N^3)</code></p> 
<hr> 
<h2><a id="5__150"></a>5. 多源最短路径问题</h2> 
<p>说白了就是任意两点之间的最短路径<br> Floyd-Warshall算法就是解决方法之一</p> 
<blockquote> 
 <p>和单源最短路径算法的思路相似. 这里需要用到两个数组, 只不过这里是用两个二维数组, 一个二维数组存储顶点i-&gt;j的最短路径值, 另外一个数组存储 (i,j)的父节点下标. i,j是最短路径的中间某节点</p> 
</blockquote> 
<hr> 
<h2><a id="6_FloydWarshall_159"></a>6. Floyd-Warshall算法讲解</h2> 
<p>Floyd算法考虑的是一条最短路径的中间节点，即简单路径p={v1,v2,…,vn}上除v1和vn的任意节<br> 点。设k是p的一个中间节点，那么从i到j的最短路径p就被分成i到k和k到j的两段最短路径p1，p2。p1是从i到k且中间节点属于{1，2，…，k-1}取得的一条最短路径。p2是从k到j且中间节点属于{1，2，…，k-1}取得的一条最短路径</p> 
<p><img src="https://images2.imgbox.com/69/c1/t1hcF0de_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/00/5b/TZJ3tkEI_o.png" alt="在这里插入图片描述"></p> 
<p><mark>你可能觉得很抽象,下面来个实际案例:</mark></p> 
<p><img src="https://images2.imgbox.com/ba/0b/fOI1pWKC_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/29/12/U2CslnYm_o.png" alt="在这里插入图片描述"></p> 
<p><mark>上代码:</mark></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">FloydWarShall</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>W<span class="token operator">&gt;&gt;</span><span class="token operator">&amp;</span> vvDist<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span><span class="token operator">&amp;</span> vvpPath<span class="token punctuation">)</span><span class="token comment">//多源最短路径求解问题(任意两点的最短路径),数组vvDist中包含了所有点的最短距离</span>
<span class="token punctuation">{<!-- --></span>
	size_t N <span class="token operator">=</span> _vertex<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	vvDist<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>
	vvpPath<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		vvDist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> MAX_W<span class="token punctuation">)</span><span class="token punctuation">;</span>
		vvpPath<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//把直接相连的边给更新一下,后续就不需要_edge数组了</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> MAX_W<span class="token punctuation">)</span><span class="token comment">//直接相连</span>
			<span class="token punctuation">{<!-- --></span>
				vvDist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> _edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
				vvpPath<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token comment">//起点是i,目前的父路径暂时是i(后面可能会是K)</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span>
				vvDist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">W</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//最短路径的更新,i-&gt;j,中间可能经过了k个顶点,i-&gt;{其他顶点(最多是N-2)}-&gt;j</span>
	<span class="token comment">//k作为i,j的中间点,k可以是任意顶点,k可以是1,2,3,任意点,要把所有点拿来更新</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//虽然是最多只需要走n-2个点,但是这里除掉的两个点我们并不知道是哪两个,所以都需要走一遍</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">//以K作为中间的去更新i-&gt;j的路径</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>vvDist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!=</span> MAX_W <span class="token operator">&amp;&amp;</span> vvDist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> MAX_W <span class="token operator">&amp;&amp;</span> vvDist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> vvDist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> vvDist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//i-&gt;k的路径和k-&gt;j的路径都存在,并且i-&gt;k加上k-&gt;j的路径小于i直接到j</span>
				<span class="token punctuation">{<!-- --></span>
					vvDist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> vvDist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> vvDist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
					vvpPath<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> vvpPath<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//这里j的父路径不能直接写成k,因为k-&gt;j中间可能还有其他点,比如k-&gt;x-&gt;y-&gt;j,最开始的i,j是在_edge数组中取得,而这里应该是从vvppath[k][j]中取得,需要找跟j相连的上一个顶点</span>
				<span class="token punctuation">}</span>

			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h2><a id="7__224"></a>7. 总结</h2> 
<p>图论总体来说比较抽象,很难理解这些算法的思路. 但是也不用慌张,图论本身就属于加分项, 你知道算法原理即可, 不用会手撕, 换个角度, 面试官也不一定能手撕这些算法.</p> 
<hr> 
<center>
  🔎 
 <font color="#4b0080"> 下期预告:LRU cache讲解 </font>🔍 
</center>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/833802b9a5d2a072f3796e01357d14c1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AI Agent - 7大认知框架全解析与代码实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/51315b7bf7a13724ad80f66e295d7773/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C--贪吃蛇</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>