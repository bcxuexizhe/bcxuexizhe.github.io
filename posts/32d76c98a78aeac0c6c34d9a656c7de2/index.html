<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【算法与数据结构】归并排序的代码实现（详细图解）以及master公式的讲解 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/32d76c98a78aeac0c6c34d9a656c7de2/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【算法与数据结构】归并排序的代码实现（详细图解）以及master公式的讲解">
  <meta property="og:description" content="目录
1、归并排序
1.1、算法描述
1.2、图解说明
2、代码实现 3、master公式
3.1、公式以及结论
3.2、适用于某些特殊的递归
3.3、计算归并排序的时间复杂度
1、归并排序 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用递归或者说是分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。
若将两个有序表合并成一个有序表，称为二路归并。
1.1、算法描述 把长度为n的输入序列分成两个长度为n/2的子序列；对这两个子序列分别采用归并排序；将两个排序好的子序列合并成一个最终的排序序列。 而将两个的有序数列合并成一个有序数列，我们称之为&#34;归并&#34;，这就是归并排序名字的由来。
1.2、图解说明 一句话简单说：对L到R范围排序，可以先求出L到R的中点M。先让左侧数据排好序，然后再让右侧数据排好序，此时再将两个有序子序列整合成一个新的有序序列。
​
例如：
对一个数组[8,3,6,4,2,1,5,7]进行归并排序。
第一步：把长度为n的输入序列分成两个长度为n/2的子序列，新的子序列再分别分成两个长度为自身一半也就是n/4的子序列，以此类推。当分到单个子序列只剩下一个数字时，一个数字就是天然了有序，即此时左侧和右侧都排好序了。
​
第二步：将两个排序好的子序列合并成一个新的排序序列。首先在每个子序列中都有一个指针指向子序列的第一个元素，两个指针的元素两两比较，较小的元素先放入新的子序列中，然后指针挪动继续比较，直至全部放入新的子序列当中，即完成一次子序列合并。慢慢合并最终使所有元素都成有序，即完成归并排序。
​
这个思路过程是非常精髓的，理解了这个思路之后，就可以试着用代码实现了。
2、代码实现 要使用归并，首先需要知道数组arr以及数组最左L下标和最右R下标，因此需要求出并带入MergeSort当中。
int main() { int arr[10] = { 8,3,6,4,2,1,5,7 }; int sz = sizeof(arr) / sizeof(arr[0]); MergeSort(arr, 0, sz - 1); int i = 0; for ( i = 0; i &lt; sz; i&#43;&#43;) { printf(&#34;%d &#34;, arr[i]); } return 0; } 接下来看看MergeSort的实现。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-10-05T10:24:34+08:00">
    <meta property="article:modified_time" content="2023-10-05T10:24:34+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【算法与数据结构】归并排序的代码实现（详细图解）以及master公式的讲解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" src="https://images2.imgbox.com/e3/50/Mvlg2ub5_o.png"></p> 
<p style="text-align:center;"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" rel="nofollow">1、归并排序</a></p> 
<p id="%C2%A01.1%E3%80%81%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-toc" style="margin-left:40px;"><a href="#%C2%A01.1%E3%80%81%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0" rel="nofollow"> 1.1、算法描述</a></p> 
<p id="%C2%A01.2%E3%80%81%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E-toc" style="margin-left:40px;"><a href="#%C2%A01.2%E3%80%81%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E" rel="nofollow"> 1.2、图解说明</a></p> 
<p id="2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow">2、代码实现 </a></p> 
<p id="%C2%A03%E3%80%81master%E5%85%AC%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%C2%A03%E3%80%81master%E5%85%AC%E5%BC%8F" rel="nofollow">3、master公式</a></p> 
<p id="3.1%E3%80%81%E5%85%AC%E5%BC%8F%E4%BB%A5%E5%8F%8A%E7%BB%93%E8%AE%BA-toc" style="margin-left:40px;"><a href="#3.1%E3%80%81%E5%85%AC%E5%BC%8F%E4%BB%A5%E5%8F%8A%E7%BB%93%E8%AE%BA" rel="nofollow">3.1、公式以及结论</a></p> 
<p id="3.2%E3%80%81%E9%80%82%E7%94%A8%E4%BA%8E%E6%9F%90%E4%BA%9B%E7%89%B9%E6%AE%8A%E7%9A%84%E9%80%92%E5%BD%92-toc" style="margin-left:40px;"><a href="#3.2%E3%80%81%E9%80%82%E7%94%A8%E4%BA%8E%E6%9F%90%E4%BA%9B%E7%89%B9%E6%AE%8A%E7%9A%84%E9%80%92%E5%BD%92" rel="nofollow">3.2、适用于某些特殊的递归</a></p> 
<p id="%C2%A03.3%E3%80%81%E8%AE%A1%E7%AE%97%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:40px;"><a href="#%C2%A03.3%E3%80%81%E8%AE%A1%E7%AE%97%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow">3.3、计算归并排序的时间复杂度</a></p> 
<p style="text-align:center;"><br><img alt="" src="https://images2.imgbox.com/ae/f6/QF7FfPTi_o.gif"></p> 
<p></p> 
<h2 id="1%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">1、归并排序</h2> 
<blockquote> 
 <p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用<strong>递归</strong>或者说是<strong>分治法</strong>（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</p> 
 <p>若将两个有序表合并成一个有序表，称为<strong>二路归并</strong>。</p> 
</blockquote> 
<h3 id="%C2%A01.1%E3%80%81%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"> 1.1、算法描述</h3> 
<blockquote> 
 <ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul> 
 <p>而将两个的有序数列合并成一个有序数列，我们称之为"归并"，这就是归并排序名字的由来。</p> 
</blockquote> 
<h3 id="%C2%A01.2%E3%80%81%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E"> 1.2、图解说明</h3> 
<blockquote> 
 <p>一句话简单说：对L到R范围排序，可以先求出L到R的中点M。先让左侧数据排好序，然后再让右侧数据排好序，此时再将两个有序子序列整合成一个新的有序序列。</p> 
</blockquote> 
<div> 
 <p><img alt="" height="265" src="https://images2.imgbox.com/b0/09/BxgSde0w_o.png" width="696">​</p> 
</div> 
<p> 例如：</p> 
<blockquote> 
 <p><strong>对一个数组[8,3,6,4,2,1,5,7]进行归并排序。</strong></p> 
</blockquote> 
<p><strong>第一步：</strong>把长度为n的输入序列分成两个长度为n/2的子序列，新的子序列再分别分成两个长度为自身一半也就是n/4的子序列，以此类推。当分到单个子序列只剩下一个数字时，一个数字就是天然了有序，即此时左侧和右侧都排好序了。</p> 
<div> 
 <p><img alt="" height="595" src="https://images2.imgbox.com/7c/08/pd11eTYv_o.png" width="1200">​</p> 
</div> 
<p></p> 
<p><strong>第二步：</strong>将两个排序好的子序列合并成一个新的排序序列。首先在每个子序列中都有一个指针指向子序列的第一个元素，两个指针的元素两两比较，较小的元素先放入新的子序列中，然后指针挪动继续比较，直至全部放入新的子序列当中，即完成一次子序列合并。慢慢合并最终使所有元素都成有序，即完成归并排序。</p> 
<div> 
 <p><img alt="" height="611" src="https://images2.imgbox.com/92/de/EEjzcnFg_o.png" width="761">​</p> 
</div> 
<blockquote> 
 <p> 这个思路过程是非常精髓的，理解了这个思路之后，就可以试着用代码实现了。</p> 
</blockquote> 
<h2 id="2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%C2%A0">2、代码实现 </h2> 
<blockquote> 
 <p>要使用归并，首先需要知道数组arr以及数组最左L下标和最右R下标，因此需要求出并带入MergeSort当中。</p> 
</blockquote> 
<div> 
 <pre><code class="language-cpp">int main()
{
	int arr[10] = { 8,3,6,4,2,1,5,7 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	MergeSort(arr, 0, sz - 1);
	int i = 0;
	for ( i = 0; i &lt; sz; i++)
	{
		printf("%d ", arr[i]);
	}
	return 0;
}</code></pre> 
</div> 
<blockquote> 
 <p>接下来看看MergeSort的实现。</p> 
 <ol><li>首先是判断L是否等于R，如果L和R相等时就相当于是单个子序列中只存在了一个元素，而此时该子序列就为有序，因此不用进行操作直接返回即可，即if(L == R) return；</li><li>如果L不等于R时则认为该子序列中仍然可拆分，便求出mid中间值，并分别进行两次递归让两块递归范围有序，递归范围是L到mid、mid+1到R。</li><li>最后当递归结束时则代表L到mid、mid+1到R序列已有序，整体还无序，此时需要使用ExternalSort外部排序将这两个子序列整合成一个新的有序序列。</li></ol> 
</blockquote> 
<div> 
 <pre><code class="language-cpp">void MergeSort(int* arr, int L, int R)
{
	if (L == R)  //子序列只有一个数，默认为有序
	{
		return;
	}
	int mid = L + (R - L) / 2;
	MergeSort(arr, L, mid);
	MergeSort(arr, mid + 1, R);
	ExternalSort(arr, L, mid, R);
}
</code></pre> 
</div> 
<blockquote> 
 <p>ExternalSort的作用就是让arr中的L到M、M+1到R合并成一个新的有序序列，并将判断后的结果序列先存入到help指针指向的区域，等待完成所有合并，再将help整个区域的数据拷贝到arr对应的位置。</p> 
 <p>而存入help的<strong>规则</strong>是：</p> 
 <p></p> 
 <p><span style="color:#0d0016;">1、如果p1和p2都没有越界进行while循环：</span></p> 
 <p><span style="color:#0d0016;">p1和p2比较，如果p1大于p2，则将p2所指向的元素放入help中，然后将p2右移指向下一个，继续下一轮比较。</span></p> 
 <p><span style="color:#0d0016;">p1和p2比较，如果p1小于等于p2，则将p1所指向的元素放入help中，然后将p1右移指向下一个，继续下一轮比较。</span></p> 
 <p><span style="color:#0d0016;">2、如果有一方越界了，则退出循环，并判断p1和p2中哪个还有剩余的元素未排入help中，如果有则直接排入到help中。</span></p> 
</blockquote> 
<div> 
 <p><img alt="" height="372" src="https://images2.imgbox.com/9e/bf/dDYhbZ8Q_o.png" width="764">​</p> 
</div> 
<div> 
 <pre><code class="language-cpp">void ExternalSort(int* arr, int L, int M, int R)
{
	int* help = (int*)malloc(sizeof(int) * (R - L + 1)); //辅助空间，用于存放排序后的数据，空间大小为R-L+1。
	if (help == NULL)
	{
		perror("ExternalSort-&gt;malloc");
		return;
	}
	int helpSz = R - L + 1;
	int i = 0;
	int p1 = L;
	int p2 = M + 1;
	while (p1 &lt;= M &amp;&amp; p2 &lt;= R)
	{
        //判断p1是否小于等于p2，如果是则将p1指向的值放入help数组中然后两指针前进一位，反之p2亦然
		help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];
	}
	while (p1 &lt;= M)   //如果p1还没越界，则将剩余的元素全部拷贝到help之后
	{
		help[i++] = arr[p1++];
	}
	while (p2 &lt;= R)   //如果p2还没越界，则将剩余的元素全部拷贝到help之后
	{
		help[i++] = arr[p2++];
	}
	for ( i = 0; i &lt; helpSz; i++)
	{
		arr[L + i] = help[i];    //将合并完成的数据拷贝回原数组arr的对应位置
	}
	free(help);
	help = NULL;
}

</code></pre> 
</div> 
<blockquote> 
 <p>到这里，归并排序的代码实现部分就结束了，总的来说因为使用的是递归，代码量是不多的，但是最难的是理解归并排序的思路， 需要好好体会归并排序的操作步骤和思路。</p> 
</blockquote> 
<h2 id="%C2%A03%E3%80%81master%E5%85%AC%E5%BC%8F" style="background-color:transparent;">3、master公式</h2> 
<blockquote> 
 <p>那么完成了归并排序之后，我想知道这个排序的时间复杂度是多少的话，我该怎么算？有人说当然是直接百度搜索一下就知道了。我想说的是这样确实是没问题，但是秉持着<strong>“授人以鱼不如授人以渔”</strong>的理念，我想带大家深入了解并让大家学会自己去<strong>计算递归的时间复杂度</strong>。</p> 
 <p></p> 
 <p>而用来计算的公式就是使用<strong>master公式：</strong>在计算涉及递归的算法的时候，计算复杂度就会变得有些麻烦。master公式就是用来进行剖析递归行为和递归行为时间复杂度的估算的。</p> 
</blockquote> 
<h3 id="3.1%E3%80%81%E5%85%AC%E5%BC%8F%E4%BB%A5%E5%8F%8A%E7%BB%93%E8%AE%BA">3.1、公式以及结论</h3> 
<ul><li> <p>master公式：<strong>T(N) = a*T(N/b) + O(N^d)</strong></p> </li><li> <p><strong><img alt="T(N) = a * T(\frac{N}{b})+O(N^{d})" class="mathcode" src="https://images2.imgbox.com/b2/81/lsXmZ9UV_o.png"></strong></p> </li><li> <p>公式解释：<strong>N</strong>表示母问题的规模。<strong>N/b</strong>表示子问题的规模，子问题规模必须相同，即都为N/b。<strong>a</strong>表示递归的次数也就是子问题在母问题中被调用了多少次。<strong>O(N^d)</strong>表示除了递归调用操作以外其余操作的复杂度。</p> </li><li>结论（证明过于复杂，只需要记住结论即可）：</li></ul> 
<ol><li>当公式中的a、b、d符合d&lt;logb a时，时间复杂度为O(N^(logb a))</li><li>当公式中的a、b、d符合d=logb a时，时间复杂度为O((N^d)*logN)</li><li>当公式中的a、b、d符合d&gt;logb a时，时间复杂度为O(N^d)</li></ol> 
<ul><li> <p><strong><span style="background-color:#ffd900;">注意：master公式适用于一些特殊的递归，就是子问题规模必须等分，不管你是分成几部分，就算是划分的区域有重叠，只要区域大小一致，就都可以使用。</span></strong></p> </li></ul> 
<p><strong>【举例说明】</strong></p> 
<blockquote> 
 <p>下面是一个使用递归实现在一个数组中找最大值的代码，这里是使用<strong>二分法</strong>来快速查找最大值，子问题的划分大小是一致的，因此可以使用<strong>master公式</strong>计算时间复杂度。</p> 
 <ol><li>首先可以看到process中自身调用了两次process，母问题中有<strong>两个子问题调用</strong>，<strong>即a=2</strong>。</li><li>然后由于是二分法，因此每个子问题的规模是母问题规模的一半，<strong>即N/2</strong>。</li><li>接着再看其他操作，其他操作都只执行一次，即时间复杂度为<strong>O(1)</strong>。</li><li>最后：该递归的master公式就是<strong>T(N) = 2 * T(N/2) + O(1)。</strong></li></ol> 
 <p><strong>即a = 2, b = 2, d = 0，代入结论公式得d&lt;logb a，<span style="background-color:#ffd900;">时间复杂度为O(N^(logb a)) = O(N)</span></strong></p> 
</blockquote> 
<pre><code class="language-cpp">int process(int* arr, int L, int R)
{
	if (L == R)
		return arr[L];
	int mid = L + (R - L) / 2;
	int leftMAX = process(arr, L, mid);    //左半边
	int rightMAX = process(arr, mid + 1, R);   //右半边
	return leftMAX &gt; rightMAX ? leftMAX : rightMAX;
}

int main()
{
	int arr[] = { 8,3,6,4,2,1,5,7 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	int max = process(arr, 0, sz - 1);
	printf("%d\n", max);
	return 0;
}</code></pre> 
<h3 id="3.2%E3%80%81%E9%80%82%E7%94%A8%E4%BA%8E%E6%9F%90%E4%BA%9B%E7%89%B9%E6%AE%8A%E7%9A%84%E9%80%92%E5%BD%92">3.2、适用于某些特殊的递归</h3> 
<blockquote> 
 <p><span style="color:#0d0016;">上面说到过：master公式适用于一些特殊的递归，就是子问题规模必须等分，不管你是分成几部分，就算是划分的区域有重叠，只要区域大小一致，就都可以使用。</span></p> 
 <p><strong><span style="color:#0d0016;">但是仍然会有些人会误解意思，下面使用图解的方式给大家解释一下。</span></strong></p> 
</blockquote> 
<p><strong>【图解说明】</strong></p> 
<blockquote> 
 <p> 首先，<strong>等分区域</strong>是最容易理解的，就是将N等分成若干份，二分就是N/2，三分就是N/3。</p> 
</blockquote> 
<p class="img-center"><img alt="" height="446" src="https://images2.imgbox.com/10/7c/r8zzodbm_o.png" width="821"></p> 
<blockquote> 
 <p>子问题的规模是左侧三分之二和右侧三分之二，这样的符合master公式吗？</p> 
 <p>答案是<strong>符合</strong>的，因为这里只关注的是<strong>区域大小是否一致</strong>，而不关心区域是否重叠。</p> 
</blockquote> 
<p class="img-center"><img alt="" height="254" src="https://images2.imgbox.com/fd/bb/K4LJZTtW_o.png" width="1056"></p> 
<blockquote> 
 <p> 子问题规模不一样，不符合master公式。</p> 
</blockquote> 
<p class="img-center"><img alt="" height="217" src="https://images2.imgbox.com/af/87/t5Wldeqn_o.png" width="906"></p> 
<h3 id="%C2%A03.3%E3%80%81%E8%AE%A1%E7%AE%97%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">3.3、计算归并排序的时间复杂度</h3> 
<blockquote> 
 <p>学完了master公式，那么我们就来计算一下<strong>归并排序</strong>的时间复杂度吧。</p> 
</blockquote> 
<pre><code class="language-cpp">void MergeSort(int* arr, int L, int R)
{
	if (L == R)  //子序列只有一个数，默认为有序
	{
		return;
	}
	int mid = L + (R - L) / 2;
	MergeSort(arr, L, mid);
	MergeSort(arr, mid + 1, R);
	ExternalSort(arr, L, mid, R);
}
</code></pre> 
<blockquote> 
 <p>假设整个过程的数据量是N的规模，两个子问题都是T(N/2)，因此是2*T(N/2)。</p> 
 <p>那么现在来观察除了子问题外的其他语句：if语句是<strong>O(1)</strong>的时间复杂度，而ExternalSort函数的两个指针都只往右前进不会回退的遍历所有数据一遍，又因为数据量是N的规模，所以ExternalSort函数的时间复杂度是<strong>O(N)</strong>。</p> 
 <p><strong>即：T(N) = 2 * T(N/2) + O(N)    其中a  = 2，b = 2，d = 1</strong></p> 
 <p><strong>将a、b、d代入结论公式得d=logb a，时间复杂度为<span style="background-color:#ffd900;">O((N^d)*logN) = O(N*logN)。</span></strong></p> 
</blockquote> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/77/97/v2xVTtd4_o.gif"></p> 
<p style="text-align:center;"><strong><span style="background-color:#a2e043;">如果觉得作者写的不错，求给博主一个大大的点赞支持一下，你们的支持是我更新的最大动力！</span></strong></p> 
<p style="text-align:center;"><strong><span style="background-color:#a2e043;">如果觉得作者写的不错，求给博主一个大大的点赞支持一下，你们的支持是我更新的最大动力！</span></strong></p> 
<p style="text-align:center;"><strong><span style="background-color:#a2e043;">如果觉得作者写的不错，求给博主一个大大的点赞支持一下，你们的支持是我更新的最大动力！</span></strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/76f4e293c63d73951b548e04df42b68e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">网络爬虫——urllib（1）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7a8021c8bad5bbca43eb70a5df871876/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mac怎么卸载软件没有叉的那种，别慌看这里</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>