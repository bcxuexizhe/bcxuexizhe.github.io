<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>计算机操作系统实验：进程调度实验 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/b85ba4e78900ec85a678b713ec272506/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="计算机操作系统实验：进程调度实验">
  <meta property="og:description" content="目录 前言
二、实验目的
三、实验要求
四、实验原理
五、实验过程
六、代码详解
总结
前言 计算机操作系统是管理计算机硬件和软件资源的核心软件，它负责为用户提供一个友好、高效、安全的使用环境。进程调度是操作系统的一个重要功能，它决定了进程在处理器上的执行顺序和时间，从而影响了系统的性能和用户的体验。本实验旨在通过模拟不同的进程调度算法，比较它们的优缺点，加深对操作系统原理和设计的理解和掌握。
一、开发语言及实验平台
C&#43;&#43;/JAVA
Turbo C / Microsoft Visual Studio 6.0 / Microsoft Visual Studio .NET 2010
在本文中使用的是c语言（？），使用的平台是devc&#43;&#43;
二、实验目的 （1）加深对进程的概念及进程调度算法的理解；
（2）在了解和掌握进程调度算法的基础上，编制进程调度算法通用程序，将调试结果显示在计算机屏幕上，并检测机算和笔算的一致性。
三、实验要求 （1）了解进程调度；
（2）理解利用进程调度算法进行调度的原理；
（3）使用某种编程语言进行算法模拟。
四、实验原理 例题：设计一个有N个进程的进程调度算法。 进程调度算法：采用最高优先数的调度算法（即把处理机分配给优先数最高的进程）。
每个进程有一个进程控制块（PCB）表示。进程控制块可以包含如下信息：进程名、优先数、到达时间、需要运行时间、已用CPU时间、进程状态等等。
进程的优先数及需要的运行时间可以事先人为的指定（也可以由随机数产生）。进程的到达时间为进程的输入的时间。进程的运行时间以时间片为单位进行计算。
每个进程的状态可以是就绪W（Wait）、运行R（Run）、或完成F（Finish）三种状态之一。就绪进程获得CPU后都只能运行一个时间片。用已占用CPU时间加1表示。
如果运行一个时间片后，进程的已占用CPU时间已达到所需要的运行时间，则撤销该进程，如果运行一个时间片后，进程的已占用CPU时间还未达到所需要的运行时间，也就是进程还需要继续运行，此时应该将进程的优先数减1（即降低一级），然后把它插入就绪队列等待CPU。
每进行一次调度程序都打印一次运行进程、就绪队列、以及各个进程的PCB，以便进行检查。
重复以上过程，直到所要的进程都完成为止。
分析:
使用固定队列与静动态优先级结合，每个优先级为0~0xFF,并且以小的数字为高优先级，大的数字为低优先级，每次皆使用循环得到最高优先级的进程并执行，然后将其动态优先级设置为最低，并将其他进程动态优先级提高，以使得每个进程都有机会运行。进程的优先级与运行时间由随机数产生。
五、实验过程 代码如下：
#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;time.h&gt; /*常量和状态定义*/ #define PRO_NUM 0x05 #define MAX_TIME 0xFF /*状态宏*/ #define WAIT 0x01 #define RUN 0x02 #define FINISH 0x03 #define ID_ERROR 0x10 #define MIN_PRIOR 0xFF //255 #define MAX_PRIOR 0x00 0 typedef unsigned int Uint32; /*进程PCB*/ struct PCB_Info { Uint32 s_id; Uint32 s_static_prior; Uint32 s_dynamic_prior; Uint32 s_start_time; Uint32 s_need_time; Uint32 s_used_time; Uint32 s_state; }; /*进程队列*/ PCB_Info g_queue[5]; Uint32 g_time = 0; /*模拟进程执行函数*/ void Simulator(); /*初始化5个进程函数*/ void Init_Process(); /*初始化进程队列函数*/ void Init_Queue(); /*创建进程函数*/ Uint32 Create_Process(Uint32 pri,Uint32 needtime); /*系统运行函数*/ void Run_Process(); /*得到最高优先级进程 ID函数*/ Uint32 Get_PriProcess(); /*进程时间片执行函数*/ void Work_Process(Uint32 id); /*改变进程状态和优先级函数*/ void Change_Process(Uint32 id); /*打印进程状态函数*/ void Print_State(); /*结束系统函数*/ void End_Process(); /*入口函数*/ int main( int argc, char *argv[ ]) { Simulator(); return 0; } void Simulator() { Init_Process(); Run_Process(); End_Process(); } void Init_Process() { int i; Uint32 id; srand( (unsigned)time( NULL ) ); Init_Queue(); for(i=0;i&lt;PRO_NUM;&#43;&#43;i) { /*在这里修改随机数的范围，建议优先级取值为0到4之间，进程工作总时间为1到10之间*/ id=Create_Process(rand()%5, 1&#43;rand()%10); if(id!">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-04-01T16:38:46+08:00">
    <meta property="article:modified_time" content="2023-04-01T16:38:46+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">计算机操作系统实验：进程调度实验</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95"><a id="_0"></a><strong>目录</strong></h2> 
<p id="%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95-toc" style="margin-left:0px;"></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84" rel="nofollow">二、实验目的</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82" rel="nofollow">三、实验要求</a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%AE%9E%E9%AA%8C%E5%8E%9F%E7%90%86-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E5%AE%9E%E9%AA%8C%E5%8E%9F%E7%90%86" rel="nofollow">四、实验原理</a></p> 
<p id="%E4%BA%94%E3%80%81%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B" rel="nofollow">五、实验过程</a></p> 
<p id="%E5%85%AD%E3%80%81%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3" rel="nofollow">六、代码详解</a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
<hr> 
<h2 id="%E5%89%8D%E8%A8%80"><a id="_12"></a>前言</h2> 
<p>计算机操作系统是管理计算机硬件和软件资源的核心软件，它负责为用户提供一个友好、高效、安全的使用环境。进程调度是操作系统的一个重要功能，它决定了进程在处理器上的执行顺序和时间，从而影响了系统的性能和用户的体验。本实验旨在通过模拟不同的进程调度算法，比较它们的优缺点，加深对操作系统原理和设计的理解和掌握。</p> 
<hr> 
<p><strong>一、开发语言及实验平台</strong></p> 
<p style="margin-left:0;text-align:justify;">C++/JAVA</p> 
<p style="margin-left:0;text-align:justify;">Turbo C / Microsoft Visual Studio 6.0 / Microsoft Visual Studio .NET 2010</p> 
<p style="margin-left:0;text-align:justify;"><strong>在本文中使用的是c语言（？），使用的平台是devc++</strong></p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84" style="margin-left:0px;text-align:justify;">二、实验目的</h2> 
<p style="margin-left:0;text-align:justify;">（1）加深对进程的概念及进程调度算法的理解；</p> 
<p style="margin-left:0;text-align:justify;">（2）在了解和掌握进程调度算法的基础上，编制进程调度算法通用程序，将调试结果显示在计算机屏幕上，并检测机算和笔算的一致性。</p> 
<h2 id="%E4%B8%89%E3%80%81%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82" style="margin-left:0px;text-align:justify;">三、实验要求</h2> 
<p style="margin-left:0;text-align:justify;">（1）了解进程调度；</p> 
<p style="margin-left:0;text-align:justify;">（2）理解利用进程调度算法进行调度的原理；</p> 
<p style="margin-left:0;text-align:justify;">（3）使用某种编程语言进行算法模拟。</p> 
<h2 id="%E5%9B%9B%E3%80%81%E5%AE%9E%E9%AA%8C%E5%8E%9F%E7%90%86" style="margin-left:0px;text-align:justify;">四、实验原理</h2> 
<ul><li style="text-align:justify;">例题：设计一个有N个进程的进程调度算法。</li></ul> 
<p style="margin-left:0;text-align:justify;">进程调度算法：采用最高优先数的调度算法（即把处理机分配给优先数最高的进程）。</p> 
<p style="margin-left:0;text-align:justify;">每个进程有一个进程控制块（PCB）表示。进程控制块可以包含如下信息：进程名、优先数、到达时间、需要运行时间、已用CPU时间、进程状态等等。</p> 
<p style="margin-left:0;text-align:justify;">进程的优先数及需要的运行时间可以事先人为的指定（也可以由随机数产生）。进程的到达时间为进程的输入的时间。进程的运行时间以时间片为单位进行计算。</p> 
<p style="margin-left:0;text-align:justify;">每个进程的状态可以是就绪W（Wait）、运行R（Run）、或完成F（Finish）三种状态之一。就绪进程获得CPU后都只能运行一个时间片。用已占用CPU时间加1表示。</p> 
<p style="margin-left:0;text-align:justify;">如果运行一个时间片后，进程的已占用CPU时间已达到所需要的运行时间，则撤销该进程，如果运行一个时间片后，进程的已占用CPU时间还未达到所需要的运行时间，也就是进程还需要继续运行，此时应该将进程的优先数减1（即降低一级），然后把它插入就绪队列等待CPU。</p> 
<p style="margin-left:0;text-align:justify;">每进行一次调度程序都打印一次运行进程、就绪队列、以及各个进程的PCB，以便进行检查。</p> 
<p style="margin-left:0;text-align:justify;">重复以上过程，直到所要的进程都完成为止。</p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="color:#000000;">分析</span></strong><strong><span style="color:#000000;">:</span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">使用固定队列与静动态优先级结合，每个优先级为</span><span style="color:#000000;">0~0xFF,</span><span style="color:#000000;">并且以小的数字为高优先级，大的数字为低优先级，每次皆使用循环得到最高优先级的进程并执行，然后将其动态优先级设置为最低，并将其他进程动态优先级提高，以使得每个进程都有机会运行。进程的优先级与运行时间由随机数产生。</span></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="664" src="https://images2.imgbox.com/09/66/jBS2RUmD_o.png" width="449"></p> 
<h2 id="%E4%BA%94%E3%80%81%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B" style="margin-left:0px;text-align:justify;">五、实验过程</h2> 
<p><strong>代码如下：</strong></p> 
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

/*常量和状态定义*/
#define        PRO_NUM        0x05
#define        MAX_TIME    0xFF
   /*状态宏*/
#define        WAIT        0x01
#define        RUN            0x02
#define        FINISH        0x03

#define        ID_ERROR    0x10

#define        MIN_PRIOR    0xFF //255
#define        MAX_PRIOR    0x00 0


typedef unsigned int    Uint32;

/*进程PCB*/
struct PCB_Info
{
   Uint32    s_id;
   Uint32    s_static_prior;
   Uint32    s_dynamic_prior;
   Uint32    s_start_time;
   Uint32    s_need_time;
   Uint32    s_used_time;
   Uint32    s_state;
};

/*进程队列*/
PCB_Info    g_queue[5];
Uint32        g_time = 0;
/*模拟进程执行函数*/
void Simulator();
/*初始化5个进程函数*/
void Init_Process();
/*初始化进程队列函数*/
void Init_Queue();
/*创建进程函数*/
Uint32 Create_Process(Uint32 pri,Uint32 needtime);
/*系统运行函数*/
void Run_Process();
/*得到最高优先级进程 ID函数*/
Uint32 Get_PriProcess();
/*进程时间片执行函数*/
void    Work_Process(Uint32 id);
/*改变进程状态和优先级函数*/
void    Change_Process(Uint32 id);
/*打印进程状态函数*/
void    Print_State();
/*结束系统函数*/
void End_Process();
/*入口函数*/
int main( int argc, char *argv[ ])
{
   Simulator();
   return 0;
}
void Simulator()
{
   Init_Process();
   Run_Process();
   End_Process();
}

void Init_Process()
{
   int i;
   Uint32 id;
   srand( (unsigned)time( NULL ) );
   Init_Queue();
   for(i=0;i&lt;PRO_NUM;++i)
   {
       /*在这里修改随机数的范围，建议优先级取值为0到4之间，进程工作总时间为1到10之间*/
       id=Create_Process(rand()%5, 1+rand()%10);
       if(id!=ID_ERROR)
       {
           printf("**********************************\n");
           printf("创建进程成功\n");
           printf("进程ID号为:%d\n",id);
           printf("进程的静态优先权为:%d\n",g_queue[id].s_static_prior);
           printf("进程的动态优先权为:%d\n",g_queue[id].s_dynamic_prior);
           printf("进程的到达时间为:%d\n",g_queue[id].s_start_time);
           printf("进程需要时间为:%d\n",g_queue[id].s_need_time);
           printf("进程已用CPU时间为:%d\n",g_queue[id].s_used_time);
           printf("进程的状态为:%d\n",g_queue[id].s_state);
           printf("\n");
       }
       else
       {
           printf("创建进程失败\n");
       }
   }
}

void Init_Queue()
{
   int i;
   for(i=0;i&lt;PRO_NUM;++i)
   {
       g_queue[i].s_id=i;
       g_queue[i].s_dynamic_prior=MIN_PRIOR; //255
       g_queue[i].s_need_time=0;
       g_queue[i].s_start_time=0;
       g_queue[i].s_static_prior=MIN_PRIOR;
       g_queue[i].s_used_time=0;
       g_queue[i].s_state=FINISH;
//g_queue[i].s_state=Sart;//这里有一个错误，在这里Sart并没有被定义，根据上下文，这里应该是想将进程的状态设置为START或者WAIT，根据上面的宏定义，将这里改成WAIT
   }
}

Uint32 Create_Process(Uint32 pri,Uint32 needtime)
{
   int i=0;
   Uint32 id=ID_ERROR;
   for(i=0;i&lt;PRO_NUM;++i)
   {
       if(g_queue[i].s_state ==FINISH)
       {
           id=g_queue[i].s_id;
           g_queue[i].s_dynamic_prior=MIN_PRIOR;
           g_queue[i].s_need_time=needtime;
           g_queue[i].s_start_time=g_time;
           g_queue[i].s_state=WAIT;
           g_queue[i].s_static_prior=pri;
           g_queue[i].s_used_time=0x0;
           break;
       }
   }
   return id;
}

void Run_Process()
{
   Uint32 id;    
   while((id=Get_PriProcess())!=ID_ERROR)
   {
       Work_Process(id);
       Change_Process(id);
   }
}

void    Print_State()
{
   int i;
   printf("时间 进程ID\t状态 已用时间 需要时间 开始时间 静优先级 动优先级\n");
   for(i=0;i&lt;PRO_NUM;++i)
   {        
       printf("%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n",g_time,g_queue[i].s_id,g_queue[i].s_state,g_queue[i].s_used_time,g_queue[i].s_need_time,
           g_queue[i].s_start_time,g_queue[i].s_static_prior,g_queue[i].s_dynamic_prior);
   }
}

Uint32 Get_PriProcess()
{
   Uint32 id=ID_ERROR;
   int  i, prev_id=ID_ERROR;
   Uint32 prior=MIN_PRIOR*2, temp_prior;
   for(i=0;i&lt;PRO_NUM;++i)
   {
       if(g_queue[i].s_state!=FINISH)
       {
           temp_prior=g_queue[i].s_dynamic_prior+g_queue[i].s_static_prior;
           if(temp_prior&lt;=prior)
           {
               id=i;
               prior=temp_prior;
           }
       }
   }
   return id;
}

void    Work_Process(Uint32 id)
{
   ++g_time;
   g_queue[id].s_state=RUN;
   ++g_queue[id].s_used_time;
   Print_State();
}

void    Change_Process(Uint32 id)
{
   int i;
   if(g_queue[id].s_need_time==g_queue[id].s_used_time)
   {
       g_queue[id].s_state=FINISH; 
   }
   else
   {
       g_queue[id].s_dynamic_prior=MIN_PRIOR;
       g_queue[id].s_state=WAIT;
       
   }
   for(i=0;i&lt;PRO_NUM;++i)
   {
       if((i!=id)&amp;&amp;(g_queue[i].s_state!=FINISH))
       {
           g_queue[i].s_dynamic_prior &gt;0 ?--g_queue[i].s_dynamic_prior:g_queue[i].s_dynamic_prior=0;
       }
   }
}


void End_Process()
{
   printf("所有进程结束状态:\n");
   Print_State();
   printf("所有进程已经结束!\n");
}
</code></pre> 
<h2 id="%E5%85%AD%E3%80%81%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3" style="margin-left:0px;text-align:justify;">六、代码详解</h2> 
<p style="margin-left:0;text-align:justify;">这是一段C语言的进程调度程序，现在来解释一下这段代码：</p> 
<p>这段代码是一个简单的进程调度程序，它使用优先级调度算法来模拟进程的执行。程序中定义了一些常量和状态，包括进程数量、最大时间、等待状态、运行状态和完成状态。它还定义了一个PCB_Info结构体，用来表示进程的PCB（进程控制块），其中包含了进程的ID、静态优先级、动态优先级、开始时间、需要时间、已使用时间和状态。</p> 
<p>代码中还定义了一个全局变量g_queue，用来表示进程队列，以及一个全局变量g_time，用来表示当前时间。此外，还定义了一些函数原型，包括模拟进程执行函数Simulator()，初始化5个进程函数Init_Process()，初始化进程队列函数Init_Queue()，创建进程函数Create_Process()，系统运行函数Run_Process()，得到最高优先级进程ID函数Get_PriProcess()，进程时间片执行函数Work_Process()，改变进程状态和优先级函数Change_Process()，打印进程状态函数Print_State()和结束系统函数End_Process()。</p> 
<p>在main()函数中调用了Simulator()函数来模拟整个系统的运行。Simulator()函数中依次调用了Init_Process()函数来初始化5个进程，Run_Process()函数来运行系统，并在最后调用End_Process()函数来结束系统。</p> 
<p>Init_Process()函数用来初始化5个进程。在这个函数中，首先调用了Init_Queue()函数来初始化进程队列，然后使用for循环来创建5个进程。在循环中，使用rand()函数来生成随机数，作为创建进程的优先级和需要时间的参数。然后调用Create_Process()函数来创建进程，并根据返回值判断是否创建成功。如果创建成功，则打印出进程的相关信息；否则，打印出创建失败的信息。</p> 
<p>Init_Queue()函数用来初始化进程队列。在这个函数中，使用for循环来遍历进程队列中的每一个元素，并对其进行初始化。初始化包括设置进程的ID、动态优先级、需要时间、开始时间、静态优先级、已使用时间和状态。</p> 
<p>Create_Process()函数用来创建进程。在这个函数中，首先遍历进程队列，寻找一个状态为FINISH的进程。如果找到了，则将其ID赋值给id变量，并对其进行初始化，包括设置动态优先级、需要时间、开始时间、状态、静态优先级和已使用时间。最后返回id变量的值。</p> 
<p>Run_Process()函数用来运行系统。在这个函数中，首先调用Get_PriProcess()函数来获取最高优先级的进程ID。如果返回值不等于ID_ERROR，则调用Work_Process()函数来执行该进程，并调用Change_Process()函数来改变该进程的状态和优先级。然后继续循环，直到Get_PriProcess()函数返回ID_ERROR为止。</p> 
<p>Get_PriProcess()函数用来获取最高优先级的进程ID。在这个函数中，首先定义了一个id变量并初始化为ID_ERROR，然后使用for循环来遍历进程队列中的每一个元素。对于每一个元素，如果它的状态不为FINISH，则计算它的优先级（静态优先级+动态优先级），并与当前最高优先级进行比较。如果它的优先级小于等于当前最高优先级，则更新id变量和当前最高优先级。最后返回id变量的值。</p> 
<p>Work_Process()函数用来执行进程。在这个函数中，首先将全局变量g_time加1，然后将指定进程的状态设置为RUN，并将其已使用时间加1。最后调用Print_State()函数来打印进程状态。</p> 
<p>Change_Process()函数用来改变进程状态和优先级。在这个函数中，首先判断指定进程是否已经完成（即已使用时间等于需要时间）。如果已经完成，则将其状态设置为FINISH；否则，将其动态优先级设置为MIN_PRIOR，并将其状态设置为WAIT。然后使用for循环来遍历进程队列中的其他元素，并对它们的动态优先级进行更新。</p> 
<p>End_Process()函数用来结束系统。在这个函数中，首先打印出所有进程结束状态的信息，然后调用Print_State()函数来打印进程状态。最后打印出所有进程已经结束的信息。</p> 
<p style="margin-left:0;text-align:justify;">效果如下：</p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="599" src="https://images2.imgbox.com/1d/48/TuepukNV_o.png" width="678"></p> 
<p><img alt="" height="604" src="https://images2.imgbox.com/44/60/dmRH0zc0_o.png" width="763"></p> 
<p><img alt="" height="604" src="https://images2.imgbox.com/03/68/AOHndug8_o.png" width="797"></p> 
<p> 以上。</p> 
<hr> 
<h2 id="%E6%80%BB%E7%BB%93"><a id="_55"></a>总结</h2> 
<p>本实验通过编写一个C语言的进程调度程序，来模拟优先级调度算法的过程和效果。程序中定义了进程的PCB结构体，包含了进程的ID、静态优先级、动态优先级、开始时间、需要时间、已使用时间和状态等信息。程序还定义了一些函数，用来初始化进程队列、创建进程、运行系统、获取最高优先级进程、执行进程、改变进程状态和优先级、打印进程状态和结束系统等功能。程序使用了随机数来生成进程的优先级和需要时间，并使用循环来遍历进程队列，找到最高优先级的进程并执行，然后降低其动态优先级，并提高其他进程的动态优先级，以保证每个进程都有机会运行。程序在每次执行一个进程后，都会打印出当前的时间和所有进程的状态，以便观察和检查。程序在所有进程都完成后，会打印出最终的结果，并结束系统。</p> 
<p>通过本实验，加深了对进程调度算法的理解和掌握，熟悉了C语言的编程技巧和调试方法，提高了分析问题和解决问题的能力。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f61429498f89fdee69e23adacad8a091/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">大模型训练——PEFT与LORA介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ddbb8f603307379bb5ba43e51e9be874/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">国内外交通数据集介绍（附参数说明）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>