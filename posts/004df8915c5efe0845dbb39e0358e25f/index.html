<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>轻松拿捏C语言——【保姆级·指针讲解】期末C语言＜指针＞急救包，全是干货，诚意满满！ - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/004df8915c5efe0845dbb39e0358e25f/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="轻松拿捏C语言——【保姆级·指针讲解】期末C语言＜指针＞急救包，全是干货，诚意满满！">
  <meta property="og:description" content="🥰欢迎关注 轻松拿捏C语言系列，来和 小哇 一起进步！✊
🌈感谢大家的阅读、点赞、收藏和关注💕
目录👑
一、指针与内存🪐
二、指针变量 、取地址操作符&amp;和解引用操作符* 🌏
三、指针变量类型的意义🌔
1.指针变量类型不同决定了在解引用的时候能访问的字节数不同💛
2.指针变量类型决定了指针向前或向后的步长🧡
3.void*指针🩵
四、const修饰指针☀️
五、指针运算🌈
1、指针加减运算🌸
2、指针相减🌺
3、指针关系运算🌷
六、野指针🏵️
1.指针变量没有初始化
2.指针越界访问
3.指针指向的空间被释放掉了
七、传值调用与传址调用🌻
八、一维数组与指针🌼
1.数组名的理解
2.用指针访问数组
3.一维数组传参本质
九、指针数组🌙
1.定义 2.用指针数组模拟二维数组 十、字符指针变量 💙
十一、数组指针变量💜
1.定义
2.数组指针变量的初始化：
3、二维数组传参的本质： 十二、函数指针变量💗
1.定义
2.使用
3.两段代码
十三、函数指针数组💖
1.定义
2.区分两个数组，两个指针变量 3.函数指针数组用途——转移表
一、指针与内存 有一栋楼，里有200个房间，假如我们要去某个房间找某个人，然后他说他在C304，我们就能通过门牌号C304快速找到他所在房间。
在计算机中内存划分为一个个内存单元，每个内存单元也有编号，每个内存单元占1字节的空间大小，1字节又等于8个比特位
这相当于，内存就是一栋楼，每个内存单元就是一个房间，内存单元编号就是房间门牌号，房间里有8个床位。
内存单元编号==地址==指针
二、指针变量 、取地址操作符&amp;和解引用操作符* int a = 10;
这里创建了一个整型变量a，占四个字节，所以就会向内存申请四个字节大小的连续空间，每个字节的内存单元都有编号。
通过取地址符&amp; 我们可以得到a所占四个字节中 地址最小的内存单元 的地址，该地址就是变量a的地址
因为这四个字节的空间连续，我们得到了这一个地址，就能挨着访问另外的地址
拿到地址有什么用？
我们可以将地址存储在一个变量中，用来存储地址的这个变量就叫做指针变量
int a = 10;
int* b = &amp;a;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-19T10:25:05+08:00">
    <meta property="article:modified_time" content="2024-05-19T10:25:05+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">轻松拿捏C语言——【保姆级·指针讲解】期末C语言＜指针＞急救包，全是干货，诚意满满！</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p><img alt="" src="https://images2.imgbox.com/4e/1a/TTvlMnZt_o.gif"><img alt="" height="313" src="https://images2.imgbox.com/a0/e2/1ymphqsF_o.gif" width="1200"><span style="color:#be191c;"><span style="background-color:#fefcd8;">🥰欢迎关注 </span></span><strong><strong><strong><strong><strong><strong><strong><strong><span style="color:#be191c;"><span style="background-color:#fefcd8;"><a href="https://blog.csdn.net/kiku20231213/category_12648019.html?spm=1001.2014.3001.5482" title="轻松拿捏C语言系列">轻松拿捏C语言系列</a></span></span></strong></strong></strong></strong></strong></strong></strong></strong><span style="color:#be191c;"><span style="background-color:#fefcd8;">，来和 小哇 一起进步！✊</span></span></p> 
<p><span style="color:#be191c;"><span style="background-color:#fefcd8;">🌈感谢大家的阅读、点赞、收藏和关注💕</span></span></p> 
<hr> 
<p id="main-toc"><strong>目录</strong>👑</p> 
<p id="%C2%A0%E4%B8%80%E3%80%81%E6%8C%87%E9%92%88%E4%B8%8E%E5%86%85%E5%AD%98-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%80%E3%80%81%E6%8C%87%E9%92%88%E4%B8%8E%E5%86%85%E5%AD%98" rel="nofollow"><span style="color:#956fe7;"><span style="background-color:#edf6e8;"> 一、指针与内存</span></span></a><span style="color:#956fe7;"><span style="background-color:#edf6e8;">🪐</span></span></p> 
<p id="%E4%BA%8C%E3%80%81%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%20%E3%80%81%E5%8F%96%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%AC%A6%26%E5%92%8C%E8%A7%A3%E5%BC%95%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6*%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%20%E3%80%81%E5%8F%96%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%AC%A6%26%E5%92%8C%E8%A7%A3%E5%BC%95%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6*%C2%A0" rel="nofollow"><span style="color:#956fe7;"><span style="background-color:#edf6e8;">二、指针变量 、取地址操作符&amp;和解引用操作符* </span></span></a><span style="color:#956fe7;"><span style="background-color:#edf6e8;">🌏</span></span></p> 
<p id="%E4%B8%89%E3%80%81%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%84%8F%E4%B9%89-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%84%8F%E4%B9%89" rel="nofollow"><span style="color:#956fe7;"><span style="background-color:#edf6e8;">三、指针变量类型的意义</span></span></a><span style="color:#956fe7;"><span style="background-color:#edf6e8;">🌔</span></span></p> 
<p id="1.%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C%E5%86%B3%E5%AE%9A%E4%BA%86%E5%9C%A8%E8%A7%A3%E5%BC%95%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%E8%83%BD%E8%AE%BF%E9%97%AE%E7%9A%84%E5%AD%97%E8%8A%82%E6%95%B0%E4%B8%8D%E5%90%8C-toc" style="margin-left:40px;"><a href="#1.%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C%E5%86%B3%E5%AE%9A%E4%BA%86%E5%9C%A8%E8%A7%A3%E5%BC%95%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%E8%83%BD%E8%AE%BF%E9%97%AE%E7%9A%84%E5%AD%97%E8%8A%82%E6%95%B0%E4%B8%8D%E5%90%8C" rel="nofollow"><span style="color:#956fe7;"><span style="background-color:#edf6e8;">1.指针变量类型不同决定了在解引用的时候能访问的字节数不同</span></span></a><span style="color:#956fe7;"><span style="background-color:#edf6e8;">💛</span></span></p> 
<p id="2.%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%86%B3%E5%AE%9A%E4%BA%86%E6%8C%87%E9%92%88%E5%90%91%E5%89%8D%E6%88%96%E5%90%91%E5%90%8E%E7%9A%84%E6%AD%A5%E9%95%BF-toc" style="margin-left:40px;"><a href="#2.%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%86%B3%E5%AE%9A%E4%BA%86%E6%8C%87%E9%92%88%E5%90%91%E5%89%8D%E6%88%96%E5%90%91%E5%90%8E%E7%9A%84%E6%AD%A5%E9%95%BF" rel="nofollow"><span style="color:#956fe7;"><span style="background-color:#edf6e8;">2.指针变量类型决定了指针向前或向后的步长</span></span></a><span style="color:#956fe7;"><span style="background-color:#edf6e8;">🧡</span></span></p> 
<p id="3.void*%E6%8C%87%E9%92%88-toc" style="margin-left:40px;"><a href="#3.void*%E6%8C%87%E9%92%88" rel="nofollow"><span style="color:#956fe7;"><span style="background-color:#edf6e8;">3.void*指针</span></span></a><span style="color:#956fe7;"><span style="background-color:#edf6e8;">🩵</span></span></p> 
<p id="%E5%9B%9B%E3%80%81const%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81const%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88" rel="nofollow"><span style="color:#1c7892;"><span style="background-color:#fef2f0;">四、const修饰指针</span></span></a><span style="color:#1c7892;"><span style="background-color:#fef2f0;">☀️</span></span></p> 
<p id="%E4%BA%94%E3%80%81%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97" rel="nofollow"><span style="color:#1c7892;"><span style="background-color:#fef2f0;">五、指针运算</span></span></a><span style="color:#1c7892;"><span style="background-color:#fef2f0;">🌈</span></span></p> 
<p id="1%E3%80%81%E6%8C%87%E9%92%88%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E6%8C%87%E9%92%88%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97" rel="nofollow"><span style="color:#1c7892;"><span style="background-color:#fef2f0;">1、指针加减运算</span></span></a><span style="color:#1c7892;"><span style="background-color:#fef2f0;">🌸</span></span></p> 
<p id="2%E3%80%81%E6%8C%87%E9%92%88%E7%9B%B8%E5%87%8F-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E6%8C%87%E9%92%88%E7%9B%B8%E5%87%8F" rel="nofollow"><span style="color:#1c7892;"><span style="background-color:#fef2f0;">2、指针相减</span></span></a><span style="color:#1c7892;"><span style="background-color:#fef2f0;">🌺</span></span></p> 
<p id="3%E3%80%81%E6%8C%87%E9%92%88%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E6%8C%87%E9%92%88%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97" rel="nofollow"><span style="color:#1c7892;"><span style="background-color:#fef2f0;">3、指针关系运算</span></span></a><span style="color:#1c7892;"><span style="background-color:#fef2f0;">🌷</span></span></p> 
<p id="%E5%85%AD%E3%80%81%E9%87%8E%E6%8C%87%E9%92%88-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E9%87%8E%E6%8C%87%E9%92%88" rel="nofollow"><span style="color:#1c7892;"><span style="background-color:#fef2f0;">六、野指针</span></span></a><span style="color:#1c7892;"><span style="background-color:#fef2f0;">🏵️</span></span></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E6%B2%A1%E6%9C%89%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E6%B2%A1%E6%9C%89%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow"><span style="color:#1c7892;"><span style="background-color:#fef2f0;">        1.指针变量没有初始化</span></span></a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E6%8C%87%E9%92%88%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E6%8C%87%E9%92%88%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE" rel="nofollow"><span style="color:#1c7892;"><span style="background-color:#fef2f0;">        2.指针越界访问</span></span></a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A03.%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E7%A9%BA%E9%97%B4%E8%A2%AB%E9%87%8A%E6%94%BE%E6%8E%89%E4%BA%86-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A03.%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E7%A9%BA%E9%97%B4%E8%A2%AB%E9%87%8A%E6%94%BE%E6%8E%89%E4%BA%86" rel="nofollow"><span style="color:#1c7892;"><span style="background-color:#fef2f0;">         3.指针指向的空间被释放掉了</span></span></a></p> 
<p id="%E4%B8%83%E3%80%81%E4%BC%A0%E5%80%BC%E8%B0%83%E7%94%A8%E4%B8%8E%E4%BC%A0%E5%9D%80%E8%B0%83%E7%94%A8-toc" style="margin-left:0px;"><a href="#%E4%B8%83%E3%80%81%E4%BC%A0%E5%80%BC%E8%B0%83%E7%94%A8%E4%B8%8E%E4%BC%A0%E5%9D%80%E8%B0%83%E7%94%A8" rel="nofollow"><span style="color:#1c7892;"><span style="background-color:#fef2f0;">七、传值调用与传址调用</span></span></a><span style="color:#1c7892;"><span style="background-color:#fef2f0;">🌻</span></span></p> 
<p id="%E5%85%AB%E3%80%81%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88-toc" style="margin-left:0px;"><a href="#%E5%85%AB%E3%80%81%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88" rel="nofollow"><span style="color:#1c7331;"><span style="background-color:#eaf4fc;">八、一维数组与指针</span></span></a><span style="color:#1c7331;"><span style="background-color:#eaf4fc;">🌼</span></span></p> 
<p id="1.%E6%95%B0%E7%BB%84%E5%90%8D%E7%9A%84%E7%90%86%E8%A7%A3-toc" style="margin-left:40px;"><a href="#1.%E6%95%B0%E7%BB%84%E5%90%8D%E7%9A%84%E7%90%86%E8%A7%A3" rel="nofollow"><span style="color:#1c7331;"><span style="background-color:#eaf4fc;">1.数组名的理解</span></span></a></p> 
<p id="2.%E7%94%A8%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#2.%E7%94%A8%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84" rel="nofollow"><span style="color:#1c7331;"><span style="background-color:#eaf4fc;">2.用指针访问数组</span></span></a></p> 
<p id="3.%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82%E6%9C%AC%E8%B4%A8-toc" style="margin-left:40px;"><a href="#3.%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82%E6%9C%AC%E8%B4%A8" rel="nofollow"><span style="color:#1c7331;"><span style="background-color:#eaf4fc;">3.一维数组传参本质</span></span></a></p> 
<p id="%E4%B9%9D%E3%80%81%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84-toc" style="margin-left:0px;"><a href="#%E4%B9%9D%E3%80%81%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84" rel="nofollow"><span style="color:#1c7331;"><span style="background-color:#eaf4fc;">九、指针数组</span></span></a><span style="color:#1c7331;"><span style="background-color:#eaf4fc;">🌙</span></span></p> 
<p id="1.%E5%AE%9A%E4%B9%89%C2%A0-toc" style="margin-left:40px;"><a href="#1.%E5%AE%9A%E4%B9%89%C2%A0" rel="nofollow"><span style="color:#1c7331;"><span style="background-color:#eaf4fc;">1.定义 </span></span></a></p> 
<p id="2.%E7%94%A8%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%C2%A0-toc" style="margin-left:40px;"><a href="#2.%E7%94%A8%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%C2%A0" rel="nofollow"><span style="color:#1c7331;"><span style="background-color:#eaf4fc;">2.用指针数组模拟二维数组 </span></span></a></p> 
<p id="%E5%8D%81%E3%80%81%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E3%80%81%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%C2%A0" rel="nofollow"><span style="color:#1c7331;"><span style="background-color:#eaf4fc;">十、字符指针变量 </span></span></a><span style="color:#1c7331;"><span style="background-color:#eaf4fc;">💙</span></span></p> 
<p id="%E5%8D%81%E4%B8%80%E3%80%81%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E4%B8%80%E3%80%81%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F" rel="nofollow"><span style="color:#1c7331;"><span style="background-color:#eaf4fc;">十一、数组指针变量</span></span></a><span style="color:#1c7331;"><span style="background-color:#eaf4fc;">💜</span></span></p> 
<p id="1.%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#1.%E5%AE%9A%E4%B9%89" rel="nofollow"><span style="color:#1c7331;"><span style="background-color:#eaf4fc;">1.定义</span></span></a></p> 
<p id="2.%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A-toc" style="margin-left:40px;"><a href="#2.%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A" rel="nofollow"><span style="color:#1c7331;"><span style="background-color:#eaf4fc;">2.数组指针变量的初始化：</span></span></a></p> 
<p id="3%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%9A%C2%A0-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%9A%C2%A0" rel="nofollow"><span style="color:#1c7331;"><span style="background-color:#eaf4fc;">3、二维数组传参的本质： </span></span></a></p> 
<p id="%E5%8D%81%E4%BA%8C%E3%80%81%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E4%BA%8C%E3%80%81%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#ffd7b9;">十二、函数指针变量</span></span></a><span style="color:#be191c;"><span style="background-color:#ffd7b9;">💗</span></span></p> 
<p id="1.%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#1.%E5%AE%9A%E4%B9%89" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#ffd7b9;">1.定义</span></span></a></p> 
<p id="2.%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#2.%E4%BD%BF%E7%94%A8" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#ffd7b9;">2.使用</span></span></a></p> 
<p id="3.%E4%B8%A4%E6%AE%B5%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#3.%E4%B8%A4%E6%AE%B5%E4%BB%A3%E7%A0%81" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#ffd7b9;">3.两段代码</span></span></a></p> 
<p id="%E5%8D%81%E4%B8%89%E3%80%81%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E4%B8%89%E3%80%81%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#ffd7b9;">十三、函数指针数组</span></span></a><span style="color:#be191c;"><span style="background-color:#ffd7b9;">💖</span></span></p> 
<p id="%C2%A01.%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#%C2%A01.%E5%AE%9A%E4%B9%89" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#ffd7b9;"> 1.定义</span></span></a></p> 
<p id="2.%E5%8C%BA%E5%88%86%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%EF%BC%8C%E4%B8%A4%E4%B8%AA%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%C2%A0-toc" style="margin-left:40px;"><a href="#2.%E5%8C%BA%E5%88%86%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%EF%BC%8C%E4%B8%A4%E4%B8%AA%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%C2%A0" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#ffd7b9;">2.区分两个数组，两个指针变量 </span></span></a></p> 
<p id="3.%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E7%94%A8%E9%80%94%E2%80%94%E2%80%94%E8%BD%AC%E7%A7%BB%E8%A1%A8-toc" style="margin-left:40px;"><a href="#3.%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E7%94%A8%E9%80%94%E2%80%94%E2%80%94%E8%BD%AC%E7%A7%BB%E8%A1%A8" rel="nofollow"><span style="color:#be191c;"><span style="background-color:#ffd7b9;">3.函数指针数组用途——转移表</span></span></a></p> 
<hr id="hr-toc"> 
<p></p> 
<p> </p> 
<h2 id="%C2%A0%E4%B8%80%E3%80%81%E6%8C%87%E9%92%88%E4%B8%8E%E5%86%85%E5%AD%98" style="background-color:transparent;"><span style="background-color:#e7fafa;"> </span><span style="background-color:#e7fafa;">一、指针与内存</span></h2> 
<p>        有一栋楼，里有200个房间，假如我们要去某个房间找某个人，然后他说他在C304，我们就能通过门牌号C304快速找到他所在房间。</p> 
<p>        在计算机中<strong><span style="background-color:#e7fafa;">内存划分为一个个内存单元，每个内存单元也有编号，每个内存单元占1字节的空间大小，1字节又等于8个比特位</span></strong></p> 
<p>       这相当于，内存就是一栋楼，每个内存单元就是一个房间，内存单元编号就是房间门牌号，房间里有8个床位。</p> 
<p>        <span style="color:#0d0016;"><strong><span style="background-color:#e7fafa;">内存单元编号==地址==指针</span></strong></span></p> 
<p></p> 
<h2 id="%E4%BA%8C%E3%80%81%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%20%E3%80%81%E5%8F%96%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%AC%A6%26%E5%92%8C%E8%A7%A3%E5%BC%95%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6*%C2%A0" style="background-color:transparent;"><span style="background-color:#e7fafa;">二、指针变量 、取地址操作符&amp;和解引用操作符*</span> </h2> 
<p>       <span style="background-color:#f9eda6;">  int a = 10;</span></p> 
<p>        这里创建了一个整型变量a，占四个字节，所以就会向内存申请四个字节大小的连续空间，每个字节的内存单元都有编号。</p> 
<p>        通过<strong>取地址符&amp; </strong>我们可以得到a所占四个字节中 地址最小的内存单元 的地址，该地址就是变量a的地址</p> 
<p>        因为这四个字节的空间连续，我们得到了这一个地址，就能挨着访问另外的地址</p> 
<p>        拿到地址有什么用？</p> 
<p>        我们可以将地址存储在一个变量中，用来存储地址的这个变量就叫做<strong>指针变量</strong></p> 
<p><strong>    <span style="background-color:#f9eda6;">   </span></strong><span style="background-color:#f9eda6;">int a = 10;</span></p> 
<p><span style="background-color:#f9eda6;">       int* b = &amp;a;</span></p> 
<p>这里b就是一个指针变量，它的类型是int*类型。int*中*说明b是指针变量，int说明b指向的对象是整型（即b中存储的这个地址对应的变量a是整型）</p> 
<p>        通过<strong>解引用操作符*</strong>,我们可以改变指针变量指向的内容</p> 
<p><strong><span style="background-color:#f9eda6;">           </span></strong><span style="background-color:#f9eda6;">int a = 10;</span></p> 
<p><span style="background-color:#f9eda6;">           int* b = &amp;a;</span></p> 
<p><span style="background-color:#f9eda6;">           *b = 5；</span>这样a中的值就从10变成了5。b中存放的是a的地址，*b就是找到b中存放的地址对应的空间，所以其实*b就是a了，*b=5就是把a变成了5。</p> 
<p>        通过解引用操作符没有直接修改变量a，而是通过地址来间接修改</p> 
<p>另外指针变量的大小与它的类型没有关系，在32位平台下（32个比特位），指针变量大小是4个字节；在64位平台下指针变量是8个字节。</p> 
<p></p> 
<p>总结一下关于指针p的三个值：</p> 
<blockquote> 
 <p>​​int a = 1;</p> 
 <p>int* p = &amp;a;</p> 
</blockquote> 
<p>①p        p中放着一个地址，这里是a的地址</p> 
<p>②*p        p指向的对象，这里为a</p> 
<p>③&amp;p        表示变量p的地址 </p> 
<p></p> 
<p><strong>        二级指针：存放一级指针变量地址的变量</strong></p> 
<p>int a = 10;</p> 
<p>int* p =&amp;a;</p> 
<p>int** m = &amp;p;</p> 
<p><img alt="" height="269" src="https://images2.imgbox.com/b5/27/jkiDkFV4_o.png" width="293"> </p> 
<p>对*m = p，**m = *p = a。</p> 
<p></p> 
<h2 id="%E4%B8%89%E3%80%81%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%84%8F%E4%B9%89"><span style="background-color:#e7fafa;">三、指针变量类型的意义</span></h2> 
<h3 id="1.%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C%E5%86%B3%E5%AE%9A%E4%BA%86%E5%9C%A8%E8%A7%A3%E5%BC%95%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%E8%83%BD%E8%AE%BF%E9%97%AE%E7%9A%84%E5%AD%97%E8%8A%82%E6%95%B0%E4%B8%8D%E5%90%8C">1.指针变量类型不同决定了在解引用的时候能访问的字节数不同</h3> 
<p>例如，char*类型的指针解引用时只能访问一个字节，而int*类型的指针解引用能访问四个字节</p> 
<p><span style="background-color:#fefcd8;">int n = 0x11223344;</span></p> 
<p><span style="background-color:#fefcd8;">int *pi = &amp;n;</span></p> 
<p><span style="background-color:#fefcd8;">*pi = 0;</span>这里将变量n的四个字节空间的内容都改成0</p> 
<p><span style="background-color:#fef2f0;">int n = 0x11223344;</span></p> 
<p><span style="background-color:#fef2f0;">char *pc = (char *)&amp;n;</span></p> 
<p><span style="background-color:#fef2f0;">*pc = 0;</span>这里只将变量n四个字节中第一个字节的内容改为0</p> 
<h3 id="2.%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%86%B3%E5%AE%9A%E4%BA%86%E6%8C%87%E9%92%88%E5%90%91%E5%89%8D%E6%88%96%E5%90%91%E5%90%8E%E7%9A%84%E6%AD%A5%E9%95%BF">2.指针变量类型决定了指针向前或向后的步长</h3> 
<p>char* 类型的指针变量+1跳过1个字节， int* 类型的指针变量+1跳过了4个字节。这就是指针变量的类型差异带来的变化。</p> 
<p>指针+1，其实跳过1个指针指向的元素。指针可以+1，那也可 以-1。</p> 
<h3 id="3.void*%E6%8C%87%E9%92%88"><strong>3.void*指针</strong></h3> 
<p>void*是一种特殊的指针类型，也叫泛型指针（或无具体类型的指针）</p> 
<p>优点：可以接收任何类型的指针</p> 
<p>缺点：不能进行 指针+-整数的运算，不能进行 解引用操作</p> 
<p></p> 
<h2 id="%E5%9B%9B%E3%80%81const%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88" style="background-color:transparent;"><span style="background-color:#e7fafa;">四、const修饰指针</span></h2> 
<p>       <strong> const修饰变量时，变量不能被修改</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
int main()
{
 int m = 0;
 m = 20;//m是可以修改的
 const int n = 0;
 n = 20;//n是不能被修改的
 return 0;
}</code></pre> 
<p>但是这里我们可以不直接修改变量n，可以通过它的地址来间接修改</p> 
<p><img alt="" height="208" src="https://images2.imgbox.com/93/3f/ABUaKKoI_o.png" width="451">但我们给n加上const的目的就是为了使它不能被修改，所以我们应该让p拿到n的地址后也不能间接修改n</p> 
<p>我们可以在*p前面加上const<span style="background-color:#fff5e6;">      const int *p = &amp;n;   或者  int const *p   </span>这样就不能通过指针变量p来间接修改n的值了</p> 
<p><strong>const如果放在*的左边，修饰的是指针指向的内容，保证指针指向的内容不能通过指针来改变。 但是指针变量本身的内容可变（就是他存储的地址可以改变）。 </strong></p> 
<p><strong> const如果放在*的右边，修饰的是指针变量本身，保证了指针变量的内容不能修改（它存储的地址不能改变），但是指针指向的内容，可以通过指针改变。</strong></p> 
<p></p> 
<h2 id="%E4%BA%94%E3%80%81%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97"><span style="background-color:#e7fafa;">五、指针运算</span></h2> 
<h3 id="1%E3%80%81%E6%8C%87%E9%92%88%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97">1、指针加减运算</h3> 
<p>        数组在内存中连续存放，找到第一个元素地址就能顺藤摸瓜找到所有元素</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
int main()
{
 int arr[10] = {1,2,3,4,5,6,7,8,9,10};
 int *p = &amp;arr[0];
 int i = 0;
 int sz = sizeof(arr)/sizeof(arr[0]);
 for(i=0; i&lt;sz; i++)
 {
     printf("%d ", *(p+i));// p+i 这⾥就是指针+整数
 }
 return 0;
}</code></pre> 
<h3 id="2%E3%80%81%E6%8C%87%E9%92%88%E7%9B%B8%E5%87%8F">2、指针相减</h3> 
<p><strong>前提：两个指针指向同一块空间</strong></p> 
<p><strong>指针 - 指针的绝对值是指针间的元素个数</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
int my_strlen(char *s)//s为字符串常量abc中a的地址
{
 char *p = s;
 while(*p != '\0' )
     p++;当p指向\0，不再++
 return p-s;指向\0的地址p减指向a的地址s，所以p-s为3
}
int main()
{
 printf("%d\n", my_strlen("abc"));//打印3
 return 0;
}</code></pre> 
<h3 id="3%E3%80%81%E6%8C%87%E9%92%88%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97">3、指针关系运算</h3> 
<p>地址大小比较</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
int main()
{
 int arr[10] = {1,2,3,4,5,6,7,8,9,10};
 int *p = &amp;arr[0];
 int sz = sizeof(arr)/sizeof(arr[0]);
 while(p&lt;arr+sz) //指针的⼤⼩⽐较
 {
     printf("%d ", *p);
     p++;
 }
 return 0;
}
</code></pre> 
<h2></h2> 
<h2 id="%E5%85%AD%E3%80%81%E9%87%8E%E6%8C%87%E9%92%88"><span style="background-color:#e7fafa;">六、野指针</span></h2> 
<p>指针指向的位置是未知的、不正确的、随机的，那么这个指针就是野指针。</p> 
<p>     <strong>   野指针成因：</strong></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E6%B2%A1%E6%9C%89%E5%88%9D%E5%A7%8B%E5%8C%96">        1.指针变量没有初始化</h3> 
<p><span style="background-color:#fff5e6;">int *p;//局部变量指针未初始化，默认为随机值</span></p> 
<p><span style="background-color:#fff5e6;">*p = 20;</span></p> 
<p>        规避方法，将指针初始化</p> 
<p>        当不知道指针变量该指向哪里时，可以给指针赋值NULL. NULL 是C语⾔中定义的⼀个标识符常量，值是0，0也是地址，这个地址是无法使用的，读写该地址会报错。 </p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E6%8C%87%E9%92%88%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE">        2.指针越界访问</h3> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
int main()
{
 int arr[10] = {0};
 int *p = &amp;arr[0];
 int i = 0;
 for(i=0; i&lt;=11; i++)
 {
     //当指针指向的范围超出数组arr的范围时，p就是野指针
     *(p++) = i;
 }
 return 0;
}</code></pre> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A03.%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E7%A9%BA%E9%97%B4%E8%A2%AB%E9%87%8A%E6%94%BE%E6%8E%89%E4%BA%86">        <strong> 3.指针指向的空间被释放掉了</strong></h3> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
int* test()
{
 int n = 100;//局部变量n
 return &amp;n;//该函数结束后，创建的变量n会被销毁
}
int main()
{
 int*p = test();
 printf("%d\n", *p);
 return 0;
}</code></pre> 
<h2 style="background-color:transparent;"></h2> 
<h2 id="%E4%B8%83%E3%80%81%E4%BC%A0%E5%80%BC%E8%B0%83%E7%94%A8%E4%B8%8E%E4%BC%A0%E5%9D%80%E8%B0%83%E7%94%A8" style="background-color:transparent;"><span style="background-color:#e7fafa;">七、传值调用与传址调用</span></h2> 
<p>        通过一个题来感受一下什么是传值调用，什么是传址调用</p> 
<p>写一个函数，交换整型变量的值</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
void Swap(int x, int y)
{
 int tmp = x;
 x = y;
 y = tmp;
}
int main()
{
 int a = 0;
 int b = 0;
 scanf("%d %d", &amp;a, &amp;b);
 printf("交换前：a=%d b=%d\n", a, b);
 Swap(a, b);
 printf("交换后：a=%d b=%d\n", a, b);
 return 0;
}</code></pre> 
<p><img alt="" height="761" src="https://images2.imgbox.com/c6/a7/TP2eQYIv_o.png" width="1200"></p> 
<p>但是我们却发现a和b的值却没有交换</p> 
<p>调试看一下：</p> 
<p><img alt="" height="675" src="https://images2.imgbox.com/14/a4/RE5IOFlC_o.png" width="1179"></p> 
<p>通过调试我们发现，虽然a确实把值传给了x，b把值传给了y，但是a的地址和x的地址不是同一个地址，b的地址和y的地址也不是同一个地址。</p> 
<p>这是因为变量x和y是在Swap函数内部创建的，变量x和变量y是两个独立的空间，因此x和y交换值对变量a和b是没有影响的。</p> 
<p>像这样把变量的值传给函数，这就是<strong><span style="background-color:#fff5e6;">传值调用。</span></strong></p> 
<p><strong><span style="background-color:#fff5e6;">把实际参数传递给形式参数时，形参会单独创建一个空间来接收实参，因此形参的改变对实参没有影响</span>。</strong></p> 
<p>所以我们可以将a和b的地址传过去，通过地址将a和b的值交换。 </p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
void Swap(int* x, int* y)
{
 int tmp = *x;
 *x = *y;
 *y = tmp;
}
int main()
{
 int a = 0;
 int b = 0;
 scanf("%d %d", &amp;a, &amp;b);
 printf("交换前：a=%d b=%d\n", a, b);
 Swap(&amp;a, &amp;b);
 printf("交换后：a=%d b=%d\n", a, b);
 return 0;
}</code></pre> 
<p><img alt="" height="313" src="https://images2.imgbox.com/6f/77/dWWcH4UQ_o.png" width="553"> 交换成功。</p> 
<p>像这样把变量的地址传递给函数，这就是<strong>传址调用。</strong></p> 
<p>所以在函数中需要改变主调函数中变量的值，我们可以采用传址调用；如果仅需要在函数内利用变量的值来计算，就采用传值调用。</p> 
<h2 style="background-color:transparent;"></h2> 
<h2 id="%E5%85%AB%E3%80%81%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88" style="background-color:transparent;"><span style="background-color:#e7fafa;">八、一维数组与指针</span></h2> 
<h3 id="1.%E6%95%B0%E7%BB%84%E5%90%8D%E7%9A%84%E7%90%86%E8%A7%A3">1.数组名的理解</h3> 
<p><strong><span style="background-color:#fefcd8;">数组名是数组首元素的地址</span></strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
int main()
{
 int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
 printf("&amp;arr[0] = %p\n", &amp;arr[0]);
 printf("arr = %p\n", arr);
 return 0;
}
</code></pre> 
<p><img alt="" height="232" src="https://images2.imgbox.com/36/e3/aGncnCWh_o.png" width="292"> 数组名和数组首元素打出的地址一样。</p> 
<p>但是有两个例外：</p> 
<p>       <strong>1、 sizeof(数组名)，sizeof中单独放数组名，这的数组名表示整个数组，计算的是整个数组的大小， 单位是字节</strong></p> 
<p><strong>       2、 &amp;数组名，这的数组名表示整个数组，取出的是整个数组的地址</strong></p> 
<p>这里讲一下&amp;arr和arr的区别：</p> 
<p><img alt="" height="265" src="https://images2.imgbox.com/8d/8b/aLORyCxa_o.png" width="378"></p> 
<p>可以看出它们三个打印出的一模一样，没区别呀？</p> 
<p><img alt="" height="335" src="https://images2.imgbox.com/9d/bd/ikVOHHUK_o.png" width="373"></p> 
<p>这时就发现，&amp;arr[0]和arr加1，它们地址都只加了 4，而&amp;arr加1后，它的地址加了40。</p> 
<p>这时因为&amp;arr[0]和arr都是首元素的地址，它们加1，就是跳过一个元素</p> 
<p>而&amp;arr是整个数组的地址，它加1就是跳过整个数组</p> 
<h3 id="2.%E7%94%A8%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84">2.用指针访问数组</h3> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
int main()
{
 int arr[10] = {0};
 //输⼊
 int i = 0;
 int sz = sizeof(arr)/sizeof(arr[0]);
 //输⼊
 int* p = arr;
 for(i=0; i&lt;sz; i++)
 {
 scanf("%d", p+i);
 //scanf("%d", arr+i);//也可以这样写
 }
 //输出
 for(i=0; i&lt;sz; i++)
 {
 printf("%d ", *(p+i));
 }
 return 0;
}
</code></pre> 
<p>将*(p+i)换成p[i]也是能够正常打印的，所以本质上p[i] 是等价于 *(p+i)。</p> 
<p>同理arr[i] 应该等价于 *(arr+i) 。</p> 
<h3 id="3.%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82%E6%9C%AC%E8%B4%A8" style="background-color:transparent;"><strong>3.一维数组传参本质</strong></h3> 
<p>之前我们都是在主函数里计算数组元素的个数，那能在函数里计算吗？</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
void test(int arr[])
{
 int sz2 = sizeof(arr)/sizeof(arr[0]);
 printf("sz2 = %d\n", sz2);
}
int main()
{
 int arr[10] = {1,2,3,4,5,6,7,8,9,10};
 int sz1 = sizeof(arr)/sizeof(arr[0]);
 printf("sz1 = %d\n", sz1);
 test(arr);
 return 0;
}</code></pre> 
<p>这个代码看上去感觉sz1和sz2算出来是一样的，但并不是这样。 </p> 
<p><img alt="" height="373" src="https://images2.imgbox.com/db/bc/kuvtIEDA_o.png" width="409"></p> 
<p>上面讲过，<strong>arr表示数组首元素的<span style="background-color:#ffd7b9;">地址</span></strong>，因此在形参中我们应该用一个int* 类型的指针变量来接受实参，所以形参中int arr[]只是写成了数组的形式，本质上还是一个指针变量。</p> 
<p>所以在函数内部sizeof（arr）计算的是数组首元素的地址的大小，并不是整个数组的大小</p> 
<p>（这里提一个点，在32位的环境下 指针变量占4字节，64位环境下 指针变量占8字节，所以不同环境下sz2可能算出来一个是1，一个是2）。</p> 
<h2 style="background-color:transparent;"></h2> 
<h2 id="%E4%B9%9D%E3%80%81%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84" style="background-color:transparent;"><span style="background-color:#e7fafa;">九、指针数组</span></h2> 
<h3 id="1.%E5%AE%9A%E4%B9%89%C2%A0">1.定义 </h3> 
<p><span style="color:#fe2c24;"><strong><span style="background-color:#fefcd8;">        指针数组是一个存放指针的数组，是数组。</span></strong></span></p> 
<p>        类比，整型数组是存放整型的，字符数组是存放字符的数组。</p> 
<p>所以指针数组的每个元素存储的都是地址，类型都为指针类型，每个元素又能通过指针指向一块空间。</p> 
<blockquote> 
 <p>一个指针数组arr，长度为5，元素类型为int*类型 即元素都是 整型指针变量 的地址。</p> 
 <p>int* arr[5] = {&amp;a1,&amp;a2,&amp;a3,&amp;a4,&amp;a5};</p> 
 <p>那么这个数组arr的类型 为 int* [5]</p> 
</blockquote> 
<h3 id="2.%E7%94%A8%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%C2%A0"><strong>2.用指针数组模拟二维数组 </strong></h3> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
int main()
{
 int arr1[] = {1,2,3,4,5};
 int arr2[] = {2,3,4,5,6};
 int arr3[] = {3,4,5,6,7};
 //数组名是数组⾸元素的地址，类型是int*的，就可以存放在parr数组中
 int* parr[3] = {arr1, arr2, arr3};
 int i = 0;
 int j = 0;
 for(i=0; i&lt;3; i++)
 {
 for(j=0; j&lt;5; j++)
 {
 printf("%d ", parr[i][j]);
 }
 printf("\n");
 }</code></pre> 
<p>parr[i]是访问parr数组的元素，parr[i]找到的数组元素指向了整型⼀维数组，parr[i][j]就是整型⼀维数组中的元素。 </p> 
<p>但这并非是二维数组，二维数组是连续的一块空间，但指针数组模拟的并不是连续的。</p> 
<p><img alt="" height="244" src="https://images2.imgbox.com/05/ce/v2aXUgLz_o.png" width="425"></p> 
<h2 style="background-color:transparent;"></h2> 
<h2 id="%E5%8D%81%E3%80%81%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%C2%A0" style="background-color:transparent;"><span style="background-color:#e7fafa;">十、字符指针变量</span> </h2> 
<p><span style="background-color:#fefcd8;"><strong>有一种指针类型是 char* 类型</strong></span></p> 
<p><span style="background-color:#fefcd8;"><strong>        它是把一个字符的地址放进指针变量中</strong></span></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
{
    char a = 'w';
    char* p = &amp;a;
    printf("%c\n",*P);
    return 0;
}</code></pre> 
<p>请问下面这个代码是把⼀个字符串放到pstr指针变量里了吗</p> 
<pre><code class="language-cpp">int main()
{
 const char* pstr = "hello Bao Gengxiaowa.";
 printf("%s\n", pstr);
 return 0;
}</code></pre> 
<p><strong>并不是！</strong></p> 
<p> 它是将字符串hello Bao Gengxiaowa.的首元素地址即h的地址放进指针变量中。</p> 
<p>用%s打印字符串，只需要传首元素的地址。</p> 
<p> </p> 
<p>现在来看一段代码：</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
int main()
{
 char str1[] = "hello Bao Gengxiaowa.";
 char str2[] = "hello Bao Gengxiaowa.";
 const char *str3 = "hello Bao Gengxiaowa.";
 const char *str4 = "hello Bao Gengxiaowa.";
 if(str1 ==str2)
 printf("str1 and str2 are same\n");
 else
 printf("str1 and str2 are not same\n");
 
 if(str3 ==str4)
 printf("str3 and str4 are same\n");
 else
 printf("str3 and str4 are not same\n");
 
 return 0;
}
</code></pre> 
<p>❓ 你觉得程序允许后屏幕会打印哪些语句？</p> 
<p><img alt="" height="296" src="https://images2.imgbox.com/37/2b/12RxYXF6_o.png" width="441"></p> 
<p>你对了吗😃</p> 
<p><img alt="" height="256" src="https://images2.imgbox.com/fb/6d/DXq32s7S_o.png" width="422"></p> 
<p>这是因为str1和str2是两个数组首元素的地址，是两个不同的地址。</p> 
<p>        所以str1、str2 not same</p> 
<p>而str3、str4都是字符指针变量，都存放的是字符串 hello Bao Gengxiaowa.的首元素h的地址。</p> 
<p>        所以str3、str4 same</p> 
<h2 style="background-color:transparent;"></h2> 
<h2 id="%E5%8D%81%E4%B8%80%E3%80%81%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F" style="background-color:transparent;"><span style="background-color:#e7fafa;">十一、数组指针变量</span></h2> 
<h3 id="1.%E5%AE%9A%E4%B9%89" style="background-color:transparent;">1.定义</h3> 
<p><span style="background-color:#fff5e6;">       <span style="color:#fe2c24;"><strong> 数组指针变量是一个指向数组的指针，存储的是数组的地址，它不是数组</strong></span></span></p> 
<p>类比一下：</p> 
<p>        整型指针变量 int* p;存储的是一个int型变量的地址，指针类型是 int*。</p> 
<p>        字符指针变量 char* p；存储的是一个char类型变量的地址，指针类型是 char*。</p> 
<p>看看这两个分别是什么：</p> 
<blockquote> 
 <p>int *p1[10];</p> 
 <p>int (*p2)[10];</p> 
</blockquote> 
<p>        第一个是 一个数组长度为10，数组元素类型为 int* 的 指针数组，存储的是指针（地址）。</p> 
<p>        第二个是 一个指向的 数组长度为10 数组元素类型为 int 的 数组指针，这个数组指针变量中存储的是数组的地址。 <strong>这个指针变量的类型为 int （*）[10]</strong></p> 
<p><span style="background-color:#fefcd8;">注意：[]的优先级要高于*号的，所以在数组指针变量中，必须加上（）来保证p先和*结合，否则p和[]先结合，那就是一个指针数组了。</span></p> 
<h3 id="2.%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A"><strong>2.数组指针变量的初始化：</strong></h3> 
<blockquote> 
 <p>int arr[10] = {0};</p> 
 <p>int (*p)[10] = &amp;arr;//数组的地址 </p> 
</blockquote> 
<p>p和&amp;arr的类型一致，都是int （*）[10]类型。</p> 
<p>p是这个数组指针变量的变量名，10表示p指向的数组元素个数，int为数组元素的类型。</p> 
<h3 id="3%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%9A%C2%A0"><strong>3、二维数组传参的本质：</strong> </h3> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
void test(int a[3][5], int r, int c)
{
 ………
}
int main()
{
 int arr[3][5] = {<!-- -->{1,2,3,4,5}, {2,3,4,5,6},{3,4,5,6,7}};
 test(arr, 3, 5);
 return 0;
}
</code></pre> 
<p>这里实参是二维数组，形参也是二维数组的形式 ，知道了数组指针后 参数还能有别的写法吗？</p> 
<p><img alt="" height="292" src="https://images2.imgbox.com/f8/74/bPC81oEf_o.png" width="556"></p> 
<p>二维数组可以看成是一个 一维数组 的数组，每一行就是一个一维数组，那么二维数组首元素的地址就是第一行的地址</p> 
<p>第一行数组元素类型为 int [5]，所以第一行元素的<strong>地址的类型</strong>为 int (*)[5]</p> 
<p><span style="background-color:#fef2f0;"><strong>所以二维数组传参的本质是 传递了地址，传递的是第一行这个一维数组的地址。</strong></span></p> 
<p>所以形参也可以写成指针形式：</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
void test(int (*p)[5], int r, int c)
{
 int i = 0;
 int j = 0;
 for(i=0; i&lt;r; i++)
 {
     for(j=0; j&lt;c; j++)
     {
         printf("%d ", *(*(p+i)+j));
     }
     printf("\n");
 }
}

int main()
{
 int arr[3][5] = {<!-- -->{1,2,3,4,5}, {2,3,4,5,6},{3,4,5,6,7}};
 test(arr, 3, 5);
 return 0;
}
</code></pre> 
<h2 style="background-color:transparent;"></h2> 
<h2 id="%E5%8D%81%E4%BA%8C%E3%80%81%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F" style="background-color:transparent;"><span style="background-color:#e7fafa;">十二、函数指针变量</span></h2> 
<h3 style="background-color:transparent;">1.定义</h3> 
<p><span style="color:#fe2c24;"><span style="background-color:#fefcd8;">        </span></span><span style="color:#ed7976;"><span style="background-color:#fefcd8;">函数指针变量是存放函数地址的变量，能通过这个变量或地址来调用函数</span></span></p> 
<p><span style="background-color:#fefcd8;">        <span style="color:#ed7976;">函数名 就是函数的地址，也可以在函数名的前面加上&amp;来获取地址</span>（加不加&amp;都一样）</span></p> 
<p>  写法：</p> 
<pre><code class="language-cpp">void test()
{
 printf("hehe\n");
}
void (*pf1)() = &amp;test;
void (*pf2)()= test;


int Add(int x, int y)
{
 return x+y;
}
int(*pf3)(int, int) = Add;
int(*pf3)(int x, int y) = &amp;Add;//x和y写上或者省略都是可以的</code></pre> 
<p><strong>那int(*pf3)(int, int)举例，pf3是函数指针变量的变量名，</strong></p> 
<p><strong><span style="background-color:#fef2f0;">函数指针变量pf3的类型（就是函数地址的类型）是int(*)(int,int)</span></strong></p> 
<p><strong>它指向的函数的参数有两个，类型都为int，函数的返回值类型为int</strong>。</p> 
<h3 id="2.%E4%BD%BF%E7%94%A8">2.使用</h3> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
int Add(int x, int y)
{
 return x+y;
}
 int main()
{
 int(*pf3)(int, int) = Add;
 printf("%d\n", (*pf3)(2, 3));
 printf("%d\n", pf3(3, 5));
 return 0;
}</code></pre> 
<p>这里printf中的*pf3和pf3都是函数Add地址，所以(*pf3)(2,3)和pf3(3,5)都是在调用函数Add。 </p> 
<h3 id="3.%E4%B8%A4%E6%AE%B5%E4%BB%A3%E7%A0%81">3.两段代码</h3> 
<p>来看两段代码</p> 
<blockquote> 
 <p>(*(void (*)())0)();</p> 
</blockquote> 
<p> 这个代码中，void (*)()是一个函数指针类型，它指向的函数没有形参，返回值类型为void。</p> 
<p>void (*)()放在整数0的前面表示强制类型转换，将整型的数字0转换成void (*)()类型的 地址0。</p> 
<p>所以这是一次函数调用，调用0地址处放的那个函数，0地址处放的函数没有参数，返回值也是void</p> 
<blockquote> 
 <p>void (*signal(int , void(*)(int)))(int); </p> 
</blockquote> 
<p>这整个代码表示的是一个 函数的声明。</p> 
<p>函数名字是signal，函数参数有两个，一个是int类型，一个是 void(*)(int)函数指针类型。</p> 
<p>函数的返回值类型也是 void(*)(int)函数指针类型，也就是说函数signal的返回值是一个函数的地址。</p> 
<p>但是 我们并没有写成 void(*)(int) signal(int , void(*)(int))，而是把函数名和参数放进返回值类型里面，所以就是void (*signal(int , void(*)(int)))(int); </p> 
<h2 style="background-color:transparent;"></h2> 
<h2 id="%E5%8D%81%E4%B8%89%E3%80%81%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84" style="background-color:transparent;"><span style="background-color:#e7fafa;">十三、函数指针数组</span></h2> 
<h3 id="%C2%A01.%E5%AE%9A%E4%B9%89"> 1.定义</h3> 
<p><span style="color:#ed7976;"><span style="background-color:#fefcd8;">是一个用来存放函数指针的数组</span></span></p> 
<p><strong>定义：</strong>int (*p[3])();</p> 
<p>p先和[3]结合表示数组，数组中存放的是int (*)()类型的函数地址。</p> 
<p>我们可以这样使用</p> 
<pre><code class="language-cpp">int func1() { return 1; }  
int func2() { return 2; }  
int func3() { return 3; }  
  
int (*p[3])() = {func1, func2, func3};
</code></pre> 
<h3 id="2.%E5%8C%BA%E5%88%86%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%EF%BC%8C%E4%B8%A4%E4%B8%AA%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%C2%A0">2.区分两个数组，两个指针变量 </h3> 
<p>我们来区分一下这几个是什么：</p> 
<blockquote> 
 <p><span style="color:#ed7976;"><strong>1、int (*p[3])();  </strong></span><strong>//函数指针数组</strong></p> 
 <p><span style="color:#ed7976;"><strong>2、int*(p[3]);    </strong></span><strong>  //指针数组</strong></p> 
 <p><span style="color:#ed7976;"><strong>3、int (*p)();     </strong></span><strong> //函数指针变量</strong></p> 
 <p><span style="color:#ed7976;"><strong>4、int (*p)[3];   </strong></span><strong> //数组指针变量</strong></p> 
</blockquote> 
<p> 第1个中p是一个数组，它包含 3 个元素，每个元素都是int (*)()类型</p> 
<p>第2个中，p是一个数组，有3个元素，每个元素都是int*类型</p> 
<p>第3个中，p是一个指针变量，它存储的是一个函数的地址，这个函数返回值为int型，没有形参</p> 
<p>第4个中，p也是一个指针变量，存储的是一个数组的地址，数组有3个int型的元素。</p> 
<h3 id="3.%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E7%94%A8%E9%80%94%E2%80%94%E2%80%94%E8%BD%AC%E7%A7%BB%E8%A1%A8">3.函数指针数组用途——转移表</h3> 
<p>使用转移表比使用switch语句更加灵活，因为你可以动态地改变转移表的内容，而不需要修改调用转移表的代码。</p> 
<p>举例：分别用switch和转移表来实现一个计算器功能</p> 
<p>用switch：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
void menu()
{
	printf("====================================\n");
	printf("*********  1.add   2.sub  **********\n");
	printf("*********  3.mul   4.div  **********\n");
	printf("*********  0.exit  退出   **********\n");
	printf("====================================\n");
}
int add(int x, int y)
{
	return x + y;
}
int sub(int x, int y)
{
	return x - y;
}
int mul(int x, int y)
{
	return x * y;
}
int div(int x, int y)
{
	return x / y;
}
int main()
{
	int input = 0;
	int x = 0;
	int y = 0;
	int ret = 0;
	do
	{
		menu();
		printf("请选择：");
        scanf("%d", &amp;input);
        switch (input)
         {
         case 1:
             printf("输⼊操作数：");
             scanf("%d %d", &amp;x, &amp;y);
             ret = add(x, y);
             printf("ret = %d\n", ret);
             break;
         case 2:
             printf("输⼊操作数：");
             scanf("%d %d", &amp;x, &amp;y);
             ret = sub(x, y);
             printf("ret = %d\n", ret);
             break;
         case 3:
             printf("输⼊操作数：");
             scanf("%d %d", &amp;x, &amp;y);
             ret = mul(x, y);
             printf("ret = %d\n", ret);
             break;
         case 4:
             printf("输⼊操作数：");
             scanf("%d %d", &amp;x, &amp;y);
             ret = div(x, y);
             printf("ret = %d\n", ret);
             break;
         case 0:
             printf("退出程序\n");
             break;
         default:
             printf("选择错误\n");
             break;

	} while (input);
	return 0;
}</code></pre> 
<p>用函数指针数组（转移表）：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
void menu()
{
	printf("====================================\n");
	printf("*********  1.add   2.sub  **********\n");
	printf("*********  3.mul   4.div  **********\n");
	printf("*********  0.exit  退出   **********\n");
	printf("====================================\n");
}
int add(int x, int y)
{
	return x + y;
}
int sub(int x, int y)
{
	return x - y;
}
int mul(int x, int y)
{
	return x * y;
}
int div(int x, int y)
{
	return x / y;
}
int main()
{
	int input = 0;
	int x = 0;
	int y = 0;
	int ret = 0;
    //函数指针数组
	int (*arr[5])(int, int) = {0,add,sub,mul,div };
	do
	{
		menu();
		printf("请选择：");
		scanf("%d", &amp;input);
		if (input &gt;= 1 &amp;&amp; input &lt;= 4)
		{
			printf("请输入两个操作数");
			scanf("%d %d", &amp;x, &amp;y);
			ret = arr[input](x, y);
			printf("%d\n", ret);
		}
		else if (input == 0)
			printf("退出计算器\n");
		else
			printf("输出错误，请选择0-4\n");
	} while (input);
	return 0;
}</code></pre> 
<p> 用转移表代码量大大减少，能提高程序效率。</p> 
<hr> 
<p><span style="color:#956fe7;"><span style="background-color:#e7fafa;"> 🎉🎉🎉本文内容结束啦，希望各位大佬多多指教！</span></span></p> 
<p><span style="color:#956fe7;"><span style="background-color:#e7fafa;">🌹🌹感谢大家三连支持</span></span></p> 
<p><span style="color:#956fe7;"><span style="background-color:#e7fafa;">💕敬请期待下篇文章吧~</span></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c328a997b6255d4c25dca0f2b7cdd024/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">超级好用的C&#43;&#43;实用库之DNS解析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/31d418189308af79bfd07a3c6ff87332/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[JAVASE] 类和对象(四) - 多态</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>