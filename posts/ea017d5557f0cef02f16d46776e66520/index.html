<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【LeetCode例232】【C语言】用栈实现队列~动画超详细解读! - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/ea017d5557f0cef02f16d46776e66520/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【LeetCode例232】【C语言】用栈实现队列~动画超详细解读!">
  <meta property="og:description" content="0 技术需求 了解并实现栈和队列,熟悉栈和队列的基本逻辑
这里挂上链接&lt;队列&gt; &lt;栈&gt;
1 题目介绍 1.1 看题 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作**（push、pop、peek、empty）**：
实现 MyQueue 类：
void push(int x) 将元素 x 推到队列的末尾int pop() 从队列的开头移除并返回元素int peek() 返回队列开头的元素boolean empty() 如果队列为空，返回 true ；否则，返回 false 说明：
你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 这里挂上题目链接: 232.用栈实现队列
1.2 分析 这道题目其实就是让我们用栈的基本功能以及函数实现队列的基本功能及函数
myQueueCreate - 创建MyQueuemyQueuePush - MyQueue入队myQueuePop - MyQueue出队myQueuePeek - MyQueue取队头myQueueEmpty - MyQueue判空myQueueFree - myQueue释放 比较重要的一点就是我们使用C实现,所以我们需要先手搓一遍栈的函数才能写这道题(当然完全理解过栈和队列的话CV一下也不是不行(doge))
2 解题思路 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-16T04:05:20+08:00">
    <meta property="article:modified_time" content="2024-05-16T04:05:20+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【LeetCode例232】【C语言】用栈实现队列~动画超详细解读!</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="0__2"></a>0 技术需求</h4> 
<blockquote> 
 <p>了解并实现栈和队列,熟悉栈和队列的基本逻辑<br> 这里挂上链接<a href="https://blog.csdn.net/2302_79981653/article/details/138930380">&lt;队列&gt;</a> <a href="https://blog.csdn.net/2302_79981653/article/details/138925665">&lt;栈&gt;</a></p> 
</blockquote> 
<hr> 
<h4><a id="1__6"></a>1 题目介绍</h4> 
<h5><a id="11__7"></a>1.1 看题</h5> 
<blockquote> 
 <p>请你仅使用<strong>两个栈</strong>实现先入先出队列。队列应当支持一般队列支持的所有操作**（push、pop、peek、empty）**：</p> 
</blockquote> 
<blockquote> 
 <p>实现 MyQueue 类：</p> 
 <ul><li>void push(int x) 将元素 x 推到队列的末尾</li><li>int pop() 从队列的开头移除并返回元素</li><li>int peek() 返回队列开头的元素</li><li>boolean empty() 如果队列为空，返回 true ；否则，返回 false</li></ul> 
</blockquote> 
<blockquote> 
 <p>说明：</p> 
 <ul><li>你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>这里挂上题目链接: <a href="https://leetcode.cn/problems/implement-queue-using-stacks/description/" rel="nofollow">232.用栈实现队列</a></strong></p> 
</blockquote> 
<h5><a id="12__21"></a>1.2 分析</h5> 
<blockquote> 
 <p>这道题目其实就是让我们用栈的基本功能以及函数实现队列的基本功能及函数</p> 
 <ol><li><strong>myQueueCreate - 创建MyQueue</strong></li><li><strong>myQueuePush - MyQueue入队</strong></li><li><strong>myQueuePop - MyQueue出队</strong></li><li><strong>myQueuePeek - MyQueue取队头</strong></li><li><strong>myQueueEmpty - MyQueue判空</strong></li><li><strong>myQueueFree - myQueue释放</strong></li></ol> 
 <p>比较重要的一点就是我们使用C实现,所以我们需要先<strong>手搓一遍栈的函数才能写这道题</strong>(当然完全理解过栈和队列的话CV一下也不是不行(doge))</p> 
</blockquote> 
<h4><a id="2__31"></a>2 解题思路</h4> 
<h5><a id="21__32"></a>2.1 基本思想</h5> 
<blockquote> 
 <p>我们都知道,如果给一串数据,全部入栈之后再出栈,出栈的数据的顺序会反过来,而题目要求我们使用两个栈实现队列,我们就可以利用上进栈再出栈会逆置的特性<br> <img src="https://images2.imgbox.com/fa/f7/jJK2fVBJ_o.gif" alt="请添加图片描述"></p> 
</blockquote> 
<h5><a id="22_1_36"></a>2.2 实现思路1(非最优解)</h5> 
<h6><a id="221_MyQueue_37"></a>2.2.1 定义MyQueue</h6> 
<p>这里我们在 MyQueue 结构体里定义两个<strong>分别指向 栈st1 和 栈st2 的指针</strong></p> 
<ul><li>st1: 用于先存放入"队列"的数据</li><li>st2: 用于逆置st1的数据</li></ul> 
<pre><code>//定义MyQueue
typedef struct 
{
    ST* st1;
    ST* st2;
} MyQueue;
</code></pre> 
<h6><a id="222_myQueue_49"></a>2.2.2 myQueue的初始化</h6> 
<ul><li>题目要求在函数内部创建 MyQueue ,所以我们只能把内存开辟在堆区上才能把空间保留下来,如果放在栈区上,函数一结束 MyQueue 就被自动销毁了( st1 和 st2 都是指针,开辟完别忘了初始化,虽然这里用的 calloc 但还是自己再初始化一遍保险保险)<br> <img src="https://images2.imgbox.com/24/89/I86AqcCN_o.gif" alt="请添加图片描述"></li></ul> 
<pre><code>	MyQueue* pmq = (MyQueue*)calloc(1, sizeof(MyQueue));
	pmq-&gt;st1 = NULL;
	pmq-&gt;st2 = NULL;
</code></pre> 
<ul><li>既然 st1 和 st2 都是指针,所以也需要初始化一下这俩栈,直接调用现成的函数就行</li></ul> 
<pre><code>    pmq-&gt;st1 = (ST*)calloc(1, sizeof(ST));
    pmq-&gt;st2 = (ST*)calloc(1, sizeof(ST));

    STInit(pmq-&gt;st1);
    STInit(pmq-&gt;st2);
</code></pre> 
<ul><li>别忘了返回创建的MyQueue</li></ul> 
<pre><code>    return pmq;
</code></pre> 
<p>所以 myQueueCreate 函数就长这样</p> 
<pre><code>//创建MyQueue
MyQueue* myQueueCreate() 
{
    MyQueue* pmq = (MyQueue*)calloc(1, sizeof(MyQueue));
    pmq-&gt;st1 = NULL;
    pmq-&gt;st2 = NULL;

    pmq-&gt;st1 = (ST*)calloc(1, sizeof(ST));
    pmq-&gt;st2 = (ST*)calloc(1, sizeof(ST));

    STInit(pmq-&gt;st1);
    STInit(pmq-&gt;st2);

    return pmq;
}
</code></pre> 
<h6><a id="223_myQueue__88"></a>2.2.3 myQueue 的入"队列"</h6> 
<ul><li>我们说 st1 只负责接收入"队列",要出"队列"再通过 st2 逆置一下,所以我们直接把数据无脑放进 st1 就行<br> <img src="https://images2.imgbox.com/4b/a5/gPuLZnJA_o.gif" alt="请添加图片描述"></li></ul> 
<pre><code>//MyQueue入队
void myQueuePush(MyQueue* obj, int x) 
{
    STPush(obj-&gt;st1, x);
}
</code></pre> 
<h6><a id="224_myQueue__99"></a>2.2.4 myQueue 的出"队列"</h6> 
<ul><li>我们知道出队列需要把 st1 的所有数据再入一遍 栈st2 把整个数据逆序一遍才能"出队"一个数据,所以这里只要 st1 不是空,我们就不断往 st2 输出数据<br> <img src="https://images2.imgbox.com/98/6f/MCLFIdAZ_o.gif" alt="请添加图片描述"></li></ul> 
<pre><code>    while(!STEmpty(obj-&gt;st1))
    {
        STPush(obj-&gt;st2, STTop(obj-&gt;st1));
        STPop(obj-&gt;st1);
    }
</code></pre> 
<ul><li>因为题目要求要有返回值,此时 栈st2 的栈顶作为出"队列"的"队头",我们把"队头"的值暂时存到 ret 里,方便返回其值</li></ul> 
<pre><code>	int ret = STTop(obj-&gt;st2);
</code></pre> 
<ul><li>然后让 st2 出栈一个值,也就是栈顶那个值,即"出队"一次</li></ul> 
<pre><code>	STPop(obj-&gt;st2);
</code></pre> 
<ul><li>最后把 st2 剩余的值重新放回 st1 中暂存,并返回 ret</li></ul> 
<pre><code>    while(!STEmpty(obj-&gt;st2))
    {
        STPush(obj-&gt;st1, STTop(obj-&gt;st2));
        STPop(obj-&gt;st2);
    }
    return ret;
</code></pre> 
<p>那么这就是 MyQueue 的一次完整的"出队"了</p> 
<pre><code>//MyQueue出队
int myQueuePop(MyQueue* obj) 
{
    while(!STEmpty(obj-&gt;st1))
    {
        STPush(obj-&gt;st2, STTop(obj-&gt;st1));
        STPop(obj-&gt;st1);
    }
    int ret = STTop(obj-&gt;st2);
    STPop(obj-&gt;st2);
    while(!STEmpty(obj-&gt;st2))
    {
        STPush(obj-&gt;st1, STTop(obj-&gt;st2));
        STPop(obj-&gt;st2);
    }
    return ret;
}
</code></pre> 
<h6><a id="225_MyQueue_147"></a>2.2.5 MyQueue取队头</h6> 
<ul><li> <p>"取队头"的步骤其实和"出队"差不多,只是中间少了一步让 st2 栈顶出栈的内容,也就导致我只是取了 st2栈顶 的值而已, 取完值之后 st2 里的内容全都原封不动地还给 st1 了<br> <img src="https://images2.imgbox.com/f1/fd/RWuVjd8p_o.gif" alt="请添加图片描述"></p> </li><li> <p>一样的把 st1 的所有值入一遍 st2</p> </li></ul> 
<pre><code>    while(!STEmpty(obj-&gt;st1))
    {
        STPush(obj-&gt;st2, STTop(obj-&gt;st1));
        STPop(obj-&gt;st1);
    }
</code></pre> 
<ul><li>一样的把"队头"的值给临时变量 ret</li></ul> 
<pre><code>	int ret = STTop(obj-&gt;st2);
</code></pre> 
<ul><li>最后又是一样的把 st2 的所有值还给 st1 并且返回 ret</li></ul> 
<pre><code>    while(!STEmpty(obj-&gt;st2))
    {
        STPush(obj-&gt;st1, STTop(obj-&gt;st2));
        STPop(obj-&gt;st2);
    }
    return ret;
</code></pre> 
<p>以下是MyQueue取队头的完整代码</p> 
<pre><code>//MyQueue取队头
int myQueuePeek(MyQueue* obj) 
{
    while(!STEmpty(obj-&gt;st1))
    {
        STPush(obj-&gt;st2, STTop(obj-&gt;st1));
        STPop(obj-&gt;st1);
    }
    int ret = STTop(obj-&gt;st2);
    while(!STEmpty(obj-&gt;st2))
    {
        STPush(obj-&gt;st1, STTop(obj-&gt;st2));
        STPop(obj-&gt;st2);
    }
    return ret;
}
</code></pre> 
<h6><a id="226_MyQueue_191"></a>2.2.6 MyQueue判空</h6> 
<ul><li>我们所有的数据全部存在 st1 里,除了需要逆置的时候, st2 里头一般都是没有任何内容的,所以我们只需要单纯的给 st1 判空就行了</li></ul> 
<pre><code>//MyQueue判空
bool myQueueEmpty(MyQueue* obj) 
{
    return STEmpty(obj-&gt;st1);
}
</code></pre> 
<h6><a id="227_MyQueue_200"></a>2.2.7 MyQueue的销毁</h6> 
<ul><li>这里我们需先把 st1 和 st2 先销毁,再销毁 MyQueue(obj) 的空间,如果先销毁 MyQueue 的话,我们就找不到 st1 和 st2 了,也就销毁不了这俩栈了<br> <img src="https://images2.imgbox.com/fb/48/KNMNwIh8_o.gif" alt="请添加图片描述"></li></ul> 
<pre><code>//MyQueue释放
void myQueueFree(MyQueue* obj) 
{
    STDestroy(obj-&gt;st1);
    STDestroy(obj-&gt;st2);

    obj-&gt;st1 = NULL;
    obj-&gt;st2 = NULL;

    free(obj);
}
</code></pre> 
<h6><a id="228__216"></a>2.2.8 完整动画</h6> 
<p><img src="https://images2.imgbox.com/ae/49/9FDAktTj_o.gif" alt="请添加图片描述"></p> 
<h5><a id="23_2_219"></a>2.3 实现思路2(最优解)</h5> 
<blockquote> 
 <ul><li>区别于思路1,思路2不需要频繁让数据在 st1 和 st2 之间来回跳</li><li>一样的让 st1 专注"入队", st2 专注"出队",区别在于要等 st2 "出队"完才向其补充数据</li><li>其他的函数就如法炮制就行了,这里着重讲取"队头"和"出队"</li></ul> 
</blockquote> 
<h6><a id="231_MyQueue_223"></a>2.3.1 MyQueue取队头</h6> 
<ul><li>这里取完队头之后不把 st2 的数据挪回 st1 里,方便下次挪动或者删除<br> <img src="https://images2.imgbox.com/ca/f3/8EuIxZGQ_o.gif" alt="请添加图片描述"></li></ul> 
<pre><code>//MyQueue取队头
int myQueuePeek(MyQueue* obj) 
{
    if(STEmpty(obj-&gt;st2))//判断 st2 有没有数据,有数据就不动,没数据就把 st1 的数据挪过来
    {
        while(!STEmpty(obj-&gt;st1))
        {
            STPush(obj-&gt;st2, STTop(obj-&gt;st1));
            STPop(obj-&gt;st1);
        }
    }
    int ret = STTop(obj-&gt;st2);
    return ret;
}
</code></pre> 
<h6><a id="232_MyQueue_242"></a>2.3.2 MyQueue出队</h6> 
<ul><li>同样的,出队之后不把 st2 的数据挪回 st1 里</li></ul> 
<blockquote> 
 <ul><li>注意:这里动画先执行了三次出队,然后执行了一次入队,最后执行了三次出队</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/fe/d5/yNSI6lP5_o.gif" alt="请添加图片描述"></p> 
<pre><code>//MyQueue出队
int myQueuePop(MyQueue* obj) 
{
    if(STEmpty(obj-&gt;st2))//判断 st2 有没有数据,有数据就不动,没数据就把 st1 的数据挪过来
    {
        while(!STEmpty(obj-&gt;st1))
        {
            STPush(obj-&gt;st2, STTop(obj-&gt;st1));
            STPop(obj-&gt;st1);
        }
    }
    int ret = STTop(obj-&gt;st2);
    STPop(obj-&gt;st2);
    return ret;
}
</code></pre> 
<h6><a id="233__264"></a>2.3.3 完整动画</h6> 
<p><img src="https://images2.imgbox.com/9d/a0/M1YA8ixx_o.gif" alt="请添加图片描述"></p> 
<h4><a id="3__267"></a>3 完整实现代码</h4> 
<blockquote> 
 <p>因为这里是用C写这道题,所以代码前面一定得加上栈的所有内容哦</p> 
</blockquote> 
<h5><a id="31_1_269"></a>3.1 方法1</h5> 
<pre><code>//类型定义
typedef int DataType;

typedef struct stack
{
	DataType* pdata;
	int top;
	int capa;
}ST;


//函数定义

//栈的扩容
void CheckCapa(ST* pst);

//获取栈顶数据
DataType STTop(ST* pst);

//栈的判空
bool STEmpty(ST* pst);

//查看数据量
int STSize(ST* pst);

//栈的初始化
void STInit(ST* pst);

//栈的删除
void STDestroy(ST* pst);

//压栈
void STPush(ST* pst, DataType data);

//出栈
void STPop(ST* pst);

//函数定义

//栈的扩容
void CheckCapa(ST* pst)
{
	assert(pst);
	if (pst-&gt;top + 1 == pst-&gt;capa)
	{
		DataType* tmp = (DataType*)realloc(pst-&gt;pdata, 2 * pst-&gt;capa * sizeof(DataType));
		if (tmp == NULL)
		{
			perror("CheckCapa::realloc");
			exit(1);
		}
		else
		{
			pst-&gt;pdata = tmp;
		}
		pst-&gt;capa = 2 * pst-&gt;capa;
	}
}

//获取栈顶数据
DataType STTop(ST* pst)
{
	assert(pst);
	return pst-&gt;pdata[pst-&gt;top];
}

//栈的判空
bool STEmpty(ST* pst)
{
	assert(pst);
	return pst-&gt;top + 1 == 0;
}

//查看数据量
int STSize(ST* pst)
{
	assert(pst);
	return pst-&gt;top + 1;
}

//栈的初始化
void STInit(ST* pst)
{
	assert(pst);

	pst-&gt;pdata = (DataType*)calloc(4, sizeof(DataType));
	if (pst-&gt;pdata == NULL)
	{
		perror("STInit::calloc");
		exit(1);
	}
	pst-&gt;top = -1;
	pst-&gt;capa = 4;
}

//栈的删除
void STDestroy(ST* pst)
{
	free(pst-&gt;pdata);
	pst-&gt;pdata = NULL;
	pst-&gt;capa = 0;
	pst-&gt;top = -1;
}

//压栈
void STPush(ST* pst, DataType data)
{
	CheckCapa(pst);
	(pst-&gt;top)++;
	pst-&gt;pdata[pst-&gt;top] = data;
}

//出栈
void STPop(ST* pst)
{
	if (STEmpty(pst))
	{
		return;
	}
	else
	{
		(pst-&gt;top)--;
	}
}

//----------------------------------------------------------------------------------------------------

//定义MyQueue
typedef struct 
{
    ST* st1;
    ST* st2;
} MyQueue;


//创建MyQueue
MyQueue* myQueueCreate() 
{
    MyQueue* pmq = (MyQueue*)calloc(1, sizeof(MyQueue));
    pmq-&gt;st1 = NULL;
    pmq-&gt;st2 = NULL;

    pmq-&gt;st1 = (ST*)calloc(1, sizeof(ST));
    pmq-&gt;st2 = (ST*)calloc(1, sizeof(ST));

    STInit(pmq-&gt;st1);
    STInit(pmq-&gt;st2);

    return pmq;
}

//MyQueue入队
void myQueuePush(MyQueue* obj, int x) 
{
    STPush(obj-&gt;st1, x);
}

//MyQueue出队
int myQueuePop(MyQueue* obj) 
{
    while(!STEmpty(obj-&gt;st1))
    {
        STPush(obj-&gt;st2, STTop(obj-&gt;st1));
        STPop(obj-&gt;st1);
    }
    int ret = STTop(obj-&gt;st2);
    STPop(obj-&gt;st2);
    while(!STEmpty(obj-&gt;st2))
    {
        STPush(obj-&gt;st1, STTop(obj-&gt;st2));
        STPop(obj-&gt;st2);
    }
    return ret;
}

//MyQueue取队头
int myQueuePeek(MyQueue* obj) 
{
    while(!STEmpty(obj-&gt;st1))
    {
        STPush(obj-&gt;st2, STTop(obj-&gt;st1));
        STPop(obj-&gt;st1);
    }
    int ret = STTop(obj-&gt;st2);
    while(!STEmpty(obj-&gt;st2))
    {
        STPush(obj-&gt;st1, STTop(obj-&gt;st2));
        STPop(obj-&gt;st2);
    }
    return ret;
}

//MyQueue判空
bool myQueueEmpty(MyQueue* obj) 
{
    return STEmpty(obj-&gt;st1);
}

//MyQueue释放
void myQueueFree(MyQueue* obj) 
{
    STDestroy(obj-&gt;st1);
    STDestroy(obj-&gt;st2);

    obj-&gt;st1 = NULL;
    obj-&gt;st2 = NULL;

    free(obj);
}
</code></pre> 
<h5><a id="31_2_481"></a>3.1 方法2</h5> 
<pre><code>typedef int DataType;

typedef struct stack
{
	DataType* pdata;
	int top;
	int capa;
}ST;


//函数定义

//栈的扩容
void CheckCapa(ST* pst);

//获取栈顶数据
DataType STTop(ST* pst);

//栈的判空
bool STEmpty(ST* pst);

//查看数据量
int STSize(ST* pst);

//栈的初始化
void STInit(ST* pst);

//栈的删除
void STDestroy(ST* pst);

//压栈
void STPush(ST* pst, DataType data);

//出栈
void STPop(ST* pst);

//函数定义

//栈的扩容
void CheckCapa(ST* pst)
{
	assert(pst);
	if (pst-&gt;top + 1 == pst-&gt;capa)
	{
		DataType* tmp = (DataType*)realloc(pst-&gt;pdata, 2 * pst-&gt;capa * sizeof(DataType));
		if (tmp == NULL)
		{
			perror("CheckCapa::realloc");
			exit(1);
		}
		else
		{
			pst-&gt;pdata = tmp;
		}
		pst-&gt;capa = 2 * pst-&gt;capa;
	}
}

//获取栈顶数据
DataType STTop(ST* pst)
{
	assert(pst);
	return pst-&gt;pdata[pst-&gt;top];
}

//栈的判空
bool STEmpty(ST* pst)
{
	assert(pst);
	return pst-&gt;top + 1 == 0;
}

//查看数据量
int STSize(ST* pst)
{
	assert(pst);
	return pst-&gt;top + 1;
}

//栈的初始化
void STInit(ST* pst)
{
	assert(pst);

	pst-&gt;pdata = (DataType*)calloc(4, sizeof(DataType));
	if (pst-&gt;pdata == NULL)
	{
		perror("STInit::calloc");
		exit(1);
	}
	pst-&gt;top = -1;
	pst-&gt;capa = 4;
}

//栈的删除
void STDestroy(ST* pst)
{
	free(pst-&gt;pdata);
	pst-&gt;pdata = NULL;
	pst-&gt;capa = 0;
	pst-&gt;top = -1;
}

//压栈
void STPush(ST* pst, DataType data)
{
	CheckCapa(pst);
	(pst-&gt;top)++;
	pst-&gt;pdata[pst-&gt;top] = data;
}

//出栈
void STPop(ST* pst)
{
	if (STEmpty(pst))
	{
		return;
	}
	else
	{
		(pst-&gt;top)--;
	}
}

//----------------------------------------------------------------------------------------------------

//定义MyQueue
typedef struct 
{
    ST* st1;
    ST* st2;
} MyQueue;


//创建MyQueue
MyQueue* myQueueCreate() 
{
    MyQueue* pmq = (MyQueue*)calloc(1, sizeof(MyQueue));
    pmq-&gt;st1 = NULL;
    pmq-&gt;st2 = NULL;

    pmq-&gt;st1 = (ST*)calloc(1, sizeof(ST));
    pmq-&gt;st2 = (ST*)calloc(1, sizeof(ST));

    STInit(pmq-&gt;st1);
    STInit(pmq-&gt;st2);

    return pmq;
}

//MyQueue入队
void myQueuePush(MyQueue* obj, int x) 
{
    STPush(obj-&gt;st1, x);
}

//MyQueue出队
int myQueuePop(MyQueue* obj) 
{
    if(STEmpty(obj-&gt;st2))
    {
        while(!STEmpty(obj-&gt;st1))
        {
            STPush(obj-&gt;st2, STTop(obj-&gt;st1));
            STPop(obj-&gt;st1);
        }
    }
    int ret = STTop(obj-&gt;st2);
    STPop(obj-&gt;st2);
    return ret;
}

//MyQueue取队头
int myQueuePeek(MyQueue* obj) 
{
    if(STEmpty(obj-&gt;st2))
    {
        while(!STEmpty(obj-&gt;st1))
        {
            STPush(obj-&gt;st2, STTop(obj-&gt;st1));
            STPop(obj-&gt;st1);
        }
    }
    int ret = STTop(obj-&gt;st2);
    return ret;
}

//MyQueue判空
bool myQueueEmpty(MyQueue* obj) 
{
    return (STEmpty(obj-&gt;st1) &amp;&amp; STEmpty(obj-&gt;st2));
}

//MyQueue释放
void myQueueFree(MyQueue* obj) 
{
    STDestroy(obj-&gt;st1);
    STDestroy(obj-&gt;st2);

    obj-&gt;st1 = NULL;
    obj-&gt;st2 = NULL;

    free(obj);
}
</code></pre> 
<hr> 
<blockquote> 
 <p><strong>佬!都看到这了,如果觉得有帮助的话一定要点赞啊佬 &gt;v&lt; !!!</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>放个卡密在这,感谢各位能看到这儿啦!</strong><br> <img src="https://images2.imgbox.com/68/da/5HjQMuyi_o.jpg" alt="请添加图片描述"></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/847e9caf048bf695d1039851d7f1ec44/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">50个kafka常见面试题及答案，撸完阿里P7见(1)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/06e5d1e5c457f27c5583695852db67ec/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Navicat和MySQL的安装</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>