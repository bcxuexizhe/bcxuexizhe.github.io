<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java多态（如果想知道Java中有关多多态的知识点，那么只看这一篇就足够了！） - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/89030e3909ff25cba90e1a394c689d92/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="Java多态（如果想知道Java中有关多多态的知识点，那么只看这一篇就足够了！）">
  <meta property="og:description" content="前言：多态是面向对象编程中的一个重要概念，它允许我们在不同的对象上调用相同的方法，但根据对象的不同，可以产生不同的行为。在 Java 中，多态性是一个强大的特性，它有助于代码的可扩展性和可维护性。
✨✨✨这里是秋刀鱼不做梦的BLOG
✨✨✨想要了解更多内容可以访问我的主页秋刀鱼不做梦-CSDN博客
先让我们看一下本篇文章的大致内容：
目录
1.向上转型&#43;向下转型
（1）向上转型
（2）向下转型
补充：instanceof
2.方法重写
3.静态绑定&#43;动态绑定
（1）静态绑定
（2）动态绑定
4.多态
为了更好地理解多态，我们需要掌握以下核心概念：（先进行了解即可）
方法重写（Override）： 子类可以提供对父类中已有方法的新实现。在子类中重新定义一个与父类中方法名、参数列表和返回类型相同的方法，从而覆盖（重写）了父类中的方法。
向上转型（Upcasting）： 可以将子类的对象引用赋给父类类型的变量，这被称为向上转型。这样做可以让我们在父类引用上调用子类的方法，从而实现多态性。
动态绑定（Dynamic Binding）： 运行时多态性的关键概念之一。它意味着方法的调用是在程序运行时根据对象的实际类型来确定的，而不是在编译时。
instanceof 运算符： 用于检查一个对象是否是特定类的实例。它可以帮助我们在运行时确定对象的类型，从而进行适当的操作。 为了理解学习多态，让我们先学习一下这些核心知识，接下来我们将一一学习它们。
1.向上转型&#43;向下转型 先来让我们认识一下什么是向上转型和向下转型。
（1）向上转型 向上转型（Upcasting）： 将子类的对象引用赋给父类类型的变量，这被称为向上转型。其作用为可以让我们在父类引用上调用子类的方法，从而实现多态性。
了解完了什么是向上转型之后，让我们看一个向上转型的例子来进一步理解：
//父类Animal class Animal { void makeSound() { System.out.println(&#34;The animal makes a sound&#34;); } } //子类Dog class Dog extends Animal { @Override void makeSound() { System.out.println(&#34;The dog barks&#34;); } } public class Test { public static void main(String[] args) { // 创建一个Dog对象 Dog myDog = new Dog(); // 向上转型：将Dog对象赋值给Animal引用 Animal myAnimal = myDog; // 这就是向上转型 } } 在这个例子中，我们有一个Animal类和一个Dog类，其中Dog是Animal的子类。在main方法中，我们创建了一个Dog对象，并将其赋值给一个Animal类型的引用myAnimal，这就是向上转型的一个例子。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-21T15:20:11+08:00">
    <meta property="article:modified_time" content="2024-05-21T15:20:11+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java多态（如果想知道Java中有关多多态的知识点，那么只看这一篇就足够了！）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        <strong>前言：多态是面向对象编程中的一个重要概念，它允许我们在不同的对象上调用相同的方法，但根据对象的不同，可以产生不同的行为。在 Java 中，多态性是一个强大的特性，它有助于代码的可扩展性和可维护性。</strong></p> 
<hr> 
<blockquote> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/44/14/e9Iisshj_o.jpg"></p> 
 <p><strong>✨✨✨<span style="color:#ff9900;">这里是秋刀鱼不做梦的BLOG</span></strong></p> 
 <p><span style="color:#ff9900;"><strong>✨✨✨想要了解更多内容可以访问我的主页</strong></span><a href="https://blog.csdn.net/2302_80198073?type=blog" title="秋刀鱼不做梦-CSDN博客">秋刀鱼不做梦-CSDN博客</a></p> 
</blockquote> 
<p><span style="color:#a2e043;"><strong>先让我们看一下本篇文章的大致内容：</strong></span></p> 
<p style="text-align:center;"><span style="color:#a2e043;"><strong><img alt="" src="https://images2.imgbox.com/01/28/YDTb1OH3_o.png"></strong></span></p> 
<p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%2B%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B-toc" style="margin-left:0px;"><strong><a href="#1.%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%2B%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B" rel="nofollow">1.向上转型+向下转型</a></strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%881%EF%BC%89%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%881%EF%BC%89%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B" rel="nofollow">        （1）向上转型</a></strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%882%EF%BC%89%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%882%EF%BC%89%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B" rel="nofollow">        （2）向下转型</a></strong></p> 
<p id="%E8%A1%A5%E5%85%85%EF%BC%9Ainstanceof-toc" style="margin-left:40px;"><strong><a href="#%E8%A1%A5%E5%85%85%EF%BC%9Ainstanceof" rel="nofollow">补充：instanceof</a></strong></p> 
<p id="2.%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99-toc" style="margin-left:0px;"><strong><a href="#2.%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99" rel="nofollow">2.方法重写</a></strong></p> 
<p id="3.%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%2B%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A-toc" style="margin-left:0px;"><strong><a href="#3.%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%2B%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A" rel="nofollow">3.静态绑定+动态绑定</a></strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%881%EF%BC%89%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%881%EF%BC%89%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A" rel="nofollow">        （1）静态绑定</a></strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%882%EF%BC%89%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%882%EF%BC%89%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A" rel="nofollow">        （2）动态绑定</a></strong></p> 
<p id="4.%E5%A4%9A%E6%80%81-toc" style="margin-left:0px;"><strong><a href="#4.%E5%A4%9A%E6%80%81" rel="nofollow">4.多态</a></strong></p> 
<hr id="hr-toc"> 
<p></p> 
<p><span style="color:#fe2c24;"><strong>为了更好地理解多态，我们需要掌握以下核心概念：（先进行了解即可）</strong></span></p> 
<blockquote> 
 <ol><li><strong>方法重写（Override）： 子类可以提供对父类中已有方法的新实现。在子类中重新定义一个与父类中方法名、参数列表和返回类型相同的方法，从而覆盖（重写）了父类中的方法。<br> 向上转型（Upcasting）： 可以将子类的对象引用赋给父类类型的变量，这被称为向上转型。这样做可以让我们在父类引用上调用子类的方法，从而实现多态性。<br> 动态绑定（Dynamic Binding）： 运行时多态性的关键概念之一。它意味着方法的调用是在程序运行时根据对象的实际类型来确定的，而不是在编译时。<br> instanceof 运算符： 用于检查一个对象是否是特定类的实例。它可以帮助我们在运行时确定对象的类型，从而进行适当的操作。</strong></li></ol> 
</blockquote> 
<p><span style="color:#a2e043;"><strong>为了理解学习多态，让我们先学习一下这些核心知识，接下来我们将一一学习它们。</strong></span></p> 
<p></p> 
<h2 id="1.%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%2B%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span style="color:#956fe7;">1.向上转型+向下转型</span></h2> 
<p>      <strong>  先来让我们认识一下什么是向上转型和向下转型。</strong></p> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%881%EF%BC%89%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B">        <span style="color:#4da8ee;"><strong>（1）向上转型</strong></span></h3> 
<blockquote> 
 <p>    <span style="color:#ff9900;">    <strong>向上转型（Upcasting）：</strong> 将子类的对象引用赋给父类类型的变量，这被称为向上转型。其作用为可以让我们在父类引用上调用子类的方法，从而实现多态性。</span></p> 
</blockquote> 
<p><strong>了解完了什么是向上转型之后，让我们看一个向上转型的例子来进一步理解：</strong></p> 
<pre><code class="language-java">//父类Animal
class Animal {
    void makeSound() {
        System.out.println("The animal makes a sound");
    }
}
//子类Dog
class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("The dog barks");
    }
}

public class Test {
    public static void main(String[] args) {
        // 创建一个Dog对象
        Dog myDog = new Dog();

        // 向上转型：将Dog对象赋值给Animal引用
        Animal myAnimal = myDog; // 这就是向上转型
    }
}</code></pre> 
<p><span style="color:#38d8f0;"><strong>        </strong></span><span style="color:#38d8f0;"><strong>在这个例子中，我们有一个Animal类和一个<code>Dog</code>类，其中<code>Dog</code>是<code>Animal</code>的子类。在<code>main</code>方法中，我们创建了一个<code>Dog</code>对象，并将其赋值给一个<code>Animal</code>类型的引用<code>myAnimal，</code>这就是向上转型的一个例子。</strong></span></p> 
<p><strong>了解了什么是向上转型之后，在让我们看一下什么是向下转型。</strong></p> 
<p><strong><span style="color:#ffd900;">        </span></strong></p> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%882%EF%BC%89%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><strong><span style="color:#ffd900;">        </span><span style="color:#4da8ee;">（2）向下转型</span></strong></h3> 
<blockquote> 
 <p>        <span style="color:#ff9900;"> <strong>向下转型（downcasting）：</strong>将一个子类对象经过向上转型之后当成父类方法使用，再无法调用子类的方法，但有时候可能需要调用子类特有的方法，此时，将父类引用再还原为子类对象即可，即向下转换。</span></p> 
</blockquote> 
<p><strong>了解了什么是向下转型，现在让我们使用一个向下转型的例子来进一步理解（还是继续使用上面的案例）：</strong></p> 
<pre><code class="language-java">//父类Animal
class Animal {
    void makeSound() {
        System.out.println("The animal makes a sound");
    }
}
//子类Dog
class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("The dog barks");
    }
}

public class Test {
    public static void main(String[] args) {
        // 向上转型  
        Animal myAnimal = new Dog();

        // 检查myAnimal是否真的是Dog的一个实例  
        if (myAnimal instanceof Dog) {
            // 向下转型：将Animal引用转换为Dog引用  
            Dog myDog = (Dog) myAnimal; // 这就是向下转型  
        } else {
            //如果不是Dog类
            System.out.println("myAnimal is not a Dog");
        }
    }
}
</code></pre> 
<p><span style="color:#38d8f0;"><strong>        </strong></span><span style="color:#38d8f0;"><strong>在这个例子中，我们首先创建了一个<code>Dog</code>对象，并将其赋值给了一个<code>Animal</code>类型的引用<code>myAnimal</code>。然后，我们使用<code>instanceof</code>操作符来检查<code>myAnimal</code>是否真的是<code>Dog</code>的一个实例。如果是，我们就可以安全地进行向下转型，将<code>myAnimal</code>转换为<code>Dog</code>类型的引用myDog,如果不是，则返回 “myAnimal is not a Dog”</strong></span></p> 
<p></p> 
<h3 id="%E8%A1%A5%E5%85%85%EF%BC%9Ainstanceof"><span style="color:#4da8ee;"><strong>补充：instanceof</strong></span></h3> 
<p><span style="color:#38d8f0;"><strong>        </strong></span><strong>在这个案例中我们看到出现了一个关键词instanceof，那么instanceof的作用是什么呢？</strong></p> 
<p><strong>目前我们可以理解instanceof的作用为：</strong></p> 
<blockquote> 
 <p><strong><span style="color:#a2e043;">        </span><span style="color:#a2e043;">instanceof是一个运算符，其用于测试对象是否是一个类的实例。</span></strong></p> 
</blockquote> 
<p><span style="color:#ff9900;"><strong>instanceof使用的语法形式为：</strong></span></p> 
<pre><code class="language-java">if (object instanceof Class) {
    // object 是 Class 类型或其子类的实例
}</code></pre> 
<p><strong>这样我们就大致的了解了什么是向上转型和向下转型了。</strong></p> 
<p></p> 
<p></p> 
<h2 id="2.%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span style="color:#956fe7;"><strong>2.方法重写</strong></span></h2> 
<p><strong>        方法重写是Java多态中的核心步骤之一，那么什么是方法重写呢？</strong></p> 
<blockquote> 
 <p><strong><span style="color:#ff9900;">        </span><span style="color:#ff9900;">方法重写（Override）： 即子类可以提供对父类中已有方法的新实现。在子类中重新定义一个与父类中方法名、参数列表和返回类型相同的方法，从而覆盖（重写）了父类中的方法。</span></strong></p> 
</blockquote> 
<p>        嗯嗯嗯......看是大致看懂了，但是还是不是太理解，接下来我们使用实例来帮助你进一步理解什么是方法重写（继续使用上面的案例）：</p> 
<pre><code class="language-java">//父类Animal
class Animal {
    void makeSound(String name) {
        System.out.println("The animal makes a sound");
    }
}
//子类Dog
class Dog extends Animal {
    
    //对父类的方法重写
    @Override
    void makeSound(String name) {
        System.out.println("The dog barks");
    }
}</code></pre> 
<p><span style="color:#38d8f0;"><strong>        </strong></span><span style="color:#38d8f0;"><strong>我们可以看到子类Dog继承了其父类Animal，并且也创建了一个同父类中的makeSound（）方法相同的方法，只不过内部的实现有所区别，这就是方法的重写。</strong></span></p> 
<p></p> 
<p><span style="color:#fe2c24;"><strong>        </strong></span><span style="color:#fe2c24;"><strong>注意：</strong></span><span style="color:#fe2c24;"><strong> </strong></span><span style="color:#fe2c24;"><strong>子类在重写父类的方法时，一般必须与父类方法原型一致： 即返回值类型，方法名，参数列表要完全一致（如图）：</strong></span></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/80/96/bmOusfRu_o.png"></p> 
<p></p> 
<p><strong>当然，对于Java中的方法重写，还有许多需要注意的事项：</strong></p> 
<blockquote> 
 <p><span style="color:#ff9900;"><strong>1. 被重写的方法返回值类型可以不同，但是必须是具有父子关系;</strong></span></p> 
 <p></p> 
 <p><span style="color:#ff9900;"><strong>2. 子类的访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类方法被public修饰，则子类中重写该方法就不能声明为 protected；</strong></span></p> 
 <p><br><span style="color:#ff9900;"><strong>3. 父类被static、private修饰的方法、构造方法都不能被重写；</strong></span></p> 
 <p><br><span style="color:#ff9900;"><strong>4. 重写的方法, 可以使用 @Override 注解来显式指定. 有了这个注解能帮我们进行一些合法性校验. 例如不小心将方法名字拼写错了 (比如写成 aet), 那么此时编译器就会发现父类中没有 aet 方法, 就会编译报错, 提示无法构成重写.；</strong></span></p> 
</blockquote> 
<p><strong>这样我们就大致的了解了什么是方法重写了。</strong></p> 
<p></p> 
<p></p> 
<h2 id="3.%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%2B%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span style="color:#956fe7;"><strong>3.</strong>静态绑定+动态绑定</span></h2> 
<p>       <strong> 讲到多态时，我们都会提及静态绑定和动态绑定，那么什么是静态绑定、动态绑定呢？</strong></p> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%881%EF%BC%89%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A"><span style="color:#4da8ee;">        </span><span style="color:#4da8ee;">（1）静态绑定</span></h3> 
<blockquote> 
 <p><span style="color:#ff9900;"><strong>        </strong></span><span style="color:#ff9900;"><strong>静态绑定：也称为前期绑定(早绑定)，即在编译时，根据用户所传递实参类型就确定了具体调用那个方法。</strong></span></p> 
</blockquote> 
<p><span style="color:#a2e043;"><strong>其中最常见的例子就是方法的重载（例如）：</strong></span></p> 
<pre><code class="language-java">// 第一个重载方法，没有参数
    public void display() {
        System.out.println("No parameters passed.");
    }

    // 第三个重载方法，接受一个字符串参数
    public void display(String message) {
        System.out.println("A string parameter: " + message);
    }

    // 第三个重载方法，接受两个整数参数
    public void display(int num1, int num2) {
        System.out.println("Two integer parameters: " + num1 + " and " + num2);
    }</code></pre> 
<p><span style="color:#38d8f0;"><strong>在调用这些方法的时候，我们可以在编译的时候就知道调用的是哪一个方法（因为它们的参数不同），这就是静态绑定。</strong></span></p> 
<p></p> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%882%EF%BC%89%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span style="color:#4da8ee;"><strong>        </strong></span><span style="color:#4da8ee;"><strong>（2）动态绑定</strong></span></h3> 
<blockquote> 
 <p><span style="color:#38d8f0;"><strong>     </strong></span><span style="color:#ff9900;"><strong>   </strong><strong>动态绑定：也称为后期绑定(晚绑定)，即在编译时，不能确定方法的行为，需要等到程序运行时，才能够确定具体调用那个类的方法。</strong></span></p> 
</blockquote> 
<p><span style="color:#a2e043;"><strong>其中最常见的例子就是多态中的方法的调用，这里先不进行讲解，下文合适时会提及。</strong></span></p> 
<p><strong>这样我们就大致的了解了什么是静态绑定和动态绑定了。</strong></p> 
<p></p> 
<p></p> 
<h2 id="4.%E5%A4%9A%E6%80%81"><span style="color:#956fe7;">4.多态</span></h2> 
<p><strong>        铺垫了这么多的知识，终于到了本文最重要，最核心的知识了——什么是Java中的多态？</strong></p> 
<p><strong>先让我们了解一下多态的定义：</strong></p> 
<blockquote> 
 <p>       <span style="color:#ff9900;"><strong> 多态（Polymorphism）是面向对象编程的核心概念之一。它源于希腊语，意为“多种形态”。多态性使得我们可以使用通用的接口来表示不同的对象，并且能够在运行时确定对象的具体类型，从而调用相应的方法。</strong></span></p> 
</blockquote> 
<p></p> 
<p><strong>鹅鹅鹅......没看懂，那么我们接下来使用更加平易近人的方式来描述一下什么是多态：</strong></p> 
<blockquote> 
 <p><span style="color:#ff9900;"><strong>        </strong></span><span style="color:#ff9900;"><strong>通俗来说，多态就是多种形态，具体点就是去完成某个行为，当不同的对象去完成时会产生出不同的状态。</strong></span></p> 
</blockquote> 
<p><span style="color:#a2e043;"><strong>为了更好的使你了解什么是多态，我们使用一个案例进行讲解（每一步都有详解）：</strong></span></p> 
<pre><code class="language-java">// 定义一个基类（父类）
class Animal {
    void makeSound() {
        System.out.println("The animal makes a sound");
    }
}
// 定义一个派生类（子类），继承自Animal类
class Dog extends Animal {
    // 重写父类的方法
    @Override
    void makeSound() {
        System.out.println("The dog barks");
    }
}
// 另一个派生类（子类），也继承自Animal类
class Cat extends Animal {
    // 重写父类的方法
    @Override
    void makeSound() {
        System.out.println("The cat meows");
    }
}

// 主类，用于演示多态
public class Test {
    public static void main(String[] args) {
        //创建两个对象，一个为Dog类，一个为Cat类
        Animal animalDog = new Dog();
        Animal animalCat = new Cat();

        //分别调用makeSound方法
        animalDog.makeSound();
        animalCat.makeSound();
    }
}</code></pre> 
<p><strong>当你运行这个Test方法时，你会看到控制台输出了以下结果：</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/11/94/Re7dZzlK_o.png"></p> 
<p><span style="color:#38d8f0;"><strong>        </strong></span><span style="color:#38d8f0;"><strong>通过这个案例，我们就知道了Java中多态是如何工作的，我们尽管都是调用了父类（Animal）的makeSound方法，但是最终调用的为其子类中对其重写的方法，这就是所谓的Java中的多态。</strong></span></p> 
<p></p> 
<p><strong>不知道你是否还记得上文中提及的动态绑定，这也是一个动态绑定的例子：</strong></p> 
<blockquote> 
 <p><span style="color:#ff9900;"><strong>        </strong></span><span style="color:#ff9900;"><strong>动态绑定：也称为后期绑定(晚绑定)，即在编译时，不能确定方法的行为，需要等到程序运行时，才能够确定具体调用那个类的方法。</strong></span></p> 
</blockquote> 
<p><strong>        我们在编译的时候，都是调用的其父类的makeSound方法，</strong><span style="color:#4da8ee;"><strong>这就是在编译时，不能确定方法的行为</strong></span><strong>，但是当我们运行后，其就会调用特定对象中的方法，，</strong><span style="color:#4da8ee;"><strong>即需要等到程序运行时，才能够确定具体调用那个类的方法。</strong></span></p> 
<p></p> 
<p><strong>        ——了解了Java中的多态之后，那么为什么要使用多态呢？</strong></p> 
<p><span style="color:#fe2c24;"><strong>多态的优点：</strong></span></p> 
<blockquote> 
 <ol><li><strong>代码重用：</strong> 可以使用通用的接口来操作不同类型的对象，从而减少了代码的重复编写。</li><li><strong>灵活性：</strong> 可以轻松地扩展程序，添加新的子类而无需修改现有的代码。</li><li><strong>可维护性：</strong> 通过多态，我们可以将代码组织得更加清晰和易于维护。</li><li><strong>简化接口：</strong> 多态性允许我们使用通用接口，而不必关心对象的具体类型。</li><li><strong>提高代码的可读性：</strong> 代码更易于理解，因为它更符合现实世界的模型。</li></ol> 
</blockquote> 
<p><span style="color:#ffd900;"><strong>当然多态在日常生活中也有许多的实际用处，只不过我们需要将其转换为代码的形式而已，例如：</strong></span></p> 
<blockquote> 
 <ol><li><strong>图形绘制：</strong> 图形绘制程序可以使用多态性来处理不同类型的图形对象，如圆形、矩形和三角形。</li><li><strong>汽车制造：</strong> 汽车制造公司可以使用多态性来处理不同型号和品牌的汽车，从而简化生产流程。</li><li><strong>动态插件：</strong> 软件应用程序可以使用多态性来支持动态加载和卸载插件，从而增加灵活性。</li><li><strong>电子商务：</strong> 电子商务平台可以使用多态性来处理不同类型的商品和付款方式。</li><li><strong>游戏开发</strong><strong>：</strong> 游戏开发中的角色和道具可以使用多态性来实现不同的行为。</li></ol> 
</blockquote> 
<p><strong>这样我们就了解了什么是java中的多态了。</strong></p> 
<p></p> 
<hr> 
<p style="text-align:center;"><span style="color:#38d8f0;"><strong>以上就是本篇文章的所有内容了~~~</strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/96d58439de32fcb95c812ba4c0ad1f06/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">寻找峰值 ---- 二分查找</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6085c3faccab5d98e5fe2a528b826cea/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">24-LINUX-UDP网络连接</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>