<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;技能进阶指南——多态语法剖析 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/e74e3d173d3884cd6b12578a20976089/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="C&#43;&#43;技能进阶指南——多态语法剖析">
  <meta property="og:description" content="前言：多态是面向对象的三大特性之一。顾名思义， 多态就是多种状态。 那么是什么的多种状态呢？ 这里的可能有很多。比如我们去买火车票， 有普通票， 学生票； 又比如我们去旅游， 有儿童票， 有成人票等等。 这些都是多态的例子。 具体转化为我们的编程思想就是：让不同类型的对象去完成相同的事， 这就是多态。
本篇内容主要讲述多态， 多为语法方面的知识点。 适合已经学完继承的友友们观看。
目录
一、多态的相关概念
1.1虚函数
1.2虚函数的重写
1.3虚函数重写的两个例外
1.4override 和 final 的使用
二、重载、重写、隐藏（重定义）的区别
三、如何构成多态
四、抽象类
五、普通继承和接口继承
六、静态绑定和动态绑定
具体什么是多态在前言中已经提到， 正文部分不做赘述。
一、多态的相关概念 1.1虚函数 被virtual关键字修饰的成员函数叫做虚函数。 例如：
//A位基类 class A { public: virtual void func() //定义一个虚函数 { cout &lt;&lt; &#34;Afunc()&#34; &lt;&lt; endl; } }; 需要注意的是， 对于构造函数和析构函数来说。 析构函数可以是虚函数， 但是构造函数不可以是虚函数。 具体原因如下：（建议看完整篇文章和总结虚函数表机制——c&#43;&#43;多态底层原理-CSDN博客​​​​​​ 之后再来看下面这段解释）：
首先：通过之前的学习， 我们知道了， 虚函数的地址是存在虚函数表里面的。 想要调用对应的虚函数， 我们需要先去虚函数表中寻找对应虚函数的地址。 但是虚函数表是在构造函数的初始化列表初始化的。如果构造函数是虚函数， 那么调用构造函数的时候就找不到。 所以构造函数没办法是虚函数。
1.2虚函数的重写 虚函数的重写就是： 在派生类当中， 有一个和基类中某一个虚函数函数头的虚函数（函数头就是：函数的返回值， 函数名， 函数的参数列表）。 这个时候就会构成虚函数的重写, 即 子类重写了基类的虚函数。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-22T21:08:16+08:00">
    <meta property="article:modified_time" content="2024-05-22T21:08:16+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;技能进阶指南——多态语法剖析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>        <span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">前言</span></strong></span>：多态是面向对象的三大特性之一。顾名思义， 多态就是多种状态。 那么是什么的多种状态呢？ 这里的可能有很多。比如我们去买火车票， 有普通票， 学生票； 又比如我们去旅游， 有儿童票， 有成人票等等。 这些都是多态的例子。 具体转化为我们的编程思想就是：<span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">让不同类型的对象去完成相同的事， 这就是多态</span></strong></span>。</p> 
 <p>       <span style="color:#1a439c;"> <strong><span style="background-color:#f9eda6;">本篇内容主要讲述多态， 多为语法方面的知识点。 适合已经学完继承的友友们观看。</span></strong></span></p> 
</blockquote> 
<p>        </p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%A4%9A%E6%80%81%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%A4%9A%E6%80%81%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5" rel="nofollow">一、多态的相关概念</a></p> 
<p id="1.1%E8%99%9A%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#1.1%E8%99%9A%E5%87%BD%E6%95%B0" rel="nofollow">1.1虚函数</a></p> 
<p id="1.2%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E5%86%99-toc" style="margin-left:40px;"><a href="#1.2%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E5%86%99" rel="nofollow">1.2虚函数的重写</a></p> 
<p id="1.3%E8%99%9A%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%BE%8B%E5%A4%96-toc" style="margin-left:40px;"><a href="#1.3%E8%99%9A%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%BE%8B%E5%A4%96" rel="nofollow">1.3虚函数重写的两个例外</a></p> 
<p id="%C2%A01.4override%20%E5%92%8C%20final%20%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#%C2%A01.4override%20%E5%92%8C%20final%20%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow"> 1.4override 和 final 的使用</a></p> 
<p id="%E4%BA%8C%E3%80%81%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%E3%80%81%E9%9A%90%E8%97%8F%EF%BC%88%E9%87%8D%E5%AE%9A%E4%B9%89%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%E3%80%81%E9%9A%90%E8%97%8F%EF%BC%88%E9%87%8D%E5%AE%9A%E4%B9%89%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">二、重载、重写、隐藏（重定义）的区别</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%A6%82%E4%BD%95%E6%9E%84%E6%88%90%E5%A4%9A%E6%80%81-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%A6%82%E4%BD%95%E6%9E%84%E6%88%90%E5%A4%9A%E6%80%81" rel="nofollow">三、如何构成多态</a></p> 
<p id="%E5%9B%9B%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB" rel="nofollow">四、抽象类</a></p> 
<p id="%E4%BA%94%E3%80%81%E6%99%AE%E9%80%9A%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E6%99%AE%E9%80%9A%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF" rel="nofollow">五、普通继承和接口继承</a></p> 
<p id="%E5%85%AD%E3%80%81%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A" rel="nofollow">六、静态绑定和动态绑定</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p>具体什么是多态在前言中已经提到， 正文部分不做赘述。</p> 
<h2 id="%E4%B8%80%E3%80%81%E5%A4%9A%E6%80%81%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">一、多态的相关概念</h2> 
<h3 id="1.1%E8%99%9A%E5%87%BD%E6%95%B0">1.1虚函数</h3> 
<p>        被virtual关键字修饰的成员函数叫做虚函数。 例如：</p> 
<pre><code class="language-cpp">//A位基类
class A 
{
public:

	virtual void func()    //定义一个虚函数
	{
		cout &lt;&lt; "Afunc()" &lt;&lt; endl;
	}
};
</code></pre> 
<p>         需要注意的是， 对于构造函数和析构函数来说。 析构函数可以是虚函数， 但是构造函数不可以是虚函数。 </p> 
<blockquote> 
 <p><strong><span style="color:#be191c;">具体原因如下：（建议看完整篇文章和<a href="https://blog.csdn.net/strive_mianyang/article/details/136892186?spm=1001.2014.3001.5501" title="总结虚函数表机制——c++多态底层原理-CSDN博客​​​​​​">总结虚函数表机制——c++多态底层原理-CSDN博客​​​​​​</a> 之后再来看下面这段解释）：</span></strong></p> 
 <p><strong><span style="color:#be191c;">       </span><span style="color:#1c7892;"> 首先：通过之前的学习， 我们知道了， 虚函数的地址是存在虚函数表里面的。 想要调用对应的虚函数， 我们需要先去虚函数表中寻找对应虚函数的地址。 但是虚函数表是在构造函数的初始化列表初始化的。如果构造函数是虚函数， 那么调用构造函数的时候就找不到。 所以构造函数没办法是虚函数。</span></strong></p> 
</blockquote> 
<h3 id="1.2%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E5%86%99">1.2虚函数的重写</h3> 
<p>        虚函数的重写就是： 在派生类当中， 有一个和基类中某一个虚函数函数头的虚函数（函数头就是：<span style="color:#be191c;"><strong>函数的返回值， 函数名， 函数的参数列表</strong></span>）。 这个时候就会构成虚函数的重写, 即 <span style="color:#be191c;"><strong>子类重写了基类的虚函数</strong></span>。</p> 
<pre><code class="language-cpp">//A位基类
class A 
{
public:

	virtual void func() 
	{
		cout &lt;&lt; "Afunc()" &lt;&lt; endl;
	}
};

//B类继承A类
class B : public A
{
public:
	
	//重写A类的func函数
	virtual void func()  //注意， 这里的virtual可以不写， 因为编译器默认这里是加了virtual的
	{
		cout &lt;&lt; "Bfunc()" &lt;&lt; endl;
	}
};
</code></pre> 
<p><span style="color:#1c7892;"><strong>        需要注意的是， 上图中派生类的func可以不加virtual， 因为基类的func是虚函数， 编译器会默认派生类中和他函数头相同的函数也是虚函数</strong></span>。 </p> 
<h3 id="1.3%E8%99%9A%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%BE%8B%E5%A4%96">1.3虚函数重写的两个例外</h3> 
<p>        协变:派生类在重写基类的虚函数的时候， 与基类虚函数返回值类型不同。即基类虚函数返回基类对象的指针或者引用， 派生类虚函数返回派生类对象的指针或者引用的时候， 成为协变。</p> 
<pre><code class="language-cpp">
//A位基类
class A
{
public:

	virtual A* func()
	{
		cout &lt;&lt; "Afunc()" &lt;&lt; endl;
	}
};

//B类继承A类
class B : public A
{
public:

	//重写A类的func函数
	virtual B* func()
	{
		cout &lt;&lt; "Bfunc()" &lt;&lt; endl;
	}
};

//C类继承A类
class C : public A
{
	virtual C* func()
	{
		cout &lt;&lt; "Cfunc" &lt;&lt; endl;
	}
};
</code></pre> 
<p>    </p> 
<p>        析构函数的重写: 基类析构函数如果加了virtual， 那么说明基类的析构函数为虚函数。 这个时候如果派生类的析构函数也就变成了虚函数。 那么成不成为虚函数对于析构函数来说有什么不同呢？</p> 
<p>        <span style="color:#be191c;"><strong>首先我们需要知道的是， 在一个普通的类之中， 编译器其实将析构函数统一处理成为了destructor。</strong></span></p> 
<p><span style="color:#be191c;"><strong>        </strong></span>然后， 对于一个派生类来说， 如果它的析构函数不是虚函数。 当我们使用父类的指针构成多态时， 只会析构派生类的一部分:</p> 
<pre><code class="language-cpp">//A位基类
class A
{
public:

	virtual A* func()
	{
		cout &lt;&lt; "Afunc()" &lt;&lt; endl;
	}

    //其他动态内存分配的空间
    //int* ...
    //double* ...
};

//B类继承A类
class B : public A
{
public:

	//重写A类的func函数
	virtual B* func()
	{
		cout &lt;&lt; "Bfunc()" &lt;&lt; endl;
	}

    //其他动态内存分配的空间
    //int* ...
    //double* ...
};


void test_func(A* p)
{
	p-&gt;func();
}


int main() 
{
	C c;

	A* p = nullptr;
	p = &amp;c;

	delete p;
	return 0;
}
</code></pre> 
<p>         如上图， 假如delete p， 那么就只能释放属于C类自己的那一部分。那么属于A类的那一部分将得不到释放。 </p> 
<p>        但是， 如果我们对A类的析构函数使用虚函数。 那么派生类的析构函数也变成了虚函数， 这个时候如果再形成多态。delete p就能将A类和C类都释放掉。</p> 
<pre><code class="language-cpp">
//A位基类
class A
{
public:

	virtual A* func()
	{
		cout &lt;&lt; "Afunc()" &lt;&lt; endl;
	}

	virtual ~A() 
	{}
};

//B类继承A类
class B : public A
{
public:
	//重写A类的func函数
	virtual B* func()
	{
		cout &lt;&lt; "Bfunc()" &lt;&lt; endl;
	}

	virtual ~B()
	{}
};
</code></pre> 
<h3 id="%C2%A01.4override%20%E5%92%8C%20final%20%E7%9A%84%E4%BD%BF%E7%94%A8"> 1.4override 和 final 的使用</h3> 
<p>先谈override， override是用来检验某个虚函数是否构成了重写。如果没有构成重写， 那么编译器就会报错。</p> 
<p>        如下为构成重写:</p> 
<pre><code class="language-cpp">//A位基类
class A
{
public:

	virtual void func()
	{
		cout &lt;&lt; "Afunc()" &lt;&lt; endl;
	}

};
//B类继承A类
class B : public A
{
public:
	//重写A类的func函数
	virtual void func() override
	{
		cout &lt;&lt; "Bfunc()" &lt;&lt; endl;
	}

};
</code></pre> 
<p><img alt="" height="373" src="https://images2.imgbox.com/b9/cd/KTZUvRD8_o.png" width="567"></p> 
<p></p> 
<p>如下为没有构成重写：</p> 
<pre><code class="language-cpp">
//A位基类
class A
{
public:

	void func()
	{
		cout &lt;&lt; "Afunc()" &lt;&lt; endl;
	}
};
//B类继承A类
class B : public A
{
public:
	//重写A类的func函数
	virtual void func() override
	{
		cout &lt;&lt; "Bfunc()" &lt;&lt; endl;
	}

};
</code></pre> 
<p><img alt="" height="765" src="https://images2.imgbox.com/74/a6/EFT3Ux32_o.png" width="1200"></p> 
<p></p> 
<h2 id="%E4%BA%8C%E3%80%81%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%E3%80%81%E9%9A%90%E8%97%8F%EF%BC%88%E9%87%8D%E5%AE%9A%E4%B9%89%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB">二、重载、重写、隐藏（重定义）的区别</h2> 
<p></p> 
<blockquote> 
 <ul><li><span style="color:#be191c;"><strong><span style="background-color:#ffd900;">重载：</span></strong></span> <span style="color:#be191c;"><strong>函数处于相同作用域内， 并且函数的函数名相同， 参数不同。</strong></span></li><li><span style="color:#be191c;"><strong><span style="background-color:#ffd900;">重写：</span></strong></span> <span style="color:#be191c;"><strong>函数分别处于基类和派生类中，并且都是虚函数， 并且有相同的函数头</strong></span></li><li><span style="color:#be191c;"><strong><span style="background-color:#ffd900;">隐藏：</span></strong></span> <span style="color:#be191c;"><strong>继承体系中函数分别处在基类和派生类的作用与之中， 不是虚函数，并且都具有相同的函数头</strong></span></li></ul> 
</blockquote> 
<h2 id="%E4%B8%89%E3%80%81%E5%A6%82%E4%BD%95%E6%9E%84%E6%88%90%E5%A4%9A%E6%80%81">三、如何构成多态</h2> 
<p>        要形成多态有两个条件：</p> 
<blockquote> 
 <ul><li><span style="color:#be191c;"><strong>一、虚函数的重写。</strong></span></li><li><span style="color:#be191c;"><strong>二、父类的指针指向子类,或者父类的引用引用子类对象。</strong></span></li></ul> 
</blockquote> 
<p>        如下为一个多态的实例：</p> 
<blockquote> 
 <pre><code class="language-cpp">//A位基类
class A 
{
public:

	virtual void func() 
	{
		cout &lt;&lt; "Afunc()" &lt;&lt; endl;
	}
};

//B类继承A类
class B : public A
{
public:
	
	virtual void func() 
	{
		cout &lt;&lt; "Bfunc()" &lt;&lt; endl;
	}
};

//C类继承A类
class C : public A
{
	virtual void func() 
	{
		cout &lt;&lt; "Cfunc" &lt;&lt; endl;
	}
};

int main() 
{
	C c;
	B b;
	A* p = nullptr;
	p = &amp;c;
	p-&gt;func();
	p = &amp;b;
	p-&gt;func();
	return 0;
}</code></pre> 
 <p>         在这串代码中， B类和C类都是A类的派生类。 他们都有对A类中的虚函数func进行重写， 满足条件一。 </p> 
 <p>        然后基类的指针p先是指向了C类的对象。 又指向了B类的对象。 构成了父类的指针指向子类， 满足条件二。</p> 
 <p>        所以， 这就是一个多态。</p> 
 <p><img alt="" height="497" src="https://images2.imgbox.com/0f/18/DK1asaWG_o.png" width="992"></p> 
</blockquote> 
<p>其实， 多态的应用场景多为这样：</p> 
<pre><code class="language-cpp">
//A位基类
class A 
{
public:

	virtual void func() 
	{
		cout &lt;&lt; "Afunc()" &lt;&lt; endl;
	}
};

//B类继承A类
class B : public A
{
public:
	
	virtual void func() 
	{
		cout &lt;&lt; "Bfunc()" &lt;&lt; endl;
	}
};

//C类继承A类
class C : public A
{
	virtual void func() 
	{
		cout &lt;&lt; "Cfunc" &lt;&lt; endl;
	}
};


void test_func(A* p) 
{
	p-&gt;func();
}


int main() 
{
	C c;
	B b;
	test_func(&amp;b);
	test_func(&amp;c);
	return 0;
}</code></pre> 
<p>        这样， 通过传送不同类型的对象给test_func函数， 就能构成多态。</p> 
<h2 id="%E5%9B%9B%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB">四、抽象类</h2> 
<p>        如果一个虚函数后面加上 =0， 那么这个虚函数就是纯虚函数， 并且包含这个纯虚函数的类叫做抽象类。</p> 
<p>        抽象类不能实例化对象。</p> 
<pre><code class="language-cpp">
//A位基类
class A
{
public:

	virtual void func() = 0;
};



int main() 
{
	A a;

	return 0;
}
</code></pre> 
<p><img alt="" height="387" src="https://images2.imgbox.com/13/df/4xgbkCRL_o.png" width="617"></p> 
<p></p> 
<p>但是A的派生类如果重写了纯虚函数， 那么就可以这个派生类就可以实例化处对象。</p> 
<p><img alt="" height="416" src="https://images2.imgbox.com/0b/9d/mGAbciXF_o.png" width="584"></p> 
<p>但是如果A的派生类没有重写纯虚函数， 那么这个派生类同样不能实例化处对象。</p> 
<pre><code class="language-cpp">
//A位基类
class A
{
public:
	virtual void func() = 0;
};

//B类继承A类
class B : public A
{
public:
	//重写A类的func函数
};

int main() 
{
	B b;
	return 0;
}
</code></pre> 
<p><img alt="" height="376" src="https://images2.imgbox.com/59/ec/R7G6KilA_o.png" width="578"></p> 
<h2 id="%E4%BA%94%E3%80%81%E6%99%AE%E9%80%9A%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF">五、普通继承和接口继承</h2> 
<p>        普通继承：在继承体系中， 派生类继承了基类的函数， 能够直接使用的是普通继承， 这类继承继承的是基类函数的实现。 </p> 
<p>        接口继承：如果继承了基类的虚函数， 并且重写实现了多态。 那么就是一种接口继承， 多态的体系是一种接口的继承， 具体的函数实现是由派生类自己实现的。</p> 
<p></p> 
<h2 id="%E5%85%AD%E3%80%81%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A">六、静态绑定和动态绑定</h2> 
<p>        静态绑定： 静态绑定又被成为前期绑定,  当程序在编译的时候确定的要调用的函数， 确定了程序要执行的行为， 这个过程成为静态多态。 比如我们使用的函数重载就是静态的多态。</p> 
<p>        动态绑定： 动态绑定又被成为后期绑定， 当程序在编译之后也就是运行期间根据不同的对象调用不同的函数。 这个过程叫做动态多态， 也就是多态。</p> 
<p>------------------------------------------------------</p> 
<p>ps： 本篇内容没有讲解多态的原理， 因为多态的原理其实就是虚函数表。 而虚函数表的详细讲解博主之前已经写过一篇： <a href="https://blog.csdn.net/strive_mianyang/article/details/136892186?spm=1001.2014.3001.5501" title="总结虚函数表机制——c++多态底层原理-CSDN博客">总结虚函数表机制——c++多态底层原理-CSDN博客</a> 。</p> 
<p>        在这篇文章中， 博主用自己的理解讲解的虚函数表的机制与实现。 写的不甚严谨， 但是里面的结论却是博主通过调试一步一步验证的来的。感兴趣的友友们可以看一下。</p> 
<p>后续补带有虚函数的类的内存大小的计算（暂时有点模糊， 先不写， 而且最近考试比较多。可能要等暑假才能补上这一板块）。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/252dcf7d0afd594903ceb871c0d4abcd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">人工智能（二）-Transformer模型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ae0ca785eee10d0ce48a42ba58221ad0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【FFmpeg】Windows 10 平台 FFmpeg 开发环境搭建 ① ( 安装 Visual Studio 2015 | JavaScript_ProjectSystem 安装包丢失或损坏 )</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>