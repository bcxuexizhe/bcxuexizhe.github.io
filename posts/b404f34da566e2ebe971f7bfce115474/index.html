<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>常微分方程算法之阿当姆斯法（Adams法） - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/b404f34da566e2ebe971f7bfce115474/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="常微分方程算法之阿当姆斯法（Adams法）">
  <meta property="og:description" content="目录
一、方法背景
二、算法原理及推导过程
1、辛普森（Simpson）方法
2、汉明（Hamming）方法
3、隐式四阶阿当姆斯（Adams）方法
4、预估-校正阿当姆斯法
三、算例实现 一、方法背景 欧拉法、梯形法、改进欧拉法以及龙格-库塔法都属于单步法，即计算的时候只用到上一步的值。如果可以将已经计算出来的结果值用于的计算，就能够增加计算精度。我们尝试使用前面已经计算出来的k个值来提高求解的精度，即线性多步法的思路。通常线性k步法的公式为：
式中且，和为待定系数。如果，就是单步法：
，其中
若，得到，即为欧拉法；
若，得到，即为隐式欧拉法；
若，得到，即为梯形法。
同时，如果时是显格式；如果时是隐格式。
龙格-库塔法的原理是利用函数在某点处的函数值的线性组合来计算导数，而线性多步法的原理则是利用已经算出的函数值的线性组合来计算导数。
二、算法原理及推导过程 我们尝试推导k=3时的隐式线性多步法数值计算公式（即），阶数为四阶：
对于上式，其截断误差为：
假设，则，在处对分别使用泰勒公式，将得到的展开式带入到截断误差计算公式中可得：
为了得到四阶格式，需要满足：
上式有无穷多解，只要满足上式条件的系数、所组成的隐式线性多步格式都是四阶的。
其中，满足和系数条件的个别情况下的著名方法有：
1、辛普森（Simpson）方法 取，可得：
2、汉明（Hamming）方法 取，可得：
3、隐式四阶阿当姆斯（Adams）方法 取，可得：
在线性多步法中，形如：
的k步法称为阿当姆斯法。当时为阿当姆斯显格式，称为Adams-Bashforth公式；当时为阿当姆斯隐格式，称为Adams-Monlton公式。
4、预估-校正阿当姆斯法 与改进欧拉法类似，可以通过显示法预测初值，然后利用隐式法进行迭代。阿当姆斯法也可以使用预估-校正的方式进行计算：
显式阿当姆斯法为：
隐式阿当姆斯法为：
于是，预估-校正阿当姆斯法为：
①预估: ②校正： 三、算例实现 求解初值问题：
步长h=0.2。已知精确解为：
代码如下：
#include &lt;cmath&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; int main(int argc, char* argv[]) { int i,N; double a,b,h,y0,k1,k2,k3,k4,err,y_predict; double *x,*y; double exact(double x); double f(double x, double y); a=0.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-05T00:05:47+08:00">
    <meta property="article:modified_time" content="2024-04-05T00:05:47+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">常微分方程算法之阿当姆斯法（Adams法）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E6%96%B9%E6%B3%95%E8%83%8C%E6%99%AF-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%96%B9%E6%B3%95%E8%83%8C%E6%99%AF" rel="nofollow">一、方法背景</a></p> 
<p id="%E4%BA%8C%E3%80%81%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E6%8E%A8%E5%AF%BC%E8%BF%87%E7%A8%8B-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E6%8E%A8%E5%AF%BC%E8%BF%87%E7%A8%8B" rel="nofollow">二、算法原理及推导过程</a></p> 
<p id="1%E3%80%81%E8%BE%9B%E6%99%AE%E6%A3%AE%EF%BC%88Simpson%EF%BC%89%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E8%BE%9B%E6%99%AE%E6%A3%AE%EF%BC%88Simpson%EF%BC%89%E6%96%B9%E6%B3%95" rel="nofollow">1、辛普森（Simpson）方法</a></p> 
<p id="2%E3%80%81%E6%B1%89%E6%98%8E%EF%BC%88Hamming%EF%BC%89%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E6%B1%89%E6%98%8E%EF%BC%88Hamming%EF%BC%89%E6%96%B9%E6%B3%95" rel="nofollow">2、汉明（Hamming）方法</a></p> 
<p id="3%E3%80%81%E9%9A%90%E5%BC%8F%E5%9B%9B%E9%98%B6%E9%98%BF%E5%BD%93%E5%A7%86%E6%96%AF%EF%BC%88Adams%EF%BC%89%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E9%9A%90%E5%BC%8F%E5%9B%9B%E9%98%B6%E9%98%BF%E5%BD%93%E5%A7%86%E6%96%AF%EF%BC%88Adams%EF%BC%89%E6%96%B9%E6%B3%95" rel="nofollow">3、隐式四阶阿当姆斯（Adams）方法</a></p> 
<p id="4%E3%80%81%E9%A2%84%E4%BC%B0-%E6%A0%A1%E6%AD%A3%E9%98%BF%E5%BD%93%E5%A7%86%E6%96%AF%E6%B3%95-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E9%A2%84%E4%BC%B0-%E6%A0%A1%E6%AD%A3%E9%98%BF%E5%BD%93%E5%A7%86%E6%96%AF%E6%B3%95" rel="nofollow">4、预估-校正阿当姆斯法</a></p> 
<p id="%E4%B8%89%E3%80%81%E7%AE%97%E4%BE%8B%E5%AE%9E%E7%8E%B0%C2%A0%20%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E7%AE%97%E4%BE%8B%E5%AE%9E%E7%8E%B0%C2%A0%20%C2%A0" rel="nofollow">三、算例实现   </a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E6%96%B9%E6%B3%95%E8%83%8C%E6%99%AF">一、方法背景</h2> 
<p style="text-align:justify;">       <a class="link-info" href="https://blog.csdn.net/L_peanut/article/details/137268437?spm=1001.2014.3001.5501" title="欧拉法">欧拉法</a>、<a class="link-info" href="https://blog.csdn.net/L_peanut/article/details/137273933?spm=1001.2014.3001.5501" title="梯形法">梯形法</a>、<a class="link-info" href="https://blog.csdn.net/L_peanut/article/details/137326300?spm=1001.2014.3001.5501" title="改进欧拉法">改进欧拉法</a>以及<a class="link-info" href="https://blog.csdn.net/L_peanut/article/details/137336203?spm=1001.2014.3001.5501" title="龙格-库塔法">龙格-库塔法</a>都属于单步法，即计算<img alt="y_{i+1}" class="mathcode" src="https://images2.imgbox.com/3a/3a/HVe4yjsW_o.png">的时候只用到上一步<img alt="y_{i}" class="mathcode" src="https://images2.imgbox.com/8f/e8/OfubkzcV_o.png">的值。如果可以将已经计算出来的结果值<img alt="y_{0},y_{1},y_{2},\cdot \cdot \cdot ,y_{i}" class="mathcode" src="https://images2.imgbox.com/eb/ee/76Gpvmg8_o.png">用于<img alt="y_{i+1}" class="mathcode" src="https://images2.imgbox.com/9a/76/PdaIHlY5_o.png">的计算，就能够增加计算精度。我们尝试使用前面已经计算出来的k个值<img alt="y_{i-k+1},y_{i-k+2},\cdot \cdot \cdot ,y_{i-1},y_{i}" class="mathcode" src="https://images2.imgbox.com/16/6a/F5GD3KWS_o.png">来提高求解<img alt="y_{i+1}" class="mathcode" src="https://images2.imgbox.com/5f/47/ydvo0X7P_o.png">的精度，即线性多步法的思路。通常线性k步法的公式为：</p> 
<p style="text-align:center;"><img alt="y_{i+1}=\sum_{j=0}^{k-1}\alpha_{j}y_{i-j}+h\sum_{j=-1}^{k-1}\beta_{j}f_{i-j} \space\space\space\space (1) \\ \space\space\space\space = \alpha_{0}y_{i}+\alpha_{1}y_{i-1}+\cdot \cdot \cdot +\alpha_{k-1}y_{i-k+1}+h(\beta_{-1}f_{i+1}+\beta_{0}f_{i}+\beta_{1}f_{i-1}+\cdot \cdot \cdot +\beta_{k-1}f_{i-k+1})" class="mathcode" src="https://images2.imgbox.com/48/1b/rlBUjsLy_o.png"></p> 
<p style="text-align:justify;">式中<img alt="f_{j}=f(x_{j},y_{i})" class="mathcode" src="https://images2.imgbox.com/46/20/EzSTJh1w_o.png">且<img alt="x_{j}=x_{0}+jh,i=k-1,k,k+1,\cdot \cdot \cdot ,n-1" class="mathcode" src="https://images2.imgbox.com/61/5e/gNbgNwNH_o.png">，<img alt="\alpha" class="mathcode" src="https://images2.imgbox.com/f2/b5/lVWxutRp_o.png">和<img alt="\beta" class="mathcode" src="https://images2.imgbox.com/b1/8d/lxCWzZvv_o.png">为待定系数。如果<img alt="k=1" class="mathcode" src="https://images2.imgbox.com/39/3a/Gxzxm2SM_o.png">，就是单步法：</p> 
<p style="text-align:center;"><img alt="y_{i+1}=y_{i}+h(\beta_{-1}f_{i+1}+\beta_{0}f_{i})" class="mathcode" src="https://images2.imgbox.com/88/9d/gFrFdTW5_o.png">，其中<img alt="\beta_{-1}+\beta_{0}=1" class="mathcode" src="https://images2.imgbox.com/fd/4b/YOxTlC6v_o.png"></p> 
<p style="text-align:justify;">       若<img alt="\beta_{-1}=0,\beta_{0}=1" class="mathcode" src="https://images2.imgbox.com/4b/43/FdNXgvq9_o.png">，得到<img alt="y_{i+1}=y_{i}+hf_{i}=y_{i}+hf(x_{i},y_{i})" class="mathcode" src="https://images2.imgbox.com/3a/80/cOE3A2xO_o.png">，即为<span style="background-color:#ff9900;">欧拉法</span>；</p> 
<p style="text-align:justify;">       若<img alt="\beta_{-1}=1,\beta_{0}=0" class="mathcode" src="https://images2.imgbox.com/80/26/HfBVtdgQ_o.png">，得到<img alt="y_{i+1}=y_{i}+hf_{i+1}=y_{i}+hf(x_{i+1},y_{i+1})" class="mathcode" src="https://images2.imgbox.com/83/1d/cM0mCW8V_o.png">，即为<span style="background-color:#ff9900;">隐式欧拉法</span>；</p> 
<p style="text-align:justify;">       若<img alt="\beta_{-1}=\beta_{0}=\frac{1}{2}" class="mathcode" src="https://images2.imgbox.com/38/5b/CaPaCLzP_o.png">，得到<img alt="y_{i+1}=y_{i}+\frac{1}{2}h(f_{i+1}+f_{i})\\ \space\space\space\space=y_{i}+\frac{1}{2}h(f(x_{i+1},y_{i+1})+f(x_{i},y_{i}))" class="mathcode" src="https://images2.imgbox.com/fc/c9/3sxfurJA_o.png">，即为<span style="background-color:#ff9900;">梯形法</span>。</p> 
<p style="text-align:justify;">       同时，如果<img alt="\beta_{-1}=0" class="mathcode" src="https://images2.imgbox.com/d6/dc/OTceAVKd_o.png">时是显格式；如果<img alt="\beta_{-1}\neq 0" class="mathcode" src="https://images2.imgbox.com/13/3c/4MOyDcXV_o.png">时是隐格式。</p> 
<p style="text-align:justify;">       龙格-库塔法的原理是利用函数在某点处的函数值的线性组合来计算导数，而线性多步法的原理则是利用已经算出的函数值的线性组合来计算导数。</p> 
<h2 id="%E4%BA%8C%E3%80%81%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E6%8E%A8%E5%AF%BC%E8%BF%87%E7%A8%8B">二、算法原理及推导过程</h2> 
<p>       我们尝试推导k=3时的隐式线性多步法数值计算公式（即<img alt="\beta_{-1}\neq 0" class="mathcode" src="https://images2.imgbox.com/9b/b1/SB11NyJa_o.png">），阶数为四阶：</p> 
<p style="text-align:center;"><img alt="y_{i+1}=\alpha_{0}y_{i}+\alpha_{1}y_{i-1}+\alpha_{2}y_{i-2}+h(\beta_{-1}f_{i+1}+\beta_{0}f_{i}+\beta_{1}f_{i-1}+\beta_{2}f_{i-2})" class="mathcode" src="https://images2.imgbox.com/6d/63/Eyzi5Pwp_o.png"></p> 
<p>       对于上式，其截断误差为：</p> 
<p style="text-align:center;"><img alt="LTE=y(x_{i+1})-[\alpha_{0}y(x_{i})+\alpha_{1}y(x_{i-1})+\alpha_{2}y(x_{i-2})+h(\beta_{-1}f(x_{i+1},y(x_{i+1}))+\beta_{0}f(x_{i},y(x_{i}))+\beta_{1}f(x_{i-1},y(x_{i-1}))+\beta_{2}f(x_{i-2},y(x_{i-2})))]" class="mathcode" src="https://images2.imgbox.com/d0/da/bi3aF58a_o.png"></p> 
<p style="text-align:justify;">假设<img alt="y_{i}=y(x_{i})" class="mathcode" src="https://images2.imgbox.com/1b/f2/nuFfvQA0_o.png">，则<img alt="f_{i}=f(x_{i},y_{i})=f(x_{i},y(x_{i}))=y^{'}(x_{i})" class="mathcode" src="https://images2.imgbox.com/ec/84/a3FfCTlV_o.png">，在<img alt="x_{i}" class="mathcode" src="https://images2.imgbox.com/e5/ca/vXJV8jKz_o.png">处对<img alt="y(x_{i+1}),y(x_{i-1})" class="mathcode" src="https://images2.imgbox.com/e3/03/iOOAplQg_o.png">分别使用泰勒公式，将得到的展开式带入到截断误差计算公式中可得：</p> 
<p style="text-align:center;"><img alt="LTE=(1-\alpha_{0}-\alpha_{1}-\alpha_{2})y(x_{i})+\\(1+\alpha_{1}+2\alpha_{2}-\beta_{-1}-\beta_{0}-\beta_{1}-\beta_{2})hy^{'}(x_{i})+\\ (\frac{1}{2}-\frac{1}{2}\alpha_{1}-2\alpha_{2}-\beta_{-1}+\beta_{1}+2\beta_{2})h^{2}y^{''}(x_{i})+\\(\frac{1}{6}+\frac{1}{6}\alpha_{1}+\frac{4}{3}\alpha_{2}-\frac{1}{2}\beta_{-1}-\frac{1}{2}\beta_{1}-2\beta_{2})h^{3}y^{'''}(x_{i})+\\ (\frac{1}{24}-\frac{1}{24}\alpha_{1}-\frac{2}{3}\alpha_{2}-\frac{1}{6}\beta_{-1}+\frac{1}{6}\beta_{1}+\frac{4}{3}\beta_{2})h^{4}y^{(4)}(x_{i})+\\ (\frac{1}{120}+\frac{1}{120}\alpha_{1}+\frac{4}{15}\alpha_{2}-\frac{1}{24}\beta_{-1}-\frac{1}{24}\beta_{1}-\frac{2}{3}\beta_{2})h^{5}y^{5}(x_{i})+O(h^{6})" class="mathcode" src="https://images2.imgbox.com/95/fb/WnNQ9pdf_o.png"></p> 
<p style="text-align:justify;">       为了得到四阶格式，需要满足：</p> 
<p style="text-align:center;"><img alt="\left\{\begin{matrix} \alpha_{0}+\alpha_{1}+\alpha_{2}=1,\\ \alpha_{1}+2\alpha_{2}-\beta_{-1}-\beta_{0}-\beta_{1}-\beta_{2}=-1,\\ \frac{1}{2}\alpha_{1}+2\alpha_{2}+\beta_{-1}-\beta_{1}-2\beta_{2}=\frac{1}{2},\\ \frac{1}{6}\alpha_{1}+\frac{4}{3}\alpha_{2}-\frac{1}{2}\beta_{-1}-\frac{1}{2}\beta_{1}-2\beta_{2}=-\frac{1}{6},\\ \frac{1}{24}\alpha_{1}+\frac{2}{3}\alpha_{2}+\frac{1}{6}\beta_{-1}-\frac{1}{6}\beta_{1}-\frac{4}{3}\beta_{2}=\frac{1}{24},\\ \frac{1}{240}\alpha_{1}+\frac{4}{15}\alpha_{2}-\frac{1}{24}\beta_{-1}-\frac{1}{24}\beta_{1}-\frac{2}{3}\beta_{2}\neq -\frac{1}{120},\\ \beta_{-1}\neq0 \end{matrix}\right." class="mathcode" src="https://images2.imgbox.com/74/13/pRWxk3VI_o.png"></p> 
<p style="text-align:justify;">上式有无穷多解，只要满足上式条件的系数<img alt="\alpha" class="mathcode" src="https://images2.imgbox.com/53/b1/gFNlT4S5_o.png">、<img alt="\beta" class="mathcode" src="https://images2.imgbox.com/2b/f3/5u245tD3_o.png">所组成的隐式线性多步格式都是四阶的。</p> 
<p style="text-align:justify;">        其中，满足<img alt="\alpha" class="mathcode" src="https://images2.imgbox.com/e6/7f/ZlMU8AHb_o.png">和<img alt="\beta" class="mathcode" src="https://images2.imgbox.com/a8/ea/qE8ZLBvM_o.png">系数条件的个别情况下的著名方法有：</p> 
<h3 id="1%E3%80%81%E8%BE%9B%E6%99%AE%E6%A3%AE%EF%BC%88Simpson%EF%BC%89%E6%96%B9%E6%B3%95">1、辛普森（Simpson）方法</h3> 
<p>        取<img alt="\alpha_{0}=0,\alpha_{1}=1,\alpha_{2}=0,\beta_{-1}=\frac{1}{3},\beta_{0}=\frac{4}{3},\beta_{1}=\frac{1}{3},\beta_{2}=0" class="mathcode" src="https://images2.imgbox.com/da/82/k5DkfBsd_o.png">，可得：</p> 
<p style="text-align:center;"><img alt="y_{i+1}=y_{i-1}+\frac{1}{3}h(f_{i+1}+4f_{i}+f_{i-1})" class="mathcode" src="https://images2.imgbox.com/f2/b8/2Z9OeyYd_o.png"></p> 
<h3 id="2%E3%80%81%E6%B1%89%E6%98%8E%EF%BC%88Hamming%EF%BC%89%E6%96%B9%E6%B3%95">2、汉明（Hamming）方法</h3> 
<p>        取<img alt="\alpha_{0}=\frac{9}{8},\alpha_{1}=0,\alpha_{2}=-\frac{1}{8},\beta_{-1}=\frac{3}{8},\beta_{0}=\frac{3}{4},\beta_{1}=-\frac{3}{8},\beta_{2}=0" class="mathcode" src="https://images2.imgbox.com/eb/a4/ihUyleQp_o.png">，可得：</p> 
<p style="text-align:center;"><img alt="y_{i+1}=\frac{1}{8}(9y_{i}-y_{i-2})+\frac{3}{8}h(f_{i+1}+2f_{i}-f_{i-1})" class="mathcode" src="https://images2.imgbox.com/51/2c/4LYYmmKJ_o.png"></p> 
<h3 id="3%E3%80%81%E9%9A%90%E5%BC%8F%E5%9B%9B%E9%98%B6%E9%98%BF%E5%BD%93%E5%A7%86%E6%96%AF%EF%BC%88Adams%EF%BC%89%E6%96%B9%E6%B3%95">3、隐式四阶阿当姆斯（Adams）方法</h3> 
<p>        取<img alt="\alpha_{0}=1,\alpha_{1}=0,\alpha_{2}=0,\beta_{-1}=\frac{9}{24},\beta_{0}=\frac{19}{24},\beta_{1}=-\frac{5}{24},\beta_{2}=\frac{1}{24}" class="mathcode" src="https://images2.imgbox.com/b8/e4/mlmj5YsY_o.png">，可得：</p> 
<p style="text-align:center;"><img alt="y_{i+1}=y_{i}+\frac{1}{24}h(9f_{i+1}+19f_{i}-5f_{i-1}+f_{i-2})" class="mathcode" src="https://images2.imgbox.com/d2/85/ZQodsjjm_o.png"></p> 
<p style="text-align:justify;">        在线性多步法中，形如：</p> 
<p style="text-align:center;"><img alt="y_{i+1}=y_{i}+h\sum^{k-1}_{j=-1}\beta_{j}f_{i-j}=y_{i}+h(\beta_{-1}f_{i+1}+\beta_{0}f_{i}+\beta_{1}f_{i-1}+\cdot \cdot \cdot +\beta_{k-1}f_{i-k+1})" class="mathcode" src="https://images2.imgbox.com/e4/73/GvOOajE4_o.png"></p> 
<p style="text-align:justify;">的k步法称为阿当姆斯法。当<img alt="\beta_{-1}=0" class="mathcode" src="https://images2.imgbox.com/9d/7f/ZHpqPLnd_o.png">时为阿当姆斯显格式，称为Adams-Bashforth公式；当<img alt="\beta_{-1}\neq0" class="mathcode" src="https://images2.imgbox.com/6a/0d/M7onPiCE_o.png">时为阿当姆斯隐格式，称为Adams-Monlton公式。</p> 
<h3 id="4%E3%80%81%E9%A2%84%E4%BC%B0-%E6%A0%A1%E6%AD%A3%E9%98%BF%E5%BD%93%E5%A7%86%E6%96%AF%E6%B3%95" style="text-align:justify;">4、预估-校正阿当姆斯法</h3> 
<p style="text-align:justify;">        与改进欧拉法类似，可以通过显示法预测初值，然后利用隐式法进行迭代。阿当姆斯法也可以使用预估-校正的方式进行计算：</p> 
<p style="text-align:justify;">        显式阿当姆斯法为：</p> 
<p style="text-align:center;"><img alt="y_{i+1}=y_{i}+\frac{1}{24}h(55f_{i}-59f_{i-1}+37f_{i-2}-9f_{i-3})" class="mathcode" src="https://images2.imgbox.com/79/be/nidxAV3B_o.png"></p> 
<p style="text-align:justify;">        隐式阿当姆斯法为：</p> 
<p style="text-align:center;"><img alt="y_{i+1}=y_{i}+\frac{1}{24}h(9f_{i+1}+19f_{i}-5f_{i-1}+f_{i-2})" class="mathcode" src="https://images2.imgbox.com/64/66/GsIa9jN5_o.png"></p> 
<p style="text-align:justify;">        于是，预估-校正阿当姆斯法为：</p> 
<p style="text-align:center;">①预估:              <img alt="\bar{y}_{i+1}=y_{i}+\frac{1}{24}h(55f_{i}-59f_{i-1}+37f_{i-2}-9f_{i-3})" class="mathcode" src="https://images2.imgbox.com/0d/53/dkmlZ6XT_o.png"></p> 
<p style="text-align:center;">②校正：  <img alt="y_{i+1}=y_{i}+\frac{1}{24}h(9f(x_{i+1},\bar{y}_{i+1})+19f_{i}-5f_{i-1}+f_{i-2})" class="mathcode" src="https://images2.imgbox.com/fb/43/CtFnLla6_o.png"></p> 
<h2 id="%E4%B8%89%E3%80%81%E7%AE%97%E4%BE%8B%E5%AE%9E%E7%8E%B0%C2%A0%20%C2%A0">三、算例实现   </h2> 
<p>        求解初值问题：</p> 
<p style="text-align:center;"><img alt="\left\{\begin{matrix} y^{'}=-y+x+1 &amp;, 0&lt;x\leqslant 1,\\ y(0)=1 &amp; \end{matrix}\right." class="mathcode" src="https://images2.imgbox.com/cc/3f/GVTCiZCL_o.png"></p> 
<p style="text-align:justify;">步长h=0.2。已知精确解为：</p> 
<p>        代码如下：</p> 
<hr> 
<pre><code class="language-cpp">#include &lt;cmath&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;


int main(int argc, char* argv[])
{
        int i,N;
        double a,b,h,y0,k1,k2,k3,k4,err,y_predict;
        double *x,*y;
        double exact(double x);
        double f(double x, double y);

        a=0.0;
        b=1.0;
        N=5;
        h=(b-a)/N;

        x=(double*)malloc(sizeof(double)*(N+1));
        y=(double*)malloc(sizeof(double)*(N+1));

        for(i=0;i&lt;=N;i++)
                x[i]=a+i*h;

        y0=1.0;
        y[0]=y0;

        for(i=0;i&lt;3;i++)
        {
                k1=h*f(x[i],y[i]);
                k2=h*f(x[i]+0.5*h,y[i]+0.5*k1);
                k3=h*f(x[i]+0.5*h,y[i]+0.5*k2);
                k4=h*f(x[i]+h,y[i]+k3);
                y[i+1]=y[i]+(k1+2*k2+2*k3+k4)/6.0;
        }

        for(i=3;i&lt;N;i++)
        {
                //显示预测初值
                y_predict=y[i]+h*(55*f(x[i],y[i])-59*f(x[i-1],y[i-1])+37*f(x[i-2],y[i-2])-9*f(x[i-3],y[i-3]))/24.0;
                //隐式求解
                y[i+1]=y[i]+h*(9*f(x[i+1],y_predict)+19*f(x[i],y[i])-5*f(x[i-1],y[i-1])+f(x[i-2],y[i-2]))/24.0;
        }

        for(i=0;i&lt;=N;i++)
        {
                printf("x[%d]=%.2f,   y=%f,   exact=%f,   err=%.4e.\n",i,x[i],y[i],exact(x[i]),fabs(y[i]-exact(x[i])));

        }
free(x);
free(y);

        return 0;
}

double f(double x, double y)
{
        return -y+x+1;
}
double exact(double x)
{
        return x+exp(-x);
}
</code></pre> 
<p>N=5时，运行结果如下：</p> 
<pre><code class="language-cpp">x[0]=0.00,   y=1.000000,   exact=1.000000,   err=0.0000e+00.
x[1]=0.20,   y=1.018733,   exact=1.018731,   err=2.5803e-06.
x[2]=0.40,   y=1.070324,   exact=1.070320,   err=4.2251e-06.
x[3]=0.60,   y=1.148817,   exact=1.148812,   err=5.1888e-06.
x[4]=0.80,   y=1.249323,   exact=1.249329,   err=6.4190e-06.
x[5]=1.00,   y=1.367866,   exact=1.367879,   err=1.3775e-05.</code></pre> 
<p>N=10时，运行结果如下：</p> 
<pre><code class="language-bash">x[0]=0.00,   y=1.000000,   exact=1.000000,   err=0.0000e+00.
x[1]=0.10,   y=1.004838,   exact=1.004837,   err=8.1964e-08.
x[2]=0.20,   y=1.018731,   exact=1.018731,   err=1.4833e-07.
x[3]=0.30,   y=1.040818,   exact=1.040818,   err=2.0132e-07.
x[4]=0.40,   y=1.070320,   exact=1.070320,   err=1.2779e-07.
x[5]=0.50,   y=1.106530,   exact=1.106531,   err=3.9130e-07.
x[6]=0.60,   y=1.148811,   exact=1.148812,   err=6.0354e-07.
x[7]=0.70,   y=1.196585,   exact=1.196585,   err=7.7242e-07.
x[8]=0.80,   y=1.249328,   exact=1.249329,   err=9.0367e-07.
x[9]=0.90,   y=1.306569,   exact=1.306570,   err=1.0029e-06.
x[10]=1.00,   y=1.367878,   exact=1.367879,   err=1.0751e-06.</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3a50dac00a2037cfdb6d779e4e170c96/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【阿里云 centos7安装python3.12遇到的坑，openssl】Could not build the ssl module! Python requires a OpenSSL 1.1.1</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/de0c2441bfa6235ccb250d39ecae64f0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2024免费Mac苹果解压压缩包软件BetterZip5</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>