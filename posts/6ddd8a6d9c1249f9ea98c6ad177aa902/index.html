<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】异常 - 编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcxuexizhe.github.io/posts/6ddd8a6d9c1249f9ea98c6ad177aa902/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="【C&#43;&#43;】异常">
  <meta property="og:description" content="1. 概念 异常是一种处理错误的方式，当一个函数发现自己无法处理的错误时就可以抛出异常，让函数的 直接或间接的调用者处理这个错误
代码举例
#include&lt;iostream&gt; using namespace std; int division(int x,int y) { if (y == 0) { throw &#34;除0错误&#34;; } return x / y; } int main() { try { int x, y; cin &gt;&gt; x &gt;&gt; y; division(x, y); } catch (const char* e) { cout &lt;&lt; e &lt;&lt; endl; } return 0; } 运行结果：
注：
throw: 当问题出现时，程序会抛出一个异常，这是通过使用 throw 关键字来完成的
catch: 在您想要处理问题的地方，通过异常处理程序捕获异常.catch 关键字用于捕获异
常，可以有多个catch进行捕获
try: try 块中的代码标识将被激活的特定异常,它后面通常跟着一个或多个 catch 块">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-15T18:40:20+08:00">
    <meta property="article:modified_time" content="2024-05-15T18:40:20+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】异常</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9f/d2/WgXz2p9Z_o.jpg"></p> 
<hr> 
<h2 id="X2W2Y">1. 概念</h2> 
<p id="uc37c788f">异常是一种处理错误的方式，<strong>当一个函数发现自己无法处理的错误时就可以抛出异常，让函数的 </strong></p> 
<p id="ufb3f1f96"><strong>直接或间接的调用者处理这个错误</strong></p> 
<p id="u29c5e78b"></p> 
<blockquote> 
 <p>代码举例</p> 
 <pre id="hUf9x"><code>#include&lt;iostream&gt;
using namespace std;
int division(int x,int y)
{
	if (y == 0)
	{
		throw "除0错误";
	}
	return x / y;
}
int main()
{
	try
	{
		int x, y;
		cin &gt;&gt; x &gt;&gt; y;
		division(x, y);
	}
	catch (const char* e)
	{
		cout &lt;&lt; e &lt;&lt; endl;
	}
   return 0;
}</code></pre> 
 <p id="u5c958857">运行结果：</p> 
 <p id="u1dc75d78"></p> 
 <p class="img-center"><img alt="" height="90" id="u78fb150d" src="https://images2.imgbox.com/90/b1/lUMMiFWp_o.png" width="264"></p> 
 <p id="u49e5f64a"></p> 
</blockquote> 
<p id="u7593ef60"><span style="color:#fe2c24;">注：</span></p> 
<p id="uec01695f"><strong>throw: </strong>当问题出现时，程序会抛出一个异常，这是通过使用 <strong>throw </strong>关键字来完成的</p> 
<p id="ubc2c4776"><strong>catch: </strong>在您想要处理问题的地方，通过异常处理程序捕获异常.<strong>catch </strong>关键字用于捕获异</p> 
<p id="ue913af6c">常，可以有多个catch进行捕获</p> 
<p id="u9960d55c"><strong>try:</strong> try 块中的代码标识将被激活的特定异常,它后面通常跟着一个或多个 catch 块</p> 
<p id="ubd5b9a6b"></p> 
<h2 id="UGJLy">2. 使用</h2> 
<h3 id="Ht2lB"><strong>a. 异常的抛出和捕获</strong></h3> 
<h4 id="b3a8T"><strong>（一）异常的抛出和匹配原则 </strong></h4> 
<ol><li id="u649350ef">异常是通过<strong>抛出对象而引发</strong>的，该<strong>对象的类型</strong>决定了应该激活哪个catch的处理代码</li><li id="uf51e4b90">被<strong>选中的处理代码</strong>是调用链中<strong>与该对象类型匹配且离抛出异常位置最近</strong>的那一个</li></ol> 
<blockquote> 
 <p>代码举例</p> 
 <pre id="erqPN"><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int divsion(int x,int y)
{
	if (y == 0)
	{
		throw "除数不能为 0";
	}
	return x / y;
}
void func()
{
	try
	{
		int x, y;
		cin &gt;&gt; x &gt;&gt; y;
		divsion(x, y);
	}
	catch(const char* x)
	{
		cout &lt;&lt; "func()" &lt;&lt; endl;
		cout &lt;&lt; x;
	}
}
int main()
{
	try
	{
		func();;
	}
	catch (const char* x)
	{
		cout &lt;&lt; " main()" &lt;&lt; endl;
		cout &lt;&lt; x;
	}
   return 0;
}</code></pre> 
 <p id="ua685e202"></p> 
 <p id="u78c0533e">运行结果：</p> 
 <p id="ua1cdbaab"></p> 
 <p class="img-center"><img alt="" height="105" id="K3u3L" src="https://images2.imgbox.com/4b/17/9xwv7BeJ_o.png" width="319"></p> 
 <p id="u5f729319"></p> 
</blockquote> 
<p id="ubbcb7d4a">throw 抛出的异常对应的是最里面的循环链</p> 
<ol><li id="u30468b6a">抛出异常对象后，会生成一个异常对象的拷贝，因为抛出的异常对象可能是一个临时对象，</li></ol> 
<p id="ubbea780e">所以会生成一个拷贝对象，这个拷贝的临时对象会在被catch以后销毁（这里的处理类似</p> 
<p id="u5ca7352a">于函数的传值返回）</p> 
<p>     2.  catch(...)可以捕获任意类型的异常，问题是不知道异常错误是什么</p> 
<blockquote> 
 <p>代码举例</p> 
 <pre id="BnLra"><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int divsion(int x,int y)
{
	if (y == 0)
	{
		throw "除数不能为 0";
	}
	return x / y;
}
int main()
{
	try
	{
		int x, y;
		cin &gt;&gt; x &gt;&gt; y;
		divsion(x, y);
	}
	catch (const char* x)
	{
		cout &lt;&lt; "func()" &lt;&lt; endl;
		cout &lt;&lt; x;
	}
	catch (...)
	{
		cout &lt;&lt; "未知错误" &lt;&lt; endl;
	}
   return 0;
}</code></pre> 
</blockquote> 
<p>3. 实际中抛出和捕获的匹配原则有个例外，并不都是类型完全匹配，<strong>可以抛出的派生类对象，</strong> </p> 
<p id="u96ee305c"><strong>使用基类捕获</strong></p> 
<p id="u142744b2"></p> 
<p id="u543e7c27"></p> 
<h4 id="jaW0Z"><strong>（二）在函数调用链中异常栈展开匹配原则 </strong></h4> 
<ol><li id="uecc705b6">首先<strong>检查throw本身是否在try块内部，如果是再查找匹配的catch语句</strong>，如果有匹配的，则</li></ol> 
<p id="u9b047ec4">调到catch的地方进行处理</p> 
<p>      2.  没有匹配的catch则退出当前函数栈，继续在调用函数的栈中进行查找匹配的catch</p> 
<p><strong>      3.  如果到达main函数的栈，依旧没有匹配的，则终止程序</strong>。上述这个沿着调用链查找匹配的</p> 
<p id="u6f818cb4">catch子句的过程称为<strong>栈展开</strong>。所以实际中我们最后都要加一个catch(...)捕获任意类型的异常，否则当有异常没捕获，程序就会直接终止</p> 
<p>     4.  找到匹配的catch子句并处理以后，会继续沿着catch子句后面继续执行</p> 
<p id="u0720cf22"></p> 
<h3 id="H5u3u"><strong>b. 异常的重新抛出</strong></h3> 
<p id="u98ee1f14">有可能单个的catch不能完全处理一个异常，在进行一些校正处理以后，希望再交给更外层的调用</p> 
<p id="u34b8387b">链函数来处理，catch则可以通过重新抛出将异常传递给更上层的函数进行处理</p> 
<blockquote> 
 <p>代码举例</p> 
 <pre id="lWElF"><code>#include&lt;iostream&gt;
using namespace std;
int Division(int a, int b)
{
	
	if (b == 0)
	{
		throw "除数不能为0";
	}
	return a / b;
}
void Func()
{
	
	int* array = new int[10];
	try {
		int len, time;
		cin &gt;&gt; len &gt;&gt; time;
		cout &lt;&lt; Division(len, time) &lt;&lt; endl;
	}
	catch (...)
	{
		cout &lt;&lt; "delete []" &lt;&lt; array &lt;&lt; endl;
		delete[] array;
		throw;
	}
	cout &lt;&lt; "delete []" &lt;&lt; array &lt;&lt; endl;
	delete[] array;
}
int main()
{
	try
	{
		Func();
	}
	catch (const char* arr)
	{
		cout &lt;&lt; arr &lt;&lt; endl;
	}
	return 0;
}</code></pre> 
 <p id="ufcff3b6b"></p> 
 <p id="uc51f9d10">运行结果：</p> 
 <p id="ue3c9f354"></p> 
 <p class="img-center"><img alt="" height="138" id="ua048b74e" src="https://images2.imgbox.com/39/2c/aa8euMxu_o.png" width="555"></p> 
 <p id="uf1809806"></p> 
</blockquote> 
<h2 id="p638b">3. <strong>异常安全</strong></h2> 
<ol><li id="ucfbebb17"><strong>构造函数完成对象的构造和初始化</strong>，<strong>最好不要</strong>在构造函数中抛出异常，否则<strong>可能导致对象不 </strong></li></ol> 
<p id="u9e3aea2e"><strong>完整或没有完全初始化 </strong></p> 
<p><strong>     2.  析构函数主要完成资源的清理</strong>，<strong>最好不要</strong>在析构函数内抛出异常，否则<strong>可能导致资源泄漏</strong></p> 
<p>     3.  C++中异常经常会导致资源泄漏的问题，比如在new和delete中抛出了异常，导致内存泄</p> 
<p id="u9c2c27a0">漏，C++经常使用RAII（资源回收）来解决以上问题</p> 
<p id="u649eb1da"></p> 
<h2 id="bzvFM">4. <strong>异常规范</strong></h2> 
<ol><li id="uf6a8e676">异常规格说明的目的是为了让函数使用者知道该函数可能抛出的异常有哪些， 可以在函数的</li></ol> 
<p id="uac39715b">后面接throw(类型)，列出这个函数可能抛掷的所有异常类型</p> 
<p>     2.  函数的后面接throw()，表示函数不抛异常 （c++11 喜欢写成 noexcpet 表示绝对不会抛异常）</p> 
<p>     3.  若无异常接口声明，则此函数可以抛掷任何类型的异常</p> 
<p id="u8526f196"></p> 
<h2 id="lopNy">5. <strong>C++标准库的异常体系</strong></h2> 
<p id="u378b36e5">C++ 提供了一系列标准的异常，我们可以在程序中使用这些标准的异常。它们是以父</p> 
<p id="ua537d231">子类层次结构组织起来的</p> 
<p id="u6236f146"></p> 
<p class="img-center"><img alt="" height="844" id="u724eabcb" src="https://images2.imgbox.com/9d/38/wp4fc5zo_o.png" width="674"></p> 
<p id="u1859cd4b"></p> 
<p id="u03652815"><span style="color:#fe2c24;">注：</span></p> 
<p id="u7054a02d">因为C++标准库设计的不够好用，所以实际中很多公司像上面一样自己定义一套异常继承体系</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9bf200b0db08d020c3953be175010049/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【大数据】计算引擎MapReduce</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6c03f9f03fbfb15cc52480aff23dfc8f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">粒子系统技术在AI去衣应用中的创新探索</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>