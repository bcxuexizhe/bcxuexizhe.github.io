<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.126.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程学习者</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程学习者的博客">
		<meta property="og:url" content="https://bcxuexizhe.github.io/">
  <meta property="og:site_name" content="编程学习者">
  <meta property="og:title" content="编程学习者">
  <meta property="og:description" content="编程学习者的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程学习者">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程学习者" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程学习者</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1846df8bea8f3b38cf81952aa17ef65/" rel="bookmark">
			【Linux 网络编程】网络的基础知识详解！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 计算机网络背景2. 认识 "协议"3. 协议分层 1. 计算机网络背景 网络互联: 多台计算机连接在一起, 完成数据共享;
🍎局域网（LAN----Local Area Network）: 计算机数量更多了, 通过交换机和路由器连接。
🍎 广域网WAN: 将远隔千里的计算机都连在一起;
2. 认识 “协议” 🍎① “协议” 本质是一种约定 (通信双方之间 )，可以理解我们在淘宝上面买一个商品，我们收到快递后，我们收到的不止是买的商品还有一个快递单 ( 这个快递单其实就是我们双方约定好的协议，从快递单我们知道双方的寄货、收货信息， — 报文 ---- ，协议是通信信息多出来的部分 )
协议其实就是C语言中的结构体，结构体中 填充我们需要的字段（两个结构体对象之间相互通信，所以都认识）
🍎② 计算机之间的传输媒介是光信号和电信号. 通过 “频率” 和 “强弱” 来表示 0 和 1 这样的信息. 要想传递各种不同的信息, 就需要约定好双方的数据格式.
🍎③ 小问题: 只要通信的两台主机, 约定好协议就可以了么?
计算机生产厂商有很多;计算机操作系统, 也有很多;计算机网络硬件设备, 还是有很多;如何让这些不同厂商之间生产的计算机能够相互顺畅的通信?
就需要有人站出来, 约定一个共同的标准, 大家都来遵守, 这就是网络协议; 🍎④ 每层都需要有自己的协议！
3. 协议分层 🍎 打电话📞的例子：🐧 分层有什么好处呢？
① 分层最大的好处在于 “封装”；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1846df8bea8f3b38cf81952aa17ef65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b59b40e26af464d074058a8ebe7ed5c7/" rel="bookmark">
			C&#43;&#43;：类和对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 C++是面向对象的语言，本文将通过上、中、下三大部分，带你深入了解类与对象。
目录
一、前言 二、部分：上
1.面向过程和面向对象初步认识
2.类的引入
3.类的定义
4.类的访问限定符及封装
5.类的作用域
6.类的实例化
7.类的对象大小的计算
8.类成员函数的this指针
结束语：上
三、部分：中
类的6个默认成员函数
函数一：构造函数
函数二：析构函数
函数三： 拷贝构造函数
函数四：赋值运算符重载
函数五函数六：取地址及const取地址操作符重载
结束语 ：中
四：部分下
1.对流插入和流提取的重载
2. 再谈构造函数
3.explicit关键字
4.static成员
5.匿名对象
6.友元
7.内部类
五：再次理解类和对象
二、部分：上 本部分主要有以下内容：
1. 面向过程和面向对象初步认识 2. 类的引入 3. 类的定义 4. 类的访问限定符及封装 5. 类的作用域 6. 类的实例化 7. 类的对象大小的计算 8. 类成员函数的 this 指针 1.面向过程和面向对象初步认识 C语言是面向过程的，关注的是过程，分析出求解问题的步骤，通过函数调用逐步解决问题。
就拿洗衣服而言，C语言是下面的步骤：
C++则是面向的对象，关注的是对象，将一件事情拆分成不同的对象，靠对象之间的交互完成。
特别注意一点，这里的面向对象，指的不是男女朋友的对象！
2.类的引入 在学习C语言时，我们学习了很多结构，eg：栈、堆、队列等等，在实现这些结构时，都是借助了struct，那在C++中，祖师爷为了让结构更好的使用，于是优化了结构，引入了类，因此C++的类就是优化过的结构体。
C语言结构体中只能定义变量，在C++中，结构体内不仅可以定义成员变量，也可以定义成员函数。比如：
之前在数据结构初阶中，用C语言方式实现的栈，结构体中只能定义变量；现在以C++方式实现，会发现struct中也可以定义函数。
下面来看一个Stack类的例子。
typedef int DataType; struct Stack { void Init(size_t capacity) { _array = (DataType*)malloc(sizeof(DataType) * capacity); if (nullptr == _array) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b59b40e26af464d074058a8ebe7ed5c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d3ce766e443885b373dd60b3fa21e00/" rel="bookmark">
			如何配置才能连接远程服务器上的 redis server ？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Intro修改点 Intro 以阿里云服为例。
首先，我在我买的阿里云服务器中以下载源码、手动编译的方式安装了 redis-server，操作流程见：Ubuntu redis 下载解压配置使用及密码管理 &amp;&amp; 包管理工具联网安装。
接着，我在本地电脑下载了 redis 官方推荐的 redis insight 客户端工具：https://redis.io/insight/
但是这个时候用本地客户端(GUI客户端、redis-cli 命令工具、亦或是Java或其他程序的客户端library)去连接已经在远程服务器运行的 redis-server ，却是连接失败。
错误如下：
修改点 修改 redis-server 启动时会读取的配置文件：redis.conf
bind 0.0.0.0 requirepass 123456 port 6379 注意 bind 配置，0.0.0.0 和 127.0.0.1 是有区别的。
然后在云服务器的界面中，修改安全设置：防火墙开 6379
推而广之，在一台机器上启动 redis-server 服务。在另一台机器上用 redis-client(任意形式的，GUI界面，程序客户端等)试图连接不在同一台机器上运行着的 redis-server
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16c5b79131d4844d0e22d2f2907163e7/" rel="bookmark">
			解决文件传输难题：如何绕过Gitee的100MB上传限制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在版本控制和代码托管领域，Gitee作为一个流行的平台，为用户提供了便捷的服务。然而，其对单个文件大小设定的100MB限制有时会造成一些不便。
使用云存储服务 推荐理由：
便捷性：多数云存储服务如： Dropbox、Google Drive等提供了简洁的用户界面和跨平台兼容性。
安全性：这些服务通常提供高级的数据加密和安全性措施，保护文件不被未授权访问。共享简便：生成分享链接即可让其他人下载或查看文件，非常适合团队协作。 Git LFS 操作： 第一步：在Git仓库中为仓库设置相关配置： $ git lfs install 第二步：选择要用LFS追踪的文件： $ git lfs track "*.svg" # 或者具体到某个文件 $ git lfs track "2.png" $ git lfs track "example.lfs" 第三步：保存并提交配置： $ git add .gitattributes $ git commit -m "add .gitattributes" 配置总结：
安装Git LFS之后，只需三步，即可在仓库中配置LFS功能，即：
#step 1 $ git lfs install #step 2 $ git lfs track files # step 3 $ git add .gitattributes 总结： Git LFS是一个易于安装、易于配置，使用高效的Git拓展工具，它能有效的管理仓库中的大文件，避免仓库体积过大，影响项目管理效率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16c5b79131d4844d0e22d2f2907163e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3751fc8d357bde1e489fa0a89265563/" rel="bookmark">
			YOLO-10更快、更强
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YOLO-10简介 主要贡献： 无NMS的一致双分配 YOLOv10提出了一种通过双标签分配而不用非极大值抑制NMS的策略。这种方法结合了一对多和一对一分配策略的优势，提高了效率并保持了性能。 高效的网络设计 轻量化分类头：在不显著影响性能的情况下，减少了计算开销。
空间-通道解耦下采样：解耦空间下采样和通道调整，优化计算成本。
基于秩的块设计：根据各阶段的内在秩适应块设计，减少冗余，提高效率。
大核卷积和部分自注意力PSA：在不显著增加计算成本的情况下，增强了感受野和全局建模能力。
一致双分配策略 一对多分配：在训练期间，多个预测框被分配给一个真实物体标签。这种策略提供了丰富的监督信号，优化效果更好。
一对一分配：仅一个预测框被分配给一个真实物体标签，避免了NMS，但由于监督信号较弱，容易导致收敛速度慢和性能欠佳。
双头架构：模型在训练期间使用两个预测头，一个使用一对多分配，另一个使用一对一分配。这样，模型可以在训练期间利用一对多分配的丰富监督信号，而在推理期间则使用一对一分配的预测结果，从而实现无NMS的高效推理。
Head优化
综合一对一多与一对一的bbox分配策略，网络模块添加两种类型的head模块；推理过程中只保留一对一分配head相较于分类head，回归head承担更多意义 效率驱动的模型设计 空间-通道解耦下采样，首先利用点状卷积调节通道维度，然后使用深度卷积进行空间下采样秩引导的块设计：提出了一个紧凑型倒置块（CIB）结构，它采用廉价的深度卷积进行空间混合和高效的一维卷积进行通道混合，如图（b），作为高效的基本构建块。随着模型规模的增加，其感受野自然扩大，使用大核卷积的好处减弱，作者只对小型模型规模采用大核卷积 CIB
class Conv(nn.Module): """Standard convolution with args(ch_in, ch_out, kernel, stride, padding, groups, dilation, activation).""" default_act = nn.SiLU() # default activation def __init__(self, c1, c2, k=1, s=1, p=None, g=1, d=1, act=True): """Initialize Conv layer with given arguments including activation.""" super().__init__() self.conv = nn.Conv2d(c1, c2, k, s, autopad(k, p, d), groups=g, dilation=d, bias=False) self.bn = nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3751fc8d357bde1e489fa0a89265563/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f46a61173829f759860e2c9eac619b0a/" rel="bookmark">
			SQL 语言：嵌入式 SQL 和动态 SQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 基本概述嵌入式 SQL动态 SQL总结 基本概述 嵌入式SQL和动态SQL是两种在应用程序中嵌入和使用SQL语句的方法。它们都允许开发人员在编程语言中编写SQL语句，以便在应用程序中执行数据库操作。然而，这两种方法在实现方式、性能和灵活性方面存在一些差异。
嵌入式SQL是一种将SQL语句直接嵌入到宿主语言（如C、C++、Java等）代码中的方法。在这种情况下，开发人员需要使用特定的语法和预处理器来将SQL语句与宿主语言代码集成在一起。嵌入式SQL的主要优点是它允许开发人员在编写应用程序时使用熟悉的宿主语言语法，同时仍然能够利用SQL的强大功能。此外，嵌入式SQL通常具有较好的性能，因为它允许编译器在编译时检查SQL语句的有效性，并生成优化的代码。
动态SQL是一种在运行时构建和执行SQL语句的方法。在这种情况下，开发人员需要使用字符串拼接或模板引擎等技术来动态生成SQL语句。然后，这些语句可以在应用程序运行时传递给数据库服务器进行执行。动态SQL的主要优点是它具有很高的灵活性，因为它允许开发人员根据运行时条件构建和修改SQL语句。这使得动态SQL非常适合处理复杂的查询和更新操作，以及支持用户自定义的查询和报告功能。然而，动态SQL的性能可能较差，因为它需要在运行时解析和优化SQL语句，这可能导致额外的开销。
总的来说，嵌入式SQL和动态SQL各有优缺点。嵌入式SQL适用于那些需要高性能和编译时错误检查的场景，而动态SQL适用于那些需要高度灵活性和运行时动态生成SQL语句的场景。在选择使用哪种方法时，开发人员应权衡这些因素，并根据应用程序的具体需求做出决策。
在实际开发过程中，开发人员可能需要结合使用嵌入式SQL和动态SQL。例如，他们可以使用嵌入式SQL编写大部分数据库操作，以确保高性能和编译时错误检查；同时，对于需要高度灵活性的部分，可以使用动态SQL来实现。这种混合方法可以充分利用两种方法的优点，同时避免它们的局限性。
嵌入式 SQL SQL 提供了将 SQL 语句嵌入某种高级语言中的使用方式，但是如何识别嵌入在高级语言中的 SQL 语句，通常采用预编译的方法。该方法的关键问题是必须区分主语言中嵌入的 SQL语句，以及主语言和 SQL 间的通信问题。采用的方法由 DBMS 的预处理程序对源程序进行扫描，识别出 SQL 语句，把它们转换为主语言调用语句，以使主语言编译程序能识别它，最后由主语言的编译程序将整个源程序编译成目标码。
如何区分主语言语句与 SQL 语句？
需要在所有的 SQL 语句前加前缀 EXEC SQL，而 SQL 的结束标志随主语言的不同而不同。
PL/1 和 C 语言的引用格式为：EXEC SQL &lt;SQL语句&gt;；COBOL 语言的引用格式为：EXEC SQL &lt;SQL 语句&gt; END-EXEC； 主语言与数据库如何通信？
（1）SQL 通信区 (SQL Communication Area,SQLCA) 向主语言传递 SQL 语句执行的状态信息，使主语言能够根据此信息控制程序流程。
（2）主变量也称共享变量。主语言向 SQL 语句提供参数主要通过主变量，主变量由主语言的程序定义，并用 SQL 的 DECLARE 语句说明，引用变量一定要加上:。
EXEC SQL BEGIN DECLARE SECTION; /*说明主变量*/ char Msno[4],Mcno[3],Givensno[5]; int Mgrade; char SQLSTATE[6]; EXEC SQL END DECLARE SECTION; 分析：以上说明了五个共享变量，其中，SQLSTATE 是一个特殊的共享变量，解释 SQL 语句执行状况的作用。当 SQL 语句执行成功时，系统自动给 SQLSTATE 赋值上全零值，否则为非全零（”02000”)。因此，当执行一条SQL语句后，可以根据 SQLSTATE 的值转向不同的分支，以控制程序的流向。引用时，为了与 SQL 属性名相区别，需在主变量前加: 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f46a61173829f759860e2c9eac619b0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c11930a9ab14818f1cd2db052719ec0/" rel="bookmark">
			第十四届蓝桥杯c&#43;&#43;研究生组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A 混乘数字
关键思路是求每个十进制数的数字以及怎么在一个数组中让判断所有的数字次数相等。
求每个十进制的数字
while(n!=0){ int x = n%10;//x获取了n的每一个位数字 n/=10; } 扩展：求二进制的每位数字 （注意：进制转换、1的个数、位运算）
x &gt;&gt; k &amp; 1//k代表第几个位置 判断几个数中的数字次数相等
下面是判断3个数中的数字次数相等
bool swap(int n,int i,int j){ int a[]={0,0,0,0,0,0,0,0,0,0}; while(n!=0){ int x = n%10; a[x]++; n/=10; } while(i!=0){ int x = i%10; a[x]--; i/=10; } while(j!=0){ int x = j%10; a[x]--; j/=10; } for(int i=0;i&lt;=9;i++){ if(a[i]!=0){ return false; } } return true; } 完整代码：
#include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; bool swap(int n,int i,int j){ int a[]={0,0,0,0,0,0,0,0,0,0}; while(n!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c11930a9ab14818f1cd2db052719ec0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d0fb695c48c8909c9691e33e43596df/" rel="bookmark">
			markdown语法保存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 欢迎使用Markdown编辑器新的改变功能快捷键合理的创建标题，有助于目录的生成如何改变文本的样式插入链接与图片如何插入一段漂亮的代码片生成一个适合你的列表创建一个表格设定内容居中、居左、居右SmartyPants 创建一个自定义列表如何创建一个注脚注释也是必不可少的KaTeX数学公式新的甘特图功能，丰富你的文章UML 图表FLowchart流程图导出与导入导出导入 欢迎使用Markdown编辑器 你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。
新的改变 我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：
全新的界面设计 ，将会带来全新的写作体验；在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示；增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；全新的 KaTeX数学公式 语法；增加了支持甘特图的mermaid语法1 功能；增加了 多屏幕编辑 Markdown文章功能；增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间；增加了 检查列表 功能。 功能快捷键 撤销：Ctrl/Command + Z
重做：Ctrl/Command + Y
加粗：Ctrl/Command + B
斜体：Ctrl/Command + I
标题：Ctrl/Command + Shift + H
无序列表：Ctrl/Command + Shift + U
有序列表：Ctrl/Command + Shift + O
检查列表：Ctrl/Command + Shift + C
插入代码：Ctrl/Command + Shift + K
插入链接：Ctrl/Command + Shift + L
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d0fb695c48c8909c9691e33e43596df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0aa61aca3bfe00cacad19fa45affe9a/" rel="bookmark">
			电脑丢失api-ms-win-crt-runtime-l1-1-0.dll的多种修复方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在计算机使用过程中，我们经常会遇到一些错误提示，其中之一就是“api-ms-win-crt-runtime-l1-1-0.dll丢失”。这个错误通常发生在Windows操作系统中，它表示一个动态链接库文件丢失或损坏。这个问题可能会导致某些应用程序无法正常运行，给用户带来困扰。小编将介绍5种解决api-ms-win-crt-runtime-l1-1-0.dll丢失问题的方法，帮助用户快速恢复系统的正常运行。
一，了解api-ms-win-crt-runtime-l1-1-0.dll是什么 api-ms-win-crt-runtime-l1-1-0.dll 是一个Windows操作系统中的动态链接库（DLL）文件，它是Universal C Runtime (UCRT) 的一部分。UCRT为在Windows上运行的应用程序提供了标准的C/C++运行时支持。这个特定的DLL包含了许多基本的操作系统级功能，如内存管理、输入/输出操作、字符串处理和数学运算等，这些都是C和C++程序运行所必需的。
二，文件丢失原因分析 系统文件损坏：系统文件损坏是导致api-ms-win-crt-runtime-l1-1-0.dll丢失的一个常见原因。这种情况可能是由于病毒感染、不当的系统维护操作或硬件故障造成的。根据统计，大约有30%的dll丢失问题与系统文件损坏有关。
软件冲突：软件冲突也可能导致dll文件丢失。当多个程序试图修改或访问同一系统资源时，可能会导致文件损坏或丢失。例如，安全软件可能会错误地将某些dll文件识别为恶意软件并将其隔离或删除。
系统更新失败：系统更新失败是另一个可能的原因。Windows系统在更新过程中可能会遇到错误，导致更新不完整，从而丢失必要的dll文件。根据微软的官方数据，系统更新失败率通常低于1%，但一旦发生，就可能需要用户采取额外的措施来解决问题。
三，具体表现 当api-ms-win-crt-runtime-l1-1-0.dll文件丢失时，用户可能会遇到以下具体表现：
应用程序启动失败，出现错误提示消息，指出缺少必要的dll文件。
系统稳定性下降，可能会出现崩溃或重启。
某些依赖于该dll文件的功能无法正常工作，影响用户体验。
四，解决方法 方法一：重新安装Microsoft Visual C++ Redistributable 重新安装Microsoft Visual C++ Redistributable是解决api-ms-win-crt-runtime-l1-1-0.dll丢失问题的有效方法之一。由于该dll文件是Visual C++ Redistributable的一部分，因此安装相应的Visual C++版本可以确保所有必要的运行时组件都得到更新和修复。根据微软官方数据，大约有80%的dll问题可以通过此方法解决。
方法二：使用系统文件检查器（SFC）扫描 系统文件检查器（SFC）是一个内置的Windows实用程序，用于扫描和修复系统文件，包括丢失或损坏的dll文件。根据微软的统计，SFC扫描能够解决大约60%的系统文件相关问题。
以管理员身份运行：为了执行SFC扫描，必须以管理员权限打开命令提示符。这可以通过在开始菜单中搜索“命令提示符”，然后选择“以管理员身份运行”来实现。
输入正确的命令：在命令提示窗口中，键入sfc /scannow命令，然后按Enter键执行。如果发现有文件损坏或丢失，它将尝试用缓存中的副本替换这些文件，从而修复问题
方法三：使用DLL修复工具（有效） 首先在浏览器顶部输入：dll修复工具.site（按下键盘回车键打开）并下载。
运行该程序，点击一键修复，它将自动扫描并修复系统中缺失或损坏的DLL文件。
检测完成后将使用一键修复便可以解决缺失的api-ms-win-crt-runtime-l1-1-0.dll文件和其他的dll文件可以一并修复。等待修复过程完成后，重新启动电脑以使更改生效。
优点：方便快捷，适用于不熟悉手动操作的用户。据统计数据，DLL修复工具在某些情况下可以解决超过90%的dll相关问题。
方法四：手动下载并替换dll文件 还可以尝试从可信的源手动下载api-ms-win-crt-runtime-l1-1-0.dll文件，并将其复制到系统的适当目录中。对于64位系统，通常是C:\Windows\System32，而对于32位应用程序在64位系统上，则是C:\Windows\SysWOW64。
完成复制后，使用regsvr32 api-ms-win-crt-runtime-l1-1-0.dll命令注册dll文件。根据用户反馈，这种方法在大约70%的情况下有效。
方法五：执行系统还原或修复安装 如果问题是由最近的系统更改引起的，执行系统还原到一个早期的还原点或进行Windows修复安装可能是解决问题的最后手段。系统还原可以撤销最近的系统更改，而修复安装则可以修复系统而不丢失个人文件。
根据微软的官方数据，这两种方法在特定情况下可以解决超过50%的系统问题。
五，预防措施 定期备份系统：定期备份系统是预防api-ms-win-crt-runtime-l1-1-0.dll丢失的重要措施之一。通过设置系统还原点或使用第三方备份软件，用户可以在系统出现问题时快速恢复到正常状态。根据一项针对500名用户的调查，定期备份的用户在遇到系统问题时恢复时间平均减少了75%。
谨慎卸载软件：在卸载软件时，应确保使用官方提供的卸载程序或通过控制面板的“程序和功能”进行操作。这可以防止软件残留文件对系统稳定性造成影响。统计显示，通过谨慎卸载软件，系统文件损坏的风险降低了约40%。
安装杀毒软件：安装并定期更新杀毒软件可以有效防止病毒感染导致的系统文件损坏。根据杀毒软件提供商的报告，安装杀毒软件的用户遭受病毒攻击的概率降低了90%以上。
更新系统补丁：及时安装Windows更新和补丁是维护系统稳定性和安全性的关键。微软定期发布安全更新和补丁来修复已知的漏洞和问题。根据微软的官方数据，保持系统更新可以减少80%以上的安全风险。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec0f21b92cbd318949a59bdcf2b5bcc1/" rel="bookmark">
			【大数据】Hadoop 2.X和1.X升级优化对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.前言
2.hadoop 1.X的缺点和优化方向
3.解决NameNode的局限性
3.1.Hadoop HA
3.2.Haddop federation
4.yarn
5.周边组件
1.前言 本文是作者大数据系列中的一文，专栏地址：
https://blog.csdn.net/joker_zjn/category_12631789.html?spm=1001.2014.3001.5482
前文中我们从大数据的概论入手、分别聊了分布式文件系统的鼻祖GFS、分布式数据库的鼻祖Big Table、hadoop中的分布式文件系统HDFS、计算引擎Map Reduce、分布式数据库HBase。以上关于Hadoop的内容都是基于hadoop 1.X来聊的，Hadoop 1.X作为推出的第一个版本经过实战的检验发现还有诸多很需要优化的地方，本文就会来聊一下hadoop 2.X中对hadoop 1.X做了哪些优化。
2.hadoop 1.X的缺点和优化方向 hadoop1.0版本有几个待优化点：
NameNode是单节点的，存储上会有上限，容错上也会有局限性。
抽象层次低，需要大量的底层操作，即大量指令操作、大量代码编写。
计算引擎有局限性限
mapreduce能解决的问题有限
资源利用率地，由于没有很好的资源调度机制，而是粗略的将不同作业之间的资源直接相互独立开来，会导致各个job的资源只有自己能用，就算已经到了reduce阶段，自身的map资源也不能被别的job用到。
效率很低，MapReduce的单个计算任务的结果会存入HDFS中，也就是落了磁盘，因此如果是进行迭代计算（上一个job的输出是下一个job的输入）就要来回读HDFS。
hadoop在2.X版本中对这些问题从两方便做了优化：
优化自身的核心组件HDFS、MapReduce
引入其它周边的配套组件，扩展能力
首先是对核心组件的优化：
组件1.X存在的问题2.X的改进HDFSnameNode存在单点失效问题引入HDFS HA，对nameNode进行热备HDFS命名空间单一无法实现资源隔离引入HDFS Federation，分出多个命名空间MapReduce资源管理、调度效率低引入单独的资源管理框架YARN 其次是扩展了周边组件，增强了能力：
组件功能所解决的问题pig用户只需要编写少量语句就能完成计算任务，省去MapReduce的代码编写抽象层次低spark基于内存的计算框架，比mapreduce快，有良好实时性，迭代计算快计算任务延迟高，不适合迭代计算Tez支持DAG作业，对作业操作进行重新分解和组合，减少不必要的操作，相当于对Map Reduce进行过程精简不同Map Reduce之间存在重复此操作，拉低了效率 3.解决NameNode的局限性 3.1.Hadoop HA Hadoop HA属于一种架构，是对Hadoop的水平扩展，用来解决NameNode没有热备份的问题。
HA架构中将NameNode分为活跃和待命两种状态，活跃和待命节点通过共享的存储系统来同步元数据信息。就是说活跃的把元数据信息实时放到共享存储中，待命节点自己去拿，从而做到同步。
至于选哪个作为活跃名称节点对外暴露，交给zookeeper就好。
3.2.Haddop federation Haddop federation属于一种架构，是对Hadoop的垂直扩展，用来解决单节点存储上限的问题，如果名称节点是单节点那么内存会很有局限性，毕竟要装入内存的元数据很多。
Hadoop federation将名称节点切分为不同的命名空间（其实就是文件系统路径下的不同的文件夹），一个名称上面有一个或者多个命名空间，不同的名称节点上管理不同的命名空间。
至于客户端怎么访问到自己要的命名空间喃？会在客户端本地提前配置好映射，指定客户端去访问哪些名称节点。
4.yarn yarn是hadoop 2.X开始引入的资源调度、监控框架。
在hadoop 1.X中，Map Reduce干的活儿很杂，既是个资源调度框架，要负责资源调度、任务监控、还是个计算框架，要负责具体的计算。作为资源调度框架来说，hadoop 1.X的设计上不太合理，所以hadoop在2.x的时候借着重构资源调度框架的时候，将资源调度单独拆了出来做成了新的组件——yarn。这样拆之后在hadoop 2.X开始mapreduce就不再负责资源调度，而是一个纯计算框架。
hadoop 1.X的设计上哪里不合理：
全部资源管理、全部job的任务调度、全部job的任务监控都要由jobtracker来负责，压力太大了。就像公司管理一样，所有员工直接对接老板，老板肯定扛不住，分级对接才是正解，老板就能减轻很多压力。每一级对接自己的管理层，管理层再统一对接老板yarn的设计思想就是这种分级管理的思想。
yarn有三大核心组件：
Resource Manager，负责资源管理Application Master，负责任务调度、任务监控NodeManager，在具体节点上负责与前两者通信 Map Reduce 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec0f21b92cbd318949a59bdcf2b5bcc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/188c576f45fd3aad7249bcfcde19ec3f/" rel="bookmark">
			【FL Studio至尊版：音乐制作界的“瑞士军刀”】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​ 导语：在音乐制作领域，有一款软件被誉为“瑞士军刀”，它就是FL Studio。本文将为您揭示FL Studio的四大爆点，带您领略这款软件的独特魅力。
一、FL Studio：音乐制作界的“瑞士军刀”
FL Studio，全称Fruity Loops Studio，自1997年发布以来，凭借其强大的功能、灵活的操作和丰富的音色库，赢得了全球音乐人的喜爱。它被誉为音乐制作界的“瑞士军刀”，成为了许多音乐制作人和爱好者的首选工具。
二、FL Studio四大爆点
1. “一站式”音乐制作
FL Studio拥有丰富的内置插件，包括乐器、效果器、采样器等，涵盖了音乐制作的各个环节。从编曲、录音、混音到母带处理，FL Studio都能为您提供一站式解决方案。
2. 强大的编曲功能
FL Studio的钢琴卷帘窗支持无限音轨和剪辑功能，让音乐创作更加灵活自由。同时，软件内置了丰富的循环库和切片工具，助力您轻松创作出节奏感强烈的音乐作品。
3. 创新的音乐可视化
FL Studio创新性地将音乐可视化引入音乐制作过程。通过音乐的可视化编辑，您可以更加直观地观察和调整音乐结构，激发创作灵感。
4. 完善的插件支持
FL Studio支持第三方VST插件，让您可以轻松拓展音乐创作工具库。同时，软件内置了许多高品质的效果器插件，如压缩、混响、均衡等，满足您对音质的高要求。
三、软件特点
FL Studio凭借其“一站式”音乐制作、强大编曲功能、创新音乐可视化和完善插件支持等四大爆点，成为了音乐制作界的佼佼者。它为音乐创作提供了无限可能，帮助众多音乐制作人实现了梦想。
FL Studio的编曲功能是其核心特点之一，它为用户提供了丰富多样的工具和选项，以便创作出各种风格的音乐。以下是FL Studio编曲功能的详细介绍：
1. **钢琴卷帘窗（Piano Roll）**：
- 这是FL Studio中最为重要的编曲工具之一，它允许用户以图形界面的方式编辑和排列音符。
- 用户可以轻松地调整音符的长度、音高、音量和动态，以及添加弯音（Pitch Bend）和颤音（Vibrato）等表达技巧。
- 钢琴卷帘窗支持多点编辑，用户可以同时选择多个音符进行批量操作，极大地提高了工作效率。
2. **步进音序器（Step Sequencer）**：
- 对于喜欢编程节奏和旋律的用户，FL Studio提供了强大的步进音序器。
- 用户可以通过点击的方式来快速创建节奏模式，这对于制作鼓点和贝斯线特别有用。
- 步进音序器支持多种视图，包括钢琴卷帘窗视图、样式视图和经典视图，满足不同用户的习惯和需求。
3. **通道机架（Channel Rack）**：
- 通道机架是FL Studio中管理乐器和采样插件的地方。
- 用户可以将多个乐器插件放入不同的通道，每个通道都有自己的MIDI控制器和效果器设置，实现灵活的编曲和声音设计。
4. **循环和切片（Loop and Slicing）**：
- FL Studio支持音频文件的循环和自动切片功能，用户可以快速地将采样切成节奏性的切片，并立即在钢琴卷帘窗中使用它们。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/188c576f45fd3aad7249bcfcde19ec3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd284d403f708ffe047e26bb47e21fce/" rel="bookmark">
			WebSpoon9.0（KETTLE的WEB版本）编译 &#43; tomcat/docker部署 &#43; 远程调试教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Kettle简介 Kettle是一款国外开源的ETL工具，纯Java编写，可以在Window、Linux、Unix上运行，绿色无需安装，数据抽取高效稳定
WebSpoon是Kettle的Web版本，由Kettle社区维护，不受Pentaho支持，实现了Kettle的大部分功能
拉取代码 仓库地址：https://github.com/HiromuHota/pentaho-kettle
git clone https://github.com/HiromuHota/pentaho-kettle.git 编译 配置 maven 的环境变量
将 settings.xml 放在你用户目录下 /.m2 中按需修改
settings.xml 内容如下
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"&gt; &lt;!-- This is the recommended settings.xml for development of Hitachi Vantara projects. --&gt; &lt;!-- If your wish to mirror everything through pentaho-public's repo uncomment bellow. Not recommended for external developers. --&gt; &lt;!-- &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;pentaho-public&lt;/id&gt; &lt;url&gt;https://repo.orl.eng.hitachivantara.com/artifactory/pnt-mvn/&lt;/url&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; --&gt; &lt;!-- Don't forget to add setting-security.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd284d403f708ffe047e26bb47e21fce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e45bc330522764e1e935adabdb0ab93/" rel="bookmark">
			MPE中environment.py复盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.__init__
初始化函数参数：
world: 一个包含环境信息和所有智能体的世界对象。reset_callback, reward_callback, observation_callback, info_callback, done_callback: 这些都是回调函数，用于在环境的特定事件发生时执行相应的操作。shared_viewer: 一个布尔值，用于决定是否共享渲染视图。 存储世界对象和智能体列表：
self.world: 存储传入的世界对象。self.agents: 从世界对象中获取所有策略智能体（policy_agents）的列表。 设置智能体数量：
self.n: 设置智能体的数量，等于世界中策略智能体的数量。 设置回调函数：
将传入的回调函数赋值给类属性。 设置环境参数：
self.discrete_action_space: 布尔值，表示动作空间是否为离散的，默认为Trueself.discrete_action_input: 布尔值，表示动作输入是否为离散的（即使动作空间是连续的），默认为Falseself.force_discrete_action: 布尔值，表示是否强制将连续动作离散化。self.shared_reward: 布尔值，表示是否所有智能体共享相同的奖励。 初始化时间和动作/观测空间列表：
self.time: 初始化时间计数器。self.action_space 和 self.observation_space: 初始化动作空间和观测空间的列表。 配置动作和观测空间：
遍历每个智能体，根据智能体的特性和环境参数配置其动作空间和观测空间。离散的情况下就使用spaces.Discrete函数，连续情况下就使用spaces.Box函数。 总动作空间：
如果智能体有多个动作空间，将它们组合成一个总动作空间。如果所有动作空间都是离散的，可以使用 MultiDiscrete 动作空间简化表示。 观测空间：
调用 observation_callback 函数来确定每个智能体的观测空间维度，并创建一个无限边界的盒子空间作为观测空间。 初始化通信动作向量：
将每个智能体的通信动作向量初始化为零。 渲染设置：
根据 self.shared_viewer 的值，初始化渲染视图列表 self.viewers。 重置渲染：
调用 _reset_render 方法来重置渲染设置。 2.step
输入动作：接受一个动作列表 action_n，其中每个元素 action_n[i] 是针对相应智能体 i 的动作。
初始化列表：初始化用于存储每个智能体观测、奖励、完成状态和信息的列表。
设置智能体动作：遍历每个智能体，使用 _set_action 函数为每个智能体设置动作。这个函数根据传入的动作和智能体的动作空间来更新智能体的内部状态。
推进世界状态：调用 self.world.step() 来根据所有智能体的动作推进环境的状态。
记录观测：再次遍历智能体，为每个智能体获取观测、奖励、完成状态和信息。
obs_n：存储每个智能体的观测。reward_n：存储每个智能体获得的奖励。done_n：存储每个智能体的任务完成状态（例如，是否达到终止状态）。info_n：存储每个智能体的额外信息。 计算总奖励：如果环境是合作性的（self.shared_reward 为 True），则将所有智能体获得的奖励相加，然后让每个智能体都获得相同的总奖励。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e45bc330522764e1e935adabdb0ab93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5501557107ae81447243f145297a55a6/" rel="bookmark">
			一款拥有15000&#43;POC漏洞扫描工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1
工具介绍 0x01 免责声明
请勿使用本文中所提供的任何技术信息或代码工具进行非法测试和违法行为。若使用者利用本文中技术信息或代码工具对任何计算机系统造成的任何直接或者间接的后果及损失，均由使用者本人负责。本文所提供的技术信息或代码工具仅供于学习，一切不良后果与文章作者无关。使用者应该遵守法律法规，并尊重他人的合法权益。
0x02 工具介绍
scan4all拥有15000+PoC漏洞扫描，23种应用弱口令爆破，7000+Web指纹，146种协议，90000+规则Port扫描。集成 vscan、nuclei、ksubdomain、subfinder等，充分自动化进行扫描。是一款Fuzz、HW打点、BugBounty神器等工具。
scan4all的流程图如下：
0x03 使用方法
快速开始
scan4all -host &lt;hostname or IP address&gt;scan4all -host 127.0.0.1scan4all -host example.comscan4all -host 127.0.0.1/24 指定端口
scan4all -host 127.0.0.1 -p 3306,8080 自定义输出结果JSON或CSV
scan4all -host 127.0.0.1 -json -o result.jsonscan4all -host 127.0.0.1 -csv -o result.csv 设置线程和线程速率
scan4all -host 127.0.0.1 -c 25 -rate 1000 2
下载地址 https://github.com/hktalent/scan4all
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/006be27e6629316e60a3a30e958eef94/" rel="bookmark">
			一文了解微服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文作者：NGINX
原文链接：一文了解微服务
转载来源：NGINX 中文官网
NGINX 唯一中文官方社区 ，尽在 nginx.org.cn
微服务是一种使用多个小组件构建复杂应用的方法。本文介绍了它的工作原理、优缺点及其可带来的优势。
什么是微服务？ 微服务是一种利用多个小组件（每个组件执行一种功能，例如身份验证、通知或支付处理）构建大型复杂应用的软件架构方法。每个微服务都是软件开发项目中的一个独立单元，具有自己的代码库、基础设施和数据库。微服务协同工作，通过 Web API 或消息队列进行通信，以对传入事件作出响应。
简化的微服务架构
关于微服务的视频 什么是微服务？
NGINX Plus 助力 BuzzFeed 迁移至微服务
点击此处观看详细讲解视频&gt;&gt;
为何采用微服务架构？ 在传统单体架构中，一个应用的所有功能均在单个代码库中实现。这种方法有几个弊端：
随着应用日趋复杂，任何一位开发人员都很难弄清整个代码库。新入职的开发人员也很难上手。一个解决办法是将不同的功能模块分配给不同的开发人员或团队。这样开发人员可以更轻松地掌控自己的代码，但问题是会更难跟踪与其他模块的依赖关系。因此，一个模块的变更很有可能会影响其他模块。
当您需要添加或增强功能时，您必须编译并测试整个应用，以验证该变更是否会破坏模块之间的兼容性。然后，您必须将整个应用作为单个二进制文件进行部署。
而微服务架构则将应用功能划分成多个独立的微型服务（service），有助于简化 CI/CD。微服务开发速度更快且更易于理解和维护。每个服务均可由只专注于该服务的团队独立开发。该团队可以选择最适合微服务的编程语言、开发平台和数据库。微服务通常封装为容器，以进一步简化部署。
微服务具有松散耦合性，这意味着它们不依赖于其他微服务的内部构件。它们之间通过 API 进行通信。只要每个微服务暴露的 API 保持向后兼容，对一个微服务进行更改时，便无需更新其他任何微服务。
简而言之，想要在微服务架构中进行修改的开发人员可以在单个微服务容器中执行这一操作，而在单体架构中操作的开发人员则可能不得不耗费大量的时间来重写整个堆栈。
微服务使用群体 为了快速响应不断变化的业务需求，技术团队纷纷转而采用微服务架构。开发人员正引领这一变革，这在很大程度上是因为更多企业授予了开发人员选择应用和交付工具的权限。2020 年开展的一项 NGINX 用户调查显示，超过一半的受访者在其部分或全部应用中使用微服务。 2022 年，在正弃用单体系统的公司工作的更多 NGINX 用户表示，之所以采用微服务，在一定程度上是因为容器编排所允许的可扩展性。
微服务 101：优缺点 微服务可将传统的单体应用转变为更加灵活、安全且高效的架构，从而帮助您节省大量时间、成本和资源。下面总结了微服务的优缺点，这些优缺点可能影响应用性能和设计。
优点： 开发人员可以自由地独立开发和部署服务，从而提高决策速度。
得益于微服务的小规模和自主性，基于微服务的方法能够缩短开发周期，因为不同的团队可以同时实现不同的服务。团队之间的依赖性通常会减弱甚至消除。
微服务可轻松地部署至容器，有助于减少开销并提高跨不同环境的可移植性。
由于微服务很容易与 CI/CD 工具集成，因此开发人员可实施现代 DevOps 实践，例如自动化 CI/CD 流水线。
轻松扩展应用，按需“调整大小”，因为通常每个服务都弹性十足。
微服务更易于构建、测试和维护。
服务围绕业务功能组织实施。
开发人员可以采用最适合特定服务的技术。
更轻松地隔离故障——如果一个微服务发生故障，其他微服务仍可继续运行。
缺点： 微服务架构会加剧复杂性，因为开发人员必须降低容错率，缩短网络延迟，处理不同的编程语言，并跨多个服务实现负载均衡。
由于微服务具有分布式特性，因此微服务故障排除可能繁琐复杂。
增加应用中的微服务数量会增加集成和管理工作。
处理多个数据库
API 是微服务吗？ 简而言之，不是。API 本身不是微服务。但 API 正越来越多地作为应用内的通信机制集成到微服务架构中。一个微服务的功能暴露为一组 API 端点，其他微服务通过对相应端点进行 API 调用来调用该功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/006be27e6629316e60a3a30e958eef94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6b60a851fe32843e52061cba37ea4a7/" rel="bookmark">
			西储大学数据集学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据集下载地址：CWRU凯斯西储大学轴承数据数据集——附：下载链接_西储大学轴承数据集下载-CSDN博客
最近研究故障诊断，先对使用比较多的西储大学数据集研究。以资料【1】中的内容展开研究。
1、轴承的结构 轴承分为外圈、内圈、保持架和滚珠（这两个一般放一起）。所以故障一般也分为外圈、内圈、滚动体。
2、平台组成 一个1.5KW（2马力）的电动机（图左侧）；一个扭矩传感器/ 译码器（图中间连接处）；一个功率测试计（图右侧）；电子控制器(图中没显示) 按照平台的介绍，应该如下图。
Electric motor——电动机
Dynamometer——功率测试计
Torque transducer/encoder——传感器/译码器
Fan end bearing——风扇端轴承（FE）
Drive end bearing——驱动端轴承（DE）
其中研究的数据都是来自FE和DE测量的。
3、待测轴承 待检测的轴承支撑着电动机的转轴；驱动端轴承为SKF6205 ，采样频率为12Khz和48Khz；风扇端轴承为SKF6203 ，采样频率为12Khz。 介绍了轴承的型号和采样频率。
4、故障设置 轴承的损伤是用电火花加工的单点损伤；SKF轴承用来检测直径为0.1778、0.3556、0.5334毫米的损伤；NTN轴承则是用来检测直径是0.7112、1.016毫米的损伤； 这一部分介绍了故障的采集方法和直径。SKF（Svenska Kullager-Fabriken）是斯凯孚公司（总部所在地:瑞典哥德堡。NTN是日本公司。
5、信号采集 由于外圈损伤的位置是相对固定的，因此损伤点相对于轴承负荷区的不同位置对电动机/轴承系统的振动响应有直接的影响。为了量化这种影响，驱动端和风扇端轴承外圈的损伤点分别放置在3点钟、6点钟、12点钟三个不同位置。电动机风扇端和驱动端的轴承座上方各放置一个加速度传感器用来采集故障轴承的振动加速度信号。振动信号由16 通道数据记录仪采集得到。功率和转速通过扭矩传感器/ 译码器测得。将加工过的故障轴承重新装入测试电机中，分别在0、1、2和3马力的电机负载工况工作条件下记录振动加速度信号数据。利用该实验台获取的正常样本8 个、外圈损伤样本53 个、内圈损伤样本23 个及滚动体损伤样本11 个。 参考资料【2】中选择6点钟的数据。
6、轴承数据格式 数据文件为Matlab格式。每个文件包含风扇和驱动端振动数据，以及电机转速。对于所有文件，在变量名显示下列项目：
DE - drive end accelerometer data 驱动端加速度数据FE - fan end accelerometer data 风扇端加速度数据BA - base accelerometer data 基座加速度数据（正常）time - time series data 时间序列数据RPM- rpm during testing 转每分钟，除以60为旋转频率 下载下来的数据集如下图：
有4个文件夹，12kDE文件夹里面有60个数据，12k FE有45个数据，48k DE有52个数据，NB 有4个数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6b60a851fe32843e52061cba37ea4a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a8dd82fb2782a82881776550cbca312/" rel="bookmark">
			C&#43;&#43;之using
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 using是C++11引入的关键字
1、类型别名 using可以用来为类型创建一个新的名字，方便代码维护。
// 定义类型别名 using data_type = short; // 使用 data_type value = 5; 2、命名空间别名 using可以为非常长的命名空间创建一个别名，方便使用。
namespace very_very_long_namespace { int func() { return 5; } } // 定义命名空间别名 using vln = very_very_long_namespace; // 使用 int value = vln::func(); 3、命名空间导入 使用using关键字可以将命名空间中的单个成员或整个命名空间导入到当前作用域，减少代码的冗余。
using std::string; // 或导入整个命名空间 using namespace std; 4、模板别名 在使用模版的过程中，可以使用using为模板定义一个新的别名，使得模板使用更加简洁。
template&lt;typename T&gt; using Vec = std::vector&lt;T&gt;; // 使用 Vec&lt;int&gt; intVector; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0619527d8de4c6fc6f2c7649e6ee563/" rel="bookmark">
			SpringCloud之SSO单点登录-基于Gateway和OAuth2的跨系统统一认证和鉴权详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单点登录（SSO）是一种身份验证过程，允许用户通过一次登录访问多个系统。本文将深入解析单点登录的原理，并详细介绍如何在Spring Cloud环境中实现单点登录。通过具体的架构图和代码示例，我们将展示SSO的工作机制和优势，帮助开发者更好地理解和应用这一技术。
一、单点登录简介 1、单点登录介绍 单点登录（Single Sign-On，简称SSO）是一种认证机制，允许用户通过一次身份验证后，访问多个相互信任的应用系统。它简化了用户的操作，提高了用户体验，同时也降低了管理多个认证系统的复杂性。在现代分布式系统和微服务架构中，SSO尤为重要，因为它可以减少重复的登录操作，统一用户认证入口，提高系统的安全性和可管理性。
2、单点登录原理 SSO的基本原理是通过共享认证状态来实现对多个系统的访问。其核心步骤包括：
用户认证：用户在SSO认证中心进行登录，认证中心验证用户身份后生成一个Token。Token共享：用户访问其他受信任的应用系统时，携带这个Token。应用系统通过验证Token来确认用户身份。会话管理：SSO系统管理用户会话状态，确保用户在有效期内不需要重复登录。 3、单点登录架构图 二、单点登录实现 在Spring Cloud环境中实现单点登录需要考虑以下几个步骤：
步骤描述1. 建立认证中心创建一个专门的认证服务，负责用户登录和Token生成。可以使用Spring Security和OAuth2来实现这一功能。2. 配置网关服务通过Spring Cloud Gateway或Zuul来实现请求路由和Token验证。3. 应用服务集成将各个应用服务与认证中心集成，确保每个请求都经过Token验证。 1. 建立认证中心 认证中心负责用户认证和Token生成。可以使用Spring Security和OAuth2来实现认证中心。
OAuth2 协议介绍：
OAuth2 协议是一种授权框架，允许第三方应用在用户授权下，访问用户的资源而无需共享用户的凭据，常用于社交媒体登录等场景。
OAuth2 协议一共支持四种不同的授权模式：
授权码模式：大多数第三方平台登录功能都采用这种模式，因其具有较高的安全性。简化模式：简化模式不需要第三方服务器（客户端）的参与，直接在浏览器中向授权服务器申请令牌（token）。如果网站是纯静态页面，可以采用这种方式。密码模式：密码模式要求用户将用户名和密码直接提供给客户端，客户端再使用这些信息向授权服务器申请令牌（token）。这种模式需要用户对客户端有高度的信任，例如客户端应用和服务器提供商是同一家公司。客户端模式：客户端模式是指客户端以自己的名义而非用户的名义向授权服务器申请授权。严格来说，客户端模式并不属于OAuth协议的典型解决方案，但在某些移动端授权服务器上使用这种模式对开发者来说非常方便。 最常用的是授权码模式，也是我们这里使用的模式。
OAuth2 授权码模式示意图：
为了更清晰地展示授权码模式的每个环节，我们可以使用Mermaid将流程分为几个部分。以下是分成四张图分别介绍每个环节的示例代码：
Step 1: 用户请求资源并重定向到授权服务器 Step 2: 用户同意授权并获取授权码 Step 3: 客户端交换授权码获取访问令牌 Step 4: 客户端使用访问令牌访问资源服务器 ① 添加OAuth2依赖 给项目添加OAuth2依赖项：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-oauth2-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-oauth2-resource-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2-jose&lt;/artifactId&gt; &lt;/dependency&gt; ② 配置OAuth2认证服务器 创建并配置OAuth2认证服务器：
@Configuration @EnableAuthorizationServer public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter { @Autowired private AuthenticationManager authenticationManager; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0619527d8de4c6fc6f2c7649e6ee563/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e08104b087a2d7c3536308b064b14d4/" rel="bookmark">
			前端 JS 经典：浏览器中 ESModule 的工作原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：在开发中，我们经常写出如下代码。这就是 ES 模块化。那浏览器是如何运行的，它的运作机制到底是怎么样的呢。
在 index.html 导入 main.js
&lt;script src="./main.js" type="module"&gt;&lt;/script&gt; 在 main.js 中导入 bar.js
import bar from "./bar.js"; 在 bar.js 中导入 foo.js 然后动态导入 async.js
import foo from "./foo.js"; import("./async.js").then((e) =&gt; {}); 首先浏览器使用 ESModule 导入了 main.js，在这 main.js 里面又间接或直接导入了其他的 js。形成了模块化的依赖。
在浏览器导入 main.js 时，会做第一件事，模块化的解析，这不是 js 运行哦！那怎么来做解析呢，首先把这个 url 地址补全，因为现在是相对路径，然后去下载相应模块，拿到这个模块里面的代码，然后继续解析这个模块里面的代码，会拿到这个模块里所有的顶级静态导入语句。那什么是顶级静态导入语句勒，顶级是写在最上面的导入，静态就是，不是写在判断或循环里面的导入。比如 import bar from "./bar.js" 这种。
解析结束后，就会进行下一个阶段，模块的执行。怎么执行呢，回到入口文件，先执行第一行，如果是 import，就会进入到 from 导入的 js 里，又去执行 js 里面的代码，一直循环。执行结束后，会导出一个东西，导出后，浏览器会在内部生成一个映射表，为什么要做映射呢，是为了缓存，将来还有别的模块使用映射表里的模块，就直接从这个表格获取东西交给他了。
然后遇到动态导入语句，动态导入语句是在执行的时候导入，然后解析，得到完整的 url 地址，然后去下载这个 js。继续解析。
这就是浏览器 ESModule 的运行机制。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c96b4735a1a3be6a9324675d7f88b32/" rel="bookmark">
			Java特性之设计模式【备忘录模式】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、备忘录模式 概述
备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象，备忘录模式属于行为型模式
备忘录模式允许在不破坏封装性的前提下，捕获和恢复对象的内部状态
主要解决：
允许捕获并保存一个对象的内部状态，以便在将来可以恢复到该状态，实现撤销和回滚操作
何时使用：
需要实现对象状态的撤销和恢复功能。当需要在对象中实现撤销操作或者恢复到先前状态的功能时，备忘录模式是一种有效的设计模式。它可以让对象保存其内部状态的快照，并在需要时进行恢复，从而实现撤销和恢复的功能 优缺点
优点：
提供状态恢复机制：允许用户方便地回到历史状态封装状态信息：用户不需要关心状态的保存细节 缺点：
资源消耗：如果对象的状态复杂，保存状态可能会占用较多资源 1. 各个角色介绍 1.1 备忘录（Memento） 负责存储原发器对象的内部状态。备忘录可以保持原发器的状态的一部分或全部信息 1.2 原发器（Originator） 创建一个备忘录对象，并且可以使用备忘录对象恢复自身的内部状态。原发器通常会在需要保存状态的时候创建备忘录对象，并在需要恢复状态的时候使用备忘录对象 1.3 负责人（Caretaker） 负责保存备忘录对象，但是不对备忘录对象进行操作或检查。负责人只能将备忘录传递给其他对象 2. UML图 ​ 备忘录模式使用三个类 Memento、Originator 和 CareTaker。Memento 包含了要被恢复的对象的状态。Originator 创建并在 Memento 对象中存储状态。Caretaker 对象负责从 Memento 中恢复对象的状态
3. 具体例子和代码 角色分配
Memento：备忘录
Originator：原发器
Caretaker：负责人
3.1 备忘录实体 Memento package com.vinjcent.prototype.memento; import io.swagger.annotations.ApiModelProperty; import lombok.Data; /** * @author vinjcent * @description 备忘录 * @since 2024/5/16 20:11 */ @Data public class Memento { @ApiModelProperty(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c96b4735a1a3be6a9324675d7f88b32/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<span class="pagination__item pagination__item--current">1/71</span>
	<a class="pagination__item pagination__item--next btn" href="/page/2/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程学习者.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>